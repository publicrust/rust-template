[
  {
    "HookSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSignature": "Internal(Arg arg)",
    "MethodSourseCode": "\n\tprivate static bool Internal(Arg arg)\n\t{\n\t\tif (arg.Invalid)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022IOnServerCommand\u0022, arg);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!arg.HasPermission())\n\t\t{\n\t\t\targ.ReplyWith(\u0022You cannot run this command\u0022);\n\t\t\treturn false;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022ConsoleSystem: \u0022 \u002B arg.cmd.FullName))\n\t\t\t{\n\t\t\t\targ.cmd.Call(arg);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\targ.ReplyWith(\u0022Error: \u0022 \u002B arg.cmd.FullName \u002B \u0022 - \u0022 \u002B ex.Message \u002B \u0022 (\u0022 \u002B ex.Source \u002B \u0022)\u0022);\n\t\t\tDebug.LogException(ex);\n\t\t\treturn false;\n\t\t}\n\t\tif (arg.cmd.Variable \u0026\u0026 arg.cmd.GetOveride != null \u0026\u0026 string.IsNullOrWhiteSpace(arg.Reply))\n\t\t{\n\t\t\tstring @string = arg.cmd.String;\n\t\t\tstring text = (arg.cmd.Variable ? arg.cmd.String : \u0022\u0022);\n\t\t\tif (!arg.Silent)\n\t\t\t{\n\t\t\t\tif (arg.Option.PrintValueOnly)\n\t\t\t\t{\n\t\t\t\t\targ.ReplyWith(@string);\n\t\t\t\t}\n\t\t\t\telse if (text != @string)\n\t\t\t\t{\n\t\t\t\t\targ.ReplyWith($\u0022{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}\u0022);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\targ.ReplyWith($\u0022{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}\u0022);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ConsoleSystem",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "IOnRunCommandLine()",
    "MethodSignature": "UpdateValuesFromCommandLine()",
    "MethodSourseCode": "\n\tpublic static void UpdateValuesFromCommandLine()\n\t{\n\t\tif (Interface.CallHook(\u0022IOnRunCommandLine\u0022) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (KeyValuePair\u003Cstring, string\u003E @switch in Facepunch.CommandLine.GetSwitches())\n\t\t{\n\t\t\tstring text = @switch.Value;\n\t\t\tif (text == \u0022\u0022)\n\t\t\t{\n\t\t\t\ttext = \u00221\u0022;\n\t\t\t}\n\t\t\tstring strCommand = @switch.Key.Substring(1);\n\t\t\tRun(Option.Unrestricted, strCommand, text);\n\t\t}\n\t}\n",
    "ClassName": "ConsoleSystem",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRconMessage(System.Net.IPAddress ipAddress, Oxide.Core.RemoteConsole.RemoteMessage message)",
    "MethodSignature": "IOnRconMessage(IPAddress ipAddress, string command)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnRconMessage\u0022)]\n\tprivate object IOnRconMessage(IPAddress ipAddress, string command)\n\t{\n\t\tif (ipAddress != null \u0026\u0026 !string.IsNullOrEmpty(command))\n\t\t{\n\t\t\tRemoteMessage message = RemoteMessage.GetMessage(command);\n\t\t\tif (string.IsNullOrEmpty(message?.Message))\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnRconMessage\u0022, ipAddress, message) != null)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstring[] array = Oxide.Core.CommandLine.Split(message.Message);\n\t\t\tif (array.Length \u003E= 1)\n\t\t\t{\n\t\t\t\tstring obj = array[0].ToLower();\n\t\t\t\tstring[] obj2 = array.Skip(1).ToArray();\n\t\t\t\tif (Interface.CallHook(\u0022OnRconCommand\u0022, ipAddress, obj, obj2) != null)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnApplicationCommand(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string command, string[] args)",
    "MethodSignature": "TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)",
    "MethodSourseCode": "\n\tprivate void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)\n\t{\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (string.IsNullOrEmpty(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);\n\t\tif (command == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!basePlayer.IsConnected)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer, command, args);\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer.IPlayer, command, args);\n\t\t\treturn;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerCommand\u0022, basePlayer, command, args);\n\t\tobject obj2 = Interface.CallHook(\u0022OnUserCommand\u0022, basePlayer.IPlayer, command, args);\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tif (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args) \u0026\u0026 Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tbasePlayer.IPlayer.Reply(string.Format(lang.GetMessage(\u0022UnknownCommand\u0022, this, basePlayer.IPlayer.Id), command));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tException ex2 = ex;\n\t\t\tstring text2 = string.Empty;\n\t\t\tstring empty = string.Empty;\n\t\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\t\twhile (ex2 != null)\n\t\t\t{\n\t\t\t\tstring text3 = ex2.GetType().Name;\n\t\t\t\ttext2 = (text3 \u002B \u0022: \u0022 \u002B ex2.Message).TrimEnd(\u0027 \u0027, \u0027:\u0027);\n\t\t\t\tstringBuilder.AppendLine(ex2.StackTrace);\n\t\t\t\tif (ex2.InnerException != null)\n\t\t\t\t{\n\t\t\t\t\tstringBuilder.AppendLine(\u0022Rethrow as \u0022 \u002B text3);\n\t\t\t\t}\n\t\t\t\tex2 = ex2.InnerException;\n\t\t\t}\n\t\t\tStackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);\n\t\t\tfor (int i = 0; i \u003C stackTrace.FrameCount; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tMethodBase method = stackTrace.GetFrame(i).GetMethod();\n\t\t\t\tif ((object)method != null \u0026\u0026 (object)method.DeclaringType != null \u0026\u0026 method.DeclaringType.Namespace == \u0022Oxide.Plugins\u0022)\n\t\t\t\t{\n\t\t\t\t\tempty = method.DeclaringType.Name;\n\t\t\t\t}\n\t\t\t}\n\t\t\tInterface.Oxide.LogError(string.Format(\u0022Failed to run command \u0027/{0}\u0027 on plugin \u0027{1}\u0027. ({2}){3}{4}\u0022, command, empty, text2.Replace(Environment.NewLine, \u0022 \u0022), Environment.NewLine, stackTrace));\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnPlayerLanguageChanged(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string val)",
    "MethodSignature": "OnPlayerSetInfo(Connection connection, string key, string val)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerSetInfo\u0022)]\n\tprivate void OnPlayerSetInfo(Connection connection, string key, string val)\n\t{\n\t\tif (!(key == \u0022global.language\u0022))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tlang.SetLanguage(val, connection.userid.ToString());\n\t\tBasePlayer basePlayer = connection.player as BasePlayer;\n\t\tif (basePlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerLanguageChanged\u0022, basePlayer, val);\n\t\t\tif (basePlayer.IPlayer != null)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnPlayerLanguageChanged\u0022, basePlayer.IPlayer, val);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnServerCommand(string argCmdFullName, string[] RustCommandSystemExtractArgs)",
    "MethodSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerCommand\u0022)]\n\tprivate object IOnServerCommand(ConsoleSystem.Arg arg)\n\t{\n\t\tif (arg == null || (arg.Connection != null \u0026\u0026 arg.Player() == null))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (arg.cmd.FullName == \u0022chat.say\u0022 || arg.cmd.FullName == \u0022chat.teamsay\u0022 || arg.cmd.FullName == \u0022chat.localsay\u0022)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnServerCommand\u0022, arg);\n\t\tobject obj2 = Interface.CallHook(\u0022OnServerCommand\u0022, arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnRconCommand(System.Net.IPAddress ipAddress, string obj, string[] obj2)",
    "MethodSignature": "IOnRconMessage(IPAddress ipAddress, string command)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnRconMessage\u0022)]\n\tprivate object IOnRconMessage(IPAddress ipAddress, string command)\n\t{\n\t\tif (ipAddress != null \u0026\u0026 !string.IsNullOrEmpty(command))\n\t\t{\n\t\t\tRemoteMessage message = RemoteMessage.GetMessage(command);\n\t\t\tif (string.IsNullOrEmpty(message?.Message))\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnRconMessage\u0022, ipAddress, message) != null)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstring[] array = Oxide.Core.CommandLine.Split(message.Message);\n\t\t\tif (array.Length \u003E= 1)\n\t\t\t{\n\t\t\t\tstring obj = array[0].ToLower();\n\t\t\t\tstring[] obj2 = array.Skip(1).ToArray();\n\t\t\t\tif (Interface.CallHook(\u0022OnRconCommand\u0022, ipAddress, obj, obj2) != null)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer iPlayer, string reason)",
    "MethodSignature": "OnPlayerDisconnected(BasePlayer basePlayer, string reason)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerDisconnected\u0022)]\n\tprivate void OnPlayerDisconnected(BasePlayer basePlayer, string reason)\n\t{\n\t\tIPlayer iPlayer = basePlayer.IPlayer;\n\t\tif (iPlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnUserDisconnected\u0022, iPlayer, reason);\n\t\t}\n\t\tCovalence.PlayerManager.PlayerDisconnected(basePlayer);\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanUseUI(BasePlayer player, string json)",
    "MethodSignature": "AddUi(BasePlayer player, string json)",
    "MethodSourseCode": "\n\tpublic static bool AddUi(BasePlayer player, string json)\n\t{\n\t\tif (player?.net != null \u0026\u0026 Interface.CallHook(\u0022CanUseUI\u0022, player, json) == null)\n\t\t{\n\t\t\tCommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player(\u0022AddUI\u0022, player.net.connection), json);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "CuiHelper",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnServerInitialized(bool false)",
    "MethodSignature": "OnPluginLoaded(Plugin plugin)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPluginLoaded\u0022)]\n\tprivate void OnPluginLoaded(Plugin plugin)\n\t{\n\t\tif (serverInitialized)\n\t\t{\n\t\t\tplugin.CallHook(\u0022OnServerInitialized\u0022, false);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer player)",
    "MethodSignature": "IOnPlayerConnected(BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerConnected\u0022)]\n\tprivate void IOnPlayerConnected(BasePlayer basePlayer)\n\t{\n\t\tlang.SetLanguage(basePlayer.net.connection.info.GetString(\u0022global.language\u0022, \u0022en\u0022), basePlayer.UserIDString);\n\t\tbasePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);\n\t\tCovalence.PlayerManager.PlayerConnected(basePlayer);\n\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);\n\t\tif (player != null)\n\t\t{\n\t\t\tbasePlayer.IPlayer = player;\n\t\t\tInterface.CallHook(\u0022OnUserConnected\u0022, player);\n\t\t}\n\t\tInterface.Oxide.CallHook(\u0022OnPlayerConnected\u0022, basePlayer);\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "CanUserLogin(string username, string text, string obj)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\n\tprivate object IOnUserApprove(Connection connection)\n\t{\n\t\tstring username = connection.username;\n\t\tstring text = connection.userid.ToString();\n\t\tstring obj = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\n\t\tuint authLevel = connection.authLevel;\n\t\tif (permission.IsLoaded)\n\t\t{\n\t\t\tpermission.UpdateNickname(text, username);\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\n\t\t\t}\n\t\t\tif (authLevel \u003E= 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\n\t\t\t}\n\t\t}\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\n\t\tobject obj2 = Interface.CallHook(\u0022CanClientLogin\u0022, connection);\n\t\tobject obj3 = Interface.CallHook(\u0022CanUserLogin\u0022, username, text, obj);\n\t\tobject obj4 = ((obj2 == null) ? obj3 : obj2);\n\t\tif (obj4 is string || (obj4 is bool \u0026\u0026 !(bool)obj4))\n\t\t{\n\t\t\tConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\n\t\t\treturn true;\n\t\t}\n\t\tobject obj5 = Interface.CallHook(\u0022OnUserApprove\u0022, connection);\n\t\tobject result = Interface.CallHook(\u0022OnUserApproved\u0022, username, text, obj);\n\t\tif (obj5 != null)\n\t\t{\n\t\t\treturn obj5;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string message)",
    "MethodSignature": "IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerChat\u0022)]\n\tprivate object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)\n\t{\n\t\tif (string.IsNullOrEmpty(message) || message.Equals(\u0022text\u0022))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tstring chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);\n\t\tif (chatCommandPrefix != null)\n\t\t{\n\t\t\tTryRunPlayerCommand(basePlayer, message, chatCommandPrefix);\n\t\t\treturn false;\n\t\t}\n\t\tmessage = message.EscapeRichText();\n\t\tif (basePlayer == null || !basePlayer.IsConnected)\n\t\t{\n\t\t\treturn Interface.CallHook(\u0022OnPlayerOfflineChat\u0022, playerId, playerName, message, channel);\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerChat\u0022, basePlayer, message, channel);\n\t\tobject result = Interface.CallHook(\u0022OnUserChat\u0022, basePlayer.IPlayer, message);\n\t\tif (obj != null)\n\t\t{\n\t\t\treturn obj;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnPlayerUnbanned(string player?Name ?? \u0022Unnamed\u0022, ulong steamId, string player?Address ?? \u00220\u0022)",
    "MethodSignature": "OnServerUserRemove(ulong steamId)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnServerUserRemove\u0022)]\n\tprivate void OnServerUserRemove(ulong steamId)\n\t{\n\t\tif (serverInitialized \u0026\u0026 ServerUsers.users.ContainsKey(steamId) \u0026\u0026 ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\tstring text = steamId.ToString();\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\n\t\t\tInterface.CallHook(\u0022OnPlayerUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, steamId, player?.Address ?? \u00220\u0022);\n\t\t\tInterface.CallHook(\u0022OnUserUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, text, player?.Address ?? \u00220\u0022);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnCupboardAssign(BuildingPrivlidge privlidge, ulong userID, BasePlayer player)",
    "MethodSignature": "IOnCupboardAuthorize(ulong userID, BasePlayer player, BuildingPrivlidge privlidge)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnCupboardAuthorize\u0022)]\n\tprivate object IOnCupboardAuthorize(ulong userID, BasePlayer player, BuildingPrivlidge privlidge)\n\t{\n\t\tif (userID == (ulong)player.userID)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnCupboardAuthorize\u0022, privlidge, player) != null)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnCupboardAssign\u0022, privlidge, userID, player) != null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnUserUnbanned(string player?Name ?? \u0022Unnamed\u0022, string text, string player?Address ?? \u00220\u0022)",
    "MethodSignature": "OnServerUserRemove(ulong steamId)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnServerUserRemove\u0022)]\n\tprivate void OnServerUserRemove(ulong steamId)\n\t{\n\t\tif (serverInitialized \u0026\u0026 ServerUsers.users.ContainsKey(steamId) \u0026\u0026 ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\tstring text = steamId.ToString();\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\n\t\t\tInterface.CallHook(\u0022OnPlayerUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, steamId, player?.Address ?? \u00220\u0022);\n\t\t\tInterface.CallHook(\u0022OnUserUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, text, player?.Address ?? \u00220\u0022);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnPlayerConnected(BasePlayer basePlayer)",
    "MethodSignature": "IOnPlayerConnected(BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerConnected\u0022)]\n\tprivate void IOnPlayerConnected(BasePlayer basePlayer)\n\t{\n\t\tlang.SetLanguage(basePlayer.net.connection.info.GetString(\u0022global.language\u0022, \u0022en\u0022), basePlayer.UserIDString);\n\t\tbasePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);\n\t\tCovalence.PlayerManager.PlayerConnected(basePlayer);\n\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);\n\t\tif (player != null)\n\t\t{\n\t\t\tbasePlayer.IPlayer = player;\n\t\t\tInterface.CallHook(\u0022OnUserConnected\u0022, player);\n\t\t}\n\t\tInterface.Oxide.CallHook(\u0022OnPlayerConnected\u0022, basePlayer);\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnUserApproved(string username, string text, string obj)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\n\tprivate object IOnUserApprove(Connection connection)\n\t{\n\t\tstring username = connection.username;\n\t\tstring text = connection.userid.ToString();\n\t\tstring obj = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\n\t\tuint authLevel = connection.authLevel;\n\t\tif (permission.IsLoaded)\n\t\t{\n\t\t\tpermission.UpdateNickname(text, username);\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\n\t\t\t}\n\t\t\tif (authLevel \u003E= 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\n\t\t\t}\n\t\t}\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\n\t\tobject obj2 = Interface.CallHook(\u0022CanClientLogin\u0022, connection);\n\t\tobject obj3 = Interface.CallHook(\u0022CanUserLogin\u0022, username, text, obj);\n\t\tobject obj4 = ((obj2 == null) ? obj3 : obj2);\n\t\tif (obj4 is string || (obj4 is bool \u0026\u0026 !(bool)obj4))\n\t\t{\n\t\t\tConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\n\t\t\treturn true;\n\t\t}\n\t\tobject obj5 = Interface.CallHook(\u0022OnUserApprove\u0022, connection);\n\t\tobject result = Interface.CallHook(\u0022OnUserApproved\u0022, username, text, obj);\n\t\tif (obj5 != null)\n\t\t{\n\t\t\treturn obj5;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnUserBanned(string playerName, string text, string player?Address ?? \u00220\u0022, string reason, long expiry)",
    "MethodSignature": "OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnServerUserSet\u0022)]\n\tprivate void OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)\n\t{\n\t\tif (serverInitialized \u0026\u0026 group == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\tstring text = steamId.ToString();\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\n\t\t\tInterface.CallHook(\u0022OnPlayerBanned\u0022, playerName, steamId, player?.Address ?? \u00220\u0022, reason, expiry);\n\t\t\tInterface.CallHook(\u0022OnUserBanned\u0022, playerName, text, player?.Address ?? \u00220\u0022, reason, expiry);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string command, string[] args)",
    "MethodSignature": "TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)",
    "MethodSourseCode": "\n\tprivate void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)\n\t{\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (string.IsNullOrEmpty(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);\n\t\tif (command == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!basePlayer.IsConnected)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer, command, args);\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer.IPlayer, command, args);\n\t\t\treturn;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerCommand\u0022, basePlayer, command, args);\n\t\tobject obj2 = Interface.CallHook(\u0022OnUserCommand\u0022, basePlayer.IPlayer, command, args);\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tif (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args) \u0026\u0026 Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tbasePlayer.IPlayer.Reply(string.Format(lang.GetMessage(\u0022UnknownCommand\u0022, this, basePlayer.IPlayer.Id), command));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tException ex2 = ex;\n\t\t\tstring text2 = string.Empty;\n\t\t\tstring empty = string.Empty;\n\t\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\t\twhile (ex2 != null)\n\t\t\t{\n\t\t\t\tstring text3 = ex2.GetType().Name;\n\t\t\t\ttext2 = (text3 \u002B \u0022: \u0022 \u002B ex2.Message).TrimEnd(\u0027 \u0027, \u0027:\u0027);\n\t\t\t\tstringBuilder.AppendLine(ex2.StackTrace);\n\t\t\t\tif (ex2.InnerException != null)\n\t\t\t\t{\n\t\t\t\t\tstringBuilder.AppendLine(\u0022Rethrow as \u0022 \u002B text3);\n\t\t\t\t}\n\t\t\t\tex2 = ex2.InnerException;\n\t\t\t}\n\t\t\tStackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);\n\t\t\tfor (int i = 0; i \u003C stackTrace.FrameCount; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tMethodBase method = stackTrace.GetFrame(i).GetMethod();\n\t\t\t\tif ((object)method != null \u0026\u0026 (object)method.DeclaringType != null \u0026\u0026 method.DeclaringType.Namespace == \u0022Oxide.Plugins\u0022)\n\t\t\t\t{\n\t\t\t\t\tempty = method.DeclaringType.Name;\n\t\t\t\t}\n\t\t\t}\n\t\t\tInterface.Oxide.LogError(string.Format(\u0022Failed to run command \u0027/{0}\u0027 on plugin \u0027{1}\u0027. ({2}){3}{4}\u0022, command, empty, text2.Replace(Environment.NewLine, \u0022 \u0022), Environment.NewLine, stackTrace));\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnLoseCondition(object[] array)",
    "MethodSignature": "IOnLoseCondition(Item item, float amount)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnLoseCondition\u0022)]\n\tprivate object IOnLoseCondition(Item item, float amount)\n\t{\n\t\tobject[] array = new object[2] { item, amount };\n\t\tInterface.CallHook(\u0022OnLoseCondition\u0022, array);\n\t\tamount = (float)array[1];\n\t\tfloat condition = item.condition;\n\t\titem.condition -= amount;\n\t\tif (item.condition \u003C= 0f \u0026\u0026 item.condition \u003C condition)\n\t\t{\n\t\t\titem.OnBroken();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)",
    "MethodSignature": "IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnBaseCombatEntityHurt\u0022)]\n\tprivate object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)\n\t{\n\t\tif (!(entity is BasePlayer))\n\t\t{\n\t\t\treturn Interface.CallHook(\u0022OnEntityTakeDamage\u0022, entity, hitInfo);\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerLanguageChanged(BasePlayer basePlayer, string val)",
    "MethodSignature": "OnPlayerSetInfo(Connection connection, string key, string val)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerSetInfo\u0022)]\n\tprivate void OnPlayerSetInfo(Connection connection, string key, string val)\n\t{\n\t\tif (!(key == \u0022global.language\u0022))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tlang.SetLanguage(val, connection.userid.ToString());\n\t\tBasePlayer basePlayer = connection.player as BasePlayer;\n\t\tif (basePlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerLanguageChanged\u0022, basePlayer, val);\n\t\t\tif (basePlayer.IPlayer != null)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnPlayerLanguageChanged\u0022, basePlayer.IPlayer, val);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "CanPickupEntity(BasePlayer basePlayer, BaseEntity entity)",
    "MethodSignature": "ICanPickupEntity(BasePlayer basePlayer, BaseEntity entity)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022ICanPickupEntity\u0022)]\n\tprivate object ICanPickupEntity(BasePlayer basePlayer, BaseEntity entity)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanPickupEntity\u0022, basePlayer, entity);\n\t\tif (!(obj is bool) || (bool)obj)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnServerInitialized(bool serverInitialized)",
    "MethodSignature": "IOnServerInitialized()",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerInitialized\u0022)]\n\tprivate void IOnServerInitialized()\n\t{\n\t\tif (!serverInitialized)\n\t\t{\n\t\t\tAnalytics.Collect();\n\t\t\tif (!Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tInterface.Oxide.LogWarning(\u0022The server is currently listed under Community. Please be aware that Facepunch only allows admin tools (that do not affect gameplay) under the Community section\u0022);\n\t\t\t}\n\t\t\tserverInitialized = true;\n\t\t\tInterface.CallHook(\u0022OnServerInitialized\u0022, serverInitialized);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnMessagePlayer(string text, BasePlayer player, ulong userId)",
    "MethodSignature": "Message(BasePlayer player, string message, string prefix, ulong userId, object[] args)",
    "MethodSourseCode": "\n\tpublic void Message(BasePlayer player, string message, string prefix, ulong userId = 0uL, params object[] args)\n\t{\n\t\tif (!string.IsNullOrEmpty(message))\n\t\t{\n\t\t\tmessage = ((args.Length != 0) ? string.Format(Formatter.ToUnity(message), args) : Formatter.ToUnity(message));\n\t\t\tstring text = ((prefix != null) ? (prefix \u002B \u0022 \u0022 \u002B message) : message);\n\t\t\tif (Interface.CallHook(\u0022OnMessagePlayer\u0022, text, player, userId) == null)\n\t\t\t{\n\t\t\t\tplayer.SendConsoleCommand(\u0022chat.add\u0022, 2, userId, text);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Player",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer iPlayer)",
    "MethodSignature": "OnPlayerRespawned(BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerRespawned\u0022)]\n\tprivate void OnPlayerRespawned(BasePlayer basePlayer)\n\t{\n\t\tIPlayer iPlayer = basePlayer.IPlayer;\n\t\tif (iPlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnUserRespawned\u0022, iPlayer);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string reason)",
    "MethodSignature": "OnPlayerKicked(BasePlayer basePlayer, string reason)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerKicked\u0022)]\n\tprivate void OnPlayerKicked(BasePlayer basePlayer, string reason)\n\t{\n\t\tif (basePlayer.IPlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnUserKicked\u0022, basePlayer.IPlayer, reason);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanClientLogin(Network.Connection connection)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\n\tprivate object IOnUserApprove(Connection connection)\n\t{\n\t\tstring username = connection.username;\n\t\tstring text = connection.userid.ToString();\n\t\tstring obj = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\n\t\tuint authLevel = connection.authLevel;\n\t\tif (permission.IsLoaded)\n\t\t{\n\t\t\tpermission.UpdateNickname(text, username);\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\n\t\t\t}\n\t\t\tif (authLevel \u003E= 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\n\t\t\t}\n\t\t}\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\n\t\tobject obj2 = Interface.CallHook(\u0022CanClientLogin\u0022, connection);\n\t\tobject obj3 = Interface.CallHook(\u0022CanUserLogin\u0022, username, text, obj);\n\t\tobject obj4 = ((obj2 == null) ? obj3 : obj2);\n\t\tif (obj4 is string || (obj4 is bool \u0026\u0026 !(bool)obj4))\n\t\t{\n\t\t\tConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\n\t\t\treturn true;\n\t\t}\n\t\tobject obj5 = Interface.CallHook(\u0022OnUserApprove\u0022, connection);\n\t\tobject result = Interface.CallHook(\u0022OnUserApproved\u0022, username, text, obj);\n\t\tif (obj5 != null)\n\t\t{\n\t\t\treturn obj5;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerCommand\u0022)]\n\tprivate object IOnServerCommand(ConsoleSystem.Arg arg)\n\t{\n\t\tif (arg == null || (arg.Connection != null \u0026\u0026 arg.Player() == null))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (arg.cmd.FullName == \u0022chat.say\u0022 || arg.cmd.FullName == \u0022chat.teamsay\u0022 || arg.cmd.FullName == \u0022chat.localsay\u0022)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnServerCommand\u0022, arg);\n\t\tobject obj2 = Interface.CallHook(\u0022OnServerCommand\u0022, arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnCupboardAuthorize(BuildingPrivlidge privlidge, BasePlayer player)",
    "MethodSignature": "IOnCupboardAuthorize(ulong userID, BasePlayer player, BuildingPrivlidge privlidge)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnCupboardAuthorize\u0022)]\n\tprivate object IOnCupboardAuthorize(ulong userID, BasePlayer player, BuildingPrivlidge privlidge)\n\t{\n\t\tif (userID == (ulong)player.userID)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnCupboardAuthorize\u0022, privlidge, player) != null)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnCupboardAssign\u0022, privlidge, userID, player) != null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer iPlayer)",
    "MethodSignature": "OnPlayerRespawn(BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerRespawn\u0022)]\n\tprivate object OnPlayerRespawn(BasePlayer basePlayer)\n\t{\n\t\tIPlayer iPlayer = basePlayer.IPlayer;\n\t\tif (iPlayer == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn Interface.CallHook(\u0022OnUserRespawn\u0022, iPlayer);\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnUserApprove(Network.Connection connection)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\n\tprivate object IOnUserApprove(Connection connection)\n\t{\n\t\tstring username = connection.username;\n\t\tstring text = connection.userid.ToString();\n\t\tstring obj = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\n\t\tuint authLevel = connection.authLevel;\n\t\tif (permission.IsLoaded)\n\t\t{\n\t\t\tpermission.UpdateNickname(text, username);\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\n\t\t\t}\n\t\t\tif (authLevel \u003E= 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\n\t\t\t}\n\t\t}\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\n\t\tobject obj2 = Interface.CallHook(\u0022CanClientLogin\u0022, connection);\n\t\tobject obj3 = Interface.CallHook(\u0022CanUserLogin\u0022, username, text, obj);\n\t\tobject obj4 = ((obj2 == null) ? obj3 : obj2);\n\t\tif (obj4 is string || (obj4 is bool \u0026\u0026 !(bool)obj4))\n\t\t{\n\t\t\tConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\n\t\t\treturn true;\n\t\t}\n\t\tobject obj5 = Interface.CallHook(\u0022OnUserApprove\u0022, connection);\n\t\tobject result = Interface.CallHook(\u0022OnUserApproved\u0022, username, text, obj);\n\t\tif (obj5 != null)\n\t\t{\n\t\t\treturn obj5;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)",
    "MethodSignature": "IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnEntitySaved\u0022)]\n\tprivate void IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)\n\t{\n\t\tif (serverInitialized \u0026\u0026 saveInfo.forConnection != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnEntitySaved\u0022, baseNetworkable, saveInfo);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerOfflineChat(ulong playerId, string playerName, string message, ConVar.Chat.ChatChannel channel)",
    "MethodSignature": "IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerChat\u0022)]\n\tprivate object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)\n\t{\n\t\tif (string.IsNullOrEmpty(message) || message.Equals(\u0022text\u0022))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tstring chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);\n\t\tif (chatCommandPrefix != null)\n\t\t{\n\t\t\tTryRunPlayerCommand(basePlayer, message, chatCommandPrefix);\n\t\t\treturn false;\n\t\t}\n\t\tmessage = message.EscapeRichText();\n\t\tif (basePlayer == null || !basePlayer.IsConnected)\n\t\t{\n\t\t\treturn Interface.CallHook(\u0022OnPlayerOfflineChat\u0022, playerId, playerName, message, channel);\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerChat\u0022, basePlayer, message, channel);\n\t\tobject result = Interface.CallHook(\u0022OnUserChat\u0022, basePlayer.IPlayer, message);\n\t\tif (obj != null)\n\t\t{\n\t\t\treturn obj;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnServerShutdown()",
    "MethodSignature": "IOnServerShutdown()",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerShutdown\u0022)]\n\tprivate void IOnServerShutdown()\n\t{\n\t\tInterface.Oxide.CallHook(\u0022OnServerShutdown\u0022);\n\t\tInterface.Oxide.OnShutdown();\n\t\tCovalence.PlayerManager.SavePlayerData();\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerCommand(BasePlayer basePlayer, string command, string[] args)",
    "MethodSignature": "TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)",
    "MethodSourseCode": "\n\tprivate void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)\n\t{\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (string.IsNullOrEmpty(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);\n\t\tif (command == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!basePlayer.IsConnected)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer, command, args);\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer.IPlayer, command, args);\n\t\t\treturn;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerCommand\u0022, basePlayer, command, args);\n\t\tobject obj2 = Interface.CallHook(\u0022OnUserCommand\u0022, basePlayer.IPlayer, command, args);\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tif (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args) \u0026\u0026 Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tbasePlayer.IPlayer.Reply(string.Format(lang.GetMessage(\u0022UnknownCommand\u0022, this, basePlayer.IPlayer.Id), command));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tException ex2 = ex;\n\t\t\tstring text2 = string.Empty;\n\t\t\tstring empty = string.Empty;\n\t\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\t\twhile (ex2 != null)\n\t\t\t{\n\t\t\t\tstring text3 = ex2.GetType().Name;\n\t\t\t\ttext2 = (text3 \u002B \u0022: \u0022 \u002B ex2.Message).TrimEnd(\u0027 \u0027, \u0027:\u0027);\n\t\t\t\tstringBuilder.AppendLine(ex2.StackTrace);\n\t\t\t\tif (ex2.InnerException != null)\n\t\t\t\t{\n\t\t\t\t\tstringBuilder.AppendLine(\u0022Rethrow as \u0022 \u002B text3);\n\t\t\t\t}\n\t\t\t\tex2 = ex2.InnerException;\n\t\t\t}\n\t\t\tStackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);\n\t\t\tfor (int i = 0; i \u003C stackTrace.FrameCount; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tMethodBase method = stackTrace.GetFrame(i).GetMethod();\n\t\t\t\tif ((object)method != null \u0026\u0026 (object)method.DeclaringType != null \u0026\u0026 method.DeclaringType.Namespace == \u0022Oxide.Plugins\u0022)\n\t\t\t\t{\n\t\t\t\t\tempty = method.DeclaringType.Name;\n\t\t\t\t}\n\t\t\t}\n\t\t\tInterface.Oxide.LogError(string.Format(\u0022Failed to run command \u0027/{0}\u0027 on plugin \u0027{1}\u0027. ({2}){3}{4}\u0022, command, empty, text2.Replace(Environment.NewLine, \u0022 \u0022), Environment.NewLine, stackTrace));\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnNpcTarget(BaseEntity baseEntity, BaseEntity target)",
    "MethodSignature": "IOnNpcTarget(SenseComponent sense, BaseEntity target)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnNpcTarget\u0022)]\n\tprivate object IOnNpcTarget(SenseComponent sense, BaseEntity target)\n\t{\n\t\tif (!sense || !target)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tBaseEntity baseEntity = sense.baseEntity;\n\t\tif (!baseEntity)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnNpcTarget\u0022, baseEntity, target) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnPlayerChat(BasePlayer basePlayer, string message, ConVar.Chat.ChatChannel channel)",
    "MethodSignature": "IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerChat\u0022)]\n\tprivate object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)\n\t{\n\t\tif (string.IsNullOrEmpty(message) || message.Equals(\u0022text\u0022))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tstring chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);\n\t\tif (chatCommandPrefix != null)\n\t\t{\n\t\t\tTryRunPlayerCommand(basePlayer, message, chatCommandPrefix);\n\t\t\treturn false;\n\t\t}\n\t\tmessage = message.EscapeRichText();\n\t\tif (basePlayer == null || !basePlayer.IsConnected)\n\t\t{\n\t\t\treturn Interface.CallHook(\u0022OnPlayerOfflineChat\u0022, playerId, playerName, message, channel);\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerChat\u0022, basePlayer, message, channel);\n\t\tobject result = Interface.CallHook(\u0022OnUserChat\u0022, basePlayer.IPlayer, message);\n\t\tif (obj != null)\n\t\t{\n\t\t\treturn obj;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnDestroyUI(BasePlayer player, string elem)",
    "MethodSignature": "DestroyUi(BasePlayer player, string elem)",
    "MethodSourseCode": "\n\tpublic static bool DestroyUi(BasePlayer player, string elem)\n\t{\n\t\tif (player?.net != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnDestroyUI\u0022, player, elem);\n\t\t\tCommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player(\u0022DestroyUI\u0022, player.net.connection), elem);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "CuiHelper",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnNpcTarget(BaseNpc npc, BaseEntity target)",
    "MethodSignature": "IOnNpcTarget(BaseNpc npc, BaseEntity target)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnNpcTarget\u0022)]\n\tprivate object IOnNpcTarget(BaseNpc npc, BaseEntity target)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcTarget\u0022, npc, target) != null)\n\t\t{\n\t\t\tnpc.SetFact(BaseNpc.Facts.HasEnemy, 0);\n\t\t\tnpc.SetFact(BaseNpc.Facts.EnemyRange, 3);\n\t\t\tnpc.SetFact(BaseNpc.Facts.AfraidRange, 1);\n\t\t\tnpc.playerTargetDecisionStartTime = 0f;\n\t\t\treturn 0f;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnEntityTakeDamage(BasePlayer basePlayer, HitInfo hitInfo)",
    "MethodSignature": "IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnBasePlayerAttacked\u0022)]\n\tprivate object IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)\n\t{\n\t\tif (!serverInitialized || basePlayer == null || hitInfo == null || basePlayer.IsDead() || isPlayerTakingDamage || basePlayer is NPCPlayer)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnEntityTakeDamage\u0022, basePlayer, hitInfo) != null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tisPlayerTakingDamage = true;\n\t\ttry\n\t\t{\n\t\t\tbasePlayer.OnAttacked(hitInfo);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tisPlayerTakingDamage = false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnPlayerBanned(string playerName, ulong steamId, string player?Address ?? \u00220\u0022, string reason, long expiry)",
    "MethodSignature": "OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnServerUserSet\u0022)]\n\tprivate void OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)\n\t{\n\t\tif (serverInitialized \u0026\u0026 group == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\tstring text = steamId.ToString();\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\n\t\t\tInterface.CallHook(\u0022OnPlayerBanned\u0022, playerName, steamId, player?.Address ?? \u00220\u0022, reason, expiry);\n\t\t\tInterface.CallHook(\u0022OnUserBanned\u0022, playerName, text, player?.Address ?? \u00220\u0022, reason, expiry);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnApplicationCommand(BasePlayer basePlayer, string command, string[] args)",
    "MethodSignature": "TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)",
    "MethodSourseCode": "\n\tprivate void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)\n\t{\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (string.IsNullOrEmpty(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);\n\t\tif (command == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!basePlayer.IsConnected)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer, command, args);\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer.IPlayer, command, args);\n\t\t\treturn;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerCommand\u0022, basePlayer, command, args);\n\t\tobject obj2 = Interface.CallHook(\u0022OnUserCommand\u0022, basePlayer.IPlayer, command, args);\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tif (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args) \u0026\u0026 Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tbasePlayer.IPlayer.Reply(string.Format(lang.GetMessage(\u0022UnknownCommand\u0022, this, basePlayer.IPlayer.Id), command));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tException ex2 = ex;\n\t\t\tstring text2 = string.Empty;\n\t\t\tstring empty = string.Empty;\n\t\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\t\twhile (ex2 != null)\n\t\t\t{\n\t\t\t\tstring text3 = ex2.GetType().Name;\n\t\t\t\ttext2 = (text3 \u002B \u0022: \u0022 \u002B ex2.Message).TrimEnd(\u0027 \u0027, \u0027:\u0027);\n\t\t\t\tstringBuilder.AppendLine(ex2.StackTrace);\n\t\t\t\tif (ex2.InnerException != null)\n\t\t\t\t{\n\t\t\t\t\tstringBuilder.AppendLine(\u0022Rethrow as \u0022 \u002B text3);\n\t\t\t\t}\n\t\t\t\tex2 = ex2.InnerException;\n\t\t\t}\n\t\t\tStackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);\n\t\t\tfor (int i = 0; i \u003C stackTrace.FrameCount; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tMethodBase method = stackTrace.GetFrame(i).GetMethod();\n\t\t\t\tif ((object)method != null \u0026\u0026 (object)method.DeclaringType != null \u0026\u0026 method.DeclaringType.Namespace == \u0022Oxide.Plugins\u0022)\n\t\t\t\t{\n\t\t\t\t\tempty = method.DeclaringType.Name;\n\t\t\t\t}\n\t\t\t}\n\t\t\tInterface.Oxide.LogError(string.Format(\u0022Failed to run command \u0027/{0}\u0027 on plugin \u0027{1}\u0027. ({2}){3}{4}\u0022, command, empty, text2.Replace(Environment.NewLine, \u0022 \u0022), Environment.NewLine, stackTrace));\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnPlayerBanned(Network.Connection connection, string status)",
    "MethodSignature": "IOnPlayerBanned(Connection connection, AuthResponse status)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerBanned\u0022)]\n\tprivate void IOnPlayerBanned(Connection connection, AuthResponse status)\n\t{\n\t\tInterface.CallHook(\u0022OnPlayerBanned\u0022, connection, status.ToString());\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "Loaded()",
    "MethodSignature": "HandleAddedToManager(PluginManager manager)",
    "MethodSourseCode": "\n\tpublic override void HandleAddedToManager(PluginManager manager)\n\t{\n\t\tbase.HandleAddedToManager(manager);\n\t\tif (base.Filename != null)\n\t\t{\n\t\t\tWatcher.AddMapping(base.Name);\n\t\t}\n\t\tbase.Manager.OnPluginAdded \u002B= OnPluginLoaded;\n\t\tbase.Manager.OnPluginRemoved \u002B= OnPluginUnloaded;\n\t\tforeach (KeyValuePair\u003Cstring, MemberInfo\u003E pluginReferenceMember in pluginReferenceMembers)\n\t\t{\n\t\t\tif (pluginReferenceMember.Value.MemberType == MemberTypes.Property)\n\t\t\t{\n\t\t\t\t((PropertyInfo)pluginReferenceMember.Value).SetValue(this, manager.GetPlugin(pluginReferenceMember.Key), null);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t((FieldInfo)pluginReferenceMember.Value).SetValue(this, manager.GetPlugin(pluginReferenceMember.Key));\n\t\t\t}\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tOnCallHook(\u0022Loaded\u0022, null);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tInterface.Oxide.LogException($\u0022Failed to initialize plugin \u0027{base.Name} v{base.Version}\u0027\u0022, ex);\n\t\t\tbase.Loader.PluginErrors[base.Name] = ex.Message;\n\t\t}\n\t}\n",
    "ClassName": "CSharpPlugin",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnFrame(object[] args)",
    "MethodSignature": "OnFrame(float delta)",
    "MethodSourseCode": "\n\tprivate void OnFrame(float delta)\n\t{\n\t\tobject[] args = new object[1] { delta };\n\t\tforeach (KeyValuePair\u003Cstring, Plugin\u003E loadedPlugin in loader.LoadedPlugins)\n\t\t{\n\t\t\tif (loadedPlugin.Value is CSharpPlugin { HookedOnFrame: not false } cSharpPlugin)\n\t\t\t{\n\t\t\t\tcSharpPlugin.CallHook(\u0022OnFrame\u0022, args);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CSharpExtension",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "Unload()",
    "MethodSignature": "HandleRemovedFromManager(PluginManager manager)",
    "MethodSourseCode": "\n\tpublic override void HandleRemovedFromManager(PluginManager manager)\n\t{\n\t\tif (base.IsLoaded)\n\t\t{\n\t\t\tCallHook(\u0022Unload\u0022, null);\n\t\t}\n\t\tWatcher.RemoveMapping(base.Name);\n\t\tbase.Manager.OnPluginAdded -= OnPluginLoaded;\n\t\tbase.Manager.OnPluginRemoved -= OnPluginUnloaded;\n\t\tforeach (KeyValuePair\u003Cstring, MemberInfo\u003E pluginReferenceMember in pluginReferenceMembers)\n\t\t{\n\t\t\tif (pluginReferenceMember.Value.MemberType == MemberTypes.Property)\n\t\t\t{\n\t\t\t\t((PropertyInfo)pluginReferenceMember.Value).SetValue(this, null, null);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t((FieldInfo)pluginReferenceMember.Value).SetValue(this, null);\n\t\t\t}\n\t\t}\n\t\tbase.HandleRemovedFromManager(manager);\n\t}\n",
    "ClassName": "CSharpPlugin",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnClientDisconnected(Network.Connection cn, string strReason)",
    "MethodSignature": "OnDisconnected(string strReason, Connection cn)",
    "MethodSourseCode": "\n\tprotected void OnDisconnected(string strReason, Connection cn)\n\t{\n\t\tif (cn != null)\n\t\t{\n\t\t\tRecordDisconnection(cn);\n\t\t\tcn.connected = false;\n\t\t\tcn.active = false;\n\t\t\tif (callbackHandler != null)\n\t\t\t{\n\t\t\t\tcallbackHandler.OnDisconnected(strReason, cn);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnClientDisconnected\u0022, cn, strReason);\n\t\t\tRemoveConnection(cn);\n\t\t}\n\t}\n",
    "ClassName": "Server",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnNetworkSubscriptionsUpdate(Network.Networkable network.Networkable, System.Collections.Generic.List\u003CNetwork.Visibility.Group\u003E obj)",
    "MethodSignature": "UpdateHighPrioritySubscriptions()",
    "MethodSourseCode": "\n\tpublic bool UpdateHighPrioritySubscriptions()\n\t{\n\t\tif (subscriber == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022UpdateHighPrioritySubscriptions\u0022))\n\t\t{\n\t\t\tList\u003CGroup\u003E obj = Pool.Get\u003CList\u003CGroup\u003E\u003E();\n\t\t\tListHashSet\u003CGroup\u003E obj2 = Pool.Get\u003CListHashSet\u003CGroup\u003E\u003E();\n\t\t\tsv.visibility.GetVisibleFromNear(this.group, obj2);\n\t\t\tAddVisibleFromNear(secondaryGroup, obj2);\n\t\t\tListHashSet\u003CGroup\u003E.Compare(subscriber.subscribed, obj2, obj, null, null);\n\t\t\tif (Interface.CallHook(\u0022OnNetworkSubscriptionsUpdate\u0022, this, obj, null) == null)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tGroup group = obj[i];\n\t\t\t\t\tsubscriber.Subscribe(group);\n\t\t\t\t\tif (handler != null)\n\t\t\t\t\t{\n\t\t\t\t\t\thandler.OnNetworkGroupEnter(group);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPool.FreeUnmanaged(ref obj);\n\t\t\tPool.FreeUnmanaged(ref obj2);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Networkable",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnNetworkSubscriptionsUpdate(Network.Networkable network.Networkable, System.Collections.Generic.List\u003CNetwork.Visibility.Group\u003E obj, System.Collections.Generic.List\u003CNetwork.Visibility.Group\u003E obj2)",
    "MethodSignature": "UpdateSubscriptions(int removeLimit, int addLimit)",
    "MethodSourseCode": "\n\tpublic bool UpdateSubscriptions(int removeLimit, int addLimit)\n\t{\n\t\tif (!updateSubscriptions)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (subscriber == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022UpdateSubscriptions\u0022))\n\t\t{\n\t\t\tupdateSubscriptions = false;\n\t\t\tList\u003CGroup\u003E obj = Pool.Get\u003CList\u003CGroup\u003E\u003E();\n\t\t\tList\u003CGroup\u003E obj2 = Pool.Get\u003CList\u003CGroup\u003E\u003E();\n\t\t\tListHashSet\u003CGroup\u003E obj3 = Pool.Get\u003CListHashSet\u003CGroup\u003E\u003E();\n\t\t\tsv.visibility.GetVisibleFromFar(this.group, obj3);\n\t\t\tAddVisibleFromNear(secondaryGroup, obj3);\n\t\t\tListHashSet\u003CGroup\u003E.Compare(subscriber.subscribed, obj3, obj, obj2, null);\n\t\t\tif (Interface.CallHook(\u0022OnNetworkSubscriptionsUpdate\u0022, this, obj, obj2) == null)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C obj2.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tGroup group = obj2[i];\n\t\t\t\t\tif (removeLimit \u003E 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsubscriber.Unsubscribe(group);\n\t\t\t\t\t\tif (handler != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thandler.OnNetworkGroupLeave(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveLimit -= group.networkables.Count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tupdateSubscriptions = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j \u003C obj.Count; j\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tGroup group2 = obj[j];\n\t\t\t\t\tif (addLimit \u003E 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsubscriber.Subscribe(group2);\n\t\t\t\t\t\tif (handler != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thandler.OnNetworkGroupEnter(group2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddLimit -= group2.networkables.Count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tupdateSubscriptions = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPool.FreeUnmanaged(ref obj);\n\t\t\tPool.FreeUnmanaged(ref obj2);\n\t\t\tPool.FreeUnmanaged(ref obj3);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Networkable",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnClanMemberAdded(long clanId, ulong steamId)",
    "MethodSignature": "AcceptInvite(long clanId, ulong steamId)",
    "MethodSourseCode": "\n\tpublic bool AcceptInvite(long clanId, ulong steamId)\n\t{\n\t\tBeginTransaction();\n\t\ttry\n\t\t{\n\t\t\tif (DeleteInvite(clanId, steamId) \u0026\u0026 CreateMember(clanId, steamId))\n\t\t\t{\n\t\t\t\tCommit();\n\t\t\t\tInterface.CallHook(\u0022OnClanMemberAdded\u0022, clanId, steamId);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tRollback();\n\t\t\treturn false;\n\t\t}\n\t\tcatch\n\t\t{\n\t\t\tRollback();\n\t\t\tthrow;\n\t\t}\n\t}\n",
    "ClassName": "LocalClanDatabase",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnSwitchToggled(ElectricSwitch electricSwitch, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_Switch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_Switch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool @switch = msg.read.Bool();\n\t\t\tSetSwitch(@switch);\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "ElectricSwitch",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnTechTreeNodeUnlocked(Workbench workbench, TechTreeData.NodeInstance byID, BasePlayer player)",
    "MethodSignature": "RPC_TechTreeUnlock(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_TechTreeUnlock(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint id = msg.read.Int32();\n\t\tint level = msg.read.Int32();\n\t\tTechTreeData techTreeForLevel = GetTechTreeForLevel(level);\n\t\tif (techTreeForLevel == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tTechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);\n\t\tif (byID == null)\n\t\t{\n\t\t\tDebug.Log(\u0022Node for unlock not found :\u0022 \u002B id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!techTreeForLevel.PlayerCanUnlock(player, byID))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (byID.IsGroup())\n\t\t\t{\n\t\t\t\tforeach (int output in byID.outputs)\n\t\t\t\t{\n\t\t\t\t\tTechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);\n\t\t\t\t\tif (byID2 != null \u0026\u0026 byID2.itemDef != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayer.blueprints.Unlock(byID2.itemDef);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, \u0022techtree\u0022, 0, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.Log(\u0022Player unlocked group :\u0022 \u002B byID.groupName);\n\t\t\t}\n\t\t\telse if (byID.itemDef != null \u0026\u0026 Interface.CallHook(\u0022OnTechTreeNodeUnlock\u0022, this, byID, player) == null)\n\t\t\t{\n\t\t\t\tint tax;\n\t\t\t\tint num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);\n\t\t\t\tint itemid = ItemManager.FindItemDefinition(\u0022scrap\u0022).itemid;\n\t\t\t\tif (player.inventory.GetAmount(itemid) \u003E= num \u002B tax)\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.Take(null, itemid, num \u002B tax);\n\t\t\t\t\tplayer.blueprints.Unlock(byID.itemDef);\n\t\t\t\t\tInterface.CallHook(\u0022OnTechTreeNodeUnlocked\u0022, this, byID, player);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, \u0022techtree\u0022, num \u002B tax, this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 46
  },
  {
    "HookSignature": "OnPlayerDropActiveItem(BasePlayer player, Item activeItem)",
    "MethodSignature": "DropActive(Vector3 position, Vector3 velocity)",
    "MethodSourseCode": "\n\tpublic void DropActive(Vector3 position, Vector3 velocity)\n\t{\n\t\tif (player.GetActiveShield(out var foundShield))\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnPlayerActiveShieldDrop\u0022, player, foundShield) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDroppedItem droppedItem = foundShield.GetItem().Drop(position, velocity) as DroppedItem;\n\t\t\tif (droppedItem != null)\n\t\t\t{\n\t\t\t\tdroppedItem.DropReason = DroppedItem.DropReasonEnum.Death;\n\t\t\t\tdroppedItem.DroppedBy = player.userID;\n\t\t\t\tdroppedItem.DroppedTime = DateTime.UtcNow;\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(player, droppedItem, DroppedItem.DropReasonEnum.Death);\n\t\t\t}\n\t\t}\n\t\tItem activeItem = player.GetActiveItem();\n\t\tif (activeItem == null || Interface.CallHook(\u0022OnPlayerDropActiveItem\u0022, player, activeItem) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022PlayerBelt.DropActive\u0022))\n\t\t{\n\t\t\tDroppedItem droppedItem2 = activeItem.Drop(position, velocity) as DroppedItem;\n\t\t\tif (droppedItem2 != null)\n\t\t\t{\n\t\t\t\tdroppedItem2.DropReason = DroppedItem.DropReasonEnum.Death;\n\t\t\t\tdroppedItem2.DroppedBy = player.userID;\n\t\t\t\tdroppedItem2.DroppedTime = DateTime.UtcNow;\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(player, droppedItem2, DroppedItem.DropReasonEnum.Death);\n\t\t\t}\n\t\t\tplayer.svActiveItemID = default(ItemId);\n\t\t\tplayer.SendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "PlayerBelt",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnTurretIdentifierSet(AutoTurret autoTurret, BasePlayer msgPlayer, string text2)",
    "MethodSignature": "Server_SetID(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void Server_SetID(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || !CanChangeID(msg.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (string.IsNullOrEmpty(text) || ComputerStation.IsValidIdentifier(text))\n\t\t{\n\t\t\tstring text2 = msg.read.String();\n\t\t\tif (ComputerStation.IsValidIdentifier(text2) \u0026\u0026 text == GetIdentifier() \u0026\u0026 Interface.CallHook(\u0022OnTurretIdentifierSet\u0022, this, msg.player, text2) == null)\n\t\t\t{\n\t\t\t\tDebug.Log(\u0022SetID success!\u0022);\n\t\t\t\tUpdateIdentifier(text2);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnCrateLaptopAttack(HackableLockedCrate hackableLockedCrate, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnAttacked(HitInfo info)\n\t{\n\t\tif (base.isServer)\n\t\t{\n\t\t\tif (StringPool.Get(info.HitBone) == \u0022laptopcollision\u0022)\n\t\t\t{\n\t\t\t\tif (Interface.CallHook(\u0022OnCrateLaptopAttack\u0022, this, info) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tEffect.server.Run(shockEffect.resourcePath, this, info.HitBone, info.HitPositionLocal, Vector3.up);\n\t\t\t\thackSeconds -= 8f * (info.damageTypes.Total() / 50f);\n\t\t\t\tif (hackSeconds \u003C 0f)\n\t\t\t\t{\n\t\t\t\t\thackSeconds = 0f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRefreshDecay();\n\t\t}\n\t\tbase.OnAttacked(info);\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnRidableAnimalClaimed(RidableHorse ridableHorse, BasePlayer player)",
    "MethodSignature": "SERVER_Claim(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void SERVER_Claim(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 IsForSale)\n\t\t{\n\t\t\tint tokenItemID = msg.read.Int32();\n\t\t\tItem purchaseToken = GetPurchaseToken(player, tokenItemID);\n\t\t\tif (purchaseToken != null \u0026\u0026 Interface.CallHook(\u0022OnRidableAnimalClaim\u0022, this, player, purchaseToken) == null \u0026\u0026 ItemIsSaddle(purchaseToken))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved2, b: false);\n\t\t\t\tOnClaimedWithToken(purchaseToken);\n\t\t\t\tpurchaseToken.UseItem();\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);\n\t\t\t\tAttemptMount(player, doMountChecks: false);\n\t\t\t\tInterface.CallHook(\u0022OnRidableAnimalClaimed\u0022, this, player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RidableHorse",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnWorldProjectileCreate(HitInfo info, Item item)",
    "MethodSignature": "CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)",
    "MethodSourseCode": "\n\tprotected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)\n\t{\n\t\tif (Interface.CallHook(\u0022CanCreateWorldProjectile\u0022, info, itemDef) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 projectileVelocity = info.ProjectileVelocity;\n\t\tItem item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));\n\t\tif (Interface.CallHook(\u0022OnWorldProjectileCreate\u0022, info, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = null;\n\t\tif (!info.DidHit)\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\treturn;\n\t\t}\n\t\tif (projectilePrefab.breakProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.breakProbability)\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\treturn;\n\t\t}\n\t\tif (projectilePrefab.conditionLoss \u003E 0f)\n\t\t{\n\t\t\titem.LoseCondition(projectilePrefab.conditionLoss * 100f);\n\t\t\tif (item.isBroken)\n\t\t\t{\n\t\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (projectilePrefab.stickProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.stickProbability)\n\t\t{\n\t\t\tbaseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));\n\t\t\tDroppedItem droppedItem = baseEntity as DroppedItem;\n\t\t\tif (droppedItem != null)\n\t\t\t{\n\t\t\t\tdroppedItem.StickIn();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbaseEntity.GetComponent\u003CRigidbody\u003E().isKinematic = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tRigidbody component = baseEntity.GetComponent\u003CRigidbody\u003E();\n\t\t\tcomponent.AddForce(projectileVelocity.normalized * 200f);\n\t\t\tcomponent.WakeUp();\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnEventTrigger(TriggeredEventPrefab triggeredEventPrefab)",
    "MethodSignature": "RunEvent()",
    "MethodSourseCode": "\n\tpublic override void RunEvent()\n\t{\n\t\tif (Interface.CallHook(\u0022OnEventTrigger\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDebug.Log(\u0022[event] \u0022 \u002B targetPrefab.resourcePath);\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);\n\t\tif (!baseEntity)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbaseEntity.SendMessage(\u0022TriggeredEventSpawn\u0022, SendMessageOptions.DontRequireReceiver);\n\t\tbaseEntity.Spawn();\n\t\tspawnedEntity = baseEntity;\n\t\tif (!shouldBroadcastSpawn)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\n\t\t{\n\t\t\tif ((bool)activePlayer \u0026\u0026 activePlayer.IsConnected \u0026\u0026 !activePlayer.IsInTutorial)\n\t\t\t{\n\t\t\t\tactivePlayer.ShowToast(GameTip.Styles.Server_Event, spawnPhrase, false);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "TriggeredEventPrefab",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, LootableCorpse lootableCorpse)",
    "MethodSignature": "RPC_LootCorpse(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tprivate void RPC_LootCorpse(RPCMessage rpc)\n\t{\n\t\tBasePlayer player = rpc.player;\n\t\tif (!player || !player.CanInteract() || !CanLoot() || containers == null || Interface.CallHook(\u0022CanLootEntity\u0022, player, this) != null || !player.inventory.loot.StartLootingEntity(this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetFlag(Flags.Open, b: true);\n\t\tfor (int i = 0; i \u003C containers.Length; i\u002B\u002B)\n\t\t{\n\t\t\tItemContainer itemContainer = containers[i];\n\t\t\tif (CanLootContainer(itemContainer, i))\n\t\t\t{\n\t\t\t\tplayer.inventory.loot.AddContainer(itemContainer);\n\t\t\t}\n\t\t}\n\t\tplayer.inventory.loot.SendImmediate();\n\t\tplayer.RadioactiveLootCheck(player.inventory.loot.containers);\n\t\tClientRPC(RpcTarget.Player(\u0022RPC_ClientLootCorpse\u0022, player));\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "LootableCorpse",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnFuelAmountCheck(EntityFuelSystem entityFuelSystem, Item fuelItem)",
    "MethodSignature": "GetFuelAmount()",
    "MethodSourseCode": "\n\tpublic int GetFuelAmount()\n\t{\n\t\tItem fuelItem = GetFuelItem();\n\t\tobject obj = Interface.CallHook(\u0022OnFuelAmountCheck\u0022, this, fuelItem);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tif (fuelItem == null || fuelItem.amount \u003C 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn fuelItem.amount;\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnResearchCostDetermine(ItemDefinition info)",
    "MethodSignature": "ScrapForResearch(ItemDefinition info)",
    "MethodSourseCode": "\n\tpublic static int ScrapForResearch(ItemDefinition info)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnResearchCostDetermine\u0022, info);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tif (info.isRedirectOf != null)\n\t\t{\n\t\t\treturn ScrapForResearch(info.isRedirectOf);\n\t\t}\n\t\tint result = 0;\n\t\tif (info.rarity == Rarity.Common)\n\t\t{\n\t\t\tresult = 20;\n\t\t}\n\t\tif (info.rarity == Rarity.Uncommon)\n\t\t{\n\t\t\tresult = 75;\n\t\t}\n\t\tif (info.rarity == Rarity.Rare)\n\t\t{\n\t\t\tresult = 125;\n\t\t}\n\t\tif (info.rarity == Rarity.VeryRare || info.rarity == Rarity.None)\n\t\t{\n\t\t\tresult = 500;\n\t\t}\n\t\tItemBlueprint itemBlueprint = ItemManager.FindBlueprint(info);\n\t\tif (itemBlueprint != null \u0026\u0026 itemBlueprint.defaultBlueprint)\n\t\t{\n\t\t\treturn ConVar.Server.defaultBlueprintResearchCost;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnOvenCooked(BaseOven baseOven, Item item, BaseEntity slot)",
    "MethodSignature": "Cook()",
    "MethodSourseCode": "\n\tpublic void Cook()\n\t{\n\t\tif (HasFlag(Flags.Reserved8))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item = FindBurnable();\n\t\tif (Interface.CallHook(\u0022OnOvenCook\u0022, this, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (item == null \u0026\u0026 !CanRunWithNoFuel)\n\t\t{\n\t\t\tStopCooking();\n\t\t\treturn;\n\t\t}\n\t\tforeach (Item item2 in base.inventory.itemList)\n\t\t{\n\t\t\tif (item2.position \u003E= _inputSlotIndex \u0026\u0026 item2.position \u003C _inputSlotIndex \u002B inputSlots \u0026\u0026 !item2.HasFlag(Item.Flag.Cooking))\n\t\t\t{\n\t\t\t\titem2.SetFlag(Item.Flag.Cooking, b: true);\n\t\t\t\titem2.MarkDirty();\n\t\t\t}\n\t\t}\n\t\tIncreaseCookTime(0.5f * GetSmeltingSpeed());\n\t\tBaseEntity slot = GetSlot(Slot.FireMod);\n\t\tif ((bool)slot)\n\t\t{\n\t\t\tslot.SendMessage(\u0022Cook\u0022, 0.5f, SendMessageOptions.DontRequireReceiver);\n\t\t}\n\t\tif (item != null)\n\t\t{\n\t\t\tItemModBurnable itemModBurnable = item.info.ItemModBurnable;\n\t\t\titem.fuel -= 0.5f * (cookingTemperature / 200f);\n\t\t\tif (!item.HasFlag(Item.Flag.OnFire))\n\t\t\t{\n\t\t\t\titem.SetFlag(Item.Flag.OnFire, b: true);\n\t\t\t\titem.MarkDirty();\n\t\t\t}\n\t\t\tif (item.fuel \u003C= 0f)\n\t\t\t{\n\t\t\t\tConsumeFuel(item, itemModBurnable);\n\t\t\t}\n\t\t}\n\t\tOnCooked();\n\t\tInterface.CallHook(\u0022OnOvenCooked\u0022, this, item, slot);\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 46
  },
  {
    "HookSignature": "CanHideStash(BasePlayer rpcPlayer, StashContainer stashContainer)",
    "MethodSignature": "RPC_HideStash(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_HideStash(RPCMessage rpc)\n\t{\n\t\tif (Interface.CallHook(\u0022CanHideStash\u0022, rpc.player, this) == null)\n\t\t{\n\t\t\tFacepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);\n\t\t\tSetHidden(isHidden: true);\n\t\t\tInterface.CallHook(\u0022OnStashHidden\u0022, this, rpc.player);\n\t\t}\n\t}\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnRemoveDying(GrowableEntity growableEntity, BasePlayer receiver)",
    "MethodSignature": "RemoveDying(BasePlayer receiver)",
    "MethodSourseCode": "\n\tpublic void RemoveDying(BasePlayer receiver)\n\t{\n\t\tif (State == PlantProperties.State.Dying \u0026\u0026 !(Properties.removeDyingItem == null) \u0026\u0026 Interface.CallHook(\u0022OnRemoveDying\u0022, this, receiver) == null)\n\t\t{\n\t\t\tif (Properties.removeDyingEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(Properties.removeDyingEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tItem item = ItemManager.Create(Properties.removeDyingItem, 1, 0uL);\n\t\t\tif (receiver != null)\n\t\t\t{\n\t\t\t\treceiver.GiveItem(item, GiveItemReason.PickedUp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 0.5f, Vector3.up * 1f);\n\t\t\t}\n\t\t\tTellPlanter();\n\t\t\tDie();\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerViolation(BasePlayer ply, AntiHackType type, float amount, UnityEngine.GameObject gameObject)",
    "MethodSignature": "AddViolation(BasePlayer ply, AntiHackType type, float amount, GameObject gameObject)",
    "MethodSourseCode": "\n\tpublic static void AddViolation(BasePlayer ply, AntiHackType type, float amount, GameObject gameObject = null)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerViolation\u0022, ply, type, amount, gameObject) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022AntiHack.AddViolation\u0022))\n\t\t{\n\t\t\tply.lastViolationType = type;\n\t\t\tply.lastViolationTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\tply.violationLevel \u002B= amount;\n\t\t\tif (type == AntiHackType.NoClip || type == AntiHackType.FlyHack || type == AntiHackType.SpeedHack || type == AntiHackType.InsideGeometry || type == AntiHackType.InsideTerrain || type == AntiHackType.Ticks)\n\t\t\t{\n\t\t\t\tply.lastMovementViolationTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t}\n\t\t\tif ((ConVar.AntiHack.debuglevel \u003E= 2 \u0026\u0026 amount \u003E 0f) || (ConVar.AntiHack.debuglevel \u003E= 3 \u0026\u0026 type != AntiHackType.NoClip) || ConVar.AntiHack.debuglevel \u003E= 4)\n\t\t\t{\n\t\t\t\tstring text = \u0022Added violation of \u0022 \u002B amount \u002B \u0022 in frame \u0022 \u002B UnityEngine.Time.frameCount \u002B \u0022 (now has \u0022 \u002B ply.violationLevel \u002B \u0022)\u0022;\n\t\t\t\tif (gameObject != null)\n\t\t\t\t{\n\t\t\t\t\ttext = text \u002B \u0022 \u0022 \u002B gameObject.name;\n\t\t\t\t\tBaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);\n\t\t\t\t\tif (baseEntity != null)\n\t\t\t\t\t{\n\t\t\t\t\t\ttext = text \u002B \u0022 (entity: \u0022 \u002B baseEntity.ShortPrefabName \u002B \u0022)\u0022;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tLogToConsole(ply, type, text);\n\t\t\t}\n\t\t\tEnforceViolations(ply);\n\t\t}\n\t}\n",
    "ClassName": "AntiHack",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanNetworkTo(BaseNetworkable baseNetworkable, BasePlayer player)",
    "MethodSignature": "ShouldNetworkTo(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool ShouldNetworkTo(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanNetworkTo\u0022, this, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (net.group == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn player.net.subscriber.IsSubscribed(net.group);\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerDeath(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "Die(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void Die(HitInfo info = null)\n\t{\n\t\tusing (TimeWarning.New(\u0022Player.Die\u0022))\n\t\t{\n\t\t\tif (!IsDead())\n\t\t\t{\n\t\t\t\tHandcuffs restraintItem = Belt.GetRestraintItem();\n\t\t\t\tif (restraintItem != null)\n\t\t\t\t{\n\t\t\t\t\trestraintItem.HeldWhenOwnerDied(this);\n\t\t\t\t}\n\t\t\t\tif (InGesture)\n\t\t\t\t{\n\t\t\t\t\tServer_CancelGesture();\n\t\t\t\t}\n\t\t\t\tif (Belt != null \u0026\u0026 ShouldDropActiveItem())\n\t\t\t\t{\n\t\t\t\t\tVector3 vector = new Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));\n\t\t\t\t\tBelt.DropActive(GetDropPosition(), GetInheritedDropVelocity() \u002B vector.normalized * 3f);\n\t\t\t\t}\n\t\t\t\tif (!WoundInsteadOfDying(info) \u0026\u0026 Interface.CallHook(\u0022OnPlayerDeath\u0022, this, info) == null)\n\t\t\t\t{\n\t\t\t\t\tSleepingBag.OnPlayerDeath(this);\n\t\t\t\t\tbase.Die(info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnPlayerRecovered(BasePlayer basePlayer)",
    "MethodSignature": "RecoverFromWounded()",
    "MethodSourseCode": "\n\tpublic void RecoverFromWounded()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerRecover\u0022, this) == null)\n\t\t{\n\t\t\tif (IsCrawling())\n\t\t\t{\n\t\t\t\tbase.health = UnityEngine.Random.Range(2f, 6f) \u002B healingWhileCrawling;\n\t\t\t}\n\t\t\thealingWhileCrawling = 0f;\n\t\t\tSetPlayerFlag(PlayerFlags.Wounded, b: false);\n\t\t\tSetPlayerFlag(PlayerFlags.Incapacitated, b: false);\n\t\t\tif ((bool)BaseGameMode.GetActiveGameMode(base.isServer))\n\t\t\t{\n\t\t\t\tBaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPlayerRecovered\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnLiftUse(Lift lift, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_UseLift(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_UseLift(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 Interface.CallHook(\u0022OnLiftUse\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tMoveUp();\n\t\t}\n\t}\n",
    "ClassName": "Lift",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanHelicopterDropCrate(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "CanDropCrate()",
    "MethodSourseCode": "\n\tpublic bool CanDropCrate()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterDropCrate\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn numCrates \u003E 0;\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanHelicopterUseNapalm(PatrolHelicopterAI patrolHelicopterAI)",
    "MethodSignature": "CanUseNapalm()",
    "MethodSourseCode": "\n\tpublic bool CanUseNapalm()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterUseNapalm\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn UnityEngine.Time.realtimeSinceStartup - lastNapalmTime \u003E= UnityEngine.Random.Range(25f, 35f);\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanSwapToSeat(BasePlayer player, ModularCarSeat modularCarSeat)",
    "MethodSignature": "CanSwapToThis(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool CanSwapToThis(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanSwapToSeat\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (associatedSeatingModule.DoorsAreLockable)\n\t\t{\n\t\t\tModularCar modularCar = associatedSeatingModule.Vehicle as ModularCar;\n\t\t\tif (modularCar != null)\n\t\t\t{\n\t\t\t\treturn modularCar.PlayerCanUseThis(player, ModularCarCodeLock.LockType.Door);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ModularCarSeat",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityMarkHostile(BaseCombatEntity baseCombatEntity, float duration)",
    "MethodSignature": "MarkHostileFor(float duration)",
    "MethodSourseCode": "\n\tpublic virtual void MarkHostileFor(float duration = 60f)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntityMarkHostile\u0022, this, duration) == null)\n\t\t{\n\t\t\tfloat b = UnityEngine.Time.realtimeSinceStartup \u002B duration;\n\t\t\tunHostileTime = Mathf.Max(unHostileTime, b);\n\t\t}\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnMissionAssigned(BaseMission mission, IMissionProvider provider, BasePlayer assignee)",
    "MethodSignature": "AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)",
    "MethodSourseCode": "\n\tpublic static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)\n\t{\n\t\tif (!missionsenabled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!mission.IsEligableForMission(assignee, provider))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanAssignMission\u0022, assignee, mission, provider);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tint num = assignee.missions.FindIndexWith((MissionInstance i) =\u003E i.missionID, mission.id);\n\t\tMissionInstance missionInstance;\n\t\tint activeMission;\n\t\tif (num \u003E= 0)\n\t\t{\n\t\t\tmissionInstance = assignee.missions[num];\n\t\t\tactiveMission = num;\n\t\t\tmissionInstance.Reset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmissionInstance = Facepunch.Pool.Get\u003CMissionInstance\u003E();\n\t\t\tactiveMission = assignee.missions.Count;\n\t\t\tassignee.missions.Add(missionInstance);\n\t\t}\n\t\tmissionInstance.missionID = mission.id;\n\t\tmissionInstance.startTime = UnityEngine.Time.time;\n\t\tmissionInstance.providerID = provider.ProviderID();\n\t\tmissionInstance.status = MissionStatus.Active;\n\t\tmissionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];\n\t\tfor (int j = 0; j \u003C mission.objectives.Length; j\u002B\u002B)\n\t\t{\n\t\t\tmissionInstance.objectiveStatuses[j] = new MissionInstance.ObjectiveStatus();\n\t\t}\n\t\tmission.MissionStart(missionInstance, assignee);\n\t\tassignee.SetActiveMission(activeMission);\n\t\tassignee.MissionDirty();\n\t\tInterface.CallHook(\u0022OnMissionAssigned\u0022, mission, provider, assignee);\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseMission",
    "HookLineInvoke": 43
  },
  {
    "HookSignature": "OnDefaultItemsReceive(PlayerInventory playerInventory)",
    "MethodSignature": "GiveDefaultItems()",
    "MethodSourseCode": "\n\tpublic void GiveDefaultItems()\n\t{\n\t\tif (Interface.CallHook(\u0022OnDefaultItemsReceive\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tStrip();\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif (activeGameMode != null \u0026\u0026 activeGameMode.HasLoadouts())\n\t\t{\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);\n\t\t\treturn;\n\t\t}\n\t\tGiveDefaultItemWithSkin(\u0022client.rockskin\u0022, \u0022rock\u0022);\n\t\tGiveDefaultItemWithSkin(\u0022client.torchskin\u0022, \u0022torch\u0022);\n\t\tif (IsBirthday() \u0026\u0026 !base.baseEntity.IsInTutorial)\n\t\t{\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022cakefiveyear\u0022, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022partyhat\u0022, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerWear);\n\t\t}\n\t\tif (IsChristmas() \u0026\u0026 !base.baseEntity.IsInTutorial)\n\t\t{\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\n\t\t}\n\t\tInterface.CallHook(\u0022OnDefaultItemsReceived\u0022, this);\n\t\tvoid GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)\n\t\t{\n\t\t\tulong num = 0uL;\n\t\t\tint infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);\n\t\t\tbool flag = false;\n\t\t\tbool flag2 = false;\n\t\t\tflag2 = base.baseEntity?.UnlockAllSkins ?? false;\n\t\t\tif (infoInt \u003E 0 \u0026\u0026 (base.baseEntity.blueprints.CheckSkinOwnership(infoInt, base.baseEntity.userID) || flag2))\n\t\t\t{\n\t\t\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);\n\t\t\t\tif (itemDefinition != null \u0026\u0026 ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)\n\t\t\t\t{\n\t\t\t\t\tIPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);\n\t\t\t\t\tif (itemDefinition2 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum = itemDefinition2.WorkshopDownload;\n\t\t\t\t\t}\n\t\t\t\t\tif (num == 0L \u0026\u0026 itemDefinition.skins != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tItemSkinDirectory.Skin[] skins = itemDefinition.skins;\n\t\t\t\t\t\tfor (int i = 0; i \u003C skins.Length; i\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tItemSkinDirectory.Skin skin = skins[i];\n\t\t\t\t\t\t\tif (skin.id == infoInt \u0026\u0026 skin.invItem != null \u0026\u0026 skin.invItem is ItemSkin itemSkin \u0026\u0026 itemSkin.Redirect != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tGiveItem(ItemManager.CreateByName(itemShortName, 1, num).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityFlagsNetworkUpdate(BaseEntity baseEntity)",
    "MethodSignature": "SendNetworkUpdate_Flags()",
    "MethodSourseCode": "\n\tpublic void SendNetworkUpdate_Flags()\n\t{\n\t\tif (Rust.Application.isLoading || Rust.Application.isLoadingSave || base.IsDestroyed || net == null || !isSpawned)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022SendNetworkUpdate_Flags\u0022))\n\t\t{\n\t\t\tLogEntry(RustLog.EntryType.Network, 3, \u0022SendNetworkUpdate_Flags\u0022);\n\t\t\tif (Interface.CallHook(\u0022OnEntityFlagsNetworkUpdate\u0022, this) == null)\n\t\t\t{\n\t\t\t\tList\u003CConnection\u003E subscribers = GetSubscribers();\n\t\t\t\tif (subscribers != null \u0026\u0026 subscribers.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tSendDemoTransientEntity();\n\t\t\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\t\t\tnetWrite.PacketID(Message.Type.EntityFlags);\n\t\t\t\t\tnetWrite.EntityID(net.ID);\n\t\t\t\t\tnetWrite.Int32((int)flags);\n\t\t\t\t\tSendInfo info = new SendInfo(subscribers);\n\t\t\t\t\tnetWrite.Send(info);\n\t\t\t\t}\n\t\t\t\tbase.gameObject.SendOnSendNetworkUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_RotateVM(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_RotateVM(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnRotateVendingMachine\u0022, this, msg.player) == null \u0026\u0026 CanRotate())\n\t\t{\n\t\t\tUpdateEmptyFlag();\n\t\t\tif (msg.player.CanBuild() \u0026\u0026 IsInventoryEmpty())\n\t\t\t{\n\t\t\t\tbase.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerHealthChange(BasePlayer basePlayer, float oldvalue, float newvalue)",
    "MethodSignature": "OnHealthChanged(float oldvalue, float newvalue)",
    "MethodSourseCode": "\n\tpublic override void OnHealthChanged(float oldvalue, float newvalue)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerHealthChange\u0022, this, oldvalue, newvalue) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbase.OnHealthChanged(oldvalue, newvalue);\n\t\tif (base.isServer)\n\t\t{\n\t\t\tif (oldvalue \u003E newvalue)\n\t\t\t{\n\t\t\t\tLifeStoryHurt(oldvalue - newvalue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLifeStoryHeal(newvalue - oldvalue);\n\t\t\t}\n\t\t\tmetabolism.isDirty = true;\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUseHBHFSensor(BasePlayer player, HBHFSensor hBHFSensor)",
    "MethodSignature": "CanUse(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanUse(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseHBHFSensor\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn player.CanBuild();\n\t}\n",
    "ClassName": "HBHFSensor",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnLockerSwap(Locker locker, int num, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_Equip(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Equip(RPCMessage msg)\n\t{\n\t\tint num = msg.read.Int32();\n\t\tif (num \u003C 0 || num \u003E= 3 || Interface.CallHook(\u0022OnLockerSwap\u0022, this, num, msg.player) != null || IsEquipping())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tif (player.IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseLock @lock = GetLock();\n\t\tif (@lock != null \u0026\u0026 !@lock.OnTryToOpen(player))\n\t\t{\n\t\t\tplayer.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);\n\t\t\treturn;\n\t\t}\n\t\tint num2 = num * 14;\n\t\tbool flag = false;\n\t\tfor (int i = 0; i \u003C clothingBuffer.Length; i\u002B\u002B)\n\t\t{\n\t\t\tItem slot = player.inventory.containerWear.GetSlot(i);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tslot.RemoveFromContainer();\n\t\t\t\tclothingBuffer[i] = slot;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j \u003C 8; j\u002B\u002B)\n\t\t{\n\t\t\tint num3 = num2 \u002B j;\n\t\t\tItem slot2 = base.inventory.GetSlot(num3);\n\t\t\tItem item = clothingBuffer[j];\n\t\t\tif (slot2 != null)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tif (slot2.info.category != ItemCategory.Attire || !slot2.MoveToContainer(player.inventory.containerWear, j))\n\t\t\t\t{\n\t\t\t\t\tslot2.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tif (!item.MoveToContainer(base.inventory, num3) \u0026\u0026 !item.MoveToContainer(player.inventory.containerWear, j))\n\t\t\t\t{\n\t\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t\tclothingBuffer[j] = null;\n\t\t}\n\t\tfor (int k = 0; k \u003C 6; k\u002B\u002B)\n\t\t{\n\t\t\tint num4 = num2 \u002B k \u002B 8;\n\t\t\tint iTargetPos = k;\n\t\t\tItem slot3 = base.inventory.GetSlot(num4);\n\t\t\tItem slot4 = player.inventory.containerBelt.GetSlot(k);\n\t\t\tslot4?.RemoveFromContainer();\n\t\t\tif (slot3 != null)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tif (!slot3.MoveToContainer(player.inventory.containerBelt, iTargetPos))\n\t\t\t\t{\n\t\t\t\t\tslot3.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (slot4 != null)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tif (!slot4.MoveToContainer(base.inventory, num4))\n\t\t\t\t{\n\t\t\t\t\tslot4.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tEffect.server.Run(equipSound.resourcePath, player, StringPool.Get(\u0022spine3\u0022), Vector3.zero, Vector3.zero);\n\t\t\tSetFlag(Flags.Reserved1, b: true);\n\t\t\tInvoke(ClearEquipping, 1.5f);\n\t\t}\n\t}\n",
    "ClassName": "Locker",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnSendCommand(Network.Connection cn, string strCommand, object[] args)",
    "MethodSignature": "SendClientCommand(Connection cn, string strCommand, object[] args)",
    "MethodSourseCode": "\n\tpublic static void SendClientCommand(Connection cn, string strCommand, params object[] args)\n\t{\n\t\tif (Network.Net.sv.IsConnected() \u0026\u0026 Interface.CallHook(\u0022OnSendCommand\u0022, cn, strCommand, args) == null)\n\t\t{\n\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\tnetWrite.PacketID(Message.Type.ConsoleCommand);\n\t\t\tstring val = ConsoleSystem.BuildCommand(strCommand, args);\n\t\t\tnetWrite.String(val);\n\t\t\tnetWrite.Send(new SendInfo(cn));\n\t\t}\n\t}\n",
    "ClassName": "ConsoleNetwork",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFindBurnable(BaseOven baseOven)",
    "MethodSignature": "FindBurnable()",
    "MethodSourseCode": "\n\tpublic Item FindBurnable()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnFindBurnable\u0022, this);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\tif (base.inventory == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tforeach (Item item in base.inventory.itemList)\n\t\t{\n\t\t\tif (IsBurnableItem(item))\n\t\t\t{\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPhoneNameUpdated(PhoneController phoneController, string PhoneName, BasePlayer msgPlayer)",
    "MethodSignature": "UpdatePhoneName(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void UpdatePhoneName(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (!(msg.player != currentPlayer))\n\t\t{\n\t\t\tstring text = msg.read.String();\n\t\t\tif (text.Length \u003E 30)\n\t\t\t{\n\t\t\t\ttext = text.Substring(0, 30);\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnPhoneNameUpdate\u0022, this, text, msg.player) == null)\n\t\t\t{\n\t\t\t\tPhoneName = text;\n\t\t\t\tbase.baseEntity.SendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnPhoneNameUpdated\u0022, this, PhoneName, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnXmasStockingFill(Stocking stocking)",
    "MethodSignature": "SpawnLoot()",
    "MethodSourseCode": "\n\tpublic override void SpawnLoot()\n\t{\n\t\tif (base.inventory == null)\n\t\t{\n\t\t\tDebug.Log(\u0022CONTACT DEVELOPERS! Stocking::PopulateLoot has null inventory!!! \u0022 \u002B base.name);\n\t\t}\n\t\telse if (IsEmpty() \u0026\u0026 Interface.CallHook(\u0022OnXmasStockingFill\u0022, this) == null)\n\t\t{\n\t\t\tbase.SpawnLoot();\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tHurt(MaxHealth() * 0.1f, DamageType.Generic, null, useProtection: false);\n\t\t}\n\t}\n",
    "ClassName": "Stocking",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "RPC_OpenAdmin(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_OpenAdmin(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (CanPlayerAdmin(player))\n\t\t{\n\t\t\tOpenShop(player);\n\t\t\tClientRPC(RpcTarget.Player(\u0022CLIENT_OpenAdminMenu\u0022, player));\n\t\t\tInterface.CallHook(\u0022OnOpenVendingAdmin\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnGrowableGathered(GrowableEntity growableEntity, Item item, BasePlayer player)",
    "MethodSignature": "GiveFruit(BasePlayer player, int amount, bool applyCondition, bool eat)",
    "MethodSourseCode": "\n\tpublic void GiveFruit(BasePlayer player, int amount, bool applyCondition, bool eat)\n\t{\n\t\tItem item = ItemManager.Create(Properties.pickupItem, amount, 0uL);\n\t\titem.SetItemOwnership(player, ItemOwnershipPhrases.Harvested);\n\t\tif (applyCondition)\n\t\t{\n\t\t\titem.conditionNormalized = Properties.fruitVisualScaleCurve.Evaluate(StageProgressFraction);\n\t\t}\n\t\tif (eat \u0026\u0026 player != null \u0026\u0026 IsFood())\n\t\t{\n\t\t\tItemModConsume component = item.info.GetComponent\u003CItemModConsume\u003E();\n\t\t\tif (component != null)\n\t\t\t{\n\t\t\t\tcomponent.DoAction(item, player);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (player != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnGrowableGathered\u0022, this, item, player);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);\n\t\t\tplayer.GiveItem(item, GiveItemReason.ResourceHarvested);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 0.5f, Vector3.up * 1f);\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnBookmarkControl(ComputerStation computerStation, BasePlayer player, string text, IRemoteControllable remoteControllable)",
    "MethodSignature": "BeginControllingBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void BeginControllingBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);\n\t\tif (remoteControllable == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity ent = remoteControllable.GetEnt();\n\t\tif (ent == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022RC identifier \u0022 \u002B text \u002B \u0022 was found but has a null or destroyed entity, this should never happen\u0022);\n\t\t}\n\t\telse if (remoteControllable.CanControl(player.userID) \u0026\u0026 !(Vector3.Distance(base.transform.position, ent.transform.position) \u003E= remoteControllable.MaxRange) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkControl\u0022, this, player, text, remoteControllable) == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tIRemoteControllable component = baseEntity.GetComponent\u003CIRemoteControllable\u003E();\n\t\t\t\tcomponent?.StopControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t\t\tInterface.CallHook(\u0022OnBookmarkControlEnded\u0022, this, player, component);\n\t\t\t}\n\t\t\tplayer.net.SwitchSecondaryGroup(ent.net.group);\n\t\t\tplayer.SetRcEntityPosition(ent.transform.position);\n\t\t\tcurrentlyControllingEnt.uid = ent.net.ID;\n\t\t\tcurrentPlayerID = player.userID;\n\t\t\tbool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t\tSetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tSendControlBookmarks(player);\n\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 remoteControllable.GetEnt() is CCTV_RC)\n\t\t\t{\n\t\t\t\tInvokeRepeating(CheckCCTVAchievement, 1f, 3f);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnBookmarkControlStarted\u0022, this, player, text, remoteControllable);\n\t\t\tInvokeRepeating(ControlCheck, 0f, 0f);\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnExperimentStart(Workbench workbench, BasePlayer player)",
    "MethodSignature": "RPC_BeginExperiment(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_BeginExperiment(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (player == null || IsWorking())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;\n\t\tint num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);\n\t\tfor (int i = 0; i \u003C experimentalItems.subSpawn.Length; i\u002B\u002B)\n\t\t{\n\t\t\tint num2 = i \u002B num;\n\t\t\tif (num2 \u003E= experimentalItems.subSpawn.Length)\n\t\t\t{\n\t\t\t\tnum2 -= experimentalItems.subSpawn.Length;\n\t\t\t}\n\t\t\tItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;\n\t\t\tif ((bool)itemDef.Blueprint \u0026\u0026 !itemDef.Blueprint.defaultBlueprint \u0026\u0026 itemDef.Blueprint.userCraftable \u0026\u0026 itemDef.Blueprint.isResearchable \u0026\u0026 !itemDef.Blueprint.NeedsSteamItem \u0026\u0026 !itemDef.Blueprint.NeedsSteamDLC \u0026\u0026 !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))\n\t\t\t{\n\t\t\t\tpendingBlueprint = itemDef;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pendingBlueprint == null)\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022You have already unlocked everything for this workbench tier.\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnExperimentStart\u0022, this, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem slot = base.inventory.GetSlot(0);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tif (!slot.MoveToContainer(player.inventory.containerMain))\n\t\t\t\t{\n\t\t\t\t\tslot.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t}\n\t\t\tif (experimentStartEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tCancelInvoke(ExperimentComplete);\n\t\t\tInvoke(ExperimentComplete, 5f);\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnExperimentStarted\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnMissionSucceeded(BaseMission baseMission, BaseMission.MissionInstance instance, BasePlayer assignee)",
    "MethodSignature": "MissionSuccess(MissionInstance instance, BasePlayer assignee)",
    "MethodSourseCode": "\n\tpublic virtual void MissionSuccess(MissionInstance instance, BasePlayer assignee)\n\t{\n\t\tinstance.status = MissionStatus.Accomplished;\n\t\tMissionEnded(instance, assignee);\n\t\tMissionComplete(instance, assignee);\n\t\tInterface.CallHook(\u0022OnMissionSucceeded\u0022, this, instance, assignee);\n\t}\n",
    "ClassName": "BaseMission",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnBuildingSplit(BuildingManager.Building oldBuilding, uint newID)",
    "MethodSignature": "Split(Building oldBuilding)",
    "MethodSourseCode": "\n\tprivate void Split(Building oldBuilding)\n\t{\n\t\tList\u003CBuilding\u003E obj = Facepunch.Pool.Get\u003CList\u003CBuilding\u003E\u003E();\n\t\tBuilding largestSplit = null;\n\t\twhile (oldBuilding.HasBuildingBlocks())\n\t\t{\n\t\t\tBuildingBlock buildingBlock = oldBuilding.buildingBlocks[0];\n\t\t\tuint newID = BuildingManager.server.NewBuildingID();\n\t\t\tInterface.CallHook(\u0022OnBuildingSplit\u0022, oldBuilding, newID);\n\t\t\tbuildingBlock.EntityLinkBroadcast(delegate(BuildingBlock b)\n\t\t\t{\n\t\t\t\tb.AttachToBuilding(newID);\n\t\t\t});\n\t\t\tBuilding building = BuildingManager.server.GetBuilding(newID);\n\t\t\tif (building != null)\n\t\t\t{\n\t\t\t\tobj.Add(building);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tforeach (Building item in obj)\n\t\t{\n\t\t\tif (item.buildingBlocks.Count \u003E num)\n\t\t\t{\n\t\t\t\tnum = item.buildingBlocks.Count;\n\t\t\t\tlargestSplit = item;\n\t\t\t}\n\t\t}\n\t\tSplitEntities(oldBuilding.buildingPrivileges, largestSplit);\n\t\tSplitEntities(oldBuilding.decayEntities, largestSplit);\n\t\tif (AI.nav_carve_use_building_optimization)\n\t\t{\n\t\t\toldBuilding.isNavMeshCarvingDirty = true;\n\t\t\tint ticks = 2;\n\t\t\tUpdateNavMeshCarver(oldBuilding, ref ticks, 0);\n\t\t}\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t}\n",
    "ClassName": "ServerBuildingManager",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnDigitalClockAlarmsSet(DigitalClock digitalClock, ProtoBuf.DigitalClockMessage digitalClockMessage)",
    "MethodSignature": "RPC_SetAlarms(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(5uL)]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_SetAlarms(RPCMessage msg)\n\t{\n\t\tif (!CanPlayerAdmin(msg.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDigitalClockMessage digitalClockMessage = msg.read.Proto\u003CDigitalClockMessage\u003E();\n\t\tif (Interface.CallHook(\u0022OnDigitalClockAlarmsSet\u0022, this, digitalClockMessage) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\talarms.Clear();\n\t\t\tforeach (DigitalClockAlarm alarm in digitalClockMessage.alarms)\n\t\t\t{\n\t\t\t\tAlarm item = new Alarm(DigitalClockEx.ToTimeSpan(alarm.time), alarm.active);\n\t\t\t\talarms.Add(item);\n\t\t\t}\n\t\t\tmuted = digitalClockMessage.muted;\n\t\t\tMarkDirty();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\t((IDisposable)digitalClockMessage)?.Dispose();\n\t\t}\n\t}\n",
    "ClassName": "DigitalClock",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnAnalysisComplete(SurveyCrater surveyCrater, BasePlayer msgPlayer)",
    "MethodSignature": "AnalysisComplete(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void AnalysisComplete(RPCMessage msg)\n\t{\n\t\tInterface.CallHook(\u0022OnAnalysisComplete\u0022, this, msg.player);\n\t}\n",
    "ClassName": "SurveyCrater",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanHelicopterTarget(PatrolHelicopterAI patrolHelicopterAI, BasePlayer ply)",
    "MethodSignature": "PlayerVisible(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic bool PlayerVisible(BasePlayer ply)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterTarget\u0022, this, ply);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022PatrolHelicoperAI.PlayerVisible\u0022))\n\t\t{\n\t\t\tVector3 position = ply.eyes.position;\n\t\t\tif (ply.eyes.position.y \u003C WaterSystem.OceanLevel \u0026\u0026 Mathf.Abs(WaterSystem.OceanLevel - ply.eyes.position.y) \u003E oceanDepthTargetCutoff)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (TOD_Sky.Instance.IsNight \u0026\u0026 Vector3.Distance(position, interestZoneOrigin) \u003E 40f)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tVector3 vector = base.transform.position - Vector3.up * 6f;\n\t\t\tfloat num = Vector3.Distance(position, vector);\n\t\t\tVector3 normalized = (position - vector).normalized;\n\t\t\tif (GamePhysics.Trace(new Ray(vector \u002B normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) \u0026\u0026 GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerRespawn(BasePlayer player, SleepingBag sleepingBag2)",
    "MethodSignature": "SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)",
    "MethodSourseCode": "\n\tpublic static bool SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)\n\t{\n\t\tBasePlayer player2 = player;\n\t\tSleepingBag[] array = FindForPlayer(player2.userID, ignoreTimers: true);\n\t\tSleepingBag sleepingBag2 = array.FirstOrDefault((SleepingBag x) =\u003E x.ValidForPlayer(player2.userID, ignoreTimers: false) \u0026\u0026 x.net.ID == sleepingBag \u0026\u0026 x.unlockTime \u003C UnityEngine.Time.realtimeSinceStartup);\n\t\tif (sleepingBag2 == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerRespawn\u0022, player, sleepingBag2);\n\t\tif (obj is SleepingBag)\n\t\t{\n\t\t\tsleepingBag2 = (SleepingBag)obj;\n\t\t}\n\t\tif (sleepingBag2 is StaticRespawnArea staticRespawnArea \u0026\u0026 !staticRespawnArea.IsAuthed(player2.userID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (sleepingBag2.GetRespawnState(player2.userID) != RespawnInformation.SpawnOptions.RespawnState.OK)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tsleepingBag2.GetSpawnPos(out var pos, out var rot);\n\t\tplayer2.RespawnAt(pos, rot, sleepingBag2);\n\t\tsleepingBag2.PostPlayerSpawn(player2);\n\t\tSleepingBag[] array2 = array;\n\t\tfor (int i = 0; i \u003C array2.Length; i\u002B\u002B)\n\t\t{\n\t\t\tSetBagTimer(array2[i], pos, SleepingBagResetReason.Respawned, player2);\n\t\t}\n\t\tif (sleepingBag2.HasFlag(Flags.Reserved14))\n\t\t{\n\t\t\tsleepingBag2.Kill();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnPatrolHelicopterTakeDamage(PatrolHelicopter patrolHelicopter, HitInfo info)",
    "MethodSignature": "Hurt(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void Hurt(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPatrolHelicopterTakeDamage\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = false;\n\t\tif (info.damageTypes.Total() \u003E= base.health)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnPatrolHelicopterKill\u0022, this, info) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbase.health = 10000f;\n\t\t\tmyAI.CriticalDamage();\n\t\t\tflag = true;\n\t\t}\n\t\tbase.Hurt(info);\n\t\tif (flag)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tmyAI.OtherDamaged(info);\n\t\tweakspot[] array = weakspots;\n\t\tforeach (weakspot weakspot in array)\n\t\t{\n\t\t\tstring[] bonenames = weakspot.bonenames;\n\t\t\tforeach (string str in bonenames)\n\t\t\t{\n\t\t\t\tif (info.HitBone == StringPool.Get(str))\n\t\t\t\t{\n\t\t\t\t\tweakspot.Hurt(info.damageTypes.Total(), info);\n\t\t\t\t\tmyAI.WeakspotDamaged(weakspot, info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PatrolHelicopter",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanVendingAcceptItem(VendingMachine vendingMachine, Item item, int targetSlot)",
    "MethodSignature": "CanAcceptItem(Item item, int targetSlot)",
    "MethodSourseCode": "\n\tpublic bool CanAcceptItem(Item item, int targetSlot)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanVendingAcceptItem\u0022, this, item, targetSlot);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tBasePlayer basePlayer = item.GetRootContainer()?.GetOwnerPlayer();\n\t\tif (transactionActive || industrialItemIncoming)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (item.parent == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (base.inventory.itemList.Contains(item))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn item.GetEntityOwner() is ContainerCorpse;\n\t\t}\n\t\treturn CanPlayerAdmin(basePlayer);\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityGroundMissing(BaseEntity baseEntity)",
    "MethodSignature": "OnGroundMissing()",
    "MethodSourseCode": "\tprivate void OnGroundMissing()\n\t{\n\t\tBaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);\n\t\tif (baseEntity != null \u0026\u0026 Interface.CallHook(\u0022OnEntityGroundMissing\u0022, baseEntity) == null)\n\t\t{\n\t\t\tBaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;\n\t\t\tif (Stability.log_ground_missing_death)\n\t\t\t{\n\t\t\t\tDebug.Log($\u0022Killing \u0027{baseEntity.ToString()}\u0027 at position {base.transform.position} due to ground missing\u0022);\n\t\t\t}\n\t\t\tif (baseCombatEntity != null)\n\t\t\t{\n\t\t\t\tbaseCombatEntity.Die();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbaseEntity.Kill(BaseNetworkable.DestroyMode.Gib);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DestroyOnGroundMissing",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnWindmillUpdate(ElectricWindmill electricWindmill)",
    "MethodSignature": "WindUpdate()",
    "MethodSourseCode": "\n\tpublic void WindUpdate()\n\t{\n\t\tif (Interface.CallHook(\u0022OnWindmillUpdate\u0022, this) == null)\n\t\t{\n\t\t\tserverWindSpeed = GetWindSpeedScale();\n\t\t\tif (!AmIVisible())\n\t\t\t{\n\t\t\t\tserverWindSpeed = 0f;\n\t\t\t}\n\t\t\tint num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);\n\t\t\tbool num2 = currentEnergy != num;\n\t\t\tcurrentEnergy = num;\n\t\t\tif (num2)\n\t\t\t{\n\t\t\t\tMarkDirty();\n\t\t\t}\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnWindmillUpdated\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "ElectricWindmill",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCodeChanged(BasePlayer rpcPlayer, CodeLock codeLock, string text, bool flag)",
    "MethodSignature": "RPC_ChangeCode(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f, CheckParent = true)]\n\t[RPC_Server]\n\tprivate void RPC_ChangeCode(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = rpc.read.String();\n\t\tbool flag = rpc.read.Bit();\n\t\tif (!IsLocked() \u0026\u0026 text.Length == 4 \u0026\u0026 text.IsNumeric() \u0026\u0026 !(!hasCode \u0026\u0026 flag) \u0026\u0026 Interface.CallHook(\u0022CanChangeCode\u0022, rpc.player, this, text, flag) == null)\n\t\t{\n\t\t\tif (!hasCode \u0026\u0026 !flag)\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tcode = text;\n\t\t\t\thasCode = code.Length \u003E 0;\n\t\t\t\twhitelistPlayers.Clear();\n\t\t\t\twhitelistPlayers.Add(rpc.player.userID);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tguestCode = text;\n\t\t\t\thasGuestCode = guestCode.Length \u003E 0;\n\t\t\t\tguestPlayers.Clear();\n\t\t\t\tguestPlayers.Add(rpc.player.userID);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnCodeChanged\u0022, rpc.player, this, text, flag);\n\t\t\tDoEffect(effectCodeChanged.resourcePath);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnPlayerLootEnd(PlayerLoot playerLoot)",
    "MethodSignature": "Clear()",
    "MethodSourseCode": "\n\tpublic void Clear()\n\t{\n\t\tif (!IsLooting())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tInterface.CallHook(\u0022OnPlayerLootEnd\u0022, this);\n\t\tbase.baseEntity.HasClosedLoot();\n\t\tMarkDirty();\n\t\tif ((bool)entitySource)\n\t\t{\n\t\t\tentitySource.SendMessage(\u0022PlayerStoppedLooting\u0022, base.baseEntity, SendMessageOptions.DontRequireReceiver);\n\t\t}\n\t\tforeach (ItemContainer container in containers)\n\t\t{\n\t\t\tif (container != null)\n\t\t\t{\n\t\t\t\tcontainer.onDirty -= MarkDirty;\n\t\t\t}\n\t\t}\n\t\tClearContainers();\n\t\tentitySource = null;\n\t\titemSource = null;\n\t}\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnCargoShipHarborLeave(CargoShip cargoShip)",
    "MethodSignature": "LeaveHarbor()",
    "MethodSourseCode": "\n\tprivate void LeaveHarbor()\n\t{\n\t\tif (docking_debug)\n\t\t{\n\t\t\tDebug.Log(\u0022Cargo is leaving harbor.\u0022);\n\t\t}\n\t\tPlayHorn();\n\t\tSetFlag(Flags.Reserved1, b: false);\n\t\tSetFlag(Flags.Reserved2, b: true);\n\t\tcurrentHarborApproachNode\u002B\u002B;\n\t\tInterface.CallHook(\u0022OnCargoShipHarborLeave\u0022, this);\n\t}\n",
    "ClassName": "CargoShip",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnStructureDemolish(DecayEntity decayEntity, BasePlayer msgPlayer, bool false)",
    "MethodSignature": "DoDemolish(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void DoDemolish(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanDemolish(msg.player) \u0026\u0026 Interface.CallHook(\u0022OnStructureDemolish\u0022, this, msg.player, false) == null)\n\t\t{\n\t\t\tStabilityEntity stabilityEntity = this as StabilityEntity;\n\t\t\tif (stabilityEntity != null)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, stabilityEntity);\n\t\t\t}\n\t\t\tKill(DestroyMode.Gib);\n\t\t}\n\t}\n",
    "ClassName": "DecayEntity",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "IOnBaseCombatEntityHurt(BaseCombatEntity baseCombatEntity, HitInfo info)",
    "MethodSignature": "Hurt(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void Hurt(HitInfo info)\n\t{\n\t\tAssert.IsTrue(base.isServer, \u0022This should be called serverside only\u0022);\n\t\tif (IsDead() || IsTransferProtected())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022Hurt( HitInfo )\u0022, 50))\n\t\t{\n\t\t\tfloat num = health;\n\t\t\tScaleDamage(info);\n\t\t\tif (info.PointStart != Vector3.zero)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C propDirection.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tif (!(propDirection[i].extraProtection == null) \u0026\u0026 !propDirection[i].IsWeakspot(base.transform, info))\n\t\t\t\t\t{\n\t\t\t\t\t\tpropDirection[i].extraProtection.Scale(info.damageTypes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinfo.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);\n\t\t\tif (!(this is BasePlayer))\n\t\t\t{\n\t\t\t\tinfo.damageTypes.Scale(DamageType.Fun_Water, 0f);\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022IOnBaseCombatEntityHurt\u0022, this, info) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDebugHurt(info);\n\t\t\tfloat num2 = info.damageTypes.Total();\n\t\t\thealth = num - num2;\n\t\t\tSendNetworkUpdate();\n\t\t\tLogEntry(RustLog.EntryType.Combat, 2, \u0022hurt {0}/{1} - {2} health left\u0022, info.damageTypes.GetMajorityDamageType(), num2, health.ToString(\u00220\u0022));\n\t\t\tlastDamage = info.damageTypes.GetMajorityDamageType();\n\t\t\tlastAttacker = info.Initiator;\n\t\t\tif (lastAttacker != null)\n\t\t\t{\n\t\t\t\tBaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;\n\t\t\t\tif (baseCombatEntity != null)\n\t\t\t\t{\n\t\t\t\t\tbaseCombatEntity.lastDealtDamageTime = UnityEngine.Time.time;\n\t\t\t\t\tbaseCombatEntity.lastDealtDamageTo = this;\n\t\t\t\t}\n\t\t\t\tif (this.IsValid() \u0026\u0026 lastAttacker is BasePlayer basePlayer)\n\t\t\t\t{\n\t\t\t\t\tbasePlayer.ProcessMissionEvent(BaseMission.MissionEventType.HURT_ENTITY, net.ID, num2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;\n\t\t\tif (markAttackerHostile \u0026\u0026 baseCombatEntity2 != null \u0026\u0026 baseCombatEntity2 != this)\n\t\t\t{\n\t\t\t\tbaseCombatEntity2.MarkHostileFor();\n\t\t\t}\n\t\t\tif (lastDamage.IsConsideredAnAttack())\n\t\t\t{\n\t\t\t\tSetJustAttacked();\n\t\t\t\tif (lastAttacker != null)\n\t\t\t\t{\n\t\t\t\t\tLastAttackedDir = (lastAttacker.transform.position - base.transform.position).normalized;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool flag = Health() \u003C= 0f;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityTakeDamage(info, flag);\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tDie(info);\n\t\t\t}\n\t\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\n\t\t\tif ((bool)initiatorPlayer)\n\t\t\t{\n\t\t\t\tif (IsDead())\n\t\t\t\t{\n\t\t\t\t\tinitiatorPlayer.stats.combat.LogAttack(info, \u0022killed\u0022, num);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinitiatorPlayer.stats.combat.LogAttack(info, \u0022\u0022, num);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (base.Components == null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0; j \u003C base.Components.Count; j\u002B\u002B)\n\t\t\t{\n\t\t\t\tif (!(base.Components[j] == null))\n\t\t\t\t{\n\t\t\t\t\tbase.Components[j].Hurt(info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnMapImageUpdated()",
    "MethodSignature": "ImageUpdate(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.FromOwner(false)]\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\tpublic void ImageUpdate(RPCMessage msg)\n\t{\n\t\tif (msg.player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte b = msg.read.UInt8();\n\t\tbyte b2 = msg.read.UInt8();\n\t\tuint num = msg.read.UInt32();\n\t\tif ((b == 0 \u0026\u0026 fogImages[b2] == num) || (b == 1 \u0026\u0026 paintImages[b2] == num))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tuint num2 = (uint)(b * 1000 \u002B b2);\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (array != null)\n\t\t{\n\t\t\tFileStorage.server.RemoveEntityNum(net.ID, num2);\n\t\t\tuint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);\n\t\t\tif (b == 0)\n\t\t\t{\n\t\t\t\tfogImages[b2] = num3;\n\t\t\t}\n\t\t\tif (b == 1)\n\t\t\t{\n\t\t\t\tpaintImages[b2] = num3;\n\t\t\t}\n\t\t\tInvalidateNetworkCache();\n\t\t\tInterface.CallHook(\u0022OnMapImageUpdated\u0022);\n\t\t}\n\t}\n",
    "ClassName": "MapEntity",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnCargoShipHarborArrived(CargoShip cargoShip)",
    "MethodSignature": "OnArrivedAtHarbor()",
    "MethodSourseCode": "\n\tpublic void OnArrivedAtHarbor()\n\t{\n\t\tSetFlag(Flags.Reserved1, b: true);\n\t\tList\u003CTransform\u003E obj = Pool.Get\u003CList\u003CTransform\u003E\u003E();\n\t\tfloat num = UnityEngine.Random.Range(dock_time * 0.05f, dock_time * 0.1f);\n\t\tforeach (HarborCraneContainerPickup allCrane in HarborCraneContainerPickup.AllCranes)\n\t\t{\n\t\t\tif (allCrane == null || allCrane.isClient || allCrane.Distance2D(this) \u003E 150f)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tobj.Clear();\n\t\t\tCargoShipContainerDestination[] array = containerDestinations;\n\t\t\tforeach (CargoShipContainerDestination cargoShipContainerDestination in array)\n\t\t\t{\n\t\t\t\tif (allCrane.IsDestinationValidForCrane(cargoShipContainerDestination))\n\t\t\t\t{\n\t\t\t\t\tobj.Add(cargoShipContainerDestination.transform);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (obj.Count \u003E 0)\n\t\t\t{\n\t\t\t\tallCrane.AssignDestination(obj, this, num);\n\t\t\t\tnum \u002B= dock_time * UnityEngine.Random.Range(0.1f, 0.15f);\n\t\t\t}\n\t\t}\n\t\tPool.FreeUnmanaged(ref obj);\n\t\tInvoke(PreHarborLeaveHorn, dock_time - 60f);\n\t\tif (refresh_loot_on_dock)\n\t\t{\n\t\t\tRespawnLoot();\n\t\t}\n\t\tif (harborIndex == 0)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved3, b: true);\n\t\t}\n\t\telse if (harborIndex == 1)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved4, b: true);\n\t\t}\n\t\tInvoke(LeaveHarbor, dock_time);\n\t\tInterface.CallHook(\u0022OnCargoShipHarborArrived\u0022, this);\n\t}\n",
    "ClassName": "CargoShip",
    "HookLineInvoke": 42
  },
  {
    "HookSignature": "OnEntityDistanceCheck(BaseEntity ent, BasePlayer player, uint id, string debugName, float maximumDistance, bool checkParent)",
    "MethodSignature": "Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance, bool checkParent)",
    "MethodSourseCode": "\n\t\t\tpublic static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance, bool checkParent = false)\n\t\t\t{\n\t\t\t\tif (ent == null || player == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnEntityDistanceCheck\u0022, ent, player, id, debugName, maximumDistance, checkParent);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tbool flag = ent.Distance(player.eyes.position) \u003C= maximumDistance;\n\t\t\t\tif (checkParent \u0026\u0026 !flag)\n\t\t\t\t{\n\t\t\t\t\tBaseEntity parentEntity = ent.GetParentEntity();\n\t\t\t\t\tflag = parentEntity != null \u0026\u0026 parentEntity.Distance(player.eyes.position) \u003C= maximumDistance;\n\t\t\t\t}\n\t\t\t\treturn flag;\n\t\t\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnRackedWeaponTake(Item slot, BasePlayer player, WeaponRack weaponRack)",
    "MethodSignature": "GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex, bool tryHold, bool sendUpdate)",
    "MethodSourseCode": "\n\tprivate void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)\n\t{\n\t\tif (player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);\n\t\tif (weaponAtIndex == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\n\t\tif (slot == null || Interface.CallHook(\u0022OnRackedWeaponTake\u0022, slot, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tClearSlot(weaponAtIndex);\n\t\tbool flag = false;\n\t\tbool flag2 = true;\n\t\tif (slot.IsBackpack())\n\t\t{\n\t\t\tflag2 = false;\n\t\t\tif (slot.info.GetComponent\u003CItemModBackpack\u003E() != null \u0026\u0026 player.inventory.GetAnyBackpack() == null)\n\t\t\t{\n\t\t\t\tflag = slot.MoveToContainer(player.inventory.containerWear);\n\t\t\t}\n\t\t}\n\t\tif (!flag)\n\t\t{\n\t\t\tflag = slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex);\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tif (flag2 \u0026\u0026 ((tryHold \u0026\u0026 player.GetHeldEntity() == null) || playerBeltIndex != -1))\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022SetActiveBeltSlot\u0022, player), slot.position, slot.uid);\n\t\t\t}\n\t\t\tClientRPC(RpcTarget.Player(\u0022PlayGrabSound\u0022, player), slot.info.itemid);\n\t\t}\n\t\telse if (!slot.MoveToContainer(player.inventory.containerMain))\n\t\t{\n\t\t\tslot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\n\t\t}\n\t\tif (sendUpdate)\n\t\t{\n\t\t\tItemManager.DoRemoves();\n\t\t\tSendNetworkUpdateImmediate();\n\t\t}\n\t\tInterface.CallHook(\u0022OnRackedWeaponTaken\u0022, slot, player, this);\n\t}\n",
    "ClassName": "WeaponRack",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnCargoShipHarborApproach(CargoShip cargoShip, CargoNotifier cn)",
    "MethodSignature": "StartHarborApproach(CargoNotifier cn)",
    "MethodSourseCode": "\n\tpublic void StartHarborApproach(CargoNotifier cn)\n\t{\n\t\tif (Interface.CallHook(\u0022OnCargoShipHarborApproach\u0022, this, cn) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPlayHorn();\n\t\tisDoingHarborApproach = true;\n\t\tdockCount\u002B\u002B;\n\t\tshouldLookAhead = false;\n\t\tif (proxManager != null)\n\t\t{\n\t\t\tproxManager.StartMovement();\n\t\t}\n\t\tClearAllHarborEntitiesOnShip();\n\t\tforeach (HarborCraneContainerPickup allCrane in HarborCraneContainerPickup.AllCranes)\n\t\t{\n\t\t\tif (!(allCrane == null) \u0026\u0026 !allCrane.isClient \u0026\u0026 !(allCrane.Distance2D(harborApproachPath.nodes[harborApproachPath.nodes.Count / 2].Position) \u003E 150f))\n\t\t\t{\n\t\t\t\tallCrane.ReplenishContainers();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CargoShip",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemResearched(ResearchTable researchTable, int num)",
    "MethodSignature": "ResearchAttemptFinished()",
    "MethodSourseCode": "\n\tpublic void ResearchAttemptFinished()\n\t{\n\t\tItem targetItem = GetTargetItem();\n\t\tItem scrapItem = GetScrapItem();\n\t\tif (targetItem != null \u0026\u0026 scrapItem != null)\n\t\t{\n\t\t\tint num = ScrapForResearch(targetItem);\n\t\t\tobject obj = Interface.CallHook(\u0022OnItemResearched\u0022, this, num);\n\t\t\tif (obj is int)\n\t\t\t{\n\t\t\t\tnum = (int)obj;\n\t\t\t}\n\t\t\tif (scrapItem.amount \u003E= num)\n\t\t\t{\n\t\t\t\tif (scrapItem.amount == num)\n\t\t\t\t{\n\t\t\t\t\tbase.inventory.Remove(scrapItem);\n\t\t\t\t\tscrapItem.RemoveFromContainer();\n\t\t\t\t\tscrapItem.Remove();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tscrapItem.UseItem(num);\n\t\t\t\t}\n\t\t\t\tbase.inventory.Remove(targetItem);\n\t\t\t\ttargetItem.Remove();\n\t\t\t\tItem item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);\n\t\t\t\tif (base.LastLootedByPlayer != null)\n\t\t\t\t{\n\t\t\t\t\titem.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.ResearchTable);\n\t\t\t\t}\n\t\t\t\titem.blueprintTarget = ((targetItem.info.isRedirectOf != null) ? targetItem.info.isRedirectOf.itemid : targetItem.info.itemid);\n\t\t\t\tif (!item.MoveToContainer(base.inventory, 0))\n\t\t\t\t{\n\t\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t\tif (researchSuccessEffect.isValid)\n\t\t\t\t{\n\t\t\t\t\tEffect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSendNetworkUpdateImmediate();\n\t\tif (user != null)\n\t\t{\n\t\t\tuser.inventory.loot.SendImmediate();\n\t\t}\n\t\tEndResearch();\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnCardSwipe(CardReader cardReader, Keycard keycard, BasePlayer msgPlayer)",
    "MethodSignature": "ServerCardSwiped(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void ServerCardSwiped(RPCMessage msg)\n\t{\n\t\tif (!IsPowered() || Vector3Ex.Distance2D(msg.player.transform.position, base.transform.position) \u003E 1f || IsInvoking(GrantCard) || IsInvoking(FailCard) || HasFlag(Flags.On))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tNetworkableId uid = msg.read.EntityID();\n\t\tKeycard keycard = BaseNetworkable.serverEntities.Find(uid) as Keycard;\n\t\tEffect.server.Run(swipeEffect.resourcePath, audioPosition.position, Vector3.up, msg.player.net.connection);\n\t\tif (keycard == null || Interface.CallHook(\u0022OnCardSwipe\u0022, this, keycard, msg.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item = keycard.GetItem();\n\t\tif (item != null \u0026\u0026 !(item.parent.playerOwner != msg.player))\n\t\t{\n\t\t\tif (keycard.accessLevel == accessLevel \u0026\u0026 item.conditionNormalized \u003E 0f)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnKeycardSwiped(msg.player, this);\n\t\t\t\tInvoke(GrantCard, 0.5f);\n\t\t\t\titem.LoseCondition(1f);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tInvoke(FailCard, 0.5f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CardReader",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnVendingShopOpened(VendingMachine vendingMachine, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_OpenShop(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_OpenShop(RPCMessage msg)\n\t{\n\t\tif (OccupiedCheck(msg.player) \u0026\u0026 Interface.CallHook(\u0022OnVendingShopOpen\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tOpenShop(msg.player);\n\t\t\tInterface.CallHook(\u0022OnVendingShopOpened\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnTimedExplosiveExplode(TimedExplosive timedExplosive, UnityEngine.Vector3 explosionFxPos)",
    "MethodSignature": "Explode(Vector3 explosionFxPos)",
    "MethodSourseCode": "\n\tpublic virtual void Explode(Vector3 explosionFxPos)\n\t{\n\t\tFacepunch.Rust.Analytics.Azure.OnExplosion(this);\n\t\tCollider component = GetComponent\u003CCollider\u003E();\n\t\tif ((bool)component)\n\t\t{\n\t\t\tcomponent.enabled = false;\n\t\t}\n\t\tWaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(explosionFxPos - new Vector3(0f, 0.25f, 0f), waves: true, volumes: true);\n\t\tif (underwaterExplosionEffect.isValid \u0026\u0026 waterInfo.isValid \u0026\u0026 waterInfo.currentDepth \u003E= underwaterExplosionDepth)\n\t\t{\n\t\t\tEffect.server.Run(underwaterExplosionEffect.resourcePath, explosionFxPos, GetExplosionNormal(), null, broadcast: true);\n\t\t}\n\t\telse if (explosionEffect.isValid)\n\t\t{\n\t\t\tVector3 posWorld = explosionFxPos;\n\t\t\tif (explosionOffsetMode == ExplosionEffectOffsetMode.Local)\n\t\t\t{\n\t\t\t\tVector3 vector = base.transform.TransformPoint(explosionEffectOffset) - base.transform.position;\n\t\t\t\tposWorld \u002B= vector;\n\t\t\t}\n\t\t\tif (explosionOffsetMode == ExplosionEffectOffsetMode.World)\n\t\t\t{\n\t\t\t\tposWorld \u002B= explosionEffectOffset;\n\t\t\t}\n\t\t\tEffect.server.Run(explosionEffect.resourcePath, posWorld, GetExplosionNormal(), null, broadcast: true);\n\t\t}\n\t\tif (watersurfaceExplosionEffect.isValid \u0026\u0026 waterInfo.isValid \u0026\u0026 waterInfo.overallDepth \u003E= watersurfaceExplosionDepth.x \u0026\u0026 waterInfo.currentDepth \u003C= watersurfaceExplosionDepth.y)\n\t\t{\n\t\t\tEffect.server.Run(watersurfaceExplosionEffect.resourcePath, explosionFxPos.WithY(waterInfo.surfaceLevel), GetExplosionNormal(), null, broadcast: true);\n\t\t}\n\t\tif (GetDamageList(null).Count \u003E 0)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnTimedExplosiveExplode\u0022, this, explosionFxPos) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tVector3 vector2 = ExplosionCenter();\n\t\t\tif (onlyDamageParent)\n\t\t\t{\n\t\t\t\tint num = 166144;\n\t\t\t\tif (!ConVar.AntiHack.explosive_vehicle_parent_damage_deployables \u0026\u0026 parentEntity.Get(serverside: true) is BaseVehicle)\n\t\t\t\t{\n\t\t\t\t\tnum \u0026= -257;\n\t\t\t\t}\n\t\t\t\tDamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), vector2, minExplosionRadius, explosionRadius, GetDamageList(null), num, useLineOfSight: true, IgnoreAI, ignoreAttackingPlayer: false, extendedLineOfSight: false, playerDamage);\n\t\t\t\tBaseEntity baseEntity = GetParentEntity();\n\t\t\t\tBaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;\n\t\t\t\twhile (baseCombatEntity == null \u0026\u0026 baseEntity != null \u0026\u0026 baseEntity.HasParent())\n\t\t\t\t{\n\t\t\t\t\tbaseEntity = baseEntity.GetParentEntity();\n\t\t\t\t\tbaseCombatEntity = baseEntity as BaseCombatEntity;\n\t\t\t\t}\n\t\t\t\tif (baseEntity == null || !GameObjectEx.IsOnLayer(baseEntity.gameObject, Rust.Layer.Construction))\n\t\t\t\t{\n\t\t\t\t\tList\u003CBuildingBlock\u003E obj = Facepunch.Pool.Get\u003CList\u003CBuildingBlock\u003E\u003E();\n\t\t\t\t\tVis.Entities(vector2, explosionRadius, obj, 2097152, QueryTriggerInteraction.Ignore);\n\t\t\t\t\tBuildingBlock buildingBlock = null;\n\t\t\t\t\tfloat num2 = float.PositiveInfinity;\n\t\t\t\t\tforeach (BuildingBlock item in obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!item.isClient \u0026\u0026 !item.IsDestroyed \u0026\u0026 !(item.healthFraction \u003C= 0f))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat num3 = Vector3.Distance(item.ClosestPoint(vector2), vector2);\n\t\t\t\t\t\t\tif (num3 \u003C num2 \u0026\u0026 item.IsVisible(vector2, explosionRadius))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbuildingBlock = item;\n\t\t\t\t\t\t\t\tnum2 = num3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ((bool)buildingBlock)\n\t\t\t\t\t{\n\t\t\t\t\t\tHitInfo hitInfo = new HitInfo();\n\t\t\t\t\t\thitInfo.Initiator = creatorEntity;\n\t\t\t\t\t\thitInfo.WeaponPrefab = LookupPrefab();\n\t\t\t\t\t\thitInfo.damageTypes.Add(GetDamageList(buildingBlock));\n\t\t\t\t\t\thitInfo.PointStart = vector2;\n\t\t\t\t\t\thitInfo.PointEnd = buildingBlock.transform.position;\n\t\t\t\t\t\tfloat amount = 1f - Mathf.Clamp01((num2 - minExplosionRadius) / (explosionRadius - minExplosionRadius));\n\t\t\t\t\t\thitInfo.damageTypes.ScaleAll(amount);\n\t\t\t\t\t\tbuildingBlock.Hurt(hitInfo);\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t\t\t\t}\n\t\t\t\tif ((bool)baseCombatEntity)\n\t\t\t\t{\n\t\t\t\t\tHitInfo hitInfo2 = new HitInfo();\n\t\t\t\t\thitInfo2.Initiator = creatorEntity;\n\t\t\t\t\thitInfo2.WeaponPrefab = LookupPrefab();\n\t\t\t\t\thitInfo2.damageTypes.Add(GetDamageList(baseEntity));\n\t\t\t\t\tbaseCombatEntity.Hurt(hitInfo2);\n\t\t\t\t}\n\t\t\t\telse if (baseEntity != null)\n\t\t\t\t{\n\t\t\t\t\tHitInfo hitInfo3 = new HitInfo();\n\t\t\t\t\thitInfo3.Initiator = creatorEntity;\n\t\t\t\t\thitInfo3.WeaponPrefab = LookupPrefab();\n\t\t\t\t\thitInfo3.damageTypes.Add(GetDamageList(baseEntity));\n\t\t\t\t\thitInfo3.PointStart = vector2;\n\t\t\t\t\thitInfo3.PointEnd = baseEntity.transform.position;\n\t\t\t\t\tbaseEntity.OnAttacked(hitInfo3);\n\t\t\t\t}\n\t\t\t\tif (splashWallpaperThroughWalls)\n\t\t\t\t{\n\t\t\t\t\tList\u003CBuildingBlock\u003E obj2 = Facepunch.Pool.Get\u003CList\u003CBuildingBlock\u003E\u003E();\n\t\t\t\t\tVis.Entities(vector2, 3.4f, obj2, 2097152, QueryTriggerInteraction.Ignore);\n\t\t\t\t\tforeach (BuildingBlock item2 in obj2)\n\t\t\t\t\t{\n\t\t\t\t\t\titem2.RemoveWallpaper(0);\n\t\t\t\t\t\titem2.RemoveWallpaper(1);\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), vector2, minExplosionRadius, explosionRadius, GetDamageList(null), 1210222849, useLineOfSight: true, IgnoreAI, ignoreAttackingPlayer: false, extendedLineOfSight: false, playerDamage, splashWallpaperThroughWalls);\n\t\t\t}\n\t\t\tSeismicSensor.Notify(vector2, vibrationLevel);\n\t\t\tBlindAnyAI();\n\t\t}\n\t\tif (!base.IsDestroyed \u0026\u0026 !HasFlag(Flags.Broken) \u0026\u0026 !ConVar.Server.explosive_testing_mode)\n\t\t{\n\t\t\tKill(DestroyMode.Gib);\n\t\t}\n\t}\n",
    "ClassName": "TimedExplosive",
    "HookLineInvoke": 34
  },
  {
    "HookSignature": "OnInventoryNetworkUpdate(PlayerInventory playerInventory, ItemContainer container, ProtoBuf.UpdateItemContainer updateItemContainer, PlayerInventory.Type type, PlayerInventory.NetworkInventoryMode mode)",
    "MethodSignature": "SendUpdatedInventoryInternal(Type type, ItemContainer container, NetworkInventoryMode mode)",
    "MethodSourseCode": "\n\tpublic void SendUpdatedInventoryInternal(Type type, ItemContainer container, NetworkInventoryMode mode)\n\t{\n\t\tusing UpdateItemContainer updateItemContainer = Facepunch.Pool.Get\u003CUpdateItemContainer\u003E();\n\t\tupdateItemContainer.type = (int)type;\n\t\tif (base.baseEntity.IsSpectating())\n\t\t{\n\t\t\tmode = NetworkInventoryMode.LocalPlayer;\n\t\t}\n\t\tif (container != null)\n\t\t{\n\t\t\tcontainer.dirty = false;\n\t\t\tupdateItemContainer.container = Facepunch.Pool.Get\u003CList\u003CProtoBuf.ItemContainer\u003E\u003E();\n\t\t\tbool bIncludeContainer = type != Type.Wear || mode == NetworkInventoryMode.LocalPlayer;\n\t\t\tupdateItemContainer.container.Add(container.Save(bIncludeContainer));\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnInventoryNetworkUpdate\u0022, this, container, updateItemContainer, type, mode) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tswitch (mode)\n\t\t{\n\t\tcase NetworkInventoryMode.Everyone:\n\t\t\tbase.baseEntity.ClientRPC(RpcTarget.NetworkGroup(\u0022UpdatedItemContainer\u0022), updateItemContainer);\n\t\t\tbreak;\n\t\tcase NetworkInventoryMode.LocalPlayer:\n\t\t\tbase.baseEntity.ClientRPC(RpcTarget.Player(\u0022UpdatedItemContainer\u0022, base.baseEntity), updateItemContainer);\n\t\t\tbreak;\n\t\tcase NetworkInventoryMode.EveryoneButLocal:\n\t\t\tif (base.baseEntity.net?.group?.subscribers == null)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t{\n\t\t\t\tforeach (Connection subscriber in base.baseEntity.net.group.subscribers)\n\t\t\t\t{\n\t\t\t\t\tif (subscriber.player is BasePlayer basePlayer \u0026\u0026 basePlayer != base.baseEntity)\n\t\t\t\t\t{\n\t\t\t\t\t\tbase.baseEntity.ClientRPC(RpcTarget.Player(\u0022UpdatedItemContainer\u0022, basePlayer), updateItemContainer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "CanBypassQueue(Network.Connection connection)",
    "MethodSignature": "CanJumpQueue(Connection connection)",
    "MethodSourseCode": "\n\tprivate bool CanJumpQueue(Connection connection)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBypassQueue\u0022, connection);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (DeveloperList.Contains(connection.userid))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tServerUsers.User user = ServerUsers.Get(connection.userid);\n\t\tif (user != null \u0026\u0026 user.group == ServerUsers.UserGroup.Moderator)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (user != null \u0026\u0026 user.group == ServerUsers.UserGroup.Owner)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (user != null \u0026\u0026 user.group == ServerUsers.UserGroup.SkipQueue)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0; i \u003C reservedSlots.Count; i\u002B\u002B)\n\t\t{\n\t\t\tif (reservedSlots[i].UserId == connection.userid \u0026\u0026 reservedSlots[i].Expiry \u003E UnityEngine.Time.realtimeSinceStartup)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "ConnectionQueue",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanTakeCutting(BasePlayer player, GrowableEntity growableEntity)",
    "MethodSignature": "TakeClones(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void TakeClones(BasePlayer player)\n\t{\n\t\tif (player == null || !CanClone() || Interface.CallHook(\u0022CanTakeCutting\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = Properties.BaseCloneCount \u002B Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) / 2;\n\t\tif (num \u003E 0)\n\t\t{\n\t\t\tItem item = ItemManager.Create(Properties.CloneItem, num, 0uL);\n\t\t\titem.SetItemOwnership(player, ItemOwnershipPhrases.Cloned);\n\t\t\tGrowableGeneEncoding.EncodeGenesToItem(this, item);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);\n\t\t\tplayer.GiveItem(item, GiveItemReason.ResourceHarvested);\n\t\t\tif (Properties.pickEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tTellPlanter();\n\t\t\tDie();\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnMeleeAttack(BasePlayer player, HitInfo obj)",
    "MethodSignature": "PlayerAttack(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server]\n\tpublic void PlayerAttack(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientAttack(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022PlayerAttack\u0022, 50))\n\t\t{\n\t\t\tusing PlayerAttack playerAttack = msg.read.Proto\u003CPlayerAttack\u003E();\n\t\t\tif (playerAttack == null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tHitInfo obj = Facepunch.Pool.Get\u003CHitInfo\u003E();\n\t\t\tobj.LoadFromAttack(playerAttack.attack, serverSide: true);\n\t\t\tobj.Initiator = player;\n\t\t\tobj.Weapon = this;\n\t\t\tobj.WeaponPrefab = this;\n\t\t\tobj.Predicted = msg.connection;\n\t\t\tobj.damageProperties = damageProperties;\n\t\t\tif (Interface.CallHook(\u0022OnMeleeAttack\u0022, player, obj) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (obj.IsNaNOrInfinity())\n\t\t\t{\n\t\t\t\tstring shortPrefabName = base.ShortPrefabName;\n\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Contains NaN (\u0022 \u002B shortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.LogInvalid(obj, \u0022melee_nan\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBaseEntity hitEntity = obj.HitEntity;\n\t\t\tBasePlayer basePlayer = obj.HitEntity as BasePlayer;\n\t\t\tbool flag = basePlayer != null;\n\t\t\tbool flag2 = flag \u0026\u0026 basePlayer.IsSleeping();\n\t\t\tbool flag3 = flag \u0026\u0026 basePlayer.IsWounded();\n\t\t\tbool flag4 = flag \u0026\u0026 basePlayer.isMounted;\n\t\t\tbool flag5 = flag \u0026\u0026 basePlayer.HasParent();\n\t\t\tbool flag6 = hitEntity != null;\n\t\t\tbool flag7 = flag6 \u0026\u0026 hitEntity.IsNpc;\n\t\t\tbool flag8;\n\t\t\tint num5;\n\t\t\tVector3 center;\n\t\t\tVector3 position;\n\t\t\tVector3 pointStart;\n\t\t\tVector3 hitPositionWorld;\n\t\t\tVector3 vector;\n\t\t\tint num16;\n\t\t\tif (ConVar.AntiHack.melee_protection \u003E 0)\n\t\t\t{\n\t\t\t\tflag8 = true;\n\t\t\t\tfloat num = 1f \u002B ConVar.AntiHack.melee_forgiveness;\n\t\t\t\tfloat melee_clientframes = ConVar.AntiHack.melee_clientframes;\n\t\t\t\tfloat melee_serverframes = ConVar.AntiHack.melee_serverframes;\n\t\t\t\tfloat num2 = melee_clientframes / 60f;\n\t\t\t\tfloat num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);\n\t\t\t\tfloat num4 = (player.desyncTimeClamped \u002B num2 \u002B num3) * num;\n\t\t\t\tnum5 = 1075904512;\n\t\t\t\tif (ConVar.AntiHack.melee_terraincheck)\n\t\t\t\t{\n\t\t\t\t\tnum5 |= 0x800000;\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_vehiclecheck)\n\t\t\t\t{\n\t\t\t\t\tnum5 |= 0x8000000;\n\t\t\t\t}\n\t\t\t\tif (flag \u0026\u0026 obj.boneArea == (HitArea)(-1))\n\t\t\t\t{\n\t\t\t\t\tstring shortPrefabName2 = base.ShortPrefabName;\n\t\t\t\t\tstring shortPrefabName3 = basePlayer.ShortPrefabName;\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Bone is invalid  (\u0022 \u002B shortPrefabName2 \u002B \u0022 on \u0022 \u002B shortPrefabName3 \u002B \u0022 bone \u0022 \u002B obj.HitBone \u002B \u0022)\u0022);\n\t\t\t\t\tplayer.stats.combat.LogInvalid(obj, \u0022melee_bone\u0022);\n\t\t\t\t\tflag8 = false;\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 2)\n\t\t\t\t{\n\t\t\t\t\tif (flag6)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat num6 = hitEntity.MaxVelocity() \u002B hitEntity.GetParentVelocity().magnitude;\n\t\t\t\t\t\tfloat num7 = hitEntity.BoundsPadding() \u002B num4 * num6;\n\t\t\t\t\t\tfloat num8 = hitEntity.Distance(obj.HitPositionWorld);\n\t\t\t\t\t\tif (num8 \u003E num7)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName4 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring shortPrefabName5 = hitEntity.ShortPrefabName;\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Entity too far away (\u0022 \u002B shortPrefabName4 \u002B \u0022 on \u0022 \u002B shortPrefabName5 \u002B \u0022 with \u0022 \u002B num8 \u002B \u0022m \u003E \u0022 \u002B num7 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\n\t\t\t\t\t\t\tplayer.stats.combat.LogInvalid(obj, \u0022melee_target\u0022);\n\t\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 4 \u0026\u0026 flag8 \u0026\u0026 flag \u0026\u0026 !flag7 \u0026\u0026 !flag2 \u0026\u0026 !flag3 \u0026\u0026 !flag4 \u0026\u0026 !flag5)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat magnitude = basePlayer.GetParentVelocity().magnitude;\n\t\t\t\t\t\tfloat num9 = basePlayer.BoundsPadding() \u002B num4 * magnitude \u002B ConVar.AntiHack.tickhistoryforgiveness;\n\t\t\t\t\t\tfloat num10 = basePlayer.tickHistory.Distance(basePlayer, obj.HitPositionWorld);\n\t\t\t\t\t\tif (num10 \u003E num9)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName6 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring shortPrefabName7 = basePlayer.ShortPrefabName;\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Player too far away (\u0022 \u002B shortPrefabName6 \u002B \u0022 on \u0022 \u002B shortPrefabName7 \u002B \u0022 with \u0022 \u002B num10 \u002B \u0022m \u003E \u0022 \u002B num9 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\n\t\t\t\t\t\t\tplayer.stats.combat.LogInvalid(obj, \u0022player_distance\u0022);\n\t\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 1)\n\t\t\t\t{\n\t\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat magnitude2 = player.GetParentVelocity().magnitude;\n\t\t\t\t\t\tfloat num11 = player.BoundsPadding() \u002B num4 * magnitude2 \u002B num * maxDistance;\n\t\t\t\t\t\tfloat num12 = player.tickHistory.Distance(player, obj.HitPositionWorld);\n\t\t\t\t\t\tif (num12 \u003E num11)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName8 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring text = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Initiator too far away (\u0022 \u002B shortPrefabName8 \u002B \u0022 on \u0022 \u002B text \u002B \u0022 with \u0022 \u002B num12 \u002B \u0022m \u003E \u0022 \u002B num11 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\n\t\t\t\t\t\t\tplayer.stats.combat.LogInvalid(obj, \u0022melee_initiator\u0022);\n\t\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat num13 = player.MaxVelocity() \u002B player.GetParentVelocity().magnitude;\n\t\t\t\t\t\tfloat num14 = player.BoundsPadding() \u002B num4 * num13 \u002B num * maxDistance;\n\t\t\t\t\t\tfloat num15 = player.Distance(obj.HitPositionWorld);\n\t\t\t\t\t\tif (num15 \u003E num14)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName9 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring text2 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Initiator too far away (\u0022 \u002B shortPrefabName9 \u002B \u0022 on \u0022 \u002B text2 \u002B \u0022 with \u0022 \u002B num15 \u002B \u0022m \u003E \u0022 \u002B num14 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\n\t\t\t\t\t\t\tplayer.stats.combat.LogInvalid(obj, \u0022melee_initiator\u0022);\n\t\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 3)\n\t\t\t\t{\n\t\t\t\t\tif (flag6)\n\t\t\t\t\t{\n\t\t\t\t\t\tcenter = player.eyes.center;\n\t\t\t\t\t\tposition = player.eyes.position;\n\t\t\t\t\t\tpointStart = obj.PointStart;\n\t\t\t\t\t\thitPositionWorld = obj.HitPositionWorld;\n\t\t\t\t\t\thitPositionWorld -= (hitPositionWorld - pointStart).normalized * 0.001f;\n\t\t\t\t\t\tvector = obj.PositionOnRay(hitPositionWorld);\n\t\t\t\t\t\tVector3 vector2 = Vector3.zero;\n\t\t\t\t\t\tVector3 vector3 = Vector3.zero;\n\t\t\t\t\t\tVector3 vector4 = Vector3.zero;\n\t\t\t\t\t\tif (ConVar.AntiHack.melee_backtracking \u003E 0f)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvector2 = (position - center).normalized * ConVar.AntiHack.melee_backtracking;\n\t\t\t\t\t\t\tvector3 = (pointStart - position).normalized * ConVar.AntiHack.melee_backtracking;\n\t\t\t\t\t\t\tvector4 = (vector - pointStart).normalized * ConVar.AntiHack.melee_backtracking;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (GamePhysics.LineOfSight(center - vector2, position \u002B vector2, num5) \u0026\u0026 GamePhysics.LineOfSight(position - vector3, pointStart \u002B vector3, num5) \u0026\u0026 GamePhysics.LineOfSight(pointStart - vector4, vector, num5) \u0026\u0026 GamePhysics.LineOfSight(vector, hitPositionWorld, num5))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum16 = (GamePhysics.LineOfSight(position, hitPositionWorld, num5) ? 1 : 0);\n\t\t\t\t\t\t\tif (num16 != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tplayer.stats.Add(\u0022hit_\u0022 \u002B hitEntity.Categorize() \u002B \u0022_direct_los\u0022, 1, Stats.Server);\n\t\t\t\t\t\t\t\tgoto IL_07d6;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum16 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplayer.stats.Add(\u0022hit_\u0022 \u002B hitEntity.Categorize() \u002B \u0022_indirect_los\u0022, 1, Stats.Server);\n\t\t\t\t\t\tgoto IL_07d6;\n\t\t\t\t\t}\n\t\t\t\t\tgoto IL_08c4;\n\t\t\t\t}\n\t\t\t\tgoto IL_0a2b;\n\t\t\t}\n\t\t\tgoto IL_0a3e;\n\t\t\tIL_08c4:\n\t\t\tif (flag8 \u0026\u0026 flag \u0026\u0026 !flag7)\n\t\t\t{\n\t\t\t\tVector3 hitPositionWorld2 = obj.HitPositionWorld;\n\t\t\t\tVector3 position2 = basePlayer.eyes.position;\n\t\t\t\tVector3 vector5 = basePlayer.CenterPoint();\n\t\t\t\tfloat melee_losforgiveness = ConVar.AntiHack.melee_losforgiveness;\n\t\t\t\tbool flag9 = GamePhysics.LineOfSight(hitPositionWorld2, position2, num5, 0f, melee_losforgiveness) \u0026\u0026 GamePhysics.LineOfSight(position2, hitPositionWorld2, num5, melee_losforgiveness, 0f);\n\t\t\t\tif (!flag9)\n\t\t\t\t{\n\t\t\t\t\tflag9 = GamePhysics.LineOfSight(hitPositionWorld2, vector5, num5, 0f, melee_losforgiveness) \u0026\u0026 GamePhysics.LineOfSight(vector5, hitPositionWorld2, num5, melee_losforgiveness, 0f);\n\t\t\t\t}\n\t\t\t\tif (!flag9)\n\t\t\t\t{\n\t\t\t\t\tstring shortPrefabName10 = base.ShortPrefabName;\n\t\t\t\t\tstring shortPrefabName11 = basePlayer.ShortPrefabName;\n\t\t\t\t\tstring[] obj2 = new string[12]\n\t\t\t\t\t{\n\t\t\t\t\t\t\u0022Line of sight (\u0022, shortPrefabName10, \u0022 on \u0022, shortPrefabName11, \u0022) \u0022, null, null, null, null, null,\n\t\t\t\t\t\tnull, null\n\t\t\t\t\t};\n\t\t\t\t\tVector3 vector6 = hitPositionWorld2;\n\t\t\t\t\tobj2[5] = vector6.ToString();\n\t\t\t\t\tobj2[6] = \u0022 \u0022;\n\t\t\t\t\tvector6 = position2;\n\t\t\t\t\tobj2[7] = vector6.ToString();\n\t\t\t\t\tobj2[8] = \u0022 or \u0022;\n\t\t\t\t\tvector6 = hitPositionWorld2;\n\t\t\t\t\tobj2[9] = vector6.ToString();\n\t\t\t\t\tobj2[10] = \u0022 \u0022;\n\t\t\t\t\tvector6 = vector5;\n\t\t\t\t\tobj2[11] = vector6.ToString();\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(obj2));\n\t\t\t\t\tplayer.stats.combat.LogInvalid(obj, \u0022melee_los\u0022);\n\t\t\t\t\tflag8 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto IL_0a2b;\n\t\t\tIL_0a2b:\n\t\t\tif (!flag8)\n\t\t\t{\n\t\t\t\tAntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgoto IL_0a3e;\n\t\t\tIL_07d6:\n\t\t\tif (num16 == 0)\n\t\t\t{\n\t\t\t\tstring shortPrefabName12 = base.ShortPrefabName;\n\t\t\t\tstring shortPrefabName13 = hitEntity.ShortPrefabName;\n\t\t\t\tstring[] obj3 = new string[14]\n\t\t\t\t{\n\t\t\t\t\t\u0022Line of sight (\u0022, shortPrefabName12, \u0022 on \u0022, shortPrefabName13, \u0022) \u0022, null, null, null, null, null,\n\t\t\t\t\tnull, null, null, null\n\t\t\t\t};\n\t\t\t\tVector3 vector6 = center;\n\t\t\t\tobj3[5] = vector6.ToString();\n\t\t\t\tobj3[6] = \u0022 \u0022;\n\t\t\t\tvector6 = position;\n\t\t\t\tobj3[7] = vector6.ToString();\n\t\t\t\tobj3[8] = \u0022 \u0022;\n\t\t\t\tvector6 = pointStart;\n\t\t\t\tobj3[9] = vector6.ToString();\n\t\t\t\tobj3[10] = \u0022 \u0022;\n\t\t\t\tvector6 = vector;\n\t\t\t\tobj3[11] = vector6.ToString();\n\t\t\t\tobj3[12] = \u0022 \u0022;\n\t\t\t\tvector6 = hitPositionWorld;\n\t\t\t\tobj3[13] = vector6.ToString();\n\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(obj3));\n\t\t\t\tplayer.stats.combat.LogInvalid(obj, \u0022melee_los\u0022);\n\t\t\t\tflag8 = false;\n\t\t\t}\n\t\t\tgoto IL_08c4;\n\t\t\tIL_0a3e:\n\t\t\tplayer.metabolism.UseHeart(heartStress * 0.2f);\n\t\t\tusing (TimeWarning.New(\u0022DoAttackShared\u0022, 50))\n\t\t\t{\n\t\t\t\tDoAttackShared(obj);\n\t\t\t}\n\t\t\tFacepunch.Pool.Free(ref obj);\n\t\t}\n\t}\n",
    "ClassName": "BaseMelee",
    "HookLineInvoke": 25
  },
  {
    "HookSignature": "OnSignalBroadcast(BaseEntity baseEntity)",
    "MethodSignature": "SignalBroadcast(Signal signal, Connection sourceConnection)",
    "MethodSourseCode": "\n\tpublic void SignalBroadcast(Signal signal, Connection sourceConnection = null)\n\t{\n\t\tif (net != null \u0026\u0026 net.group != null \u0026\u0026 !base.limitNetworking \u0026\u0026 Interface.CallHook(\u0022OnSignalBroadcast\u0022, this) == null)\n\t\t{\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022SignalFromServer\u0022, this, SendMethod.Unreliable, Priority.Immediate), (int)signal, sourceConnection?.userid ?? 0);\n\t\t}\n\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnElevatorButtonPress(ElevatorLift elevatorLift, BasePlayer msgPlayer, Elevator.Direction direction, bool flag)",
    "MethodSignature": "Server_RaiseLowerFloor(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void Server_RaiseLowerFloor(RPCMessage msg)\n\t{\n\t\tElevator.Direction direction = (Elevator.Direction)msg.read.Int32();\n\t\tbool flag = msg.read.Unread \u003E 0 \u0026\u0026 msg.read.Bit();\n\t\tif (Interface.CallHook(\u0022OnElevatorButtonPress\u0022, this, msg.player, direction, flag) == null)\n\t\t{\n\t\t\tSetFlag((direction == Elevator.Direction.Up) ? Flags.Reserved1 : Flags.Reserved2, b: true);\n\t\t\tSetFlag(Flags.Reserved6, flag);\n\t\t\towner.Server_RaiseLowerElevator(direction, flag);\n\t\t\tInvoke(ClearDirection, 0.7f);\n\t\t\tif (liftButtonPressedEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(liftButtonPressedEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ElevatorLift",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnLiquidWeaponFired(LiquidWeapon liquidWeapon, BasePlayer player)",
    "MethodSignature": "StartFiring(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server]\n\tprivate void StartFiring(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (OnCooldown())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!RequiresPumping)\n\t\t{\n\t\t\tpressure = MaxPressure;\n\t\t}\n\t\tif (CanFire(player))\n\t\t{\n\t\t\tCancelInvoke(FireTick);\n\t\t\tInvokeRepeating(FireTick, 0f, FireRate);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tStartCooldown(FireRate);\n\t\t\tif (base.isServer)\n\t\t\t{\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnLiquidWeaponFired\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "LiquidWeapon",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnSleepingBagValidCheck(SleepingBag sleepingBag, ulong playerID, bool ignoreTimers)",
    "MethodSignature": "ValidForPlayer(ulong playerID, bool ignoreTimers)",
    "MethodSourseCode": "\n\tpublic virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnSleepingBagValidCheck\u0022, this, playerID, ignoreTimers);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (deployerUserID == playerID)\n\t\t{\n\t\t\tif (!ignoreTimers)\n\t\t\t{\n\t\t\t\treturn unlockTime \u003C UnityEngine.Time.realtimeSinceStartup;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnWallpaperRemove(BuildingBlock buildingBlock, int side)",
    "MethodSignature": "RemoveWallpaper(int side)",
    "MethodSourseCode": "\n\tpublic void RemoveWallpaper(int side)\n\t{\n\t\tif (Interface.CallHook(\u0022OnWallpaperRemove\u0022, this, side) == null)\n\t\t{\n\t\t\tswitch (side)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\twallpaperHealth = -1f;\n\t\t\t\twallpaperID = 0uL;\n\t\t\t\twallpaperRotation = 0f;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\twallpaperHealth2 = -1f;\n\t\t\t\twallpaperID2 = 0uL;\n\t\t\t\twallpaperRotation2 = 0f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (base.isServer)\n\t\t\t{\n\t\t\t\tSetConditionalModel(currentSkin.DetermineConditionalModelState(this));\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022RefreshSkin\u0022));\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPhoneDial(PhoneController phoneController, PhoneController telephone, BasePlayer currentPlayer)",
    "MethodSignature": "CallPhone(int number)",
    "MethodSourseCode": "\n\tpublic void CallPhone(int number)\n\t{\n\t\tif (number == PhoneNumber)\n\t\t{\n\t\t\tOnDialFailed(Telephone.DialFailReason.CallSelf);\n\t\t\treturn;\n\t\t}\n\t\tif (TelephoneManager.GetCurrentActiveCalls() \u002B 1 \u003E TelephoneManager.MaxConcurrentCalls)\n\t\t{\n\t\t\tOnDialFailed(Telephone.DialFailReason.NetworkBusy);\n\t\t\treturn;\n\t\t}\n\t\tPhoneController telephone = TelephoneManager.GetTelephone(number);\n\t\tif (telephone != null)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnPhoneDial\u0022, this, telephone, currentPlayer) == null)\n\t\t\t{\n\t\t\t\tif (telephone.serverState == Telephone.CallState.Idle \u0026\u0026 telephone.CanReceiveCall())\n\t\t\t\t{\n\t\t\t\t\tSetPhoneState(Telephone.CallState.Dialing);\n\t\t\t\t\tlastDialedNumber = number;\n\t\t\t\t\tactiveCallTo = telephone;\n\t\t\t\t\tactiveCallTo.ReceiveCallFrom(this);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tOnDialFailed(Telephone.DialFailReason.Engaged);\n\t\t\t\t\ttelephone.OnIncomingCallWhileBusy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOnDialFailed(Telephone.DialFailReason.WrongNumber);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "CanUseVending(BasePlayer player, VendingMachine vendingMachine)",
    "MethodSignature": "CanOpenLootPanel(BasePlayer player, string panelName)",
    "MethodSourseCode": "\n\tpublic override bool CanOpenLootPanel(BasePlayer player, string panelName)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseVending\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (panelName == customerPanel)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (base.CanOpenLootPanel(player, panelName))\n\t\t{\n\t\t\treturn CanPlayerAdmin(player);\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSprinklerSplashed(Sprinkler sprinkler)",
    "MethodSignature": "DoSplash()",
    "MethodSourseCode": "\n\tprivate void DoSplash()\n\t{\n\t\tusing (TimeWarning.New(\u0022SprinklerSplash\u0022))\n\t\t{\n\t\t\tint num = WaterPerSplash;\n\t\t\tif ((float)updateSplashableCache \u003E SplashFrequency * 4f || forceUpdateSplashables)\n\t\t\t{\n\t\t\t\tcachedSplashables.Clear();\n\t\t\t\tforceUpdateSplashables = false;\n\t\t\t\tupdateSplashableCache = 0f;\n\t\t\t\tVector3 position = Eyes.position;\n\t\t\t\tVector3 up = base.transform.up;\n\t\t\t\tfloat sprinklerEyeHeightOffset = Server.sprinklerEyeHeightOffset;\n\t\t\t\tfloat value = Vector3.Angle(up, Vector3.up) / 180f;\n\t\t\t\tvalue = Mathf.Clamp(value, 0.2f, 1f);\n\t\t\t\tsprinklerEyeHeightOffset *= value;\n\t\t\t\tVector3 startPosition = position \u002B up * (Server.sprinklerRadius * 0.5f);\n\t\t\t\tVector3 endPosition = position \u002B up * sprinklerEyeHeightOffset;\n\t\t\t\tList\u003CBaseEntity\u003E obj = Facepunch.Pool.Get\u003CList\u003CBaseEntity\u003E\u003E();\n\t\t\t\tVis.Entities(startPosition, endPosition, Server.sprinklerRadius, obj, 1237003025);\n\t\t\t\tif (obj.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tforeach (BaseEntity item in obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!item.isClient \u0026\u0026 item is ISplashable splashable \u0026\u0026 !cachedSplashables.Contains(splashable) \u0026\u0026 splashable.WantsSplash(currentFuelType, num) \u0026\u0026 item.IsVisible(position) \u0026\u0026 (!(item is IOEntity entity) || !IsConnectedTo(entity, IOEntity.backtracking)) \u0026\u0026 (!(item is BasePlayer) || !(currentFuelType.baseRadioactivity \u003E 0f)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcachedSplashables.Add(splashable);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t\t\t}\n\t\t\tif (cachedSplashables.Count \u003E 0)\n\t\t\t{\n\t\t\t\tint num2 = num / cachedSplashables.Count;\n\t\t\t\tfloat num3 = (float)(num % cachedSplashables.Count) / (float)cachedSplashables.Count;\n\t\t\t\tforeach (ISplashable cachedSplashable in cachedSplashables)\n\t\t\t\t{\n\t\t\t\t\tint amount = num2 \u002B ((UnityEngine.Random.value \u003C num3) ? 1 : 0);\n\t\t\t\t\tif (!ObjectEx.IsUnityNull(cachedSplashable) \u0026\u0026 cachedSplashable.WantsSplash(currentFuelType, amount))\n\t\t\t\t\t{\n\t\t\t\t\t\tint num4 = cachedSplashable.DoSplash(currentFuelType, amount);\n\t\t\t\t\t\tnum -= num4;\n\t\t\t\t\t\tif (num \u003C= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (DecayPerSplash \u003E 0f)\n\t\t\t{\n\t\t\t\tHurt(DecayPerSplash);\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnSprinklerSplashed\u0022, this);\n\t}\n",
    "ClassName": "Sprinkler",
    "HookLineInvoke": 56
  },
  {
    "HookSignature": "CanDismountEntity(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "DismountPlayer(BasePlayer player, bool lite)",
    "MethodSourseCode": "\n\tpublic void DismountPlayer(BasePlayer player, bool lite = false)\n\t{\n\t\tif (_mounted == null || _mounted != player || Interface.CallHook(\u0022CanDismountEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseVehicle baseVehicle = VehicleParent();\n\t\tif (lite)\n\t\t{\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PrePlayerDismount(player, this);\n\t\t\t}\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted = null;\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t\tOnPlayerDismounted(player);\n\t\t\tInterface.CallHook(\u0022OnEntityDismounted\u0022, this, player);\n\t\t\treturn;\n\t\t}\n\t\tif (!GetDismountPosition(player, out var res) || Distance(res) \u003E 10f)\n\t\t{\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PrePlayerDismount(player, this);\n\t\t\t}\n\t\t\tres = player.transform.position;\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted.MovePosition(res);\n\t\t\t_mounted.transform.rotation = Quaternion.identity;\n\t\t\t_mounted.ClientRPC(RpcTarget.Player(\u0022ForcePositionTo\u0022, _mounted), res);\n\t\t\tBasePlayer mounted = _mounted;\n\t\t\t_mounted = null;\n\t\t\tDebug.LogWarning(\u0022Killing player due to invalid dismount point :\u0022 \u002B player.displayName \u002B \u0022 / \u0022 \u002B player.userID.Get() \u002B \u0022 on obj : \u0022 \u002B base.gameObject.name);\n\t\t\tmounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t\tOnPlayerDismounted(player);\n\t\t\treturn;\n\t\t}\n\t\tif (baseVehicle != null)\n\t\t{\n\t\t\tbaseVehicle.PrePlayerDismount(player, this);\n\t\t}\n\t\tif (AntiHack.TestNoClipping(_mounted, res, res, BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _, vehicleLayer: true))\n\t\t{\n\t\t\t_mounted.PauseVehicleNoClipDetection(5f);\n\t\t}\n\t\t_mounted.DismountObject();\n\t\t_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);\n\t\t_mounted.OverrideViewAngles(Vector3.zero);\n\t\t_mounted.MovePosition(res);\n\t\t_mounted.SendNetworkUpdateImmediate();\n\t\t_mounted.SendModelState(force: true);\n\t\t_mounted = null;\n\t\tif (baseVehicle != null)\n\t\t{\n\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t}\n\t\tplayer.ForceUpdateTriggers();\n\t\tif ((bool)player.GetParentEntity())\n\t\t{\n\t\t\tBaseEntity baseEntity = player.GetParentEntity();\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022ForcePositionToParentOffset\u0022, player), baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022ForcePositionTo\u0022, player), res);\n\t\t\tplayer.ClientRPC(RpcTarget.NetworkGroup(\u0022ForceResetRotation\u0022, player));\n\t\t}\n\t\tFacepunch.Rust.Analytics.Azure.OnDismountEntity(player, this, baseVehicle);\n\t\tInterface.CallHook(\u0022OnEntityDismounted\u0022, this, player);\n\t\tOnPlayerDismounted(player);\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDispenserBonus(ResourceDispenser resourceDispenser, BasePlayer player, Item item)",
    "MethodSignature": "AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)",
    "MethodSourseCode": "\n\tpublic void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)\n\t{\n\t\tif (forceFullFinishBonus)\n\t\t{\n\t\t\tfraction = 1f;\n\t\t}\n\t\tSendMessage(\u0022FinishBonusAssigned\u0022, SendMessageOptions.DontRequireReceiver);\n\t\tif (fraction \u003C= 0f || finishBonus == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (ItemAmount finishBonu in finishBonus)\n\t\t{\n\t\t\tint num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));\n\t\t\tint num2 = CalculateGatherBonus(player, finishBonu, num);\n\t\t\tItem item = ItemManager.Create(finishBonu.itemDef, num \u002B num2, 0uL);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnDispenserBonus\u0022, this, player, item);\n\t\t\t\tif (obj is Item)\n\t\t\t\t{\n\t\t\t\t\titem = (Item)obj;\n\t\t\t\t}\n\t\t\t\tApplyItemOwnership(player, item);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);\n\t\t\t\tInterface.CallHook(\u0022OnDispenserBonusReceived\u0022, this, player, item);\n\t\t\t\twhile (item.amount \u003E item.MaxStackable())\n\t\t\t\t{\n\t\t\t\t\tItem item2 = item.SplitItem(item.MaxStackable());\n\t\t\t\t\tplayer.GiveItem(item2, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t\t\t}\n\t\t\t\tplayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ResourceDispenser",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "CanUnlock(BasePlayer player, ModularCarCodeLock modularCarCodeLock, string codeEntered)",
    "MethodSignature": "TryOpenWithCode(BasePlayer player, string codeEntered)",
    "MethodSourseCode": "\n\tpublic bool TryOpenWithCode(BasePlayer player, string codeEntered)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUnlock\u0022, player, this, codeEntered);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (CodeEntryBlocked(player))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!(codeEntered == Code))\n\t\t{\n\t\t\tif (Time.realtimeSinceStartup \u003E lastWrongTime \u002B 60f)\n\t\t\t{\n\t\t\t\twrongCodes = 0;\n\t\t\t}\n\t\t\tplayer.Hurt((float)(wrongCodes \u002B 1) * 5f, DamageType.ElectricShock, owner, useProtection: false);\n\t\t\twrongCodes\u002B\u002B;\n\t\t\tif (wrongCodes \u003E 5)\n\t\t\t{\n\t\t\t\tplayer.ShowToast(GameTip.Styles.Red_Normal, CodeLock.blockwarning, false);\n\t\t\t}\n\t\t\tif ((float)wrongCodes \u003E= CodeLock.maxFailedAttempts)\n\t\t\t{\n\t\t\t\towner.SetFlag(BaseEntity.Flags.Reserved10, b: true);\n\t\t\t\towner.Invoke(ClearCodeEntryBlocked, CodeLock.lockoutCooldown);\n\t\t\t}\n\t\t\tlastWrongTime = Time.realtimeSinceStartup;\n\t\t\treturn false;\n\t\t}\n\t\tif (TryAddPlayer(player.userID))\n\t\t{\n\t\t\twrongCodes = 0;\n\t\t}\n\t\towner.SendNetworkUpdate();\n\t\treturn true;\n\t}\n",
    "ClassName": "ModularCarCodeLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanStackItem(Item item, Item item)",
    "MethodSignature": "CanStack(Item item)",
    "MethodSourseCode": "\n\tpublic bool CanStack(Item item)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanStackItem\u0022, this, item);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (item == this)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (MaxStackable() \u003C= 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.info.stackable \u003C= 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.info.itemid != info.itemid)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (hasCondition \u0026\u0026 condition != item.info.condition.max)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.hasCondition \u0026\u0026 item.condition != item.info.condition.max)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsValid())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsBlueprint() \u0026\u0026 blueprintTarget != item.blueprintTarget)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.skin != skin)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.info.amountType == ItemDefinition.AmountType.Genetics || info.amountType == ItemDefinition.AmountType.Genetics)\n\t\t{\n\t\t\tint num = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));\n\t\t\tint num2 = ((instanceData != null) ? instanceData.dataInt : (-1));\n\t\t\tif (num != num2)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (item.instanceData != null \u0026\u0026 instanceData != null \u0026\u0026 (item.IsOn() != IsOn() || (item.instanceData.dataInt != instanceData.dataInt \u0026\u0026 item.info.Blueprint != null \u0026\u0026 item.info.Blueprint.GetWorkbenchLevel() == 3)))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (instanceData != null \u0026\u0026 instanceData.subEntity.IsValid \u0026\u0026 (bool)info.GetComponent\u003CItemModSign\u003E())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.instanceData != null \u0026\u0026 item.instanceData.subEntity.IsValid \u0026\u0026 (bool)item.info.GetComponent\u003CItemModSign\u003E())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (BlockStackFoodItem(item, this))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTrapTrigger(BearTrap bearTrap, UnityEngine.GameObject obj)",
    "MethodSignature": "ObjectEntered(GameObject obj)",
    "MethodSourseCode": "\n\tpublic override void ObjectEntered(GameObject obj)\n\t{\n\t\tif (Armed() \u0026\u0026 Interface.CallHook(\u0022OnTrapTrigger\u0022, this, obj) == null)\n\t\t{\n\t\t\thurtTarget = obj;\n\t\t\tInvoke(DelayedFire, 0.05f);\n\t\t}\n\t}\n",
    "ClassName": "BearTrap",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerRevive(BasePlayer getOwnerPlayer, BasePlayer player)",
    "MethodSignature": "GiveEffectsTo(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate void GiveEffectsTo(BasePlayer player)\n\t{\n\t\tif (!player)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition ownerItemDefinition = GetOwnerItemDefinition();\n\t\tItemModConsumable component = ownerItemDefinition.GetComponent\u003CItemModConsumable\u003E();\n\t\tif (!component)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022No consumable for medicaltool :\u0022 \u002B base.name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnHealingItemUse\u0022, this, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\t\tFacepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);\n\t\t\tif (player != ownerPlayer)\n\t\t\t{\n\t\t\t\tif (Interface.CallHook(\u0022OnPlayerRevive\u0022, GetOwnerPlayer(), player) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (player.IsWounded() \u0026\u0026 canRevive)\n\t\t\t\t{\n\t\t\t\t\tplayer.StopWounded(ownerPlayer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach (ItemModConsumable.ConsumableEffect effect in component.effects)\n\t\t\t{\n\t\t\t\tif (effect.type == MetabolismAttribute.Type.Health)\n\t\t\t\t{\n\t\t\t\t\tplayer.health \u002B= effect.amount;\n\t\t\t\t\tplayer.ProcessMissionEvent(BaseMission.MissionEventType.HEAL, prefabID, effect.amount);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (player is BasePet)\n\t\t\t{\n\t\t\t\tplayer.SendNetworkUpdateImmediate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MedicalTool",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnBonusItemDropped(Item item, BasePlayer basePlayer, ItemContainer container)",
    "MethodSignature": "DropBonusItems(BaseEntity initiator, ItemContainer container)",
    "MethodSourseCode": "\n\tpublic override void DropBonusItems(BaseEntity initiator, ItemContainer container)\n\t{\n\t\tbase.DropBonusItems(initiator, container);\n\t\tif (initiator == null || container == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer = initiator as BasePlayer;\n\t\tif (basePlayer == null || scrapAmount \u003C= 0 || !(scrapDef != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = ((basePlayer.modifiers != null) ? (1f \u002B basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\n\t\tif (!(num \u003E 1f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\n\t\tfloat num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\n\t\tvariableValue \u002B= num2;\n\t\tint num3 = 0;\n\t\tif (variableValue \u003E= 1f)\n\t\t{\n\t\t\tnum3 = (int)variableValue;\n\t\t\tvariableValue -= (float)num3;\n\t\t}\n\t\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\n\t\tif (num3 \u003E 0)\n\t\t{\n\t\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\n\t\t\tif (item != null \u0026\u0026 Interface.CallHook(\u0022OnBonusItemDrop\u0022, item, basePlayer, container) == null)\n\t\t\t{\n\t\t\t\t(item.Drop(GetDropPosition() \u002B new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;\n\t\t\t\tInterface.CallHook(\u0022OnBonusItemDropped\u0022, item, basePlayer, container);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "LootContainer",
    "HookLineInvoke": 34
  },
  {
    "HookSignature": "OnFeedbackReported(BasePlayer basePlayer, string text, string text2, Facepunch.Models.ReportType reportType)",
    "MethodSignature": "OnFeedbackReport(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner(false)]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\tpublic async void OnFeedbackReport(RPCMessage msg)\n\t{\n\t\ttry\n\t\t{\n\t\t\tstring text = msg.read.String();\n\t\t\tstring text2 = msg.read.StringMultiLine();\n\t\t\tstring text3 = ((text2 != null \u0026\u0026 text2.Length \u003E 1400) ? text2.Substring(0, 1400) : text2);\n\t\t\tReportType reportType = (ReportType)Mathf.Clamp(msg.read.Int32(), 0, 6);\n\t\t\tif (ConVar.Server.printReportsToConsole)\n\t\t\t{\n\t\t\t\tDebugEx.Log($\u0022[FeedbackReport] {this} reported {reportType} - \\\u0022{text}\\\u0022 \\\u0022{text3}\\\u0022\u0022);\n\t\t\t\tRCon.Broadcast(RCon.LogType.Report, new\n\t\t\t\t{\n\t\t\t\t\tPlayerId = UserIDString,\n\t\t\t\t\tPlayerName = displayName,\n\t\t\t\t\tSubject = text,\n\t\t\t\t\tMessage = text3,\n\t\t\t\t\tType = reportType\n\t\t\t\t});\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnFeedbackReported\u0022, this, text, text2, reportType);\n\t\t\tif (!string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))\n\t\t\t{\n\t\t\t\tstring image = msg.read.StringMultiLine(60000);\n\t\t\t\tFacepunch.Models.Feedback feedback = default(Facepunch.Models.Feedback);\n\t\t\t\tfeedback.Type = reportType;\n\t\t\t\tfeedback.Message = text3;\n\t\t\t\tfeedback.Subject = text;\n\t\t\t\tFacepunch.Models.Feedback feedback2 = feedback;\n\t\t\t\tfeedback2.AppInfo.Image = image;\n\t\t\t\tDebugEx.Log(\u0022[OnFeedbackReport to endpoint] \u0022 \u002B await Facepunch.Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, userID, ConVar.Server.reportsServerEndpointKey, feedback2));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022[OnFeedbackReport] Exception occurred when sending F7 report to endpoint: \u0022 \u002B ex.Message);\n\t\t\tDebug.LogException(ex);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, StorageContainer storageContainer)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t\tSetFlag(Flags.Open, b: false);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "StorageContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnActiveTelephoneUpdated(BasePlayer basePlayer, PhoneController t)",
    "MethodSignature": "SetActiveTelephone(PhoneController t)",
    "MethodSourseCode": "\n\tpublic void SetActiveTelephone(PhoneController t)\n\t{\n\t\tactiveTelephone = t;\n\t\tInterface.CallHook(\u0022OnActiveTelephoneUpdated\u0022, this, t);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanResearchItem(BasePlayer player, Item targetItem)",
    "MethodSignature": "DoResearch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void DoResearch(RPCMessage msg)\n\t{\n\t\tif (IsResearching())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tItem targetItem = GetTargetItem();\n\t\tif (targetItem != null \u0026\u0026 Interface.CallHook(\u0022CanResearchItem\u0022, player, targetItem) == null \u0026\u0026 targetItem.amount \u003C= 1 \u0026\u0026 IsItemResearchable(targetItem))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnItemResearch\u0022, this, targetItem, player);\n\t\t\ttargetItem.CollectedForCrafting(player);\n\t\t\tresearchFinishedTime = UnityEngine.Time.realtimeSinceStartup \u002B researchDuration;\n\t\t\tInvoke(ResearchAttemptFinished, researchDuration);\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tint scrapCost = ScrapForResearch(targetItem);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tif (researchStartEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t\tmsg.player.GiveAchievement(\u0022RESEARCH_ITEM\u0022);\n\t\t}\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnEntityStabilityCheck(StabilityEntity stabilityEntity)",
    "MethodSignature": "StabilityCheck()",
    "MethodSourseCode": "\n\tpublic virtual void StabilityCheck()\n\t{\n\t\tif (base.IsDestroyed || Interface.CallHook(\u0022OnEntityStabilityCheck\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (supports == null)\n\t\t{\n\t\t\tInitializeSupports();\n\t\t}\n\t\tbool flag = false;\n\t\tint num = DistanceFromGround();\n\t\tif (num != cachedDistanceFromGround)\n\t\t{\n\t\t\tcachedDistanceFromGround = num;\n\t\t\tflag = true;\n\t\t}\n\t\tfloat num2 = SupportValue();\n\t\tif (Mathf.Abs(cachedStability - num2) \u003E Stability.accuracy)\n\t\t{\n\t\t\tcachedStability = num2;\n\t\t\tflag = true;\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tdirty = true;\n\t\t\tUpdateConnectedEntities();\n\t\t\tUpdateStability();\n\t\t}\n\t\telse if (dirty)\n\t\t{\n\t\t\tdirty = false;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tif (num2 \u003C Stability.collapse)\n\t\t{\n\t\t\tif (stabilityStrikes \u003C Stability.strikes)\n\t\t\t{\n\t\t\t\tUpdateStability();\n\t\t\t\tstabilityStrikes\u002B\u002B;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (Stability.log_stability_death)\n\t\t\t{\n\t\t\t\tDebug.Log($\u0022Killing \u0027{ToString()}\u0027 at position {base.transform.position} due to low stability: {Math.Round(num2 * 100f, 2)} \u003C {Math.Round(Stability.collapse * 100f, 1)}%\u0022);\n\t\t\t}\n\t\t\tKill(DestroyMode.Gib);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstabilityStrikes = 0;\n\t\t}\n\t}\n",
    "ClassName": "StabilityEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBookmarkControlEnd(ComputerStation computerStation, BasePlayer ply, BaseEntity baseEntity)",
    "MethodSignature": "StopControl(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic void StopControl(BasePlayer ply)\n\t{\n\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\tif ((bool)baseEntity)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnBookmarkControlEnd\u0022, this, ply, baseEntity) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbaseEntity.GetComponent\u003CIRemoteControllable\u003E().StopControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t}\n\t\tif ((bool)ply)\n\t\t{\n\t\t\tply.net.SwitchSecondaryGroup(null);\n\t\t\tply.SetRcEntityPosition(null);\n\t\t}\n\t\tcurrentlyControllingEnt.uid = default(NetworkableId);\n\t\tcurrentPlayerID = 0uL;\n\t\tSetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);\n\t\tSendNetworkUpdate();\n\t\tSendControlBookmarks(ply);\n\t\tCancelInvoke(ControlCheck);\n\t\tInterface.CallHook(\u0022OnBookmarkControlEnded\u0022, this, ply, baseEntity);\n\t\tCancelInvoke(CheckCCTVAchievement);\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanTrainCarCouple(TrainCar owner, TrainCar theirCouplingOwner)",
    "MethodSignature": "TryCouple(TrainCoupling theirCoupling, bool reflect)",
    "MethodSourseCode": "\n\tpublic bool TryCouple(TrainCoupling theirCoupling, bool reflect)\n\t{\n\t\tif (!isValid)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (CoupledTo == theirCoupling)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (IsCoupled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanTrainCarCouple\u0022, owner, theirCoupling.owner);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (reflect \u0026\u0026 !theirCoupling.TryCouple(this, reflect: false))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tCoupledTo = theirCoupling;\n\t\towner.SetFlag(flag, b: true, recursive: false, networkupdate: false);\n\t\towner.SendNetworkUpdate();\n\t\treturn true;\n\t}\n",
    "ClassName": "TrainCoupling",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnMeleeThrown(BasePlayer player, Item item)",
    "MethodSignature": "CLProject(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner(false)]\n\t[RPC_Server.IsActiveItem]\n\tprivate void CLProject(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientAttack(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (player == null || player.IsHeadUnderwater())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!canThrowAsProjectile)\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Not throwable (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022not_throwable\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem item = GetItem();\n\t\t\tif (item == null)\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022item_missing\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItemModProjectile component = item.info.GetComponent\u003CItemModProjectile\u003E();\n\t\t\tif (!(component == null))\n\t\t\t{\n\t\t\t\tusing (ProjectileShoot projectileShoot = msg.read.Proto\u003CProjectileShoot\u003E())\n\t\t\t\t{\n\t\t\t\t\tif (projectileShoot.projectiles.Count != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Projectile count mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022count_mismatch\u0022);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tplayer.CleanupExpiredProjectiles();\n\t\t\t\t\t\tGuid projectileGroupId = Guid.NewGuid();\n\t\t\t\t\t\tforeach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Duplicate ID (\u0022 \u002B projectile.projectileID \u002B \u0022)\u0022);\n\t\t\t\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022duplicate_id\u0022);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tVector3 positionOffset = Vector3.zero;\n\t\t\t\t\t\t\t\tif (ConVar.AntiHack.projectile_positionoffset \u0026\u0026 (player.isMounted || player.HasParent()))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tVector3 position = player.eyes.position;\n\t\t\t\t\t\t\t\t\tpositionOffset = position - projectile.startPos;\n\t\t\t\t\t\t\t\t\tprojectile.startPos = position;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (!ValidateEyePos(player, projectile.startPos))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tItem pickupItem = (ThrowFullStack ? item : ItemManager.CreateByItemID(item.info.itemid, 1, 0uL));\n\t\t\t\t\t\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, projectileGroupId, positionOffset, pickupItem);\n\t\t\t\t\t\t\t\tEffect effect = new Effect();\n\t\t\t\t\t\t\t\teffect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);\n\t\t\t\t\t\t\t\teffect.scale = 1f;\n\t\t\t\t\t\t\t\teffect.pooledString = component.projectileObject.resourcePath;\n\t\t\t\t\t\t\t\teffect.number = projectile.seed;\n\t\t\t\t\t\t\t\tEffectNetwork.Send(effect);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ThrowFullStack)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem.SetParent(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem.UseItem();\n\t\t\t\t\t\t\tif (item.amount == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\titem.SetParent(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tInterface.CallHook(\u0022OnMeleeThrown\u0022, player, item);\n\t\t\t\t\t\tSingletonComponent\u003CNpcNoiseManager\u003E.Instance.OnWeaponThrown(player, this, canAiHearIt);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022mod_missing\u0022);\n\t\t}\n\t}\n",
    "ClassName": "BaseMelee",
    "HookLineInvoke": 90
  },
  {
    "HookSignature": "OnEntityDeath(ResourceEntity resourceEntity, HitInfo info)",
    "MethodSignature": "OnDied(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void OnDied(HitInfo info)\n\t{\n\t\tisKilled = true;\n\t\tInterface.CallHook(\u0022OnEntityDeath\u0022, this, info);\n\t\tKill();\n\t}\n",
    "ClassName": "ResourceEntity",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "IOnNpcTarget(Rust.Ai.Gen2.SenseComponent rust.Ai.Gen2.SenseComponent, BaseEntity entity)",
    "MethodSignature": "CanTarget(BaseEntity entity)",
    "MethodSourseCode": "\n\tpublic bool CanTarget(BaseEntity entity)\n\t{\n\t\tif (!entity.IsValid())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (entity.IsTransferProtected())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (entity.IsDestroyed)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!entity.IsNonNpcPlayer() \u0026\u0026 !entity.IsNpc)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (entity.IsNpcPlayer())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (entity is BaseCombatEntity baseCombatEntity \u0026\u0026 baseCombatEntity.IsDead())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (InSameTeam(entity))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (entity is BasePlayer item)\n\t\t{\n\t\t\tif (AI.ignoreplayers)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (SimpleAIMemory.PlayerIgnoreList.Contains(item))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022IOnNpcTarget\u0022, this, entity);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "SenseComponent",
    "HookLineInvoke": 42
  },
  {
    "HookSignature": "OnPlayerTick(BasePlayer basePlayer, PlayerTick msg, bool wasPlayerStalled)",
    "MethodSignature": "OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)",
    "MethodSourseCode": "\n\tprivate void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)\n\t{\n\t\tif (msg.inputState != null)\n\t\t{\n\t\t\tserverInput.Flip(msg.inputState);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerTick\u0022, this, msg, wasPlayerStalled) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (serverInput.current.buttons != serverInput.previous.buttons)\n\t\t{\n\t\t\tResetInputIdleTime();\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerInput\u0022, this, serverInput) != null || IsReceivingSnapshot)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (IsSpectating())\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022Tick_Spectator\u0022))\n\t\t\t{\n\t\t\t\tTick_Spectator();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (IsSleeping())\n\t\t{\n\t\t\tif (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))\n\t\t\t{\n\t\t\t\tEndSleeping();\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t}\n\t\t\tUpdateActiveItem(default(ItemId));\n\t\t\treturn;\n\t\t}\n\t\tif (IsRestrained \u0026\u0026 restraintItemId.HasValue \u0026\u0026 restraintItemId.HasValue)\n\t\t{\n\t\t\tUpdateActiveItem(restraintItemId.Value);\n\t\t}\n\t\telse if (!Belt.CanHoldItem())\n\t\t{\n\t\t\tUpdateActiveItem(default(ItemId));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUpdateActiveItem(msg.activeItem);\n\t\t}\n\t\tUpdateModelStateFromTick(msg);\n\t\tif (float.IsNaN(modelState.ducking) || float.IsInfinity(modelState.ducking))\n\t\t{\n\t\t\tKick(\u0022Kicked: invalid modelstate\u0022);\n\t\t\treturn;\n\t\t}\n\t\tmodelState.ducking = Mathf.Clamp01(modelState.ducking);\n\t\tif (IsIncapacitated())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tForwardReceiveTickToListeners(msg);\n\t\tif (isMounted)\n\t\t{\n\t\t\tGetMounted().PlayerServerInput(serverInput, this);\n\t\t}\n\t\tUpdatePositionFromTick(msg, wasPlayerStalled);\n\t\tUpdateRotationFromTick(msg);\n\t\tint activeMission = GetActiveMission();\n\t\tif (activeMission \u003E= 0 \u0026\u0026 activeMission \u003C missions.Count)\n\t\t{\n\t\t\tBaseMission.MissionInstance missionInstance = missions[activeMission];\n\t\t\tif (missionInstance.status == BaseMission.MissionStatus.Active \u0026\u0026 missionInstance.NeedsPlayerInput())\n\t\t\t{\n\t\t\t\tProcessMissionEvent(BaseMission.MissionEventType.PLAYER_TICK, net.ID, 0f);\n\t\t\t}\n\t\t}\n\t\tif (!TutorialIsland.EnforceTrespassChecks || IsAdmin || IsNpc || net == null || net.group == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (net.group.restricted)\n\t\t{\n\t\t\tbool flag = false;\n\t\t\tif (!IsInTutorial)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tTutorialIsland currentTutorialIsland = GetCurrentTutorialIsland();\n\t\t\t\tif (currentTutorialIsland == null || currentTutorialIsland.net.group != net.group)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\ttutorialKickTime \u002B= UnityEngine.Time.deltaTime;\n\t\t\t\tif (tutorialKickTime \u003E 3f)\n\t\t\t\t{\n\t\t\t\t\tDebug.LogWarning($\u0022Killing player {displayName}/{userID.Get()} as they are on a tutorial island that doesn\u0027t belong them\u0022);\n\t\t\t\t\tHurt(999f);\n\t\t\t\t\ttutorialKickTime = 0f;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttutorialKickTime = 0f;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!IsInTutorial || net.group.restricted)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbool flag2 = false;\n\t\t\tTutorialIsland currentTutorialIsland2 = GetCurrentTutorialIsland();\n\t\t\tif (currentTutorialIsland2 == null || currentTutorialIsland2.net.group != net.group)\n\t\t\t{\n\t\t\t\tflag2 = true;\n\t\t\t}\n\t\t\tif (flag2)\n\t\t\t{\n\t\t\t\ttutorialKickTime \u002B= UnityEngine.Time.deltaTime;\n\t\t\t\tif (tutorialKickTime \u003E 3f)\n\t\t\t\t{\n\t\t\t\t\tDebug.LogWarning($\u0022Killing player {displayName}/{userID.Get()} as they are no longer on a tutorial island and are marked as being in a tutorial\u0022);\n\t\t\t\t\tHurt(999f);\n\t\t\t\t\ttutorialKickTime = 0f;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttutorialKickTime = 0f;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnDoorKnocked(Door door, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_KnockDoor(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void RPC_KnockDoor(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract(usableWhileCrawling: true) || !knockEffect.isValid || UnityEngine.Time.realtimeSinceStartup \u003C nextKnockTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextKnockTime = UnityEngine.Time.realtimeSinceStartup \u002B 0.5f;\n\t\tBaseEntity slot = GetSlot(Slot.LowerCenterDecoration);\n\t\tif (slot != null)\n\t\t{\n\t\t\tDoorKnocker component = slot.GetComponent\u003CDoorKnocker\u003E();\n\t\t\tif ((bool)component)\n\t\t\t{\n\t\t\t\tcomponent.Knock(rpc.player);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tEffect.server.Run(knockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\tInterface.CallHook(\u0022OnDoorKnocked\u0022, this, rpc.player);\n\t}\n",
    "ClassName": "Door",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnCollectiblePickedup(CollectibleEntity collectibleEntity, BasePlayer reciever, Item item)",
    "MethodSignature": "DoPickup(BasePlayer reciever, bool eat)",
    "MethodSourseCode": "\n\tpublic void DoPickup(BasePlayer reciever, bool eat = false)\n\t{\n\t\tif (itemList == null || Interface.CallHook(\u0022OnCollectiblePickup\u0022, this, reciever, eat) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = ((reciever.modifiers != null) ? reciever.modifiers.GetValue(Modifier.ModifierType.Collectible_DoubleYield) : 0f);\n\t\tbool flag = num != 0f \u0026\u0026 UnityEngine.Random.value \u003C num;\n\t\tItemAmount[] array = itemList;\n\t\tforeach (ItemAmount itemAmount in array)\n\t\t{\n\t\t\tif (reciever != null \u0026\u0026 reciever.IsInTutorial \u0026\u0026 itemAmount.ignoreInTutorial)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tItem item = ItemManager.Create(itemAmount.itemDef, flag ? ((int)itemAmount.amount * 2) : ((int)itemAmount.amount), 0uL);\n\t\t\tif (item == null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\titem.SetItemOwnership(reciever, ItemOwnershipPhrases.GatheredPhrase);\n\t\t\tif (eat \u0026\u0026 item.info.category == ItemCategory.Food \u0026\u0026 reciever != null)\n\t\t\t{\n\t\t\t\tItemModConsume component = item.info.GetComponent\u003CItemModConsume\u003E();\n\t\t\t\tif (component != null)\n\t\t\t\t{\n\t\t\t\t\tcomponent.DoAction(item, reciever);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((bool)reciever)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever);\n\t\t\t\tInterface.CallHook(\u0022OnCollectiblePickedup\u0022, this, reciever, item);\n\t\t\t\treciever.GiveItem(item, GiveItemReason.ResourceHarvested);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 0.5f, Vector3.up);\n\t\t\t}\n\t\t}\n\t\titemList = null;\n\t\tif (pickupEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);\n\t\t}\n\t\tRandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find\u003CRandomItemDispenser\u003E(prefabID);\n\t\tif (randomItemDispenser != null)\n\t\t{\n\t\t\trandomItemDispenser.DistributeItems(reciever, base.transform.position);\n\t\t}\n\t\tKill();\n\t}\n",
    "ClassName": "CollectibleEntity",
    "HookLineInvoke": 34
  },
  {
    "HookSignature": "CanUpdateSign(BasePlayer player, CarvablePumpkin carvablePumpkin)",
    "MethodSignature": "CanUpdateSign(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanUpdateSign(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUpdateSign\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player.IsAdmin || player.IsDeveloper)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (!player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsLocked())\n\t\t{\n\t\t\treturn (ulong)player.userID == base.OwnerID;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "CarvablePumpkin",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnOvenTemperature(BaseOven baseOven, int slot)",
    "MethodSignature": "GetTemperature(int slot)",
    "MethodSourseCode": "\n\tpublic float GetTemperature(int slot)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnOvenTemperature\u0022, this, slot);\n\t\tif (obj is float)\n\t\t{\n\t\t\treturn (float)obj;\n\t\t}\n\t\tif (!HasFlag(Flags.On))\n\t\t{\n\t\t\treturn 15f;\n\t\t}\n\t\treturn cookingTemperature;\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnVehicleModuleSelected(Item vehicleItem, ModularCarGarage modularCarGarage, BasePlayer player)",
    "MethodSignature": "RPC_SelectedLootItem(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void RPC_SelectedLootItem(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tItemId itemUID = msg.read.ItemID();\n\t\tif (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem vehicleItem = carOccupant.GetVehicleItem(itemUID);\n\t\tif (vehicleItem == null || Interface.CallHook(\u0022OnVehicleModuleSelect\u0022, vehicleItem, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = player.inventory.loot.RemoveContainerAt(3);\n\t\tif (TryGetModuleForItem(vehicleItem, out var result))\n\t\t{\n\t\t\tif (result is VehicleModuleStorage vehicleModuleStorage)\n\t\t\t{\n\t\t\t\tIItemContainerEntity container = vehicleModuleStorage.GetContainer();\n\t\t\t\tif (!ObjectEx.IsUnityNull(container))\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.loot.AddContainer(container.inventory);\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (result is VehicleModuleCamper vehicleModuleCamper)\n\t\t\t{\n\t\t\t\tIItemContainerEntity container2 = vehicleModuleCamper.GetContainer();\n\t\t\t\tif (!ObjectEx.IsUnityNull(container2))\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.loot.AddContainer(container2.inventory);\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t}\n\t\tInterface.CallHook(\u0022OnVehicleModuleSelected\u0022, vehicleItem, this, player);\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 42
  },
  {
    "HookSignature": "OnItemSplit(Item item, int split_Amount)",
    "MethodSignature": "SplitItem(int split_Amount)",
    "MethodSourseCode": "\n\tpublic Item SplitItem(int split_Amount)\n\t{\n\t\tAssert.IsTrue(split_Amount \u003E 0, \u0022split_Amount \u003C= 0\u0022);\n\t\tif (split_Amount \u003C= 0)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tif (split_Amount \u003E= amount)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnItemSplit\u0022, this, split_Amount);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\tamount -= split_Amount;\n\t\tItem item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);\n\t\titem.amount = split_Amount;\n\t\titem.skin = skin;\n\t\tMigrateItemOwnership(item, split_Amount);\n\t\tif (IsBlueprint())\n\t\t{\n\t\t\titem.blueprintTarget = blueprintTarget;\n\t\t}\n\t\tif (info.amountType == ItemDefinition.AmountType.Genetics \u0026\u0026 instanceData != null \u0026\u0026 instanceData.dataInt != 0)\n\t\t{\n\t\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\n\t\t\titem.instanceData.dataInt = instanceData.dataInt;\n\t\t\titem.instanceData.ShouldPool = false;\n\t\t}\n\t\tif (instanceData != null \u0026\u0026 instanceData.dataInt \u003E 0 \u0026\u0026 info != null \u0026\u0026 info.Blueprint != null \u0026\u0026 info.Blueprint.GetWorkbenchLevel() == 3)\n\t\t{\n\t\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\n\t\t\titem.instanceData.dataInt = instanceData.dataInt;\n\t\t\titem.instanceData.ShouldPool = false;\n\t\t\titem.SetFlag(Flag.IsOn, IsOn());\n\t\t}\n\t\tif (instanceData != null \u0026\u0026 (bool)info.GetComponent\u003CItemModFoodSpoiling\u003E())\n\t\t{\n\t\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\n\t\t\titem.instanceData.dataFloat = instanceData.dataFloat;\n\t\t\titem.instanceData.ShouldPool = false;\n\t\t}\n\t\tMarkDirty();\n\t\treturn item;\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnTurretTarget(AutoTurret autoTurret, BaseCombatEntity targ)",
    "MethodSignature": "SetTarget(BaseCombatEntity targ)",
    "MethodSourseCode": "\n\tpublic void SetTarget(BaseCombatEntity targ)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTurretTarget\u0022, this, targ) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (targ != target || targ.IsRealNull() != target.IsRealNull())\n\t\t{\n\t\t\tEffect.server.Run((targ == null) ? targetLostEffect.resourcePath : targetAcquiredEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\tif (outputs != null \u0026\u0026 outputs.Length != 0 \u0026\u0026 outputs[0].connectedTo.Get() != null)\n\t\t\t{\n\t\t\t\tMarkDirtyForceUpdateOutputs();\n\t\t\t}\n\t\t\tnextShotTime \u002B= 0.10000000149011612;\n\t\t\tauthDirty = true;\n\t\t}\n\t\ttarget = targ;\n\t\tif (target.IsRealNull())\n\t\t{\n\t\t\ttargetVisible = false;\n\t\t\tnextVisCheck = 0.0;\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfBroadcasterAdd(IRFObject obj, int frequency)",
    "MethodSignature": "AddBroadcaster(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void AddBroadcaster(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfBroadcasterAdd\u0022, obj, frequency) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tHashSet\u003CIRFObject\u003E broadcasterSet = GetBroadcasterSet(frequency);\n\t\tif (broadcasterSet.RemoveWhere((IRFObject b) =\u003E b == null || !BaseEntityEx.IsValidEntityReference(b)) \u003E 0)\n\t\t{\n\t\t\tDebug.LogWarning($\u0022Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.\u0022);\n\t\t}\n\t\tif (broadcasterSet.Add(obj))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnRfBroadcasterAdded\u0022, obj, frequency);\n\t\t\tif (!_isFrequencyBroadcasting.TryGetValue(frequency, out var value) || !value)\n\t\t\t{\n\t\t\t\t_isFrequencyBroadcasting[frequency] = true;\n\t\t\t\tUpdateListenersForFrequency(frequency, isBroadcasting: true);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnXmasLootDistribute(XMasRefill xMasRefill)",
    "MethodSignature": "ServerInit()",
    "MethodSourseCode": "\n\tpublic override void ServerInit()\n\t{\n\t\tbase.ServerInit();\n\t\tif (!XMas.enabled)\n\t\t{\n\t\t\tInvoke(RemoveMe, 0.1f);\n\t\t\treturn;\n\t\t}\n\t\tgoodKids = ((BasePlayer.activePlayerList != null) ? new List\u003CBasePlayer\u003E(BasePlayer.activePlayerList) : new List\u003CBasePlayer\u003E());\n\t\tstockings = ((Stocking.stockings != null) ? new List\u003CStocking\u003E(Stocking.stockings.Values) : new List\u003CStocking\u003E());\n\t\tInvoke(RemoveMe, 60f);\n\t\tif (Interface.CallHook(\u0022OnXmasLootDistribute\u0022, this) == null)\n\t\t{\n\t\t\tInvokeRepeating(DistributeLoot, 3f, 0.02f);\n\t\t\tInvoke(SendBells, 0.5f);\n\t\t}\n\t}\n",
    "ClassName": "XMasRefill",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnFuelConsume(BaseOven baseOven, Item fuel, ItemModBurnable burnable)",
    "MethodSignature": "ConsumeFuel(Item fuel, ItemModBurnable burnable)",
    "MethodSourseCode": "\n\tpublic void ConsumeFuel(Item fuel, ItemModBurnable burnable)\n\t{\n\t\tif (Interface.CallHook(\u0022OnFuelConsume\u0022, this, fuel, burnable) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (allowByproductCreation \u0026\u0026 burnable.byproductItem != null \u0026\u0026 UnityEngine.Random.Range(0f, 1f) \u003E burnable.byproductChance)\n\t\t{\n\t\t\tItem item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);\n\t\t\tif (!item.MoveToContainer(base.inventory))\n\t\t\t{\n\t\t\t\tOvenFull();\n\t\t\t\titem.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\n\t\t\t}\n\t\t}\n\t\tif (fuel.amount \u003C= GetFuelRate())\n\t\t{\n\t\t\tfuel.Remove();\n\t\t\treturn;\n\t\t}\n\t\tint fuelRate = GetFuelRate();\n\t\tfuel.UseItem(fuelRate);\n\t\tFacepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, \u0022smelt\u0022);\n\t\tfuel.fuel = burnable.fuelAmount;\n\t\tfuel.MarkDirty();\n\t\tInterface.CallHook(\u0022OnFuelConsumed\u0022, this, fuel, burnable);\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemDeployed(Deployer deployer, ItemModDeployable modDeployable, BaseEntity baseEntity)",
    "MethodSignature": "DoDeploy_Regular(Deployable deployable, Ray ray)",
    "MethodSourseCode": "\n\tpublic void DoDeploy_Regular(Deployable deployable, Ray ray)\n\t{\n\t\tif (!HasItemAmount())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!ownerPlayer.CanBuild())\n\t\t{\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);\n\t\t}\n\t\telse if (ConVar.AntiHack.objectplacement \u0026\u0026 ownerPlayer.TriggeredMovementAntiHack())\n\t\t{\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.AntihackWithReason, false, ownerPlayer.lastViolationType.ToString());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!CheckPlacement(deployable, ray, 8f) || !UnityEngine.Physics.Raycast(ray, out var hitInfo, 8f, 1235288065))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tVector3 point = hitInfo.point;\n\t\t\tQuaternion deployedRotation = GetDeployedRotation(hitInfo.normal, ray.direction);\n\t\t\tItem ownerItem = GetOwnerItem();\n\t\t\tItemModDeployable modDeployable = GetModDeployable();\n\t\t\tif (ownerPlayer.Distance(point) \u003E 3f)\n\t\t\t{\n\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.TooFarAway, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!ownerPlayer.CanBuild(point, deployedRotation, deployable.bounds))\n\t\t\t{\n\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath, point, deployedRotation);\n\t\t\tif (!baseEntity)\n\t\t\t{\n\t\t\t\tDebug.LogWarning(\u0022Couldn\u0027t create prefab:\u0022 \u002B modDeployable.entityPrefab.resourcePath);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbaseEntity.skinID = ownerItem.skin;\n\t\t\tbaseEntity.SendMessage(\u0022SetDeployedBy\u0022, ownerPlayer, SendMessageOptions.DontRequireReceiver);\n\t\t\tbaseEntity.OwnerID = ownerPlayer.userID;\n\t\t\tbaseEntity.Spawn();\n\t\t\tmodDeployable.OnDeployed(baseEntity, ownerPlayer);\n\t\t\tInterface.CallHook(\u0022OnItemDeployed\u0022, this, modDeployable, baseEntity);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);\n\t\t\tUseItemAmount(1);\n\t\t}\n\t}\n",
    "ClassName": "Deployer",
    "HookLineInvoke": 51
  },
  {
    "HookSignature": "OnEntityVisibilityCheck(BaseEntity ent, BasePlayer player, uint id, string debugName, float maximumDistance)",
    "MethodSignature": "Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)",
    "MethodSourseCode": "\n\t\t\tpublic static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)\n\t\t\t{\n\t\t\t\tif (ent == null || player == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnEntityVisibilityCheck\u0022, ent, player, id, debugName, maximumDistance);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tif (GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 1218519041))\n\t\t\t\t{\n\t\t\t\t\tif (!ent.IsVisible(player.eyes.HeadRay(), 1218519041, maximumDistance))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn ent.IsVisible(player.eyes.position, maximumDistance);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanFireLiquidWeapon(BasePlayer player, LiquidWeapon liquidWeapon)",
    "MethodSignature": "CanFire(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate bool CanFire(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanFireLiquidWeapon\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (RequiresPumping \u0026\u0026 pressure \u003C PressureLossPerTick)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (HasFlag(Flags.Open))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (AmountHeld() \u003C= 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!player.CanInteract())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!player.CanAttack() || player.IsRunning())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tItem item = GetItem();\n\t\tif (item == null || item.contents == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "LiquidWeapon",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBackpackDrop(Item anyBackpack, PlayerInventory playerInventory)",
    "MethodSignature": "TryDropBackpack()",
    "MethodSourseCode": "\n\tpublic void TryDropBackpack()\n\t{\n\t\tItem anyBackpack = GetAnyBackpack();\n\t\tif (anyBackpack != null \u0026\u0026 base.baseEntity.isServer \u0026\u0026 Interface.CallHook(\u0022OnBackpackDrop\u0022, anyBackpack, this) == null)\n\t\t{\n\t\t\tanyBackpack.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "ICanPickupEntity(BasePlayer msgPlayer, RFTimedExplosive rFTimedExplosive)",
    "MethodSignature": "Pickup(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void Pickup(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022ICanPickupEntity\u0022, msg.player, this) != null || !msg.player.CanInteract() || !IsArmed())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item = ItemManager.Create(pickupDefinition, 1, 0uL);\n\t\tif (item != null)\n\t\t{\n\t\t\tif (ItemOwnership.IsValid())\n\t\t\t{\n\t\t\t\titem.SetItemOwnership(ItemOwnership);\n\t\t\t}\n\t\t\tif (!(Mathf.Abs(startPickupTime \u002B 5f - UnityEngine.Time.realtimeSinceStartup) \u003E ConVar.AntiHack.rpc_timer_forgiveness))\n\t\t\t{\n\t\t\t\titem.instanceData.dataInt = GetFrequency();\n\t\t\t\titem.SetFlag(Item.Flag.IsOn, IsArmed());\n\t\t\t\tmsg.player.GiveItem(item, GiveItemReason.PickedUp);\n\t\t\t\tKill();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFTimedExplosive",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnMissionStarted(BaseMission baseMission, BaseMission.MissionInstance instance, BasePlayer assignee)",
    "MethodSignature": "MissionStart(MissionInstance instance, BasePlayer assignee)",
    "MethodSourseCode": "\n\tpublic virtual void MissionStart(MissionInstance instance, BasePlayer assignee)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMissionStart\u0022, this, instance, assignee) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C objectives.Length; i\u002B\u002B)\n\t\t{\n\t\t\tobjectives[i].Get().MissionStarted(i, instance, assignee);\n\t\t}\n\t\tif (acceptEffect.isValid)\n\t\t{\n\t\t\tDoMissionEffect(acceptEffect.resourcePath, assignee);\n\t\t}\n\t\tMissionEntityEntry[] array = missionEntities;\n\t\tforeach (MissionEntityEntry missionEntityEntry in array)\n\t\t{\n\t\t\tif (missionEntityEntry.spawnOnMissionStart)\n\t\t\t{\n\t\t\t\tinstance.GetMissionEntity(missionEntityEntry.identifier, assignee);\n\t\t\t}\n\t\t}\n\t\tif (AllowedTutorialItems != 0)\n\t\t{\n\t\t\tassignee.SetTutorialAllowance(AllowedTutorialItems);\n\t\t}\n\t\tInterface.CallHook(\u0022OnMissionStarted\u0022, this, instance, assignee);\n\t}\n",
    "ClassName": "BaseMission",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnCounterTargetChange(PowerCounter powerCounter, BasePlayer msgPlayer, int num)",
    "MethodSignature": "SERVER_SetTarget(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void SERVER_SetTarget(RPCMessage msg)\n\t{\n\t\tint num = msg.read.Int32();\n\t\tif (Interface.CallHook(\u0022OnCounterTargetChange\u0022, this, msg.player, num) == null \u0026\u0026 CanPlayerAdmin(msg.player))\n\t\t{\n\t\t\ttargetCounterNumber = num;\n\t\t\tMarkDirty();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "PowerCounter",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerMetabolize(PlayerMetabolism playerMetabolism, BaseCombatEntity ownerEntity, float delta)",
    "MethodSignature": "ServerUpdate(BaseCombatEntity ownerEntity, float delta)",
    "MethodSourseCode": "\n\tpublic override void ServerUpdate(BaseCombatEntity ownerEntity, float delta)\n\t{\n\t\tbase.ServerUpdate(ownerEntity, delta);\n\t\tInterface.CallHook(\u0022OnPlayerMetabolize\u0022, this, ownerEntity, delta);\n\t\tif (owner.IsConnected)\n\t\t{\n\t\t\tSendChangesToClient();\n\t\t}\n\t}\n",
    "ClassName": "PlayerMetabolism",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnEntityDismounted(BaseMountable baseMountable, BasePlayer player)",
    "MethodSignature": "DismountPlayer(BasePlayer player, bool lite)",
    "MethodSourseCode": "\n\tpublic void DismountPlayer(BasePlayer player, bool lite = false)\n\t{\n\t\tif (_mounted == null || _mounted != player || Interface.CallHook(\u0022CanDismountEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseVehicle baseVehicle = VehicleParent();\n\t\tif (lite)\n\t\t{\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PrePlayerDismount(player, this);\n\t\t\t}\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted = null;\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t\tOnPlayerDismounted(player);\n\t\t\tInterface.CallHook(\u0022OnEntityDismounted\u0022, this, player);\n\t\t\treturn;\n\t\t}\n\t\tif (!GetDismountPosition(player, out var res) || Distance(res) \u003E 10f)\n\t\t{\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PrePlayerDismount(player, this);\n\t\t\t}\n\t\t\tres = player.transform.position;\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted.MovePosition(res);\n\t\t\t_mounted.transform.rotation = Quaternion.identity;\n\t\t\t_mounted.ClientRPC(RpcTarget.Player(\u0022ForcePositionTo\u0022, _mounted), res);\n\t\t\tBasePlayer mounted = _mounted;\n\t\t\t_mounted = null;\n\t\t\tDebug.LogWarning(\u0022Killing player due to invalid dismount point :\u0022 \u002B player.displayName \u002B \u0022 / \u0022 \u002B player.userID.Get() \u002B \u0022 on obj : \u0022 \u002B base.gameObject.name);\n\t\t\tmounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t\tOnPlayerDismounted(player);\n\t\t\treturn;\n\t\t}\n\t\tif (baseVehicle != null)\n\t\t{\n\t\t\tbaseVehicle.PrePlayerDismount(player, this);\n\t\t}\n\t\tif (AntiHack.TestNoClipping(_mounted, res, res, BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _, vehicleLayer: true))\n\t\t{\n\t\t\t_mounted.PauseVehicleNoClipDetection(5f);\n\t\t}\n\t\t_mounted.DismountObject();\n\t\t_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);\n\t\t_mounted.OverrideViewAngles(Vector3.zero);\n\t\t_mounted.MovePosition(res);\n\t\t_mounted.SendNetworkUpdateImmediate();\n\t\t_mounted.SendModelState(force: true);\n\t\t_mounted = null;\n\t\tif (baseVehicle != null)\n\t\t{\n\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t}\n\t\tplayer.ForceUpdateTriggers();\n\t\tif ((bool)player.GetParentEntity())\n\t\t{\n\t\t\tBaseEntity baseEntity = player.GetParentEntity();\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022ForcePositionToParentOffset\u0022, player), baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022ForcePositionTo\u0022, player), res);\n\t\t\tplayer.ClientRPC(RpcTarget.NetworkGroup(\u0022ForceResetRotation\u0022, player));\n\t\t}\n\t\tFacepunch.Rust.Analytics.Azure.OnDismountEntity(player, this, baseVehicle);\n\t\tInterface.CallHook(\u0022OnEntityDismounted\u0022, this, player);\n\t\tOnPlayerDismounted(player);\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnRfFrequencyChanged(Detonator detonator, int freq, BasePlayer player)",
    "MethodSignature": "ServerSetFrequency(BasePlayer player, int freq)",
    "MethodSourseCode": "\n\tpublic void ServerSetFrequency(BasePlayer player, int freq)\n\t{\n\t\tif (player == null || GetOwnerPlayer() != player || UnityEngine.Time.time \u003C nextChangeTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\tif (RFManager.IsReserved(freq))\n\t\t{\n\t\t\tRFManager.ReserveErrorPrint(player);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, freq, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem ownerItem = GetOwnerItem();\n\t\t\tRFManager.ChangeFrequency(frequency, freq, this, isListener: false, IsOn());\n\t\t\tfrequency = freq;\n\t\t\tSendNetworkUpdate();\n\t\t\tItem item = GetItem();\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tif (item.instanceData == null)\n\t\t\t\t{\n\t\t\t\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\n\t\t\t\t\titem.instanceData.ShouldPool = false;\n\t\t\t\t}\n\t\t\t\titem.instanceData.dataInt = frequency;\n\t\t\t\titem.MarkDirty();\n\t\t\t}\n\t\t\townerItem?.LoseCondition(ownerItem.maxCondition * 0.01f);\n\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, freq, player);\n\t\t}\n\t}\n",
    "ClassName": "Detonator",
    "HookLineInvoke": 34
  },
  {
    "HookSignature": "CanLootPlayer(BasePlayer basePlayer, BasePlayer player)",
    "MethodSignature": "CanBeLooted(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool CanBeLooted(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanLootPlayer\u0022, this, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player == this)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif ((IsWounded() || IsSleeping() || CurrentGestureIsSurrendering || IsRestrainedOrSurrendering) \u0026\u0026 !IsLoadingAfterTransfer())\n\t\t{\n\t\t\treturn !IsTransferring();\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDemoRecordingStart(string text, BasePlayer basePlayer)",
    "MethodSignature": "StartDemoRecording()",
    "MethodSourseCode": "\n\tpublic void StartDemoRecording()\n\t{\n\t\tif (net != null \u0026\u0026 net.connection != null \u0026\u0026 !net.connection.IsRecording)\n\t\t{\n\t\t\tstring text = $\u0022demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem\u0022;\n\t\t\tif (Interface.CallHook(\u0022OnDemoRecordingStart\u0022, text, this) == null)\n\t\t\t{\n\t\t\t\tDebug.Log(ToString() \u002B \u0022 recording started: \u0022 \u002B text);\n\t\t\t\tnet.connection.StartRecording(text, new Demo.Header\n\t\t\t\t{\n\t\t\t\t\tversion = Demo.Version,\n\t\t\t\t\tlevel = UnityEngine.Application.loadedLevelName,\n\t\t\t\t\tlevelSeed = World.Seed,\n\t\t\t\t\tlevelSize = World.Size,\n\t\t\t\t\tchecksum = World.Checksum,\n\t\t\t\t\tlocalclient = userID,\n\t\t\t\t\tposition = eyes.position,\n\t\t\t\t\trotation = eyes.HeadForward(),\n\t\t\t\t\tlevelUrl = World.Url,\n\t\t\t\t\trecordedTime = DateTime.Now.ToBinary()\n\t\t\t\t});\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tSendGlobalSnapshot();\n\t\t\t\tSendFullSnapshot();\n\t\t\t\tSendEntityUpdate();\n\t\t\t\tTreeManager.SendSnapshot(this);\n\t\t\t\tServerMgr.SendReplicatedVars(net.connection);\n\t\t\t\tInvokeRepeating(MonitorDemoRecording, 10f, 10f);\n\t\t\t\tInterface.CallHook(\u0022OnDemoRecordingStarted\u0022, text, this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "IOnServerInitialized()",
    "MethodSignature": "OpenConnection(bool useSteamServer)",
    "MethodSourseCode": "\n\tpublic void OpenConnection(bool useSteamServer = true)\n\t{\n\t\tif (ConVar.Server.queryport \u003C= 0 || ConVar.Server.queryport == ConVar.Server.port)\n\t\t{\n\t\t\tConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) \u002B 1;\n\t\t}\n\t\tNetwork.Net.sv.ip = ConVar.Server.ip;\n\t\tNetwork.Net.sv.port = ConVar.Server.port;\n\t\tNetwork.Net.sv.secure = ConVar.Server.secure;\n\t\tbool secure = ConVar.Server.secure;\n\t\tif (Facepunch.CommandLine.HasSwitch(\u0022-insecure\u0022))\n\t\t{\n\t\t\tNetwork.Net.sv.secure = false;\n\t\t\tConVar.Server.secure = false;\n\t\t}\n\t\tif (Network.Net.sv.secure \u0026\u0026 ConVar.Server.encryption \u003C 2)\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning(\u0022A server requires a minimum \u0027encryption\u0027 convar value of 1 to be secure and visible in the server browser, in a future release this will be increased to 2. To remain secure, increase your \u0027encryption\u0027 convar to 2 before starting your server.\u0022);\n\t\t\tif (ConVar.Server.encryption \u003C 1)\n\t\t\t{\n\t\t\t\tNetwork.Net.sv.secure = false;\n\t\t\t\tConVar.Server.secure = false;\n\t\t\t}\n\t\t}\n\t\tif (!secure \u0026\u0026 !Facepunch.CommandLine.HasSwitch(\u0022-insecure\u0022))\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning(\u0022The \u0027secure\u0027 convar is now obsolete. For running an insecure server please pass \u0027-insecure\u0027 in the startup parameters. This convar will be removed in a future release.\u0022);\n\t\t\tNetwork.Net.sv.secure = false;\n\t\t}\n\t\tif (useSteamServer)\n\t\t{\n\t\t\tStartSteamServer();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPlatformService.Instance.Initialize(RustPlatformHooks.Instance);\n\t\t}\n\t\tif (!Network.Net.sv.Start(this))\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning(\u0022Couldn\u0027t Start Server.\u0022);\n\t\t\tCloseConnection();\n\t\t\treturn;\n\t\t}\n\t\tNetwork.Net.sv.cryptography = new NetworkCryptographyServer();\n\t\tEACServer.DoStartup();\n\t\tInvokeRepeating(\u0022DoTick\u0022, 1f, 1f / (float)ConVar.Server.tickrate);\n\t\tInvokeRepeating(\u0022DoHeartbeat\u0022, 1f, 1f);\n\t\trunFrameUpdate = true;\n\t\tConsoleSystem.OnReplicatedVarChanged \u002B= OnReplicatedVarChanged;\n\t\tInterface.CallHook(\u0022IOnServerInitialized\u0022);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 50
  },
  {
    "HookSignature": "OnTeamLeave(RelationshipManager.PlayerTeam playerTeam, BasePlayer basePlayer)",
    "MethodSignature": "leaveteam(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void leaveteam(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (!(basePlayer == null) \u0026\u0026 basePlayer.currentTeam != 0L)\n\t\t{\n\t\t\tPlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);\n\t\t\tif (playerTeam != null \u0026\u0026 Interface.CallHook(\u0022OnTeamLeave\u0022, playerTeam, basePlayer) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.RemovePlayer(basePlayer.userID);\n\t\t\t\tbasePlayer.ClearTeam();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnMlrsFired(MLRS mLRS, BasePlayer owner)",
    "MethodSignature": "Fire(BasePlayer owner)",
    "MethodSourseCode": "\n\tpublic void Fire(BasePlayer owner)\n\t{\n\t\tUpdateStorageState();\n\t\tif (CanFire \u0026\u0026 !(GetMounted() == null) \u0026\u0026 Interface.CallHook(\u0022OnMlrsFire\u0022, this, owner) == null)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved6, b: true);\n\t\t\tradiusModIndex = 0;\n\t\t\tnextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);\n\t\t\trocketOwnerRef.Set(owner);\n\t\t\tInvokeRepeating(FireNextRocket, 0f, 0.5f);\n\t\t\tInterface.CallHook(\u0022OnMlrsFired\u0022, this, owner);\n\t\t}\n\t}\n",
    "ClassName": "MLRS",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnQuarryConsumeFuel(MiningQuarry miningQuarry, Item item)",
    "MethodSignature": "FuelCheck()",
    "MethodSourseCode": "\n\tpublic bool FuelCheck()\n\t{\n\t\tif (pendingWork \u003E 0f)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tItem item = fuelStoragePrefab.instance.GetComponent\u003CStorageContainer\u003E().inventory.FindItemByItemName(\u0022diesel_barrel\u0022);\n\t\tobject obj = Interface.CallHook(\u0022OnQuarryConsumeFuel\u0022, this, item);\n\t\tif (obj is Item)\n\t\t{\n\t\t\titem = (Item)obj;\n\t\t}\n\t\tif (item != null \u0026\u0026 item.amount \u003E= 1)\n\t\t{\n\t\t\tpendingWork \u002B= workPerFuel;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, item.info.shortname, 1, this);\n\t\t\titem.UseItem();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "MiningQuarry",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnItemRefill(Item item, BasePlayer player)",
    "MethodSignature": "ServerCommand(Item item, string command, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void ServerCommand(Item item, string command, BasePlayer player)\n\t{\n\t\tif (command == \u0022refill\u0022 \u0026\u0026 !player.IsSwimming() \u0026\u0026 HasCraftLevel(player) \u0026\u0026 !(item.conditionNormalized \u003E= 1f) \u0026\u0026 Interface.CallHook(\u0022OnItemRefill\u0022, item, player) == null)\n\t\t{\n\t\t\tfloat conditionNormalized = item.conditionNormalized;\n\t\t\tfloat maxConditionNormalized = item.maxConditionNormalized;\n\t\t\titem.DoRepair(conditionLost);\n\t\t\tif (successEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(successEffect.resourcePath, player.eyes.position);\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnItemRepaired(player, player.GetCachedCraftLevelWorkbench(), item, conditionNormalized, maxConditionNormalized);\n\t\t}\n\t}\n",
    "ClassName": "ItemModRepair",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnQuarryGather(MiningQuarry miningQuarry, Item item)",
    "MethodSignature": "ProcessResources()",
    "MethodSourseCode": "\n\tpublic void ProcessResources()\n\t{\n\t\tif (_linkedDeposit == null || hopperPrefab.instance == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!FuelCheck())\n\t\t{\n\t\t\tSetOn(isOn: false);\n\t\t}\n\t\tfloat num = Mathf.Min(workToAdd, pendingWork);\n\t\tpendingWork -= num;\n\t\tforeach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)\n\t\t{\n\t\t\tif ((!canExtractLiquid \u0026\u0026 resource.isLiquid) || (!canExtractSolid \u0026\u0026 !resource.isLiquid))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfloat workNeeded = resource.workNeeded;\n\t\t\tint num2 = Mathf.FloorToInt(resource.workDone / workNeeded);\n\t\t\tresource.workDone \u002B= num;\n\t\t\tint num3 = Mathf.FloorToInt(resource.workDone / workNeeded);\n\t\t\tif (resource.workDone \u003E workNeeded)\n\t\t\t{\n\t\t\t\tresource.workDone %= workNeeded;\n\t\t\t}\n\t\t\tif (num2 != num3)\n\t\t\t{\n\t\t\t\tint iAmount = num3 - num2;\n\t\t\t\tItem item = ItemManager.Create(resource.type, iAmount, 0uL);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);\n\t\t\t\tif (Interface.CallHook(\u0022OnQuarryGather\u0022, this, item) != null)\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t}\n\t\t\t\telse if (!item.MoveToContainer(hopperPrefab.instance.GetComponent\u003CStorageContainer\u003E().inventory))\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t\tSetOn(isOn: false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MiningQuarry",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnPlayerCorpseSpawn(BasePlayer basePlayer)",
    "MethodSignature": "CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List\u003CTriggerBase\u003E triggersOnDeath, bool forceServerSide)",
    "MethodSourseCode": "\n\tpublic virtual BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List\u003CTriggerBase\u003E triggersOnDeath, bool forceServerSide = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerCorpseSpawn\u0022, this) != null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tstring strCorpsePrefab = ((!(ConVar.Physics.serversideragdolls || forceServerSide)) ? \u0022assets/prefabs/player/player_corpse.prefab\u0022 : \u0022assets/prefabs/player/player_corpse_new.prefab\u0022);\n\t\t\tbool flag = false;\n\t\t\tif (ConVar.Global.cinematicGingerbreadCorpses)\n\t\t\t{\n\t\t\t\tforeach (Item item in inventory.containerWear.itemList)\n\t\t\t\t{\n\t\t\t\t\tif (item != null \u0026\u0026 item.info.TryGetComponent\u003CItemCorpseOverride\u003E(out var component))\n\t\t\t\t\t{\n\t\t\t\t\t\tstrCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) \u003E 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);\n\t\t\t\t\t\tflag = component.BlockWearableCopy;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab, posOnDeath, rotOnDeath, flagsOnDeath, modelState) as PlayerCorpse;\n\t\t\tif ((bool)playerCorpse)\n\t\t\t{\n\t\t\t\tplayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tif (!flag)\n\t\t\t\t{\n\t\t\t\t\tplayerCorpse.TakeFrom(this, inventory.containerMain, inventory.containerWear, inventory.containerBelt);\n\t\t\t\t}\n\t\t\t\tplayerCorpse.playerName = displayName;\n\t\t\t\tplayerCorpse.streamerName = RandomUsernames.Get(userID);\n\t\t\t\tplayerCorpse.playerSteamID = userID;\n\t\t\t\tplayerCorpse.underwearSkin = GetUnderwearSkin();\n\t\t\t\tif (!CollectionEx.IsNullOrEmpty(triggersOnDeath))\n\t\t\t\t{\n\t\t\t\t\tforeach (TriggerBase item2 in triggersOnDeath)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (item2 is TriggerParent triggerParent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttriggerParent.ForceParentEarly(playerCorpse);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tplayerCorpse.Spawn();\n\t\t\t\tplayerCorpse.TakeChildren(this);\n\t\t\t\tResourceDispenser component2 = playerCorpse.GetComponent\u003CResourceDispenser\u003E();\n\t\t\t\tint num = 2;\n\t\t\t\tif (lifeStory != null)\n\t\t\t\t{\n\t\t\t\t\tnum \u002B= Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);\n\t\t\t\t}\n\t\t\t\tcomponent2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition(\u0022fat.animal\u0022), num));\n\t\t\t\tInterface.CallHook(\u0022OnPlayerCorpseSpawned\u0022, this, playerCorpse);\n\t\t\t\treturn playerCorpse;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t\tstatic float GetFloatBasedOnUserID(ulong steamid, ulong seed)\n\t\t{\n\t\t\tUnityEngine.Random.State state = UnityEngine.Random.state;\n\t\t\tUnityEngine.Random.InitState((int)(seed \u002B steamid));\n\t\t\tfloat result = UnityEngine.Random.Range(0f, 1f);\n\t\t\tUnityEngine.Random.state = state;\n\t\t\treturn result;\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnExcavatorResourceSet(ExcavatorArm excavatorArm, string text, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_SetResourceTarget(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tpublic void RPC_SetResourceTarget(RPCMessage msg)\n\t{\n\t\tstring text = msg.read.String();\n\t\tif (Interface.CallHook(\u0022OnExcavatorResourceSet\u0022, this, text, msg.player) == null)\n\t\t{\n\t\t\tswitch (text)\n\t\t\t{\n\t\t\tcase \u0022HQM\u0022:\n\t\t\t\tresourceMiningIndex = 0;\n\t\t\t\tbreak;\n\t\t\tcase \u0022Sulfur\u0022:\n\t\t\t\tresourceMiningIndex = 1;\n\t\t\t\tbreak;\n\t\t\tcase \u0022Stone\u0022:\n\t\t\t\tresourceMiningIndex = 2;\n\t\t\t\tbreak;\n\t\t\tcase \u0022Metal\u0022:\n\t\t\t\tresourceMiningIndex = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!IsOn())\n\t\t\t{\n\t\t\t\tBeginMining();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ExcavatorArm",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnEngineLoadoutRefresh(Rust.Modular.EngineStorage rust.Modular.EngineStorage)",
    "MethodSignature": "RefreshLoadoutData()",
    "MethodSourseCode": "\n\tpublic void RefreshLoadoutData()\n\t{\n\t\tif (Interface.CallHook(\u0022OnEngineLoadoutRefresh\u0022, this) == null)\n\t\t{\n\t\t\tisUsable = base.inventory.IsFull() \u0026\u0026 base.inventory.itemList.All((Item item) =\u003E !item.isBroken);\n\t\t\taccelerationBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsAcceleration) / (float)accelerationBoostSlots;\n\t\t\ttopSpeedBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsTopSpeed) / (float)topSpeedBoostSlots;\n\t\t\tfuelEconomyBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsFuelEconomy) / (float)fuelEconomyBoostSlots;\n\t\t\tSendNetworkUpdate();\n\t\t\tGetEngineModule()?.RefreshPerformanceStats(this);\n\t\t}\n\t}\n",
    "ClassName": "EngineStorage",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemRemove(Item item)",
    "MethodSignature": "Remove(float fTime)",
    "MethodSourseCode": "\n\tpublic void Remove(float fTime = 0f)\n\t{\n\t\tif (removeTime \u003E 0f || Interface.CallHook(\u0022OnItemRemove\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (isServer)\n\t\t{\n\t\t\tItemMod[] itemMods = info.itemMods;\n\t\t\tfor (int i = 0; i \u003C itemMods.Length; i\u002B\u002B)\n\t\t\t{\n\t\t\t\titemMods[i].OnRemove(this);\n\t\t\t}\n\t\t}\n\t\tthis.onCycle = null;\n\t\tremoveTime = UnityEngine.Time.time \u002B fTime;\n\t\tthis.OnDirty = null;\n\t\tposition = -1;\n\t\tItemManager.RemoveItem(this, fTime);\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFreeableContainerReleaseStarted(FreeableLootContainer freeableLootContainer, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_FreeCrateTimer(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void RPC_FreeCrateTimer(RPCMessage msg)\n\t{\n\t\tif (IsTiedDown())\n\t\t{\n\t\t\tstartUntieTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\tInterface.CallHook(\u0022OnFreeableContainerReleaseStarted\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "FreeableLootContainer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnServerUserSet(ulong uid, ServerUsers.UserGroup group, string username, string notes, long expiry)",
    "MethodSignature": "Set(ulong uid, UserGroup group, string username, string notes, long expiry)",
    "MethodSourseCode": "\n\tpublic static void Set(ulong uid, UserGroup group, string username, string notes, long expiry = -1L)\n\t{\n\t\tRemove(uid);\n\t\tUser value = new User\n\t\t{\n\t\t\tsteamid = uid,\n\t\t\tgroup = group,\n\t\t\tusername = username,\n\t\t\tnotes = notes,\n\t\t\texpiry = expiry\n\t\t};\n\t\tInterface.CallHook(\u0022OnServerUserSet\u0022, uid, group, username, notes, expiry);\n\t\tusers.Add(uid, value);\n\t}\n",
    "ClassName": "ServerUsers",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnPortalUse(BasePlayer player, BasePortal basePortal)",
    "MethodSignature": "UsePortal(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void UsePortal(BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPortalUse\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tLinkPortal();\n\t\tif (targetPortal != null)\n\t\t{\n\t\t\tplayer.PauseFlyHackDetection();\n\t\t\tplayer.PauseSpeedHackDetection();\n\t\t\tplayer.ApplyStallProtection(4f);\n\t\t\tVector3 position = player.transform.position;\n\t\t\tVector3 vector = targetPortal.GetLocalEntryExitPosition();\n\t\t\tVector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());\n\t\t\tVector3 vector3 = vector2;\n\t\t\tif (isMirrored)\n\t\t\t{\n\t\t\t\tVector3 position2 = base.transform.InverseTransformPoint(player.transform.position);\n\t\t\t\tvector = targetPortal.relativeAnchor.transform.TransformPoint(position2);\n\t\t\t\tvector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvector3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;\n\t\t\t}\n\t\t\tif (disappearEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(disappearEffect.resourcePath, position, Vector3.up);\n\t\t\t}\n\t\t\tif (appearEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(appearEffect.resourcePath, vector, Vector3.up);\n\t\t\t}\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022StartLoading_Quick\u0022, player), arg1: true);\n\t\t\tplayer.SetParent(null, worldPositionStays: true);\n\t\t\tplayer.Teleport(vector);\n\t\t\tplayer.ForceUpdateTriggers();\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022ForceViewAnglesTo\u0022, player), vector3);\n\t\t\tif (transitionSoundEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tplayer.UpdateNetworkGroup();\n\t\t\tplayer.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tInterface.CallHook(\u0022OnPortalUsed\u0022, player, this);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebug.Log(\u0022No portal...\u0022);\n\t\t}\n\t}\n",
    "ClassName": "BasePortal",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLock(BasePlayer player, ModularCar owner, ModularCarCodeLock modularCarCodeLock)",
    "MethodSignature": "HasLockPermission(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool HasLockPermission(BasePlayer player)\n\t{\n\t\tif (!player.IsValid() || player.IsDead())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanLock\u0022, player, owner, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn HasLockPermission(player.userID);\n\t}\n",
    "ClassName": "ModularCarCodeLock",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnRfBroadcasterAdded(IRFObject obj, int frequency)",
    "MethodSignature": "AddBroadcaster(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void AddBroadcaster(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfBroadcasterAdd\u0022, obj, frequency) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tHashSet\u003CIRFObject\u003E broadcasterSet = GetBroadcasterSet(frequency);\n\t\tif (broadcasterSet.RemoveWhere((IRFObject b) =\u003E b == null || !BaseEntityEx.IsValidEntityReference(b)) \u003E 0)\n\t\t{\n\t\t\tDebug.LogWarning($\u0022Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.\u0022);\n\t\t}\n\t\tif (broadcasterSet.Add(obj))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnRfBroadcasterAdded\u0022, obj, frequency);\n\t\t\tif (!_isFrequencyBroadcasting.TryGetValue(frequency, out var value) || !value)\n\t\t\t{\n\t\t\t\t_isFrequencyBroadcasting[frequency] = true;\n\t\t\t\tUpdateListenersForFrequency(frequency, isBroadcasting: true);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnMagazineReload(BaseProjectile baseProjectile, IAmmoContainer ammoSource, BasePlayer getOwnerPlayer)",
    "MethodSignature": "TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount)",
    "MethodSourseCode": "\n\tpublic virtual bool TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount = -1)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnMagazineReload\u0022, this, ammoSource, GetOwnerPlayer());\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!TryReload(ammoSource, desiredAmount))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tSendNetworkUpdateImmediate();\n\t\tItemManager.DoRemoves();\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (ownerPlayer != null)\n\t\t{\n\t\t\townerPlayer.inventory.ServerUpdate(0f);\n\t\t}\n\t\tif (!fractionalReload)\n\t\t{\n\t\t\tUpdateShieldState(bHeld: true);\n\t\t}\n\t\telse if (primaryMagazine.contents == primaryMagazine.capacity || !ammoSource.HasAmmo(primaryMagazine.definition.ammoTypes))\n\t\t{\n\t\t\tUpdateShieldState(bHeld: true);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFishCatch(Item item, BaseFishingRod baseFishingRod, BasePlayer ownerPlayer)",
    "MethodSignature": "CatchProcessBudgeted()",
    "MethodSourseCode": "\n\tprivate void CatchProcessBudgeted()\n\t{\n\t\tinQueue = false;\n\t\tFishingBobber fishingBobber = currentBobber.Get(serverside: true);\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)\n\t\t{\n\t\t\tServer_Cancel(FailReason.UserRequested);\n\t\t\treturn;\n\t\t}\n\t\tVector3 position = ownerPlayer.transform.position;\n\t\tfloat num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));\n\t\tfloat num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));\n\t\tif (num \u003E ((num2 \u003E 1.2f) ? 60f : 180f))\n\t\t{\n\t\t\tServer_Cancel(FailReason.BadAngle);\n\t\t\treturn;\n\t\t}\n\t\tif (num2 \u003E 1.2f \u0026\u0026 (float)lastSightCheck \u003E 0.4f)\n\t\t{\n\t\t\tif (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))\n\t\t\t{\n\t\t\t\tServer_Cancel(FailReason.Obstructed);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastSightCheck = 0f;\n\t\t}\n\t\tif (Vector3.Distance(position, fishingBobber.transform.position) \u003E MaxCastDistance * 2f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TooFarAway);\n\t\t\treturn;\n\t\t}\n\t\tif (Vector3.Distance(playerStartPosition, position) \u003E 1f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.PlayerMoved);\n\t\t\treturn;\n\t\t}\n\t\tif (CurrentState == CatchState.Waiting)\n\t\t{\n\t\t\tif ((float)catchTime \u003C 0f)\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_HookedSomething\u0022));\n\t\t\t\tCurrentState = CatchState.Catching;\n\t\t\t\tfishingBobber.SetFlag(Flags.Reserved1, b: true);\n\t\t\t\tnextFishStateChange = 0f;\n\t\t\t\tfishCatchDuration = 0f;\n\t\t\t\tstrainTimer = 0f;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tFishState fishState = currentFishState;\n\t\tif ((float)nextFishStateChange \u003C 0f)\n\t\t{\n\t\t\tfloat num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);\n\t\t\tif (currentFishState != 0)\n\t\t\t{\n\t\t\t\tcurrentFishState = (FishState)0;\n\t\t\t\tnextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 \u002B 1f);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003C 50)\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState = FishState.PullingLeft;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState = FishState.PullingRight;\n\t\t\t\t}\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003E 60 \u0026\u0026 Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) \u003C MaxCastDistance - 2f)\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState |= FishState.PullingBack;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((float)fishCatchDuration \u003E 120f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TimeOut);\n\t\t\treturn;\n\t\t}\n\t\tbool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);\n\t\tbool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);\n\t\tbool flag3 = HasReelInInput(ownerPlayer.serverInput);\n\t\tif (flag2 \u0026\u0026 flag)\n\t\t{\n\t\t\tflag2 = (flag = false);\n\t\t}\n\t\tUpdateFlags(flag2, flag, flag3);\n\t\tif (CurrentState == CatchState.Waiting)\n\t\t{\n\t\t\tflag = (flag2 = (flag3 = false));\n\t\t}\n\t\tif (flag2 \u0026\u0026 !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\n\t\t{\n\t\t\tflag2 = false;\n\t\t}\n\t\tif (flag \u0026\u0026 !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\n\t\t{\n\t\t\tflag = false;\n\t\t}\n\t\tfloat value = ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f);\n\t\tfishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier, value);\n\t\tbool flag4 = false;\n\t\tfloat num4 = 0f;\n\t\tif (flag3 || flag2 || flag)\n\t\t{\n\t\t\tflag4 = true;\n\t\t\tnum4 = 0.5f;\n\t\t}\n\t\tif (currentFishState != 0 \u0026\u0026 flag4)\n\t\t{\n\t\t\tif (currentFishState.Contains(FishState.PullingBack) \u0026\u0026 flag3)\n\t\t\t{\n\t\t\t\tnum4 = 1.5f;\n\t\t\t}\n\t\t\telse if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) \u0026\u0026 flag3)\n\t\t\t{\n\t\t\t\tnum4 = 1.2f;\n\t\t\t}\n\t\t\telse if (currentFishState.Contains(FishState.PullingLeft) \u0026\u0026 flag)\n\t\t\t{\n\t\t\t\tnum4 = 0.8f;\n\t\t\t}\n\t\t\telse if (currentFishState.Contains(FishState.PullingRight) \u0026\u0026 flag2)\n\t\t\t{\n\t\t\t\tnum4 = 0.8f;\n\t\t\t}\n\t\t}\n\t\tif (flag3 \u0026\u0026 currentFishState != 0)\n\t\t{\n\t\t\tnum4 \u002B= 1f;\n\t\t}\n\t\tnum4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;\n\t\tnum4 -= ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f) - 1f;\n\t\tif (flag4)\n\t\t{\n\t\t\tstrainTimer \u002B= UnityEngine.Time.deltaTime * num4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);\n\t\t}\n\t\tfloat num5 = strainTimer / 6f;\n\t\tSetFlag(Flags.Reserved1, flag4 \u0026\u0026 num5 \u003E 0.25f);\n\t\tif ((float)lastStrainUpdate \u003E 0.4f || fishState != currentFishState)\n\t\t{\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_UpdateFishState\u0022), (int)currentFishState, num5);\n\t\t\tlastStrainUpdate = 0f;\n\t\t}\n\t\tif (strainTimer \u003E 7f || ForceFail)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TensionBreak);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!(num2 \u003C= FishCatchDistance) \u0026\u0026 !ForceSuccess)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tCurrentState = CatchState.Caught;\n\t\t\tif (currentFishTarget != null)\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(currentFishTarget, 1, 0uL);\n\t\t\t\titem.SetItemOwnership(ownerPlayer, ItemOwnershipPhrases.Fishing);\n\t\t\t\tobject obj = Interface.CallHook(\u0022CanCatchFish\u0022, ownerPlayer, this, item);\n\t\t\t\tif (obj is bool \u0026\u0026 !(bool)obj)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobject obj2 = Interface.CallHook(\u0022OnFishCatch\u0022, item, this, ownerPlayer);\n\t\t\t\tif (obj2 is Item \u0026\u0026 obj2 as Item != item)\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t\titem = (Item)obj2;\n\t\t\t\t}\n\t\t\t\townerPlayer.GiveItem(item, GiveItemReason.Crafted);\n\t\t\t\tif (currentFishTarget.shortname == \u0022skull.human\u0022)\n\t\t\t\t{\n\t\t\t\t\titem.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));\n\t\t\t\t}\n\t\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 !string.IsNullOrEmpty(fishableModifier.SteamStatName))\n\t\t\t\t{\n\t\t\t\t\townerPlayer.stats.Add(fishableModifier.SteamStatName, 1);\n\t\t\t\t\townerPlayer.stats.Save(forceSteamSave: true);\n\t\t\t\t\tFishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);\n\t\t\t\t}\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnCaughtFish(ownerPlayer, item);\n\t\t\t}\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_OnCaughtFish\u0022), currentFishTarget.itemid);\n\t\t\townerPlayer.SignalBroadcast(Signal.Alt_Attack);\n\t\t\tInvoke(ResetLine, 6f);\n\t\t\tfishingBobber.Kill();\n\t\t\tcurrentBobber.Set(null);\n\t\t\tCancelInvoke(CatchProcess);\n\t\t\tInterface.CallHook(\u0022OnFishCaught\u0022, currentFishTarget, this, ownerPlayer);\n\t\t}\n\t}\n",
    "ClassName": "BaseFishingRod",
    "HookLineInvoke": 171
  },
  {
    "HookSignature": "OnRocketLaunched(BasePlayer player, BaseEntity baseEntity)",
    "MethodSignature": "SV_Launch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server]\n\tprivate void SV_Launch(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientAttack(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t\treturn;\n\t\t}\n\t\tif (reloadFinished \u0026\u0026 HasReloadCooldown())\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Reloading (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022reload_cooldown\u0022);\n\t\t\treturn;\n\t\t}\n\t\treloadStarted = false;\n\t\treloadFinished = false;\n\t\tif (!base.UsingInfiniteAmmoCheat)\n\t\t{\n\t\t\tif (primaryMagazine.contents \u003C= 0)\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Magazine empty (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022magazine_empty\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tModifyAmmoCount(-1);\n\t\t}\n\t\tSignalBroadcast(Signal.Attack, string.Empty, player.net.connection);\n\t\tVector3 vector = msg.read.Vector3();\n\t\tVector3 vector2 = msg.read.Vector3().normalized;\n\t\tbool num = msg.read.Bit();\n\t\tBaseEntity mounted = player.GetParentEntity();\n\t\tif (mounted == null)\n\t\t{\n\t\t\tmounted = player.GetMounted();\n\t\t}\n\t\tif (num)\n\t\t{\n\t\t\tif (mounted != null)\n\t\t\t{\n\t\t\t\tvector = mounted.transform.TransformPoint(vector);\n\t\t\t\tvector2 = mounted.transform.TransformDirection(vector2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvector = player.eyes.position;\n\t\t\t\tvector2 = player.eyes.BodyForward();\n\t\t\t}\n\t\t}\n\t\tif (!ValidateEyePos(player, vector))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemModProjectile component = primaryMagazine.ammoType.GetComponent\u003CItemModProjectile\u003E();\n\t\tif (!component)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022mod_missing\u0022);\n\t\t\treturn;\n\t\t}\n\t\tfloat num2 = GetAimCone() \u002B component.projectileSpread;\n\t\tif (num2 \u003E 0f)\n\t\t{\n\t\t\tvector2 = AimConeUtil.GetModifiedAimConeDirection(num2, vector2);\n\t\t}\n\t\tfloat num3 = 1f;\n\t\tif (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num3, 1237003025))\n\t\t{\n\t\t\tnum3 = hitInfo.distance - 0.1f;\n\t\t}\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector \u002B vector2 * num3);\n\t\tif (baseEntity == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbaseEntity.creatorEntity = player;\n\t\tServerProjectile component2 = baseEntity.GetComponent\u003CServerProjectile\u003E();\n\t\tif ((bool)component2)\n\t\t{\n\t\t\tcomponent2.InitializeVelocity(GetInheritedVelocity(player, vector2) \u002B vector2 * component2.speed * initialSpeedMultiplier);\n\t\t}\n\t\tbaseEntity.Spawn();\n\t\tProjectileLaunched_Server(component2);\n\t\tFacepunch.Rust.Analytics.Azure.OnExplosiveLaunched(player, baseEntity, this);\n\t\tInterface.CallHook(\u0022OnRocketLaunched\u0022, player, baseEntity);\n\t\tStartAttackCooldown(ScaleRepeatDelay(repeatDelay));\n\t\tItem ownerItem = GetOwnerItem();\n\t\tif (ownerItem != null)\n\t\t{\n\t\t\tif (!base.UsingInfiniteAmmoCheat)\n\t\t\t{\n\t\t\t\townerItem.LoseCondition(UnityEngine.Random.Range(1f, 2f));\n\t\t\t}\n\t\t\tBaseMountable mounted2 = player.GetMounted();\n\t\t\tif (mounted2 != null)\n\t\t\t{\n\t\t\t\tmounted2.OnWeaponFired(this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseLauncher",
    "HookLineInvoke": 86
  },
  {
    "HookSignature": "OnExplosiveDud(DudTimedExplosive dudTimedExplosive)",
    "MethodSignature": "Explode()",
    "MethodSourseCode": "\n\tpublic override void Explode()\n\t{\n\t\tif (creatorEntity != null \u0026\u0026 creatorEntity.IsNpc)\n\t\t{\n\t\t\tbase.Explode();\n\t\t}\n\t\telse if (UnityEngine.Random.Range(0f, 1f) \u003C dudChance \u0026\u0026 Interface.CallHook(\u0022OnExplosiveDud\u0022, this) == null)\n\t\t{\n\t\t\tBecomeDud();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbase.Explode();\n\t\t}\n\t}\n",
    "ClassName": "DudTimedExplosive",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanAdministerVending(BasePlayer player, NPCVendingMachine nPCVendingMachine)",
    "MethodSignature": "CanPlayerAdmin(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool CanPlayerAdmin(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanAdministerVending\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "NPCVendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDeleteVendingOffer(VendingMachine vendingMachine, int num)",
    "MethodSignature": "RPC_DeleteSellOrder(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_DeleteSellOrder(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (CanPlayerAdmin(player))\n\t\t{\n\t\t\tint num = msg.read.Int32();\n\t\t\tInterface.CallHook(\u0022OnDeleteVendingOffer\u0022, this, num);\n\t\t\tif (num \u003E= 0 \u0026\u0026 num \u003C sellOrders.sellOrders.Count)\n\t\t\t{\n\t\t\t\tProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[num];\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem, sellOrder.currencyIsBP, added: false);\n\t\t\t\tsellOrders.sellOrders.RemoveAt(num);\n\t\t\t}\n\t\t\tRefreshSellOrderStockLevel();\n\t\t\tUpdateMapMarker();\n\t\t\tSendSellOrders(player);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnSignalBroadcast(BaseEntity baseEntity, Network.Connection sourceConnection)",
    "MethodSignature": "SignalBroadcast(Signal signal, string arg, Connection sourceConnection)",
    "MethodSourseCode": "\n\tpublic void SignalBroadcast(Signal signal, string arg, Connection sourceConnection = null)\n\t{\n\t\tif (net != null \u0026\u0026 net.group != null \u0026\u0026 !base.limitNetworking \u0026\u0026 Interface.CallHook(\u0022OnSignalBroadcast\u0022, this, sourceConnection) == null)\n\t\t{\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022SignalFromServerEx\u0022, this, SendMethod.Unreliable, Priority.Immediate), (int)signal, arg, sourceConnection?.userid ?? 0);\n\t\t}\n\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnMetalDetectorFlagRequest(BaseMetalDetector baseMetalDetector, UnityEngine.Vector3 vector, BasePlayer player)",
    "MethodSignature": "RPC_RequestFlag(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(2uL)]\n\t[RPC_Server.FromOwner(false)]\n\tprivate void RPC_RequestFlag(RPCMessage rpc)\n\t{\n\t\tBasePlayer player = rpc.player;\n\t\tif (!(player == null) \u0026\u0026 !player.InSafeZone() \u0026\u0026 nearestSource != null)\n\t\t{\n\t\t\tVector3 vector = rpc.read.Vector3();\n\t\t\tInterface.CallHook(\u0022OnMetalDetectorFlagRequest\u0022, this, vector, player);\n\t\t\tif (nearestSource.VerifyScanPosition(player.transform.position, vector, out var spotPos))\n\t\t\t{\n\t\t\t\tnearestSource.Detected(spotPos);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseMetalDetector",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnCatapultFireForce(Catapult catapult, BasePlayer shooter, float num2)",
    "MethodSignature": "Fire(BasePlayer shooter, float force)",
    "MethodSourseCode": "\n\tpublic bool Fire(BasePlayer shooter, float force)\n\t{\n\t\tFireRecoil();\n\t\tfloat num = Mathf.Lerp(2f, 1f, Mathf.Clamp01(force));\n\t\tfloat num2 = Mathf.Lerp(0.5f, 1f, Mathf.Clamp01(force));\n\t\tbool flag = true;\n\t\tVector3 firingPos = muzzle.position;\n\t\tBasePlayer passenger = GetPassenger();\n\t\tobject obj = Interface.CallHook(\u0022OnCatapultFireForce\u0022, this, shooter, num2);\n\t\tif (obj is float)\n\t\t{\n\t\t\tnum2 = (float)obj;\n\t\t}\n\t\tif (passenger != null)\n\t\t{\n\t\t\tpassenger.ServerPosition = muzzle.transform.position;\n\t\t\tpassenger.Ragdoll(muzzle.transform.forward * (20f * num2) \u002B Vector3.up * (2.5f * num), matchPlayerGravity: false, flailInAir: true, dieOnImpact: true, this);\n\t\t\treturn true;\n\t\t}\n\t\tif (GamePhysics.CheckSphere(muzzle.position, 1f, 1236994833, QueryTriggerInteraction.Ignore))\n\t\t{\n\t\t\tVector3 vector = base.transform.position \u002B Vector3.up * 2f;\n\t\t\tif (GamePhysics.Trace(new Ray(vector, muzzle.position - vector), 0f, out var hitInfo, 10f, 1236994833, QueryTriggerInteraction.Ignore))\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tfiringPos = hitInfo.point - Vector3.up;\n\t\t\t}\n\t\t}\n\t\tServerProjectile projectile2;\n\t\tif (loadedAmmoDef == BoulderItemDef)\n\t\t{\n\t\t\tItemModCatapultBoulder component = loadedAmmoDef.GetComponent\u003CItemModCatapultBoulder\u003E();\n\t\t\tif (component == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tforeach (ItemModCatapultBoulder.ProjectileSettings projectileSetting in component.projectileSettings)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C projectileSetting.count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tVector3 forward = muzzle.forward;\n\t\t\t\t\tforward = Quaternion.Euler(UnityEngine.Random.Range(0f - component.spreadAngle, component.spreadAngle), UnityEngine.Random.Range(0f - component.spreadAngle, component.spreadAngle), 0f) * forward;\n\t\t\t\t\tif (FireProjectile(projectileSetting.prefab, firingPos, forward, shooter, 0.25f, 30f * num2, out var projectile))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprojectile.GetComponent\u003CTimedExplosive\u003E()?.ForceExplode();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprojectile.ignoreEntity = this;\n\t\t\t\t\t\tprojectile.gravityModifier *= num * UnityEngine.Random.Range(1f - projectileSetting.gravityModifier, 1f \u002B projectileSetting.gravityModifier);\n\t\t\t\t\t\tshooter.MarkHostileFor();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tloadedAmmoItem.UseItem();\n\t\t}\n\t\telse if (TryFireProjectile(ammoStorageRef.Get(base.isServer), AmmoTypes.CATAPULT_BOULDER, firingPos, muzzle.forward, shooter, 0.25f, 30f * num2, out projectile2))\n\t\t{\n\t\t\tprojectile2.ignoreEntity = this;\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tprojectile2.GetComponent\u003CTimedExplosive\u003E()?.ForceExplode();\n\t\t\t}\n\t\t\tprojectile2.gravityModifier *= num;\n\t\t\tshooter.MarkHostileFor();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "Catapult",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnItemLock(Item item)",
    "MethodSignature": "LockUnlock(bool bNewState)",
    "MethodSourseCode": "\n\tpublic void LockUnlock(bool bNewState)\n\t{\n\t\tif (HasFlag(Flag.IsLocked) != bNewState \u0026\u0026 (!bNewState || Interface.CallHook(\u0022OnItemLock\u0022, this) == null) \u0026\u0026 (bNewState || Interface.CallHook(\u0022OnItemUnlock\u0022, this) == null))\n\t\t{\n\t\t\tSetFlag(Flag.IsLocked, bNewState);\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBookmarkDelete(ComputerStation computerStation, BasePlayer player, string text)",
    "MethodSignature": "DeleteBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void DeleteBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player) || isStatic)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (IsValidIdentifier(text) \u0026\u0026 controlBookmarks.Contains(text) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkDelete\u0022, this, player, text) == null)\n\t\t{\n\t\t\tcontrolBookmarks.Remove(text);\n\t\t\tSendControlBookmarks(player);\n\t\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\t\tif (baseEntity != null \u0026\u0026 baseEntity.TryGetComponent\u003CIRemoteControllable\u003E(out var component) \u0026\u0026 component.GetIdentifier() == text)\n\t\t\t{\n\t\t\t\tStopControl(player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnEngineStarted(MotorRowboat motorRowboat, BasePlayer driver)",
    "MethodSignature": "EngineToggle(bool wantsOn)",
    "MethodSourseCode": "\n\tpublic void EngineToggle(bool wantsOn)\n\t{\n\t\tif (!fuelSystem.HasFuel(forceCheck: true))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer driver = GetDriver();\n\t\tif (!wantsOn || Interface.CallHook(\u0022OnEngineStart\u0022, this, driver) == null)\n\t\t{\n\t\t\tSetFlag(Flags.On, wantsOn);\n\t\t\tif (wantsOn)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnEngineStarted\u0022, this, driver);\n\t\t\t}\n\t\t\tif (wantsOn)\n\t\t\t{\n\t\t\t\trigidBody.WakeUp();\n\t\t\t\tbuoyancy.Wake();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MotorRowboat",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, ContainerIOEntity containerIOEntity)",
    "MethodSignature": "PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)",
    "MethodSourseCode": "\n\tpublic virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = \u0022\u0022, bool doPositionChecks = true)\n\t{\n\t\tif (Interface.CallHook(\u0022CanLootEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif ((needsBuildingPrivilegeToUse || StorageContainer.ShouldRequireAuthIfNoCodelock(this, requireAuthIfNotLocked)) \u0026\u0026 !player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (needsBuildingPrivilegeToUse \u0026\u0026 !player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif ((onlyOneUser \u0026\u0026 IsOpen()) || IsTransferring())\n\t\t{\n\t\t\tplayer.ShowToast(GameTip.Styles.Red_Normal, StorageContainer.LockedMessage, false);\n\t\t\treturn false;\n\t\t}\n\t\tif (panelToOpen == \u0022\u0022)\n\t\t{\n\t\t\tpanelToOpen = lootPanelName;\n\t\t}\n\t\tif (!CanOpenLootPanel(player, panelToOpen))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player.inventory.loot.StartLootingEntity(this, doPositionChecks))\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\tplayer.inventory.loot.AddContainer(_inventory);\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022RPC_OpenLootPanel\u0022, player), panelToOpen);\n\t\t\tSendNetworkUpdate();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "ContainerIOEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit resourceDeposit)",
    "MethodSignature": "CreateFromPosition(Vector3 pos)",
    "MethodSourseCode": "\n\tpublic ResourceDeposit CreateFromPosition(Vector3 pos)\n\t{\n\t\tVector2i indexFrom = GetIndexFrom(pos);\n\t\tUnityEngine.Random.State state = UnityEngine.Random.state;\n\t\tUnityEngine.Random.InitState((int)new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed \u002B World.Salt));\n\t\tResourceDeposit resourceDeposit = new ResourceDeposit\n\t\t{\n\t\t\torigin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20)\n\t\t};\n\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C 0.5f)\n\t\t{\n\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022stones\u0022), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbool flag = false;\n\t\t\tfloat num = 0f;\n\t\t\tif (World.Procedural)\n\t\t\t{\n\t\t\t\tif (TerrainMeta.BiomeMap.GetBiome(pos, 1) \u003E 0.5f)\n\t\t\t\t{\n\t\t\t\t\tnum \u002B= 0.25f;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum \u002B= 0.15f;\n\t\t\t}\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num)\n\t\t\t{\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022crude.oil\u0022), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(8f, 10f), ResourceDeposit.surveySpawnType.ITEM, liquid: true);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022stones\u0022), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);\n\t\t\t\tfloat num2 = 0f;\n\t\t\t\tnum2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) \u003E 0.5f) ? 1f : 0f) * 0.25f));\n\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num2)\n\t\t\t\t{\n\t\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022metal.ore\u0022), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);\n\t\t\t\t}\n\t\t\t\tfloat num3 = 0f;\n\t\t\t\tnum3 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) \u003E 0.5f) ? 1f : 0f) * (0.25f \u002B 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) \u002B 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));\n\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num3)\n\t\t\t\t{\n\t\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022sulfur.ore\u0022), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);\n\t\t\t\t}\n\t\t\t\tfloat num4 = 0f;\n\t\t\t\tif (World.Procedural)\n\t\t\t\t{\n\t\t\t\t\tif (TerrainMeta.BiomeMap.GetBiome(pos, 8) \u003E 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) \u003E 0.5f)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum4 \u002B= 0.25f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnum4 \u002B= 0.15f;\n\t\t\t\t}\n\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num4)\n\t\t\t\t{\n\t\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022hq.metal.ore\u0022), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_deposits.Add(indexFrom, resourceDeposit);\n\t\tInterface.CallHook(\u0022OnResourceDepositCreated\u0022, resourceDeposit);\n\t\tUnityEngine.Random.state = state;\n\t\treturn resourceDeposit;\n\t}\n",
    "ClassName": "ResourceDepositManager",
    "HookLineInvoke": 68
  },
  {
    "HookSignature": "OnQueueUpdate(Network.Connection c, int position)",
    "MethodSignature": "SendQueueUpdate(Connection c, int position)",
    "MethodSourseCode": "\n\tpublic void SendQueueUpdate(Connection c, int position)\n\t{\n\t\tif (Interface.CallHook(\u0022OnQueueUpdate\u0022, c, position) == null)\n\t\t{\n\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\tnetWrite.PacketID(Message.Type.QueueUpdate);\n\t\t\tnetWrite.UInt16((ushort)Queued);\n\t\t\tnetWrite.UInt16((ushort)position);\n\t\t\tnetWrite.Send(new SendInfo(c));\n\t\t}\n\t}\n",
    "ClassName": "ConnectionQueue",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnConnectionQueue(Network.Connection connection)",
    "MethodSignature": "Join(Connection connection)",
    "MethodSourseCode": "\n\tinternal void Join(Connection connection)\n\t{\n\t\tif (Interface.CallHook(\u0022OnConnectionQueue\u0022, connection) == null)\n\t\t{\n\t\t\tnextMessageTime = 0f;\n\t\t\tif ((Queued == 0 \u0026\u0026 !IsServerFull) || CanJumpQueue(connection))\n\t\t\t{\n\t\t\t\tJoinGame(connection);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconnection.state = Connection.State.InQueue;\n\t\t\tqueue.Add(connection);\n\t\t}\n\t}\n",
    "ClassName": "ConnectionQueue",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNetworkGroupLeft(BaseNetworkable baseNetworkable, Network.Visibility.Group group)",
    "MethodSignature": "OnNetworkGroupLeave(Group group)",
    "MethodSourseCode": "\n\tpublic virtual void OnNetworkGroupLeave(Group group)\n\t{\n\t\tInterface.CallHook(\u0022OnNetworkGroupLeft\u0022, this, group);\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBedMade(SleepingBag sleepingBag, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_MakeBed(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_MakeBed(RPCMessage msg)\n\t{\n\t\tif (!canBePublic || !IsPublic() || !msg.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ConVar.Server.max_sleeping_bags \u003E 0)\n\t\t{\n\t\t\tCanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);\n\t\t\tif (canAssignBedResult.HasValue)\n\t\t\t{\n\t\t\t\tif (canAssignBedResult.Value.Result != 0)\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Red_Normal, cannotMakeBedPhrase, false);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());\n\t\t\t\t}\n\t\t\t\tif (canAssignBedResult.Value.Result != 0)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tulong num = deployerUserID;\n\t\tdeployerUserID = msg.player.userID;\n\t\tNotifyPlayer(num);\n\t\tNotifyPlayer(deployerUserID);\n\t\tOnBagChangedOwnership(this, num);\n\t\tInterface.CallHook(\u0022OnBedMade\u0022, this, msg.player);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "OnTeamCreate(BasePlayer basePlayer)",
    "MethodSignature": "trycreateteam(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void trycreateteam(ConsoleSystem.Arg arg)\n\t{\n\t\tif (maxTeamSize == 0)\n\t\t{\n\t\t\targ.ReplyWith(\u0022Teams are disabled on this server\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer.currentTeam == 0L \u0026\u0026 Interface.CallHook(\u0022OnTeamCreate\u0022, basePlayer) == null)\n\t\t{\n\t\t\tPlayerTeam playerTeam = ServerInstance.CreateTeam();\n\t\t\tPlayerTeam playerTeam2 = playerTeam;\n\t\t\tplayerTeam2.teamLeader = basePlayer.userID;\n\t\t\tplayerTeam2.AddPlayer(basePlayer);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnTeamChanged(\u0022created\u0022, playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);\n\t\t\tInterface.CallHook(\u0022OnTeamCreated\u0022, basePlayer, playerTeam);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanLock(BasePlayer rpcPlayer, CodeLock codeLock)",
    "MethodSignature": "TryLock(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f, CheckParent = true)]\n\tprivate void TryLock(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 !IsLocked() \u0026\u0026 code.Length == 4 \u0026\u0026 Interface.CallHook(\u0022CanLock\u0022, rpc.player, this) == null \u0026\u0026 whitelistPlayers.Contains(rpc.player.userID))\n\t\t{\n\t\t\tDoEffect(effectLocked.resourcePath);\n\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnItemFilter(Item item, StorageContainer storageContainer, int targetSlot)",
    "MethodSignature": "ItemFilter(Item item, int targetSlot)",
    "MethodSourseCode": "\n\tpublic virtual bool ItemFilter(Item item, int targetSlot)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnItemFilter\u0022, item, this, targetSlot);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (onlyAcceptCategory == ItemCategory.All)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn item.info.category == onlyAcceptCategory;\n\t}\n",
    "ClassName": "StorageContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnServerRestartInterrupt()",
    "MethodSignature": "RestartServer(string strNotice, int iSeconds)",
    "MethodSourseCode": "\n\tpublic static void RestartServer(string strNotice, int iSeconds)\n\t{\n\t\tif (SingletonComponent\u003CServerMgr\u003E.Instance == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (SingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine != null)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnServerRestartInterrupt\u0022) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tShowToastToAllClients(GameTip.Styles.Server_Event, RESTART_INTERRUPTED_PHRASE, false);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.StopCoroutine(SingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine = null;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnServerRestart\u0022, strNotice, iSeconds) == null)\n\t\t{\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine = SingletonComponent\u003CServerMgr\u003E.Instance.ServerRestartWarning(strNotice, iSeconds);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.StartCoroutine(SingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.UpdateServerInformation();\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "CanBeHomingTargeted(PatrolHelicopter patrolHelicopter)",
    "MethodSignature": "IsValidHomingTarget()",
    "MethodSourseCode": "\n\tpublic bool IsValidHomingTarget()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeHomingTargeted\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PatrolHelicopter",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnShopCancelClick(ShopFront shopFront, BasePlayer msgPlayer)",
    "MethodSignature": "CancelClicked(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void CancelClicked(RPCMessage msg)\n\t{\n\t\tif (IsTradingPlayer(msg.player) \u0026\u0026 Interface.CallHook(\u0022OnShopCancelClick\u0022, this, msg.player) == null)\n\t\t{\n\t\t\t_ = (bool)vendorPlayer;\n\t\t\t_ = (bool)customerPlayer;\n\t\t\tResetTrade();\n\t\t}\n\t}\n",
    "ClassName": "ShopFront",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnSurveyGather(SurveyCharge surveyCharge, Item item)",
    "MethodSignature": "Explode()",
    "MethodSourseCode": "\n\tpublic override void Explode()\n\t{\n\t\tbase.Explode();\n\t\tif (WaterLevel.Test(base.transform.position, waves: true, volumes: true, this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);\n\t\tif (orCreate == null || Time.realtimeSinceStartup - orCreate.lastSurveyTime \u003C 10f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\torCreate.lastSurveyTime = Time.realtimeSinceStartup;\n\t\tif (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 point = hitOut.point;\n\t\t_ = hitOut.normal;\n\t\tList\u003CSurveyCrater\u003E obj = Pool.Get\u003CList\u003CSurveyCrater\u003E\u003E();\n\t\tVis.Entities(base.transform.position, 10f, obj, 1);\n\t\tbool num = obj.Count \u003E 0;\n\t\tPool.FreeUnmanaged(ref obj);\n\t\tif (num)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = false;\n\t\tbool flag2 = false;\n\t\tforeach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)\n\t\t{\n\t\t\tif (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM \u0026\u0026 !resource.isLiquid \u0026\u0026 resource.amount \u003E= 1000)\n\t\t\t{\n\t\t\t\tint num2 = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);\n\t\t\t\tint iAmount = 1;\n\t\t\t\tflag = true;\n\t\t\t\tif (resource.isLiquid)\n\t\t\t\t{\n\t\t\t\t\tflag2 = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i \u003C num2; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tItem item = ItemManager.Create(resource.type, iAmount, 0uL);\n\t\t\t\t\tInterface.CallHook(\u0022OnSurveyGather\u0022, this, item);\n\t\t\t\t\tVector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up);\n\t\t\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 1f, GetInheritedDropVelocity() \u002B modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation).SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tstring strPrefab = (flag2 ? craterPrefab_Oil.resourcePath : craterPrefab.resourcePath);\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SurveyCharge",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "CanFastTrackCraftTask(ItemCrafter itemCrafter, ItemCraftTask itemCraftTask, int taskID)",
    "MethodSignature": "FastTrackTask(int taskID)",
    "MethodSourseCode": "\n\tpublic bool FastTrackTask(int taskID)\n\t{\n\t\tint taskID2 = taskID;\n\t\tif (queue.Count == 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (owner != null \u0026\u0026 owner.IsTransferring())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tItemCraftTask value = queue.First.Value;\n\t\tif (value == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) =\u003E x.taskUID == taskID2 \u0026\u0026 !x.cancelled);\n\t\tif (itemCraftTask == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (itemCraftTask == value)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanFastTrackCraftTask\u0022, this, itemCraftTask, taskID);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tvalue.endTime = 0f;\n\t\tqueue.Remove(itemCraftTask);\n\t\tqueue.AddFirst(itemCraftTask);\n\t\towner.Command(\u0022note.craft_fasttracked\u0022, taskID2);\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "OnMissionStart(BaseMission baseMission, BaseMission.MissionInstance instance, BasePlayer assignee)",
    "MethodSignature": "MissionStart(MissionInstance instance, BasePlayer assignee)",
    "MethodSourseCode": "\n\tpublic virtual void MissionStart(MissionInstance instance, BasePlayer assignee)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMissionStart\u0022, this, instance, assignee) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C objectives.Length; i\u002B\u002B)\n\t\t{\n\t\t\tobjectives[i].Get().MissionStarted(i, instance, assignee);\n\t\t}\n\t\tif (acceptEffect.isValid)\n\t\t{\n\t\t\tDoMissionEffect(acceptEffect.resourcePath, assignee);\n\t\t}\n\t\tMissionEntityEntry[] array = missionEntities;\n\t\tforeach (MissionEntityEntry missionEntityEntry in array)\n\t\t{\n\t\t\tif (missionEntityEntry.spawnOnMissionStart)\n\t\t\t{\n\t\t\t\tinstance.GetMissionEntity(missionEntityEntry.identifier, assignee);\n\t\t\t}\n\t\t}\n\t\tif (AllowedTutorialItems != 0)\n\t\t{\n\t\t\tassignee.SetTutorialAllowance(AllowedTutorialItems);\n\t\t}\n\t\tInterface.CallHook(\u0022OnMissionStarted\u0022, this, instance, assignee);\n\t}\n",
    "ClassName": "BaseMission",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanCraft(PlayerBlueprints playerBlueprints, ItemDefinition itemDefinition, int skinItemId)",
    "MethodSignature": "CanCraft(int itemid, int skinItemId, ulong playerId)",
    "MethodSourseCode": "\n\tpublic bool CanCraft(int itemid, int skinItemId, ulong playerId)\n\t{\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemid);\n\t\tif (itemDefinition == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanCraft\u0022, this, itemDefinition, skinItemId);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (skinItemId != 0 \u0026\u0026 !base.baseEntity.UnlockAllSkins \u0026\u0026 !CheckSkinOwnership(skinItemId, playerId))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (base.baseEntity.currentCraftLevel \u003C (float)itemDefinition.Blueprint.GetWorkbenchLevel())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (HasUnlocked(itemDefinition))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "PlayerBlueprints",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnFlameExplosion(FlameExplosive flameExplosive, UnityEngine.Collider component)",
    "MethodSignature": "FlameExplode(Vector3 surfaceNormal)",
    "MethodSourseCode": "\n\tpublic void FlameExplode(Vector3 surfaceNormal)\n\t{\n\t\tif (!base.isServer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 position = base.transform.position;\n\t\tif (blockCreateUnderwater \u0026\u0026 WaterLevel.Test(position, waves: true, volumes: false))\n\t\t{\n\t\t\tbase.Explode();\n\t\t\treturn;\n\t\t}\n\t\tCollider component = GetComponent\u003CCollider\u003E();\n\t\tif ((bool)component)\n\t\t{\n\t\t\tcomponent.enabled = false;\n\t\t}\n\t\tfor (int i = 0; (float)i \u003C numToCreate; i\u002B\u002B)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, position);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tfloat num = (float)i / numToCreate;\n\t\t\t\tVector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle * spreadCurve.Evaluate(num), surfaceNormal);\n\t\t\t\tfloat y = UnityEngine.Random.Range(0f, 360f);\n\t\t\t\tQuaternion rotation = Quaternion.Euler(0f, y, 0f);\n\t\t\t\tbaseEntity.transform.SetPositionAndRotation(position, rotation);\n\t\t\t\tbaseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t\tInterface.CallHook(\u0022OnFlameExplosion\u0022, this, component);\n\t\t\t\tVector3 vector = modifiedAimConeDirection.normalized * UnityEngine.Random.Range(minVelocity, maxVelocity) * velocityCurve.Evaluate(num * UnityEngine.Random.Range(1f, 1.1f));\n\t\t\t\tFireBall component2 = baseEntity.GetComponent\u003CFireBall\u003E();\n\t\t\t\tif (component2 != null)\n\t\t\t\t{\n\t\t\t\t\tcomponent2.SetDelayedVelocity(vector);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbaseEntity.SetVelocity(vector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbase.Explode();\n\t}\n",
    "ClassName": "FlameExplosive",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnBroadcastCommand(string strCommand, object[] args)",
    "MethodSignature": "BroadcastToAllClients(string strCommand, object[] args)",
    "MethodSourseCode": "\n\tpublic static void BroadcastToAllClients(string strCommand, params object[] args)\n\t{\n\t\tif (Network.Net.sv.IsConnected() \u0026\u0026 Interface.CallHook(\u0022OnBroadcastCommand\u0022, strCommand, args) == null)\n\t\t{\n\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\tnetWrite.PacketID(Message.Type.ConsoleCommand);\n\t\t\tnetWrite.String(ConsoleSystem.BuildCommand(strCommand, args));\n\t\t\tnetWrite.Send(new SendInfo(Network.Net.sv.connections));\n\t\t}\n\t}\n",
    "ClassName": "ConsoleNetwork",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnAnimalDungProduce(RidableHorse ridableHorse)",
    "MethodSignature": "DoDung()",
    "MethodSourseCode": "\n\tprivate void DoDung()\n\t{\n\t\tdungProduction -= 1f;\n\t\tif (Interface.CallHook(\u0022OnAnimalDungProduce\u0022, this) == null)\n\t\t{\n\t\t\tQuaternion rotation = Quaternion.Euler(UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-180f, 180f));\n\t\t\tVector3 vVelocity = new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), UnityEngine.Random.Range(-1f, -3f), UnityEngine.Random.Range(-0.5f, 0.5f));\n\t\t\tItem item = ItemManager.Create(dungItem, 1, 0uL);\n\t\t\titem.SetItemOwnership(currentBreed.breedName.english, ItemOwnershipPhrases.Pooped);\n\t\t\titem.Drop(dungSpawnPoint.position \u002B UnityEngine.Random.insideUnitSphere * 0.1f, vVelocity, rotation);\n\t\t\tInterface.CallHook(\u0022OnAnimalDungProduced\u0022, this, item);\n\t\t}\n\t}\n",
    "ClassName": "RidableHorse",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnComposterUpdate(Composter composter)",
    "MethodSignature": "UpdateComposting()",
    "MethodSourseCode": "\n\tpublic void UpdateComposting()\n\t{\n\t\tif (Interface.CallHook(\u0022OnComposterUpdate\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C base.inventory.capacity; i\u002B\u002B)\n\t\t{\n\t\t\tItem slot = base.inventory.GetSlot(i);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tCompostItem(slot);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Composter",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerKeepAlive(BasePlayer basePlayer, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_KeepAlive(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_KeepAlive(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 !(msg.player == this) \u0026\u0026 IsWounded() \u0026\u0026 Interface.CallHook(\u0022OnPlayerKeepAlive\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tProlongWounding(10f);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, RidableHorse ridableHorse)",
    "MethodSignature": "SERVER_OpenLoot(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void SERVER_OpenLoot(RPCMessage rpc)\n\t{\n\t\tif (storageInventory == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = rpc.player;\n\t\tstring text = rpc.read.String();\n\t\tif (!(player == null) \u0026\u0026 player.CanInteract() \u0026\u0026 CanOpenStorage(player) \u0026\u0026 (!needsBuildingPrivilegeToUse || player.CanBuild()) \u0026\u0026 Interface.CallHook(\u0022CanLootEntity\u0022, player, this) == null \u0026\u0026 player.inventory.loot.StartLootingEntity(this))\n\t\t{\n\t\t\tItemContainer container = equipmentInventory;\n\t\t\tstring arg = lootPanelName;\n\t\t\tif (text == \u0022storage\u0022)\n\t\t\t{\n\t\t\t\targ = storagePanelName;\n\t\t\t\tcontainer = storageInventory;\n\t\t\t}\n\t\t\tplayer.inventory.loot.AddContainer(container);\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022RPC_OpenLootPanel\u0022, player), arg);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "RidableHorse",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnNpcAlert(ScientistNPC scientistNPC)",
    "MethodSignature": "Alert()",
    "MethodSourseCode": "\n\tpublic void Alert()\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcAlert\u0022, this) == null)\n\t\t{\n\t\t\tlastAlertedTime = Time.time;\n\t\t\tSetChatterType(RadioChatterType.Alert);\n\t\t}\n\t}\n",
    "ClassName": "ScientistNPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanSetBedPublic(BasePlayer msgPlayer, SleepingBag sleepingBag)",
    "MethodSignature": "RPC_MakePublic(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic virtual void RPC_MakePublic(RPCMessage msg)\n\t{\n\t\tif (!canBePublic || !msg.player.CanInteract() || (deployerUserID != (ulong)msg.player.userID \u0026\u0026 !msg.player.CanBuild()))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = msg.read.Bit();\n\t\tif (flag == IsPublic() || Interface.CallHook(\u0022CanSetBedPublic\u0022, msg.player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetPublic(flag);\n\t\tif (!IsPublic())\n\t\t{\n\t\t\tif (ConVar.Server.max_sleeping_bags \u003E 0)\n\t\t\t{\n\t\t\t\tCanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);\n\t\t\t\tif (canAssignBedResult.HasValue)\n\t\t\t\t{\n\t\t\t\t\tif (canAssignBedResult.Value.Result == BagResultType.Ok)\n\t\t\t\t\t{\n\t\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Long, cannotMakeBedPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());\n\t\t\t\t\t}\n\t\t\t\t\tif (canAssignBedResult.Value.Result != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tulong num = deployerUserID;\n\t\t\tdeployerUserID = msg.player.userID;\n\t\t\tNotifyPlayer(num);\n\t\t\tNotifyPlayer(deployerUserID);\n\t\t\tOnBagChangedOwnership(this, num);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, deployerUserID = msg.player.userID);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFacepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, 0uL);\n\t\t}\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnNetworkSubscriptionsGather(NetworkVisibilityGrid networkVisibilityGrid, Network.Visibility.Group group, ListHashSet\u003CNetwork.Visibility.Group\u003E groups, int radius)",
    "MethodSignature": "GetVisibleFrom(Group group, ListHashSet\u003CGroup\u003E groups, int radius)",
    "MethodSourseCode": "\n\tprivate void GetVisibleFrom(Group group, ListHashSet\u003CGroup\u003E groups, int radius)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNetworkSubscriptionsGather\u0022, this, group, groups, radius) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tListHashSet\u003CGroup\u003E groups2 = groups;\n\t\tgroups2.Add(Network.Net.sv.visibility.Get(0u));\n\t\tif (group.restricted)\n\t\t{\n\t\t\tgroups2.Add(group);\n\t\t\treturn;\n\t\t}\n\t\tint iD = (int)group.ID;\n\t\tif (iD \u003C startID)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tvar (num, num2, groupLayer2) = DeconstructGroupId(iD);\n\t\tAddLayers(num, num2, groupLayer2);\n\t\tfor (int i = 1; i \u003C= radius; i\u002B\u002B)\n\t\t{\n\t\t\tAddLayers(num - i, num2, groupLayer2);\n\t\t\tAddLayers(num \u002B i, num2, groupLayer2);\n\t\t\tAddLayers(num, num2 - i, groupLayer2);\n\t\t\tAddLayers(num, num2 \u002B i, groupLayer2);\n\t\t\tfor (int j = 1; j \u003C i; j\u002B\u002B)\n\t\t\t{\n\t\t\t\tAddLayers(num - i, num2 - j, groupLayer2);\n\t\t\t\tAddLayers(num - i, num2 \u002B j, groupLayer2);\n\t\t\t\tAddLayers(num \u002B i, num2 - j, groupLayer2);\n\t\t\t\tAddLayers(num \u002B i, num2 \u002B j, groupLayer2);\n\t\t\t\tAddLayers(num - j, num2 - i, groupLayer2);\n\t\t\t\tAddLayers(num \u002B j, num2 - i, groupLayer2);\n\t\t\t\tAddLayers(num - j, num2 \u002B i, groupLayer2);\n\t\t\t\tAddLayers(num \u002B j, num2 \u002B i, groupLayer2);\n\t\t\t}\n\t\t\tAddLayers(num - i, num2 - i, groupLayer2);\n\t\t\tAddLayers(num - i, num2 \u002B i, groupLayer2);\n\t\t\tAddLayers(num \u002B i, num2 - i, groupLayer2);\n\t\t\tAddLayers(num \u002B i, num2 \u002B i, groupLayer2);\n\t\t}\n\t\tvoid Add(int groupX, int groupY, int groupLayer)\n\t\t{\n\t\t\tgroups2.Add(Network.Net.sv.visibility.Get(CoordToID(groupX, groupY, groupLayer)));\n\t\t}\n\t\tvoid AddLayers(int groupX, int groupY, int groupLayer)\n\t\t{\n\t\t\tAdd(groupX, groupY, groupLayer);\n\t\t\tif (groupLayer == 0)\n\t\t\t{\n\t\t\t\tAdd(groupX, groupY, 1);\n\t\t\t}\n\t\t\tif (groupLayer == 1)\n\t\t\t{\n\t\t\t\tAdd(groupX, groupY, 2);\n\t\t\t\tAdd(groupX, groupY, 0);\n\t\t\t}\n\t\t\tif (groupLayer == 2)\n\t\t\t{\n\t\t\t\tAdd(groupX, groupY, 1);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "NetworkVisibilityGrid",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfListenerAdd(IRFObject obj, int frequency)",
    "MethodSignature": "AddListener(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void AddListener(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfListenerAdd\u0022, obj, frequency) == null \u0026\u0026 GetListenerSet(frequency).Add(obj))\n\t\t{\n\t\t\tbool value;\n\t\t\tbool on = _isFrequencyBroadcasting.TryGetValue(frequency, out value) \u0026\u0026 value;\n\t\t\tobj.RFSignalUpdate(on);\n\t\t\tInterface.CallHook(\u0022OnRfListenerAdded\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanExplosiveStick(TimedExplosive timedExplosive, BaseEntity entity)",
    "MethodSignature": "CanStickTo(BaseEntity entity)",
    "MethodSourseCode": "\n\tpublic virtual bool CanStickTo(BaseEntity entity)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanExplosiveStick\u0022, this, entity);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (entity.TryGetComponent\u003CDecorDeployable\u003E(out var _))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (entity is Drone)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (entity is TravellingVendor)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "TimedExplosive",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCoalingTowerStart(CoalingTower coalingTower, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_Unload(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void RPC_Unload(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnCoalingTowerStart\u0022, this, msg.player) == null \u0026\u0026 !TryUnloadActiveWagon(out var attemptStatus) \u0026\u0026 msg.player != null)\n\t\t{\n\t\t\tClientRPC(RpcTarget.Player(\u0022ActionFailed\u0022, msg.player), (byte)attemptStatus, arg2: true);\n\t\t}\n\t}\n",
    "ClassName": "CoalingTower",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnItemRemovedFromContainer(ItemContainer itemContainer, Item item)",
    "MethodSignature": "Remove(Item item)",
    "MethodSourseCode": "\n\tpublic bool Remove(Item item)\n\t{\n\t\tif (!itemList.Contains(item))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tonPreItemRemove?.Invoke(item);\n\t\titemList.Remove(item);\n\t\titem.parent = null;\n\t\tonItemParentChanged?.Invoke(parent, item);\n\t\tonItemAddedRemoved?.Invoke(item, arg2: false);\n\t\tItemContainer itemContainer = parent?.parent;\n\t\tif (itemContainer != null \u0026\u0026 itemContainer.onItemContentsChanged != null)\n\t\t{\n\t\t\titemContainer.onItemContentsChanged(item, arg2: false);\n\t\t}\n\t\tMarkDirty();\n\t\tInterface.CallHook(\u0022OnItemRemovedFromContainer\u0022, this, item);\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemContainer",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnRackedWeaponTaken(Item slot, BasePlayer player, WeaponRack weaponRack)",
    "MethodSignature": "GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex, bool tryHold, bool sendUpdate)",
    "MethodSourseCode": "\n\tprivate void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)\n\t{\n\t\tif (player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);\n\t\tif (weaponAtIndex == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\n\t\tif (slot == null || Interface.CallHook(\u0022OnRackedWeaponTake\u0022, slot, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tClearSlot(weaponAtIndex);\n\t\tbool flag = false;\n\t\tbool flag2 = true;\n\t\tif (slot.IsBackpack())\n\t\t{\n\t\t\tflag2 = false;\n\t\t\tif (slot.info.GetComponent\u003CItemModBackpack\u003E() != null \u0026\u0026 player.inventory.GetAnyBackpack() == null)\n\t\t\t{\n\t\t\t\tflag = slot.MoveToContainer(player.inventory.containerWear);\n\t\t\t}\n\t\t}\n\t\tif (!flag)\n\t\t{\n\t\t\tflag = slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex);\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tif (flag2 \u0026\u0026 ((tryHold \u0026\u0026 player.GetHeldEntity() == null) || playerBeltIndex != -1))\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022SetActiveBeltSlot\u0022, player), slot.position, slot.uid);\n\t\t\t}\n\t\t\tClientRPC(RpcTarget.Player(\u0022PlayGrabSound\u0022, player), slot.info.itemid);\n\t\t}\n\t\telse if (!slot.MoveToContainer(player.inventory.containerMain))\n\t\t{\n\t\t\tslot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\n\t\t}\n\t\tif (sendUpdate)\n\t\t{\n\t\t\tItemManager.DoRemoves();\n\t\t\tSendNetworkUpdateImmediate();\n\t\t}\n\t\tInterface.CallHook(\u0022OnRackedWeaponTaken\u0022, slot, player, this);\n\t}\n",
    "ClassName": "WeaponRack",
    "HookLineInvoke": 49
  },
  {
    "HookSignature": "OnMapMarkerRemove(BasePlayer basePlayer, System.Collections.Generic.List\u003CProtoBuf.MapNote\u003E StatePointsOfInterest, int num)",
    "MethodSignature": "Server_RemovePointOfInterest(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner(false)]\n\t[RPC_Server.CallsPerSecond(10uL)]\n\tpublic void Server_RemovePointOfInterest(RPCMessage msg)\n\t{\n\t\tint num = msg.read.Int32();\n\t\tif (State.pointsOfInterest != null \u0026\u0026 State.pointsOfInterest.Count \u003E num \u0026\u0026 num \u003E= 0 \u0026\u0026 Interface.CallHook(\u0022OnMapMarkerRemove\u0022, this, State.pointsOfInterest, num) == null)\n\t\t{\n\t\t\tState.pointsOfInterest[num].Dispose();\n\t\t\tState.pointsOfInterest.RemoveAt(num);\n\t\t\tDirtyPlayerState();\n\t\t\tSendMarkersToClient();\n\t\t\tTeamUpdate();\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnDecayDamage(DecayEntity decayEntity)",
    "MethodSignature": "OnDecay(Decay decay, float decayDeltaTime)",
    "MethodSourseCode": "\n\tpublic virtual void OnDecay(Decay decay, float decayDeltaTime)\n\t{\n\t\tlastDecayTick = UnityEngine.Time.time;\n\t\tif (HasParent() || !decay.ShouldDecay(this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = decayDeltaTime * ConVar.Decay.scale;\n\t\tif (ConVar.Decay.upkeep)\n\t\t{\n\t\t\tupkeepTimer \u002B= num;\n\t\t\tif (upkeepTimer \u003E 0f)\n\t\t\t{\n\t\t\t\tBuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();\n\t\t\t\tif (buildingPrivilege != null)\n\t\t\t\t{\n\t\t\t\t\tupkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (upkeepTimer \u003C 1f)\n\t\t\t{\n\t\t\t\tif (base.healthFraction \u003C 1f \u0026\u0026 GetEntityHealScale() \u003E 0f \u0026\u0026 base.SecondsSinceAttacked \u003E 600f \u0026\u0026 Interface.CallHook(\u0022OnDecayHeal\u0022, this) == null)\n\t\t\t\t{\n\t\t\t\t\tfloat num2 = decayDeltaTime / GetEntityDecayDuration() * GetEntityHealScale();\n\t\t\t\t\tHeal(MaxHealth() * num2);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tupkeepTimer = 1f;\n\t\t}\n\t\tdecayTimer \u002B= num;\n\t\tif (decayTimer \u003C GetEntityDecayDelay())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022DecayTick\u0022))\n\t\t{\n\t\t\tfloat num3 = 1f;\n\t\t\tif (ConVar.Decay.upkeep)\n\t\t\t{\n\t\t\t\tif (!BypassInsideDecayMultiplier \u0026\u0026 !IsOutside())\n\t\t\t\t{\n\t\t\t\t\tnum3 *= ConVar.Decay.upkeep_inside_decay_scale;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C decayPoints.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tDecayPoint decayPoint = decayPoints[i];\n\t\t\t\t\tif (decayPoint.IsOccupied(this))\n\t\t\t\t\t{\n\t\t\t\t\t\tnum3 -= decayPoint.protection;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnDecayDamage\u0022, this) == null \u0026\u0026 num3 \u003E 0f)\n\t\t\t{\n\t\t\t\tfloat num4 = num / GetEntityDecayDuration() * MaxHealth();\n\t\t\t\tHurt(num4 * num3 * decayVariance, DamageType.Decay);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DecayEntity",
    "HookLineInvoke": 57
  },
  {
    "HookSignature": "OnRackedWeaponLoaded(Item slot, ItemDefinition itemDefinition, BasePlayer player, WeaponRack weaponRack)",
    "MethodSignature": "LoadWeaponAmmo(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tprivate void LoadWeaponAmmo(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!player)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint gridIndex = msg.read.Int32();\n\t\tint num = msg.read.Int32();\n\t\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);\n\t\tif (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\n\t\tif (slot == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity heldEntity = slot.GetHeldEntity();\n\t\tif (heldEntity == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseProjectile component = heldEntity.GetComponent\u003CBaseProjectile\u003E();\n\t\tif (component == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);\n\t\tif (itemDefinition == null || Interface.CallHook(\u0022OnRackedWeaponLoad\u0022, slot, itemDefinition, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (itemDefinition == SnowballGun.SnowballInventoryItem)\n\t\t{\n\t\t\titemDefinition = SnowballGun.SnowballAmmoItem;\n\t\t\tif (!(itemDefinition != null))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnum = itemDefinition.itemid;\n\t\t}\n\t\tif (itemDefinition == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemModProjectile component2 = itemDefinition.GetComponent\u003CItemModProjectile\u003E();\n\t\tif (!(component2 == null) \u0026\u0026 component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))\n\t\t{\n\t\t\tif (num != component.primaryMagazine.ammoType.itemid \u0026\u0026 component.primaryMagazine.contents \u003E 0)\n\t\t\t{\n\t\t\t\tplayer.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));\n\t\t\t\tcomponent.SetAmmoCount(0);\n\t\t\t}\n\t\t\tcomponent.primaryMagazine.ammoType = itemDefinition;\n\t\t\tcomponent.TryReloadMagazine(player.inventory);\n\t\t\tSetSlotAmmoDetails(weaponAtIndex, slot);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tClientRPC(RpcTarget.Player(\u0022PlayAmmoSound\u0022, player), itemDefinition.itemid, 0);\n\t\t\tInterface.CallHook(\u0022OnRackedWeaponLoaded\u0022, slot, itemDefinition, player, this);\n\t\t}\n\t}\n",
    "ClassName": "WeaponRack",
    "HookLineInvoke": 62
  },
  {
    "HookSignature": "OnVendingShopOpened(InvisibleVendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "OnConversationAction(BasePlayer player, string action)",
    "MethodSourseCode": "\n\tpublic virtual void OnConversationAction(BasePlayer player, string action)\n\t{\n\t\tif (action == \u0022openvending\u0022)\n\t\t{\n\t\t\tInvisibleVendingMachine vendingMachine = GetVendingMachine();\n\t\t\tif (vendingMachine != null \u0026\u0026 Vector3.Distance(player.transform.position, base.transform.position) \u003C 5f)\n\t\t\t{\n\t\t\t\tForceEndConversation(player);\n\t\t\t\tif (Interface.CallHook(\u0022OnVendingShopOpen\u0022, vendingMachine, player) == null)\n\t\t\t\t{\n\t\t\t\t\tvendingMachine.PlayerOpenLoot(player, \u0022vendingmachine.customer\u0022, doPositionChecks: false);\n\t\t\t\t\tInterface.CallHook(\u0022OnVendingShopOpened\u0022, vendingMachine, player);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(\u0022scrap\u0022);\n\t\tNPCConversationResultAction[] array = conversationResultActions;\n\t\tforeach (NPCConversationResultAction nPCConversationResultAction in array)\n\t\t{\n\t\t\tif (!(nPCConversationResultAction.action == action))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCleanupConversingPlayers();\n\t\t\tforeach (BasePlayer conversingPlayer in conversingPlayers)\n\t\t\t{\n\t\t\t\tif (!(conversingPlayer == player) \u0026\u0026 !(conversingPlayer == null))\n\t\t\t\t{\n\t\t\t\t\tint speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex(\u0022startbusy\u0022);\n\t\t\t\t\tForceSpeechNode(conversingPlayer, speechNodeIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint num = nPCConversationResultAction.scrapCost;\n\t\t\tusing PooledList\u003CItem\u003E pooledList = Facepunch.Pool.Get\u003CPooledList\u003CItem\u003E\u003E();\n\t\t\tplayer.inventory.FindItemsByItemID(pooledList, itemDefinition.itemid);\n\t\t\tforeach (Item item in pooledList)\n\t\t\t{\n\t\t\t\tnum -= item.amount;\n\t\t\t}\n\t\t\tif (num \u003E 0)\n\t\t\t{\n\t\t\t\tint speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex(\u0022toopoor\u0022);\n\t\t\t\tForceSpeechNode(player, speechNodeIndex2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);\n\t\t\tnum = nPCConversationResultAction.scrapCost;\n\t\t\tforeach (Item item2 in pooledList)\n\t\t\t{\n\t\t\t\tint num2 = Mathf.Min(num, item2.amount);\n\t\t\t\titem2.UseItem(num2);\n\t\t\t\tnum -= num2;\n\t\t\t\tif (num \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastActionPlayer = player;\n\t\t\tBroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);\n\t\t\tlastActionPlayer = null;\n\t\t\tbreak;\n\t\t}\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "CanUnlock(BasePlayer rpcPlayer, CodeLock codeLock)",
    "MethodSignature": "TryUnlock(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f, CheckParent = true)]\n\t[RPC_Server]\n\tprivate void TryUnlock(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanUnlock\u0022, rpc.player, this) == null \u0026\u0026 !IsCodeEntryBlocked() \u0026\u0026 whitelistPlayers.Contains(rpc.player.userID))\n\t\t{\n\t\t\tDoEffect(effectUnlocked.resourcePath);\n\t\t\tSetFlag(Flags.Locked, b: false);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnRfBroadcasterRemove(IRFObject obj, int frequency)",
    "MethodSignature": "RemoveBroadcaster(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void RemoveBroadcaster(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfBroadcasterRemove\u0022, obj, frequency) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tHashSet\u003CIRFObject\u003E broadcasterSet = GetBroadcasterSet(frequency);\n\t\tif (broadcasterSet.RemoveWhere((IRFObject b) =\u003E b == null || !BaseEntityEx.IsValidEntityReference(b)) \u003E 0)\n\t\t{\n\t\t\tDebug.LogWarning($\u0022Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.\u0022);\n\t\t}\n\t\tif (broadcasterSet.Remove(obj))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnRfBroadcasterRemoved\u0022, obj, frequency);\n\t\t\tif (broadcasterSet.Count == 0)\n\t\t\t{\n\t\t\t\t_isFrequencyBroadcasting[frequency] = false;\n\t\t\t\tUpdateListenersForFrequency(frequency, isBroadcasting: false);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnExplosiveFuseSet(TimedExplosive timedExplosive, float fuseLength)",
    "MethodSignature": "SetFuse(float fuseLength)",
    "MethodSourseCode": "\n\tpublic virtual void SetFuse(float fuseLength)\n\t{\n\t\tif (base.isServer)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnExplosiveFuseSet\u0022, this, fuseLength);\n\t\t\tif (obj is float)\n\t\t\t{\n\t\t\t\tfuseLength = (float)obj;\n\t\t\t}\n\t\t\tInvoke(Explode, fuseLength);\n\t\t\tSetFlag(Flags.Reserved2, b: true);\n\t\t}\n\t}\n",
    "ClassName": "TimedExplosive",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnClothingItemChanged(PlayerInventory playerInventory, Item item, bool bAdded)",
    "MethodSignature": "OnClothingChanged(Item item, bool bAdded)",
    "MethodSourseCode": "\n\tpublic void OnClothingChanged(Item item, bool bAdded)\n\t{\n\t\tbase.baseEntity.SV_ClothingChanged();\n\t\tif (ItemManager.EnablePooling)\n\t\t{\n\t\t\tif (!IsInvoking(DeferredServerUpdateAction))\n\t\t\t{\n\t\t\t\tInvoke(DeferredServerUpdateAction, 0f);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tItemManager.DoRemoves();\n\t\t\tServerUpdate(0f);\n\t\t}\n\t\tif (item.position == 7)\n\t\t{\n\t\t\titem.RecalulateParentEntity(children: true);\n\t\t\tInvoke(UpdatedVisibleHolsteredItems, 0.1f);\n\t\t\tif (base.baseEntity.GetHeldEntity() != null)\n\t\t\t{\n\t\t\t\tbase.baseEntity.GetHeldEntity().UpdateShieldState(bHeld: true);\n\t\t\t}\n\t\t\titem?.contents?.onItemAddedRemoved?.Invoke(item, bAdded);\n\t\t}\n\t\tbase.baseEntity.ProcessMissionEvent(BaseMission.MissionEventType.CLOTHINGCHANGED, 0, 0f);\n\t\tInterface.CallHook(\u0022OnClothingItemChanged\u0022, this, item, bAdded);\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnRconConnection(System.Net.IPAddress iPEndPointAddress)",
    "MethodSignature": "ProcessConnections()",
    "MethodSourseCode": "\n\t\tprivate void ProcessConnections()\n\t\t{\n\t\t\tif (!server.Pending())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSocket socket = server.AcceptSocket();\n\t\t\tif (socket != null)\n\t\t\t{\n\t\t\t\tIPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;\n\t\t\t\tif (Interface.CallHook(\u0022OnRconConnection\u0022, iPEndPoint.Address) != null)\n\t\t\t\t{\n\t\t\t\t\tsocket.Close();\n\t\t\t\t}\n\t\t\t\telse if (IsBanned(iPEndPoint.Address))\n\t\t\t\t{\n\t\t\t\t\tUnityEngine.Debug.Log(\u0022[RCON] Ignoring connection - banned. \u0022 \u002B iPEndPoint.Address.ToString());\n\t\t\t\t\tsocket.Close();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tclients.Add(new RConClient(socket));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n",
    "ClassName": "RCon",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPlayerHandcuffed(BasePlayer victim, BasePlayer handcuffer)",
    "MethodSignature": "SV_HandcuffVictim(BasePlayer victim, BasePlayer handcuffer)",
    "MethodSourseCode": "\n\tprivate void SV_HandcuffVictim(BasePlayer victim, BasePlayer handcuffer)\n\t{\n\t\tif (victim == null || handcuffer == null || victim.IsRestrained || (!victim.CurrentGestureIsSurrendering \u0026\u0026 !victim.IsWounded()) || Vector3.Distance(victim.transform.position, handcuffer.transform.position) \u003E UseDistance)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem ownerItem = GetOwnerItem();\n\t\tif (ownerItem == null || Interface.CallHook(\u0022OnPlayerHandcuff\u0022, victim, handcuffer) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tvictim.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, b: true);\n\t\tvictim.SendNetworkUpdateImmediate();\n\t\townerItem.SetFlag(Item.Flag.IsOn, b: true);\n\t\tbool flag = true;\n\t\tif (!ownerItem.MoveToContainer(victim.inventory.containerBelt))\n\t\t{\n\t\t\tItem slot = victim.inventory.containerBelt.GetSlot(0);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tif (!slot.MoveToContainer(victim.inventory.containerMain))\n\t\t\t\t{\n\t\t\t\t\tif (slot.contents != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot.contents.SetLocked(isLocked: false, lockSubItems: true);\n\t\t\t\t\t}\n\t\t\t\t\tslot.DropAndTossUpwards(victim.transform.position);\n\t\t\t\t}\n\t\t\t\tif (!ownerItem.MoveToContainer(victim.inventory.containerBelt))\n\t\t\t\t{\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!flag)\n\t\t{\n\t\t\townerItem.SetFlag(Item.Flag.IsOn, b: false);\n\t\t\tvictim.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, b: false);\n\t\t}\n\t\townerItem.MarkDirty();\n\t\tif (flag)\n\t\t{\n\t\t\tvictim.Server_CancelGesture();\n\t\t\tif (victim.IsBot)\n\t\t\t{\n\t\t\t\tInventory.EquipItemInSlot(victim, 0);\n\t\t\t}\n\t\t\tvictim.ClientRPC(RpcTarget.Player(\u0022SetActiveBeltSlot\u0022, victim), ownerItem.position, ownerItem.uid);\n\t\t\tSetLocked(flag: true, victim, ownerItem);\n\t\t\tEffect.server.Run(lockEffect.resourcePath, victim, 0u, Vector3.zero, Vector3.zero);\n\t\t\tInterface.CallHook(\u0022OnPlayerHandcuffed\u0022, victim, handcuffer);\n\t\t}\n\t}\n",
    "ClassName": "Handcuffs",
    "HookLineInvoke": 51
  },
  {
    "HookSignature": "OnPlayerSpawn(BasePlayer basePlayer, Network.Connection connection)",
    "MethodSignature": "SpawnNewPlayer(Network.Connection connection)",
    "MethodSourseCode": "\n\tpublic BasePlayer SpawnNewPlayer(Network.Connection connection)\n\t{\n\t\tRelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(connection.userid);\n\t\tBasePlayer.SpawnPoint spawnPoint = FindSpawnPoint(null, playerTeam?.teamID ?? 0);\n\t\tBasePlayer basePlayer = GameManager.server.CreateEntity(\u0022assets/prefabs/player/player.prefab\u0022, spawnPoint.pos, spawnPoint.rot).ToPlayer();\n\t\tif (Interface.CallHook(\u0022OnPlayerSpawn\u0022, basePlayer, connection) != null)\n\t\t{\n\t\t\treturn (BasePlayer)(object)spawnPoint;\n\t\t}\n\t\tbasePlayer.health = 0f;\n\t\tbasePlayer.lifestate = BaseCombatEntity.LifeState.Dead;\n\t\tbasePlayer.ResetLifeStateOnSpawn = false;\n\t\tbasePlayer.limitNetworking = true;\n\t\tif (connection == null)\n\t\t{\n\t\t\tbasePlayer.EnableTransferProtection();\n\t\t}\n\t\tbasePlayer.Spawn();\n\t\tbasePlayer.limitNetworking = false;\n\t\tif (connection != null)\n\t\t{\n\t\t\tbasePlayer.PlayerInit(connection);\n\t\t\tbool flag = UnityEngine.Application.isEditor || (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 \u0026\u0026 !basePlayer.hasPreviousLife);\n\t\t\tif ((bool)BaseGameMode.GetActiveGameMode(serverside: true))\n\t\t\t{\n\t\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnNewPlayer(basePlayer, flag);\n\t\t\t}\n\t\t\telse if (flag)\n\t\t\t{\n\t\t\t\tbasePlayer.Respawn();\n\t\t\t}\n\t\t\tDebugEx.Log($\u0022{basePlayer.displayName} with steamid {basePlayer.userID.Get()} joined from ip {basePlayer.net.connection.ipaddress}\u0022);\n\t\t\tDebugEx.Log($\u0022\\tNetworkId {basePlayer.userID.Get()} is {basePlayer.net.ID} ({basePlayer.displayName})\u0022);\n\t\t\tif (basePlayer.net.connection.ownerid != 0L \u0026\u0026 basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)\n\t\t\t{\n\t\t\t\tDebugEx.Log($\u0022\\t{basePlayer} is sharing the account {basePlayer.net.connection.ownerid}\u0022);\n\t\t\t}\n\t\t}\n\t\tif (playerTeam != null \u0026\u0026 playerTeam.usePartySpawn \u0026\u0026 spawnPoint.isProcedualSpawn \u0026\u0026 playerTeam.firstSpawnLocation == default(Vector3))\n\t\t{\n\t\t\tplayerTeam.firstSpawnLocation = spawnPoint.pos;\n\t\t}\n\t\treturn basePlayer;\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerWound(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "BecomeWounded(HitInfo info)",
    "MethodSourseCode": "\n\tpublic void BecomeWounded(HitInfo info)\n\t{\n\t\tif (IsWounded() || Interface.CallHook(\u0022OnPlayerWound\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = info != null \u0026\u0026 info.damageTypes.GetMajorityDamageType() == DamageType.Fall;\n\t\tif (IsCrawling())\n\t\t{\n\t\t\twoundedByFallDamage |= flag;\n\t\t\tGoToIncapacitated(info);\n\t\t\treturn;\n\t\t}\n\t\twoundedByFallDamage = flag;\n\t\tif (flag || !ConVar.Server.crawlingenabled)\n\t\t{\n\t\t\tGoToIncapacitated(info);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGoToCrawling(info);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnVehicleLockableCheck(ModularCarCodeLock modularCarCodeLock)",
    "MethodSignature": "CanHaveALock()",
    "MethodSourseCode": "\n\tpublic bool CanHaveALock()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnVehicleLockableCheck\u0022, this);\n\t\tif (obj != null)\n\t\t{\n\t\t\tif (!(obj is bool))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!owner.IsDead())\n\t\t{\n\t\t\treturn owner.HasDriverMountPoints();\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "ModularCarCodeLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnAmmoUnload(BaseProjectile component, Item item, BasePlayer player)",
    "MethodSignature": "UnloadAmmo(Item item, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void UnloadAmmo(Item item, BasePlayer player)\n\t{\n\t\tBaseProjectile component = item.GetHeldEntity().GetComponent\u003CBaseProjectile\u003E();\n\t\tif (!component.canUnloadAmmo || Interface.CallHook(\u0022OnAmmoUnload\u0022, component, item, player) != null || !component)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = component.primaryMagazine.contents;\n\t\tif (num \u003C= 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tcomponent.SetAmmoCount(0);\n\t\titem.MarkDirty();\n\t\tSendNetworkUpdateImmediate();\n\t\tint stackable = component.primaryMagazine.ammoType.stackable;\n\t\tif (num \u003E stackable)\n\t\t{\n\t\t\tint num2 = Mathf.FloorToInt(num / component.primaryMagazine.ammoType.stackable);\n\t\t\tnum %= stackable;\n\t\t\tfor (int i = 0; i \u003C num2; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tItem item2 = ItemManager.Create(component.primaryMagazine.ammoType, stackable, 0uL);\n\t\t\t\tplayer.GiveItem(item2);\n\t\t\t}\n\t\t}\n\t\tif (num \u003E 0)\n\t\t{\n\t\t\tItem item3 = ItemManager.Create(component.primaryMagazine.ammoType, num, 0uL);\n\t\t\tplayer.GiveItem(item3);\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerSpectateEnd(BasePlayer basePlayer, string spectateFilter)",
    "MethodSignature": "StopSpectating()",
    "MethodSourseCode": "\n\tpublic void StopSpectating()\n\t{\n\t\tif (IsSpectating() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSpectateEnd\u0022, this, spectateFilter) == null)\n\t\t{\n\t\t\tSetParent(null);\n\t\t\tSetPlayerFlag(PlayerFlags.Spectating, b: false);\n\t\t\tUnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnGibsSpawned(System.Collections.Generic.List\u003CServerGib\u003E list, UnityEngine.GameObject creator)",
    "MethodSignature": "CreateGibs(string entityToCreatePath, GameObject creator, GameObject gibSource, Vector3 inheritVelocity, float spreadVelocity)",
    "MethodSourseCode": "\n\tpublic static List\u003CServerGib\u003E CreateGibs(string entityToCreatePath, GameObject creator, GameObject gibSource, Vector3 inheritVelocity, float spreadVelocity)\n\t{\n\t\tList\u003CServerGib\u003E list = new List\u003CServerGib\u003E();\n\t\tMeshRenderer[] componentsInChildren = gibSource.GetComponentsInChildren\u003CMeshRenderer\u003E(includeInactive: true);\n\t\tforeach (MeshRenderer meshRenderer in componentsInChildren)\n\t\t{\n\t\t\tMeshFilter component = meshRenderer.GetComponent\u003CMeshFilter\u003E();\n\t\t\tVector3 normalized = meshRenderer.transform.localPosition.normalized;\n\t\t\tVector3 vector = creator.transform.localToWorldMatrix.MultiplyPoint(meshRenderer.transform.localPosition) \u002B normalized * 0.5f;\n\t\t\tQuaternion quaternion = creator.transform.rotation * meshRenderer.transform.localRotation;\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(entityToCreatePath, vector, quaternion);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tServerGib component2 = baseEntity.GetComponent\u003CServerGib\u003E();\n\t\t\t\tcomponent2.transform.SetPositionAndRotation(vector, quaternion);\n\t\t\t\tcomponent2._gibName = meshRenderer.name;\n\t\t\t\tMeshCollider component3 = meshRenderer.GetComponent\u003CMeshCollider\u003E();\n\t\t\t\tMesh physicsMesh = ((component3 != null) ? component3.sharedMesh : component.sharedMesh);\n\t\t\t\tcomponent2.PhysicsInit(physicsMesh);\n\t\t\t\tVector3 vector2 = meshRenderer.transform.localPosition.normalized * spreadVelocity;\n\t\t\t\tcomponent2.rigidBody.velocity = inheritVelocity \u002B vector2;\n\t\t\t\tcomponent2.rigidBody.angularVelocity = Vector3Ex.Range(-1f, 1f).normalized * 1f;\n\t\t\t\tcomponent2.rigidBody.WakeUp();\n\t\t\t\tcomponent2.Spawn();\n\t\t\t\tlist.Add(component2);\n\t\t\t}\n\t\t}\n\t\tforeach (ServerGib item in list)\n\t\t{\n\t\t\tforeach (ServerGib item2 in list)\n\t\t\t{\n\t\t\t\tif (!(item == item2))\n\t\t\t\t{\n\t\t\t\t\tPhysics.IgnoreCollision(item2.GetCollider(), item.GetCollider(), ignore: true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnGibsSpawned\u0022, list, creator);\n\t\treturn list;\n\t}\n",
    "ClassName": "ServerGib",
    "HookLineInvoke": 38
  },
  {
    "HookSignature": "OnTrainCarUncouple(TrainCar trainCar, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_WantsUncouple(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void RPC_WantsUncouple(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 !(Vector3.SqrMagnitude(base.transform.position - player.transform.position) \u003E 200f) \u0026\u0026 Interface.CallHook(\u0022OnTrainCarUncouple\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool front = msg.read.Bit();\n\t\t\tcoupling.Uncouple(front);\n\t\t}\n\t}\n",
    "ClassName": "TrainCar",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnSignUpdated(CarvablePumpkin carvablePumpkin, BasePlayer msgPlayer)",
    "MethodSignature": "UpdateSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(5f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\t[RPC_Server]\n\tpublic void UpdateSign(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || !CanUpdateSign(msg.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = msg.read.Int32();\n\t\tif (num \u003C 0 || num \u003E= paintableSources.Length)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (msg.read.Unread \u003E 0 \u0026\u0026 msg.read.Bit() \u0026\u0026 !msg.player.IsAdmin)\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning($\u0022{msg.player} tried to upload a sign from a file but they aren\u0027t admin, ignoring\u0022);\n\t\t\treturn;\n\t\t}\n\t\tEnsureInitialized();\n\t\tif (array == null)\n\t\t{\n\t\t\tif (textureIDs[num] != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\n\t\t\t}\n\t\t\ttextureIDs[num] = 0u;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!ImageProcessing.IsValidPNG(array, 1024, 1024))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (textureIDs[num] != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\n\t\t\t}\n\t\t\ttextureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);\n\t\t}\n\t\tLogEdit(msg.player);\n\t\tSendNetworkUpdate();\n\t\tInterface.CallHook(\u0022OnSignUpdated\u0022, this, msg.player);\n\t}\n",
    "ClassName": "CarvablePumpkin",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "OnPlayerAttack(BasePlayer getOwnerPlayer, HitInfo info)",
    "MethodSignature": "DoAttackShared(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void DoAttackShared(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerAttack\u0022, GetOwnerPlayer(), info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tGetAttackStats(info);\n\t\tif (info.HitEntity != null)\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022OnAttacked\u0022, 50))\n\t\t\t{\n\t\t\t\tinfo.HitEntity.OnAttacked(info);\n\t\t\t}\n\t\t}\n\t\tif (info.DoHitEffects \u0026\u0026 base.isServer)\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022ImpactEffect\u0022, 20))\n\t\t\t{\n\t\t\t\tEffect.server.ImpactEffect(info);\n\t\t\t}\n\t\t\tif (!base.IsDestroyed)\n\t\t\t{\n\t\t\t\tSingletonComponent\u003CNpcNoiseManager\u003E.Instance.OnMeleeHit(this, info);\n\t\t\t}\n\t\t}\n\t\tif (base.isServer \u0026\u0026 !base.IsDestroyed)\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022UpdateItemCondition\u0022, 50))\n\t\t\t{\n\t\t\t\tUpdateItemCondition(info);\n\t\t\t}\n\t\t\tStartAttackCooldown(repeatDelay);\n\t\t}\n\t}\n",
    "ClassName": "BaseMelee",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcAttack(BaseNpc baseNpc, BaseEntity AttackTarget)",
    "MethodSignature": "StartAttack()",
    "MethodSourseCode": "\n\tpublic virtual void StartAttack()\n\t{\n\t\tif ((bool)AttackTarget \u0026\u0026 AttackReady() \u0026\u0026 Interface.CallHook(\u0022OnNpcAttack\u0022, this, AttackTarget) == null \u0026\u0026 !((AttackTarget.ServerPosition - ServerPosition).magnitude \u003E AttackRange))\n\t\t{\n\t\t\tnextAttackTime = UnityEngine.Time.realtimeSinceStartup \u002B AttackRate;\n\t\t\tBaseCombatEntity combatTarget = CombatTarget;\n\t\t\tif ((bool)combatTarget)\n\t\t\t{\n\t\t\t\tcombatTarget.Hurt(AttackDamage, AttackDamageType, this);\n\t\t\t\tStamina.Use(AttackCost);\n\t\t\t\tBusyTimer.Activate(0.5f);\n\t\t\t\tSignalBroadcast(Signal.Attack);\n\t\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Attack\u0022), AttackTarget.ServerPosition);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCargoShipSpawnCrate(CargoShip cargoShip)",
    "MethodSignature": "RespawnLoot()",
    "MethodSourseCode": "\n\tpublic void RespawnLoot()\n\t{\n\t\tif (Interface.CallHook(\u0022OnCargoShipSpawnCrate\u0022, this) == null)\n\t\t{\n\t\t\tInvokeRepeating(PlayHorn, 0f, 8f);\n\t\t\tSpawnCrate(lockedCratePrefab.resourcePath);\n\t\t\tSpawnCrate(eliteCratePrefab.resourcePath);\n\t\t\tfor (int i = 0; i \u003C 4; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tSpawnCrate(militaryCratePrefab.resourcePath);\n\t\t\t}\n\t\t\tfor (int j = 0; j \u003C 4; j\u002B\u002B)\n\t\t\t{\n\t\t\t\tSpawnCrate(junkCratePrefab.resourcePath);\n\t\t\t}\n\t\t\tlootRoundsPassed\u002B\u002B;\n\t\t\tif (lootRoundsPassed \u003E= loot_rounds)\n\t\t\t{\n\t\t\t\tCancelInvoke(RespawnLoot);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CargoShip",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDieselEngineToggle(DieselEngine dieselEngine, BasePlayer msgPlayer)",
    "MethodSignature": "EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(6f)]\n\t[RPC_Server]\n\tpublic void EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnDieselEngineToggle\u0022, this, msg.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (msg.read.Bit())\n\t\t{\n\t\t\tif (GetFuelAmount() \u003E 0)\n\t\t\t{\n\t\t\t\tEngineOn();\n\t\t\t\tstartedByPlayer = msg.player;\n\t\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 msg.player != null)\n\t\t\t\t{\n\t\t\t\t\tmsg.player.stats.Add(\u0022excavator_activated\u0022, 1, Stats.All);\n\t\t\t\t\tmsg.player.stats.Save(forceSteamSave: true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEngineOff();\n\t\t}\n\t}\n",
    "ClassName": "DieselEngine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnExcavatorGather(ExcavatorArm excavatorArm, Item item)",
    "MethodSignature": "ProduceResources()",
    "MethodSourseCode": "\n\tpublic void ProduceResources()\n\t{\n\t\tfloat num = resourceProductionTickRate / timeForFullResources;\n\t\tfloat num2 = resourcesToMine[resourceMiningIndex].amount * num;\n\t\tpendingResources[resourceMiningIndex].amount \u002B= num2;\n\t\tItemAmount[] array = pendingResources;\n\t\tforeach (ItemAmount itemAmount in array)\n\t\t{\n\t\t\tif (!(itemAmount.amount \u003E= (float)outputPiles.Count))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint num3 = Mathf.FloorToInt(itemAmount.amount / (float)outputPiles.Count);\n\t\t\titemAmount.amount -= num3 * 2;\n\t\t\tforeach (ExcavatorOutputPile outputPile in outputPiles)\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(resourcesToMine[resourceMiningIndex].itemDef, num3, 0uL);\n\t\t\t\tif (Interface.CallHook(\u0022OnExcavatorGather\u0022, this, item) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnExcavatorProduceItem(item, this);\n\t\t\t\tif (!item.MoveToContainer(outputPile.inventory))\n\t\t\t\t{\n\t\t\t\t\titem.Drop(outputPile.GetDropPosition(), outputPile.GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ExcavatorArm",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnResearchCostDetermine(Item item)",
    "MethodSignature": "ScrapForResearch(Item item)",
    "MethodSourseCode": "\n\tpublic static int ScrapForResearch(Item item)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnResearchCostDetermine\u0022, item);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\treturn ScrapForResearch(item.info);\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerVoice(BasePlayer basePlayer, byte[] data)",
    "MethodSignature": "OnReceivedVoice(byte[] data)",
    "MethodSourseCode": "\n\tpublic void OnReceivedVoice(byte[] data)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerVoice\u0022, this, data) == null)\n\t\t{\n\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\tnetWrite.PacketID(Message.Type.VoiceData);\n\t\t\tnetWrite.EntityID(net.ID);\n\t\t\tnetWrite.BytesWithSize(data);\n\t\t\tfloat num = 0f;\n\t\t\tif (HasPlayerFlag(PlayerFlags.VoiceRangeBoost))\n\t\t\t{\n\t\t\t\tnum = Voice.voiceRangeBoostAmount;\n\t\t\t}\n\t\t\tnetWrite.Send(new SendInfo(BaseNetworkable.GetConnectionsWithin(base.transform.position, 100f \u002B num, addSecondaryConnections: true))\n\t\t\t{\n\t\t\t\tpriority = Priority.Immediate\n\t\t\t});\n\t\t\tif (activeTelephone != null)\n\t\t\t{\n\t\t\t\tactiveTelephone.OnReceivedVoiceFromUser(data);\n\t\t\t}\n\t\t\tif (SingletonComponent\u003CNpcNoiseManager\u003E.Instance != null)\n\t\t\t{\n\t\t\t\tSingletonComponent\u003CNpcNoiseManager\u003E.Instance.OnVoiceChat(this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSaveLoad(System.Collections.Generic.Dictionary\u003CBaseEntity, ProtoBuf.Entity\u003E dictionary)",
    "MethodSignature": "Load(string strFilename, bool allowOutOfDateSaves)",
    "MethodSourseCode": "\n\tpublic static bool Load(string strFilename = \u0022\u0022, bool allowOutOfDateSaves = false)\n\t{\n\t\tSaveCreatedTime = DateTime.UtcNow;\n\t\ttry\n\t\t{\n\t\t\tif (strFilename == \u0022\u0022)\n\t\t\t{\n\t\t\t\tstrFilename = World.SaveFolderName \u002B \u0022/\u0022 \u002B World.SaveFileName;\n\t\t\t}\n\t\t\tif (!File.Exists(strFilename))\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnNewSave\u0022, strFilename);\n\t\t\t\tif (!File.Exists(\u0022TestSaves/\u0022 \u002B strFilename))\n\t\t\t\t{\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\u0022Couldn\u0027t load \u0022 \u002B strFilename \u002B \u0022 - file doesn\u0027t exist\u0022);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tstrFilename = \u0022TestSaves/\u0022 \u002B strFilename;\n\t\t\t}\n\t\t\tList\u003CBaseEntity\u003E list = FindMapEntities();\n\t\t\tDictionary\u003CBaseEntity, ProtoBuf.Entity\u003E dictionary = new Dictionary\u003CBaseEntity, ProtoBuf.Entity\u003E();\n\t\t\tusing (FileStream fileStream = File.OpenRead(strFilename))\n\t\t\t{\n\t\t\t\tusing BinaryReader binaryReader = new BinaryReader(fileStream);\n\t\t\t\tSaveCreatedTime = File.GetCreationTime(strFilename);\n\t\t\t\tif (binaryReader.ReadSByte() != 83 || binaryReader.ReadSByte() != 65 || binaryReader.ReadSByte() != 86 || binaryReader.ReadSByte() != 82)\n\t\t\t\t{\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\u0022Invalid save (missing header)\u0022);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (binaryReader.PeekChar() == 74)\n\t\t\t\t{\n\t\t\t\t\tbinaryReader.ReadChar();\n\t\t\t\t\tWipeId = JsonConvert.DeserializeObject\u003CSaveExtraData\u003E(binaryReader.ReadString()).WipeId;\n\t\t\t\t}\n\t\t\t\tif (binaryReader.PeekChar() == 68)\n\t\t\t\t{\n\t\t\t\t\tbinaryReader.ReadChar();\n\t\t\t\t\tSaveCreatedTime = Epoch.ToDateTime(binaryReader.ReadInt32());\n\t\t\t\t}\n\t\t\t\tif (binaryReader.ReadUInt32() != 270)\n\t\t\t\t{\n\t\t\t\t\tif (allowOutOfDateSaves)\n\t\t\t\t\t{\n\t\t\t\t\t\tUnityEngine.Debug.LogWarning(\u0022This save is from an older (possibly incompatible) version!\u0022);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tUnityEngine.Debug.LogWarning(\u0022This save is from an older version. It might not load properly.\u0022);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tClearMapEntities(list);\n\t\t\t\tAssert.IsTrue(BaseEntity.saveList.Count == 0, \u0022BaseEntity.saveList isn\u0027t empty!\u0022);\n\t\t\t\tNetwork.Net.sv.Reset();\n\t\t\t\tRust.Application.isLoadingSave = true;\n\t\t\t\tHashSet\u003CNetworkableId\u003E hashSet = new HashSet\u003CNetworkableId\u003E();\n\t\t\t\twhile (fileStream.Position \u003C fileStream.Length)\n\t\t\t\t{\n\t\t\t\t\tRCon.Update();\n\t\t\t\t\tuint num = binaryReader.ReadUInt32();\n\t\t\t\t\tlong position = fileStream.Position;\n\t\t\t\t\tProtoBuf.Entity entData = Facepunch.Pool.Get\u003CProtoBuf.Entity\u003E();\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tentData.ReadFromStream(fileStream, (int)num);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception exception)\n\t\t\t\t\t{\n\t\t\t\t\t\tUnityEngine.Debug.LogWarning(\u0022Skipping entity since it could not be deserialized - stream position: \u0022 \u002B position \u002B \u0022 size: \u0022 \u002B num);\n\t\t\t\t\t\tUnityEngine.Debug.LogException(exception);\n\t\t\t\t\t\tfileStream.Position = position \u002B num;\n\t\t\t\t\t\tFacepunch.Pool.Free(ref entData);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (entData.basePlayer != null \u0026\u0026 dictionary.Any((KeyValuePair\u003CBaseEntity, ProtoBuf.Entity\u003E x) =\u003E x.Value.basePlayer != null \u0026\u0026 x.Value.basePlayer.userid == entData.basePlayer.userid))\n\t\t\t\t\t{\n\t\t\t\t\t\tstring[] obj = new string[5] { \u0022Skipping entity \u0022, null, null, null, null };\n\t\t\t\t\t\tNetworkableId uid = entData.baseNetworkable.uid;\n\t\t\t\t\t\tobj[1] = uid.ToString();\n\t\t\t\t\t\tobj[2] = \u0022 - it\u0027s a player \u0022;\n\t\t\t\t\t\tobj[3] = entData.basePlayer.userid.ToString();\n\t\t\t\t\t\tobj[4] = \u0022 who is in the save multiple times\u0022;\n\t\t\t\t\t\tUnityEngine.Debug.LogWarning(string.Concat(obj));\n\t\t\t\t\t\tFacepunch.Pool.Free(ref entData);\n\t\t\t\t\t}\n\t\t\t\t\telse if (entData.baseNetworkable.uid.IsValid \u0026\u0026 hashSet.Contains(entData.baseNetworkable.uid))\n\t\t\t\t\t{\n\t\t\t\t\t\tstring[] obj2 = new string[5] { \u0022Skipping entity \u0022, null, null, null, null };\n\t\t\t\t\t\tNetworkableId uid = entData.baseNetworkable.uid;\n\t\t\t\t\t\tobj2[1] = uid.ToString();\n\t\t\t\t\t\tobj2[2] = \u0022 \u0022;\n\t\t\t\t\t\tobj2[3] = StringPool.Get(entData.baseNetworkable.prefabID);\n\t\t\t\t\t\tobj2[4] = \u0022 - uid is used multiple times\u0022;\n\t\t\t\t\t\tUnityEngine.Debug.LogWarning(string.Concat(obj2));\n\t\t\t\t\t\tFacepunch.Pool.Free(ref entData);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (entData.baseNetworkable.uid.IsValid)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thashSet.Add(entData.baseNetworkable.uid);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(StringPool.Get(entData.baseNetworkable.prefabID), entData.baseEntity.pos, Quaternion.Euler(entData.baseEntity.rot));\n\t\t\t\t\t\tif ((bool)baseEntity)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbaseEntity.InitLoad(entData.baseNetworkable.uid);\n\t\t\t\t\t\t\tbaseEntity.PreServerLoad();\n\t\t\t\t\t\t\tdictionary.Add(baseEntity, entData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022Spawning \u0022 \u002B list.Count \u002B \u0022 entities from map\u0022);\n\t\t\tforeach (BaseEntity item in list)\n\t\t\t{\n\t\t\t\tif (!(item == null))\n\t\t\t\t{\n\t\t\t\t\titem.SpawnAsMapEntity();\n\t\t\t\t}\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022\\tdone.\u0022);\n\t\t\tDebugEx.Log(\u0022Spawning \u0022 \u002B dictionary.Count \u002B \u0022 entities from save\u0022);\n\t\t\tobject obj3 = Interface.CallHook(\u0022OnSaveLoad\u0022, dictionary);\n\t\t\tif (obj3 is bool)\n\t\t\t{\n\t\t\t\treturn (bool)obj3;\n\t\t\t}\n\t\t\tBaseNetworkable.LoadInfo info = default(BaseNetworkable.LoadInfo);\n\t\t\tinfo.fromDisk = true;\n\t\t\tStopwatch stopwatch = Stopwatch.StartNew();\n\t\t\tint num2 = 0;\n\t\t\tforeach (KeyValuePair\u003CBaseEntity, ProtoBuf.Entity\u003E item2 in dictionary)\n\t\t\t{\n\t\t\t\tBaseEntity key = item2.Key;\n\t\t\t\tif (key == null)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tRCon.Update();\n\t\t\t\tinfo.msg = item2.Value;\n\t\t\t\tkey.Spawn();\n\t\t\t\tkey.Load(info);\n\t\t\t\tif (key.IsValid())\n\t\t\t\t{\n\t\t\t\t\tnum2\u002B\u002B;\n\t\t\t\t\tif (stopwatch.Elapsed.TotalMilliseconds \u003E 2000.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstopwatch.Reset();\n\t\t\t\t\t\tstopwatch.Start();\n\t\t\t\t\t\tDebugEx.Log(\u0022\\t\u0022 \u002B num2 \u002B \u0022 / \u0022 \u002B dictionary.Count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022\\tdone.\u0022);\n\t\t\tDebugEx.Log(\u0022Postprocessing \u0022 \u002B list.Count \u002B \u0022 entities from map\u0022);\n\t\t\tforeach (BaseEntity item3 in list)\n\t\t\t{\n\t\t\t\tif (!(item3 == null))\n\t\t\t\t{\n\t\t\t\t\titem3.PostMapEntitySpawn();\n\t\t\t\t}\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022\\tdone.\u0022);\n\t\t\tDebugEx.Log(\u0022Postprocessing \u0022 \u002B list.Count \u002B \u0022 entities from save\u0022);\n\t\t\tforeach (KeyValuePair\u003CBaseEntity, ProtoBuf.Entity\u003E item4 in dictionary)\n\t\t\t{\n\t\t\t\tBaseEntity key2 = item4.Key;\n\t\t\t\tif (!(key2 == null))\n\t\t\t\t{\n\t\t\t\t\tRCon.Update();\n\t\t\t\t\tif (key2.IsValid())\n\t\t\t\t\t{\n\t\t\t\t\t\tkey2.UpdateNetworkGroup();\n\t\t\t\t\t\tkey2.PostServerLoad();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022\\tdone.\u0022);\n\t\t\tforeach (KeyValuePair\u003CBaseEntity, ProtoBuf.Entity\u003E item5 in dictionary)\n\t\t\t{\n\t\t\t\tProtoBuf.Entity obj4 = item5.Value;\n\t\t\t\tFacepunch.Pool.Free(ref obj4);\n\t\t\t}\n\t\t\tdictionary.Clear();\n\t\t\tif ((bool)SingletonComponent\u003CSpawnHandler\u003E.Instance)\n\t\t\t{\n\t\t\t\tDebugEx.Log(\u0022Enforcing SpawnPopulation Limits\u0022);\n\t\t\t\tSingletonComponent\u003CSpawnHandler\u003E.Instance.EnforceLimits();\n\t\t\t\tDebugEx.Log(\u0022\\tdone.\u0022);\n\t\t\t}\n\t\t\tInitializeWipeId();\n\t\t\tRust.Application.isLoadingSave = false;\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception exception2)\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning(\u0022Error loading save (\u0022 \u002B strFilename \u002B \u0022)\u0022);\n\t\t\tUnityEngine.Debug.LogException(exception2);\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "ClassName": "SaveRestore",
    "HookLineInvoke": 123
  },
  {
    "HookSignature": "OnPlayerUnvanish(BasePlayer basePlayer)",
    "MethodSignature": "invis(Arg arg)",
    "MethodSourseCode": "\n\t[ServerVar(Help = \u0022Make admin invisible\u0022)]\n\tpublic static void invis(Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool @bool = arg.GetBool(0, !invisiblePlayers.Contains(basePlayer));\n\t\tif (@bool \u0026\u0026 !invisiblePlayers.Contains(basePlayer))\n\t\t{\n\t\t\tinvisiblePlayers.Add(basePlayer);\n\t\t\tbasePlayer.limitNetworking = true;\n\t\t\tbasePlayer.isInvisible = true;\n\t\t\tbasePlayer.syncPosition = false;\n\t\t\tbasePlayer.GetHeldEntity()?.SetHeld(bHeld: false);\n\t\t\tbasePlayer.DisablePlayerCollider();\n\t\t\tSimpleAIMemory.AddIgnorePlayer(basePlayer);\n\t\t\tBaseEntity.Query.Server.RemovePlayer(basePlayer);\n\t\t\tInterface.CallHook(\u0022OnPlayerVanish\u0022, basePlayer);\n\t\t\tif (!Rust.Global.Runner.IsInvoking(TickInvis))\n\t\t\t{\n\t\t\t\tRust.Global.Runner.InvokeRepeating(TickInvis, 0f, 0f);\n\t\t\t}\n\t\t}\n\t\telse if (!@bool \u0026\u0026 invisiblePlayers.Contains(basePlayer))\n\t\t{\n\t\t\tinvisiblePlayers.Remove(basePlayer);\n\t\t\tbasePlayer.limitNetworking = false;\n\t\t\tbasePlayer.isInvisible = false;\n\t\t\tbasePlayer.syncPosition = true;\n\t\t\tbasePlayer.EnablePlayerCollider();\n\t\t\tSimpleAIMemory.RemoveIgnorePlayer(basePlayer);\n\t\t\tBaseEntity.Query.Server.RemovePlayer(basePlayer);\n\t\t\tBaseEntity.Query.Server.AddPlayer(basePlayer);\n\t\t\tInterface.CallHook(\u0022OnPlayerUnvanish\u0022, basePlayer);\n\t\t\tif (invisiblePlayers.Count == 0)\n\t\t\t{\n\t\t\t\tRust.Global.Runner.CancelInvoke(TickInvis);\n\t\t\t}\n\t\t}\n\t\targ.ReplyWith(\u0022Invis: \u0022 \u002B basePlayer.limitNetworking);\n\t\tbasePlayer.Command(\u0022debug.setinvis_ui\u0022, basePlayer.limitNetworking);\n\t}\n",
    "ClassName": "Debugging",
    "HookLineInvoke": 36
  },
  {
    "HookSignature": "OnServerInformationUpdated()",
    "MethodSignature": "UpdateServerInformation()",
    "MethodSourseCode": "\n\tprivate void UpdateServerInformation()\n\t{\n\t\tif (!SteamServer.IsValid)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022UpdateServerInformation\u0022))\n\t\t{\n\t\t\tSteamServer.ServerName = ConVar.Server.hostname;\n\t\t\tSteamServer.MaxPlayers = ConVar.Server.maxplayers;\n\t\t\tSteamServer.Passworded = false;\n\t\t\tSteamServer.MapName = World.GetServerBrowserMapName();\n\t\t\tstring value = \u0022stok\u0022;\n\t\t\tif (Restarting)\n\t\t\t{\n\t\t\t\tvalue = \u0022strst\u0022;\n\t\t\t}\n\t\t\tstring text = $\u0022born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}\u0022;\n\t\t\tstring text2 = $\u0022gm{GamemodeName()}\u0022;\n\t\t\tif (text2 != \u0022gmrust\u0022 \u0026\u0026 text2 != \u0022gmvanilla\u0022)\n\t\t\t{\n\t\t\t\tConVar.Server.tags = ConVar.Server.tags.Replace(\u0022vanilla\u0022, \u0022\u0022);\n\t\t\t}\n\t\t\tstring text3 = (ConVar.Server.pve ? \u0022,pve\u0022 : string.Empty);\n\t\t\tstring text4 = ConVar.Server.tags?.Trim(\u0027,\u0027) ?? \u0022\u0022;\n\t\t\tstring text5 = ((!string.IsNullOrWhiteSpace(text4)) ? (\u0022,\u0022 \u002B text4) : \u0022\u0022);\n\t\t\tstring text6 = BuildInfo.Current?.Scm?.ChangeId ?? \u00220\u0022;\n\t\t\tstring text7 = (ConVar.Server.premium ? \u0022,premium\u0022 : \u0022\u0022);\n\t\t\tstring text8 = PingEstimater.GetCachedClosestRegion().Code;\n\t\t\tif (!string.IsNullOrEmpty(ConVar.Server.ping_region_code_override))\n\t\t\t{\n\t\t\t\ttext8 = ConVar.Server.ping_region_code_override;\n\t\t\t}\n\t\t\tSteamServer.GameTags = ServerTagCompressor.CompressTags($\u0022mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Network.Net.sv.ProtocolId},qp{SingletonComponent\u003CServerMgr\u003E.Instance.connectionQueue.Queued},$r{text8},v{2594}{text3}{text5},{text},{text2},cs{text6}{text7},ts{RelationshipManager.maxTeamSize}\u0022);\n\t\t\tif (ConVar.Server.description != null \u0026\u0026 ConVar.Server.description.Length \u003E 100)\n\t\t\t{\n\t\t\t\tstring[] array = ConVar.Server.description.SplitToChunks(100).ToArray();\n\t\t\t\tfor (int i = 0; i \u003C 16; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tif (i \u003C array.Length)\n\t\t\t\t\t{\n\t\t\t\t\t\tSteamServer.SetKey($\u0022description_{i:00}\u0022, array[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSteamServer.SetKey($\u0022description_{i:00}\u0022, string.Empty);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSteamServer.SetKey(\u0022description_0\u0022, ConVar.Server.description);\n\t\t\t\tfor (int j = 1; j \u003C 16; j\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tSteamServer.SetKey($\u0022description_{j:00}\u0022, string.Empty);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSteamServer.SetKey(\u0022hash\u0022, AssemblyHash);\n\t\t\tSteamServer.SetKey(\u0022status\u0022, value);\n\t\t\tstring value2 = World.Seed.ToString();\n\t\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\t\tif (activeGameMode != null \u0026\u0026 !activeGameMode.ingameMap)\n\t\t\t{\n\t\t\t\tvalue2 = \u00220\u0022;\n\t\t\t}\n\t\t\tSteamServer.SetKey(\u0022world.seed\u0022, value2);\n\t\t\tSteamServer.SetKey(\u0022world.size\u0022, World.Size.ToString());\n\t\t\tSteamServer.SetKey(\u0022pve\u0022, ConVar.Server.pve.ToString());\n\t\t\tSteamServer.SetKey(\u0022headerimage\u0022, ConVar.Server.headerimage);\n\t\t\tSteamServer.SetKey(\u0022logoimage\u0022, ConVar.Server.logoimage);\n\t\t\tSteamServer.SetKey(\u0022url\u0022, ConVar.Server.url);\n\t\t\tSteamServer.SetKey(\u0022map_image_url\u0022, MapUploader.ImageUrl);\n\t\t\tif (!string.IsNullOrWhiteSpace(ConVar.Server.favoritesEndpoint))\n\t\t\t{\n\t\t\t\tSteamServer.SetKey(\u0022favendpoint\u0022, ConVar.Server.favoritesEndpoint);\n\t\t\t}\n\t\t\tSteamServer.SetKey(\u0022gmn\u0022, GamemodeName());\n\t\t\tSteamServer.SetKey(\u0022gmt\u0022, GamemodeTitle());\n\t\t\tSteamServer.SetKey(\u0022uptime\u0022, ((int)UnityEngine.Time.realtimeSinceStartup).ToString());\n\t\t\tSteamServer.SetKey(\u0022gc_mb\u0022, Performance.report.memoryAllocations.ToString());\n\t\t\tSteamServer.SetKey(\u0022gc_cl\u0022, Performance.report.memoryCollections.ToString());\n\t\t\tSteamServer.SetKey(\u0022ram_sys\u0022, (Performance.report.memoryUsageSystem / 1000000).ToString());\n\t\t\tSteamServer.SetKey(\u0022fps\u0022, Performance.report.frameRate.ToString());\n\t\t\tSteamServer.SetKey(\u0022fps_avg\u0022, Performance.report.frameRateAverage.ToString(\u00220.00\u0022));\n\t\t\tSteamServer.SetKey(\u0022ent_cnt\u0022, BaseNetworkable.serverEntities.Count.ToString());\n\t\t\tSteamServer.SetKey(\u0022build\u0022, BuildInfo.Current.Scm.ChangeId);\n\t\t}\n\t\tInterface.CallHook(\u0022OnServerInformationUpdated\u0022);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 88
  },
  {
    "HookSignature": "OnItemPainted(PaintedItemStorageEntity paintedItemStorageEntity, Item item, BasePlayer msgPlayer, byte[] array)",
    "MethodSignature": "Server_UpdateImage(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(3uL)]\n\t[RPC_Server]\n\tprivate void Server_UpdateImage(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || (ulong)msg.player.userID != base.OwnerID)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (Item item2 in msg.player.inventory.containerWear.itemList)\n\t\t{\n\t\t\tif (item2.instanceData != null \u0026\u0026 item2.instanceData.subEntity == net.ID)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tItem item = msg.player.inventory.FindBySubEntityID(net.ID);\n\t\tif (item == null || item.isBroken)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (array == null)\n\t\t{\n\t\t\tif (_currentImageCrc != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(_currentImageCrc, FileStorage.Type.png, net.ID, 0u);\n\t\t\t}\n\t\t\t_currentImageCrc = 0u;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!ImageProcessing.IsValidPNG(array, 512, 512))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tuint currentImageCrc = _currentImageCrc;\n\t\t\tif (_currentImageCrc != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(_currentImageCrc, FileStorage.Type.png, net.ID, 0u);\n\t\t\t}\n\t\t\t_currentImageCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);\n\t\t\tif (_currentImageCrc != currentImageCrc)\n\t\t\t{\n\t\t\t\titem.LoseCondition(0.25f);\n\t\t\t}\n\t\t\tlastEditedBy = msg.player.userID;\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemPainted\u0022, this, item, msg.player, array);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "PaintedItemStorageEntity",
    "HookLineInvoke": 48
  },
  {
    "HookSignature": "OnAIBrainStateSwitch(BaseAIBrain baseAIBrain, BaseAIBrain.BasicAIState CurrentState, BaseAIBrain.BasicAIState newState)",
    "MethodSignature": "SwitchToState(BasicAIState newState, int stateContainerID)",
    "MethodSourseCode": "\n\tprivate bool SwitchToState(BasicAIState newState, int stateContainerID = -1)\n\t{\n\t\tif (newState == null || !newState.CanEnter())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (CurrentState != null)\n\t\t{\n\t\t\tif (!CurrentState.CanLeave())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (CurrentState == newState \u0026\u0026 !UseAIDesign)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tobject obj = Interface.CallHook(\u0022OnAIBrainStateSwitch\u0022, this, CurrentState, newState);\n\t\t\tif (obj != null)\n\t\t\t{\n\t\t\t\tif (!(obj is bool))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\tCurrentState.StateLeave(this, GetBaseEntity());\n\t\t}\n\t\tAddEvents(stateContainerID);\n\t\tCurrentState = newState;\n\t\tCurrentState.StateEnter(this, GetBaseEntity());\n\t\tcurrentStateContainerID = stateContainerID;\n\t\tInterface.CallHook(\u0022OnAIBrainStateSwitched\u0022, this, CurrentState);\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseAIBrain",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnTurretAssigned(AutoTurret autoTurret, ulong num, BasePlayer msgPlayer)",
    "MethodSignature": "AssignToFriend(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void AssignToFriend(RPCMessage msg)\n\t{\n\t\tif (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tulong num = msg.read.UInt64();\n\t\tif (num != 0L \u0026\u0026 !IsAuthed(num) \u0026\u0026 Interface.CallHook(\u0022OnTurretAssign\u0022, this, num, msg.player) == null)\n\t\t{\n\t\t\tstring username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);\n\t\t\tPlayerNameID playerNameID = new PlayerNameID();\n\t\t\tplayerNameID.userid = num;\n\t\t\tplayerNameID.username = username;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022added\u0022, num);\n\t\t\tauthorizedPlayers.Add(playerNameID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnTurretAssigned\u0022, this, num, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer msgPlayer, BuildingGrade.Enum constructionGradeGradeBaseType, ulong constructionGradeGradeBaseSkin)",
    "MethodSignature": "DoUpgradeToGrade(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void DoUpgradeToGrade(RPCMessage msg)\n\t{\n\t\tif (!msg.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tConstructionGrade constructionGrade = blockDefinition.GetGrade((BuildingGrade.Enum)msg.read.Int32(), msg.read.UInt64());\n\t\tif (constructionGrade == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!CanChangeToGrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))\n\t\t{\n\t\t\tif (!(DeployVolume.LastDeployHit != null))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBaseEntity baseEntity = GameObjectEx.ToBaseEntity(DeployVolume.LastDeployHit);\n\t\t\tif (baseEntity != null \u0026\u0026 baseEntity is BasePlayer basePlayer)\n\t\t\t{\n\t\t\t\tulong currentTeam = msg.player.currentTeam;\n\t\t\t\tif (currentTeam != 0L \u0026\u0026 currentTeam == basePlayer.currentTeam)\n\t\t\t\t{\n\t\t\t\t\tstring playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, false, playerNameStreamSafe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnStructureUpgrade\u0022, this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin) != null || !CanAffordUpgrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (base.SecondsSinceAttacked \u003C 30f)\n\t\t\t{\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString(\u0022N0\u0022));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!constructionGrade.gradeBase.alwaysUnlock \u0026\u0026 constructionGrade.gradeBase.skin != 0L \u0026\u0026 !msg.player.blueprints.steamInventory.HasItem((int)constructionGrade.gradeBase.skin))\n\t\t\t{\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.SkinNotOwned, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tPayForUpgrade(constructionGrade, msg.player);\n\t\t\tif (msg.player != null)\n\t\t\t{\n\t\t\t\tplayerCustomColourToApply = GetShippingContainerBlockColourForPlayer(msg.player);\n\t\t\t}\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022DoUpgradeEffect\u0022), (int)constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);\n\t\t\tBuildingGrade.Enum @enum = grade;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, constructionGrade.gradeBase.type, playerCustomColourToApply, constructionGrade.gradeBase.skin);\n\t\t\tOnSkinChanged(skinID, constructionGrade.gradeBase.skin);\n\t\t\tChangeGrade(constructionGrade.gradeBase.type, playEffect: true);\n\t\t\tif (msg.player != null \u0026\u0026 @enum != constructionGrade.gradeBase.type)\n\t\t\t{\n\t\t\t\tmsg.player.ProcessMissionEvent(BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE, new BaseMission.MissionEventPayload\n\t\t\t\t{\n\t\t\t\t\tNetworkIdentifier = net.ID,\n\t\t\t\t\tIntIdentifier = (int)constructionGrade.gradeBase.type\n\t\t\t\t}, 1f);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnStructureUpgraded\u0022, this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);\n\t\t\ttimePlaced = GetNetworkTime();\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "CanBeTargeted(BaseCombatEntity obj, AutoTurret autoTurret)",
    "MethodSignature": "ObjectVisible(BaseCombatEntity obj)",
    "MethodSourseCode": "\n\tpublic bool ObjectVisible(BaseCombatEntity obj)\n\t{\n\t\tobject obj2 = Interface.CallHook(\u0022CanBeTargeted\u0022, obj, this);\n\t\tif (obj2 is bool)\n\t\t{\n\t\t\treturn (bool)obj2;\n\t\t}\n\t\tVector3 position = eyePos.transform.position;\n\t\tif (GamePhysics.CheckSphere(position, 0.1f, 2097152))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tVector3 vector = AimOffset(obj);\n\t\tfloat num = Vector3.Distance(vector, position);\n\t\tVector3 vector2 = Vector3.Cross((vector - position).normalized, Vector3.up);\n\t\tif (num \u003E sightRange)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tList\u003CRaycastHit\u003E obj3 = Facepunch.Pool.Get\u003CList\u003CRaycastHit\u003E\u003E();\n\t\tfor (int i = 0; (float)i \u003C (CheckPeekers() ? 3f : 1f); i\u002B\u002B)\n\t\t{\n\t\t\tVector3 normalized = (vector \u002B vector2 * visibilityOffsets[i] - position).normalized;\n\t\t\tobj3.Clear();\n\t\t\tGamePhysics.TraceAll(new Ray(position, normalized), 0f, obj3, num * 1.1f, 1218652417);\n\t\t\tfor (int j = 0; j \u003C obj3.Count; j\u002B\u002B)\n\t\t\t{\n\t\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(obj3[j]);\n\t\t\t\tif ((!(entity != null) || !entity.isClient) \u0026\u0026 (!(entity != null) || !(entity.ToPlayer() != null) || entity.EqualNetID(obj)) \u0026\u0026 (!(entity != null) || !entity.EqualNetID(this)))\n\t\t\t\t{\n\t\t\t\t\tif (entity != null \u0026\u0026 (entity == obj || entity.EqualNetID(obj)))\n\t\t\t\t\t{\n\t\t\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj3);\n\t\t\t\t\t\tpeekIndex = i;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj3);\n\t\treturn false;\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanDropActiveItem(BasePlayer basePlayer)",
    "MethodSignature": "ShouldDropActiveItem()",
    "MethodSourseCode": "\n\tpublic virtual bool ShouldDropActiveItem()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanDropActiveItem\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanRecycle(Recycler recycler, Item slot)",
    "MethodSignature": "HasRecyclable()",
    "MethodSourseCode": "\n\tpublic bool HasRecyclable()\n\t{\n\t\tfor (int i = 0; i \u003C 6; i\u002B\u002B)\n\t\t{\n\t\t\tItem slot = base.inventory.GetSlot(i);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tobject obj = Interface.CallHook(\u0022CanRecycle\u0022, this, slot);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tif (slot.info.Blueprint != null)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnEntityDeath(BaseCombatEntity baseCombatEntity, HitInfo info)",
    "MethodSignature": "Die(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void Die(HitInfo info = null)\n\t{\n\t\tif (IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tLogEntry(RustLog.EntryType.Combat, 2, \u0022died\u0022);\n\t\thealth = 0f;\n\t\tlifestate = LifeState.Dead;\n\t\tInterface.CallHook(\u0022OnEntityDeath\u0022, this, info);\n\t\tif (info != null \u0026\u0026 (bool)info.InitiatorPlayer)\n\t\t{\n\t\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\n\t\t\tif (initiatorPlayer != null \u0026\u0026 initiatorPlayer.GetActiveMission() != -1 \u0026\u0026 !initiatorPlayer.IsNpc)\n\t\t\t{\n\t\t\t\tinitiatorPlayer.ProcessMissionEvent(BaseMission.MissionEventType.KILL_ENTITY, prefabID, 1f);\n\t\t\t}\n\t\t}\n\t\tusing (TimeWarning.New(\u0022OnDied\u0022))\n\t\t{\n\t\t\tTryDropCorpse(info);\n\t\t\tOnDied(info);\n\t\t}\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnStructureRotate(BuildingBlock buildingBlock, BasePlayer msgPlayer)",
    "MethodSignature": "DoRotation(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tpublic void DoRotation(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanRotate(msg.player) \u0026\u0026 blockDefinition.canRotateAfterPlacement \u0026\u0026 Interface.CallHook(\u0022OnStructureRotate\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbase.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);\n\t\t\tRefreshEntityLinks();\n\t\t\tUpdateSurroundingEntities();\n\t\t\tUpdateSkin(force: true);\n\t\t\tRefreshNeighbours(linkToNeighbours: false);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022RefreshSkin\u0022));\n\t\t\tif (!globalNetworkCooldown)\n\t\t\t{\n\t\t\t\tglobalNetworkCooldown = true;\n\t\t\t\tGlobalNetworkHandler.server.TrySendNetworkUpdate(this);\n\t\t\t\tCancelInvoke(ResetGlobalNetworkCooldown);\n\t\t\t\tInvoke(ResetGlobalNetworkCooldown, 15f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnCoalingTowerGather(CoalingTower coalingTower, Item item)",
    "MethodSignature": "EmptyTenPercent()",
    "MethodSourseCode": "\n\tprivate void EmptyTenPercent()\n\t{\n\t\tif (!IsPowered())\n\t\t{\n\t\t\tEndEmptyProcess(ActionAttemptStatus.GenericError);\n\t\t\treturn;\n\t\t}\n\t\tif (!HasUnloadableLinedUp)\n\t\t{\n\t\t\tEndEmptyProcess(ActionAttemptStatus.NoTrainCar);\n\t\t\treturn;\n\t\t}\n\t\tTrainCarUnloadable activeUnloadable = GetActiveUnloadable();\n\t\tif (tcUnloadingNow == null || activeUnloadable != tcUnloadingNow)\n\t\t{\n\t\t\tEndEmptyProcess(ActionAttemptStatus.NoTrainCar);\n\t\t\treturn;\n\t\t}\n\t\tStorageContainer storageContainer = tcUnloadingNow.GetStorageContainer();\n\t\tif (storageContainer.inventory == null || !TrainWagonLootData.instance.TryGetLootFromIndex(LootTypeIndex, out var lootOption))\n\t\t{\n\t\t\tEndEmptyProcess(ActionAttemptStatus.NoTrainCar);\n\t\t\treturn;\n\t\t}\n\t\tbool flag = tcUnloadingNow.wagonType != TrainCarUnloadable.WagonType.Fuel;\n\t\tItemContainer itemContainer = null;\n\t\tPercentFullStorageContainer percentFullStorageContainer = (flag ? GetOreStorage() : GetFuelStorage());\n\t\tif (percentFullStorageContainer != null)\n\t\t{\n\t\t\titemContainer = percentFullStorageContainer.inventory;\n\t\t}\n\t\tif (itemContainer == null)\n\t\t{\n\t\t\tEndEmptyProcess(ActionAttemptStatus.GenericError);\n\t\t\treturn;\n\t\t}\n\t\tItemContainer inventory = storageContainer.inventory;\n\t\tItemContainer newcontainer = itemContainer;\n\t\tint iAmount = Mathf.RoundToInt((float)lootOption.maxLootAmount / 10f);\n\t\tList\u003CItem\u003E obj = Facepunch.Pool.Get\u003CList\u003CItem\u003E\u003E();\n\t\tint num = inventory.Take(obj, lootOption.lootItem.itemid, iAmount);\n\t\tbool flag2 = true;\n\t\tif (num \u003E 0)\n\t\t{\n\t\t\tforeach (Item item in obj)\n\t\t\t{\n\t\t\t\tif (tcUnloadingNow.wagonType == TrainCarUnloadable.WagonType.Lootboxes)\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Interface.CallHook(\u0022OnCoalingTowerGather\u0022, this, item) != null)\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool flag3 = item.MoveToContainer(newcontainer);\n\t\t\t\tif (!flag2 || flag3)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\titem.MoveToContainer(inventory);\n\t\t\t\tflag2 = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.Free(ref obj, freeElements: false);\n\t\tfloat orePercent = tcUnloadingNow.GetOrePercent();\n\t\tif (orePercent == 0f)\n\t\t{\n\t\t\tEndEmptyProcess(ActionAttemptStatus.NoError);\n\t\t}\n\t\telse if (!flag2)\n\t\t{\n\t\t\tEndEmptyProcess(ActionAttemptStatus.OutputIsFull);\n\t\t}\n\t\telse if (flag)\n\t\t{\n\t\t\ttcUnloadingNow.SetVisualOreLevel(orePercent);\n\t\t}\n\t}\n",
    "ClassName": "CoalingTower",
    "HookLineInvoke": 52
  },
  {
    "HookSignature": "OnExplosiveDropped(BasePlayer msgPlayer, BaseEntity baseEntity, ThrownWeapon thrownWeapon)",
    "MethodSignature": "DoDrop(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server]\n\tprivate void DoDrop(RPCMessage msg)\n\t{\n\t\tif (!HasItemAmount() || HasAttackCooldown() || (!canThrowUnderwater \u0026\u0026 msg.player.IsHeadUnderwater()))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 vector = msg.read.Vector3();\n\t\tVector3 normalized = msg.read.Vector3().normalized;\n\t\tif (msg.player.isMounted || msg.player.HasParent())\n\t\t{\n\t\t\tvector = msg.player.eyes.position;\n\t\t}\n\t\telse if (!ValidateEyePos(msg.player, vector))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation(Vector3.up));\n\t\tif (baseEntity == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (canStick \u0026\u0026 UnityEngine.Physics.SphereCast(new Ray(vector, normalized), 0.05f, out var hitInfo, 1.5f, 1237003025))\n\t\t{\n\t\t\tVector3 point = hitInfo.point;\n\t\t\tVector3 normal = hitInfo.normal;\n\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(hitInfo);\n\t\t\tCollider collider = hitInfo.collider;\n\t\t\tif ((bool)entity \u0026\u0026 entity is StabilityEntity \u0026\u0026 baseEntity is TimedExplosive)\n\t\t\t{\n\t\t\t\tentity = entity.ToServer\u003CBaseEntity\u003E();\n\t\t\t\tTimedExplosive timedExplosive = baseEntity as TimedExplosive;\n\t\t\t\ttimedExplosive.onlyDamageParent = true;\n\t\t\t\ttimedExplosive.DoStick(point, normal, entity, collider);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnExplosiveLaunched(msg.player, timedExplosive);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbaseEntity.SetVelocity(normalized);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbaseEntity.SetVelocity(normalized);\n\t\t}\n\t\tbaseEntity.creatorEntity = msg.player;\n\t\tbaseEntity.skinID = skinID;\n\t\tbaseEntity.Spawn();\n\t\tSetUpThrownWeapon(baseEntity);\n\t\tStartAttackCooldown(repeatDelay);\n\t\tInterface.CallHook(\u0022OnExplosiveDropped\u0022, msg.player, baseEntity, this);\n\t\tUseItemAmount(1);\n\t}\n",
    "ClassName": "ThrownWeapon",
    "HookLineInvoke": 52
  },
  {
    "HookSignature": "OnFuelItemCheck(EntityFuelSystem entityFuelSystem, StorageContainer fuelContainer)",
    "MethodSignature": "GetFuelItem()",
    "MethodSourseCode": "\n\tpublic Item GetFuelItem()\n\t{\n\t\tStorageContainer fuelContainer = GetFuelContainer();\n\t\tobject obj = Interface.CallHook(\u0022OnFuelItemCheck\u0022, this, fuelContainer);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\tif (fuelContainer == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn fuelContainer.inventory.GetSlot(0);\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnCodeEntered(CodeLock codeLock, BasePlayer rpcPlayer, string text)",
    "MethodSignature": "UnlockWithCode(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f, CheckParent = true)]\n\tprivate void UnlockWithCode(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract() || !IsLocked() || IsCodeEntryBlocked())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = rpc.read.String();\n\t\tif (Interface.CallHook(\u0022OnCodeEntered\u0022, this, rpc.player, text) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = text == guestCode;\n\t\tbool flag2 = text == code;\n\t\tif (!(text == code) \u0026\u0026 (!hasGuestCode || !(text == guestCode)))\n\t\t{\n\t\t\tif (UnityEngine.Time.realtimeSinceStartup \u003E lastWrongTime \u002B 60f)\n\t\t\t{\n\t\t\t\twrongCodes = 0;\n\t\t\t}\n\t\t\tDoEffect(effectDenied.resourcePath);\n\t\t\tDoEffect(effectShock.resourcePath);\n\t\t\trpc.player.Hurt((float)(wrongCodes \u002B 1) * 5f, DamageType.ElectricShock, this, useProtection: false);\n\t\t\twrongCodes\u002B\u002B;\n\t\t\tif (wrongCodes \u003E 5)\n\t\t\t{\n\t\t\t\trpc.player.ShowToast(GameTip.Styles.Red_Normal, blockwarning, false);\n\t\t\t}\n\t\t\tif ((float)wrongCodes \u003E= maxFailedAttempts)\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved11, b: true);\n\t\t\t\tInvoke(ClearCodeEntryBlocked, lockoutCooldown);\n\t\t\t}\n\t\t\tlastWrongTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\treturn;\n\t\t}\n\t\tSendNetworkUpdate();\n\t\tif (flag2)\n\t\t{\n\t\t\tif (!whitelistPlayers.Contains(rpc.player.userID))\n\t\t\t{\n\t\t\t\tDoEffect(effectCodeChanged.resourcePath);\n\t\t\t\twhitelistPlayers.Add(rpc.player.userID);\n\t\t\t\twrongCodes = 0;\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: false);\n\t\t}\n\t\telse if (flag \u0026\u0026 !guestPlayers.Contains(rpc.player.userID))\n\t\t{\n\t\t\tDoEffect(effectCodeChanged.resourcePath);\n\t\t\tguestPlayers.Add(rpc.player.userID);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: true);\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnPlayerVanish(BasePlayer basePlayer)",
    "MethodSignature": "invis(Arg arg)",
    "MethodSourseCode": "\n\t[ServerVar(Help = \u0022Make admin invisible\u0022)]\n\tpublic static void invis(Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool @bool = arg.GetBool(0, !invisiblePlayers.Contains(basePlayer));\n\t\tif (@bool \u0026\u0026 !invisiblePlayers.Contains(basePlayer))\n\t\t{\n\t\t\tinvisiblePlayers.Add(basePlayer);\n\t\t\tbasePlayer.limitNetworking = true;\n\t\t\tbasePlayer.isInvisible = true;\n\t\t\tbasePlayer.syncPosition = false;\n\t\t\tbasePlayer.GetHeldEntity()?.SetHeld(bHeld: false);\n\t\t\tbasePlayer.DisablePlayerCollider();\n\t\t\tSimpleAIMemory.AddIgnorePlayer(basePlayer);\n\t\t\tBaseEntity.Query.Server.RemovePlayer(basePlayer);\n\t\t\tInterface.CallHook(\u0022OnPlayerVanish\u0022, basePlayer);\n\t\t\tif (!Rust.Global.Runner.IsInvoking(TickInvis))\n\t\t\t{\n\t\t\t\tRust.Global.Runner.InvokeRepeating(TickInvis, 0f, 0f);\n\t\t\t}\n\t\t}\n\t\telse if (!@bool \u0026\u0026 invisiblePlayers.Contains(basePlayer))\n\t\t{\n\t\t\tinvisiblePlayers.Remove(basePlayer);\n\t\t\tbasePlayer.limitNetworking = false;\n\t\t\tbasePlayer.isInvisible = false;\n\t\t\tbasePlayer.syncPosition = true;\n\t\t\tbasePlayer.EnablePlayerCollider();\n\t\t\tSimpleAIMemory.RemoveIgnorePlayer(basePlayer);\n\t\t\tBaseEntity.Query.Server.RemovePlayer(basePlayer);\n\t\t\tBaseEntity.Query.Server.AddPlayer(basePlayer);\n\t\t\tInterface.CallHook(\u0022OnPlayerUnvanish\u0022, basePlayer);\n\t\t\tif (invisiblePlayers.Count == 0)\n\t\t\t{\n\t\t\t\tRust.Global.Runner.CancelInvoke(TickInvis);\n\t\t\t}\n\t\t}\n\t\targ.ReplyWith(\u0022Invis: \u0022 \u002B basePlayer.limitNetworking);\n\t\tbasePlayer.Command(\u0022debug.setinvis_ui\u0022, basePlayer.limitNetworking);\n\t}\n",
    "ClassName": "Debugging",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnInventoryItemsFind(PlayerInventory playerInventory, int id, System.Collections.Generic.List\u003CItem\u003E list)",
    "MethodSignature": "FindItemsByItemID(List\u003CItem\u003E list, int id)",
    "MethodSourseCode": "\n\tpublic void FindItemsByItemID(List\u003CItem\u003E list, int id)\n\t{\n\t\tif (Interface.CallHook(\u0022OnInventoryItemsFind\u0022, this, id, list) == null)\n\t\t{\n\t\t\tif (containerMain != null)\n\t\t\t{\n\t\t\t\tcontainerMain.FindItemsByItemID(list, id);\n\t\t\t}\n\t\t\tif (containerBelt != null)\n\t\t\t{\n\t\t\t\tcontainerBelt.FindItemsByItemID(list, id);\n\t\t\t}\n\t\t\tif (containerWear != null)\n\t\t\t{\n\t\t\t\tcontainerWear.FindItemsByItemID(list, id);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerReported(BasePlayer basePlayer, string text4, string targetId, string text, string text2, string text3)",
    "MethodSignature": "OnPlayerReported(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.FromOwner(false)]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\t[RPC_Server]\n\tpublic async void OnPlayerReported(RPCMessage msg)\n\t{\n\t\ttry\n\t\t{\n\t\t\tstring text = msg.read.String();\n\t\t\tstring text2 = msg.read.StringMultiLine();\n\t\t\tstring message = ((text2 != null \u0026\u0026 text2.Length \u003E 1400) ? text2.Substring(0, 1400) : text2);\n\t\t\tstring text3 = msg.read.String();\n\t\t\tstring targetId = msg.read.String();\n\t\t\tstring text4 = msg.read.String();\n\t\t\tDebugEx.Log($\u0022[PlayerReport] {this} reported {text4}[{targetId}] - \\\u0022{text}\\\u0022\u0022);\n\t\t\tRCon.Broadcast(RCon.LogType.Report, new\n\t\t\t{\n\t\t\t\tPlayerId = UserIDString,\n\t\t\t\tPlayerName = displayName,\n\t\t\t\tTargetId = targetId,\n\t\t\t\tTargetName = text4,\n\t\t\t\tSubject = text,\n\t\t\t\tMessage = message,\n\t\t\t\tType = text3\n\t\t\t});\n\t\t\tInterface.CallHook(\u0022OnPlayerReported\u0022, this, text4, targetId, text, text2, text3);\n\t\t\tif (!string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))\n\t\t\t{\n\t\t\t\tReportType type = ReportType.Abuse;\n\t\t\t\tif (text3.Equals(\u0022cheat\u0022))\n\t\t\t\t{\n\t\t\t\t\ttype = ReportType.Cheat;\n\t\t\t\t}\n\t\t\t\tif (text3.Equals(\u0022break_server_rules\u0022))\n\t\t\t\t{\n\t\t\t\t\ttype = ReportType.BreakingServerRules;\n\t\t\t\t}\n\t\t\t\tFacepunch.Models.Feedback feedback = default(Facepunch.Models.Feedback);\n\t\t\t\tfeedback.Subject = text;\n\t\t\t\tfeedback.Message = message;\n\t\t\t\tfeedback.TargetReportType = text3;\n\t\t\t\tfeedback.TargetId = targetId;\n\t\t\t\tfeedback.TargetName = text4;\n\t\t\t\tfeedback.Type = type;\n\t\t\t\tFacepunch.Models.Feedback feedback2 = feedback;\n\t\t\t\tDebugEx.Log(\u0022[OnPlayerReported to endpoint] \u0022 \u002B await Facepunch.Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, userID, ConVar.Server.reportsServerEndpointKey, feedback2));\n\t\t\t}\n\t\t\tBasePlayer basePlayer = FindAwakeOrSleeping(targetId);\n\t\t\tif (basePlayer != null)\n\t\t\t{\n\t\t\t\tbasePlayer.State.numberOfTimesReported\u002B\u002B;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022[OnPlayerReported] Exception occurred when sending F7 report to endpoint: \u0022 \u002B ex.Message);\n\t\t\tDebug.LogException(ex);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 25
  },
  {
    "HookSignature": "OnRespawnInformationGiven(BasePlayer basePlayer, System.Collections.Generic.List\u003CProtoBuf.RespawnInformation.SpawnOptions\u003E list)",
    "MethodSignature": "SendRespawnOptions()",
    "MethodSourseCode": "\n\tpublic void SendRespawnOptions()\n\t{\n\t\tif (NexusServer.Started \u0026\u0026 ZoneController.Instance.CanRespawnAcrossZones(this))\n\t\t{\n\t\t\tCollectExternalAndSend();\n\t\t\treturn;\n\t\t}\n\t\tList\u003CRespawnInformation.SpawnOptions\u003E list = Facepunch.Pool.Get\u003CList\u003CRespawnInformation.SpawnOptions\u003E\u003E();\n\t\tGetRespawnOptionsForPlayer(list, userID);\n\t\tInterface.CallHook(\u0022OnRespawnInformationGiven\u0022, this, list);\n\t\tSendToPlayer(list, loading: false);\n\t\tasync void CollectExternalAndSend()\n\t\t{\n\t\t\tList\u003CRespawnInformation.SpawnOptions\u003E list2 = Facepunch.Pool.Get\u003CList\u003CRespawnInformation.SpawnOptions\u003E\u003E();\n\t\t\tGetRespawnOptionsForPlayer(list2, userID);\n\t\t\tList\u003CRespawnInformation.SpawnOptions\u003E allSpawnOptions = Facepunch.Pool.Get\u003CList\u003CRespawnInformation.SpawnOptions\u003E\u003E();\n\t\t\tforeach (RespawnInformation.SpawnOptions item in list2)\n\t\t\t{\n\t\t\t\tallSpawnOptions.Add(item.Copy());\n\t\t\t}\n\t\t\tSendToPlayer(list2, loading: true);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tRequest request = Facepunch.Pool.Get\u003CRequest\u003E();\n\t\t\t\trequest.spawnOptions = Facepunch.Pool.Get\u003CSpawnOptionsRequest\u003E();\n\t\t\t\trequest.spawnOptions.userId = userID;\n\t\t\t\tusing (NexusRpcResult nexusRpcResult = await NexusServer.BroadcastRpc(request, 10f))\n\t\t\t\t{\n\t\t\t\t\tforeach (KeyValuePair\u003Cstring, Response\u003E response in nexusRpcResult.Responses)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring key = response.Key;\n\t\t\t\t\t\tSpawnOptionsResponse spawnOptions2 = response.Value.spawnOptions;\n\t\t\t\t\t\tif (spawnOptions2 != null \u0026\u0026 spawnOptions2.spawnOptions.Count != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tforeach (RespawnInformation.SpawnOptions spawnOption in spawnOptions2.spawnOptions)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRespawnInformation.SpawnOptions spawnOptions3 = spawnOption.Copy();\n\t\t\t\t\t\t\t\tspawnOptions3.nexusZone = key;\n\t\t\t\t\t\t\t\tallSpawnOptions.Add(spawnOptions3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSendToPlayer(allSpawnOptions, loading: false);\n\t\t\t}\n\t\t\tcatch (Exception exception)\n\t\t\t{\n\t\t\t\tDebug.LogException(exception);\n\t\t\t}\n\t\t}\n\t\tvoid SendToPlayer(List\u003CRespawnInformation.SpawnOptions\u003E spawnOptions, bool loading)\n\t\t{\n\t\t\tusing RespawnInformation respawnInformation = Facepunch.Pool.Get\u003CRespawnInformation\u003E();\n\t\t\trespawnInformation.spawnOptions = spawnOptions;\n\t\t\trespawnInformation.loading = loading;\n\t\t\tif (LegacyShelter.max_shelters == LegacyShelter.FpShelterDefault \u0026\u0026 LegacyShelter.SheltersPerPlayer.ContainsKey(userID) \u0026\u0026 LegacyShelter.SheltersPerPlayer[userID].Count \u003E 0)\n\t\t\t{\n\t\t\t\trespawnInformation.shelterPositions = Facepunch.Pool.Get\u003CList\u003CVector3\u003E\u003E();\n\t\t\t\tforeach (LegacyShelter item2 in LegacyShelter.SheltersPerPlayer[userID])\n\t\t\t\t{\n\t\t\t\t\trespawnInformation.shelterPositions.Add(item2.transform.position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (IsDead())\n\t\t\t{\n\t\t\t\trespawnInformation.previousLife = previousLifeStory;\n\t\t\t\tif (!ConVar.Server.skipDeathScreenFade)\n\t\t\t\t{\n\t\t\t\t\trespawnInformation.fadeIn = previousLifeStory != null \u0026\u0026 previousLifeStory.timeDied \u003E Epoch.Current - 5;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trespawnInformation.fadeIn = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tClientRPC(RpcTarget.Player(\u0022OnRespawnInformation\u0022, this), respawnInformation);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnVendingShopRename(VendingMachine vendingMachine, string obj, BasePlayer player)",
    "MethodSignature": "RPC_UpdateShopName(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_UpdateShopName(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tstring obj = msg.read.String(32);\n\t\tif (CanPlayerAdmin(player) \u0026\u0026 Interface.CallHook(\u0022OnVendingShopRename\u0022, this, obj, player) == null)\n\t\t{\n\t\t\tshopName = obj;\n\t\t\tnameLastEditedBy = player.userID.Get();\n\t\t\tUpdateMapMarker();\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnEntityControl(PoweredRemoteControlEntity poweredRemoteControlEntity, ulong playerID)",
    "MethodSignature": "CanControl(ulong playerID)",
    "MethodSourseCode": "\n\tpublic virtual bool CanControl(ulong playerID)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnEntityControl\u0022, this, playerID);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!IsPowered())\n\t\t{\n\t\t\treturn IsStatic();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PoweredRemoteControlEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTreeData)",
    "MethodSignature": "PlayerCanUnlock(BasePlayer player, NodeInstance node)",
    "MethodSourseCode": "\n\tpublic bool PlayerCanUnlock(BasePlayer player, NodeInstance node)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUnlockTechTreeNode\u0022, player, node, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (PlayerHasPathForUnlock(player, node))\n\t\t{\n\t\t\treturn !HasPlayerUnlocked(player, node);\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "TechTreeData",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerDig(BasePlayer player, BaseDiggableEntity baseDiggableEntity)",
    "MethodSignature": "Dig(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void Dig(BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerDig\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (digsRemaining == RequiredDigCount)\n\t\t{\n\t\t\tOnFirstDig(player);\n\t\t}\n\t\tClientRPC(RpcTarget.NetworkGroup(\u0022RPC_OnDig\u0022), RequiredDigCount - digsRemaining, RequiredDigCount);\n\t\tdigsRemaining--;\n\t\tbase.health = digsRemaining;\n\t\tSendNetworkUpdate();\n\t\tOnSingleDig(player);\n\t\tif (digsRemaining \u003C= 0)\n\t\t{\n\t\t\tOnFullyDug(player);\n\t\t\tif (DestroyOnDug)\n\t\t\t{\n\t\t\t\tKill();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseDiggableEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSwitchToggled(FuelGenerator fuelGenerator, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool generatorState = msg.read.Bit();\n\t\t\tSetGeneratorState(generatorState);\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "FuelGenerator",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnWaterCollect(WaterPump waterPump, ItemDefinition itemDefinition)",
    "MethodSignature": "CreateWater()",
    "MethodSourseCode": "\n\tpublic void CreateWater()\n\t{\n\t\tif (!IsFull())\n\t\t{\n\t\t\tItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(WaterResourceLocation.position);\n\t\t\tif (itemDefinition != null \u0026\u0026 Interface.CallHook(\u0022OnWaterCollect\u0022, this, itemDefinition) == null)\n\t\t\t{\n\t\t\t\tbase.inventory.AddItem(itemDefinition, AmountPerPump, 0uL);\n\t\t\t\tUpdateOnFlag();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "WaterPump",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnItemRepair(BasePlayer player, Item itemToRepair)",
    "MethodSignature": "RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)",
    "MethodSourseCode": "\n\tpublic static void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)\n\t{\n\t\tif (itemToRepair == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition info = itemToRepair.info;\n\t\tItemBlueprint blueprint = info.Blueprint;\n\t\tif (!blueprint)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemModRepair component = itemToRepair.info.GetComponent\u003CItemModRepair\u003E();\n\t\tif (!info.condition.repairable || itemToRepair.condition == itemToRepair.maxCondition)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (mustKnowBlueprint)\n\t\t{\n\t\t\tItemDefinition itemDefinition = ((info.isRedirectOf != null) ? info.isRedirectOf : info);\n\t\t\tbool flag = player.blueprints.HasUnlocked(itemDefinition) || (itemDefinition.Blueprint != null \u0026\u0026 !itemDefinition.Blueprint.isResearchable);\n\t\t\tif (!flag \u0026\u0026 BaseGameMode.svActiveGameMode != null \u0026\u0026 BaseGameMode.svActiveGameMode.canRepairIfCraftingBanned \u0026\u0026 !itemDefinition.IsAllowed(EraRestriction.Craft))\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnItemRepair\u0022, player, itemToRepair) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = RepairCostFraction(itemToRepair);\n\t\tbool flag2 = false;\n\t\tList\u003CItemAmount\u003E obj = Facepunch.Pool.Get\u003CList\u003CItemAmount\u003E\u003E();\n\t\tGetRepairCostList(blueprint, obj);\n\t\tforeach (ItemAmount item in obj)\n\t\t{\n\t\t\tif (item.itemDef.category != ItemCategory.Component)\n\t\t\t{\n\t\t\t\tint amount = player.inventory.GetAmount(item.itemDef.itemid);\n\t\t\t\tif (Mathf.CeilToInt(item.amount * num) \u003E amount)\n\t\t\t\t{\n\t\t\t\t\tflag2 = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag2)\n\t\t{\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t\t\treturn;\n\t\t}\n\t\tforeach (ItemAmount item2 in obj)\n\t\t{\n\t\t\tif (item2.itemDef.category != ItemCategory.Component)\n\t\t\t{\n\t\t\t\tint amount2 = Mathf.CeilToInt(item2.amount * num);\n\t\t\t\tplayer.inventory.Take(null, item2.itemid, amount2);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, \u0022repair\u0022, item2.itemDef.shortname, amount2, repairBenchEntity, null, safezone: false, null, 0uL, null, itemToRepair);\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t\tfloat conditionNormalized = itemToRepair.conditionNormalized;\n\t\tfloat maxConditionNormalized = itemToRepair.maxConditionNormalized;\n\t\titemToRepair.DoRepair(maxConditionLostOnRepair);\n\t\tFacepunch.Rust.Analytics.Azure.OnItemRepaired(player, repairBenchEntity, itemToRepair, conditionNormalized, maxConditionNormalized);\n\t\tif (ConVar.Global.developer \u003E 0)\n\t\t{\n\t\t\tDebug.Log(\u0022Item repaired! condition : \u0022 \u002B itemToRepair.condition \u002B \u0022/\u0022 \u002B itemToRepair.maxCondition);\n\t\t}\n\t\tstring strName = \u0022assets/bundled/prefabs/fx/repairbench/itemrepair.prefab\u0022;\n\t\tif (component != null \u0026\u0026 component.successEffect?.Get() != null)\n\t\t{\n\t\t\tstrName = component.successEffect.resourcePath;\n\t\t}\n\t\tEffect.server.Run(strName, repairBenchEntity, 0u, Vector3.zero, Vector3.zero);\n\t}\n",
    "ClassName": "RepairBench",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnItemCraft(IndustrialCrafter industrialCrafter, ItemBlueprint blueprint)",
    "MethodSignature": "RunJob()",
    "MethodSourseCode": "\n\tprotected override void RunJob()\n\t{\n\t\tbase.RunJob();\n\t\tif (ConVar.Server.industrialCrafterFrequency \u003C= 0f || HasFlag(Flags.Reserved1) || currentlyCrafting != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C= 3; i\u002B\u002B)\n\t\t{\n\t\t\tItem targetBlueprint = GetTargetBlueprint(i);\n\t\t\tif (targetBlueprint == null || GetWorkbench() == null || GetWorkbench().Workbenchlevel \u003C targetBlueprint.blueprintTargetDef.Blueprint.GetWorkbenchLevel())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tItemBlueprint blueprint = targetBlueprint.blueprintTargetDef.Blueprint;\n\t\t\tif (Interface.CallHook(\u0022OnItemCraft\u0022, this, blueprint) != null)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool flag = true;\n\t\t\tforeach (ItemAmount ingredient in blueprint.GetIngredients())\n\t\t\t{\n\t\t\t\tif ((float)GetInputAmount(ingredient.itemDef) \u003C ingredient.amount)\n\t\t\t\t{\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tflag = false;\n\t\t\tfor (int j = 9; j \u003C= 12; j\u002B\u002B)\n\t\t\t{\n\t\t\t\tItem slot = _inventory.GetSlot(j);\n\t\t\t\tif (slot == null || (slot.info == targetBlueprint.blueprintTargetDef \u0026\u0026 slot.amount \u002B blueprint.amountToCreate \u003C= slot.MaxStackable()))\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved2, b: true);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSetFlag(Flags.Reserved2, b: false);\n\t\t\tforeach (ItemAmount ingredient2 in blueprint.GetIngredients())\n\t\t\t{\n\t\t\t\tConsumeInputIngredient(ingredient2);\n\t\t\t}\n\t\t\tcurrentlyCrafting = targetBlueprint.blueprintTargetDef;\n\t\t\tcurrentlyCraftingAmount = blueprint.amountToCreate;\n\t\t\tfloat craftTime = blueprint.GetCraftTime();\n\t\t\tInvoke(CompleteCraft, craftTime);\n\t\t\tjobFinishes = craftTime;\n\t\t\tSetFlag(Flags.Reserved1, b: true);\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022ClientUpdateCraftTimeRemaining\u0022), (float)jobFinishes, jobFinishes.Duration);\n\t\t\tbreak;\n\t\t}\n\t}\n",
    "ClassName": "IndustrialCrafter",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnMlrsTarget(MLRS mLRS, UnityEngine.Vector3 worldPos, BasePlayer _mounted)",
    "MethodSignature": "SetUserTargetHitPos(Vector3 worldPos)",
    "MethodSourseCode": "\n\tpublic void SetUserTargetHitPos(Vector3 worldPos)\n\t{\n\t\tif (UserTargetHitPos == worldPos)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (base.isServer)\n\t\t{\n\t\t\tVector3 position = TerrainMeta.Position;\n\t\t\tVector3 vector = position \u002B TerrainMeta.Size;\n\t\t\tworldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);\n\t\t\tworldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);\n\t\t\tworldPos.y = GetSurfaceHeight(worldPos);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnMlrsTarget\u0022, this, worldPos, _mounted) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserTargetHitPos = worldPos;\n\t\tif (base.isServer)\n\t\t{\n\t\t\ttrueTargetHitPos = UserTargetHitPos;\n\t\t\tforeach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)\n\t\t\t{\n\t\t\t\tVector3 center = allSafeZone.triggerCollider.bounds.center;\n\t\t\t\tcenter.y = 0f;\n\t\t\t\tfloat num = ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) \u002B targetAreaRadius;\n\t\t\t\ttrueTargetHitPos.y = 0f;\n\t\t\t\tif (Vector3.Distance(center, trueTargetHitPos) \u003C num)\n\t\t\t\t{\n\t\t\t\t\tVector3 vector2 = trueTargetHitPos - center;\n\t\t\t\t\ttrueTargetHitPos = center \u002B vector2.normalized * num;\n\t\t\t\t\ttrueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnMlrsTargetSet\u0022, this, trueTargetHitPos, _mounted);\n\t}\n",
    "ClassName": "MLRS",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnTurretClearList(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "ClearList(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tprivate void ClearList(RPCMessage rpc)\n\t{\n\t\tBasePlayer player = rpc.player;\n\t\tif (!(player == null) \u0026\u0026 !booting \u0026\u0026 !IsOnline() \u0026\u0026 player.CanBuild() \u0026\u0026 Interface.CallHook(\u0022OnTurretClearList\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.Clear();\n\t\t\tauthDirty = true;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc.player, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022clear\u0022, rpc.player.userID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnTeamUpdate(ulong currentTeam, ulong newTeam, BasePlayer basePlayer)",
    "MethodSignature": "UpdateTeam(ulong newTeam)",
    "MethodSourseCode": "\n\tpublic void UpdateTeam(ulong newTeam)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTeamUpdate\u0022, currentTeam, newTeam, this) == null)\n\t\t{\n\t\t\tcurrentTeam = newTeam;\n\t\t\tSendNetworkUpdate();\n\t\t\tif (RelationshipManager.ServerInstance.FindTeam(newTeam) == null)\n\t\t\t{\n\t\t\t\tClearTeam();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tTeamUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnServerUserRemove(ulong uid)",
    "MethodSignature": "Remove(ulong uid)",
    "MethodSourseCode": "\n\tpublic static void Remove(ulong uid)\n\t{\n\t\tInterface.CallHook(\u0022OnServerUserRemove\u0022, uid);\n\t\tusers.Remove(uid);\n\t}\n",
    "ClassName": "ServerUsers",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnReactiveTargetReset(ReactiveTarget reactiveTarget)",
    "MethodSignature": "ResetTarget()",
    "MethodSourseCode": "\n\tpublic void ResetTarget()\n\t{\n\t\tif (IsLowered() \u0026\u0026 CanToggle() \u0026\u0026 CanReset())\n\t\t{\n\t\t\tCancelInvoke(ResetTarget);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tSetFlag(Flags.Reserved1, b: false);\n\t\t\tknockdownHealth = 100f;\n\t\t\tSendPowerBurst();\n\t\t\tInterface.CallHook(\u0022OnReactiveTargetReset\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "ReactiveTarget",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnBradleyApcThink(BradleyAPC bradleyAPC)",
    "MethodSignature": "DoSimpleAI()",
    "MethodSourseCode": "\n\tpublic void DoSimpleAI()\n\t{\n\t\tif (base.isClient)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);\n\t\tif (Interface.CallHook(\u0022OnBradleyApcThink\u0022, this) != null || !DoAI)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetTarget();\n\t\tif (mountingScientists || inDeployedState)\n\t\t{\n\t\t\tClearPath();\n\t\t}\n\t\telse if (!IsOnSpline())\n\t\t{\n\t\t\tif (targetList.Count \u003E 0)\n\t\t\t{\n\t\t\t\tUpdateMovement_Hunt();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tUpdateMovement_Patrol();\n\t\t\t}\n\t\t}\n\t\tif (!IsOnSpline())\n\t\t{\n\t\t\tAdvancePathMovement(force: false);\n\t\t\tfloat num = Vector3.Distance(base.transform.position, destination);\n\t\t\tfloat value = Vector3.Distance(base.transform.position, finalDestination);\n\t\t\tif (num \u003E stoppingDist)\n\t\t\t{\n\t\t\t\tVector3 lhs = Direction2D(destination, base.transform.position);\n\t\t\t\tfloat num2 = Vector3.Dot(lhs, base.transform.right);\n\t\t\t\tfloat num3 = Vector3.Dot(lhs, base.transform.right);\n\t\t\t\tfloat num4 = Vector3.Dot(lhs, -base.transform.right);\n\t\t\t\tif (Vector3.Dot(lhs, -base.transform.forward) \u003E num2)\n\t\t\t\t{\n\t\t\t\t\tif (num3 \u003E= num4)\n\t\t\t\t\t{\n\t\t\t\t\t\tturning = 1f;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tturning = -1f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tturning = Mathf.Clamp(num2 * 3f, -1f, 1f);\n\t\t\t\t}\n\t\t\t\tfloat throttleScaleFromTurn = 1f - Mathf.InverseLerp(0f, 0.3f, Mathf.Abs(turning));\n\t\t\t\tAvoidObstacles(ref throttleScaleFromTurn);\n\t\t\t\tfloat num5 = Vector3.Dot(myRigidBody.velocity, base.transform.forward);\n\t\t\t\tif (!(throttle \u003E 0f) || !(num5 \u003C 0.5f))\n\t\t\t\t{\n\t\t\t\t\ttimeSinceSeemingStuck = 0f;\n\t\t\t\t}\n\t\t\t\telse if ((float)timeSinceSeemingStuck \u003E 10f)\n\t\t\t\t{\n\t\t\t\t\ttimeSinceStuckReverseStart = 0f;\n\t\t\t\t\ttimeSinceSeemingStuck = 0f;\n\t\t\t\t}\n\t\t\t\tfloat num6 = Mathf.InverseLerp(0.1f, 0.4f, Vector3.Dot(base.transform.forward, Vector3.up));\n\t\t\t\tif ((float)timeSinceStuckReverseStart \u003C 3f)\n\t\t\t\t{\n\t\t\t\t\tthrottle = -0.75f;\n\t\t\t\t\tturning = 1f;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrottle = (0.1f \u002B Mathf.InverseLerp(0f, 20f, value) * 1f) * throttleScaleFromTurn \u002B num6;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDoWeaponAiming();\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnServerSave()",
    "MethodSignature": "DoAutomatedSave(bool AndWait)",
    "MethodSourseCode": "\n\t[IteratorStateMachine(typeof(\u003CDoAutomatedSave\u003Ed__20))]\n\tprivate IEnumerator DoAutomatedSave(bool AndWait = false)\n\t{\n\t\tInterface.CallHook(\u0022OnServerSave\u0022);\n\t\treturn new \u003CDoAutomatedSave\u003Ed__20(0)\n\t\t{\n\t\t\t\u003C\u003E4__this = this,\n\t\t\tAndWait = AndWait\n\t\t};\n\t}\n",
    "ClassName": "SaveRestore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnWaterPurify(WaterPurifier waterPurifier, float timeCooked)",
    "MethodSignature": "ConvertWater(float timeCooked)",
    "MethodSourseCode": "\n\tprotected void ConvertWater(float timeCooked)\n\t{\n\t\tItem slot = waterStorage.inventory.GetSlot(0);\n\t\tif ((stopWhenOutputFull \u0026\u0026 slot != null \u0026\u0026 slot.amount \u003E= slot.MaxStackable()) || Interface.CallHook(\u0022OnWaterPurify\u0022, this, timeCooked) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = timeCooked * ((float)waterToProcessPerMinute / 60f);\n\t\tif (slot != null)\n\t\t{\n\t\t\tfloat num2 = Mathf.Max(slot.MaxStackable() - slot.amount, 0);\n\t\t\tnum = Mathf.Min(num, num2 * (float)freshWaterRatio);\n\t\t}\n\t\tdirtyWaterProcssed \u002B= num;\n\t\tif (dirtyWaterProcssed \u003E= 1f)\n\t\t{\n\t\t\tItem slot2 = base.inventory.GetSlot(0);\n\t\t\tint num3 = Mathf.Min(Mathf.FloorToInt(dirtyWaterProcssed), slot2.amount);\n\t\t\tnum = num3;\n\t\t\tslot2.UseItem(num3);\n\t\t\tdirtyWaterProcssed -= num3;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tpendingFreshWater \u002B= num / (float)freshWaterRatio;\n\t\tif (!(pendingFreshWater \u003E= 1f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num4 = Mathf.FloorToInt(pendingFreshWater);\n\t\tpendingFreshWater -= num4;\n\t\tItem slot3 = waterStorage.inventory.GetSlot(0);\n\t\tif (slot3 != null \u0026\u0026 slot3.info != freshWater)\n\t\t{\n\t\t\tslot3.RemoveFromContainer();\n\t\t\tslot3.Remove();\n\t\t}\n\t\tif (slot3 == null)\n\t\t{\n\t\t\tItem item = ItemManager.Create(freshWater, num4, 0uL);\n\t\t\tif (!item.MoveToContainer(waterStorage.inventory))\n\t\t\t{\n\t\t\t\titem.Remove();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tslot3.amount \u002B= num4;\n\t\t\tslot3.amount = Mathf.Clamp(slot3.amount, 0, waterStorage.maxStackSize);\n\t\t\twaterStorage.inventory.MarkDirty();\n\t\t}\n\t\tInterface.CallHook(\u0022OnWaterPurified\u0022, this, timeCooked);\n\t\twaterStorage.SendNetworkUpdate();\n\t}\n",
    "ClassName": "WaterPurifier",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnWaterCollect(WaterCatcher waterCatcher)",
    "MethodSignature": "CollectWater()",
    "MethodSourseCode": "\n\tpublic void CollectWater()\n\t{\n\t\tif (!IsFull() \u0026\u0026 Interface.CallHook(\u0022OnWaterCollect\u0022, this) == null)\n\t\t{\n\t\t\tfloat baseRate = collectionRates.baseRate;\n\t\t\tbaseRate \u002B= Climate.GetFog(base.transform.position) * collectionRates.fogRate;\n\t\t\tif (TestIsOutside(base.transform, rainTestPosition, rainTestSize, 256f))\n\t\t\t{\n\t\t\t\tbaseRate \u002B= Climate.GetRain(base.transform.position) * collectionRates.rainRate;\n\t\t\t\tbaseRate \u002B= Climate.GetSnow(base.transform.position) * collectionRates.snowRate;\n\t\t\t}\n\t\t\tAddResource(Mathf.CeilToInt(maxItemToCreate * baseRate));\n\t\t}\n\t}\n",
    "ClassName": "WaterCatcher",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnQueueCycle(int availableSlots)",
    "MethodSignature": "Cycle(int availableSlots)",
    "MethodSourseCode": "\n\tpublic void Cycle(int availableSlots)\n\t{\n\t\tif (Interface.CallHook(\u0022OnQueueCycle\u0022, availableSlots) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Time.realtimeSinceStartup \u003E nextCleanupReservedSlots)\n\t\t{\n\t\t\tnextCleanupReservedSlots = UnityEngine.Time.realtimeSinceStartup \u002B 1f;\n\t\t\tCleanupExpiredReservedSlots();\n\t\t}\n\t\tif (queue.Count != 0)\n\t\t{\n\t\t\tSendQueueUpdates();\n\t\t\tif (!IsServerFull)\n\t\t\t{\n\t\t\t\tJoinGame(queue[0]);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ConnectionQueue",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerSleepEnded(BasePlayer basePlayer)",
    "MethodSignature": "EndSleeping()",
    "MethodSourseCode": "\n\tpublic virtual void EndSleeping()\n\t{\n\t\tif (IsSleeping() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSleepEnd\u0022, this) == null)\n\t\t{\n\t\t\tif (IsRestrained)\n\t\t\t{\n\t\t\t\tinventory.SetLockedByRestraint(flag: true);\n\t\t\t}\n\t\t\tSetPlayerFlag(PlayerFlags.Sleeping, b: false);\n\t\t\tsleepStartTime = -1f;\n\t\t\tsleepingPlayerList.Remove(this);\n\t\t\tif ((ulong)userID \u003C 10000000 \u0026\u0026 !bots.Contains(this))\n\t\t\t{\n\t\t\t\tbots.Add(this);\n\t\t\t}\n\t\t\tCancelInvoke(ScheduledDeath);\n\t\t\tInvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));\n\t\t\tif (RelationshipManager.TeamsEnabled())\n\t\t\t{\n\t\t\t\tInvokeRandomized(TeamUpdate, 1f, 4f, 1f);\n\t\t\t}\n\t\t\tInvokeRandomized(UpdateClanLastSeen, 300f, 300f, 60f);\n\t\t\tEnablePlayerCollider();\n\t\t\tAddPlayerRigidbody();\n\t\t\tSetServerFall(wantsOn: false);\n\t\t\tRunOfflineMetabolism(state: false);\n\t\t\tif (HasParent())\n\t\t\t{\n\t\t\t\tSetParent(null, worldPositionStays: true);\n\t\t\t\tRemoveFromTriggers();\n\t\t\t\tForceUpdateTriggers();\n\t\t\t}\n\t\t\tinventory.containerMain.OnChanged();\n\t\t\tinventory.containerBelt.OnChanged();\n\t\t\tinventory.containerWear.OnChanged();\n\t\t\tInterface.CallHook(\u0022OnPlayerSleepEnded\u0022, this);\n\t\t\tEACServer.LogPlayerSpawn(this);\n\t\t\tif (TotalPingCount \u003E 0)\n\t\t\t{\n\t\t\t\tSendPingsToClient();\n\t\t\t}\n\t\t\tif (TutorialIsland.ShouldPlayerBeAskedToStartTutorial(this))\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022PromptToStartTutorial\u0022, this));\n\t\t\t}\n\t\t\tif (AntiHack.TestNoClipping(this, base.transform.position, base.transform.position, NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _))\n\t\t\t{\n\t\t\t\tForceCastNoClip();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 36
  },
  {
    "HookSignature": "OnWeaponFired(BaseProjectile baseProjectile, BasePlayer msgPlayer, ItemModProjectile component, ProtoBuf.ProjectileShoot projectileShoot)",
    "MethodSignature": "CLProject(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server.FromOwner(false)]\n\t[RPC_Server]\n\tprivate void CLProject(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientAttack(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t\treturn;\n\t\t}\n\t\tif (reloadFinished \u0026\u0026 HasReloadCooldown())\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Reloading (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022reload_cooldown\u0022);\n\t\t\treturn;\n\t\t}\n\t\treloadStarted = false;\n\t\treloadFinished = false;\n\t\tif (primaryMagazine.contents \u003C= 0 \u0026\u0026 !base.UsingInfiniteAmmoCheat)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Magazine empty (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022ammo_missing\u0022);\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition primaryMagazineAmmo = PrimaryMagazineAmmo;\n\t\tusing ProjectileShoot projectileShoot = msg.read.Proto\u003CProjectileShoot\u003E();\n\t\tif (primaryMagazineAmmo.itemid != projectileShoot.ammoType)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Ammo mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022ammo_mismatch\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!base.UsingInfiniteAmmoCheat)\n\t\t{\n\t\t\tModifyAmmoCount(-1);\n\t\t}\n\t\tItemModProjectile component = primaryMagazineAmmo.GetComponent\u003CItemModProjectile\u003E();\n\t\tif (component == null)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022mod_missing\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (projectileShoot.projectiles.Count \u003E component.numProjectiles)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Count mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022count_mismatch\u0022);\n\t\t\treturn;\n\t\t}\n\t\tInterface.CallHook(\u0022OnWeaponFired\u0022, this, msg.player, component, projectileShoot);\n\t\tif (player.InGesture)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSignalBroadcast(Signal.Attack, string.Empty, msg.connection, GetAttackEffect());\n\t\tplayer.CleanupExpiredProjectiles();\n\t\tGuid projectileGroupId = Guid.NewGuid();\n\t\tforeach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\n\t\t{\n\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Duplicate ID (\u0022 \u002B projectile.projectileID \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022duplicate_id\u0022);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVector3 positionOffset = Vector3.zero;\n\t\t\tif (ConVar.AntiHack.projectile_positionoffset \u0026\u0026 (player.isMounted || player.HasParent()))\n\t\t\t{\n\t\t\t\tif (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tVector3 position = player.eyes.position;\n\t\t\t\tpositionOffset = position - projectile.startPos;\n\t\t\t\tprojectile.startPos = position;\n\t\t\t}\n\t\t\telse if (!ValidateEyePos(player, projectile.startPos))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, primaryMagazineAmmo, projectileGroupId, positionOffset);\n\t\t\tif (!player.limitNetworking)\n\t\t\t{\n\t\t\t\tCreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());\n\t\t\t}\n\t\t}\n\t\tplayer.MakeNoise(player.transform.position, BaseCombatEntity.ActionVolume.Loud);\n\t\tSingletonComponent\u003CNpcNoiseManager\u003E.Instance.OnWeaponShot(player, this);\n\t\tplayer.stats.Add(component.category \u002B \u0022_fired\u0022, projectileShoot.projectiles.Count, (Stats)5);\n\t\tplayer.LifeStoryShotFired(this);\n\t\tStartAttackCooldown(ScaleRepeatDelay(repeatDelay) \u002B animationDelay);\n\t\tplayer.MarkHostileFor();\n\t\tUpdateItemCondition();\n\t\tDidAttackServerside();\n\t\tBaseMountable mounted = player.GetMounted();\n\t\tif (mounted != null)\n\t\t{\n\t\t\tmounted.OnWeaponFired(this);\n\t\t}\n\t\tEACServer.LogPlayerUseWeapon(player, this);\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 51
  },
  {
    "HookSignature": "OnBoatPathGenerate()",
    "MethodSignature": "GenerateOceanPatrolPath(float minDistanceFromShore, float minWaterDepth)",
    "MethodSourseCode": "\n\tpublic static List\u003CVector3\u003E GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnBoatPathGenerate\u0022);\n\t\tif (obj is List\u003CVector3\u003E)\n\t\t{\n\t\t\treturn (List\u003CVector3\u003E)obj;\n\t\t}\n\t\tfloat x = TerrainMeta.Size.x;\n\t\tfloat num = x * 2f * MathF.PI;\n\t\tfloat num2 = 30f;\n\t\tint num3 = Mathf.CeilToInt(num / num2);\n\t\tList\u003CVector3\u003E list = new List\u003CVector3\u003E();\n\t\tfloat num4 = x;\n\t\tfloat y = 0f;\n\t\tfor (int i = 0; i \u003C num3; i\u002B\u002B)\n\t\t{\n\t\t\tfloat num5 = (float)i / (float)num3 * 360f;\n\t\t\tlist.Add(new Vector3(Mathf.Sin(num5 * (MathF.PI / 180f)) * num4, y, Mathf.Cos(num5 * (MathF.PI / 180f)) * num4));\n\t\t}\n\t\tfloat num6 = 4f;\n\t\tfloat num7 = 200f;\n\t\tbool flag = true;\n\t\tfor (int j = 0; j \u003C AI.ocean_patrol_path_iterations \u0026\u0026 flag; j\u002B\u002B)\n\t\t{\n\t\t\tflag = false;\n\t\t\tfor (int k = 0; k \u003C num3; k\u002B\u002B)\n\t\t\t{\n\t\t\t\tVector3 vector = list[k];\n\t\t\t\tint index = ((k == 0) ? (num3 - 1) : (k - 1));\n\t\t\t\tint index2 = ((k != num3 - 1) ? (k \u002B 1) : 0);\n\t\t\t\tVector3 b = list[index2];\n\t\t\t\tVector3 b2 = list[index];\n\t\t\t\tVector3 origin = vector;\n\t\t\t\tVector3 normalized = (Vector3.zero - vector).normalized;\n\t\t\t\tVector3 vector2 = vector \u002B normalized * num6;\n\t\t\t\tif (Vector3.Distance(vector2, b) \u003E num7 || Vector3.Distance(vector2, b2) \u003E num7)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool flag2 = true;\n\t\t\t\tint num8 = 16;\n\t\t\t\tfor (int l = 0; l \u003C num8; l\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tfloat num9 = (float)l / (float)num8 * 360f;\n\t\t\t\t\tVector3 normalized2 = new Vector3(Mathf.Sin(num9 * (MathF.PI / 180f)), y, Mathf.Cos(num9 * (MathF.PI / 180f))).normalized;\n\t\t\t\t\tVector3 vector3 = vector2 \u002B normalized2 * 1f;\n\t\t\t\t\tVector3 direction = normalized;\n\t\t\t\t\tif (vector3 != Vector3.zero)\n\t\t\t\t\t{\n\t\t\t\t\t\tdirection = (vector3 - vector2).normalized;\n\t\t\t\t\t}\n\t\t\t\t\tif (UnityEngine.Physics.SphereCast(origin, 3f, direction, out var _, minDistanceFromShore, 1084293377))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag2 = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag2)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tlist[k] = vector2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Failed to generate ocean patrol path\u0022);\n\t\t\treturn null;\n\t\t}\n\t\tList\u003Cint\u003E list2 = new List\u003Cint\u003E();\n\t\tLineUtility.Simplify(list, 5f, list2);\n\t\tList\u003CVector3\u003E list3 = list;\n\t\tlist = new List\u003CVector3\u003E();\n\t\tforeach (int item in list2)\n\t\t{\n\t\t\tlist.Add(list3[item]);\n\t\t}\n\t\tDebug.Log(\u0022Generated ocean patrol path with node count: \u0022 \u002B list.Count);\n\t\treturn list;\n\t}\n",
    "ClassName": "BaseBoat",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnVehiclePush(BaseVehicle baseVehicle, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_WantsPush(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(5f)]\n\t[RPC_Server]\n\tpublic void RPC_WantsPush(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!player.isMounted \u0026\u0026 !RecentlyPushed \u0026\u0026 CanPushNow(player) \u0026\u0026 !(rigidBody == null) \u0026\u0026 (!OnlyOwnerAccessible() || !(player != creatorEntity)) \u0026\u0026 Interface.CallHook(\u0022OnVehiclePush\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tplayer.metabolism.calories.Subtract(3f);\n\t\t\tplayer.metabolism.SendChangesToClient();\n\t\t\tif (rigidBody.IsSleeping())\n\t\t\t{\n\t\t\t\trigidBody.WakeUp();\n\t\t\t}\n\t\t\tDoPushAction(player);\n\t\t\ttimeSinceLastPush = 0f;\n\t\t}\n\t}\n",
    "ClassName": "BaseVehicle",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnFireworkStarted(BaseFirework baseFirework)",
    "MethodSignature": "Begin()",
    "MethodSourseCode": "\n\tpublic virtual void Begin()\n\t{\n\t\tSetFlag(Flags.OnFire, b: false);\n\t\tSetFlag(Flags.On, b: true, recursive: false, networkupdate: false);\n\t\tSendNetworkUpdate_Flags();\n\t\tInterface.CallHook(\u0022OnFireworkStarted\u0022, this);\n\t\tInvoke(OnExhausted, activityLength);\n\t}\n",
    "ClassName": "BaseFirework",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnConnectionDequeue(Network.Connection connection)",
    "MethodSignature": "RemoveConnection(Connection connection)",
    "MethodSourseCode": "\n\tpublic void RemoveConnection(Connection connection)\n\t{\n\t\tif (Interface.CallHook(\u0022OnConnectionDequeue\u0022, connection) == null)\n\t\t{\n\t\t\tif (queue.Remove(connection))\n\t\t\t{\n\t\t\t\tnextMessageTime = 0f;\n\t\t\t}\n\t\t\tjoining.Remove(connection);\n\t\t}\n\t}\n",
    "ClassName": "ConnectionQueue",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFishingRodCast(BaseFishingRod baseFishingRod, BasePlayer ownerPlayer, Item currentLure)",
    "MethodSignature": "Server_RequestCast(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void Server_RequestCast(RPCMessage msg)\n\t{\n\t\tVector3 pos = msg.read.Vector3();\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tItem currentLure = GetCurrentLure();\n\t\tif (currentLure == null)\n\t\t{\n\t\t\tFailedCast(FailReason.NoLure);\n\t\t\treturn;\n\t\t}\n\t\tif (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))\n\t\t{\n\t\t\tFailedCast(reason);\n\t\t\treturn;\n\t\t}\n\t\tItemModCompostable component = (ItemModCompostable)Interface.CallHook(\u0022CanCastFishingRod\u0022, ownerPlayer, this, currentLure, pos);\n\t\tif (!(component is bool) || (bool)(object)component)\n\t\t{\n\t\t\tFishingBobber component2 = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position \u002B Vector3.up * 2.8f \u002B ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent\u003CFishingBobber\u003E();\n\t\t\tcomponent2.transform.forward = GetOwnerPlayer().eyes.BodyForward();\n\t\t\tcomponent2.Spawn();\n\t\t\tcomponent2.InitialiseBobber(ownerPlayer, surfaceBody, pos, 150f);\n\t\t\tint usedLureAmount = 0;\n\t\t\tif (FishLookup.Instance != null)\n\t\t\t{\n\t\t\t\tcurrentFishTarget = FishLookup.Instance.GetFish(component2.transform.position, surfaceBody, currentLure, out fishableModifier, lastFish, out usedLureAmount);\n\t\t\t}\n\t\t\tlureUsed = currentLure.info;\n\t\t\tcurrentLure.UseItem(usedLureAmount);\n\t\t\tlastFish = fishableModifier;\n\t\t\tcurrentBobber.Set(component2);\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_ReceiveCastPoint\u0022), component2.net.ID);\n\t\t\townerPlayer.SignalBroadcast(Signal.Attack);\n\t\t\tcatchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));\n\t\t\tcatchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;\n\t\t\tfloat val = (lureUsed.TryGetComponent\u003CItemModCompostable\u003E(out component) ? component.BaitValue : 0f);\n\t\t\tval = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);\n\t\t\tcatchTime = Mathf.Clamp((float)catchTime - val, 3f, 20f);\n\t\t\tplayerStartPosition = ownerPlayer.transform.position;\n\t\t\tSetFlag(Flags.Busy, b: true);\n\t\t\tCurrentState = CatchState.Waiting;\n\t\t\tInvokeRepeating(CatchProcess, 0f, 0f);\n\t\t\tinQueue = false;\n\t\t\tBasePlayer ownerPlayer2 = GetOwnerPlayer();\n\t\t\tif (ownerPlayer2 != null)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnStartFish(ownerPlayer2, currentLure, pos);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnFishingRodCast\u0022, this, ownerPlayer, currentLure);\n\t\t}\n\t}\n",
    "ClassName": "BaseFishingRod",
    "HookLineInvoke": 51
  },
  {
    "HookSignature": "OnBuildingMerge(ServerBuildingManager serverBuildingManager, BuildingManager.Building building1, BuildingManager.Building building2)",
    "MethodSignature": "Merge(Building building1, Building building2)",
    "MethodSourseCode": "\n\tprivate void Merge(Building building1, Building building2)\n\t{\n\t\tInterface.CallHook(\u0022OnBuildingMerge\u0022, this, building1, building2);\n\t\twhile (building2.HasDecayEntities())\n\t\t{\n\t\t\tbuilding2.decayEntities[0].AttachToBuilding(building1.ID);\n\t\t}\n\t\tif (AI.nav_carve_use_building_optimization)\n\t\t{\n\t\t\tbuilding1.isNavMeshCarvingDirty = true;\n\t\t\tbuilding2.isNavMeshCarvingDirty = true;\n\t\t\tint ticks = 3;\n\t\t\tUpdateNavMeshCarver(building1, ref ticks, 0);\n\t\t\tUpdateNavMeshCarver(building1, ref ticks, 0);\n\t\t}\n\t}\n",
    "ClassName": "ServerBuildingManager",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBradleyApcHunt(BradleyAPC bradleyAPC)",
    "MethodSignature": "UpdateMovement_Hunt()",
    "MethodSourseCode": "\n\tpublic void UpdateMovement_Hunt()\n\t{\n\t\tif (Interface.CallHook(\u0022OnBradleyApcHunt\u0022, this) != null || patrolPath == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tTargetInfo targetInfo = targetList[0];\n\t\tif (!targetInfo.IsValid())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (HasPath() \u0026\u0026 targetInfo.IsVisible())\n\t\t{\n\t\t\tif (currentPath.Count \u003E 1)\n\t\t\t{\n\t\t\t\tVector3 item = currentPath[currentPathIndex];\n\t\t\t\tClearPath();\n\t\t\t\tcurrentPath.Add(item);\n\t\t\t\tfinalDestination = item;\n\t\t\t\tcurrentPathIndex = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!(UnityEngine.Time.time \u003E nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbool flag = false;\n\t\t\tIAIPathNode start = patrolPath.GetClosestToPoint(base.transform.position);\n\t\t\tList\u003CIAIPathNode\u003E nodes = Facepunch.Pool.Get\u003CList\u003CIAIPathNode\u003E\u003E();\n\t\t\tif (GetEngagementPath(ref nodes))\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tstart = nodes[nodes.Count - 1];\n\t\t\t}\n\t\t\tIAIPathNode iAIPathNode = null;\n\t\t\tList\u003CIAIPathNode\u003E nearNodes = Facepunch.Pool.Get\u003CList\u003CIAIPathNode\u003E\u003E();\n\t\t\tpatrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);\n\t\t\tStack\u003CIAIPathNode\u003E stack = null;\n\t\t\tfloat num = float.PositiveInfinity;\n\t\t\tfloat y = mainTurretEyePos.localPosition.y;\n\t\t\tforeach (IAIPathNode item2 in nearNodes)\n\t\t\t{\n\t\t\t\tStack\u003CIAIPathNode\u003E path = new Stack\u003CIAIPathNode\u003E();\n\t\t\t\tif (targetInfo.entity.IsVisible(item2.Position \u002B new Vector3(0f, y, 0f)) \u0026\u0026 AStarPath.FindPath(start, item2, out path, out var pathCost) \u0026\u0026 pathCost \u003C num)\n\t\t\t\t{\n\t\t\t\t\tstack = path;\n\t\t\t\t\tnum = pathCost;\n\t\t\t\t\tiAIPathNode = item2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stack == null \u0026\u0026 nearNodes.Count \u003E 0)\n\t\t\t{\n\t\t\t\tStack\u003CIAIPathNode\u003E path2 = new Stack\u003CIAIPathNode\u003E();\n\t\t\t\tIAIPathNode iAIPathNode2 = nearNodes[UnityEngine.Random.Range(0, nearNodes.Count)];\n\t\t\t\tif (AStarPath.FindPath(start, iAIPathNode2, out path2, out var pathCost2) \u0026\u0026 pathCost2 \u003C num)\n\t\t\t\t{\n\t\t\t\t\tstack = path2;\n\t\t\t\t\tiAIPathNode = iAIPathNode2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stack != null)\n\t\t\t{\n\t\t\t\tcurrentPath.Clear();\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i \u003C nodes.Count - 1; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentPath.Add(nodes[i].Position);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tforeach (IAIPathNode item3 in stack)\n\t\t\t\t{\n\t\t\t\t\tcurrentPath.Add(item3.Position);\n\t\t\t\t}\n\t\t\t\tcurrentPathIndex = -1;\n\t\t\t\tpathLooping = false;\n\t\t\t\tfinalDestination = iAIPathNode.Position;\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref nearNodes);\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref nodes);\n\t\t\tnextEngagementPathTime = UnityEngine.Time.time \u002B 5f;\n\t\t}\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanWearItem(PlayerInventory playerInventory, Item item, int targetSlot)",
    "MethodSignature": "CanWearItem(Item item, int targetSlot)",
    "MethodSourseCode": "\n\tpublic bool CanWearItem(Item item, int targetSlot)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanWearItem\u0022, this, item, targetSlot);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn CanWearItem(item, canAdjustClothing: true, targetSlot);\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRackedWeaponUnloaded(Item slot, BasePlayer player, WeaponRack weaponRack)",
    "MethodSignature": "UnloadWeapon(BasePlayer player, int mountSlotIndex)",
    "MethodSourseCode": "\n\tprivate void UnloadWeapon(BasePlayer player, int mountSlotIndex)\n\t{\n\t\tif (player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);\n\t\tif (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\n\t\tif (slot == null || Interface.CallHook(\u0022OnRackedWeaponUnload\u0022, slot, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity heldEntity = slot.GetHeldEntity();\n\t\tif (!(heldEntity == null))\n\t\t{\n\t\t\tBaseProjectile component = heldEntity.GetComponent\u003CBaseProjectile\u003E();\n\t\t\tif (!(component == null))\n\t\t\t{\n\t\t\t\tItemDefinition ammoType = component.primaryMagazine.ammoType;\n\t\t\t\tcomponent.UnloadAmmo(slot, player);\n\t\t\t\tSetSlotAmmoDetails(weaponAtIndex, slot);\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022PlayAmmoSound\u0022, player), ammoType.itemid, 1);\n\t\t\t\tInterface.CallHook(\u0022OnRackedWeaponUnloaded\u0022, slot, player, this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "WeaponRack",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnBradleyApcInitialize(BradleyAPC bradleyAPC)",
    "MethodSignature": "Initialize()",
    "MethodSourseCode": "\n\tpublic void Initialize()\n\t{\n\t\tif (Interface.CallHook(\u0022OnBradleyApcInitialize\u0022, this) == null)\n\t\t{\n\t\t\tmyRigidBody.centerOfMass = centerOfMass.localPosition;\n\t\t\tdestination = base.transform.position;\n\t\t\tfinalDestination = base.transform.position;\n\t\t}\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEventCollectablePickup(BasePlayer msgPlayer, CollectableEasterEgg collectableEasterEgg)",
    "MethodSignature": "RPC_PickUp(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_PickUp(RPCMessage msg)\n\t{\n\t\tif (msg.player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = UnityEngine.Time.realtimeSinceStartup - lastPickupStartTime;\n\t\tif (!(msg.player.GetHeldEntity() as EasterBasket) \u0026\u0026 (num \u003E 2f || num \u003C 0.8f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif ((bool)EggHuntEvent.serverEvent)\n\t\t{\n\t\t\tif (!EggHuntEvent.serverEvent.IsEventActive() || Interface.CallHook(\u0022OnEventCollectablePickup\u0022, msg.player, this) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tEggHuntEvent.serverEvent.OnEggCollected(msg.player, this);\n\t\t\tint iAmount = 1;\n\t\t\tmsg.player.GiveItem(ItemManager.Create(itemToGive, iAmount, 0uL));\n\t\t}\n\t\tEffect.server.Run(pickupEffect.resourcePath, base.transform.position \u002B Vector3.up * 0.3f, Vector3.up);\n\t\tKill();\n\t}\n",
    "ClassName": "CollectableEasterEgg",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnDemoRecordingStop(string netConnectionRecordFilename, BasePlayer basePlayer)",
    "MethodSignature": "StopDemoRecording()",
    "MethodSourseCode": "\n\tpublic void StopDemoRecording()\n\t{\n\t\tif (net != null \u0026\u0026 net.connection != null \u0026\u0026 net.connection.IsRecording \u0026\u0026 Interface.CallHook(\u0022OnDemoRecordingStop\u0022, net.connection.recordFilename, this) == null)\n\t\t{\n\t\t\tDebug.Log(ToString() \u002B \u0022 recording stopped: \u0022 \u002B net.connection.RecordFilename);\n\t\t\tnet.connection.StopRecording();\n\t\t\tCancelInvoke(MonitorDemoRecording);\n\t\t\tInterface.CallHook(\u0022OnDemoRecordingStopped\u0022, net.connection.recordFilename, this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSamSiteTarget(SamSite samSite, SamSite.ISamSiteTarget item)",
    "MethodSignature": "TargetScan()",
    "MethodSourseCode": "\n\tpublic void TargetScan()\n\t{\n\t\tif (!IsPowered())\n\t\t{\n\t\t\tlastTargetVisibleTime = 0f;\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Time.time \u003E lastTargetVisibleTime \u002B 3f)\n\t\t{\n\t\t\tClearTarget();\n\t\t}\n\t\tif (!staticRespawn)\n\t\t{\n\t\t\tint num = ((ammoItem != null \u0026\u0026 ammoItem.parent == base.inventory) ? ammoItem.amount : 0);\n\t\t\tbool flag = lastAmmoCount \u003C lowAmmoThreshold;\n\t\t\tbool flag2 = num \u003C lowAmmoThreshold;\n\t\t\tif (num != lastAmmoCount \u0026\u0026 flag != flag2)\n\t\t\t{\n\t\t\t\tMarkIODirty();\n\t\t\t}\n\t\t\tlastAmmoCount = num;\n\t\t}\n\t\tif (HasValidTarget() || IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003CISamSiteTarget\u003E obj = Facepunch.Pool.Get\u003CList\u003CISamSiteTarget\u003E\u003E();\n\t\tif (Interface.CallHook(\u0022OnSamSiteTargetScan\u0022, this, obj) == null)\n\t\t{\n\t\t\tif (!IsInDefenderMode())\n\t\t\t{\n\t\t\t\tAddTargetSet(obj, targetTypeVehicle.scanRadius);\n\t\t\t}\n\t\t\tAddMLRSRockets(obj, targetTypeMissile.scanRadius);\n\t\t}\n\t\tISamSiteTarget samSiteTarget = null;\n\t\tforeach (ISamSiteTarget item in obj)\n\t\t{\n\t\t\tif (!item.isClient \u0026\u0026 !(item.CenterPoint().y \u003C eyePoint.transform.position.y) \u0026\u0026 item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) \u0026\u0026 item.IsValidSAMTarget(staticRespawn) \u0026\u0026 Interface.CallHook(\u0022OnSamSiteTarget\u0022, this, item) == null)\n\t\t\t{\n\t\t\t\tsamSiteTarget = item;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ObjectEx.IsUnityNull(samSiteTarget) \u0026\u0026 currentTarget != samSiteTarget)\n\t\t{\n\t\t\tlockOnTime = UnityEngine.Time.time \u002B 0.5f;\n\t\t}\n\t\tSetTarget(samSiteTarget);\n\t\tif (!ObjectEx.IsUnityNull(currentTarget))\n\t\t{\n\t\t\tlastTargetVisibleTime = UnityEngine.Time.time;\n\t\t}\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t\tif (ObjectEx.IsUnityNull(currentTarget))\n\t\t{\n\t\t\tCancelInvoke(WeaponTick);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);\n\t\t}\n\t}\n",
    "ClassName": "SamSite",
    "HookLineInvoke": 39
  },
  {
    "HookSignature": "OnEntityTakeDamage(ResourceEntity resourceEntity, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnAttacked(HitInfo info)\n\t{\n\t\tif (!base.isServer || isKilled || Interface.CallHook(\u0022OnEntityTakeDamage\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (resourceDispenser != null)\n\t\t{\n\t\t\tresourceDispenser.OnAttacked(info);\n\t\t}\n\t\tif (!info.DidGather)\n\t\t{\n\t\t\tif ((bool)baseProtection)\n\t\t\t{\n\t\t\t\tbaseProtection.Scale(info.damageTypes);\n\t\t\t}\n\t\t\tfloat num = info.damageTypes.Total();\n\t\t\thealth -= num;\n\t\t\tif (health \u003C= 0f)\n\t\t\t{\n\t\t\t\tOnDied(info);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOnHealthChanged();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ResourceEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerDrink(BasePlayer rpcPlayer, LiquidContainer liquidContainer)",
    "MethodSignature": "SVDrink(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void SVDrink(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.metabolism.CanConsume() || Interface.CallHook(\u0022OnPlayerDrink\u0022, rpc.player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (Item item in base.inventory.itemList)\n\t\t{\n\t\t\tItemModConsume component = item.info.GetComponent\u003CItemModConsume\u003E();\n\t\t\tif (!(component == null) \u0026\u0026 component.CanDoAction(item, rpc.player))\n\t\t\t{\n\t\t\t\tcomponent.DoAction(item, rpc.player);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "LiquidContainer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnVehicleHornPressed(VehicleModuleSeating vehicleModuleSeating, BasePlayer player)",
    "MethodSignature": "PlayerServerInput(InputState inputState, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void PlayerServerInput(InputState inputState, BasePlayer player)\n\t{\n\t\tbase.PlayerServerInput(inputState, player);\n\t\tif (hornLoop != null \u0026\u0026 IsOnThisModule(player))\n\t\t{\n\t\t\tbool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);\n\t\t\tif (flag != HasFlag(Flags.Reserved8))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved8, flag);\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnVehicleHornPressed\u0022, this, player);\n\t\t\t\thornPlayer = player;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "VehicleModuleSeating",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnHelicopterAttack(CH47HelicopterAIController cH47HelicopterAIController, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnAttacked(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterAttack\u0022, this, info) == null)\n\t\t{\n\t\t\tbase.OnAttacked(info);\n\t\t\tInitiateAnger();\n\t\t\tSetFlag(Flags.Reserved9, base.healthFraction \u003C= 0.8f);\n\t\t\tSetFlag(Flags.OnFire, base.healthFraction \u003C= 0.33f);\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanDeployScientists(BradleyAPC bradleyAPC, BaseEntity attacker, System.Collections.Generic.List\u003CGameObjectRef\u003E scientistPrefabs, System.Collections.Generic.List\u003CUnityEngine.Vector3\u003E spawnPositions)",
    "MethodSignature": "CanDeployScientists(BaseEntity attacker, List\u003CGameObjectRef\u003E scientistPrefabs, List\u003CVector3\u003E spawnPositions)",
    "MethodSourseCode": "\n\tprivate bool CanDeployScientists(BaseEntity attacker, List\u003CGameObjectRef\u003E scientistPrefabs, List\u003CVector3\u003E spawnPositions)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanDeployScientists\u0022, this, attacker, scientistPrefabs, spawnPositions);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tint count = scientistPrefabs.Count;\n\t\tif (!inDeployedState \u0026\u0026 Vector3.Distance(attacker.transform.position, base.transform.position) \u003E DeployAttackDistanceMax)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tspawnPositions.Clear();\n\t\tbool flag = false;\n\t\tint num = 0;\n\t\tint num2 = 0;\n\t\tint layerMask = 8454144;\n\t\twhile (!flag)\n\t\t{\n\t\t\tif (UnityEngine.Physics.Raycast(ScientistSpawnPoints[num2 % ScientistSpawnPoints.Count].transform.position \u002B Vector3.up * 1f, Vector3.down, out var hitInfo, 2f, layerMask) \u0026\u0026 NavMesh.SamplePosition(hitInfo.point \u002B Vector3.up * 0.3f, out var _, 6f, walkableAreaMask))\n\t\t\t{\n\t\t\t\tspawnPositions.Add(hitInfo.point \u002B Vector3.up * 0.1f);\n\t\t\t\tnum2\u002B\u002B;\n\t\t\t\tif (num2 \u003E= count)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum\u002B\u002B;\n\t\t\t\tif (num \u003E count * 2)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !flag;\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnAddVendingOffer(VendingMachine vendingMachine, ProtoBuf.VendingMachine.SellOrder sellOrder)",
    "MethodSignature": "AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)",
    "MethodSourseCode": "\n\tpublic void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)\n\t{\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);\n\t\tItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);\n\t\tif (!(itemDefinition == null) \u0026\u0026 !(itemDefinition2 == null))\n\t\t{\n\t\t\tcurrencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);\n\t\t\titemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);\n\t\t\tProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();\n\t\t\tsellOrder.ShouldPool = false;\n\t\t\tsellOrder.itemToSellID = itemToSellID;\n\t\t\tsellOrder.itemToSellAmount = itemToSellAmount;\n\t\t\tsellOrder.currencyID = currencyToUseID;\n\t\t\tsellOrder.currencyAmountPerItem = currencyAmount;\n\t\t\tsellOrder.currencyIsBP = bpState == 3 || bpState == 2;\n\t\t\tsellOrder.itemToSellIsBP = bpState == 3 || bpState == 1;\n\t\t\tInterface.CallHook(\u0022OnAddVendingOffer\u0022, this, sellOrder);\n\t\t\tsellOrders.sellOrders.Add(sellOrder);\n\t\t\tRefreshSellOrderStockLevel(itemDefinition);\n\t\t\tUpdateMapMarker();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnTurretShutdown(AutoTurret autoTurret)",
    "MethodSignature": "InitiateShutdown()",
    "MethodSourseCode": "\n\tpublic void InitiateShutdown()\n\t{\n\t\tif ((!IsOffline() || booting) \u0026\u0026 Interface.CallHook(\u0022OnTurretShutdown\u0022, this) == null)\n\t\t{\n\t\t\tCancelInvoke(SetOnline);\n\t\t\tbooting = false;\n\t\t\tEffect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\tSetIsOnline(online: false);\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSprayCreate(SprayCan sprayCan, UnityEngine.Vector3 vector, UnityEngine.Quaternion quaternion)",
    "MethodSignature": "CreateSpray(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void CreateSpray(RPCMessage msg)\n\t{\n\t\tif (IsBusy())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_ChangeSprayColour\u0022), -1);\n\t\tSetFlag(Flags.Busy, b: true);\n\t\tInvoke(ClearBusy, SprayCooldown);\n\t\tVector3 vector = msg.read.Vector3();\n\t\tVector3 vector2 = msg.read.Vector3();\n\t\tVector3 point = msg.read.Vector3();\n\t\tint num = msg.read.Int32();\n\t\tif (Vector3.Distance(vector, base.transform.position) \u003E 4.5f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tQuaternion quaternion = Quaternion.LookRotation((new Plane(vector2, vector).ClosestPointOnPlane(point) - vector).normalized, vector2);\n\t\tquaternion *= Quaternion.Euler(0f, 0f, 90f);\n\t\tbool flag = false;\n\t\tif (msg.player.IsDeveloper)\n\t\t{\n\t\t\tflag = true;\n\t\t}\n\t\tif (num != 0 \u0026\u0026 !flag \u0026\u0026 !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))\n\t\t{\n\t\t\tDebug.Log($\u0022SprayCan.ChangeItemSkin player does not have item :{num}:\u0022);\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnSprayCreate\u0022, this, vector, quaternion) == null)\n\t\t{\n\t\t\tulong num2 = ItemDefinition.FindSkin(SprayDecalItem.itemid, num);\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(SprayDecalEntityRef.resourcePath, vector, quaternion);\n\t\t\tbaseEntity.skinID = num2;\n\t\t\tbaseEntity.OnDeployed(null, GetOwnerPlayer(), GetItem());\n\t\t\tbaseEntity.Spawn();\n\t\t\tCheckAchievementPosition(vector);\n\t\t\tif (!base.UsingInfiniteAmmoCheat)\n\t\t\t{\n\t\t\t\tLoseCondition(ConditionLossPerSpray);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SprayCan",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnItemSkinChange(int inventoryId, Item slot, RepairBench repairBench, BasePlayer player)",
    "MethodSignature": "ChangeSkin(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void ChangeSkin(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint inventoryId = msg.read.Int32();\n\t\tItemId itemId = ((msg.read.Unread \u003E 0) ? new ItemId(msg.read.UInt64()) : default(ItemId));\n\t\tbool isValid = itemId.IsValid;\n\t\tbool flag = !isValid || UnityEngine.Time.realtimeSinceStartup \u003E nextSkinChangeAudioTime;\n\t\tItem slot = base.inventory.GetSlot(0);\n\t\tif (slot == null || Interface.CallHook(\u0022OnItemSkinChange\u0022, inventoryId, slot, this, player) != null || (isValid \u0026\u0026 slot.uid != itemId))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag2 = false;\n\t\tif (msg.player.UnlockAllSkins)\n\t\t{\n\t\t\tflag2 = true;\n\t\t}\n\t\tif (inventoryId != 0 \u0026\u0026 !flag2 \u0026\u0026 !player.blueprints.CheckSkinOwnership(inventoryId, player.userID))\n\t\t{\n\t\t\tdebugprint(\u0022RepairBench.ChangeSkin player does not have item :\u0022 \u002B inventoryId \u002B \u0022:\u0022);\n\t\t\treturn;\n\t\t}\n\t\tulong Skin = ItemDefinition.FindSkin(slot.info.itemid, inventoryId);\n\t\tif (Skin == slot.skin \u0026\u0026 slot.info.isRedirectOf == null)\n\t\t{\n\t\t\tdebugprint(\u0022RepairBench.ChangeSkin cannot apply same skin twice : \u0022 \u002B Skin \u002B \u0022: \u0022 \u002B slot.skin);\n\t\t\treturn;\n\t\t}\n\t\tItemSkinDirectory.Skin skin = slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) =\u003E (ulong)x.id == Skin);\n\t\tItemDefinition itemDefinition = slot.info;\n\t\tint num = 0;\n\t\tif (slot.info.isRedirectOf != null)\n\t\t{\n\t\t\tSkin = ItemDefinition.FindSkin(slot.info.isRedirectOf.itemid, inventoryId);\n\t\t\tskin = slot.info.isRedirectOf.skins.FirstOrDefault((ItemSkinDirectory.Skin x) =\u003E (ulong)x.id == Skin);\n\t\t\tif (skin.invItem == null)\n\t\t\t{\n\t\t\t\tif (slot.info.isRedirectOf.skins2.FirstOrDefault((IPlayerItemDefinition x) =\u003E x.DefinitionId == inventoryId) != null)\n\t\t\t\t{\n\t\t\t\t\titemDefinition = slot.info.isRedirectOf;\n\t\t\t\t\tnum = inventoryId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\titemDefinition = slot.info.isRedirectOf;\n\t\t\t\t\tnum = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum = skin.invItem.id;\n\t\t\t\tif (skin.invItem is ItemSkin itemSkin)\n\t\t\t\t{\n\t\t\t\t\tif (itemSkin.Redirect != null)\n\t\t\t\t\t{\n\t\t\t\t\t\titemDefinition = itemSkin.Redirect;\n\t\t\t\t\t\tnum = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (itemSkin.Redirect == null \u0026\u0026 slot.info.isRedirectOf != null)\n\t\t\t\t\t{\n\t\t\t\t\t\titemDefinition = slot.info.isRedirectOf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) =\u003E (ulong)x.id == Skin).invItem is ItemSkin itemSkin2 \u0026\u0026 itemSkin2.Redirect != null)\n\t\t{\n\t\t\titemDefinition = itemSkin2.Redirect;\n\t\t}\n\t\tif (itemDefinition == slot.info \u0026\u0026 itemDefinition.isRedirectOf != null \u0026\u0026 num == 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tnextSkinChangeAudioTime = UnityEngine.Time.realtimeSinceStartup \u002B 0.75f;\n\t\t}\n\t\tif (itemDefinition != slot.info)\n\t\t{\n\t\t\tbool flag3 = false;\n\t\t\tflag3 = num != 0;\n\t\t\tfloat condition = slot.condition;\n\t\t\tfloat maxCondition = slot.maxCondition;\n\t\t\tint amount = slot.amount;\n\t\t\tint ammoCount = 0;\n\t\t\tint num2 = 0;\n\t\t\tItemModContainerArmorSlot component = slot.info.GetComponent\u003CItemModContainerArmorSlot\u003E();\n\t\t\tif (component != null \u0026\u0026 slot.contents != null)\n\t\t\t{\n\t\t\t\tnum2 = slot.contents.capacity;\n\t\t\t}\n\t\t\tItemDefinition ammoType = null;\n\t\t\tif (slot.GetHeldEntity() != null \u0026\u0026 slot.GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)\n\t\t\t{\n\t\t\t\tammoCount = baseProjectile.primaryMagazine.contents;\n\t\t\t\tammoType = baseProjectile.primaryMagazine.ammoType;\n\t\t\t}\n\t\t\tList\u003CItem\u003E obj = Facepunch.Pool.Get\u003CList\u003CItem\u003E\u003E();\n\t\t\tif (slot.contents != null \u0026\u0026 slot.contents.itemList != null \u0026\u0026 slot.contents.itemList.Count \u003E 0)\n\t\t\t{\n\t\t\t\tif (slot.contents.itemList.Count \u003E obj.Capacity)\n\t\t\t\t{\n\t\t\t\t\tobj.Capacity = slot.contents.itemList.Count;\n\t\t\t\t}\n\t\t\t\tforeach (Item item2 in slot.contents.itemList)\n\t\t\t\t{\n\t\t\t\t\tobj.Add(item2);\n\t\t\t\t}\n\t\t\t\tforeach (Item item3 in obj)\n\t\t\t\t{\n\t\t\t\t\titem3.RemoveFromContainer();\n\t\t\t\t}\n\t\t\t}\n\t\t\tItem item = ItemManager.Create(itemDefinition, 1, 0uL);\n\t\t\titem.ownershipShares = slot.ownershipShares;\n\t\t\tslot.ownershipShares = null;\n\t\t\tslot.Remove();\n\t\t\tItemManager.DoRemoves();\n\t\t\titem.MoveToContainer(base.inventory, 0, allowStack: false);\n\t\t\titem.maxCondition = maxCondition;\n\t\t\titem.condition = condition;\n\t\t\titem.amount = amount;\n\t\t\tif (item.GetHeldEntity() != null \u0026\u0026 item.GetHeldEntity() is BaseProjectile baseProjectile2)\n\t\t\t{\n\t\t\t\tif (baseProjectile2.primaryMagazine != null)\n\t\t\t\t{\n\t\t\t\t\tbaseProjectile2.SetAmmoCount(ammoCount);\n\t\t\t\t\tbaseProjectile2.primaryMagazine.ammoType = ammoType;\n\t\t\t\t}\n\t\t\t\tbaseProjectile2.ForceModsChanged();\n\t\t\t}\n\t\t\tif (num2 \u003E 0)\n\t\t\t{\n\t\t\t\tcomponent = item.info.GetComponent\u003CItemModContainerArmorSlot\u003E();\n\t\t\t\tcomponent.CreateAtCapacity(num2, item);\n\t\t\t}\n\t\t\tif (obj.Count \u003E 0 \u0026\u0026 item.contents != null)\n\t\t\t{\n\t\t\t\tif (component != null)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tobj[i]?.MoveToContainer(item.contents, i, allowStack: false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tforeach (Item item4 in obj)\n\t\t\t\t\t{\n\t\t\t\t\t\titem4.MoveToContainer(item.contents);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tFacepunch.Pool.Free(ref obj, freeElements: false);\n\t\t\tif (flag3)\n\t\t\t{\n\t\t\t\tApplySkinToItem(item, Skin);\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, item, Skin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tApplySkinToItem(slot, Skin);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, slot, Skin);\n\t\t}\n\t\tif (flag \u0026\u0026 skinchangeEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(skinchangeEffect.resourcePath, this, 0u, new Vector3(0f, 1.5f, 0f), Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "RepairBench",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnRfFrequencyChanged(PagerEntity pagerEntity, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild() \u0026\u0026 !(UnityEngine.Time.time \u003C nextChangeTime))\n\t\t{\n\t\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: true);\n\t\t\t\tfrequency = num;\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PagerEntity",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnTrapDisarm(Landmine landmine, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_Disarm(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void RPC_Disarm(RPCMessage rpc)\n\t{\n\t\tif ((ulong)rpc.player.userID != triggerPlayerID \u0026\u0026 Armed() \u0026\u0026 Interface.CallHook(\u0022OnTrapDisarm\u0022, this, rpc.player) == null \u0026\u0026 Triggered())\n\t\t{\n\t\t\tif (UnityEngine.Random.Range(0, 100) \u003C 15)\n\t\t\t{\n\t\t\t\tInvoke(TryExplode, 0.05f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSetFlag(Flags.On, b: false);\n\t\t\trpc.player.GiveItem(ItemManager.CreateByName(\u0022trap.landmine\u0022, 1, 0uL), GiveItemReason.PickedUp);\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "Landmine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanSamSiteShoot(SamSite samSite)",
    "MethodSignature": "WeaponTick()",
    "MethodSourseCode": "\n\tpublic void WeaponTick()\n\t{\n\t\tif (IsDead() || UnityEngine.Time.time \u003C lockOnTime || UnityEngine.Time.time \u003C nextBurstTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!IsPowered())\n\t\t{\n\t\t\tfiredCount = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (firedCount \u003E= 6)\n\t\t{\n\t\t\tfloat timeBetweenBursts = mostRecentTargetType.timeBetweenBursts;\n\t\t\tnextBurstTime = UnityEngine.Time.time \u002B timeBetweenBursts;\n\t\t\tfiredCount = 0;\n\t\t\treturn;\n\t\t}\n\t\tEnsureReloaded();\n\t\tif (Interface.CallHook(\u0022CanSamSiteShoot\u0022, this) == null \u0026\u0026 HasAmmo())\n\t\t{\n\t\t\tbool num = ammoItem != null \u0026\u0026 ammoItem.amount == lowAmmoThreshold;\n\t\t\tif (!staticRespawn \u0026\u0026 ammoItem != null)\n\t\t\t{\n\t\t\t\tammoItem.UseItem();\n\t\t\t}\n\t\t\tfiredCount\u002B\u002B;\n\t\t\tfloat speedMultiplier = 1f;\n\t\t\tif (!ObjectEx.IsUnityNull(currentTarget))\n\t\t\t{\n\t\t\t\tspeedMultiplier = currentTarget.SAMTargetType.speedMultiplier;\n\t\t\t}\n\t\t\tFireProjectile(tubes[currentTubeIndex].position, currentAimDir, speedMultiplier);\n\t\t\tEffect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get(\u0022Tube \u0022 \u002B (currentTubeIndex \u002B 1)), Vector3.zero, Vector3.up);\n\t\t\tcurrentTubeIndex\u002B\u002B;\n\t\t\tif (currentTubeIndex \u003E= tubes.Length)\n\t\t\t{\n\t\t\t\tcurrentTubeIndex = 0;\n\t\t\t}\n\t\t\tif (num)\n\t\t\t{\n\t\t\t\tMarkIODirty();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SamSite",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnTeamKick(RelationshipManager.PlayerTeam playerTeam, BasePlayer basePlayer, ulong uLong)",
    "MethodSignature": "kickmember(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void kickmember(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);\n\t\tif (playerTeam != null \u0026\u0026 !(playerTeam.GetLeader() != basePlayer))\n\t\t{\n\t\t\tulong uLong = arg.GetULong(0, 0uL);\n\t\t\tif ((ulong)basePlayer.userID != uLong \u0026\u0026 Interface.CallHook(\u0022OnTeamKick\u0022, playerTeam, basePlayer, uLong) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.RemovePlayer(uLong);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnVendingShopOpen(NPCVendingMachine vendingMachine, BasePlayer msgPlayer)",
    "MethodSignature": "SV_OpenMenu(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void SV_OpenMenu(RPCMessage msg)\n\t{\n\t\tif (vendingMachine == null)\n\t\t{\n\t\t\tvendingMachine = GetComponentInChildren\u003CNPCVendingMachine\u003E();\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnVendingShopOpen\u0022, vendingMachine, msg.player) == null)\n\t\t{\n\t\t\tvendingMachine.OpenShop(msg.player);\n\t\t\tInterface.CallHook(\u0022OnVendingShopOpened\u0022, vendingMachine, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "TravellingVendor",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "CanMoveItem(Item item, PlayerInventory playerInventory, ItemContainerId itemContainerId, int num, int num2, ItemMoveModifier itemMoveModifier)",
    "MethodSignature": "MoveItem(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\t[BaseEntity.RPC_Server.FromOwner(false)]\n\t[BaseEntity.RPC_Server]\n\tpublic void MoveItem(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (base.baseEntity.IsTransferring())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemId id = msg.read.ItemID();\n\t\tItemContainerId itemContainerId = msg.read.ItemContainerID();\n\t\tint num = msg.read.Int8();\n\t\tint num2 = (int)msg.read.UInt32();\n\t\tItemMoveModifier itemMoveModifier = (ItemMoveModifier)msg.read.Int32();\n\t\tItem item = FindItemByUID(id);\n\t\tif (item == null)\n\t\t{\n\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidItem, false);\n\t\t\tConstructionErrors.Log(msg.player, id.ToString());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022CanMoveItem\u0022, item, this, itemContainerId, num, num2, itemMoveModifier) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBaseEntity entityOwner = item.GetEntityOwner();\n\t\t\tif (entityOwner != null \u0026\u0026 entityOwner == msg.player \u0026\u0026 msg.player.IsRestrainedOrSurrendering)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!CanMoveItemsFrom(entityOwner, item))\n\t\t\t{\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.CannotMoveItem, true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (num2 \u003C= 0)\n\t\t\t{\n\t\t\t\tnum2 = item.amount;\n\t\t\t}\n\t\t\tnum2 = Mathf.Clamp(num2, 1, item.MaxStackable());\n\t\t\tif (msg.player.GetActiveItem() == item)\n\t\t\t{\n\t\t\t\tmsg.player.UpdateActiveItem(default(ItemId));\n\t\t\t}\n\t\t\tif (!itemContainerId.IsValid)\n\t\t\t{\n\t\t\t\tBaseEntity baseEntity = entityOwner;\n\t\t\t\tif (loot.containers.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tif (entityOwner == base.baseEntity)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!itemMoveModifier.HasFlag(ItemMoveModifier.Alt))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbaseEntity = loot.entitySource;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseEntity = base.baseEntity;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (baseEntity is IIdealSlotEntity idealSlotEntity)\n\t\t\t\t{\n\t\t\t\t\titemContainerId = idealSlotEntity.GetIdealContainer(base.baseEntity, item, itemMoveModifier);\n\t\t\t\t\tif (itemContainerId == ItemContainerId.Invalid)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tItemContainer parent = item.parent;\n\t\t\t\tif (parent != null \u0026\u0026 parent.IsLocked())\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!itemContainerId.IsValid)\n\t\t\t\t{\n\t\t\t\t\tif (baseEntity == loot.entitySource)\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (ItemContainer container in loot.containers)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!container.PlayerItemInputBlocked() \u0026\u0026 !container.IsLocked() \u0026\u0026 item.MoveToContainer(container, -1, allowStack: true, ignoreStackLimit: false, base.baseEntity))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (!GiveItem(item, itemMoveModifier))\n\t\t\t\t\t{\n\t\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, \u0022GiveItem failed!\u0022, false);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tItemContainer itemContainer = FindContainer(itemContainerId);\n\t\t\tif (itemContainer == null)\n\t\t\t{\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidContainer, false);\n\t\t\t\tConstructionErrors.Log(msg.player, itemContainerId.ToString());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (itemContainer.IsLocked())\n\t\t\t{\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (itemContainer.PlayerItemInputBlocked())\n\t\t\t{\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.DoesntAcceptPlayerItems, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (itemContainer.maxStackSize \u003E 0)\n\t\t\t{\n\t\t\t\tnum2 = Mathf.Clamp(num2, 1, itemContainer.maxStackSize);\n\t\t\t}\n\t\t\tbool allowSwap = !itemContainer.PlayerItemInputBlocked() \u0026\u0026 item.parent != null \u0026\u0026 !item.parent.PlayerItemInputBlocked();\n\t\t\tusing (TimeWarning.New(\u0022Split\u0022))\n\t\t\t{\n\t\t\t\tif (item.amount \u003E num2)\n\t\t\t\t{\n\t\t\t\t\tint split_Amount = num2;\n\t\t\t\t\tItem item2 = item.SplitItem(split_Amount);\n\t\t\t\t\tItem slot = itemContainer.GetSlot(num);\n\t\t\t\t\tif (slot != null \u0026\u0026 !item.CanStack(slot) \u0026\u0026 item.parent != null \u0026\u0026 !item2.MoveToContainer(item.parent, -1, allowStack: false, ignoreStackLimit: false, base.baseEntity, allowSwap: false))\n\t\t\t\t\t{\n\t\t\t\t\t\titem.amount \u002B= item2.amount;\n\t\t\t\t\t\titem2.Remove();\n\t\t\t\t\t\tItemManager.DoRemoves();\n\t\t\t\t\t\tServerUpdate(0f);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (!item2.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity, allowSwap))\n\t\t\t\t\t{\n\t\t\t\t\t\titem.amount \u002B= item2.amount;\n\t\t\t\t\t\titem2.Remove();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\titem.parent.onItemRemovedFromStack?.Invoke(item, num2);\n\t\t\t\t\t}\n\t\t\t\t\tItemManager.DoRemoves();\n\t\t\t\t\tServerUpdate(0f);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (item.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity, allowSwap))\n\t\t\t{\n\t\t\t\tItemManager.DoRemoves();\n\t\t\t\tServerUpdate(0f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnPlayerLand(BasePlayer basePlayer, float num)",
    "MethodSignature": "ApplyFallDamageFromVelocity(float velocity)",
    "MethodSourseCode": "\n\tpublic void ApplyFallDamageFromVelocity(float velocity)\n\t{\n\t\tif (IsGod())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = Mathf.InverseLerp(-15f, -100f, velocity);\n\t\tif (num != 0f \u0026\u0026 Interface.CallHook(\u0022OnPlayerLand\u0022, this, num) == null)\n\t\t{\n\t\t\tfloat num2 = ((modifiers != null) ? Mathf.Clamp01(1f - modifiers.GetValue(Modifier.ModifierType.Clotting)) : 1f);\n\t\t\tmetabolism.bleeding.Add(num * 0.5f * num2);\n\t\t\tfloat num3 = num * 500f;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num3);\n\t\t\tHurt(num3, DamageType.Fall);\n\t\t\tif (num3 \u003E 20f \u0026\u0026 fallDamageEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(fallDamageEffect.resourcePath, base.transform.position, Vector3.zero);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPlayerLanded\u0022, this, num);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnMessagePlayer(string msg, BasePlayer basePlayer)",
    "MethodSignature": "ChatMessage(string msg)",
    "MethodSourseCode": "\n\tpublic void ChatMessage(string msg)\n\t{\n\t\tif (base.isServer \u0026\u0026 Interface.CallHook(\u0022OnMessagePlayer\u0022, msg, this) == null)\n\t\t{\n\t\t\tSendConsoleCommand(\u0022chat.add\u0022, 2, 0, msg);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnScientistRecalled(BradleyAPC bradleyAPC, ScientistNPC scientist)",
    "MethodSignature": "OnScientistMounted(ScientistNPC scientist)",
    "MethodSourseCode": "\n\tpublic void OnScientistMounted(ScientistNPC scientist)\n\t{\n\t\tif (!(scientist == null))\n\t\t{\n\t\t\tif (scientistPrefabLookUp.TryGetValue(scientist.prefabID, out var value))\n\t\t\t{\n\t\t\t\tmountedScientistPrefabs.Add(value);\n\t\t\t}\n\t\t\tactiveScientists.Remove(scientist);\n\t\t\tnumberOfScientistsToSpawn\u002B\u002B;\n\t\t\tInterface.CallHook(\u0022OnScientistRecalled\u0022, this, scientist);\n\t\t}\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "CanBeHomingTargeted(AttackHeliPilotFlare attackHeliPilotFlare)",
    "MethodSignature": "IsValidHomingTarget()",
    "MethodSourseCode": "\n\tpublic bool IsValidHomingTarget()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeHomingTargeted\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "AttackHeliPilotFlare",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCollectiblePickup(CollectibleEntity collectibleEntity, BasePlayer reciever, bool eat)",
    "MethodSignature": "DoPickup(BasePlayer reciever, bool eat)",
    "MethodSourseCode": "\n\tpublic void DoPickup(BasePlayer reciever, bool eat = false)\n\t{\n\t\tif (itemList == null || Interface.CallHook(\u0022OnCollectiblePickup\u0022, this, reciever, eat) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = ((reciever.modifiers != null) ? reciever.modifiers.GetValue(Modifier.ModifierType.Collectible_DoubleYield) : 0f);\n\t\tbool flag = num != 0f \u0026\u0026 UnityEngine.Random.value \u003C num;\n\t\tItemAmount[] array = itemList;\n\t\tforeach (ItemAmount itemAmount in array)\n\t\t{\n\t\t\tif (reciever != null \u0026\u0026 reciever.IsInTutorial \u0026\u0026 itemAmount.ignoreInTutorial)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tItem item = ItemManager.Create(itemAmount.itemDef, flag ? ((int)itemAmount.amount * 2) : ((int)itemAmount.amount), 0uL);\n\t\t\tif (item == null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\titem.SetItemOwnership(reciever, ItemOwnershipPhrases.GatheredPhrase);\n\t\t\tif (eat \u0026\u0026 item.info.category == ItemCategory.Food \u0026\u0026 reciever != null)\n\t\t\t{\n\t\t\t\tItemModConsume component = item.info.GetComponent\u003CItemModConsume\u003E();\n\t\t\t\tif (component != null)\n\t\t\t\t{\n\t\t\t\t\tcomponent.DoAction(item, reciever);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((bool)reciever)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever);\n\t\t\t\tInterface.CallHook(\u0022OnCollectiblePickedup\u0022, this, reciever, item);\n\t\t\t\treciever.GiveItem(item, GiveItemReason.ResourceHarvested);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 0.5f, Vector3.up);\n\t\t\t}\n\t\t}\n\t\titemList = null;\n\t\tif (pickupEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);\n\t\t}\n\t\tRandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find\u003CRandomItemDispenser\u003E(prefabID);\n\t\tif (randomItemDispenser != null)\n\t\t{\n\t\t\trandomItemDispenser.DistributeItems(reciever, base.transform.position);\n\t\t}\n\t\tKill();\n\t}\n",
    "ClassName": "CollectibleEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityDestroy(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "OnDied(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnDied(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntityDestroy\u0022, this) == null)\n\t\t{\n\t\t\tif (!OutOfCrates())\n\t\t\t{\n\t\t\t\tDropCrate();\n\t\t\t}\n\t\t\tbase.OnDied(info);\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnUserApprove(Network.Connection connection)",
    "MethodSignature": "OnNewConnection(Connection connection)",
    "MethodSourseCode": "\n\tpublic void OnNewConnection(Connection connection)\n\t{\n\t\tconnection.connected = false;\n\t\tif (connection.token == null || connection.token.Length \u003C 32)\n\t\t{\n\t\t\tReject(connection, \u0022Invalid Token\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (connection.userid == 0L)\n\t\t{\n\t\t\tReject(connection, \u0022Invalid SteamID\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (connection.protocol != 2594)\n\t\t{\n\t\t\tif (!DeveloperList.Contains(connection.userid))\n\t\t\t{\n\t\t\t\tReject(connection, \u0022Incompatible Version\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022Not kicking \u0022 \u002B connection.userid \u002B \u0022 for incompatible protocol (is a developer)\u0022);\n\t\t}\n\t\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))\n\t\t{\n\t\t\tServerUsers.User user = ServerUsers.Get(connection.userid);\n\t\t\tstring text = user?.notes ?? \u0022no reason given\u0022;\n\t\t\tstring text2 = ((user != null \u0026\u0026 user.expiry \u003E 0) ? (\u0022 for \u0022 \u002B (user.expiry - Epoch.Current).FormatSecondsLong()) : \u0022\u0022);\n\t\t\tReject(connection, \u0022You are banned from this server\u0022 \u002B text2 \u002B \u0022 (\u0022 \u002B text \u002B \u0022)\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))\n\t\t{\n\t\t\tDebugEx.Log(connection.ToString() \u002B \u0022 has auth level 1\u0022);\n\t\t\tconnection.authLevel = 1u;\n\t\t}\n\t\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))\n\t\t{\n\t\t\tDebugEx.Log(connection.ToString() \u002B \u0022 has auth level 2\u0022);\n\t\t\tconnection.authLevel = 2u;\n\t\t}\n\t\tif (DeveloperList.Contains(connection.userid))\n\t\t{\n\t\t\tDebugEx.Log(connection.ToString() \u002B \u0022 is a developer\u0022);\n\t\t\tconnection.authLevel = 3u;\n\t\t}\n\t\tif (Interface.CallHook(\u0022IOnUserApprove\u0022, connection) == null)\n\t\t{\n\t\t\tm_AuthConnection.Add(connection);\n\t\t\tStartCoroutine(AuthorisationRoutine(connection));\n\t\t}\n\t}\n",
    "ClassName": "ConnectionAuth",
    "HookLineInvoke": 46
  },
  {
    "HookSignature": "CanHelicopterStrafeTarget(PatrolHelicopterAI patrolHelicopterAI, BasePlayer ply)",
    "MethodSignature": "ValidRocketTarget(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic bool ValidRocketTarget(BasePlayer ply)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterStrafeTarget\u0022, this, ply);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (ply == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn !ply.IsNearEnemyBase();\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnOvenCook(BaseOven baseOven, Item item)",
    "MethodSignature": "Cook()",
    "MethodSourseCode": "\n\tpublic void Cook()\n\t{\n\t\tif (HasFlag(Flags.Reserved8))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item = FindBurnable();\n\t\tif (Interface.CallHook(\u0022OnOvenCook\u0022, this, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (item == null \u0026\u0026 !CanRunWithNoFuel)\n\t\t{\n\t\t\tStopCooking();\n\t\t\treturn;\n\t\t}\n\t\tforeach (Item item2 in base.inventory.itemList)\n\t\t{\n\t\t\tif (item2.position \u003E= _inputSlotIndex \u0026\u0026 item2.position \u003C _inputSlotIndex \u002B inputSlots \u0026\u0026 !item2.HasFlag(Item.Flag.Cooking))\n\t\t\t{\n\t\t\t\titem2.SetFlag(Item.Flag.Cooking, b: true);\n\t\t\t\titem2.MarkDirty();\n\t\t\t}\n\t\t}\n\t\tIncreaseCookTime(0.5f * GetSmeltingSpeed());\n\t\tBaseEntity slot = GetSlot(Slot.FireMod);\n\t\tif ((bool)slot)\n\t\t{\n\t\t\tslot.SendMessage(\u0022Cook\u0022, 0.5f, SendMessageOptions.DontRequireReceiver);\n\t\t}\n\t\tif (item != null)\n\t\t{\n\t\t\tItemModBurnable itemModBurnable = item.info.ItemModBurnable;\n\t\t\titem.fuel -= 0.5f * (cookingTemperature / 200f);\n\t\t\tif (!item.HasFlag(Item.Flag.OnFire))\n\t\t\t{\n\t\t\t\titem.SetFlag(Item.Flag.OnFire, b: true);\n\t\t\t\titem.MarkDirty();\n\t\t\t}\n\t\t\tif (item.fuel \u003C= 0f)\n\t\t\t{\n\t\t\t\tConsumeFuel(item, itemModBurnable);\n\t\t\t}\n\t\t}\n\t\tOnCooked();\n\t\tInterface.CallHook(\u0022OnOvenCooked\u0022, this, item, slot);\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnWindmillUpdated(ElectricWindmill electricWindmill)",
    "MethodSignature": "WindUpdate()",
    "MethodSourseCode": "\n\tpublic void WindUpdate()\n\t{\n\t\tif (Interface.CallHook(\u0022OnWindmillUpdate\u0022, this) == null)\n\t\t{\n\t\t\tserverWindSpeed = GetWindSpeedScale();\n\t\t\tif (!AmIVisible())\n\t\t\t{\n\t\t\t\tserverWindSpeed = 0f;\n\t\t\t}\n\t\t\tint num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);\n\t\t\tbool num2 = currentEnergy != num;\n\t\t\tcurrentEnergy = num;\n\t\t\tif (num2)\n\t\t\t{\n\t\t\t\tMarkDirty();\n\t\t\t}\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnWindmillUpdated\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "ElectricWindmill",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnTerrainInitialized()",
    "MethodSignature": "PostSetupComponents()",
    "MethodSourseCode": "\n\tpublic void PostSetupComponents()\n\t{\n\t\tTerrainExtension[] components = GetComponents\u003CTerrainExtension\u003E();\n\t\tfor (int i = 0; i \u003C components.Length; i\u002B\u002B)\n\t\t{\n\t\t\tcomponents[i].PostSetup();\n\t\t}\n\t\tInterface.CallHook(\u0022OnTerrainInitialized\u0022);\n\t}\n",
    "ClassName": "TerrainMeta",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnRidableAnimalClaim(RidableHorse ridableHorse, BasePlayer player, Item purchaseToken)",
    "MethodSignature": "SERVER_Claim(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void SERVER_Claim(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 IsForSale)\n\t\t{\n\t\t\tint tokenItemID = msg.read.Int32();\n\t\t\tItem purchaseToken = GetPurchaseToken(player, tokenItemID);\n\t\t\tif (purchaseToken != null \u0026\u0026 Interface.CallHook(\u0022OnRidableAnimalClaim\u0022, this, player, purchaseToken) == null \u0026\u0026 ItemIsSaddle(purchaseToken))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved2, b: false);\n\t\t\t\tOnClaimedWithToken(purchaseToken);\n\t\t\t\tpurchaseToken.UseItem();\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);\n\t\t\t\tAttemptMount(player, doMountChecks: false);\n\t\t\t\tInterface.CallHook(\u0022OnRidableAnimalClaimed\u0022, this, player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RidableHorse",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnEngineStatsRefreshed(VehicleModuleEngine vehicleModuleEngine, Rust.Modular.EngineStorage engineStorage)",
    "MethodSignature": "RefreshPerformanceStats(EngineStorage engineStorage)",
    "MethodSourseCode": "\n\tpublic void RefreshPerformanceStats(EngineStorage engineStorage)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEngineStatsRefresh\u0022, this, engineStorage) == null)\n\t\t{\n\t\t\tif (engineStorage == null)\n\t\t\t{\n\t\t\t\tIsUsable = false;\n\t\t\t\tPerformanceFractionAcceleration = 0f;\n\t\t\t\tPerformanceFractionTopSpeed = 0f;\n\t\t\t\tPerformanceFractionFuelEconomy = 0f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIsUsable = engineStorage.isUsable;\n\t\t\t\tPerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);\n\t\t\t\tPerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);\n\t\t\t\tPerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);\n\t\t\t}\n\t\t\tOverallPerformanceFraction = (PerformanceFractionAcceleration \u002B PerformanceFractionTopSpeed \u002B PerformanceFractionFuelEconomy) / 3f;\n\t\t\tInterface.CallHook(\u0022OnEngineStatsRefreshed\u0022, this, engineStorage);\n\t\t}\n\t}\n",
    "ClassName": "VehicleModuleEngine",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnItemCraft(ItemCraftTask itemCraftTask, BasePlayer owner, Item fromTempBlueprint)",
    "MethodSignature": "CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData, int amount, int skinID, Item fromTempBlueprint, bool free)",
    "MethodSourseCode": "\n\tpublic bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)\n\t{\n\t\tif (owner != null \u0026\u0026 (owner.IsTransferring() || owner.IsSleeping()))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!CanCraft(bp, amount, free))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\ttaskUID\u002B\u002B;\n\t\tItemCraftTask itemCraftTask = Facepunch.Pool.Get\u003CItemCraftTask\u003E();\n\t\titemCraftTask.blueprint = bp;\n\t\tif (!free)\n\t\t{\n\t\t\tCollectIngredients(bp, itemCraftTask, amount, owner, takeBroken: false);\n\t\t}\n\t\titemCraftTask.endTime = 0f;\n\t\titemCraftTask.taskUID = taskUID;\n\t\titemCraftTask.instanceData = instanceData;\n\t\tif (itemCraftTask.instanceData != null)\n\t\t{\n\t\t\titemCraftTask.instanceData.ShouldPool = false;\n\t\t}\n\t\titemCraftTask.amount = amount;\n\t\titemCraftTask.skinID = skinID;\n\t\tif (fromTempBlueprint != null \u0026\u0026 itemCraftTask.takenItems != null)\n\t\t{\n\t\t\tfromTempBlueprint.RemoveFromContainer();\n\t\t\titemCraftTask.takenItems.Add(fromTempBlueprint);\n\t\t\titemCraftTask.conditionScale = 0.5f;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnItemCraft\u0022, itemCraftTask, owner, fromTempBlueprint);\n\t\tif (obj is bool)\n\t\t{\n\t\t\tif (fromTempBlueprint != null \u0026\u0026 itemCraftTask.instanceData != null)\n\t\t\t{\n\t\t\t\tfromTempBlueprint.instanceData = itemCraftTask.instanceData;\n\t\t\t}\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tqueue.AddLast(itemCraftTask);\n\t\tif (owner != null)\n\t\t{\n\t\t\towner.Command(\u0022note.craft_add\u0022, itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "OnInventoryAmmoItemFind(PlayerInventory playerInventory, Rust.AmmoTypes ammoType)",
    "MethodSignature": "FindAmmo(AmmoTypes ammoType)",
    "MethodSourseCode": "\n\tpublic Item FindAmmo(AmmoTypes ammoType)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnInventoryAmmoItemFind\u0022, this, ammoType);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\tItem item = containerMain?.FindAmmo(ammoType);\n\t\tif (item == null)\n\t\t{\n\t\t\titem = containerBelt?.FindAmmo(ammoType);\n\t\t}\n\t\treturn item;\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDoorKnocked(DoorKnocker doorKnocker, BasePlayer player)",
    "MethodSignature": "Knock(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void Knock(BasePlayer player)\n\t{\n\t\tClientRPC(RpcTarget.NetworkGroup(\u0022ClientKnock\u0022), player.transform.position);\n\t\tInterface.CallHook(\u0022OnDoorKnocked\u0022, this, player);\n\t}\n",
    "ClassName": "DoorKnocker",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPortalUsed(BasePlayer player, BasePortal basePortal)",
    "MethodSignature": "UsePortal(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void UsePortal(BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPortalUse\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tLinkPortal();\n\t\tif (targetPortal != null)\n\t\t{\n\t\t\tplayer.PauseFlyHackDetection();\n\t\t\tplayer.PauseSpeedHackDetection();\n\t\t\tplayer.ApplyStallProtection(4f);\n\t\t\tVector3 position = player.transform.position;\n\t\t\tVector3 vector = targetPortal.GetLocalEntryExitPosition();\n\t\t\tVector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());\n\t\t\tVector3 vector3 = vector2;\n\t\t\tif (isMirrored)\n\t\t\t{\n\t\t\t\tVector3 position2 = base.transform.InverseTransformPoint(player.transform.position);\n\t\t\t\tvector = targetPortal.relativeAnchor.transform.TransformPoint(position2);\n\t\t\t\tvector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvector3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;\n\t\t\t}\n\t\t\tif (disappearEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(disappearEffect.resourcePath, position, Vector3.up);\n\t\t\t}\n\t\t\tif (appearEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(appearEffect.resourcePath, vector, Vector3.up);\n\t\t\t}\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022StartLoading_Quick\u0022, player), arg1: true);\n\t\t\tplayer.SetParent(null, worldPositionStays: true);\n\t\t\tplayer.Teleport(vector);\n\t\t\tplayer.ForceUpdateTriggers();\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022ForceViewAnglesTo\u0022, player), vector3);\n\t\t\tif (transitionSoundEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tplayer.UpdateNetworkGroup();\n\t\t\tplayer.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tInterface.CallHook(\u0022OnPortalUsed\u0022, player, this);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebug.Log(\u0022No portal...\u0022);\n\t\t}\n\t}\n",
    "ClassName": "BasePortal",
    "HookLineInvoke": 47
  },
  {
    "HookSignature": "OnEntityLeave(TriggerComfort triggerComfort, BaseEntity ent)",
    "MethodSignature": "OnEntityLeave(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic override void OnEntityLeave(BaseEntity ent)\n\t{\n\t\tif ((ent is BasePlayer || ent is RidableHorse || ent is RidableHorse) \u0026\u0026 Interface.CallHook(\u0022OnEntityLeave\u0022, this, ent) == null)\n\t\t{\n\t\t\t_entities.Remove(ent);\n\t\t}\n\t}\n",
    "ClassName": "TriggerComfort",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanRenameBed(BasePlayer msgPlayer, SleepingBag sleepingBag, string text)",
    "MethodSignature": "Rename(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void Rename(RPCMessage msg)\n\t{\n\t\tif (!msg.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (Interface.CallHook(\u0022CanRenameBed\u0022, msg.player, this, text) == null)\n\t\t{\n\t\t\ttext = WordFilter.Filter(text);\n\t\t\tif (string.IsNullOrEmpty(text))\n\t\t\t{\n\t\t\t\ttext = \u0022Unnamed Sleeping Bag\u0022;\n\t\t\t}\n\t\t\tif (text.Length \u003E 24)\n\t\t\t{\n\t\t\t\ttext = text.Substring(0, 22) \u002B \u0022..\u0022;\n\t\t\t}\n\t\t\tniceName = text;\n\t\t\tSendNetworkUpdate();\n\t\t\tNotifyPlayer(deployerUserID);\n\t\t}\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanBeRecycled(Item item, Recycler recycler)",
    "MethodSignature": "CanBeRecycled(Item item)",
    "MethodSourseCode": "\n\tprivate bool CanBeRecycled(Item item)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeRecycled\u0022, item, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (item != null)\n\t\t{\n\t\t\treturn item.info.Blueprint != null;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnAIBrainStateSwitched(BaseAIBrain baseAIBrain, BaseAIBrain.BasicAIState CurrentState)",
    "MethodSignature": "SwitchToState(BasicAIState newState, int stateContainerID)",
    "MethodSourseCode": "\n\tprivate bool SwitchToState(BasicAIState newState, int stateContainerID = -1)\n\t{\n\t\tif (newState == null || !newState.CanEnter())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (CurrentState != null)\n\t\t{\n\t\t\tif (!CurrentState.CanLeave())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (CurrentState == newState \u0026\u0026 !UseAIDesign)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tobject obj = Interface.CallHook(\u0022OnAIBrainStateSwitch\u0022, this, CurrentState, newState);\n\t\t\tif (obj != null)\n\t\t\t{\n\t\t\t\tif (!(obj is bool))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\tCurrentState.StateLeave(this, GetBaseEntity());\n\t\t}\n\t\tAddEvents(stateContainerID);\n\t\tCurrentState = newState;\n\t\tCurrentState.StateEnter(this, GetBaseEntity());\n\t\tcurrentStateContainerID = stateContainerID;\n\t\tInterface.CallHook(\u0022OnAIBrainStateSwitched\u0022, this, CurrentState);\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseAIBrain",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnPlayerInput(BasePlayer basePlayer, InputState serverInput)",
    "MethodSignature": "OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)",
    "MethodSourseCode": "\n\tprivate void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)\n\t{\n\t\tif (msg.inputState != null)\n\t\t{\n\t\t\tserverInput.Flip(msg.inputState);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerTick\u0022, this, msg, wasPlayerStalled) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (serverInput.current.buttons != serverInput.previous.buttons)\n\t\t{\n\t\t\tResetInputIdleTime();\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerInput\u0022, this, serverInput) != null || IsReceivingSnapshot)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (IsSpectating())\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022Tick_Spectator\u0022))\n\t\t\t{\n\t\t\t\tTick_Spectator();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (IsSleeping())\n\t\t{\n\t\t\tif (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))\n\t\t\t{\n\t\t\t\tEndSleeping();\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t}\n\t\t\tUpdateActiveItem(default(ItemId));\n\t\t\treturn;\n\t\t}\n\t\tif (IsRestrained \u0026\u0026 restraintItemId.HasValue \u0026\u0026 restraintItemId.HasValue)\n\t\t{\n\t\t\tUpdateActiveItem(restraintItemId.Value);\n\t\t}\n\t\telse if (!Belt.CanHoldItem())\n\t\t{\n\t\t\tUpdateActiveItem(default(ItemId));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUpdateActiveItem(msg.activeItem);\n\t\t}\n\t\tUpdateModelStateFromTick(msg);\n\t\tif (float.IsNaN(modelState.ducking) || float.IsInfinity(modelState.ducking))\n\t\t{\n\t\t\tKick(\u0022Kicked: invalid modelstate\u0022);\n\t\t\treturn;\n\t\t}\n\t\tmodelState.ducking = Mathf.Clamp01(modelState.ducking);\n\t\tif (IsIncapacitated())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tForwardReceiveTickToListeners(msg);\n\t\tif (isMounted)\n\t\t{\n\t\t\tGetMounted().PlayerServerInput(serverInput, this);\n\t\t}\n\t\tUpdatePositionFromTick(msg, wasPlayerStalled);\n\t\tUpdateRotationFromTick(msg);\n\t\tint activeMission = GetActiveMission();\n\t\tif (activeMission \u003E= 0 \u0026\u0026 activeMission \u003C missions.Count)\n\t\t{\n\t\t\tBaseMission.MissionInstance missionInstance = missions[activeMission];\n\t\t\tif (missionInstance.status == BaseMission.MissionStatus.Active \u0026\u0026 missionInstance.NeedsPlayerInput())\n\t\t\t{\n\t\t\t\tProcessMissionEvent(BaseMission.MissionEventType.PLAYER_TICK, net.ID, 0f);\n\t\t\t}\n\t\t}\n\t\tif (!TutorialIsland.EnforceTrespassChecks || IsAdmin || IsNpc || net == null || net.group == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (net.group.restricted)\n\t\t{\n\t\t\tbool flag = false;\n\t\t\tif (!IsInTutorial)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tTutorialIsland currentTutorialIsland = GetCurrentTutorialIsland();\n\t\t\t\tif (currentTutorialIsland == null || currentTutorialIsland.net.group != net.group)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\ttutorialKickTime \u002B= UnityEngine.Time.deltaTime;\n\t\t\t\tif (tutorialKickTime \u003E 3f)\n\t\t\t\t{\n\t\t\t\t\tDebug.LogWarning($\u0022Killing player {displayName}/{userID.Get()} as they are on a tutorial island that doesn\u0027t belong them\u0022);\n\t\t\t\t\tHurt(999f);\n\t\t\t\t\ttutorialKickTime = 0f;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttutorialKickTime = 0f;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!IsInTutorial || net.group.restricted)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbool flag2 = false;\n\t\t\tTutorialIsland currentTutorialIsland2 = GetCurrentTutorialIsland();\n\t\t\tif (currentTutorialIsland2 == null || currentTutorialIsland2.net.group != net.group)\n\t\t\t{\n\t\t\t\tflag2 = true;\n\t\t\t}\n\t\t\tif (flag2)\n\t\t\t{\n\t\t\t\ttutorialKickTime \u002B= UnityEngine.Time.deltaTime;\n\t\t\t\tif (tutorialKickTime \u003E 3f)\n\t\t\t\t{\n\t\t\t\t\tDebug.LogWarning($\u0022Killing player {displayName}/{userID.Get()} as they are no longer on a tutorial island and are marked as being in a tutorial\u0022);\n\t\t\t\t\tHurt(999f);\n\t\t\t\t\ttutorialKickTime = 0f;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttutorialKickTime = 0f;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnCrateLanded(HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "LandCheck()",
    "MethodSourseCode": "\n\tpublic void LandCheck()\n\t{\n\t\tRaycastHit hitInfo;\n\t\tif (hasLanded)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnCrateLanded\u0022, this);\n\t\t}\n\t\telse if (UnityEngine.Physics.Raycast(new Ray(base.transform.position \u002B Vector3.up * 0.5f, Vector3.down), out hitInfo, 1f, 1084293377))\n\t\t{\n\t\t\tEffect.server.Run(landEffect.resourcePath, hitInfo.point, Vector3.up);\n\t\t\thasLanded = true;\n\t\t\tCancelInvoke(LandCheck);\n\t\t}\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanUnlockTechTreeNodePath(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTreeData)",
    "MethodSignature": "PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)",
    "MethodSourseCode": "\n\tpublic bool PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUnlockTechTreeNodePath\u0022, player, node, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tNodeInstance entryNode = GetEntryNode();\n\t\tif (entryNode == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn CheckChainRecursive(player, entryNode, node);\n\t}\n",
    "ClassName": "TechTreeData",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnConstructionPlace(BaseEntity baseEntity, Construction component, Construction.Target placement, BasePlayer ownerPlayer)",
    "MethodSignature": "DoPlacement(Construction.Target placement, Construction component)",
    "MethodSourseCode": "\n\tpublic GameObject DoPlacement(Construction.Target placement, Construction component)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tBaseEntity baseEntity = component.CreateConstruction(placement, bNeedsValidPlacement: true);\n\t\tif (!baseEntity)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tfloat num = 1f;\n\t\tfloat num2 = 0f;\n\t\tItem ownerItem = GetOwnerItem();\n\t\tif (ownerItem != null)\n\t\t{\n\t\t\tbaseEntity.skinID = ownerItem.skin;\n\t\t\tif (ownerItem.hasCondition)\n\t\t\t{\n\t\t\t\tnum = ownerItem.conditionNormalized;\n\t\t\t}\n\t\t}\n\t\tPoolableEx.AwakeFromInstantiate(baseEntity.gameObject);\n\t\tBuildingBlock buildingBlock = baseEntity as BuildingBlock;\n\t\tif ((bool)buildingBlock)\n\t\t{\n\t\t\tbuildingBlock.blockDefinition = PrefabAttribute.server.Find\u003CConstruction\u003E(buildingBlock.prefabID);\n\t\t\tif (!buildingBlock.blockDefinition)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022Placing a building block that has no block definition!\u0022);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbuildingBlock.SetGrade(buildingBlock.blockDefinition.defaultGrade.gradeBase.type);\n\t\t}\n\t\tBaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;\n\t\tif ((bool)baseCombatEntity)\n\t\t{\n\t\t\tnum2 = ((buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth);\n\t\t\tbaseCombatEntity.ResetLifeStateOnSpawn = false;\n\t\t\tbaseCombatEntity.InitializeHealth(num2 * num, baseCombatEntity.StartMaxHealth());\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnConstructionPlace\u0022, baseEntity, component, placement, ownerPlayer) != null)\n\t\t{\n\t\t\tif (baseEntity.IsValid())\n\t\t\t{\n\t\t\t\tbaseEntity.KillMessage();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDecayEntity decayEntity = baseEntity as DecayEntity;\n\t\t\t\tif ((bool)decayEntity)\n\t\t\t\t{\n\t\t\t\t\tdecayEntity.DoServerDestroy();\n\t\t\t\t}\n\t\t\t\tbaseEntity.TerminateOnServer();\n\t\t\t\tbaseEntity.EntityDestroy();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tbaseEntity.OnPlaced(ownerPlayer);\n\t\tbaseEntity.OwnerID = ownerPlayer.userID;\n\t\tbaseEntity.Spawn();\n\t\tif ((bool)buildingBlock)\n\t\t{\n\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/build/frame_place.prefab\u0022, baseEntity, 0u, Vector3.zero, Vector3.zero);\n\t\t}\n\t\tStabilityEntity stabilityEntity = baseEntity as StabilityEntity;\n\t\tif ((bool)stabilityEntity)\n\t\t{\n\t\t\tstabilityEntity.UpdateSurroundingEntities();\n\t\t}\n\t\treturn baseEntity.gameObject;\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 43
  },
  {
    "HookSignature": "OnDefaultItemsReceived(PlayerInventory playerInventory)",
    "MethodSignature": "GiveDefaultItems()",
    "MethodSourseCode": "\n\tpublic void GiveDefaultItems()\n\t{\n\t\tif (Interface.CallHook(\u0022OnDefaultItemsReceive\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tStrip();\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif (activeGameMode != null \u0026\u0026 activeGameMode.HasLoadouts())\n\t\t{\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);\n\t\t\treturn;\n\t\t}\n\t\tGiveDefaultItemWithSkin(\u0022client.rockskin\u0022, \u0022rock\u0022);\n\t\tGiveDefaultItemWithSkin(\u0022client.torchskin\u0022, \u0022torch\u0022);\n\t\tif (IsBirthday() \u0026\u0026 !base.baseEntity.IsInTutorial)\n\t\t{\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022cakefiveyear\u0022, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022partyhat\u0022, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerWear);\n\t\t}\n\t\tif (IsChristmas() \u0026\u0026 !base.baseEntity.IsInTutorial)\n\t\t{\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\n\t\t}\n\t\tInterface.CallHook(\u0022OnDefaultItemsReceived\u0022, this);\n\t\tvoid GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)\n\t\t{\n\t\t\tulong num = 0uL;\n\t\t\tint infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);\n\t\t\tbool flag = false;\n\t\t\tbool flag2 = false;\n\t\t\tflag2 = base.baseEntity?.UnlockAllSkins ?? false;\n\t\t\tif (infoInt \u003E 0 \u0026\u0026 (base.baseEntity.blueprints.CheckSkinOwnership(infoInt, base.baseEntity.userID) || flag2))\n\t\t\t{\n\t\t\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);\n\t\t\t\tif (itemDefinition != null \u0026\u0026 ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)\n\t\t\t\t{\n\t\t\t\t\tIPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);\n\t\t\t\t\tif (itemDefinition2 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum = itemDefinition2.WorkshopDownload;\n\t\t\t\t\t}\n\t\t\t\t\tif (num == 0L \u0026\u0026 itemDefinition.skins != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tItemSkinDirectory.Skin[] skins = itemDefinition.skins;\n\t\t\t\t\t\tfor (int i = 0; i \u003C skins.Length; i\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tItemSkinDirectory.Skin skin = skins[i];\n\t\t\t\t\t\t\tif (skin.id == infoInt \u0026\u0026 skin.invItem != null \u0026\u0026 skin.invItem is ItemSkin itemSkin \u0026\u0026 itemSkin.Redirect != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tGiveItem(ItemManager.CreateByName(itemShortName, 1, num).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnVehicleModulesAssigned(ModularCar modularCar, Rust.Modular.ItemModVehicleModule[] modularCarPresetConfigSocketItemDefs)",
    "MethodSignature": "SpawnPreassignedModules()",
    "MethodSourseCode": "\n\tpublic void SpawnPreassignedModules()\n\t{\n\t\tif (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];\n\t\tif (Interface.CallHook(\u0022OnVehicleModulesAssign\u0022, this, modularCarPresetConfig.socketItemDefs) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C modularCarPresetConfig.socketItemDefs.Length; i\u002B\u002B)\n\t\t{\n\t\t\tItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];\n\t\t\tif (itemModVehicleModule != null \u0026\u0026 base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(itemModVehicleModule.GetComponent\u003CItemDefinition\u003E(), 1, 0uL);\n\t\t\t\tfloat num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);\n\t\t\t\titem.condition = item.maxCondition * num;\n\t\t\t\tif (!TryAddModule(item))\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnVehicleModulesAssigned\u0022, this, modularCarPresetConfig.socketItemDefs);\n\t\tInvoke(HandleAdminBonus, 0f);\n\t}\n",
    "ClassName": "ModularCar",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "OnTurretStartup(AutoTurret autoTurret)",
    "MethodSignature": "InitiateStartup()",
    "MethodSourseCode": "\n\tpublic void InitiateStartup()\n\t{\n\t\tif (!IsOnline() \u0026\u0026 !booting \u0026\u0026 Interface.CallHook(\u0022OnTurretStartup\u0022, this) == null)\n\t\t{\n\t\t\tEffect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\tInvoke(SetOnline, 2f);\n\t\t\tbooting = true;\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerAddModifiers(BasePlayer player, Item item, ItemModConsumable consumable)",
    "MethodSignature": "DoAction(Item item, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void DoAction(Item item, BasePlayer player)\n\t{\n\t\tif (item.amount \u003C 1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tGameObjectRef gameObjectRef = GetConsumeEffect();\n\t\tif (gameObjectRef.isValid)\n\t\t{\n\t\t\tVector3 posLocal = (player.IsDucked() ? new Vector3(0f, 1f, 0f) : new Vector3(0f, 2f, 0f));\n\t\t\tEffect.server.Run(gameObjectRef.resourcePath, player, 0u, posLocal, Vector3.zero);\n\t\t}\n\t\tplayer.metabolism.MarkConsumption();\n\t\tItemModConsumable consumable = GetConsumable();\n\t\tif (!string.IsNullOrEmpty(consumable.achievementWhenEaten))\n\t\t{\n\t\t\tplayer.GiveAchievement(consumable.achievementWhenEaten);\n\t\t}\n\t\tFacepunch.Rust.Analytics.Azure.OnConsumableUsed(player, item);\n\t\tfloat num = Mathf.Max(consumable.amountToConsume, 1);\n\t\tfloat num2 = Mathf.Min(item.amount, num);\n\t\tfloat num3 = num2 / num;\n\t\tfloat num4 = item.conditionNormalized;\n\t\tif (consumable.conditionFractionToLose \u003E 0f)\n\t\t{\n\t\t\tnum4 = consumable.conditionFractionToLose;\n\t\t}\n\t\tforeach (ItemModConsumable.ConsumableEffect effect in consumable.effects)\n\t\t{\n\t\t\tif (Mathf.Clamp01(player.healthFraction \u002B player.metabolism.pending_health.Fraction()) \u003E effect.onlyIfHealthLessThan)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (effect.type == MetabolismAttribute.Type.Health)\n\t\t\t{\n\t\t\t\tif (effect.amount \u003C 0f)\n\t\t\t\t{\n\t\t\t\t\tplayer.OnAttacked(new HitInfo(player, player, DamageType.Generic, (0f - effect.amount) * num3 * num4, player.transform.position \u002B player.transform.forward * 1f));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplayer.health \u002B= effect.amount * num3 * num4;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount * num3 * num4, effect.time * num3 * num4);\n\t\t\t}\n\t\t}\n\t\tplayer.ProcessMissionEvent(BaseMission.MissionEventType.CONSUME, item.info.itemid, 1f);\n\t\tif (player.modifiers != null \u0026\u0026 Interface.CallHook(\u0022OnPlayerAddModifiers\u0022, player, item, consumable) == null)\n\t\t{\n\t\t\tplayer.modifiers.Add(consumable.modifiers);\n\t\t}\n\t\tif (product != null)\n\t\t{\n\t\t\tItemAmountRandom[] array = product;\n\t\t\tforeach (ItemAmountRandom itemAmountRandom in array)\n\t\t\t{\n\t\t\t\tint num5 = Mathf.RoundToInt((float)itemAmountRandom.RandomAmount() * num4);\n\t\t\t\tif (num5 \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tItem item2 = ItemManager.Create(itemAmountRandom.itemDef, num5, 0uL);\n\t\t\t\t\tplayer.GiveItem(item2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (string.IsNullOrEmpty(eatGesture))\n\t\t{\n\t\t\tplayer.SignalBroadcast(BaseEntity.Signal.Gesture, eatGesture);\n\t\t}\n\t\tif (consumable.conditionFractionToLose \u003E 0f)\n\t\t{\n\t\t\titem.LoseCondition(consumable.conditionFractionToLose * item.maxCondition);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem.UseItem((int)num2);\n\t\t}\n\t}\n",
    "ClassName": "ItemModConsume",
    "HookLineInvoke": 51
  },
  {
    "HookSignature": "CanBeHomingTargeted(BaseHelicopter baseHelicopter)",
    "MethodSignature": "IsValidHomingTarget()",
    "MethodSourseCode": "\n\tpublic virtual bool IsValidHomingTarget()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeHomingTargeted\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseHelicopter",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "ICanPickupEntity(BasePlayer rpcPlayer, DoorCloser doorCloser)",
    "MethodSignature": "RPC_Take(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void RPC_Take(RPCMessage rpc)\n\t{\n\t\tif (Interface.CallHook(\u0022ICanPickupEntity\u0022, rpc.player, this) != null || !rpc.player.CanInteract() || !rpc.player.CanBuild())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDoor door = GetDoor();\n\t\tif (!(door == null) \u0026\u0026 door.GetPlayerLockPermission(rpc.player))\n\t\t{\n\t\t\tItem item = ItemManager.Create(itemType, 1, skinID);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\trpc.player.GiveItem(item);\n\t\t\t}\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "DoorCloser",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnSendCommand(System.Collections.Generic.List\u003CNetwork.Connection\u003E cn, string strCommand, object[] args)",
    "MethodSignature": "SendClientCommand(List\u003CConnection\u003E cn, string strCommand, object[] args)",
    "MethodSourseCode": "\n\tpublic static void SendClientCommand(List\u003CConnection\u003E cn, string strCommand, params object[] args)\n\t{\n\t\tif (Network.Net.sv.IsConnected() \u0026\u0026 Interface.CallHook(\u0022OnSendCommand\u0022, cn, strCommand, args) == null)\n\t\t{\n\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\tnetWrite.PacketID(Message.Type.ConsoleCommand);\n\t\t\tnetWrite.String(ConsoleSystem.BuildCommand(strCommand, args));\n\t\t\tnetWrite.Send(new SendInfo(cn));\n\t\t}\n\t}\n",
    "ClassName": "ConsoleNetwork",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)",
    "MethodSignature": "DoBuild(Construction.Target target, Construction component)",
    "MethodSourseCode": "\n\tpublic virtual BaseEntity DoBuild(Construction.Target target, Construction component)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tif (RayEx.IsNaNOrInfinity(target.ray))\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tif (target.position.IsNaNOrInfinity())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tif (target.normal.IsNaNOrInfinity())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tConstruction.lastPlacementError = \u0022\u0022;\n\t\tConstruction.lastPlacementErrorDebug = \u0022\u0022;\n\t\tConstruction.lastBuildingBlockError = null;\n\t\tConstruction.lastPlacementErrorIsDetailed = false;\n\t\tif (target.socket != null)\n\t\t{\n\t\t\tif (!target.socket.female)\n\t\t\t{\n\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.SocketNotFemale, false);\n\t\t\t\tConstruction.lastPlacementErrorDebug = target.socket.socketName;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (target.entity != null \u0026\u0026 target.entity.IsOccupied(target.socket))\n\t\t\t{\n\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.SocketOccupied, false);\n\t\t\t\tConstruction.lastPlacementErrorDebug = target.socket.socketName;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (target.onTerrain)\n\t\t\t{\n\t\t\t\tConstruction.lastPlacementErrorDebug = \u0022Target on terrain is not allowed when attaching to socket (\u0022 \u002B target.socket.socketName \u002B \u0022)\u0022;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tVector3 deployPos = ((target.entity != null \u0026\u0026 target.socket != null) ? target.GetWorldPosition() : target.position);\n\t\tif (AntiHack.TestIsBuildingInsideSomething(target, deployPos))\n\t\t{\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.InsideObjects, false);\n\t\t\treturn null;\n\t\t}\n\t\tif (ConVar.AntiHack.eye_protection \u003E= 2 \u0026\u0026 !component.HasAlternativeLOSChecks() \u0026\u0026 !HasLineOfSight(ownerPlayer, deployPos, target, component))\n\t\t{\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.LineOfSightBlocked, false);\n\t\t\treturn null;\n\t\t}\n\t\tif (ConVar.Server.max_sleeping_bags \u003E 0)\n\t\t{\n\t\t\tCanBuildResult? result = SleepingBag.CanBuildBed(ownerPlayer, component);\n\t\t\tif (HandleCanBuild(result, ownerPlayer))\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tGameObject gameObject = DoPlacement(target, component);\n\t\tif (gameObject == null)\n\t\t{\n\t\t\tif (!string.IsNullOrEmpty(Construction.lastPlacementError.translated))\n\t\t\t{\n\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, Construction.lastPlacementError, false);\n\t\t\t}\n\t\t\tConstructionErrors.Log(ownerPlayer, Construction.lastPlacementErrorDebug);\n\t\t}\n\t\tif (gameObject != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnEntityBuilt\u0022, this, gameObject);\n\t\t\tDeployable deployable = GetDeployable();\n\t\t\tBaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);\n\t\t\tif (baseEntity != null \u0026\u0026 deployable != null)\n\t\t\t{\n\t\t\t\tif (ShouldParent(target.entity, deployable))\n\t\t\t\t{\n\t\t\t\t\tif (target.socket is Socket_Specific_Female socket_Specific_Female)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (socket_Specific_Female.parentToBone)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbaseEntity.SetParent(target.entity, socket_Specific_Female.boneName, worldPositionStays: true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbaseEntity.SetParent(target.entity, worldPositionStays: true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseEntity.SetParent(target.entity, worldPositionStays: true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (deployable.wantsInstanceData \u0026\u0026 GetOwnerItem().instanceData != null)\n\t\t\t\t{\n\t\t\t\t\t(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);\n\t\t\t\t}\n\t\t\t\tif (deployable.copyInventoryFromItem)\n\t\t\t\t{\n\t\t\t\t\tStorageContainer component2 = baseEntity.GetComponent\u003CStorageContainer\u003E();\n\t\t\t\t\tif ((bool)component2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcomponent2.ReceiveInventoryFromItem(GetOwnerItem());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tItemModDeployable modDeployable = GetModDeployable();\n\t\t\t\tif (modDeployable != null)\n\t\t\t\t{\n\t\t\t\t\tmodDeployable.OnDeployed(baseEntity, ownerPlayer);\n\t\t\t\t}\n\t\t\t\tbaseEntity.OnDeployed(baseEntity.GetParentEntity(), ownerPlayer, GetOwnerItem());\n\t\t\t\tif (deployable.placeEffect.isValid)\n\t\t\t\t{\n\t\t\t\t\tif ((bool)target.entity \u0026\u0026 target.socket != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, target.entity.transform.TransformPoint(target.socket.worldPosition), target.entity.transform.up);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, target.position, target.normal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (baseEntity != null)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);\n\t\t\t\tif (GetOwnerItemDefinition() != null)\n\t\t\t\t{\n\t\t\t\t\townerPlayer.ProcessMissionEvent(BaseMission.MissionEventType.DEPLOY, new BaseMission.MissionEventPayload\n\t\t\t\t\t{\n\t\t\t\t\t\tWorldPosition = baseEntity.transform.position,\n\t\t\t\t\t\tUintIdentifier = baseEntity.prefabID,\n\t\t\t\t\t\tIntIdentifier = GetOwnerItemDefinition().itemid\n\t\t\t\t\t}, 1f);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPayForPlacement(ownerPlayer, component);\n\t\t\treturn baseEntity;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 74
  },
  {
    "HookSignature": "OnCCTVDirectionChange(CCTV_RC cCTV_RC, BasePlayer player)",
    "MethodSignature": "Server_SetDir(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void Server_SetDir(RPCMessage msg)\n\t{\n\t\tif (!IsStatic())\n\t\t{\n\t\t\tBasePlayer player = msg.player;\n\t\t\tif (player.CanBuild() \u0026\u0026 player.IsBuildingAuthed() \u0026\u0026 Interface.CallHook(\u0022OnCCTVDirectionChange\u0022, this, player) == null)\n\t\t\t{\n\t\t\t\tVector3 direction = Vector3Ex.Direction(player.eyes.position, yaw.transform.position);\n\t\t\t\tdirection = base.transform.InverseTransformDirection(direction);\n\t\t\t\tVector3 vector = BaseMountable.ConvertVector(Quaternion.LookRotation(direction).eulerAngles);\n\t\t\t\tpitchAmount = Mathf.Clamp(vector.x, pitchClamp.x, pitchClamp.y);\n\t\t\t\tyawAmount = Mathf.Clamp(vector.y, yawClamp.x, yawClamp.y);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CCTV_RC",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnNearbyTurretsScan(AutoTurret autoTurret, System.Collections.Generic.List\u003CAutoTurret\u003E obj, bool created)",
    "MethodSignature": "UpdateNearbyTurrets(bool created)",
    "MethodSourseCode": "\n\tpublic void UpdateNearbyTurrets(bool created)\n\t{\n\t\tList\u003CAutoTurret\u003E obj = Facepunch.Pool.Get\u003CList\u003CAutoTurret\u003E\u003E();\n\t\tif (Interface.CallHook(\u0022OnNearbyTurretsScan\u0022, this, obj, created) == null)\n\t\t{\n\t\t\tVis.Entities(base.transform.position, Sentry.interferenceradius, obj, 256, QueryTriggerInteraction.Ignore);\n\t\t}\n\t\tforeach (AutoTurret item in obj)\n\t\t{\n\t\t\tif (!(item == this))\n\t\t\t{\n\t\t\t\tif (created)\n\t\t\t\t{\n\t\t\t\t\tnearbyTurrets.Add(item);\n\t\t\t\t\titem.nearbyTurrets.Add(this);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\titem.nearbyTurrets.Remove(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!created)\n\t\t{\n\t\t\tnearbyTurrets.Clear();\n\t\t}\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnTeamAcceptInvite(RelationshipManager.PlayerTeam playerTeam, BasePlayer basePlayer)",
    "MethodSignature": "acceptinvite(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void acceptinvite(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (!(basePlayer == null) \u0026\u0026 basePlayer.currentTeam == 0L)\n\t\t{\n\t\t\tulong uLong = arg.GetULong(0, 0uL);\n\t\t\tPlayerTeam playerTeam = ServerInstance.FindTeam(uLong);\n\t\t\tif (playerTeam == null)\n\t\t\t{\n\t\t\t\tbasePlayer.ClearPendingInvite();\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnTeamAcceptInvite\u0022, playerTeam, basePlayer) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.AcceptInvite(basePlayer);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnPhoneAnswer(PhoneController phoneController, PhoneController activeCallTo)",
    "MethodSignature": "AnswerPhone(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void AnswerPhone(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (IsInvoking(TimeOutDialing))\n\t\t{\n\t\t\tCancelInvoke(TimeOutDialing);\n\t\t}\n\t\tif (!(activeCallTo == null))\n\t\t{\n\t\t\tBasePlayer player = msg.player;\n\t\t\tif (Interface.CallHook(\u0022OnPhoneAnswer\u0022, this, activeCallTo) == null)\n\t\t\t{\n\t\t\t\tUpdateServerPlayer(player);\n\t\t\t\tBeginCall();\n\t\t\t\tactiveCallTo.BeginCall();\n\t\t\t\tInterface.CallHook(\u0022OnPhoneAnswered\u0022, this, activeCallTo);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnEntityReskin(BaseEntity baseEntity2, ItemSkinDirectory.Skin skin, BasePlayer msgPlayer)",
    "MethodSignature": "ChangeItemSkin(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(2uL)]\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void ChangeItemSkin(RPCMessage msg)\n\t{\n\t\tNetworkableId uid = msg.read.EntityID();\n\t\tint targetSkin = msg.read.Int32();\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);\n\t\tif (!ValidateEntityAndSkin(msg.player, baseNetworkable, targetSkin))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (baseNetworkable != null)\n\t\t{\n\t\t\tBaseEntity baseEntity2 = baseNetworkable as BaseEntity;\n\t\t\tif ((object)baseEntity2 != null)\n\t\t\t{\n\t\t\t\tif (!GetItemDefinitionForEntity(baseEntity2, out var def, useRedirect: false))\n\t\t\t\t{\n\t\t\t\t\tFailResponse(SprayFailReason.InvalidItem);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tItemDefinition itemDefinition = null;\n\t\t\t\tulong num = ItemDefinition.FindSkin((def.isRedirectOf != null) ? def.isRedirectOf.itemid : def.itemid, targetSkin);\n\t\t\t\tItemSkinDirectory.Skin skin = ((def.isRedirectOf != null) ? def.isRedirectOf : def).skins.FirstOrDefault((ItemSkinDirectory.Skin x) =\u003E x.id == targetSkin);\n\t\t\t\tif (Interface.CallHook(\u0022OnEntityReskin\u0022, baseEntity2, skin, msg.player) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (skin.invItem != null \u0026\u0026 skin.invItem is ItemSkin itemSkin)\n\t\t\t\t{\n\t\t\t\t\tif (itemSkin.Redirect != null)\n\t\t\t\t\t{\n\t\t\t\t\t\titemDefinition = itemSkin.Redirect;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bool)def \u0026\u0026 def.isRedirectOf != null)\n\t\t\t\t\t{\n\t\t\t\t\t\titemDefinition = def.isRedirectOf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (def.isRedirectOf != null || ((bool)def \u0026\u0026 def.isRedirectOf != null))\n\t\t\t\t{\n\t\t\t\t\titemDefinition = def.isRedirectOf;\n\t\t\t\t}\n\t\t\t\tif (itemDefinition == null)\n\t\t\t\t{\n\t\t\t\t\tbaseEntity2.skinID = num;\n\t\t\t\t\tbaseEntity2.SendNetworkUpdate();\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!CanEntityBeRespawned(baseEntity2, out var reason2))\n\t\t\t\t\t{\n\t\t\t\t\t\tFailResponse(reason2);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (!GetEntityPrefabPath(itemDefinition, out var resourcePath))\n\t\t\t\t\t{\n\t\t\t\t\t\tDebug.LogWarning(\u0022Cannot find resource path of redirect entity to spawn! \u0022 \u002B itemDefinition.gameObject.name);\n\t\t\t\t\t\tFailResponse(SprayFailReason.InvalidItem);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (global::SimpleUpgrade.IsUpgradeBlocked(baseEntity2, itemDefinition, msg.player))\n\t\t\t\t\t{\n\t\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, BlockedByPlayer, false);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tCodeLockPreserveInfo codeLockPreserveInfo = default(CodeLockPreserveInfo);\n\t\t\t\t\tif (baseEntity2 is CodeLock codeLock)\n\t\t\t\t\t{\n\t\t\t\t\t\tcodeLockPreserveInfo.code = codeLock.code;\n\t\t\t\t\t\tcodeLockPreserveInfo.guestCode = codeLock.guestCode;\n\t\t\t\t\t\tcodeLockPreserveInfo.isLocked = codeLock.IsLocked();\n\t\t\t\t\t\tcodeLockPreserveInfo.whitelistPlayers = Facepunch.Pool.Get\u003CList\u003Culong\u003E\u003E();\n\t\t\t\t\t\tcodeLockPreserveInfo.guestPlayers = Facepunch.Pool.Get\u003CList\u003Culong\u003E\u003E();\n\t\t\t\t\t\tcodeLockPreserveInfo.whitelistPlayers.AddRange(codeLock.whitelistPlayers);\n\t\t\t\t\t\tcodeLockPreserveInfo.guestPlayers.AddRange(codeLock.guestPlayers);\n\t\t\t\t\t}\n\t\t\t\t\tVector3 localPosition = baseEntity2.transform.localPosition;\n\t\t\t\t\tQuaternion localRotation = baseEntity2.transform.localRotation;\n\t\t\t\t\tBaseEntity baseEntity3 = baseEntity2.GetParentEntity();\n\t\t\t\t\tfloat health = baseEntity2.Health();\n\t\t\t\t\tEntityRef[] slots = baseEntity2.GetSlots();\n\t\t\t\t\tulong ownerID = baseEntity2.OwnerID;\n\t\t\t\t\tfloat lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);\n\t\t\t\t\tint soilSaturation = ((baseEntity2 is PlanterBox planterBox) ? planterBox.soilSaturation : 0);\n\t\t\t\t\tbool flag = baseEntity2 is DecayEntity decayEntity \u0026\u0026 decayEntity.HasFlag(Flags.Reserved2);\n\t\t\t\t\tHashSet\u003CPlayerNameID\u003E hashSet = null;\n\t\t\t\t\tif (baseEntity2 is BuildingPrivlidge buildingPrivlidge)\n\t\t\t\t\t{\n\t\t\t\t\t\thashSet = new HashSet\u003CPlayerNameID\u003E(buildingPrivlidge.authorizedPlayers);\n\t\t\t\t\t}\n\t\t\t\t\tbool flag2 = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge || baseEntity2 is BoxStorage || baseEntity2 is PlanterBox;\n\t\t\t\t\tDictionary\u003CContainerSet, List\u003CItem\u003E\u003E dictionary2 = new Dictionary\u003CContainerSet, List\u003CItem\u003E\u003E();\n\t\t\t\t\tSaveEntityStorage(baseEntity2, dictionary2, 0);\n\t\t\t\t\tList\u003CChildPreserveInfo\u003E obj = Facepunch.Pool.Get\u003CList\u003CChildPreserveInfo\u003E\u003E();\n\t\t\t\t\tif (flag2)\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (BaseEntity child in baseEntity2.children)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tobj.Add(new ChildPreserveInfo\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTargetEntity = child,\n\t\t\t\t\t\t\t\tTargetBone = child.parentBone,\n\t\t\t\t\t\t\t\tLocalPosition = child.transform.localPosition,\n\t\t\t\t\t\t\t\tLocalRotation = child.transform.localRotation\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforeach (ChildPreserveInfo item in obj)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem.TargetEntity.SetParent(null, worldPositionStays: true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0; i \u003C baseEntity2.children.Count; i\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveEntityStorage(baseEntity2.children[i], dictionary2, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tIOPreserveInfo[] array = null;\n\t\t\t\t\tIOPreserveInfo[] array2 = null;\n\t\t\t\t\tList\u003COtherEntityPreserveInfo\u003E list = new List\u003COtherEntityPreserveInfo\u003E();\n\t\t\t\t\tif (baseEntity2 is IOEntity iOEntity)\n\t\t\t\t\t{\n\t\t\t\t\t\tarray = new IOPreserveInfo[iOEntity.outputs.Length];\n\t\t\t\t\t\tfor (int j = 0; j \u003C iOEntity.outputs.Length; j\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIOEntity.IOSlot iOSlot = iOEntity.outputs[j];\n\t\t\t\t\t\t\tIOEntity iOEntity2 = iOSlot.connectedTo.Get();\n\t\t\t\t\t\t\tif (iOEntity2 != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiOSlot.Preserve(ref array[j]);\n\t\t\t\t\t\t\t\tIOPreserveInfo target = default(IOPreserveInfo);\n\t\t\t\t\t\t\t\tiOEntity2.inputs[iOSlot.connectedToSlot].Preserve(ref target);\n\t\t\t\t\t\t\t\tlist.Add(new OtherEntityPreserveInfo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinfo = target,\n\t\t\t\t\t\t\t\t\tconnectedEntity = iOEntity2,\n\t\t\t\t\t\t\t\t\tindex = iOSlot.connectedToSlot,\n\t\t\t\t\t\t\t\t\tisOutput = false\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarray2 = new IOPreserveInfo[iOEntity.inputs.Length];\n\t\t\t\t\t\tfor (int k = 0; k \u003C iOEntity.inputs.Length; k\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIOEntity.IOSlot iOSlot2 = iOEntity.inputs[k];\n\t\t\t\t\t\t\tIOEntity iOEntity3 = iOSlot2.connectedTo.Get();\n\t\t\t\t\t\t\tif (iOEntity3 != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiOSlot2.Preserve(ref array2[k]);\n\t\t\t\t\t\t\t\tIOPreserveInfo target2 = default(IOPreserveInfo);\n\t\t\t\t\t\t\t\tiOEntity3.outputs[iOSlot2.connectedToSlot].Preserve(ref target2);\n\t\t\t\t\t\t\t\tlist.Add(new OtherEntityPreserveInfo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinfo = target2,\n\t\t\t\t\t\t\t\t\tconnectedEntity = iOEntity3,\n\t\t\t\t\t\t\t\t\tindex = iOSlot2.connectedToSlot,\n\t\t\t\t\t\t\t\t\tisOutput = true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbaseEntity2.Kill();\n\t\t\t\t\tbaseEntity2 = GameManager.server.CreateEntity(resourcePath, (baseEntity3 != null) ? baseEntity3.transform.TransformPoint(localPosition) : localPosition, (baseEntity3 != null) ? (baseEntity3.transform.rotation * localRotation) : localRotation);\n\t\t\t\t\tbaseEntity2.SetParent(baseEntity3);\n\t\t\t\t\tbaseEntity2.transform.localPosition = localPosition;\n\t\t\t\t\tbaseEntity2.transform.localRotation = localRotation;\n\t\t\t\t\tbaseEntity2.OwnerID = ownerID;\n\t\t\t\t\tif (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) \u0026\u0026 def2.isRedirectOf != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseEntity2.skinID = 0uL;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseEntity2.skinID = num;\n\t\t\t\t\t}\n\t\t\t\t\tif (baseEntity2 is DecayEntity decayEntity2)\n\t\t\t\t\t{\n\t\t\t\t\t\tdecayEntity2.AttachToBuilding(null);\n\t\t\t\t\t}\n\t\t\t\t\tif (baseEntity2 is PlanterBox planterBox2)\n\t\t\t\t\t{\n\t\t\t\t\t\tplanterBox2.soilSaturation = soilSaturation;\n\t\t\t\t\t}\n\t\t\t\t\tbaseEntity2.Spawn();\n\t\t\t\t\tif (baseEntity2 is IOEntity iOEntity4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (array != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int l = 0; l \u003C iOEntity4.outputs.Length; l\u002B\u002B)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiOEntity4.outputs[l].Restore(array[l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (array2 != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = 0; m \u003C iOEntity4.inputs.Length; m\u002B\u002B)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (array2[m].connectedTo != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tiOEntity4.inputs[m].Restore(array2[m]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tusing PooledList\u003CIOEntity\u003E pooledList = Facepunch.Pool.Get\u003CPooledList\u003CIOEntity\u003E\u003E();\n\t\t\t\t\t\tforeach (OtherEntityPreserveInfo item2 in list)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIOPreserveInfo info = item2.info;\n\t\t\t\t\t\t\tinfo.connectedTo = iOEntity4;\n\t\t\t\t\t\t\tif (item2.connectedEntity != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (item2.isOutput)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\titem2.connectedEntity.outputs[item2.index].Restore(info);\n\t\t\t\t\t\t\t\t\tpooledList.Add(item2.connectedEntity);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\titem2.connectedEntity.inputs[item2.index].Restore(info);\n\t\t\t\t\t\t\t\t\tpooledList.Add(item2.connectedEntity);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforeach (IOEntity item3 in pooledList)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem3.SendNetworkUpdate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (baseEntity2 is BaseCombatEntity baseCombatEntity2)\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseCombatEntity2.SetHealth(health);\n\t\t\t\t\t\tbaseCombatEntity2.lastAttackedTime = lastAttackedTime;\n\t\t\t\t\t}\n\t\t\t\t\tif (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 \u0026\u0026 hashSet != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildingPrivlidge2.authorizedPlayers = hashSet;\n\t\t\t\t\t}\n\t\t\t\t\tif (baseEntity2 is CodeLock codeLock2)\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseEntity3.SetSlot(Slot.Lock, codeLock2);\n\t\t\t\t\t\tcodeLock2.SetParent(baseEntity3, baseEntity3.GetSlotAnchorName(Slot.Lock));\n\t\t\t\t\t\tcodeLock2.code = codeLockPreserveInfo.code;\n\t\t\t\t\t\tcodeLock2.guestCode = codeLockPreserveInfo.guestCode;\n\t\t\t\t\t\tcodeLock2.SetFlag(Flags.Locked, codeLockPreserveInfo.isLocked);\n\t\t\t\t\t\tcodeLock2.whitelistPlayers.AddRange(codeLockPreserveInfo.whitelistPlayers);\n\t\t\t\t\t\tcodeLock2.guestPlayers.AddRange(codeLockPreserveInfo.guestPlayers);\n\t\t\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref codeLockPreserveInfo.whitelistPlayers);\n\t\t\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref codeLockPreserveInfo.guestPlayers);\n\t\t\t\t\t}\n\t\t\t\t\tif (dictionary2.Count \u003E 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tRestoreEntityStorage(baseEntity2, 0, dictionary2);\n\t\t\t\t\t\tif (!flag2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int n = 0; n \u003C baseEntity2.children.Count; n\u002B\u002B)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRestoreEntityStorage(baseEntity2.children[n], -1, dictionary2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforeach (KeyValuePair\u003CContainerSet, List\u003CItem\u003E\u003E item4 in dictionary2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tforeach (Item item5 in item4.Value)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDebug.Log($\u0022Deleting {item5} as it has no new container\u0022);\n\t\t\t\t\t\t\t\titem5.Remove();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);\n\t\t\t\t\t}\n\t\t\t\t\tif (flag2)\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (ChildPreserveInfo item6 in obj)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem6.TargetEntity.SetParent(baseEntity2, item6.TargetBone, worldPositionStays: true);\n\t\t\t\t\t\t\titem6.TargetEntity.transform.localPosition = item6.LocalPosition;\n\t\t\t\t\t\t\titem6.TargetEntity.transform.localRotation = item6.LocalRotation;\n\t\t\t\t\t\t\titem6.TargetEntity.SendNetworkUpdate();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbaseEntity2.SetSlots(slots);\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t\t\t\t\tif (baseEntity2 is ISprayCallback sprayCallback)\n\t\t\t\t\t{\n\t\t\t\t\t\tsprayCallback.OnReskinned(msg.player);\n\t\t\t\t\t}\n\t\t\t\t\tif (baseEntity2 is DecayEntity decayEntity3 \u0026\u0026 !flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tdecayEntity3.StopBeingDemolishable();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tInterface.CallHook(\u0022OnEntityReskinned\u0022, baseEntity2, skin, msg.player);\n\t\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_ReskinResult\u0022), 1, baseEntity2.net.ID);\n\t\t\t}\n\t\t}\n\t\tif (!base.UsingInfiniteAmmoCheat)\n\t\t{\n\t\t\tLoseCondition(ConditionLossPerReskin);\n\t\t}\n\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_ChangeSprayColour\u0022), -1);\n\t\tSetFlag(Flags.Busy, b: true);\n\t\tInvoke(ClearBusy, SprayCooldown);\n\t\tvoid FailResponse(SprayFailReason reason)\n\t\t{\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_ReskinResult\u0022), 0, (int)reason);\n\t\t}\n\t\tstatic void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary\u003CContainerSet, List\u003CItem\u003E\u003E copy)\n\t\t{\n\t\t\tif (baseEntity is IItemContainerEntity itemContainerEntity)\n\t\t\t{\n\t\t\t\tContainerSet containerSet = default(ContainerSet);\n\t\t\t\tcontainerSet.ContainerIndex = index;\n\t\t\t\tcontainerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);\n\t\t\t\tContainerSet key = containerSet;\n\t\t\t\tif (copy.ContainsKey(key))\n\t\t\t\t{\n\t\t\t\t\tforeach (Item item7 in copy[key])\n\t\t\t\t\t{\n\t\t\t\t\t\titem7.MoveToContainer(itemContainerEntity.inventory);\n\t\t\t\t\t}\n\t\t\t\t\tcopy.Remove(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic void SaveEntityStorage(BaseEntity baseEntity, Dictionary\u003CContainerSet, List\u003CItem\u003E\u003E dictionary, int index)\n\t\t{\n\t\t\tif (baseEntity is IItemContainerEntity itemContainerEntity2)\n\t\t\t{\n\t\t\t\tContainerSet containerSet2 = default(ContainerSet);\n\t\t\t\tcontainerSet2.ContainerIndex = index;\n\t\t\t\tcontainerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);\n\t\t\t\tContainerSet key2 = containerSet2;\n\t\t\t\tif (!dictionary.ContainsKey(key2))\n\t\t\t\t{\n\t\t\t\t\tdictionary.Add(key2, new List\u003CItem\u003E());\n\t\t\t\t\tforeach (Item item8 in itemContainerEntity2.inventory.itemList)\n\t\t\t\t\t{\n\t\t\t\t\t\tdictionary[key2].Add(item8);\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (Item item9 in dictionary[key2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem9.RemoveFromContainer();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.Log(\u0022Multiple containers with the same prefab id being added during vehicle reskin\u0022);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SprayCan",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "OnTurretAuthorize(AutoTurret autoTurret, BasePlayer player)",
    "MethodSignature": "AddSelfAuthorize(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void AddSelfAuthorize(BasePlayer player)\n\t{\n\t\tBasePlayer player2 = player;\n\t\tif (!IsOnline() \u0026\u0026 player2.CanBuild() \u0026\u0026 !AtMaxAuthCapacity() \u0026\u0026 Interface.CallHook(\u0022OnTurretAuthorize\u0022, this, player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.RemoveWhere((PlayerNameID x) =\u003E x.userid == (ulong)player2.userID);\n\t\t\tPlayerNameID playerNameID = new PlayerNameID();\n\t\t\tplayerNameID.userid = player2.userID;\n\t\t\tplayerNameID.username = player2.displayName;\n\t\t\tauthorizedPlayers.Add(playerNameID);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, player2, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022added\u0022, player2.userID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnCrateHack(HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "StartHacking()",
    "MethodSourseCode": "\n\tpublic void StartHacking()\n\t{\n\t\tInterface.CallHook(\u0022OnCrateHack\u0022, this);\n\t\tBroadcastEntityMessage(\u0022HackingStarted\u0022, 20f, 256);\n\t\tSetFlag(Flags.Reserved1, b: true);\n\t\tInvokeRepeating(HackProgress, 1f, 1f);\n\t\tClientRPC(RpcTarget.NetworkGroup(\u0022UpdateHackProgress\u0022), 0, (int)requiredHackSeconds);\n\t\tRefreshDecay();\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerRespawn(BasePlayer basePlayer, BasePlayer.SpawnPoint spawnPoint)",
    "MethodSignature": "Respawn()",
    "MethodSourseCode": "\n\tpublic void Respawn()\n\t{\n\t\tSpawnPoint spawnPoint = ServerMgr.FindSpawnPoint(this, 0uL);\n\t\tif (ConVar.Server.respawnAtDeathPosition \u0026\u0026 ServerCurrentDeathNote != null)\n\t\t{\n\t\t\tspawnPoint.pos = ServerCurrentDeathNote.worldPosition;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerRespawn\u0022, this, spawnPoint);\n\t\tif (obj is SpawnPoint)\n\t\t{\n\t\t\tspawnPoint = (SpawnPoint)obj;\n\t\t}\n\t\tRespawnAt(spawnPoint.pos, spawnPoint.rot);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnEntityReskinned(BaseEntity baseEntity2, ItemSkinDirectory.Skin skin, BasePlayer msgPlayer)",
    "MethodSignature": "ChangeItemSkin(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(2uL)]\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void ChangeItemSkin(RPCMessage msg)\n\t{\n\t\tNetworkableId uid = msg.read.EntityID();\n\t\tint targetSkin = msg.read.Int32();\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);\n\t\tif (!ValidateEntityAndSkin(msg.player, baseNetworkable, targetSkin))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (baseNetworkable != null)\n\t\t{\n\t\t\tBaseEntity baseEntity2 = baseNetworkable as BaseEntity;\n\t\t\tif ((object)baseEntity2 != null)\n\t\t\t{\n\t\t\t\tif (!GetItemDefinitionForEntity(baseEntity2, out var def, useRedirect: false))\n\t\t\t\t{\n\t\t\t\t\tFailResponse(SprayFailReason.InvalidItem);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tItemDefinition itemDefinition = null;\n\t\t\t\tulong num = ItemDefinition.FindSkin((def.isRedirectOf != null) ? def.isRedirectOf.itemid : def.itemid, targetSkin);\n\t\t\t\tItemSkinDirectory.Skin skin = ((def.isRedirectOf != null) ? def.isRedirectOf : def).skins.FirstOrDefault((ItemSkinDirectory.Skin x) =\u003E x.id == targetSkin);\n\t\t\t\tif (Interface.CallHook(\u0022OnEntityReskin\u0022, baseEntity2, skin, msg.player) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (skin.invItem != null \u0026\u0026 skin.invItem is ItemSkin itemSkin)\n\t\t\t\t{\n\t\t\t\t\tif (itemSkin.Redirect != null)\n\t\t\t\t\t{\n\t\t\t\t\t\titemDefinition = itemSkin.Redirect;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bool)def \u0026\u0026 def.isRedirectOf != null)\n\t\t\t\t\t{\n\t\t\t\t\t\titemDefinition = def.isRedirectOf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (def.isRedirectOf != null || ((bool)def \u0026\u0026 def.isRedirectOf != null))\n\t\t\t\t{\n\t\t\t\t\titemDefinition = def.isRedirectOf;\n\t\t\t\t}\n\t\t\t\tif (itemDefinition == null)\n\t\t\t\t{\n\t\t\t\t\tbaseEntity2.skinID = num;\n\t\t\t\t\tbaseEntity2.SendNetworkUpdate();\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!CanEntityBeRespawned(baseEntity2, out var reason2))\n\t\t\t\t\t{\n\t\t\t\t\t\tFailResponse(reason2);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (!GetEntityPrefabPath(itemDefinition, out var resourcePath))\n\t\t\t\t\t{\n\t\t\t\t\t\tDebug.LogWarning(\u0022Cannot find resource path of redirect entity to spawn! \u0022 \u002B itemDefinition.gameObject.name);\n\t\t\t\t\t\tFailResponse(SprayFailReason.InvalidItem);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (global::SimpleUpgrade.IsUpgradeBlocked(baseEntity2, itemDefinition, msg.player))\n\t\t\t\t\t{\n\t\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, BlockedByPlayer, false);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tCodeLockPreserveInfo codeLockPreserveInfo = default(CodeLockPreserveInfo);\n\t\t\t\t\tif (baseEntity2 is CodeLock codeLock)\n\t\t\t\t\t{\n\t\t\t\t\t\tcodeLockPreserveInfo.code = codeLock.code;\n\t\t\t\t\t\tcodeLockPreserveInfo.guestCode = codeLock.guestCode;\n\t\t\t\t\t\tcodeLockPreserveInfo.isLocked = codeLock.IsLocked();\n\t\t\t\t\t\tcodeLockPreserveInfo.whitelistPlayers = Facepunch.Pool.Get\u003CList\u003Culong\u003E\u003E();\n\t\t\t\t\t\tcodeLockPreserveInfo.guestPlayers = Facepunch.Pool.Get\u003CList\u003Culong\u003E\u003E();\n\t\t\t\t\t\tcodeLockPreserveInfo.whitelistPlayers.AddRange(codeLock.whitelistPlayers);\n\t\t\t\t\t\tcodeLockPreserveInfo.guestPlayers.AddRange(codeLock.guestPlayers);\n\t\t\t\t\t}\n\t\t\t\t\tVector3 localPosition = baseEntity2.transform.localPosition;\n\t\t\t\t\tQuaternion localRotation = baseEntity2.transform.localRotation;\n\t\t\t\t\tBaseEntity baseEntity3 = baseEntity2.GetParentEntity();\n\t\t\t\t\tfloat health = baseEntity2.Health();\n\t\t\t\t\tEntityRef[] slots = baseEntity2.GetSlots();\n\t\t\t\t\tulong ownerID = baseEntity2.OwnerID;\n\t\t\t\t\tfloat lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);\n\t\t\t\t\tint soilSaturation = ((baseEntity2 is PlanterBox planterBox) ? planterBox.soilSaturation : 0);\n\t\t\t\t\tbool flag = baseEntity2 is DecayEntity decayEntity \u0026\u0026 decayEntity.HasFlag(Flags.Reserved2);\n\t\t\t\t\tHashSet\u003CPlayerNameID\u003E hashSet = null;\n\t\t\t\t\tif (baseEntity2 is BuildingPrivlidge buildingPrivlidge)\n\t\t\t\t\t{\n\t\t\t\t\t\thashSet = new HashSet\u003CPlayerNameID\u003E(buildingPrivlidge.authorizedPlayers);\n\t\t\t\t\t}\n\t\t\t\t\tbool flag2 = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge || baseEntity2 is BoxStorage || baseEntity2 is PlanterBox;\n\t\t\t\t\tDictionary\u003CContainerSet, List\u003CItem\u003E\u003E dictionary2 = new Dictionary\u003CContainerSet, List\u003CItem\u003E\u003E();\n\t\t\t\t\tSaveEntityStorage(baseEntity2, dictionary2, 0);\n\t\t\t\t\tList\u003CChildPreserveInfo\u003E obj = Facepunch.Pool.Get\u003CList\u003CChildPreserveInfo\u003E\u003E();\n\t\t\t\t\tif (flag2)\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (BaseEntity child in baseEntity2.children)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tobj.Add(new ChildPreserveInfo\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTargetEntity = child,\n\t\t\t\t\t\t\t\tTargetBone = child.parentBone,\n\t\t\t\t\t\t\t\tLocalPosition = child.transform.localPosition,\n\t\t\t\t\t\t\t\tLocalRotation = child.transform.localRotation\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforeach (ChildPreserveInfo item in obj)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem.TargetEntity.SetParent(null, worldPositionStays: true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0; i \u003C baseEntity2.children.Count; i\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveEntityStorage(baseEntity2.children[i], dictionary2, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tIOPreserveInfo[] array = null;\n\t\t\t\t\tIOPreserveInfo[] array2 = null;\n\t\t\t\t\tList\u003COtherEntityPreserveInfo\u003E list = new List\u003COtherEntityPreserveInfo\u003E();\n\t\t\t\t\tif (baseEntity2 is IOEntity iOEntity)\n\t\t\t\t\t{\n\t\t\t\t\t\tarray = new IOPreserveInfo[iOEntity.outputs.Length];\n\t\t\t\t\t\tfor (int j = 0; j \u003C iOEntity.outputs.Length; j\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIOEntity.IOSlot iOSlot = iOEntity.outputs[j];\n\t\t\t\t\t\t\tIOEntity iOEntity2 = iOSlot.connectedTo.Get();\n\t\t\t\t\t\t\tif (iOEntity2 != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiOSlot.Preserve(ref array[j]);\n\t\t\t\t\t\t\t\tIOPreserveInfo target = default(IOPreserveInfo);\n\t\t\t\t\t\t\t\tiOEntity2.inputs[iOSlot.connectedToSlot].Preserve(ref target);\n\t\t\t\t\t\t\t\tlist.Add(new OtherEntityPreserveInfo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinfo = target,\n\t\t\t\t\t\t\t\t\tconnectedEntity = iOEntity2,\n\t\t\t\t\t\t\t\t\tindex = iOSlot.connectedToSlot,\n\t\t\t\t\t\t\t\t\tisOutput = false\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarray2 = new IOPreserveInfo[iOEntity.inputs.Length];\n\t\t\t\t\t\tfor (int k = 0; k \u003C iOEntity.inputs.Length; k\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIOEntity.IOSlot iOSlot2 = iOEntity.inputs[k];\n\t\t\t\t\t\t\tIOEntity iOEntity3 = iOSlot2.connectedTo.Get();\n\t\t\t\t\t\t\tif (iOEntity3 != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiOSlot2.Preserve(ref array2[k]);\n\t\t\t\t\t\t\t\tIOPreserveInfo target2 = default(IOPreserveInfo);\n\t\t\t\t\t\t\t\tiOEntity3.outputs[iOSlot2.connectedToSlot].Preserve(ref target2);\n\t\t\t\t\t\t\t\tlist.Add(new OtherEntityPreserveInfo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinfo = target2,\n\t\t\t\t\t\t\t\t\tconnectedEntity = iOEntity3,\n\t\t\t\t\t\t\t\t\tindex = iOSlot2.connectedToSlot,\n\t\t\t\t\t\t\t\t\tisOutput = true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbaseEntity2.Kill();\n\t\t\t\t\tbaseEntity2 = GameManager.server.CreateEntity(resourcePath, (baseEntity3 != null) ? baseEntity3.transform.TransformPoint(localPosition) : localPosition, (baseEntity3 != null) ? (baseEntity3.transform.rotation * localRotation) : localRotation);\n\t\t\t\t\tbaseEntity2.SetParent(baseEntity3);\n\t\t\t\t\tbaseEntity2.transform.localPosition = localPosition;\n\t\t\t\t\tbaseEntity2.transform.localRotation = localRotation;\n\t\t\t\t\tbaseEntity2.OwnerID = ownerID;\n\t\t\t\t\tif (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) \u0026\u0026 def2.isRedirectOf != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseEntity2.skinID = 0uL;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseEntity2.skinID = num;\n\t\t\t\t\t}\n\t\t\t\t\tif (baseEntity2 is DecayEntity decayEntity2)\n\t\t\t\t\t{\n\t\t\t\t\t\tdecayEntity2.AttachToBuilding(null);\n\t\t\t\t\t}\n\t\t\t\t\tif (baseEntity2 is PlanterBox planterBox2)\n\t\t\t\t\t{\n\t\t\t\t\t\tplanterBox2.soilSaturation = soilSaturation;\n\t\t\t\t\t}\n\t\t\t\t\tbaseEntity2.Spawn();\n\t\t\t\t\tif (baseEntity2 is IOEntity iOEntity4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (array != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int l = 0; l \u003C iOEntity4.outputs.Length; l\u002B\u002B)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiOEntity4.outputs[l].Restore(array[l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (array2 != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = 0; m \u003C iOEntity4.inputs.Length; m\u002B\u002B)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (array2[m].connectedTo != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tiOEntity4.inputs[m].Restore(array2[m]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tusing PooledList\u003CIOEntity\u003E pooledList = Facepunch.Pool.Get\u003CPooledList\u003CIOEntity\u003E\u003E();\n\t\t\t\t\t\tforeach (OtherEntityPreserveInfo item2 in list)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIOPreserveInfo info = item2.info;\n\t\t\t\t\t\t\tinfo.connectedTo = iOEntity4;\n\t\t\t\t\t\t\tif (item2.connectedEntity != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (item2.isOutput)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\titem2.connectedEntity.outputs[item2.index].Restore(info);\n\t\t\t\t\t\t\t\t\tpooledList.Add(item2.connectedEntity);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\titem2.connectedEntity.inputs[item2.index].Restore(info);\n\t\t\t\t\t\t\t\t\tpooledList.Add(item2.connectedEntity);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforeach (IOEntity item3 in pooledList)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem3.SendNetworkUpdate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (baseEntity2 is BaseCombatEntity baseCombatEntity2)\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseCombatEntity2.SetHealth(health);\n\t\t\t\t\t\tbaseCombatEntity2.lastAttackedTime = lastAttackedTime;\n\t\t\t\t\t}\n\t\t\t\t\tif (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 \u0026\u0026 hashSet != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildingPrivlidge2.authorizedPlayers = hashSet;\n\t\t\t\t\t}\n\t\t\t\t\tif (baseEntity2 is CodeLock codeLock2)\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseEntity3.SetSlot(Slot.Lock, codeLock2);\n\t\t\t\t\t\tcodeLock2.SetParent(baseEntity3, baseEntity3.GetSlotAnchorName(Slot.Lock));\n\t\t\t\t\t\tcodeLock2.code = codeLockPreserveInfo.code;\n\t\t\t\t\t\tcodeLock2.guestCode = codeLockPreserveInfo.guestCode;\n\t\t\t\t\t\tcodeLock2.SetFlag(Flags.Locked, codeLockPreserveInfo.isLocked);\n\t\t\t\t\t\tcodeLock2.whitelistPlayers.AddRange(codeLockPreserveInfo.whitelistPlayers);\n\t\t\t\t\t\tcodeLock2.guestPlayers.AddRange(codeLockPreserveInfo.guestPlayers);\n\t\t\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref codeLockPreserveInfo.whitelistPlayers);\n\t\t\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref codeLockPreserveInfo.guestPlayers);\n\t\t\t\t\t}\n\t\t\t\t\tif (dictionary2.Count \u003E 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tRestoreEntityStorage(baseEntity2, 0, dictionary2);\n\t\t\t\t\t\tif (!flag2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int n = 0; n \u003C baseEntity2.children.Count; n\u002B\u002B)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRestoreEntityStorage(baseEntity2.children[n], -1, dictionary2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforeach (KeyValuePair\u003CContainerSet, List\u003CItem\u003E\u003E item4 in dictionary2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tforeach (Item item5 in item4.Value)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDebug.Log($\u0022Deleting {item5} as it has no new container\u0022);\n\t\t\t\t\t\t\t\titem5.Remove();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);\n\t\t\t\t\t}\n\t\t\t\t\tif (flag2)\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (ChildPreserveInfo item6 in obj)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem6.TargetEntity.SetParent(baseEntity2, item6.TargetBone, worldPositionStays: true);\n\t\t\t\t\t\t\titem6.TargetEntity.transform.localPosition = item6.LocalPosition;\n\t\t\t\t\t\t\titem6.TargetEntity.transform.localRotation = item6.LocalRotation;\n\t\t\t\t\t\t\titem6.TargetEntity.SendNetworkUpdate();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbaseEntity2.SetSlots(slots);\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t\t\t\t\tif (baseEntity2 is ISprayCallback sprayCallback)\n\t\t\t\t\t{\n\t\t\t\t\t\tsprayCallback.OnReskinned(msg.player);\n\t\t\t\t\t}\n\t\t\t\t\tif (baseEntity2 is DecayEntity decayEntity3 \u0026\u0026 !flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tdecayEntity3.StopBeingDemolishable();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tInterface.CallHook(\u0022OnEntityReskinned\u0022, baseEntity2, skin, msg.player);\n\t\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_ReskinResult\u0022), 1, baseEntity2.net.ID);\n\t\t\t}\n\t\t}\n\t\tif (!base.UsingInfiniteAmmoCheat)\n\t\t{\n\t\t\tLoseCondition(ConditionLossPerReskin);\n\t\t}\n\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_ChangeSprayColour\u0022), -1);\n\t\tSetFlag(Flags.Busy, b: true);\n\t\tInvoke(ClearBusy, SprayCooldown);\n\t\tvoid FailResponse(SprayFailReason reason)\n\t\t{\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_ReskinResult\u0022), 0, (int)reason);\n\t\t}\n\t\tstatic void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary\u003CContainerSet, List\u003CItem\u003E\u003E copy)\n\t\t{\n\t\t\tif (baseEntity is IItemContainerEntity itemContainerEntity)\n\t\t\t{\n\t\t\t\tContainerSet containerSet = default(ContainerSet);\n\t\t\t\tcontainerSet.ContainerIndex = index;\n\t\t\t\tcontainerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);\n\t\t\t\tContainerSet key = containerSet;\n\t\t\t\tif (copy.ContainsKey(key))\n\t\t\t\t{\n\t\t\t\t\tforeach (Item item7 in copy[key])\n\t\t\t\t\t{\n\t\t\t\t\t\titem7.MoveToContainer(itemContainerEntity.inventory);\n\t\t\t\t\t}\n\t\t\t\t\tcopy.Remove(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic void SaveEntityStorage(BaseEntity baseEntity, Dictionary\u003CContainerSet, List\u003CItem\u003E\u003E dictionary, int index)\n\t\t{\n\t\t\tif (baseEntity is IItemContainerEntity itemContainerEntity2)\n\t\t\t{\n\t\t\t\tContainerSet containerSet2 = default(ContainerSet);\n\t\t\t\tcontainerSet2.ContainerIndex = index;\n\t\t\t\tcontainerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);\n\t\t\t\tContainerSet key2 = containerSet2;\n\t\t\t\tif (!dictionary.ContainsKey(key2))\n\t\t\t\t{\n\t\t\t\t\tdictionary.Add(key2, new List\u003CItem\u003E());\n\t\t\t\t\tforeach (Item item8 in itemContainerEntity2.inventory.itemList)\n\t\t\t\t\t{\n\t\t\t\t\t\tdictionary[key2].Add(item8);\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (Item item9 in dictionary[key2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem9.RemoveFromContainer();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.Log(\u0022Multiple containers with the same prefab id being added during vehicle reskin\u0022);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SprayCan",
    "HookLineInvoke": 294
  },
  {
    "HookSignature": "OnPlayerPveDamage(BaseEntity infoInitiator, HitInfo info, BuildingBlock buildingBlock)",
    "MethodSignature": "Hurt(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void Hurt(HitInfo info)\n\t{\n\t\tif (ConVar.Server.pve \u0026\u0026 (bool)info.Initiator \u0026\u0026 info.Initiator is BasePlayer)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnPlayerPveDamage\u0022, info.Initiator, info, this) == null)\n\t\t\t{\n\t\t\t\t(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((bool)info.Initiator \u0026\u0026 info.Initiator is BasePlayer { IsInTutorial: not false })\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (HasWallpaper())\n\t\t\t{\n\t\t\t\tDamageType majorityDamageType = info.damageTypes.GetMajorityDamageType();\n\t\t\t\tbool flag = info.damageTypes.Contains(DamageType.Explosion);\n\t\t\t\tDamageTypeList damageTypeList = info.damageTypes.Clone();\n\t\t\t\tif (wallpaperProtection != null)\n\t\t\t\t{\n\t\t\t\t\twallpaperProtection.Scale(damageTypeList);\n\t\t\t\t}\n\t\t\t\tfloat totalDamage = damageTypeList.Total();\n\t\t\t\tif (majorityDamageType == DamageType.Decay || flag || majorityDamageType == DamageType.Heat)\n\t\t\t\t{\n\t\t\t\t\tDamageWallpaper(totalDamage);\n\t\t\t\t\tDamageWallpaper(totalDamage, 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbool flag2 = false;\n\t\t\t\t\tfor (int i = 0; i \u003C propDirection.Length; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (propDirection[i].IsWeakspot(base.transform, info))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag2 = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDamageWallpaper(totalDamage, (!flag2) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbase.Hurt(info);\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanAffordUpgrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum iGrade, ulong iSkin)",
    "MethodSignature": "CanAffordUpgrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanAffordUpgrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanAffordUpgrade\u0022, player, this, iGrade, iSkin);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player != null \u0026\u0026 player.IsInCreativeMode \u0026\u0026 Creative.freeBuild)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (!ConVar.Decay.CanUpgradeToGrade(iGrade))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tforeach (ItemAmount item in blockDefinition.GetGrade(iGrade, iSkin).CostToBuild(grade))\n\t\t{\n\t\t\tif ((float)player.inventory.GetAmount(item.itemid) \u003C item.amount)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFreeableContainerReleased(FreeableLootContainer freeableLootContainer, BasePlayer ply)",
    "MethodSignature": "Release(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic void Release(BasePlayer ply)\n\t{\n\t\tif (Interface.CallHook(\u0022OnFreeableContainerRelease\u0022, this, ply) == null)\n\t\t{\n\t\t\tGetRB().isKinematic = false;\n\t\t\tbuoyancy.enabled = true;\n\t\t\tbuoyancy.buoyancyScale = 1f;\n\t\t\tSetFlag(Flags.Reserved8, b: false);\n\t\t\tif (freedEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(freedEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tif (ply != null \u0026\u0026 !ply.IsNpc \u0026\u0026 ply.IsConnected \u0026\u0026 net != null)\n\t\t\t{\n\t\t\t\tply.ProcessMissionEvent(BaseMission.MissionEventType.FREE_CRATE, net.ID, 1f);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnFreeUnderwaterCrate(ply, this);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnFreeableContainerReleased\u0022, this, ply);\n\t\t}\n\t}\n",
    "ClassName": "FreeableLootContainer",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnFuelConsumed(BaseOven baseOven, Item fuel, ItemModBurnable burnable)",
    "MethodSignature": "ConsumeFuel(Item fuel, ItemModBurnable burnable)",
    "MethodSourseCode": "\n\tpublic void ConsumeFuel(Item fuel, ItemModBurnable burnable)\n\t{\n\t\tif (Interface.CallHook(\u0022OnFuelConsume\u0022, this, fuel, burnable) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (allowByproductCreation \u0026\u0026 burnable.byproductItem != null \u0026\u0026 UnityEngine.Random.Range(0f, 1f) \u003E burnable.byproductChance)\n\t\t{\n\t\t\tItem item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);\n\t\t\tif (!item.MoveToContainer(base.inventory))\n\t\t\t{\n\t\t\t\tOvenFull();\n\t\t\t\titem.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\n\t\t\t}\n\t\t}\n\t\tif (fuel.amount \u003C= GetFuelRate())\n\t\t{\n\t\t\tfuel.Remove();\n\t\t\treturn;\n\t\t}\n\t\tint fuelRate = GetFuelRate();\n\t\tfuel.UseItem(fuelRate);\n\t\tFacepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, \u0022smelt\u0022);\n\t\tfuel.fuel = burnable.fuelAmount;\n\t\tfuel.MarkDirty();\n\t\tInterface.CallHook(\u0022OnFuelConsumed\u0022, this, fuel, burnable);\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "OnRackedWeaponMount(Item item, BasePlayer player, WeaponRack weaponRack)",
    "MethodSignature": "MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate)",
    "MethodSourseCode": "\n\tprivate bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate = true)\n\t{\n\t\tif (item == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnRackedWeaponMount\u0022, item, player, this);\n\t\tif (obj != null)\n\t\t{\n\t\t\tif (!(obj is bool))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tint itemid = item.info.itemid;\n\t\tWorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);\n\t\tif (forItemDef == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022no rackmount config\u0022);\n\t\t\treturn false;\n\t\t}\n\t\tif (!CanAcceptWeaponType(forItemDef))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!GridCellsFree(forItemDef, gridCellIndex, rotation, null))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.MoveToContainer(base.inventory, -1, allowStack: false) \u0026\u0026 item.position \u003E= 0 \u0026\u0026 item.position \u003C gridSlots.Length)\n\t\t{\n\t\t\tWeaponRackSlot slot = gridSlots[item.position];\n\t\t\tSetSlotItem(slot, item, gridCellIndex, rotation);\n\t\t\tSetupSlot(slot);\n\t\t\tif (player != null)\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022PlayMountSound\u0022, player), itemid);\n\t\t\t}\n\t\t}\n\t\tif (sendUpdate)\n\t\t{\n\t\t\tItemManager.DoRemoves();\n\t\t\tSendNetworkUpdateImmediate();\n\t\t}\n\t\tInterface.CallHook(\u0022OnRackedWeaponMounted\u0022, item, player, this);\n\t\treturn true;\n\t}\n",
    "ClassName": "WeaponRack",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnTrapTrigger(Landmine landmine, UnityEngine.GameObject obj)",
    "MethodSignature": "ObjectEntered(GameObject obj)",
    "MethodSourseCode": "\n\tpublic override void ObjectEntered(GameObject obj)\n\t{\n\t\tif (!base.isClient)\n\t\t{\n\t\t\tif (!Armed())\n\t\t\t{\n\t\t\t\tCancelInvoke(Arm);\n\t\t\t\tblocked = true;\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnTrapTrigger\u0022, this, obj) == null)\n\t\t\t{\n\t\t\t\tBasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;\n\t\t\t\tTrigger(ply);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Landmine",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnSignUpdated(Signage signage, BasePlayer msgPlayer, int num)",
    "MethodSignature": "UpdateSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\t[RPC_Server.MaxDistance(5f)]\n\tpublic void UpdateSign(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || !CanUpdateSign(msg.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = msg.read.Int32();\n\t\tif (num \u003C 0 || num \u003E= paintableSources.Length)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (msg.read.Unread \u003E 0 \u0026\u0026 msg.read.Bit() \u0026\u0026 !msg.player.IsAdmin)\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning($\u0022{msg.player} tried to upload a sign from a file but they aren\u0027t admin, ignoring\u0022);\n\t\t\treturn;\n\t\t}\n\t\tEnsureInitialized();\n\t\tif (array == null)\n\t\t{\n\t\t\tif (textureIDs[num] != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\n\t\t\t}\n\t\t\ttextureIDs[num] = 0u;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!ImageProcessing.IsValidPNG(array, 1024, 1024))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (textureIDs[num] != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\n\t\t\t}\n\t\t\ttextureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);\n\t\t}\n\t\tLogEdit(msg.player);\n\t\tSendNetworkUpdate();\n\t\tInterface.CallHook(\u0022OnSignUpdated\u0022, this, msg.player, num);\n\t}\n",
    "ClassName": "Signage",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "OnCupboardAuthorize(BuildingPrivlidge buildingPrivlidge, BasePlayer player)",
    "MethodSignature": "OnDeployed(BaseEntity ent, BasePlayer player)",
    "MethodSourseCode": "\n\tinternal void OnDeployed(BaseEntity ent, BasePlayer player)\n\t{\n\t\tif (player.IsValid() \u0026\u0026 !string.IsNullOrEmpty(UnlockAchievement))\n\t\t{\n\t\t\tplayer.GiveAchievement(UnlockAchievement);\n\t\t}\n\t\tif (ent is BuildingPrivlidge buildingPrivlidge \u0026\u0026 Interface.CallHook(\u0022OnCupboardAuthorize\u0022, buildingPrivlidge, player) == null)\n\t\t{\n\t\t\tbuildingPrivlidge.AddPlayer(player, player.userID);\n\t\t}\n\t}\n",
    "ClassName": "ItemModDeployable",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "RPC_Broadcast(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_Broadcast(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tbool b = msg.read.Bit();\n\t\tif (CanPlayerAdmin(player))\n\t\t{\n\t\t\tSetFlag(Flags.Reserved4, b);\n\t\t\tInterface.CallHook(\u0022OnToggleVendingBroadcast\u0022, this, player);\n\t\t\tUpdateMapMarker();\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnLootEntity(BasePlayer getComponent\u003CBasePlayer\u003E, BaseEntity targetEntity)",
    "MethodSignature": "StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks)",
    "MethodSourseCode": "\n\tpublic bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)\n\t{\n\t\tClear();\n\t\tif (!targetEntity)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!targetEntity.OnStartBeingLooted(base.baseEntity))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tAssert.IsTrue(targetEntity.isServer, \u0022Assure is server\u0022);\n\t\tPositionChecks = doPositionChecks;\n\t\tentitySource = targetEntity;\n\t\titemSource = null;\n\t\tInterface.CallHook(\u0022OnLootEntity\u0022, GetComponent\u003CBasePlayer\u003E(), targetEntity);\n\t\tMarkDirty();\n\t\tif (targetEntity is ILootableEntity lootableEntity)\n\t\t{\n\t\t\tlootableEntity.LastLootedBy = base.baseEntity.userID;\n\t\t\tlootableEntity.LastLootedByPlayer = base.baseEntity;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnItemSubmit(Item slot, Mailbox mailbox, BasePlayer fromPlayer)",
    "MethodSignature": "SubmitInputItems(BasePlayer fromPlayer)",
    "MethodSourseCode": "\n\tpublic void SubmitInputItems(BasePlayer fromPlayer)\n\t{\n\t\tfor (int i = 0; i \u003C InputContainer.capacity; i\u002B\u002B)\n\t\t{\n\t\t\tItem slot = InputContainer.GetSlot(i);\n\t\t\tif (slot != null \u0026\u0026 Interface.CallHook(\u0022OnItemSubmit\u0022, slot, this, fromPlayer) == null \u0026\u0026 slot.MoveToContainer(base.inventory))\n\t\t\t{\n\t\t\t\tEffect.server.Run(mailDropSound.resourcePath, GetDropPosition());\n\t\t\t\tif (fromPlayer != null \u0026\u0026 !PlayerIsOwner(fromPlayer))\n\t\t\t\t{\n\t\t\t\t\tSetFlag(Flags.On, b: true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Mailbox",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnStashOcclude(StashContainer stashContainer)",
    "MethodSignature": "DoOccludedCheck()",
    "MethodSourseCode": "\n\tpublic void DoOccludedCheck()\n\t{\n\t\tif (UnityEngine.Physics.SphereCast(new Ray(base.transform.position \u002B Vector3.up * 5f, Vector3.down), 0.25f, 5f, 2097152) \u0026\u0026 Interface.CallHook(\u0022OnStashOcclude\u0022, this) == null)\n\t\t{\n\t\t\tDropItems();\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSignUpdated(PhotoFrame photoFrame, BasePlayer msgPlayer)",
    "MethodSignature": "UpdateSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(5f)]\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(3uL)]\n\tpublic void UpdateSign(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 CanUpdateSign(msg.player))\n\t\t{\n\t\t\tbyte[] array = msg.read.BytesWithSize();\n\t\t\tif (array != null \u0026\u0026 ImageProcessing.IsValidPNG(array, 1024, 1024))\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveAllByEntity(net.ID);\n\t\t\t\t_overlayTextureCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);\n\t\t\t\tLogEdit(msg.player);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnSignUpdated\u0022, this, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhotoFrame",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnTurretRotate(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "FlipAim(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void FlipAim(RPCMessage rpc)\n\t{\n\t\tif (!IsOnline() \u0026\u0026 IsAuthed(rpc.player) \u0026\u0026 !booting \u0026\u0026 Interface.CallHook(\u0022OnTurretRotate\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tbase.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "IOnBasePlayerHurt(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "Hurt(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void Hurt(HitInfo info)\n\t{\n\t\tif (IsDead() || IsTransferProtected() || (IsImmortalTo(info) \u0026\u0026 info.damageTypes.Total() \u003E= 0f) || Interface.CallHook(\u0022IOnBasePlayerHurt\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool wasWounded = IsWounded();\n\t\tif (ConVar.Server.pve \u0026\u0026 !IsNpc \u0026\u0026 (bool)info.Initiator \u0026\u0026 info.Initiator is BasePlayer \u0026\u0026 info.Initiator != this)\n\t\t{\n\t\t\t(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);\n\t\t\treturn;\n\t\t}\n\t\tif (info.damageTypes.Has(DamageType.Fun_Water))\n\t\t{\n\t\t\tbool flag = true;\n\t\t\tItem activeItem = GetActiveItem();\n\t\t\tif (activeItem != null \u0026\u0026 (activeItem.info.shortname == \u0022gun.water\u0022 || activeItem.info.shortname == \u0022pistol.water\u0022))\n\t\t\t{\n\t\t\t\tfloat value = metabolism.wetness.value;\n\t\t\t\tmetabolism.wetness.Add(ConVar.Server.funWaterWetnessGain);\n\t\t\t\tbool flag2 = metabolism.wetness.value \u003E= ConVar.Server.funWaterDamageThreshold;\n\t\t\t\tflag = !flag2;\n\t\t\t\tif (info.InitiatorPlayer != null)\n\t\t\t\t{\n\t\t\t\t\tif (flag2 \u0026\u0026 value \u003C ConVar.Server.funWaterDamageThreshold)\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo.InitiatorPlayer.GiveAchievement(\u0022SUMMER_SOAKED\u0022);\n\t\t\t\t\t}\n\t\t\t\t\tif (metabolism.radiation_level.Fraction() \u003E 0.2f \u0026\u0026 !string.IsNullOrEmpty(\u0022SUMMER_RADICAL\u0022))\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo.InitiatorPlayer.GiveAchievement(\u0022SUMMER_RADICAL\u0022);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tinfo.damageTypes.Scale(DamageType.Fun_Water, 0f);\n\t\t\t}\n\t\t}\n\t\tif (info.damageTypes.Has(DamageType.BeeSting))\n\t\t{\n\t\t\tfloat num = Mathf.Abs(timeSinceLastStung - UnityEngine.Time.time);\n\t\t\tfloat num2 = 1f;\n\t\t\tif (num \u003C 2f)\n\t\t\t{\n\t\t\t\tnum2 = Mathf.Lerp(0.2f, 0.05f, Mathf.Exp((0f - num) * 1.5f));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum2 = 1f;\n\t\t\t\ttimeSinceLastStung = UnityEngine.Time.time;\n\t\t\t}\n\t\t\tinfo.damageTypes.ScaleAll(num2);\n\t\t\tif (baseProtection.Get(DamageType.BeeSting) \u003E 0f)\n\t\t\t{\n\t\t\t\tinfo.damageTypes.ScaleAll(0f);\n\t\t\t}\n\t\t}\n\t\tif (info.damageTypes.Get(DamageType.Drowned) \u003E 5f \u0026\u0026 drownEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(drownEffect.resourcePath, this, StringPool.Get(\u0022head\u0022), Vector3.zero, Vector3.zero);\n\t\t}\n\t\tif (modifiers != null)\n\t\t{\n\t\t\tif (info.damageTypes.Has(DamageType.Radiation))\n\t\t\t{\n\t\t\t\tinfo.damageTypes.Scale(DamageType.Radiation, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Resistance)));\n\t\t\t}\n\t\t\tif (info.damageTypes.Has(DamageType.RadiationExposure))\n\t\t\t{\n\t\t\t\tinfo.damageTypes.Scale(DamageType.RadiationExposure, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Exposure_Resistance)));\n\t\t\t}\n\t\t}\n\t\tmetabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);\n\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\n\t\tif ((bool)initiatorPlayer \u0026\u0026 initiatorPlayer != this)\n\t\t{\n\t\t\tif (initiatorPlayer.InSafeZone() || InSafeZone())\n\t\t\t{\n\t\t\t\tinitiatorPlayer.MarkHostileFor(300f);\n\t\t\t}\n\t\t\tif (initiatorPlayer.InSafeZone() \u0026\u0026 !initiatorPlayer.IsNpc)\n\t\t\t{\n\t\t\t\tinfo.damageTypes.ScaleAll(0f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (initiatorPlayer.IsNpc \u0026\u0026 initiatorPlayer.Family == BaseNpc.AiStatistics.FamilyEnum.Murderer \u0026\u0026 info.damageTypes.Get(DamageType.Explosion) \u003E 0f)\n\t\t\t{\n\t\t\t\tinfo.damageTypes.ScaleAll(Halloween.scarecrow_beancan_vs_player_dmg_modifier);\n\t\t\t}\n\t\t}\n\t\tbase.Hurt(info);\n\t\tif ((bool)BaseGameMode.GetActiveGameMode(serverside: true))\n\t\t{\n\t\t\tBasePlayer instigator = info?.InitiatorPlayer;\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerHurt(instigator, this, info);\n\t\t}\n\t\tif (IsRestrained \u0026\u0026 info.damageTypes.GetMajorityDamageType().InterruptsRestraintMinigame())\n\t\t{\n\t\t\tHandcuffs handcuffs = GetHeldEntity() as Handcuffs;\n\t\t\tif (handcuffs != null)\n\t\t\t{\n\t\t\t\thandcuffs.InterruptUnlockMiniGame(wasPushedOrDamaged: true);\n\t\t\t}\n\t\t}\n\t\tEACServer.LogPlayerTakeDamage(this, info, wasWounded);\n\t\tPlayerInjureState = GetInjureState();\n\t\tmetabolism.SendChangesToClient();\n\t\tif (info.PointStart != Vector3.zero \u0026\u0026 (info.damageTypes.Total() \u003E= 0f || IsGod()))\n\t\t{\n\t\t\tint arg = (int)info.damageTypes.GetMajorityDamageType();\n\t\t\tif (info.Weapon != null \u0026\u0026 info.damageTypes.Has(DamageType.Bullet))\n\t\t\t{\n\t\t\t\tBaseProjectile component = info.Weapon.GetComponent\u003CBaseProjectile\u003E();\n\t\t\t\tif (component != null \u0026\u0026 component.IsSilenced())\n\t\t\t\t{\n\t\t\t\t\targ = 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\tClientRPC(RpcTarget.PlayerAndSpectators(\u0022DirectionalDamage\u0022, this), info.PointStart, arg, Mathf.CeilToInt(info.damageTypes.Total()));\n\t\t\tif (info.damageTypes.Has(DamageType.BeeSting) \u0026\u0026 UnityEngine.Time.time \u003E timeSinceLastStungRPC \u002B 2f)\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022OnStungByBees\u0022, this));\n\t\t\t\ttimeSinceLastStungRPC = UnityEngine.Time.time;\n\t\t\t}\n\t\t}\n\t\tDeathBlow.From(info, out cachedNonSuicideHit);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBonusItemDrop(Item item, BasePlayer basePlayer, ItemContainer container)",
    "MethodSignature": "DropBonusItems(BaseEntity initiator, ItemContainer container)",
    "MethodSourseCode": "\n\tpublic override void DropBonusItems(BaseEntity initiator, ItemContainer container)\n\t{\n\t\tbase.DropBonusItems(initiator, container);\n\t\tif (initiator == null || container == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer = initiator as BasePlayer;\n\t\tif (basePlayer == null || scrapAmount \u003C= 0 || !(scrapDef != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = ((basePlayer.modifiers != null) ? (1f \u002B basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\n\t\tif (!(num \u003E 1f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\n\t\tfloat num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\n\t\tvariableValue \u002B= num2;\n\t\tint num3 = 0;\n\t\tif (variableValue \u003E= 1f)\n\t\t{\n\t\t\tnum3 = (int)variableValue;\n\t\t\tvariableValue -= (float)num3;\n\t\t}\n\t\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\n\t\tif (num3 \u003E 0)\n\t\t{\n\t\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\n\t\t\tif (item != null \u0026\u0026 Interface.CallHook(\u0022OnBonusItemDrop\u0022, item, basePlayer, container) == null)\n\t\t\t{\n\t\t\t\t(item.Drop(GetDropPosition() \u002B new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;\n\t\t\t\tInterface.CallHook(\u0022OnBonusItemDropped\u0022, item, basePlayer, container);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "LootContainer",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnEntityMarkHostile(BasePlayer basePlayer, float duration)",
    "MethodSignature": "MarkHostileFor(float duration)",
    "MethodSourseCode": "\n\tpublic override void MarkHostileFor(float duration = 60f)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntityMarkHostile\u0022, this, duration) == null)\n\t\t{\n\t\t\tdouble currentTimestamp = TimeEx.currentTimestamp;\n\t\t\tdouble val = currentTimestamp \u002B (double)duration;\n\t\t\tState.unHostileTimestamp = Math.Max(State.unHostileTimestamp, val);\n\t\t\tDirtyPlayerState();\n\t\t\tdouble num = Math.Max(State.unHostileTimestamp - currentTimestamp, 0.0);\n\t\t\tClientRPC(RpcTarget.Player(\u0022SetHostileLength\u0022, this), (float)num);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnProjectileRicochet(BasePlayer basePlayer, ProtoBuf.PlayerProjectileRicochet playerProjectileRicochet)",
    "MethodSignature": "OnProjectileRicochet(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.FromOwner(false)]\n\t[RPC_Server]\n\tpublic void OnProjectileRicochet(RPCMessage msg)\n\t{\n\t\tusing PlayerProjectileRicochet playerProjectileRicochet = msg.read.Proto\u003CPlayerProjectileRicochet\u003E();\n\t\tif (playerProjectileRicochet != null)\n\t\t{\n\t\t\tFiredProjectile value;\n\t\t\tif (playerProjectileRicochet.hitPosition.IsNaNOrInfinity() || playerProjectileRicochet.inVelocity.IsNaNOrInfinity() || playerProjectileRicochet.outVelocity.IsNaNOrInfinity() || playerProjectileRicochet.hitNormal.IsNaNOrInfinity() || float.IsNaN(playerProjectileRicochet.travelTime) || float.IsInfinity(playerProjectileRicochet.travelTime))\n\t\t\t{\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Contains NaN (\u0022 \u002B playerProjectileRicochet.projectileID \u002B \u0022)\u0022);\n\t\t\t}\n\t\t\telse if (!firedProjectiles.TryGetValue(playerProjectileRicochet.projectileID, out value))\n\t\t\t{\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Missing ID (\u0022 \u002B playerProjectileRicochet.projectileID \u002B \u0022)\u0022, logToAnalytics: false);\n\t\t\t}\n\t\t\telse if (value.firedTime \u003C UnityEngine.Time.realtimeSinceStartup - 8f)\n\t\t\t{\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Lifetime is zero (\u0022 \u002B playerProjectileRicochet.projectileID \u002B \u0022)\u0022);\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnProjectileRicochet\u0022, this, playerProjectileRicochet) == null)\n\t\t\t{\n\t\t\t\tvalue.ricochets\u002B\u002B;\n\t\t\t\tfiredProjectiles[playerProjectileRicochet.projectileID] = value;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnExperimentEnded(Workbench workbench)",
    "MethodSignature": "ExperimentComplete()",
    "MethodSourseCode": "\n\tpublic void ExperimentComplete()\n\t{\n\t\tItem experimentResourceItem = GetExperimentResourceItem();\n\t\tint scrapForExperiment = GetScrapForExperiment();\n\t\tif (pendingBlueprint == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Pending blueprint was null!\u0022);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnExperimentEnd\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (experimentResourceItem != null \u0026\u0026 experimentResourceItem.amount \u003E= scrapForExperiment \u0026\u0026 pendingBlueprint != null)\n\t\t{\n\t\t\texperimentResourceItem.UseItem(scrapForExperiment);\n\t\t\tItem item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);\n\t\t\titem.blueprintTarget = pendingBlueprint.itemid;\n\t\t\tcreatingBlueprint = true;\n\t\t\tif (!item.MoveToContainer(base.inventory, 0))\n\t\t\t{\n\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t}\n\t\t\tcreatingBlueprint = false;\n\t\t\tif (experimentSuccessEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t}\n\t\tSetFlag(Flags.On, b: false);\n\t\tpendingBlueprint = null;\n\t\tbase.inventory.SetLocked(isLocked: false);\n\t\tSendNetworkUpdate();\n\t\tInterface.CallHook(\u0022OnExperimentEnded\u0022, this);\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "CanAssignMission(BasePlayer assignee, BaseMission mission, IMissionProvider provider)",
    "MethodSignature": "AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)",
    "MethodSourseCode": "\n\tpublic static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)\n\t{\n\t\tif (!missionsenabled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!mission.IsEligableForMission(assignee, provider))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanAssignMission\u0022, assignee, mission, provider);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tint num = assignee.missions.FindIndexWith((MissionInstance i) =\u003E i.missionID, mission.id);\n\t\tMissionInstance missionInstance;\n\t\tint activeMission;\n\t\tif (num \u003E= 0)\n\t\t{\n\t\t\tmissionInstance = assignee.missions[num];\n\t\t\tactiveMission = num;\n\t\t\tmissionInstance.Reset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmissionInstance = Facepunch.Pool.Get\u003CMissionInstance\u003E();\n\t\t\tactiveMission = assignee.missions.Count;\n\t\t\tassignee.missions.Add(missionInstance);\n\t\t}\n\t\tmissionInstance.missionID = mission.id;\n\t\tmissionInstance.startTime = UnityEngine.Time.time;\n\t\tmissionInstance.providerID = provider.ProviderID();\n\t\tmissionInstance.status = MissionStatus.Active;\n\t\tmissionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];\n\t\tfor (int j = 0; j \u003C mission.objectives.Length; j\u002B\u002B)\n\t\t{\n\t\t\tmissionInstance.objectiveStatuses[j] = new MissionInstance.ObjectiveStatus();\n\t\t}\n\t\tmission.MissionStart(missionInstance, assignee);\n\t\tassignee.SetActiveMission(activeMission);\n\t\tassignee.MissionDirty();\n\t\tInterface.CallHook(\u0022OnMissionAssigned\u0022, mission, provider, assignee);\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseMission",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnStashExposed(StashContainer nearbyStashEntity, BasePlayer basePlayer)",
    "MethodSignature": "CheckStashRevealInvoke()",
    "MethodSourseCode": "\n\tprivate void CheckStashRevealInvoke()\n\t{\n\t\tfor (int i = 0; i \u003C nearbyStashes.Count; i\u002B\u002B)\n\t\t{\n\t\t\tNearbyStash nearbyStash = nearbyStashes[i];\n\t\t\tif (nearbyStash.Entity == null || nearbyStash.Entity.IsDestroyed)\n\t\t\t{\n\t\t\t\tnearbyStashes.RemoveAt(i);\n\t\t\t}\n\t\t\telse if (nearbyStash.Entity.IsHidden() \u0026\u0026 nearbyStash.Entity.PlayerInRange(this))\n\t\t\t{\n\t\t\t\tnearbyStash.LookingAtTime \u002B= StashContainer.PlayerDetectionTickRate;\n\t\t\t\tif (nearbyStash.LookingAtTime \u003E= nearbyStash.Entity.uncoverTime)\n\t\t\t\t{\n\t\t\t\t\tif (Interface.CallHook(\u0022CanSeeStash\u0022, this, nearbyStash.Entity) != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnearbyStash.Entity.SetHidden(isHidden: false);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);\n\t\t\t\t\tInterface.CallHook(\u0022OnStashExposed\u0022, nearbyStash.Entity, this);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnearbyStash.LookingAtTime = 0f;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnPlayerWantsMount(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "WantsMount(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void WantsMount(BasePlayer player)\n\t{\n\t\tif (!player.IsValid() || !player.CanInteract() || Interface.CallHook(\u0022OnPlayerWantsMount\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!DirectlyMountable())\n\t\t{\n\t\t\tBaseVehicle baseVehicle = VehicleParent();\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.WantsMount(player);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tAttemptMount(player);\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnWallpaperSet(BuildingBlock buildingBlock, ulong id, int side, float rotation)",
    "MethodSignature": "SetWallpaper(ulong id, int side, float rotation)",
    "MethodSourseCode": "\n\tpublic void SetWallpaper(ulong id, int side = 0, float rotation = 0f)\n\t{\n\t\tif (Interface.CallHook(\u0022OnWallpaperSet\u0022, this, id, side, rotation) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (side == 0)\n\t\t{\n\t\t\tif (HasWallpaper(side) \u0026\u0026 wallpaperID == id \u0026\u0026 wallpaperRotation == rotation)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twallpaperID = id;\n\t\t\twallpaperHealth = 100f;\n\t\t\twallpaperRotation = rotation;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (HasWallpaper(side) \u0026\u0026 wallpaperID2 == id \u0026\u0026 wallpaperRotation2 == rotation)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twallpaperID2 = id;\n\t\t\twallpaperHealth2 = 100f;\n\t\t\twallpaperRotation2 = rotation;\n\t\t}\n\t\tif (base.isServer)\n\t\t{\n\t\t\tSetConditionalModel(currentSkin.DetermineConditionalModelState(this));\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022RefreshSkin\u0022));\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityControl(AutoTurret autoTurret, ulong playerID)",
    "MethodSignature": "CanControl(ulong playerID)",
    "MethodSourseCode": "\n\tpublic virtual bool CanControl(ulong playerID)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnEntityControl\u0022, this, playerID);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (booting)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsPowered())\n\t\t{\n\t\t\treturn !PeacekeeperMode();\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnLootNetworkUpdate(PlayerLoot playerLoot)",
    "MethodSignature": "SendUpdate()",
    "MethodSourseCode": "\n\tprivate void SendUpdate()\n\t{\n\t\tisInvokingSendUpdate = false;\n\t\tif (!base.baseEntity.IsValid() || Interface.CallHook(\u0022OnLootNetworkUpdate\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing PlayerUpdateLoot playerUpdateLoot = Pool.Get\u003CPlayerUpdateLoot\u003E();\n\t\tif ((bool)entitySource \u0026\u0026 entitySource.net != null)\n\t\t{\n\t\t\tplayerUpdateLoot.entityID = entitySource.net.ID;\n\t\t}\n\t\tif (itemSource != null)\n\t\t{\n\t\t\tplayerUpdateLoot.itemID = itemSource.uid;\n\t\t}\n\t\tif (containers.Count \u003E 0)\n\t\t{\n\t\t\tplayerUpdateLoot.containers = Pool.Get\u003CList\u003CProtoBuf.ItemContainer\u003E\u003E();\n\t\t\tforeach (ItemContainer container in containers)\n\t\t\t{\n\t\t\t\tplayerUpdateLoot.containers.Add(container.Save());\n\t\t\t}\n\t\t}\n\t\tbase.baseEntity.ClientRPC(RpcTarget.Player(\u0022UpdateLoot\u0022, base.baseEntity), playerUpdateLoot);\n\t}\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnEntityLoaded(BaseNetworkable baseNetworkable, BaseNetworkable.LoadInfo info)",
    "MethodSignature": "Load(LoadInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void Load(LoadInfo info)\n\t{\n\t\tif (info.msg.baseNetworkable != null)\n\t\t{\n\t\t\tLoadInfo loadInfo = info;\n\t\t\tInterface.CallHook(\u0022OnEntityLoaded\u0022, this, info);\n\t\t\tProtoBuf.BaseNetworkable baseNetworkable = loadInfo.msg.baseNetworkable;\n\t\t\tif (prefabID != baseNetworkable.prefabID)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022Prefab IDs don\u0027t match! \u0022 \u002B prefabID \u002B \u0022/\u0022 \u002B baseNetworkable.prefabID \u002B \u0022 -\u003E \u0022 \u002B base.gameObject, base.gameObject);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnRunPlayerMetabolism(PlayerMetabolism playerMetabolism, BaseCombatEntity ownerEntity, float delta)",
    "MethodSignature": "RunMetabolism(BaseCombatEntity ownerEntity, float delta)",
    "MethodSourseCode": "\n\tprotected override void RunMetabolism(BaseCombatEntity ownerEntity, float delta)\n\t{\n\t\tif (Interface.CallHook(\u0022OnRunPlayerMetabolism\u0022, this, ownerEntity, delta) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (owner.IsConnected)\n\t\t{\n\t\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\t\tfloat num = owner.currentTemperature;\n\t\t\tfloat fTarget = owner.currentComfort;\n\t\t\tUpdateWorkbenchFlags();\n\t\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, owner.InSafeZone());\n\t\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.NoRespawnZone, owner.InNoRespawnZone());\n\t\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.ModifyClan, Clan.editsRequireClanTable \u0026\u0026 owner.CanModifyClan());\n\t\t\tbool num2 = activeGameMode == null || activeGameMode.allowTemperature;\n\t\t\tif (owner.IsInTutorial)\n\t\t\t{\n\t\t\t\tnum = 25f;\n\t\t\t}\n\t\t\tif (num2)\n\t\t\t{\n\t\t\t\tfloat num3 = num \u002B GetCoreTempAdjustment() - DeltaWet() * 34f;\n\t\t\t\tfloat num4 = Mathf.Clamp(owner.baseProtection.amounts[18] * 1.5f, -1f, 1f);\n\t\t\t\tfloat num5 = Mathf.InverseLerp(20f, -50f, num);\n\t\t\t\tfloat num6 = Mathf.InverseLerp(20f, 30f, num);\n\t\t\t\tfloat fTarget2 = Mathf.Clamp(num3 \u002B num5 * 70f * num4 \u002B num6 * 10f * Mathf.Abs(num4) \u002B heartrate.value * 5f, GetCoreTempMin(), GetCoreTempMax());\n\t\t\t\ttemperature.MoveTowards(fTarget2, delta * 5f);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemperature.value = 25f;\n\t\t\t}\n\t\t\tif (temperature.value \u003E= 40f)\n\t\t\t{\n\t\t\t\tfTarget = 0f;\n\t\t\t}\n\t\t\tcomfort.MoveTowards(fTarget, delta / 5f);\n\t\t\tfloat num7 = 0.6f \u002B 0.4f * comfort.value;\n\t\t\tif (calories.value \u003E 100f \u0026\u0026 owner.healthFraction \u003C num7 \u0026\u0026 radiation_poison.Fraction() \u003C 0.25f \u0026\u0026 owner.SecondsSinceAttacked \u003E 10f \u0026\u0026 !SignificantBleeding() \u0026\u0026 temperature.value \u003E= 10f \u0026\u0026 hydration.value \u003E 40f)\n\t\t\t{\n\t\t\t\tfloat num8 = Mathf.InverseLerp(calories.min, calories.max, calories.value);\n\t\t\t\tfloat num9 = 5f;\n\t\t\t\tfloat num10 = num9 * owner.MaxHealth() * 0.8f / 600f;\n\t\t\t\tnum10 \u002B= num10 * num8 * 0.5f;\n\t\t\t\tfloat num11 = num10 / num9;\n\t\t\t\tnum11 \u002B= num11 * comfort.value * 6f;\n\t\t\t\townerEntity.Heal(num11 * delta);\n\t\t\t\tcalories.Subtract(num10 * delta);\n\t\t\t\thydration.Subtract(num10 * delta * 0.2f);\n\t\t\t}\n\t\t\tfloat num12 = owner.estimatedSpeed2D / owner.GetMaxSpeed() * 0.75f;\n\t\t\tfloat fTarget3 = Mathf.Clamp(0.05f \u002B num12, 0f, 1f);\n\t\t\theartrate.MoveTowards(fTarget3, delta * 0.1f);\n\t\t\tif (!owner.IsGod())\n\t\t\t{\n\t\t\t\tfloat num13 = heartrate.Fraction() * 0.375f;\n\t\t\t\tcalories.MoveTowards(0f, delta * num13);\n\t\t\t\tfloat num14 = 1f / 120f;\n\t\t\t\tnum14 \u002B= Mathf.InverseLerp(40f, 60f, temperature.value) * (1f / 12f);\n\t\t\t\tnum14 \u002B= heartrate.value * (1f / 15f);\n\t\t\t\thydration.MoveTowards(0f, delta * num14);\n\t\t\t}\n\t\t\tbool b = hydration.Fraction() \u003C= 0f || radiation_poison.value \u003E= 100f;\n\t\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.NoSprint, b);\n\t\t\tif (temperature.value \u003E 40f)\n\t\t\t{\n\t\t\t\thydration.Add(Mathf.InverseLerp(40f, 200f, temperature.value) * delta * -1f);\n\t\t\t}\n\t\t\tif (temperature.value \u003C 10f)\n\t\t\t{\n\t\t\t\tfloat num15 = Mathf.InverseLerp(20f, -100f, temperature.value);\n\t\t\t\theartrate.MoveTowards(Mathf.Lerp(0.2f, 1f, num15), delta * 2f * num15);\n\t\t\t}\n\t\t\tfloat f = 0f;\n\t\t\tfloat f2 = 0f;\n\t\t\tif (owner.IsOutside(owner.eyes.position))\n\t\t\t{\n\t\t\t\tf = Climate.GetRain(owner.eyes.position) * Weather.wetness_rain;\n\t\t\t\tf2 = Climate.GetSnow(owner.eyes.position) * Weather.wetness_snow;\n\t\t\t}\n\t\t\tbool flag = owner.baseProtection.amounts[4] \u003E 0f;\n\t\t\tfloat currentEnvironmentalWetness = owner.currentEnvironmentalWetness;\n\t\t\tcurrentEnvironmentalWetness = Mathf.Clamp(currentEnvironmentalWetness, 0f, 0.8f);\n\t\t\tfloat num16 = owner.WaterFactor();\n\t\t\tif (!flag \u0026\u0026 num16 \u003E 0f)\n\t\t\t{\n\t\t\t\twetness.value = Mathf.Max(wetness.value, Mathf.Clamp(num16, wetness.min, wetness.max));\n\t\t\t}\n\t\t\tfloat num17 = Mathx.Max(wetness.value, f, f2, currentEnvironmentalWetness);\n\t\t\tnum17 = Mathf.Min(num17, flag ? 0f : num17);\n\t\t\twetness.MoveTowards(num17, delta * 0.05f);\n\t\t\tif (num16 \u003C wetness.value \u0026\u0026 currentEnvironmentalWetness \u003C= 0f)\n\t\t\t{\n\t\t\t\twetness.MoveTowards(0f, delta * 0.2f * Mathf.InverseLerp(0f, 100f, num));\n\t\t\t}\n\t\t\tpoison.MoveTowards(0f, delta * (5f / 9f));\n\t\t\tif (wetness.Fraction() \u003E 0.4f \u0026\u0026 owner.estimatedSpeed \u003E 0.25f \u0026\u0026 radiation_level.Fraction() == 0f)\n\t\t\t{\n\t\t\t\tradiation_poison.Subtract(radiation_poison.value * 0.2f * wetness.Fraction() * delta * 0.2f);\n\t\t\t}\n\t\t\tif (ConVar.Server.radiation)\n\t\t\t{\n\t\t\t\tif (!owner.IsGod())\n\t\t\t\t{\n\t\t\t\t\tfloat radiationAfterProtection = Radiation.GetRadiationAfterProtection(owner.modifiers.GetValue(Modifier.ModifierType.Radiation), ownerEntity.RadiationProtection());\n\t\t\t\t\tradiation_level.value = owner.radiationLevel \u002B radiationAfterProtection;\n\t\t\t\t\tif (radiation_level.value \u003E 0f)\n\t\t\t\t\t{\n\t\t\t\t\t\tradiation_poison.Add(radiation_level.value * delta);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (radiation_level.value \u003E 0f)\n\t\t\t\t{\n\t\t\t\t\tradiation_level.value = 0f;\n\t\t\t\t\tradiation_poison.value = 0f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pending_health.value \u003E 0f)\n\t\t\t{\n\t\t\t\tfloat num18 = 1f \u002B owner.modifiers.GetValue(Modifier.ModifierType.MetabolismBooster);\n\t\t\t\tfloat num19 = Mathf.Min(1f * delta * num18, pending_health.value);\n\t\t\t\townerEntity.Heal(num19);\n\t\t\t\tif (ownerEntity.healthFraction == 1f)\n\t\t\t\t{\n\t\t\t\t\tpending_health.value = 0f;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpending_health.Subtract(num19);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfloat num20 = owner.AirFactor();\n\t\tfloat num21 = ((num20 \u003E oxygen.value) ? 1f : 0.1f);\n\t\toxygen.MoveTowards(num20, delta * num21);\n\t}\n",
    "ClassName": "PlayerMetabolism",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFindSpawnPoint(BasePlayer forPlayer, ulong teamId)",
    "MethodSignature": "FindSpawnPoint(BasePlayer forPlayer, ulong teamId)",
    "MethodSourseCode": "\n\tpublic static BasePlayer.SpawnPoint FindSpawnPoint(BasePlayer forPlayer = null, ulong teamId = 0uL)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnFindSpawnPoint\u0022, forPlayer, teamId);\n\t\tif (obj is BasePlayer.SpawnPoint)\n\t\t{\n\t\t\treturn (BasePlayer.SpawnPoint)obj;\n\t\t}\n\t\tbool flag = false;\n\t\tif (forPlayer != null \u0026\u0026 forPlayer.IsInTutorial)\n\t\t{\n\t\t\tTutorialIsland currentTutorialIsland = forPlayer.GetCurrentTutorialIsland();\n\t\t\tif (currentTutorialIsland != null)\n\t\t\t{\n\t\t\t\tBasePlayer.SpawnPoint spawnPoint = new BasePlayer.SpawnPoint();\n\t\t\t\tif (forPlayer.CurrentTutorialAllowance \u003E BasePlayer.TutorialItemAllowance.Level1_HatchetPickaxe)\n\t\t\t\t{\n\t\t\t\t\tspawnPoint.pos = currentTutorialIsland.MidMissionSpawnPoint.position;\n\t\t\t\t\tspawnPoint.rot = currentTutorialIsland.MidMissionSpawnPoint.rotation;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tspawnPoint.pos = currentTutorialIsland.InitialSpawnPoint.position;\n\t\t\t\t\tspawnPoint.rot = currentTutorialIsland.InitialSpawnPoint.rotation;\n\t\t\t\t}\n\t\t\t\treturn spawnPoint;\n\t\t\t}\n\t\t}\n\t\tBaseGameMode baseGameMode = Gamemode();\n\t\tif ((bool)baseGameMode \u0026\u0026 baseGameMode.useCustomSpawns)\n\t\t{\n\t\t\tBasePlayer.SpawnPoint playerSpawn = baseGameMode.GetPlayerSpawn(forPlayer);\n\t\t\tif (playerSpawn != null)\n\t\t\t{\n\t\t\t\treturn playerSpawn;\n\t\t\t}\n\t\t}\n\t\tif (SingletonComponent\u003CSpawnHandler\u003E.Instance != null \u0026\u0026 !flag)\n\t\t{\n\t\t\tBasePlayer.SpawnPoint spawnPointForTeam = SpawnHandler.GetSpawnPointForTeam(teamId);\n\t\t\tif (spawnPointForTeam != null)\n\t\t\t{\n\t\t\t\tspawnPointForTeam.isProcedualSpawn = true;\n\t\t\t\treturn spawnPointForTeam;\n\t\t\t}\n\t\t\tBasePlayer.SpawnPoint spawnPoint2 = SpawnHandler.GetSpawnPoint();\n\t\t\tif (spawnPoint2 != null)\n\t\t\t{\n\t\t\t\tspawnPoint2.isProcedualSpawn = true;\n\t\t\t\treturn spawnPoint2;\n\t\t\t}\n\t\t}\n\t\tBasePlayer.SpawnPoint spawnPoint3 = new BasePlayer.SpawnPoint();\n\t\tif (forPlayer != null \u0026\u0026 forPlayer.IsInTutorial)\n\t\t{\n\t\t\tTutorialIsland currentTutorialIsland2 = forPlayer.GetCurrentTutorialIsland();\n\t\t\tif (currentTutorialIsland2 != null)\n\t\t\t{\n\t\t\t\tspawnPoint3.pos = currentTutorialIsland2.InitialSpawnPoint.position;\n\t\t\t\tspawnPoint3.rot = currentTutorialIsland2.InitialSpawnPoint.rotation;\n\t\t\t\treturn spawnPoint3;\n\t\t\t}\n\t\t}\n\t\tGameObject[] array = GameObject.FindGameObjectsWithTag(\u0022spawnpoint\u0022);\n\t\tif (array.Length != 0)\n\t\t{\n\t\t\tGameObject gameObject = array[UnityEngine.Random.Range(0, array.Length)];\n\t\t\tspawnPoint3.pos = gameObject.transform.position;\n\t\t\tspawnPoint3.rot = gameObject.transform.rotation;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUnityEngine.Debug.Log(\u0022Couldn\u0027t find an appropriate spawnpoint for the player - so spawning at camera\u0022);\n\t\t\tif (MainCamera.mainCamera != null)\n\t\t\t{\n\t\t\t\tspawnPoint3.pos = MainCamera.position;\n\t\t\t\tspawnPoint3.rot = MainCamera.rotation;\n\t\t\t}\n\t\t}\n\t\tif (UnityEngine.Physics.Raycast(new Ray(spawnPoint3.pos, Vector3.down), out var hitInfo, 32f, 1537286401))\n\t\t{\n\t\t\tspawnPoint3.pos = hitInfo.point;\n\t\t}\n\t\treturn spawnPoint3;\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanBeHomingTargeted(CH47Helicopter cH47Helicopter)",
    "MethodSignature": "IsValidHomingTarget()",
    "MethodSourseCode": "\n\tpublic override bool IsValidHomingTarget()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeHomingTargeted\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "CH47Helicopter",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDecayHeal(DecayEntity decayEntity)",
    "MethodSignature": "OnDecay(Decay decay, float decayDeltaTime)",
    "MethodSourseCode": "\n\tpublic virtual void OnDecay(Decay decay, float decayDeltaTime)\n\t{\n\t\tlastDecayTick = UnityEngine.Time.time;\n\t\tif (HasParent() || !decay.ShouldDecay(this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = decayDeltaTime * ConVar.Decay.scale;\n\t\tif (ConVar.Decay.upkeep)\n\t\t{\n\t\t\tupkeepTimer \u002B= num;\n\t\t\tif (upkeepTimer \u003E 0f)\n\t\t\t{\n\t\t\t\tBuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();\n\t\t\t\tif (buildingPrivilege != null)\n\t\t\t\t{\n\t\t\t\t\tupkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (upkeepTimer \u003C 1f)\n\t\t\t{\n\t\t\t\tif (base.healthFraction \u003C 1f \u0026\u0026 GetEntityHealScale() \u003E 0f \u0026\u0026 base.SecondsSinceAttacked \u003E 600f \u0026\u0026 Interface.CallHook(\u0022OnDecayHeal\u0022, this) == null)\n\t\t\t\t{\n\t\t\t\t\tfloat num2 = decayDeltaTime / GetEntityDecayDuration() * GetEntityHealScale();\n\t\t\t\t\tHeal(MaxHealth() * num2);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tupkeepTimer = 1f;\n\t\t}\n\t\tdecayTimer \u002B= num;\n\t\tif (decayTimer \u003C GetEntityDecayDelay())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022DecayTick\u0022))\n\t\t{\n\t\t\tfloat num3 = 1f;\n\t\t\tif (ConVar.Decay.upkeep)\n\t\t\t{\n\t\t\t\tif (!BypassInsideDecayMultiplier \u0026\u0026 !IsOutside())\n\t\t\t\t{\n\t\t\t\t\tnum3 *= ConVar.Decay.upkeep_inside_decay_scale;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C decayPoints.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tDecayPoint decayPoint = decayPoints[i];\n\t\t\t\t\tif (decayPoint.IsOccupied(this))\n\t\t\t\t\t{\n\t\t\t\t\t\tnum3 -= decayPoint.protection;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnDecayDamage\u0022, this) == null \u0026\u0026 num3 \u003E 0f)\n\t\t\t{\n\t\t\t\tfloat num4 = num / GetEntityDecayDuration() * MaxHealth();\n\t\t\t\tHurt(num4 * num3 * decayVariance, DamageType.Decay);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DecayEntity",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnTeamCreated(BasePlayer basePlayer, RelationshipManager.PlayerTeam playerTeam)",
    "MethodSignature": "trycreateteam(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void trycreateteam(ConsoleSystem.Arg arg)\n\t{\n\t\tif (maxTeamSize == 0)\n\t\t{\n\t\t\targ.ReplyWith(\u0022Teams are disabled on this server\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer.currentTeam == 0L \u0026\u0026 Interface.CallHook(\u0022OnTeamCreate\u0022, basePlayer) == null)\n\t\t{\n\t\t\tPlayerTeam playerTeam = ServerInstance.CreateTeam();\n\t\t\tPlayerTeam playerTeam2 = playerTeam;\n\t\t\tplayerTeam2.teamLeader = basePlayer.userID;\n\t\t\tplayerTeam2.AddPlayer(basePlayer);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnTeamChanged(\u0022created\u0022, playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);\n\t\t\tInterface.CallHook(\u0022OnTeamCreated\u0022, basePlayer, playerTeam);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnServerMessage(string message, string username, string color, ulong userid)",
    "MethodSignature": "Broadcast(string message, string username, string color, ulong userid)",
    "MethodSourseCode": "\n\tpublic static void Broadcast(string message, string username = \u0022SERVER\u0022, string color = \u0022#eee\u0022, ulong userid = 0uL)\n\t{\n\t\tif (Interface.CallHook(\u0022OnServerMessage\u0022, message, username, color, userid) == null)\n\t\t{\n\t\t\tstring text = username.EscapeRichText();\n\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 2, 0, \u0022\u003Ccolor=\u0022 \u002B color \u002B \u0022\u003E\u0022 \u002B text \u002B \u0022\u003C/color\u003E \u0022 \u002B message);\n\t\t\tChatEntry ce = default(ChatEntry);\n\t\t\tce.Channel = ChatChannel.Server;\n\t\t\tce.Message = message;\n\t\t\tce.UserId = userid.ToString();\n\t\t\tce.Username = username;\n\t\t\tce.Color = color;\n\t\t\tce.Time = Epoch.Current;\n\t\t\tRecord(ce);\n\t\t}\n\t}\n",
    "ClassName": "Chat",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFrankensteinPetSleep(FrankensteinPet frankensteinPet, FrankensteinTable frankensteinTable, BasePlayer owner)",
    "MethodSignature": "SleepFrankenstein(BasePlayer owner)",
    "MethodSourseCode": "\n\tprivate void SleepFrankenstein(BasePlayer owner)\n\t{\n\t\tif (IsInventoryEmpty() \u0026\u0026 !(owner == null) \u0026\u0026 !(owner.PetEntity == null))\n\t\t{\n\t\t\tFrankensteinPet frankensteinPet = owner.PetEntity as FrankensteinPet;\n\t\t\tif (!(frankensteinPet == null) \u0026\u0026 !(Vector3.Distance(base.transform.position, frankensteinPet.transform.position) \u003E= 5f) \u0026\u0026 Interface.CallHook(\u0022OnFrankensteinPetSleep\u0022, frankensteinPet, this, owner) == null)\n\t\t\t{\n\t\t\t\tReturnFrankensteinItems(frankensteinPet);\n\t\t\t\tItemManager.DoRemoves();\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tfrankensteinPet.Kill();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "FrankensteinTable",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanDemolish(BasePlayer player, DecayEntity decayEntity)",
    "MethodSignature": "CanDemolish(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanDemolish(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanDemolish\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (IsDemolishSupported \u0026\u0026 IsDemolishable())\n\t\t{\n\t\t\treturn HasDemolishPrivilege(player);\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "DecayEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanBeAwardedAdventGift(AdventCalendar adventCalendar, BasePlayer player)",
    "MethodSignature": "WasAwardedTodaysGift(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool WasAwardedTodaysGift(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeAwardedAdventGift\u0022, this, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn !(bool)obj;\n\t\t}\n\t\tif (!playerRewardHistory.ContainsKey(player.userID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tDateTime now = DateTime.Now;\n\t\tif (((overrideAdventCalendarMonth \u003E 0) ? overrideAdventCalendarMonth : now.Month) != startMonth)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tint num = ((overrideAdventCalendarDay \u003E 0) ? overrideAdventCalendarDay : now.Day) - startDay;\n\t\tif (num \u003C 0 || num \u003E= days.Length)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (playerRewardHistory[player.userID].Contains(num))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "AdventCalendar",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemDespawn(Item item)",
    "MethodSignature": "IdleDestroy()",
    "MethodSourseCode": "\n\tpublic void IdleDestroy()\n\t{\n\t\tInterface.CallHook(\u0022OnItemDespawn\u0022, item);\n\t\tFacepunch.Rust.Analytics.Azure.OnItemDespawn(this, item, (int)DropReason, DroppedBy);\n\t\tif (item != null)\n\t\t{\n\t\t\tBuriedItems.Instance.Register(item, base.transform.position);\n\t\t}\n\t\tDestroyItem();\n\t\tKill();\n\t}\n",
    "ClassName": "DroppedItem",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCupboardClearList(VehiclePrivilege vehiclePrivilege, BasePlayer rpcPlayer)",
    "MethodSignature": "ClearList(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void ClearList(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 IsDriver(rpc.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardClearList\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.Clear();\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "VehiclePrivilege",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnRackedWeaponMounted(Item item, BasePlayer player, WeaponRack weaponRack)",
    "MethodSignature": "MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate)",
    "MethodSourseCode": "\n\tprivate bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate = true)\n\t{\n\t\tif (item == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnRackedWeaponMount\u0022, item, player, this);\n\t\tif (obj != null)\n\t\t{\n\t\t\tif (!(obj is bool))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tint itemid = item.info.itemid;\n\t\tWorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);\n\t\tif (forItemDef == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022no rackmount config\u0022);\n\t\t\treturn false;\n\t\t}\n\t\tif (!CanAcceptWeaponType(forItemDef))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!GridCellsFree(forItemDef, gridCellIndex, rotation, null))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.MoveToContainer(base.inventory, -1, allowStack: false) \u0026\u0026 item.position \u003E= 0 \u0026\u0026 item.position \u003C gridSlots.Length)\n\t\t{\n\t\t\tWeaponRackSlot slot = gridSlots[item.position];\n\t\t\tSetSlotItem(slot, item, gridCellIndex, rotation);\n\t\t\tSetupSlot(slot);\n\t\t\tif (player != null)\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022PlayMountSound\u0022, player), itemid);\n\t\t\t}\n\t\t}\n\t\tif (sendUpdate)\n\t\t{\n\t\t\tItemManager.DoRemoves();\n\t\t\tSendNetworkUpdateImmediate();\n\t\t}\n\t\tInterface.CallHook(\u0022OnRackedWeaponMounted\u0022, item, player, this);\n\t\treturn true;\n\t}\n",
    "ClassName": "WeaponRack",
    "HookLineInvoke": 50
  },
  {
    "HookSignature": "OnNpcEquipWeapon(ScientistNPC scientistNPC, Item item)",
    "MethodSignature": "EquipWeapon(bool skipDeployDelay)",
    "MethodSourseCode": "\n\tpublic override void EquipWeapon(bool skipDeployDelay = false)\n\t{\n\t\tbase.EquipWeapon(skipDeployDelay);\n\t\tHeldEntity heldEntity = GetHeldEntity();\n\t\tif (!(heldEntity != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item = heldEntity.GetItem();\n\t\tif (item == null || item.contents == null || Interface.CallHook(\u0022OnNpcEquipWeapon\u0022, this, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Random.Range(0, 3) == 0)\n\t\t{\n\t\t\tItem item2 = ItemManager.CreateByName(\u0022weapon.mod.flashlight\u0022, 1, 0uL);\n\t\t\tif (!item2.MoveToContainer(item.contents))\n\t\t\t{\n\t\t\t\titem2.Remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlightsOn = false;\n\t\t\tInvokeRandomized(base.LightCheck, 0f, 30f, 5f);\n\t\t\tLightCheck();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tItem item3 = ItemManager.CreateByName(\u0022weapon.mod.lasersight\u0022, 1, 0uL);\n\t\t\tif (!item3.MoveToContainer(item.contents))\n\t\t\t{\n\t\t\t\titem3.Remove();\n\t\t\t}\n\t\t\tLightToggle();\n\t\t\tlightsOn = true;\n\t\t}\n\t}\n",
    "ClassName": "ScientistNPC",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnTeamRejectInvite(BasePlayer basePlayer, RelationshipManager.PlayerTeam playerTeam)",
    "MethodSignature": "rejectinvite(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void rejectinvite(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (!(basePlayer == null) \u0026\u0026 basePlayer.currentTeam == 0L)\n\t\t{\n\t\t\tulong uLong = arg.GetULong(0, 0uL);\n\t\t\tPlayerTeam playerTeam = ServerInstance.FindTeam(uLong);\n\t\t\tif (playerTeam == null)\n\t\t\t{\n\t\t\t\tbasePlayer.ClearPendingInvite();\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnTeamRejectInvite\u0022, basePlayer, playerTeam) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.RejectInvite(basePlayer);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnItemUse(Item item, int amountToConsume)",
    "MethodSignature": "UseItem(int amountToConsume)",
    "MethodSourseCode": "\n\tpublic void UseItem(int amountToConsume = 1)\n\t{\n\t\tif (amountToConsume \u003E 0)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnItemUse\u0022, this, amountToConsume);\n\t\t\tif (obj is int)\n\t\t\t{\n\t\t\t\tamountToConsume = (int)obj;\n\t\t\t}\n\t\t\tamount -= amountToConsume;\n\t\t\tReduceItemOwnership(amountToConsume);\n\t\t\tif (amount \u003C= 0)\n\t\t\t{\n\t\t\t\tamount = 0;\n\t\t\t\tRemove();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMarkDirty();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanSpectateTarget(BasePlayer basePlayer, string strName)",
    "MethodSignature": "UpdateSpectateTarget(string strName)",
    "MethodSourseCode": "\n\tpublic void UpdateSpectateTarget(string strName)\n\t{\n\t\tif (Interface.CallHook(\u0022CanSpectateTarget\u0022, this, strName) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tspectateFilter = strName;\n\t\tIEnumerable\u003CBaseEntity\u003E enumerable = null;\n\t\tif (spectateFilter.StartsWith(\u0022@\u0022))\n\t\t{\n\t\t\tstring filter = spectateFilter.Substring(1);\n\t\t\tenumerable = (from x in BaseNetworkable.serverEntities\n\t\t\t\twhere x.name.Contains(filter, CompareOptions.IgnoreCase)\n\t\t\t\twhere x != this\n\t\t\t\tselect x).Cast\u003CBaseEntity\u003E();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tIEnumerable\u003CBasePlayer\u003E source = activePlayerList.Where((BasePlayer x) =\u003E !x.IsSpectating() \u0026\u0026 !x.IsDead() \u0026\u0026 !x.IsSleeping());\n\t\t\tif (strName.Length \u003E 0)\n\t\t\t{\n\t\t\t\tsource = from x in source\n\t\t\t\t\twhere x.displayName.Contains(spectateFilter, CompareOptions.IgnoreCase) || x.UserIDString.Contains(spectateFilter)\n\t\t\t\t\twhere x != this\n\t\t\t\t\tselect x;\n\t\t\t}\n\t\t\tsource = source.OrderBy((BasePlayer x) =\u003E x.displayName);\n\t\t\tenumerable = source.Cast\u003CBaseEntity\u003E();\n\t\t}\n\t\tBaseEntity[] array = enumerable.ToArray();\n\t\tif (array.Length == 0)\n\t\t{\n\t\t\tChatMessage(\u0022No valid spectate targets!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = array[SpectateOffset % array.Length];\n\t\tif (baseEntity != null)\n\t\t{\n\t\t\tSpectatePlayer(baseEntity);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPoweredLightsPointAdd(PoweredLightsDeployer poweredLightsDeployer, BasePlayer player, UnityEngine.Vector3 vector, UnityEngine.Vector3 vector2)",
    "MethodSignature": "AddPoint(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server]\n\tpublic void AddPoint(RPCMessage msg)\n\t{\n\t\tVector3 vector = msg.read.Vector3();\n\t\tVector3 vector2 = msg.read.Vector3();\n\t\tfloat num = msg.read.Float();\n\t\tBasePlayer player = msg.player;\n\t\tif (vector.IsNaNOrInfinity() || vector2.IsNaNOrInfinity() || num.IsNaNOrInfinity() || GetItem() == null || GetItem().amount \u003C 1 || !IsVisible(vector) || !CanPlayerUse(player) || Vector3.Distance(vector, player.eyes.position) \u003E maxPlaceDistance || !CheckValidPlacement(vector, 0.1f, 10551297) || Interface.CallHook(\u0022OnPoweredLightsPointAdd\u0022, this, player, vector, vector2) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num2 = 1;\n\t\tif (active == null)\n\t\t{\n\t\t\tAdvancedChristmasLights component = GameManager.server.CreateEntity(poweredLightsPrefab.resourcePath, vector, Quaternion.LookRotation(vector2, player.eyes.HeadUp())).GetComponent\u003CAdvancedChristmasLights\u003E();\n\t\t\tcomponent.Spawn();\n\t\t\tactive = component;\n\t\t\tnum2 = 1;\n\t\t\tif (player.IsInCreativeMode \u0026\u0026 Creative.unlimitedIo)\n\t\t\t{\n\t\t\t\tnum2 = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (active.IsFinalized())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfloat a = 0f;\n\t\t\tVector3 vector3 = active.transform.position;\n\t\t\tif (active.points.Count \u003E 0)\n\t\t\t{\n\t\t\t\tvector3 = active.points[active.points.Count - 1].point;\n\t\t\t\ta = Vector3.Distance(vector, vector3);\n\t\t\t}\n\t\t\ta = Mathf.Max(a, lengthPerAmount);\n\t\t\tfloat num3 = (float)GetItem().amount * lengthPerAmount;\n\t\t\tif (player.IsInCreativeMode \u0026\u0026 Creative.unlimitedIo)\n\t\t\t{\n\t\t\t\tnum3 = 200f;\n\t\t\t}\n\t\t\tif (a \u003E num3)\n\t\t\t{\n\t\t\t\ta = num3;\n\t\t\t\tvector = vector3 \u002B Vector3Ex.Direction(vector, vector3) * a;\n\t\t\t}\n\t\t\ta = Mathf.Min(num3, a);\n\t\t\tnum2 = Mathf.CeilToInt(a / lengthPerAmount);\n\t\t\tif (player.IsInCreativeMode \u0026\u0026 Creative.unlimitedIo)\n\t\t\t{\n\t\t\t\tnum2 = 0;\n\t\t\t}\n\t\t}\n\t\tactive.AddPoint(vector, vector2, num);\n\t\tSetFlag(Flags.Reserved8, active != null);\n\t\tint iAmount = num2;\n\t\tUseItemAmount(iAmount);\n\t\tactive.AddLengthUsed(num2);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "PoweredLightsDeployer",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnCrateSpawned(BradleyAPC bradleyAPC, BaseEntity baseEntity2)",
    "MethodSignature": "OnDied(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnDied(HitInfo info)\n\t{\n\t\tif (base.isClient || Interface.CallHook(\u0022OnEntityDestroy\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tCreateExplosionMarker(10f);\n\t\tEffect.server.Run(explosionEffect.resourcePath, mainTurretEyePos.transform.position, Vector3.up, null, broadcast: true);\n\t\tVector3 zero = Vector3.zero;\n\t\tGameObject gibSource = servergibs.Get().GetComponent\u003CServerGib\u003E()._gibSource;\n\t\tList\u003CServerGib\u003E list = ServerGib.CreateGibs(servergibs.resourcePath, base.gameObject, gibSource, zero, 3f);\n\t\tfor (int i = 0; i \u003C 12 - maxCratesToSpawn; i\u002B\u002B)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, base.transform.position, base.transform.rotation);\n\t\t\tif (!baseEntity)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfloat minInclusive = 3f;\n\t\t\tfloat maxInclusive = 10f;\n\t\t\tVector3 onUnitSphere = UnityEngine.Random.onUnitSphere;\n\t\t\tbaseEntity.transform.position = base.transform.position \u002B new Vector3(0f, 1.5f, 0f) \u002B onUnitSphere * UnityEngine.Random.Range(-4f, 4f);\n\t\t\tCollider component = baseEntity.GetComponent\u003CCollider\u003E();\n\t\t\tbaseEntity.Spawn();\n\t\t\tbaseEntity.SetVelocity(zero \u002B onUnitSphere * UnityEngine.Random.Range(minInclusive, maxInclusive));\n\t\t\tforeach (ServerGib item in list)\n\t\t\t{\n\t\t\t\tUnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j \u003C maxCratesToSpawn; j\u002B\u002B)\n\t\t{\n\t\t\tVector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;\n\t\t\tonUnitSphere2.y = 0f;\n\t\t\tonUnitSphere2.Normalize();\n\t\t\tVector3 pos = base.transform.position \u002B new Vector3(0f, 1.5f, 0f) \u002B onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);\n\t\t\tBaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));\n\t\t\tbaseEntity2.Spawn();\n\t\t\tLootContainer lootContainer = baseEntity2 as LootContainer;\n\t\t\tif ((bool)lootContainer)\n\t\t\t{\n\t\t\t\tlootContainer.Invoke(lootContainer.RemoveMe, 1800f);\n\t\t\t}\n\t\t\tCollider component2 = baseEntity2.GetComponent\u003CCollider\u003E();\n\t\t\tRigidbody rigidbody = baseEntity2.gameObject.AddComponent\u003CRigidbody\u003E();\n\t\t\trigidbody.useGravity = true;\n\t\t\trigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;\n\t\t\trigidbody.mass = 2f;\n\t\t\trigidbody.interpolation = RigidbodyInterpolation.Interpolate;\n\t\t\trigidbody.velocity = zero \u002B onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);\n\t\t\trigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);\n\t\t\trigidbody.drag = 0.5f * (rigidbody.mass / 5f);\n\t\t\trigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);\n\t\t\tFireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;\n\t\t\tif ((bool)fireBall)\n\t\t\t{\n\t\t\t\tfireBall.SetParent(baseEntity2);\n\t\t\t\tfireBall.Spawn();\n\t\t\t\tfireBall.GetComponent\u003CRigidbody\u003E().isKinematic = true;\n\t\t\t\tfireBall.GetComponent\u003CCollider\u003E().enabled = false;\n\t\t\t}\n\t\t\tbaseEntity2.SendMessage(\u0022SetLockingEnt\u0022, fireBall.gameObject, SendMessageOptions.DontRequireReceiver);\n\t\t\tforeach (ServerGib item2 in list)\n\t\t\t{\n\t\t\t\tUnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnCrateSpawned\u0022, this, baseEntity2);\n\t\t}\n\t\tKillSpawnedScientists();\n\t\tif (info != null \u0026\u0026 info.InitiatorPlayer != null \u0026\u0026 info.InitiatorPlayer.serverClan != null)\n\t\t{\n\t\t\tinfo.InitiatorPlayer.AddClanScore(ClanScoreEventType.DestroyedBradley);\n\t\t}\n\t\tbase.OnDied(info);\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 67
  },
  {
    "HookSignature": "OnPhoneNameUpdate(PhoneController phoneController, string text, BasePlayer msgPlayer)",
    "MethodSignature": "UpdatePhoneName(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void UpdatePhoneName(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (!(msg.player != currentPlayer))\n\t\t{\n\t\t\tstring text = msg.read.String();\n\t\t\tif (text.Length \u003E 30)\n\t\t\t{\n\t\t\t\ttext = text.Substring(0, 30);\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnPhoneNameUpdate\u0022, this, text, msg.player) == null)\n\t\t\t{\n\t\t\t\tPhoneName = text;\n\t\t\t\tbase.baseEntity.SendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnPhoneNameUpdated\u0022, this, PhoneName, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnTakeCurrencyItem(NPCVendingMachine nPCVendingMachine, Item takenCurrencyItem)",
    "MethodSignature": "TakeCurrencyItem(Item takenCurrencyItem)",
    "MethodSourseCode": "\n\tpublic override void TakeCurrencyItem(Item takenCurrencyItem)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTakeCurrencyItem\u0022, this, takenCurrencyItem) == null)\n\t\t{\n\t\t\ttakenCurrencyItem.MoveToContainer(base.inventory);\n\t\t\ttakenCurrencyItem.RemoveFromContainer();\n\t\t\ttakenCurrencyItem.Remove();\n\t\t}\n\t}\n",
    "ClassName": "NPCVendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanChangeCode(BasePlayer rpcPlayer, CodeLock codeLock, string text, bool flag)",
    "MethodSignature": "RPC_ChangeCode(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f, CheckParent = true)]\n\t[RPC_Server]\n\tprivate void RPC_ChangeCode(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = rpc.read.String();\n\t\tbool flag = rpc.read.Bit();\n\t\tif (!IsLocked() \u0026\u0026 text.Length == 4 \u0026\u0026 text.IsNumeric() \u0026\u0026 !(!hasCode \u0026\u0026 flag) \u0026\u0026 Interface.CallHook(\u0022CanChangeCode\u0022, rpc.player, this, text, flag) == null)\n\t\t{\n\t\t\tif (!hasCode \u0026\u0026 !flag)\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tcode = text;\n\t\t\t\thasCode = code.Length \u003E 0;\n\t\t\t\twhitelistPlayers.Clear();\n\t\t\t\twhitelistPlayers.Add(rpc.player.userID);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tguestCode = text;\n\t\t\t\thasGuestCode = guestCode.Length \u003E 0;\n\t\t\t\tguestPlayers.Clear();\n\t\t\t\tguestPlayers.Add(rpc.player.userID);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnCodeChanged\u0022, rpc.player, this, text, flag);\n\t\t\tDoEffect(effectCodeChanged.resourcePath);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnStashHidden(StashContainer stashContainer, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_HideStash(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_HideStash(RPCMessage rpc)\n\t{\n\t\tif (Interface.CallHook(\u0022CanHideStash\u0022, rpc.player, this) == null)\n\t\t{\n\t\t\tFacepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);\n\t\t\tSetHidden(isHidden: true);\n\t\t\tInterface.CallHook(\u0022OnStashHidden\u0022, this, rpc.player);\n\t\t}\n\t}\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnConveyorFiltersChange(IndustrialConveyor industrialConveyor, BasePlayer msgPlayer, ProtoBuf.IndustrialConveyor.ItemFilterList itemFilterList)",
    "MethodSignature": "RPC_ChangeFilters(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\tprivate void RPC_ChangeFilters(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || !msg.player.CanBuild())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tmode = (ConveyorMode)msg.read.Int32();\n\t\tfilterItems.Clear();\n\t\tusing ProtoBuf.IndustrialConveyor.ItemFilterList itemFilterList = msg.read.Proto\u003CProtoBuf.IndustrialConveyor.ItemFilterList\u003E();\n\t\tif (itemFilterList.filters == null || Interface.CallHook(\u0022OnConveyorFiltersChange\u0022, this, msg.player, itemFilterList) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = Mathf.Min(itemFilterList.filters.Count, 60);\n\t\tfor (int i = 0; i \u003C num; i\u002B\u002B)\n\t\t{\n\t\t\tif (filterItems.Count \u003E= 30)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tItemFilter item = new ItemFilter(itemFilterList.filters[i]);\n\t\t\tif (item.TargetItem != null || item.TargetCategory.HasValue)\n\t\t\t{\n\t\t\t\tfilterItems.Add(item);\n\t\t\t}\n\t\t}\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "IndustrialConveyor",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "CanEquipItem(PlayerInventory playerInventory, Item item, int targetSlot)",
    "MethodSignature": "CanEquipItem(Item item, int targetSlot)",
    "MethodSourseCode": "\n\tpublic bool CanEquipItem(Item item, int targetSlot)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanEquipItem\u0022, this, item, targetSlot);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif ((item.info.flags \u0026 ItemDefinition.Flag.NotAllowedInBelt) != 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (base.baseEntity != null \u0026\u0026 base.baseEntity.IsRestrained)\n\t\t{\n\t\t\tHandcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();\n\t\t\tif (restraintItem != null \u0026\u0026 restraintItem.GetItem().position == targetSlot)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tItemModContainerRestriction component = item.info.GetComponent\u003CItemModContainerRestriction\u003E();\n\t\tif (component == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tBufferList\u003CItem\u003E obj2 = Facepunch.Pool.Get\u003CBufferList\u003CItem\u003E\u003E();\n\t\tobj2.CopyFrom(containerBelt.itemList);\n\t\tforeach (Item item2 in obj2)\n\t\t{\n\t\t\tif (item2 != item)\n\t\t\t{\n\t\t\t\tItemModContainerRestriction component2 = item2.info.GetComponent\u003CItemModContainerRestriction\u003E();\n\t\t\t\tif (!(component2 == null) \u0026\u0026 !component.CanExistWith(component2) \u0026\u0026 !item2.MoveToContainer(containerMain))\n\t\t\t\t{\n\t\t\t\t\titem2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.Free(ref obj2, freeElements: false);\n\t\treturn true;\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntitySnapshot(BaseNetworkable baseNetworkable, Network.Connection connection)",
    "MethodSignature": "SendAsSnapshot(Connection connection, bool justCreated)",
    "MethodSourseCode": "\n\tpublic void SendAsSnapshot(Connection connection, bool justCreated = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntitySnapshot\u0022, this, connection) == null)\n\t\t{\n\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\tconnection.validate.entityUpdates\u002B\u002B;\n\t\t\tSaveInfo saveInfo = default(SaveInfo);\n\t\t\tsaveInfo.forConnection = connection;\n\t\t\tsaveInfo.forDisk = false;\n\t\t\tSaveInfo saveInfo2 = saveInfo;\n\t\t\tnetWrite.PacketID(Message.Type.Entities);\n\t\t\tnetWrite.UInt32(connection.validate.entityUpdates);\n\t\t\tToStreamForNetwork(netWrite, saveInfo2);\n\t\t\tnetWrite.Send(new SendInfo(connection));\n\t\t\tif (DemoConVars.ServerDemosEnabled)\n\t\t\t{\n\t\t\t\tlastDemoIndex = Network.Net.sv.serverDemos.DemoCount;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityMounted(BaseMountable baseMountable, BasePlayer player)",
    "MethodSignature": "MountPlayer(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void MountPlayer(BasePlayer player)\n\t{\n\t\tif (!(_mounted != null) \u0026\u0026 !(mountAnchor == null) \u0026\u0026 Interface.CallHook(\u0022CanMountEntity\u0022, player, this) == null)\n\t\t{\n\t\t\tplayer.EnsureDismounted();\n\t\t\t_mounted = player;\n\t\t\tTransform transform = mountAnchor;\n\t\t\tplayer.SetMounted(this);\n\t\t\tplayer.MovePosition(transform.position);\n\t\t\tplayer.transform.rotation = transform.rotation;\n\t\t\tplayer.ServerRotation = transform.rotation;\n\t\t\tplayer.OverrideViewAngles(transform.rotation.eulerAngles);\n\t\t\t_mounted.eyes.NetworkUpdate(transform.rotation);\n\t\t\tplayer.SendNetworkUpdateImmediate();\n\t\t\tFacepunch.Rust.Analytics.Azure.OnMountEntity(player, this, VehicleParent());\n\t\t\tOnPlayerMounted();\n\t\t\tInterface.CallHook(\u0022OnEntityMounted\u0022, this, player);\n\t\t\tif (allowedGestures == MountGestureType.None \u0026\u0026 player.InGesture)\n\t\t\t{\n\t\t\t\tplayer.Server_CancelGesture();\n\t\t\t}\n\t\t\telse if (allowedGestures == MountGestureType.UpperBody \u0026\u0026 player.InGesture \u0026\u0026 player.CurrentGestureIsFullBody)\n\t\t\t{\n\t\t\t\tplayer.Server_CancelGesture();\n\t\t\t}\n\t\t\tif (this.IsValid() \u0026\u0026 player.IsValid())\n\t\t\t{\n\t\t\t\tplayer.ProcessMissionEvent(BaseMission.MissionEventType.MOUNT_ENTITY, net.ID, 1f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "CanUseGesture(BasePlayer player, GestureConfig gestureConfig)",
    "MethodSignature": "IsOwnedBy(BasePlayer player, bool allowCinematic)",
    "MethodSourseCode": "\n\tpublic bool IsOwnedBy(BasePlayer player, bool allowCinematic = false)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseGesture\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (forceUnlock)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (gestureType == GestureType.NPC)\n\t\t{\n\t\t\tif (player != null)\n\t\t\t{\n\t\t\t\treturn player.IsNpc;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (gestureType == GestureType.Cinematic)\n\t\t{\n\t\t\tif (!allowCinematic \u0026\u0026 (!(player != null) || !player.IsAdmin))\n\t\t\t{\n\t\t\t\treturn Server.cinematic;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn IsUnlockedBy(player);\n\t}\n",
    "ClassName": "GestureConfig",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnShopAcceptClick(ShopFront shopFront, BasePlayer msgPlayer)",
    "MethodSignature": "AcceptClicked(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void AcceptClicked(RPCMessage msg)\n\t{\n\t\tif (IsTradingPlayer(msg.player) \u0026\u0026 !(vendorPlayer == null) \u0026\u0026 !(customerPlayer == null) \u0026\u0026 Interface.CallHook(\u0022OnShopAcceptClick\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tif (IsPlayerVendor(msg.player))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved1, b: true);\n\t\t\t\tvendorInventory.SetLocked(isLocked: true);\n\t\t\t}\n\t\t\telse if (IsPlayerCustomer(msg.player))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved2, b: true);\n\t\t\t\tcustomerInventory.SetLocked(isLocked: true);\n\t\t\t}\n\t\t\tif (HasFlag(Flags.Reserved1) \u0026\u0026 HasFlag(Flags.Reserved2))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved3, b: true);\n\t\t\t\tInvoke(CompleteTrade, 2f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ShopFront",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanAffordToPlace(BasePlayer ownerPlayer, Planner planner, Construction component)",
    "MethodSignature": "CanAffordToPlace(Construction component)",
    "MethodSourseCode": "\n\tpublic virtual bool CanAffordToPlace(Construction component)\n\t{\n\t\tif (isTypeDeployable)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanAffordToPlace\u0022, ownerPlayer, this, component);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (ownerPlayer.IsInCreativeMode \u0026\u0026 Creative.freeBuild)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tforeach (ItemAmount item in component.defaultGrade.CostToBuild())\n\t\t{\n\t\t\tif ((float)ownerPlayer.inventory.GetAmount(item.itemDef.itemid) \u003C item.amount)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnItemPickup(Item thisItem, BasePlayer msgPlayer, WorldItem worldItem)",
    "MethodSignature": "Pickup(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void Pickup(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 this.item != null \u0026\u0026 allowPickup \u0026\u0026 Interface.CallHook(\u0022OnItemPickup\u0022, this.item, msg.player, this) == null \u0026\u0026 CanOpenInSafeZone(msg.player))\n\t\t{\n\t\t\tItemModContainer component = this.item.info.GetComponent\u003CItemModContainer\u003E();\n\t\t\tif (!(component != null) || !component.canLootInWorld || !(component.pickupInWorldDelay \u003E 0f) || !(Mathf.Abs(pickupStartTime \u002B component.pickupInWorldDelay - UnityEngine.Time.realtimeSinceStartup) \u003E ConVar.AntiHack.rpc_timer_forgiveness))\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022PickupSound\u0022));\n\t\t\t\tItem item = this.item;\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemPickup(msg.player, this);\n\t\t\t\tRemoveItem();\n\t\t\t\tTryApplyOwnershipOnPickup(msg.player, item);\n\t\t\t\tmsg.player.GiveItem(item, GiveItemReason.PickedUp);\n\t\t\t\tmsg.player.SignalBroadcast(Signal.Gesture, \u0022pickup_item\u0022);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "WorldItem",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnRfFrequencyChange(RFReceiver rFReceiver, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(3uL)]\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild())\n\t\t{\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tnum = RFManager.ClampFrequency(num);\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: true);\n\t\t\t\tfrequency = num;\n\t\t\t\tMarkDirty();\n\t\t\t\tSendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFReceiver",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "CanBeHomingTargeted(PlayerHelicopter playerHelicopter)",
    "MethodSignature": "IsValidHomingTarget()",
    "MethodSourseCode": "\n\tpublic override bool IsValidHomingTarget()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeHomingTargeted\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn IsOn();\n\t}\n",
    "ClassName": "PlayerHelicopter",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerWantsDismount(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "RPC_WantsDismount(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void RPC_WantsDismount(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!HasValidDismountPosition(player))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerDismountFailed\u0022, player, this);\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnPlayerWantsDismount\u0022, player, this) == null \u0026\u0026 (!(player != null) || !player.IsRestrained))\n\t\t{\n\t\t\tAttemptDismount(player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnFireworkExhausted(BaseFirework baseFirework)",
    "MethodSignature": "OnExhausted()",
    "MethodSourseCode": "\n\tpublic virtual void OnExhausted()\n\t{\n\t\tSetFlag(Flags.Reserved8, b: true, recursive: false, networkupdate: false);\n\t\tSetFlag(Flags.OnFire, b: false, recursive: false, networkupdate: false);\n\t\tSetFlag(Flags.On, b: false, recursive: false, networkupdate: false);\n\t\tEnableGlobalBroadcast(wants: false);\n\t\tSendNetworkUpdate_Flags();\n\t\tInterface.CallHook(\u0022OnFireworkExhausted\u0022, this);\n\t\tInvoke(Cleanup, corpseDuration);\n\t\t_activeFireworks.Remove(this);\n\t}\n",
    "ClassName": "BaseFirework",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnPlayerMarkersSend(BasePlayer basePlayer, ProtoBuf.MapNoteList mapNoteList)",
    "MethodSignature": "SendMarkersToClient()",
    "MethodSourseCode": "\n\tpublic void SendMarkersToClient()\n\t{\n\t\tusing MapNoteList mapNoteList = Facepunch.Pool.Get\u003CMapNoteList\u003E();\n\t\tmapNoteList.notes = Facepunch.Pool.Get\u003CList\u003CMapNote\u003E\u003E();\n\t\tif (ServerCurrentDeathNote != null)\n\t\t{\n\t\t\tmapNoteList.notes.Add(ServerCurrentDeathNote);\n\t\t}\n\t\tif (State.pointsOfInterest != null)\n\t\t{\n\t\t\tmapNoteList.notes.AddRange(State.pointsOfInterest);\n\t\t}\n\t\tInterface.CallHook(\u0022OnPlayerMarkersSend\u0022, this, mapNoteList);\n\t\tClientRPC(RpcTarget.Player(\u0022Client_ReceiveMarkers\u0022, this), mapNoteList);\n\t\tmapNoteList.notes.Clear();\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnSiegeWeaponFire(Catapult catapult, BasePlayer player)",
    "MethodSignature": "SERVER_WantsFire(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void SERVER_WantsFire(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (CanFire() \u0026\u0026 Interface.CallHook(\u0022OnSiegeWeaponFire\u0022, this, player) == null)\n\t\t{\n\t\t\tfloat force = reloadProgress;\n\t\t\tFire(player, force);\n\t\t\treloadProgress = 0f;\n\t\t\ttimeSinceLastFire = 0f;\n\t\t\tFireAnimation();\n\t\t\tGameObjectRef loadedAmmoFiringEffect = GetLoadedAmmoFiringEffect();\n\t\t\tif (loadedAmmoFiringEffect != null \u0026\u0026 loadedAmmoFiringEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(loadedAmmoFiringEffect.resourcePath, this, 0u, Vector3.zero, Vector3.up, null, broadcast: true);\n\t\t\t}\n\t\t\tRefreshLastUseTime();\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022CLIENT_Fire\u0022));\n\t\t}\n\t}\n",
    "ClassName": "Catapult",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnRandomItemAward(RandomItemDispenser randomItemDispenser, RandomItemDispenser.RandomItemChance itemChance, BasePlayer forPlayer, UnityEngine.Vector3 distributorPosition)",
    "MethodSignature": "TryAward(RandomItemChance itemChance, BasePlayer forPlayer, Vector3 distributorPosition)",
    "MethodSourseCode": "\n\tprivate bool TryAward(RandomItemChance itemChance, BasePlayer forPlayer, Vector3 distributorPosition)\n\t{\n\t\tif (Interface.CallHook(\u0022OnRandomItemAward\u0022, this, itemChance, forPlayer, distributorPosition) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tfloat num = UnityEngine.Random.Range(0f, 1f);\n\t\tif (itemChance.Chance \u003E= num)\n\t\t{\n\t\t\tItem item = ItemManager.Create(itemChance.Item, itemChance.Amount, 0uL);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\titem.SetItemOwnership(forPlayer, ItemOwnershipPhrases.GatheredPhrase);\n\t\t\t\tif ((bool)forPlayer)\n\t\t\t\t{\n\t\t\t\t\tforPlayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\titem.Drop(distributorPosition \u002B Vector3.up * 0.5f, Vector3.up);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "RandomItemDispenser",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnMlrsTargetSet(MLRS mLRS, UnityEngine.Vector3 trueTargetHitPos, BasePlayer _mounted)",
    "MethodSignature": "SetUserTargetHitPos(Vector3 worldPos)",
    "MethodSourseCode": "\n\tpublic void SetUserTargetHitPos(Vector3 worldPos)\n\t{\n\t\tif (UserTargetHitPos == worldPos)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (base.isServer)\n\t\t{\n\t\t\tVector3 position = TerrainMeta.Position;\n\t\t\tVector3 vector = position \u002B TerrainMeta.Size;\n\t\t\tworldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);\n\t\t\tworldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);\n\t\t\tworldPos.y = GetSurfaceHeight(worldPos);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnMlrsTarget\u0022, this, worldPos, _mounted) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserTargetHitPos = worldPos;\n\t\tif (base.isServer)\n\t\t{\n\t\t\ttrueTargetHitPos = UserTargetHitPos;\n\t\t\tforeach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)\n\t\t\t{\n\t\t\t\tVector3 center = allSafeZone.triggerCollider.bounds.center;\n\t\t\t\tcenter.y = 0f;\n\t\t\t\tfloat num = ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) \u002B targetAreaRadius;\n\t\t\t\ttrueTargetHitPos.y = 0f;\n\t\t\t\tif (Vector3.Distance(center, trueTargetHitPos) \u003C num)\n\t\t\t\t{\n\t\t\t\t\tVector3 vector2 = trueTargetHitPos - center;\n\t\t\t\t\ttrueTargetHitPos = center \u002B vector2.normalized * num;\n\t\t\t\t\ttrueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnMlrsTargetSet\u0022, this, trueTargetHitPos, _mounted);\n\t}\n",
    "ClassName": "MLRS",
    "HookLineInvoke": 38
  },
  {
    "HookSignature": "OnMixingTableToggle(MixingTable mixingTable, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void SVSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMixingTableToggle\u0022, this, msg.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = msg.read.Bit();\n\t\tif (flag != IsOn() \u0026\u0026 !(msg.player == null))\n\t\t{\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tStartMixing(msg.player);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStopMixing();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MixingTable",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnSwitchToggle(ElectricSwitch electricSwitch, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_Switch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_Switch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool @switch = msg.read.Bool();\n\t\t\tSetSwitch(@switch);\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "ElectricSwitch",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanBradleyApcTarget(BradleyAPC bradleyAPC, BaseEntity ent)",
    "MethodSignature": "VisibilityTest(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic bool VisibilityTest(BaseEntity ent)\n\t{\n\t\tif (ent == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!(Vector3.Distance(ent.transform.position, base.transform.position) \u003C viewDistance))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tbool flag = false;\n\t\tif (ent is BasePlayer)\n\t\t{\n\t\t\tBasePlayer basePlayer = ent as BasePlayer;\n\t\t\tVector3 position = mainTurret.transform.position;\n\t\t\tflag = IsVisible(basePlayer.eyes.position, position) || IsVisible(basePlayer.transform.position \u002B Vector3.up * 0.1f, position);\n\t\t\tif (!flag \u0026\u0026 basePlayer.isMounted \u0026\u0026 basePlayer.GetMounted().VehicleParent() != null \u0026\u0026 basePlayer.GetMounted().VehicleParent().AlwaysAllowBradleyTargeting)\n\t\t\t{\n\t\t\t\tflag = IsVisible(basePlayer.GetMounted().VehicleParent().bounds.center, position);\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tflag = !UnityEngine.Physics.SphereCast(new Ray(position, Vector3Ex.Direction(basePlayer.eyes.position, position)), 0.05f, Vector3.Distance(basePlayer.eyes.position, position), 10551297);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Standard vis test!\u0022);\n\t\t\tflag = IsVisible(ent.CenterPoint());\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanBradleyApcTarget\u0022, this, ent);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn flag;\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnTakeCurrencyItem(VendingMachine vendingMachine, Item takenCurrencyItem)",
    "MethodSignature": "TakeCurrencyItem(Item takenCurrencyItem)",
    "MethodSourseCode": "\n\tpublic virtual void TakeCurrencyItem(Item takenCurrencyItem)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTakeCurrencyItem\u0022, this, takenCurrencyItem) == null \u0026\u0026 !takenCurrencyItem.MoveToContainer(base.inventory))\n\t\t{\n\t\t\ttakenCurrencyItem.Drop(base.inventory.dropPosition, Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanBeTargeted(BasePlayer component, FlameTurret flameTurret)",
    "MethodSignature": "CheckTrigger()",
    "MethodSourseCode": "\n\tpublic bool CheckTrigger()\n\t{\n\t\tif (Time.realtimeSinceStartup \u003C nextTriggerCheckTime)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tnextTriggerCheckTime = Time.realtimeSinceStartup \u002B 1f / triggerCheckRate;\n\t\tList\u003CRaycastHit\u003E obj = Pool.Get\u003CList\u003CRaycastHit\u003E\u003E();\n\t\tHashSet\u003CBaseEntity\u003E entityContents = trigger.entityContents;\n\t\tBuildingPrivlidge cachedTc = GetCachedTc();\n\t\tbool flag = false;\n\t\tif (entityContents != null)\n\t\t{\n\t\t\tforeach (BaseEntity item in entityContents)\n\t\t\t{\n\t\t\t\tBasePlayer component = item.GetComponent\u003CBasePlayer\u003E();\n\t\t\t\tif (component.IsSleeping())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tobject obj2 = Interface.CallHook(\u0022CanBeTargeted\u0022, component, this);\n\t\t\t\tif (obj2 is bool)\n\t\t\t\t{\n\t\t\t\t\tPool.FreeUnmanaged(ref obj);\n\t\t\t\t\treturn (bool)obj2;\n\t\t\t\t}\n\t\t\t\tif (!component.IsAlive() || !(component.transform.position.y \u003C= GetEyePosition().y \u002B 0.5f) || (!(cachedTc == null) \u0026\u0026 cachedTc.IsAuthed(component)))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tobj.Clear();\n\t\t\t\tGamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);\n\t\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(obj[i]);\n\t\t\t\t\tif (entity != null \u0026\u0026 (entity == this || entity.EqualNetID(this)))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPool.FreeUnmanaged(ref obj);\n\t\treturn flag;\n\t}\n",
    "ClassName": "FlameTurret",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "CanNpcEat(BaseNpc baseNpc, BaseEntity best)",
    "MethodSignature": "WantsToEat(BaseEntity best)",
    "MethodSourseCode": "\n\tpublic virtual bool WantsToEat(BaseEntity best)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanNpcEat\u0022, this, best);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!best.HasTrait(TraitFlag.Food))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (best.HasTrait(TraitFlag.Alive))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCargoPlaneSignaled(BaseEntity baseEntity, SupplySignal supplySignal)",
    "MethodSignature": "Explode()",
    "MethodSourseCode": "\n\tpublic override void Explode()\n\t{\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);\n\t\tif ((bool)baseEntity)\n\t\t{\n\t\t\tVector3 vector = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));\n\t\t\tbaseEntity.SendMessage(\u0022InitDropPosition\u0022, base.transform.position \u002B vector, SendMessageOptions.DontRequireReceiver);\n\t\t\tbaseEntity.Spawn();\n\t\t\tInterface.CallHook(\u0022OnCargoPlaneSignaled\u0022, baseEntity, this);\n\t\t}\n\t\tInvoke(FinishUp, 210f);\n\t\tSetFlag(Flags.On, b: true);\n\t\tSendNetworkUpdateImmediate();\n\t}\n",
    "ClassName": "SupplySignal",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnSiegeWeaponPull(BaseSiegeWeapon baseSiegeWeapon, BasePlayer msgPlayer)",
    "MethodSignature": "SERVER_StartPulling(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void SERVER_StartPulling(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (CanPullNow(player) \u0026\u0026 !(rigidBody == null) \u0026\u0026 Interface.CallHook(\u0022OnSiegeWeaponPull\u0022, this, msg.player) == null \u0026\u0026 (!OnlyOwnerAccessible() || !(player != creatorEntity)))\n\t\t{\n\t\t\tplayer.metabolism.calories.Subtract(3f);\n\t\t\tplayer.metabolism.SendChangesToClient();\n\t\t\tif (rigidBody.IsSleeping())\n\t\t\t{\n\t\t\t\trigidBody.WakeUp();\n\t\t\t}\n\t\t\tStartPulling(player);\n\t\t}\n\t}\n",
    "ClassName": "BaseSiegeWeapon",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanNetworkTo(BasePlayer basePlayer, BasePlayer player)",
    "MethodSignature": "ShouldNetworkTo(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool ShouldNetworkTo(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanNetworkTo\u0022, this, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player == this)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (IsSpectating() \u0026\u0026 player != this)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tbool flag = base.ShouldNetworkTo(player);\n\t\tif (ServerOcclusion.OcclusionEnabled \u0026\u0026 flag)\n\t\t{\n\t\t\tbool flag2 = player.GetMounted() is ComputerStation;\n\t\t\tbool server_occlusion_disable_los = ConVar.AntiHack.server_occlusion_disable_los;\n\t\t\tflag = OcclusionLineOfSight(player, server_occlusion_disable_los || flag2 || !SupportsServerOcclusion());\n\t\t}\n\t\treturn flag;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemResearch(ResearchTable researchTable, Item targetItem, BasePlayer player)",
    "MethodSignature": "DoResearch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void DoResearch(RPCMessage msg)\n\t{\n\t\tif (IsResearching())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tItem targetItem = GetTargetItem();\n\t\tif (targetItem != null \u0026\u0026 Interface.CallHook(\u0022CanResearchItem\u0022, player, targetItem) == null \u0026\u0026 targetItem.amount \u003C= 1 \u0026\u0026 IsItemResearchable(targetItem))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnItemResearch\u0022, this, targetItem, player);\n\t\t\ttargetItem.CollectedForCrafting(player);\n\t\t\tresearchFinishedTime = UnityEngine.Time.realtimeSinceStartup \u002B researchDuration;\n\t\t\tInvoke(ResearchAttemptFinished, researchDuration);\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tint scrapCost = ScrapForResearch(targetItem);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tif (researchStartEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t\tmsg.player.GiveAchievement(\u0022RESEARCH_ITEM\u0022);\n\t\t}\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnBoomboxStationValidate(string url)",
    "MethodSignature": "IsStationValid(string url)",
    "MethodSourseCode": "\n\tpublic static bool IsStationValid(string url)\n\t{\n\t\tParseServerUrlList();\n\t\tobject obj = Interface.CallHook(\u0022OnBoomboxStationValidate\u0022, url);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tShoutcastStreamer.CheckBuiltInRadios();\n\t\tif (ValidStations == null || !ValidStations.ContainsValue(url))\n\t\t{\n\t\t\tif (ServerValidStations == null || !ServerValidStations.ContainsValue(url))\n\t\t\t{\n\t\t\t\tif (ShoutcastStreamer.ParsedLocalRadioList != null)\n\t\t\t\t{\n\t\t\t\t\treturn ShoutcastStreamer.ParsedLocalRadioList.ContainsValue(url);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BoomBox",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnClientProjectileEffectCreate(Network.Connection sourceConnection, BaseProjectile baseProjectile, string prefabName)",
    "MethodSignature": "CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced, bool forceClientsideEffects, List\u003CConnection\u003E targets, float distanceOverride)",
    "MethodSourseCode": "\n\tpublic void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced = false, bool forceClientsideEffects = false, List\u003CConnection\u003E targets = null, float distanceOverride = 0f)\n\t{\n\t\tif (Interface.CallHook(\u0022OnClientProjectileEffectCreate\u0022, sourceConnection, this, prefabName) == null)\n\t\t{\n\t\t\tEffect effect = reusableInstance;\n\t\t\teffect.Init(Effect.Type.Projectile, pos, velocity, sourceConnection);\n\t\t\teffect.scale = (silenced ? 0f : 1f);\n\t\t\tif (forceClientsideEffects)\n\t\t\t{\n\t\t\t\teffect.scale = 2f;\n\t\t\t}\n\t\t\teffect.pooledString = prefabName;\n\t\t\teffect.number = seed;\n\t\t\teffect.targets = targets;\n\t\t\teffect.distanceOverride = distanceOverride;\n\t\t\tEffectNetwork.Send(effect);\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerActiveShieldDrop(BasePlayer player, Shield foundShield)",
    "MethodSignature": "DropActive(Vector3 position, Vector3 velocity)",
    "MethodSourseCode": "\n\tpublic void DropActive(Vector3 position, Vector3 velocity)\n\t{\n\t\tif (player.GetActiveShield(out var foundShield))\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnPlayerActiveShieldDrop\u0022, player, foundShield) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDroppedItem droppedItem = foundShield.GetItem().Drop(position, velocity) as DroppedItem;\n\t\t\tif (droppedItem != null)\n\t\t\t{\n\t\t\t\tdroppedItem.DropReason = DroppedItem.DropReasonEnum.Death;\n\t\t\t\tdroppedItem.DroppedBy = player.userID;\n\t\t\t\tdroppedItem.DroppedTime = DateTime.UtcNow;\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(player, droppedItem, DroppedItem.DropReasonEnum.Death);\n\t\t\t}\n\t\t}\n\t\tItem activeItem = player.GetActiveItem();\n\t\tif (activeItem == null || Interface.CallHook(\u0022OnPlayerDropActiveItem\u0022, player, activeItem) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022PlayerBelt.DropActive\u0022))\n\t\t{\n\t\t\tDroppedItem droppedItem2 = activeItem.Drop(position, velocity) as DroppedItem;\n\t\t\tif (droppedItem2 != null)\n\t\t\t{\n\t\t\t\tdroppedItem2.DropReason = DroppedItem.DropReasonEnum.Death;\n\t\t\t\tdroppedItem2.DroppedBy = player.userID;\n\t\t\t\tdroppedItem2.DroppedTime = DateTime.UtcNow;\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(player, droppedItem2, DroppedItem.DropReasonEnum.Death);\n\t\t\t}\n\t\t\tplayer.svActiveItemID = default(ItemId);\n\t\t\tplayer.SendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "PlayerBelt",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnSpinWheel(BasePlayer rpcPlayer, SpinnerWheel spinnerWheel)",
    "MethodSignature": "RPC_Spin(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_Spin(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 AllowPlayerSpins() \u0026\u0026 (AnyoneSpin() || rpc.player.CanBuild()) \u0026\u0026 Interface.CallHook(\u0022OnSpinWheel\u0022, rpc.player, this) == null \u0026\u0026 !(velocity \u003E 15f))\n\t\t{\n\t\t\tvelocity \u002B= UnityEngine.Random.Range(4f, 7f);\n\t\t\tToggleChildEntityColliders(state: false);\n\t\t}\n\t}\n",
    "ClassName": "SpinnerWheel",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanHackCrate(BasePlayer msgPlayer, HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "RPC_Hack(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_Hack(RPCMessage msg)\n\t{\n\t\tif (!IsBeingHacked() \u0026\u0026 Interface.CallHook(\u0022CanHackCrate\u0022, msg.player, this) == null)\n\t\t{\n\t\t\tFacepunch.Rust.Analytics.Azure.OnLockedCrateStarted(msg.player, this);\n\t\t\toriginalHackerPlayerId = msg.player.userID;\n\t\t\toriginalHackerPlayer = msg.player;\n\t\t\tStartHacking();\n\t\t}\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanUseWires(BasePlayer player, bool cached, float cacheDuration)",
    "MethodSignature": "CanPlayerUseWires(BasePlayer player, bool cached, float cacheDuration)",
    "MethodSourseCode": "\n\tpublic static bool CanPlayerUseWires(BasePlayer player, bool cached = false, float cacheDuration = 1f)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseWires\u0022, player, cached, cacheDuration);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player != null \u0026\u0026 player.IsInCreativeMode \u0026\u0026 Creative.unlimitedIo)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (!player.CanBuild(cached, cacheDuration))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tList\u003CCollider\u003E obj2 = Facepunch.Pool.Get\u003CList\u003CCollider\u003E\u003E();\n\t\tGamePhysics.OverlapSphere(player.eyes.position, 0.1f, obj2, 536870912, QueryTriggerInteraction.Collide);\n\t\tbool result = true;\n\t\tforeach (Collider item in obj2)\n\t\t{\n\t\t\tif (!item.gameObject.CompareTag(\u0022IgnoreWireCheck\u0022))\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\treturn result;\n\t}\n",
    "ClassName": "WireTool",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnWorldPrefabSpawned(UnityEngine.GameObject gameObject, string category)",
    "MethodSignature": "SpawnPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)",
    "MethodSourseCode": "\n\tprivate static void SpawnPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)\n\t{\n\t\tif (prefab != null \u0026\u0026 (bool)prefab.Object)\n\t\t{\n\t\t\tspawnTimer.Restart();\n\t\t\tif (!Cached)\n\t\t\t{\n\t\t\t\tprefab.ApplyTerrainPlacements(position, rotation, scale);\n\t\t\t\tprefab.ApplyTerrainModifiers(position, rotation, scale);\n\t\t\t}\n\t\t\tGameObject gameObject = prefab.Spawn(position, rotation, scale);\n\t\t\tif ((bool)gameObject)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnWorldPrefabSpawned\u0022, gameObject, category);\n\t\t\t\tGameObjectEx.SetHierarchyGroup(gameObject, category);\n\t\t\t}\n\t\t\tspawnTimer.Stop();\n\t\t\tspawnTimings.Add(new SpawnTiming\n\t\t\t{\n\t\t\t\tcategory = category,\n\t\t\t\tprefab = prefab,\n\t\t\t\tposition = position,\n\t\t\t\trotation = rotation,\n\t\t\t\tscale = scale,\n\t\t\t\ttime = spawnTimer.Elapsed\n\t\t\t});\n\t\t}\n\t}\n",
    "ClassName": "World",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnSleepingBagDestroyed(SleepingBag sleepingBag2, ulong userID)",
    "MethodSignature": "DestroyBag(ulong userID, NetworkableId sleepingBag)",
    "MethodSourseCode": "\n\tpublic static bool DestroyBag(ulong userID, NetworkableId sleepingBag)\n\t{\n\t\tSleepingBag sleepingBag2 = FindForPlayer(userID, ignoreTimers: true).FirstOrDefault((SleepingBag x) =\u003E x.net.ID == sleepingBag);\n\t\tif (sleepingBag2 == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnSleepingBagDestroy\u0022, sleepingBag2, userID) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tRemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);\n\t\tsleepingBag2.deployerUserID = 0uL;\n\t\tif (sleepingBag2.HasFlag(Flags.Reserved14))\n\t\t{\n\t\t\tsleepingBag2.Kill();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsleepingBag2.SendNetworkUpdate();\n\t\t}\n\t\tBasePlayer basePlayer = BasePlayer.FindByID(userID);\n\t\tif (basePlayer != null)\n\t\t{\n\t\t\tbasePlayer.SendRespawnOptions();\n\t\t\tInterface.CallHook(\u0022OnSleepingBagDestroyed\u0022, sleepingBag2, userID);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "OnPhoneDialTimeout(PhoneController activeCallTo, PhoneController phoneController, BasePlayer activeCallToCurrentPlayer)",
    "MethodSignature": "TimeOutDialing()",
    "MethodSourseCode": "\n\tprivate void TimeOutDialing()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneDialTimeout\u0022, activeCallTo, this, activeCallTo.currentPlayer) == null)\n\t\t{\n\t\t\tif (activeCallTo != null)\n\t\t\t{\n\t\t\t\tactiveCallTo.ServerPlayAnsweringMessage(this);\n\t\t\t}\n\t\t\tSetPhoneState(Telephone.CallState.Idle);\n\t\t\tInterface.CallHook(\u0022OnPhoneDialTimedOut\u0022, activeCallTo, this, activeCallTo.currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount, bool free)",
    "MethodSignature": "CanCraft(ItemBlueprint bp, int amount, bool free)",
    "MethodSourseCode": "\n\tpublic bool CanCraft(ItemBlueprint bp, int amount = 1, bool free = false)\n\t{\n\t\tif (!bp.targetItem.IsAllowed(EraRestriction.Craft))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (base.baseEntity != null \u0026\u0026 base.baseEntity.IsRestrained)\n\t\t{\n\t\t\tHandcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();\n\t\t\tif (restraintItem != null \u0026\u0026 restraintItem.BlockCrafting)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfloat num = (float)amount / (float)bp.targetItem.craftingStackable;\n\t\tforeach (ItemCraftTask item in queue)\n\t\t{\n\t\t\tif (!item.cancelled)\n\t\t\t{\n\t\t\t\tnum \u002B= (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;\n\t\t\t}\n\t\t}\n\t\tif (num \u003E 8f)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanCraft\u0022, this, bp, amount, free);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (amount \u003C 1 || amount \u003E bp.targetItem.craftingStackable)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tforeach (ItemAmount ingredient in bp.GetIngredients())\n\t\t{\n\t\t\tif (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (ingredient.itemDef.condition.enabled \u0026\u0026 !DoesHaveOKConditionItem(ingredient.itemid, (int)ingredient.amount * amount))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnCupboardProtectionCalculated(BuildingPrivlidge buildingPrivlidge, float cachedProtectedMinutes)",
    "MethodSignature": "GetProtectedMinutes(bool force)",
    "MethodSourseCode": "\n\tpublic float GetProtectedMinutes(bool force = false)\n\t{\n\t\tif (base.isServer)\n\t\t{\n\t\t\tif (!force \u0026\u0026 UnityEngine.Time.realtimeSinceStartup \u003C nextProtectedCalcTime)\n\t\t\t{\n\t\t\t\treturn cachedProtectedMinutes;\n\t\t\t}\n\t\t\tnextProtectedCalcTime = UnityEngine.Time.realtimeSinceStartup \u002B 60f;\n\t\t\tList\u003CItemAmount\u003E obj = Facepunch.Pool.Get\u003CList\u003CItemAmount\u003E\u003E();\n\t\t\tCalculateUpkeepCostAmounts(obj);\n\t\t\tfloat num = CalculateUpkeepPeriodMinutes();\n\t\t\tfloat num2 = -1f;\n\t\t\tif (base.inventory != null)\n\t\t\t{\n\t\t\t\tusing PooledList\u003CItem\u003E pooledList = Facepunch.Pool.Get\u003CPooledList\u003CItem\u003E\u003E();\n\t\t\t\tforeach (ItemAmount item in obj)\n\t\t\t\t{\n\t\t\t\t\tpooledList.Clear();\n\t\t\t\t\tbase.inventory.FindItemsByItemID(pooledList, item.itemid);\n\t\t\t\t\tint num3 = pooledList.Sum((Item x) =\u003E x.amount);\n\t\t\t\t\tif (num3 \u003E 0 \u0026\u0026 item.amount \u003E 0f)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat num4 = (float)num3 / item.amount * num;\n\t\t\t\t\t\tif (num2 == -1f || num4 \u003C num2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum2 = num4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnum2 = 0f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (num2 == -1f)\n\t\t\t\t{\n\t\t\t\t\tnum2 = 0f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t\t\tcachedProtectedMinutes = num2;\n\t\t\tInterface.CallHook(\u0022OnCupboardProtectionCalculated\u0022, this, cachedProtectedMinutes);\n\t\t\treturn cachedProtectedMinutes;\n\t\t}\n\t\treturn 0f;\n\t}\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 42
  },
  {
    "HookSignature": "OnTurretToggle(AutoTurret autoTurret)",
    "MethodSignature": "SetIsOnline(bool online)",
    "MethodSourseCode": "\n\tpublic void SetIsOnline(bool online)\n\t{\n\t\tBaseProjectile attachedWeapon = GetAttachedWeapon();\n\t\tif ((bool)attachedWeapon \u0026\u0026 attachedWeapon is ITurretNotify turretNotify)\n\t\t{\n\t\t\tturretNotify.OnAddedRemovedToTurret(online);\n\t\t}\n\t\tif (online != IsOn() \u0026\u0026 Interface.CallHook(\u0022OnTurretToggle\u0022, this) == null)\n\t\t{\n\t\t\tSetFlag(Flags.On, online);\n\t\t\tif (online)\n\t\t\t{\n\t\t\t\tTryRegisterForInterferenceUpdate();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSetFlag(Flags.OnFire, b: false);\n\t\t\t\tUpdateInterferenceOnOthers();\n\t\t\t}\n\t\t\tbooting = false;\n\t\t\tGetAttachedWeapon()?.SetLightsOn(online);\n\t\t\tSendNetworkUpdate();\n\t\t\tif (IsOffline())\n\t\t\t{\n\t\t\t\tSetTarget(null);\n\t\t\t\tisLootable = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tisLootable = false;\n\t\t\t\tauthDirty = true;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnPlayerPingsSend(BasePlayer basePlayer, ProtoBuf.MapNoteList mapNoteList)",
    "MethodSignature": "SendPingsToClient()",
    "MethodSourseCode": "\n\tpublic void SendPingsToClient()\n\t{\n\t\tusing MapNoteList mapNoteList = Facepunch.Pool.Get\u003CMapNoteList\u003E();\n\t\tmapNoteList.notes = Facepunch.Pool.Get\u003CList\u003CMapNote\u003E\u003E();\n\t\tmapNoteList.notes.AddRange(State.pings);\n\t\tInterface.CallHook(\u0022OnPlayerPingsSend\u0022, this, mapNoteList);\n\t\tClientRPC(RpcTarget.Player(\u0022Client_ReceivePings\u0022, this), mapNoteList);\n\t\tmapNoteList.notes.Clear();\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnItemUpgrade(Item item, Item item2, BasePlayer player)",
    "MethodSignature": "ServerCommand(Item item, string command, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void ServerCommand(Item item, string command, BasePlayer player)\n\t{\n\t\tif (!(command == \u0022upgrade_item\u0022) || item.amount \u003C numForUpgrade)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= upgradeSuccessChance)\n\t\t{\n\t\t\titem.UseItem(numForUpgrade);\n\t\t\tItem item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);\n\t\t\tInterface.CallHook(\u0022OnItemUpgrade\u0022, item, item2, player);\n\t\t\titem2.SetItemOwnership(player, ItemOwnershipPhrases.UpgradeItem);\n\t\t\tif (!item2.MoveToContainer(player.inventory.containerMain))\n\t\t\t{\n\t\t\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity());\n\t\t\t}\n\t\t\tif (successEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(successEffect.resourcePath, player.eyes.position);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem.UseItem(numToLoseOnFail);\n\t\t\tif (failEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(failEffect.resourcePath, player.eyes.position);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ItemModUpgrade",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnBoomboxStationUpdate(BoomBox boomBox, string text, BasePlayer msgPlayer)",
    "MethodSignature": "Server_UpdateRadioIP(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void Server_UpdateRadioIP(BaseEntity.RPCMessage msg)\n\t{\n\t\tstring text = msg.read.String();\n\t\tif (Interface.CallHook(\u0022OnBoomboxStationUpdate\u0022, this, text, msg.player) == null \u0026\u0026 IsStationValid(text))\n\t\t{\n\t\t\tif (msg.player != null)\n\t\t\t{\n\t\t\t\tulong assignedRadioBy = msg.player.userID.Get();\n\t\t\t\tAssignedRadioBy = assignedRadioBy;\n\t\t\t}\n\t\t\tCurrentRadioIp = text;\n\t\t\tbase.baseEntity.ClientRPC(RpcTarget.NetworkGroup(\u0022OnRadioIPChanged\u0022), CurrentRadioIp);\n\t\t\tInterface.CallHook(\u0022OnBoomboxStationUpdated\u0022, this, text, msg.player);\n\t\t\tif (IsOn())\n\t\t\t{\n\t\t\t\tServerTogglePlay(play: false);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BoomBox",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerSetInfo(Network.Connection packetConnection, string itemName, string itemValue)",
    "MethodSignature": "ClientReady(Message packet)",
    "MethodSourseCode": "\n\tprivate void ClientReady(Message packet)\n\t{\n\t\tif (packet.connection.state != Network.Connection.State.Welcoming)\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid connection state\u0022);\n\t\t\treturn;\n\t\t}\n\t\tusing (ClientReady clientReady = packet.read.Proto\u003CClientReady\u003E())\n\t\t{\n\t\t\tforeach (ClientReady.ClientInfo item in clientReady.clientInfo)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnPlayerSetInfo\u0022, packet.connection, item.name, item.value);\n\t\t\t\tpacket.connection.info.Set(item.name, item.value);\n\t\t\t}\n\t\t\tpacket.connection.globalNetworking = clientReady.globalNetworking;\n\t\t\tconnectionQueue.JoinedGame(packet.connection);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnPlayerConnected(packet.connection);\n\t\t\tAddPartyMembersToTeam(packet.connection, clientReady.party);\n\t\t\tusing (TimeWarning.New(\u0022ClientReady\u0022))\n\t\t\t{\n\t\t\t\tBasePlayer basePlayer;\n\t\t\t\tusing (TimeWarning.New(\u0022SpawnPlayerSleeping\u0022))\n\t\t\t\t{\n\t\t\t\t\tbasePlayer = SpawnPlayerSleeping(packet.connection);\n\t\t\t\t}\n\t\t\t\tif (basePlayer == null)\n\t\t\t\t{\n\t\t\t\t\tusing (TimeWarning.New(\u0022SpawnNewPlayer\u0022))\n\t\t\t\t\t{\n\t\t\t\t\t\tbasePlayer = SpawnNewPlayer(packet.connection);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbasePlayer.SendRespawnOptions();\n\t\t\t\tbasePlayer.LoadClanInfo();\n\t\t\t\tif (basePlayer != null)\n\t\t\t\t{\n\t\t\t\t\tUtil.SendSignedInNotification(basePlayer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSendReplicatedVars(packet.connection);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnFishingStopped(BaseFishingRod baseFishingRod, BaseFishingRod.FailReason reason)",
    "MethodSignature": "Server_Cancel(FailReason reason)",
    "MethodSourseCode": "\n\tprivate void Server_Cancel(FailReason reason)\n\t{\n\t\tif (GetItem() != null)\n\t\t{\n\t\t\tGetItem().LoseCondition((reason == FailReason.Success) ? ConditionLossOnSuccess : ConditionLossOnFail);\n\t\t}\n\t\tSetFlag(Flags.Busy, b: false);\n\t\tUpdateFlags();\n\t\tCancelInvoke(CatchProcess);\n\t\tCurrentState = CatchState.None;\n\t\tSetFlag(Flags.Reserved1, b: false);\n\t\tFishingBobber fishingBobber = currentBobber.Get(serverside: true);\n\t\tif (fishingBobber != null)\n\t\t{\n\t\t\tfishingBobber.Kill();\n\t\t\tcurrentBobber.Set(null);\n\t\t}\n\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_ResetLine\u0022), (int)reason);\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (ownerPlayer != null)\n\t\t{\n\t\t\tFacepunch.Rust.Analytics.Azure.OnFailedFish(ownerPlayer, reason);\n\t\t}\n\t\tInterface.CallHook(\u0022OnFishingStopped\u0022, this, reason);\n\t}\n",
    "ClassName": "BaseFishingRod",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnDieselEngineToggled(DieselEngine dieselEngine)",
    "MethodSignature": "EngineOff()",
    "MethodSourseCode": "\n\tpublic void EngineOff()\n\t{\n\t\tSetFlag(Flags.On, b: false);\n\t\tBroadcastEntityMessage(\u0022DieselEngineOff\u0022);\n\t\tInterface.CallHook(\u0022OnDieselEngineToggled\u0022, this);\n\t}\n",
    "ClassName": "DieselEngine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanSwapToSeat(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "CanSwapToThis(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanSwapToThis(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanSwapToSeat\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnStructureRepair(BaseCombatEntity baseCombatEntity, BasePlayer player)",
    "MethodSignature": "DoRepair(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void DoRepair(BasePlayer player)\n\t{\n\t\tBasePlayer player2 = player;\n\t\tif (!repair.enabled || Interface.CallHook(\u0022OnStructureRepair\u0022, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = GetDamageRepairCooldown();\n\t\tif (player2.IsInCreativeMode \u0026\u0026 Creative.freeRepair)\n\t\t{\n\t\t\tnum = 0f;\n\t\t}\n\t\tif (SecondsSinceAttacked \u003C= num)\n\t\t{\n\t\t\tOnRepairFailed(player2, RecentlyDamagedError, (num - SecondsSinceAttacked).ToString(\u0022N0\u0022));\n\t\t\treturn;\n\t\t}\n\t\tfloat num2 = MaxHealth() - Health();\n\t\tfloat num3 = num2 / MaxHealth();\n\t\tif (num2 \u003C= 0f || num3 \u003C= 0f)\n\t\t{\n\t\t\tOnRepairFailed(player2, NotDamagedError);\n\t\t\treturn;\n\t\t}\n\t\tList\u003CItemAmount\u003E list = RepairCost(num3);\n\t\tif (list == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num4 = list.Sum((ItemAmount x) =\u003E x.amount);\n\t\tfloat healthBefore = health;\n\t\tif (player2.IsInCreativeMode \u0026\u0026 Creative.freeRepair)\n\t\t{\n\t\t\tnum4 = 0f;\n\t\t}\n\t\tif (num4 \u003E 0f)\n\t\t{\n\t\t\tfloat num5 = list.Min((ItemAmount x) =\u003E Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));\n\t\t\tif (float.IsNaN(num5))\n\t\t\t{\n\t\t\t\tnum5 = 0f;\n\t\t\t}\n\t\t\tnum5 = Mathf.Min(num5, 50f / num2);\n\t\t\tif (num5 \u003C= 0f)\n\t\t\t{\n\t\t\t\tOnRepairFailedResources(player2, list);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint num6 = 0;\n\t\t\tforeach (ItemAmount item in list)\n\t\t\t{\n\t\t\t\tint amount = Mathf.CeilToInt(num5 * item.amount);\n\t\t\t\tint num7 = player2.inventory.Take(null, item.itemid, amount);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, \u0022repair_entity\u0022, item.itemDef.shortname, num7, this, null, safezone: false, null, player2.userID);\n\t\t\t\tif (num7 \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tnum6 \u002B= num7;\n\t\t\t\t\tplayer2.Command(\u0022note.inv\u0022, item.itemid, num7 * -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfloat num8 = (float)num6 / num4;\n\t\t\thealth \u002B= num2 * num8;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\telse\n\t\t{\n\t\t\thealth \u002B= num2;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tFacepunch.Rust.Analytics.Azure.OnEntityRepaired(player2, this, healthBefore, health);\n\t\tif (Health() \u003E= MaxHealth())\n\t\t{\n\t\t\tOnRepairFinished(player2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOnRepair();\n\t\t}\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnHelicopterDropDoorOpen(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "SetDropDoorOpen(bool open)",
    "MethodSourseCode": "\n\tpublic void SetDropDoorOpen(bool open)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterDropDoorOpen\u0022, this) == null)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved8, open);\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnInventoryAmmoFind(PlayerInventory playerInventory, System.Collections.Generic.List\u003CItem\u003E list, Rust.AmmoTypes ammoType)",
    "MethodSignature": "FindAmmo(List\u003CItem\u003E list, AmmoTypes ammoType)",
    "MethodSourseCode": "\n\tpublic void FindAmmo(List\u003CItem\u003E list, AmmoTypes ammoType)\n\t{\n\t\tif (Interface.CallHook(\u0022OnInventoryAmmoFind\u0022, this, list, ammoType) == null)\n\t\t{\n\t\t\tcontainerMain?.FindAmmo(list, ammoType);\n\t\t\tcontainerBelt?.FindAmmo(list, ammoType);\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnWeaponReload(BaseProjectile baseProjectile, BasePlayer player)",
    "MethodSignature": "StartReload(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void StartReload(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientRPC(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t\treloadStarted = false;\n\t\t\treloadFinished = false;\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnWeaponReload\u0022, this, player) == null)\n\t\t{\n\t\t\treloadFinished = false;\n\t\t\treloadStarted = true;\n\t\t\tfractionalInsertCounter = 0;\n\t\t\tif (CanRefundAmmo)\n\t\t\t{\n\t\t\t\tSwitchAmmoTypesIfNeeded(player.inventory);\n\t\t\t}\n\t\t\tOnReloadStarted();\n\t\t\tStartReloadCooldown(GetReloadDuration());\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnInputUpdate(IOEntity iOEntity, int inputAmount, int inputSlot)",
    "MethodSignature": "UpdateFromInput(int inputAmount, int inputSlot)",
    "MethodSourseCode": "\n\tpublic virtual void UpdateFromInput(int inputAmount, int inputSlot)\n\t{\n\t\tif (Interface.CallHook(\u0022OnInputUpdate\u0022, this, inputAmount, inputSlot) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (inputs[inputSlot].type != ioType || inputs[inputSlot].type == IOType.Industrial)\n\t\t{\n\t\t\tIOStateChanged(inputAmount, inputSlot);\n\t\t\treturn;\n\t\t}\n\t\tUpdateHasPower(inputAmount, inputSlot);\n\t\tlastEnergy = currentEnergy;\n\t\tcurrentEnergy = CalculateCurrentEnergy(inputAmount, inputSlot);\n\t\tint num = GetPassthroughAmount();\n\t\tif (infiniteIoPower \u0026\u0026 GetQueueType() == QueueType.ElectricLowPriority)\n\t\t{\n\t\t\tnum = 999;\n\t\t}\n\t\tbool flag = lastPassthroughEnergy != num;\n\t\tlastPassthroughEnergy = num;\n\t\tif (currentEnergy != lastEnergy || flag)\n\t\t{\n\t\t\tIOStateChanged(inputAmount, inputSlot);\n\t\t\tensureOutputsUpdated = true;\n\t\t}\n\t\t_processQueues[GetQueueType()].Enqueue(this);\n\t}\n",
    "ClassName": "IOEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnShopCompleteTrade(ShopFront shopFront)",
    "MethodSignature": "CompleteTrade()",
    "MethodSourseCode": "\n\tpublic void CompleteTrade()\n\t{\n\t\tif (vendorPlayer != null \u0026\u0026 customerPlayer != null \u0026\u0026 HasFlag(Flags.Reserved1) \u0026\u0026 HasFlag(Flags.Reserved2))\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnShopCompleteTrade\u0022, this) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tswappingItems = true;\n\t\t\t\tfor (int num = vendorInventory.capacity - 1; num \u003E= 0; num--)\n\t\t\t\t{\n\t\t\t\t\tItem slot = vendorInventory.GetSlot(num);\n\t\t\t\t\tItem slot2 = customerInventory.GetSlot(num);\n\t\t\t\t\tif ((bool)customerPlayer \u0026\u0026 slot != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcustomerPlayer.GiveItem(slot);\n\t\t\t\t\t}\n\t\t\t\t\tif ((bool)vendorPlayer \u0026\u0026 slot2 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvendorPlayer.GiveItem(slot2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tswappingItems = false;\n\t\t\t}\n\t\t\tEffect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);\n\t\t}\n\t\tResetTrade();\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "ShopFront",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnTechTreeNodeUnlock(Workbench workbench, TechTreeData.NodeInstance byID, BasePlayer player)",
    "MethodSignature": "RPC_TechTreeUnlock(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_TechTreeUnlock(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint id = msg.read.Int32();\n\t\tint level = msg.read.Int32();\n\t\tTechTreeData techTreeForLevel = GetTechTreeForLevel(level);\n\t\tif (techTreeForLevel == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tTechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);\n\t\tif (byID == null)\n\t\t{\n\t\t\tDebug.Log(\u0022Node for unlock not found :\u0022 \u002B id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!techTreeForLevel.PlayerCanUnlock(player, byID))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (byID.IsGroup())\n\t\t\t{\n\t\t\t\tforeach (int output in byID.outputs)\n\t\t\t\t{\n\t\t\t\t\tTechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);\n\t\t\t\t\tif (byID2 != null \u0026\u0026 byID2.itemDef != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayer.blueprints.Unlock(byID2.itemDef);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, \u0022techtree\u0022, 0, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.Log(\u0022Player unlocked group :\u0022 \u002B byID.groupName);\n\t\t\t}\n\t\t\telse if (byID.itemDef != null \u0026\u0026 Interface.CallHook(\u0022OnTechTreeNodeUnlock\u0022, this, byID, player) == null)\n\t\t\t{\n\t\t\t\tint tax;\n\t\t\t\tint num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);\n\t\t\t\tint itemid = ItemManager.FindItemDefinition(\u0022scrap\u0022).itemid;\n\t\t\t\tif (player.inventory.GetAmount(itemid) \u003E= num \u002B tax)\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.Take(null, itemid, num \u002B tax);\n\t\t\t\t\tplayer.blueprints.Unlock(byID.itemDef);\n\t\t\t\t\tInterface.CallHook(\u0022OnTechTreeNodeUnlocked\u0022, this, byID, player);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, \u0022techtree\u0022, num \u002B tax, this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 37
  },
  {
    "HookSignature": "OnFireBallSpread(FireBall fireBall, BaseEntity baseEntity)",
    "MethodSignature": "TryToSpread()",
    "MethodSourseCode": "\n\tpublic void TryToSpread()\n\t{\n\t\tfloat num = 0.9f - generation * 0.1f;\n\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C num \u0026\u0026 spreadSubEntity.isValid)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.transform.position = base.transform.position \u002B Vector3.up * 0.25f;\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t\tVector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up);\n\t\t\t\tbaseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);\n\t\t\t\tInterface.CallHook(\u0022OnFireBallSpread\u0022, this, baseEntity);\n\t\t\t\tbaseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));\n\t\t\t\tbaseEntity.SendMessage(\u0022SetGeneration\u0022, generation \u002B 1f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "FireBall",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnCounterModeToggle(PowerCounter powerCounter, BasePlayer msgPlayer, bool flag)",
    "MethodSignature": "ToggleDisplayMode(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ToggleDisplayMode(RPCMessage msg)\n\t{\n\t\tbool flag = msg.read.Bit();\n\t\tif (Interface.CallHook(\u0022OnCounterModeToggle\u0022, this, msg.player, flag) == null \u0026\u0026 msg.player.CanBuild())\n\t\t{\n\t\t\tSetFlag(Flags.Reserved2, flag, recursive: false, networkupdate: false);\n\t\t\tMarkDirty();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "PowerCounter",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerKicked(Network.Connection connection, string actionReasonDetailsString)",
    "MethodSignature": "OnClientActionRequired(OnClientActionRequiredCallbackInfo data)",
    "MethodSourseCode": "\n\tprivate static void OnClientActionRequired(ref OnClientActionRequiredCallbackInfo data)\n\t{\n\t\tusing (TimeWarning.New(\u0022OnClientActionRequired\u0022, 10))\n\t\t{\n\t\t\tIntPtr clientHandle = data.ClientHandle;\n\t\t\tConnection connection = GetConnection(clientHandle);\n\t\t\tif (connection == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022[EAC] Status update for invalid client: \u0022 \u002B clientHandle);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (data.ClientAction != AntiCheatCommonClientAction.RemovePlayer)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tUtf8String actionReasonDetailsString = data.ActionReasonDetailsString;\n\t\t\t\tif (connection.IsDevelopmentBuild())\n\t\t\t\t{\n\t\t\t\t\tDebug.LogWarning(\u0022[EAC] Remove player action skipped for unprotected client: \u0022 \u002B connection.ToString());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tDebug.Log($\u0022[EAC] Kicking {connection.userid} / {connection.username} ({actionReasonDetailsString})\u0022);\n\t\t\t\tconnection.authStatusEAC = \u0022eac\u0022;\n\t\t\t\tNetwork.Net.sv.Kick(connection, \u0022EAC: \u0022 \u002B actionReasonDetailsString);\n\t\t\t\tOxide.Core.Interface.CallHook(\u0022OnPlayerKicked\u0022, connection, actionReasonDetailsString.ToString());\n\t\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned || data.ActionReasonCode == AntiCheatCommonClientActionReason.TemporaryBanned)\n\t\t\t\t{\n\t\t\t\t\tconnection.authStatusEAC = \u0022eacbanned\u0022;\n\t\t\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 2, 0, \u0022\u003Ccolor=#fff\u003ESERVER\u003C/color\u003E Kicking \u0022 \u002B connection.username \u002B \u0022 (banned by anticheat)\u0022);\n\t\t\t\t\tOxide.Core.Interface.CallHook(\u0022OnPlayerBanned\u0022, connection, actionReasonDetailsString.ToString());\n\t\t\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned)\n\t\t\t\t\t{\n\t\t\t\t\t\tEntity.DeleteBy(connection.userid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tUnregisterClientOptions unregisterClientOptions = default(UnregisterClientOptions);\n\t\t\t\tunregisterClientOptions.ClientHandle = clientHandle;\n\t\t\t\tUnregisterClientOptions options = unregisterClientOptions;\n\t\t\t\tInterface.UnregisterClient(ref options);\n\t\t\t\tclient2connection.TryRemove((uint)(int)clientHandle, out var _);\n\t\t\t\tconnection2client.TryRemove(connection, out var _);\n\t\t\t\tconnection2status.TryRemove(connection, out var _);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "EACServer",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "CanAdministerVending(BasePlayer player, VendingMachine vendingMachine)",
    "MethodSignature": "CanPlayerAdmin(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanPlayerAdmin(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanAdministerVending\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (PlayerBehind(player))\n\t\t{\n\t\t\treturn OccupiedCheck(player);\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTick()",
    "MethodSignature": "DoTick()",
    "MethodSourseCode": "\n\tprivate void DoTick()\n\t{\n\t\tInterface.CallHook(\u0022OnTick\u0022);\n\t\tRCon.Update();\n\t\tCompanionServer.Server.Update();\n\t\tNexusServer.Update();\n\t\tfor (int i = 0; i \u003C Network.Net.sv.connections.Count; i\u002B\u002B)\n\t\t{\n\t\t\tNetwork.Connection connection = Network.Net.sv.connections[i];\n\t\t\tif (!connection.isAuthenticated \u0026\u0026 !(connection.GetSecondsConnected() \u003C (float)ConVar.Server.authtimeout))\n\t\t\t{\n\t\t\t\tNetwork.Net.sv.Kick(connection, \u0022Authentication Timed Out\u0022);\n\t\t\t}\n\t\t}\n\t\tfloat num = Mathf.Max(ConVar.Server.premiumRecheckInterval, 60f);\n\t\tif (ConVar.Server.premium \u0026\u0026 (double)sinceLastPremiumRecheck \u003E (double)num)\n\t\t{\n\t\t\tsinceLastPremiumRecheck = 0.0;\n\t\t\tRecheckPremiumStatus();\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnIngredientsCollect(ItemCrafter itemCrafter, ItemBlueprint bp, ItemCraftTask task, int amount, BasePlayer player, bool takeBroken)",
    "MethodSignature": "CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount, BasePlayer player, bool takeBroken)",
    "MethodSourseCode": "\n\tprivate void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount = 1, BasePlayer player = null, bool takeBroken = true)\n\t{\n\t\tif (Interface.CallHook(\u0022OnIngredientsCollect\u0022, this, bp, task, amount, player, takeBroken) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003CItem\u003E list = new List\u003CItem\u003E();\n\t\tforeach (ItemAmount ingredient in bp.GetIngredients())\n\t\t{\n\t\t\tCollectIngredient(ingredient.itemid, (int)ingredient.amount * amount, list, takeBroken);\n\t\t}\n\t\tforeach (Item item in list)\n\t\t{\n\t\t\titem.CollectedForCrafting(player);\n\t\t}\n\t\ttask.takenItems = list;\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSendModelState(BasePlayer basePlayer)",
    "MethodSignature": "SendModelState(bool force)",
    "MethodSourseCode": "\n\tpublic void SendModelState(bool force = false)\n\t{\n\t\tif (!force \u0026\u0026 (!wantsSendModelState || nextModelStateUpdate \u003E UnityEngine.Time.time))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\twantsSendModelState = false;\n\t\tnextModelStateUpdate = UnityEngine.Time.time \u002B 0.1f;\n\t\tif (!IsDead() \u0026\u0026 !IsSpectating())\n\t\t{\n\t\t\tmodelState.sleeping = IsSleeping();\n\t\t\tmodelState.mounted = isMounted;\n\t\t\tmodelState.ragdolling = IsRagdolling();\n\t\t\tmodelState.relaxed = IsRelaxed();\n\t\t\tmodelState.onPhone = HasActiveTelephone \u0026\u0026 !activeTelephone.IsMobile;\n\t\t\tmodelState.crawling = IsCrawling();\n\t\t\tif (!base.limitNetworking \u0026\u0026 Interface.CallHook(\u0022OnSendModelState\u0022, this) == null)\n\t\t\t{\n\t\t\t\tmodelState.loading = IsLoadingAfterTransfer();\n\t\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022OnModelState\u0022), modelState);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnIORefCleared(IOEntity.IORef iOEntity.IORef, IOEntity obj)",
    "MethodSignature": "Clear()",
    "MethodSourseCode": "\n\t\tpublic void Clear()\n\t\t{\n\t\t\tIOEntity obj = ioEnt;\n\t\t\tioEnt = null;\n\t\t\tentityRef.Set(null);\n\t\t\tInterface.CallHook(\u0022OnIORefCleared\u0022, this, obj);\n\t\t}\n",
    "ClassName": "IOEntity",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnLiquidWeaponFiringStopped(LiquidWeapon liquidWeapon)",
    "MethodSignature": "StopFiring()",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server]\n\tprivate void StopFiring()\n\t{\n\t\tCancelInvoke(FireTick);\n\t\tif (!RequiresPumping)\n\t\t{\n\t\t\tpressure = MaxPressure;\n\t\t}\n\t\tSetFlag(Flags.On, b: false);\n\t\tif (base.isServer)\n\t\t{\n\t\t\tSendNetworkUpdateImmediate();\n\t\t}\n\t\tInterface.CallHook(\u0022OnLiquidWeaponFiringStopped\u0022, this);\n\t}\n",
    "ClassName": "LiquidWeapon",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnEntityControl(RemoteControlEntity remoteControlEntity, ulong playerID)",
    "MethodSignature": "CanControl(ulong playerID)",
    "MethodSourseCode": "\n\tpublic virtual bool CanControl(ulong playerID)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnEntityControl\u0022, this, playerID);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RemoteControlEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFireworkDesignChanged(PatternFirework patternFirework, ProtoBuf.PatternFirework.Design design, BasePlayer rpcPlayer)",
    "MethodSignature": "ServerSetFireworkDesign(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(5uL)]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tprivate void ServerSetFireworkDesign(RPCMessage rpc)\n\t{\n\t\tif (!PlayerCanModify(rpc.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tProtoBuf.PatternFirework.Design design = rpc.read.Proto\u003CProtoBuf.PatternFirework.Design\u003E();\n\t\tif (Interface.CallHook(\u0022OnFireworkDesignChange\u0022, this, design, rpc.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (design?.stars != null)\n\t\t{\n\t\t\twhile (design.stars.Count \u003E MaxStars)\n\t\t\t{\n\t\t\t\tint index = design.stars.Count - 1;\n\t\t\t\tdesign.stars[index].Dispose();\n\t\t\t\tdesign.stars.RemoveAt(index);\n\t\t\t}\n\t\t\tforeach (ProtoBuf.PatternFirework.Star star in design.stars)\n\t\t\t{\n\t\t\t\tstar.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));\n\t\t\t\tstar.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);\n\t\t\t}\n\t\t\tdesign.editedBy = rpc.player.userID;\n\t\t}\n\t\tDesign?.Dispose();\n\t\tDesign = design;\n\t\tInterface.CallHook(\u0022OnFireworkDesignChanged\u0022, this, design, rpc.player);\n\t\tSendNetworkUpdateImmediate();\n\t}\n",
    "ClassName": "PatternFirework",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnEntitySnapshot(BaseNetworkable ent, Network.Connection netConnection)",
    "MethodSignature": "SendEntitySnapshot(BaseNetworkable ent)",
    "MethodSourseCode": "\n\tpublic void SendEntitySnapshot(BaseNetworkable ent)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntitySnapshot\u0022, ent, net.connection) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022SendEntitySnapshot\u0022))\n\t\t{\n\t\t\tif (!(ent == null) \u0026\u0026 ent.net != null \u0026\u0026 ent.ShouldNetworkTo(this))\n\t\t\t{\n\t\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\t\tnet.connection.validate.entityUpdates\u002B\u002B;\n\t\t\t\tSaveInfo saveInfo = default(SaveInfo);\n\t\t\t\tsaveInfo.forConnection = net.connection;\n\t\t\t\tsaveInfo.forDisk = false;\n\t\t\t\tSaveInfo saveInfo2 = saveInfo;\n\t\t\t\tnetWrite.PacketID(Message.Type.Entities);\n\t\t\t\tnetWrite.UInt32(net.connection.validate.entityUpdates);\n\t\t\t\tent.ToStreamForNetwork(netWrite, saveInfo2);\n\t\t\t\tnetWrite.Send(new SendInfo(net.connection));\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemCraftCancelled(ItemCraftTask itemCraftTask, ItemCrafter itemCrafter)",
    "MethodSignature": "CancelTask(int iID)",
    "MethodSourseCode": "\n\tpublic bool CancelTask(int iID)\n\t{\n\t\tif (queue.Count == 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (owner != null \u0026\u0026 owner.IsTransferring())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) =\u003E x.taskUID == iID \u0026\u0026 !x.cancelled);\n\t\tif (itemCraftTask == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\titemCraftTask.cancelled = true;\n\t\tif (owner == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemCraftCancelled\u0022, itemCraftTask, this);\n\t\towner.Command(\u0022note.craft_done\u0022, itemCraftTask.taskUID, 0);\n\t\tif (itemCraftTask.takenItems != null \u0026\u0026 itemCraftTask.takenItems.Count \u003E 0)\n\t\t{\n\t\t\tforeach (Item takenItem in itemCraftTask.takenItems)\n\t\t\t{\n\t\t\t\tif (takenItem != null \u0026\u0026 takenItem.amount \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tif (takenItem.IsBlueprint() \u0026\u0026 takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)\n\t\t\t\t\t{\n\t\t\t\t\t\ttakenItem.UseItem(itemCraftTask.numCrafted);\n\t\t\t\t\t}\n\t\t\t\t\tif (takenItem.amount \u003E 0 \u0026\u0026 !takenItem.MoveToContainer(owner.inventory.containerMain))\n\t\t\t\t\t{\n\t\t\t\t\t\ttakenItem.Drop(owner.inventory.containerMain.dropPosition \u002B UnityEngine.Random.value * Vector3.down \u002B UnityEngine.Random.insideUnitSphere, owner.inventory.containerMain.dropVelocity);\n\t\t\t\t\t\towner.Command(\u0022note.inv\u0022, takenItem.info.itemid, -takenItem.amount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\titemCraftTask.takenItems.Clear();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnPayForPlacement(BasePlayer player, Planner planner, Construction component)",
    "MethodSignature": "PayForPlacement(BasePlayer player, Construction component)",
    "MethodSourseCode": "\n\tpublic virtual void PayForPlacement(BasePlayer player, Construction component)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPayForPlacement\u0022, player, this, component) != null || (player.IsInCreativeMode \u0026\u0026 Creative.freeBuild))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (player.IsInTutorial)\n\t\t{\n\t\t\tTutorialIsland currentTutorialIsland = player.GetCurrentTutorialIsland();\n\t\t\tif (currentTutorialIsland != null)\n\t\t\t{\n\t\t\t\tcurrentTutorialIsland.OnPlayerBuiltConstruction(player);\n\t\t\t}\n\t\t}\n\t\tif (isTypeDeployable)\n\t\t{\n\t\t\tGetItem().UseItem();\n\t\t\treturn;\n\t\t}\n\t\tList\u003CItem\u003E obj = Facepunch.Pool.Get\u003CList\u003CItem\u003E\u003E();\n\t\tforeach (ItemAmount item in component.defaultGrade.CostToBuild())\n\t\t{\n\t\t\tplayer.inventory.Take(obj, item.itemDef.itemid, (int)item.amount);\n\t\t\tplayer.Command(\u0022note.inv\u0022, item.itemDef.itemid, item.amount * -1f);\n\t\t}\n\t\tforeach (Item item2 in obj)\n\t\t{\n\t\t\titem2.Remove();\n\t\t}\n\t\tFacepunch.Pool.Free(ref obj, freeElements: false);\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCupboardAuthorize(VehiclePrivilege vehiclePrivilege, BasePlayer rpcPlayer)",
    "MethodSignature": "AddSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void AddSelfAuthorize(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 IsDriver(rpc.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardAuthorize\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tAddPlayer(rpc.player);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "VehiclePrivilege",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPhoneCallStarted(PhoneController phoneController, PhoneController activeCallTo, BasePlayer currentPlayer)",
    "MethodSignature": "BeginCall()",
    "MethodSourseCode": "\n\tpublic void BeginCall()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneCallStart\u0022, this, activeCallTo, currentPlayer) == null)\n\t\t{\n\t\t\tif (IsMobile \u0026\u0026 activeCallTo != null \u0026\u0026 !activeCallTo.RequirePower)\n\t\t\t{\n\t\t\t\t_ = currentPlayer != null;\n\t\t\t}\n\t\t\tSetPhoneStateWithPlayer(Telephone.CallState.InProcess);\n\t\t\tInvoke(TimeOutCall, TelephoneManager.MaxCallLength);\n\t\t\tInterface.CallHook(\u0022OnPhoneCallStarted\u0022, this, activeCallTo, currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "CanBuild(Planner planner, Construction construction, Construction.Target target)",
    "MethodSignature": "DoBuild(CreateBuilding msg)",
    "MethodSourseCode": "\n\tpublic virtual void DoBuild(CreateBuilding msg)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ConVar.AntiHack.objectplacement \u0026\u0026 ownerPlayer.TriggeredMovementAntiHack())\n\t\t{\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.AntihackWithReason, false, ownerPlayer.lastViolationType.ToString());\n\t\t\treturn;\n\t\t}\n\t\tConstruction construction = PrefabAttribute.server.Find\u003CConstruction\u003E(msg.blockID);\n\t\tif (construction == null)\n\t\t{\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindConstruction, false);\n\t\t\tConstructionErrors.Log(ownerPlayer, msg.blockID.ToString());\n\t\t\treturn;\n\t\t}\n\t\tif (!CanAffordToPlace(construction))\n\t\t{\n\t\t\tusing (ItemAmountList itemAmountList = Facepunch.Pool.Get\u003CItemAmountList\u003E())\n\t\t\t{\n\t\t\t\titemAmountList.amount = Facepunch.Pool.Get\u003CList\u003Cfloat\u003E\u003E();\n\t\t\t\titemAmountList.itemID = Facepunch.Pool.Get\u003CList\u003Cint\u003E\u003E();\n\t\t\t\tGetConstructionCost(itemAmountList, construction);\n\t\t\t\townerPlayer.ClientRPC(RpcTarget.Player(\u0022Client_OnRepairFailedResources\u0022, ownerPlayer), itemAmountList);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (!ownerPlayer.CanBuild() \u0026\u0026 !construction.canBypassBuildingPermission)\n\t\t{\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);\n\t\t\treturn;\n\t\t}\n\t\tDeployable deployable = GetDeployable(msg.entity);\n\t\tif (construction.deployable != deployable)\n\t\t{\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.DeployableMismatch, false);\n\t\t\treturn;\n\t\t}\n\t\tConstruction.Target target = default(Construction.Target);\n\t\tif (msg.entity.IsValid)\n\t\t{\n\t\t\ttarget.entity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;\n\t\t\tif (target.entity == null)\n\t\t\t{\n\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindEntity, false);\n\t\t\t\tConstructionErrors.Log(ownerPlayer, msg.entity.ToString());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmsg.ray = new Ray(target.entity.transform.TransformPoint(msg.ray.origin), target.entity.transform.TransformDirection(msg.ray.direction));\n\t\t\tmsg.position = target.entity.transform.TransformPoint(msg.position);\n\t\t\tmsg.normal = target.entity.transform.TransformDirection(msg.normal);\n\t\t\tmsg.rotation = target.entity.transform.rotation * msg.rotation;\n\t\t\tif (msg.socket != 0)\n\t\t\t{\n\t\t\t\tstring text = StringPool.Get(msg.socket);\n\t\t\t\tif (text != \u0022\u0022)\n\t\t\t\t{\n\t\t\t\t\ttarget.socket = FindSocket(text, target.entity.prefabID);\n\t\t\t\t}\n\t\t\t\tif (target.socket == null)\n\t\t\t\t{\n\t\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindSocket, false);\n\t\t\t\t\tConstructionErrors.Log(ownerPlayer, msg.socket.ToString());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (target.entity is Door)\n\t\t\t{\n\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantDeployOnDoor, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttarget.ray = msg.ray;\n\t\ttarget.onTerrain = msg.onterrain;\n\t\ttarget.position = msg.position;\n\t\ttarget.normal = msg.normal;\n\t\ttarget.rotation = msg.rotation;\n\t\ttarget.player = ownerPlayer;\n\t\ttarget.isHoldingShift = msg.isHoldingShift;\n\t\ttarget.valid = true;\n\t\tif (Interface.CallHook(\u0022CanBuild\u0022, this, construction, target) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ShouldParent(target.entity, deployable))\n\t\t{\n\t\t\tVector3 position = ((target.socket != null) ? target.GetWorldPosition() : target.position);\n\t\t\tfloat num = target.entity.Distance(position);\n\t\t\tif (num \u003E 1f)\n\t\t\t{\n\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.ParentTooFar, false);\n\t\t\t\tConstructionErrors.Log(ownerPlayer, num.ToString());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tBaseEntity baseEntity = DoBuild(target, construction);\n\t\tif (baseEntity != null \u0026\u0026 baseEntity is BuildingBlock buildingBlock \u0026\u0026 ownerPlayer.IsInCreativeMode \u0026\u0026 Creative.freeBuild)\n\t\t{\n\t\t\tConstructionGrade constructionGrade = construction.grades[msg.setToGrade];\n\t\t\tif (buildingBlock.currentGrade != constructionGrade)\n\t\t\t{\n\t\t\t\tbuildingBlock.ChangeGradeAndSkin(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);\n\t\t\t}\n\t\t}\n\t\tif (baseEntity != null \u0026\u0026 baseEntity is DecayEntity decayEntity)\n\t\t{\n\t\t\tdecayEntity.timePlaced = GetNetworkTime();\n\t\t}\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 84
  },
  {
    "HookSignature": "OnDigitalClockRingStop(DigitalClock digitalClock)",
    "MethodSignature": "StopRinging()",
    "MethodSourseCode": "\n\tprivate void StopRinging()\n\t{\n\t\tif (Interface.CallHook(\u0022OnDigitalClockRingStop\u0022, this) == null)\n\t\t{\n\t\t\tisRinging = false;\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022RPC_StopRinging\u0022));\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "DigitalClock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSleepingBagDestroy(SleepingBag sleepingBag2, ulong userID)",
    "MethodSignature": "DestroyBag(ulong userID, NetworkableId sleepingBag)",
    "MethodSourseCode": "\n\tpublic static bool DestroyBag(ulong userID, NetworkableId sleepingBag)\n\t{\n\t\tSleepingBag sleepingBag2 = FindForPlayer(userID, ignoreTimers: true).FirstOrDefault((SleepingBag x) =\u003E x.net.ID == sleepingBag);\n\t\tif (sleepingBag2 == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnSleepingBagDestroy\u0022, sleepingBag2, userID) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tRemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);\n\t\tsleepingBag2.deployerUserID = 0uL;\n\t\tif (sleepingBag2.HasFlag(Flags.Reserved14))\n\t\t{\n\t\t\tsleepingBag2.Kill();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsleepingBag2.SendNetworkUpdate();\n\t\t}\n\t\tBasePlayer basePlayer = BasePlayer.FindByID(userID);\n\t\tif (basePlayer != null)\n\t\t{\n\t\t\tbasePlayer.SendRespawnOptions();\n\t\t\tInterface.CallHook(\u0022OnSleepingBagDestroyed\u0022, sleepingBag2, userID);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnPhoneDialTimedOut(PhoneController activeCallTo, PhoneController phoneController, BasePlayer activeCallToCurrentPlayer)",
    "MethodSignature": "TimeOutDialing()",
    "MethodSourseCode": "\n\tprivate void TimeOutDialing()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneDialTimeout\u0022, activeCallTo, this, activeCallTo.currentPlayer) == null)\n\t\t{\n\t\t\tif (activeCallTo != null)\n\t\t\t{\n\t\t\t\tactiveCallTo.ServerPlayAnsweringMessage(this);\n\t\t\t}\n\t\t\tSetPhoneState(Telephone.CallState.Idle);\n\t\t\tInterface.CallHook(\u0022OnPhoneDialTimedOut\u0022, activeCallTo, this, activeCallTo.currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnPlayerStudyBlueprint(BasePlayer player, Item item)",
    "MethodSignature": "ServerCommand(Item item, string command, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void ServerCommand(Item item, string command, BasePlayer player)\n\t{\n\t\tif (command != \u0022study\u0022 || !item.IsBlueprint())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (item.GetOwnerPlayer() != player \u0026\u0026 player.inventory.GetBackpackWithInventory()?.contents != item.parent)\n\t\t{\n\t\t\tbool flag = false;\n\t\t\tforeach (ItemContainer container in player.inventory.loot.containers)\n\t\t\t{\n\t\t\t\tif (item.GetRootContainer() == container)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (IsBlueprintUnlocked(item, player, out var blueprintTargetDef, out var blueprint) || Interface.CallHook(\u0022OnPlayerStudyBlueprint\u0022, player, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item2 = item;\n\t\tif (item.amount \u003E 1)\n\t\t{\n\t\t\titem2 = item.SplitItem(1);\n\t\t}\n\t\titem2.UseItem();\n\t\tplayer.blueprints.Unlock(blueprintTargetDef);\n\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, blueprintTargetDef, \u0022blueprint\u0022, ResearchTable.ScrapForResearch(blueprintTargetDef), player);\n\t\tif (blueprint != null \u0026\u0026 blueprint.additionalUnlocks != null \u0026\u0026 blueprint.additionalUnlocks.Count \u003E 0)\n\t\t{\n\t\t\tforeach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)\n\t\t\t{\n\t\t\t\tplayer.blueprints.Unlock(additionalUnlock);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, additionalUnlock, \u0022blueprint\u0022, 0, player);\n\t\t\t}\n\t\t}\n\t\tif (studyEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(studyEffect.resourcePath, player, StringPool.Get(\u0022head\u0022), Vector3.zero, Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "ItemModStudyBlueprint",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnBradleyApcPatrol(BradleyAPC bradleyAPC)",
    "MethodSignature": "UpdateMovement_Patrol()",
    "MethodSourseCode": "\n\tpublic void UpdateMovement_Patrol()\n\t{\n\t\tif (patrolPath == null || UnityEngine.Time.time \u003C nextPatrolTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextPatrolTime = UnityEngine.Time.time \u002B 20f;\n\t\tif ((HasPath() \u0026\u0026 !IsAtFinalDestination()) || Interface.CallHook(\u0022OnBradleyApcPatrol\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIAIPathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);\n\t\tIAIPathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.Position);\n\t\tbool flag = false;\n\t\tList\u003CIAIPathNode\u003E nodes = Facepunch.Pool.Get\u003CList\u003CIAIPathNode\u003E\u003E();\n\t\tIAIPathNode iAIPathNode;\n\t\tif (GetEngagementPath(ref nodes))\n\t\t{\n\t\t\tflag = true;\n\t\t\tiAIPathNode = nodes[nodes.Count - 1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tiAIPathNode = patrolPath.GetClosestToPoint(base.transform.position);\n\t\t}\n\t\tif (!(Vector3.Distance(finalDestination, closestToPoint.Position) \u003E 2f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (closestToPoint == iAIPathNode)\n\t\t{\n\t\t\tcurrentPath.Clear();\n\t\t\tcurrentPath.Add(closestToPoint.Position);\n\t\t\tcurrentPathIndex = -1;\n\t\t\tpathLooping = false;\n\t\t\tfinalDestination = closestToPoint.Position;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!AStarPath.FindPath(iAIPathNode, closestToPoint, out var path, out var _))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcurrentPath.Clear();\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C nodes.Count - 1; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tcurrentPath.Add(nodes[i].Position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach (IAIPathNode item in path)\n\t\t\t{\n\t\t\t\tcurrentPath.Add(item.Position);\n\t\t\t}\n\t\t\tcurrentPathIndex = -1;\n\t\t\tpathLooping = false;\n\t\t\tfinalDestination = closestToPoint.Position;\n\t\t}\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnDoorClosed(Door door, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_CloseDoor(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_CloseDoor(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract(usableWhileCrawling: true) || !canHandOpen || !IsOpen() || IsBusy() || IsLocked())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (rpc.player.IsWounded())\n\t\t{\n\t\t\tif (!woundedCloses.ContainsKey(rpc.player) || !((float)woundedCloses[rpc.player] \u003E 2.5f))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twoundedCloses.Remove(rpc.player);\n\t\t}\n\t\tBaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;\n\t\tif (!(baseLock != null) || baseLock.OnTryToClose(rpc.player))\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: false);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tif (isSecurityDoor \u0026\u0026 NavMeshLink != null)\n\t\t\t{\n\t\t\t\tSetNavMeshLinkEnabled(wantsOn: false);\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnBaseInteract(rpc.player, this);\n\t\t\tStartCheckingForBlockages(isOpening: false);\n\t\t\tInterface.CallHook(\u0022OnDoorClosed\u0022, this, rpc.player);\n\t\t}\n\t}\n",
    "ClassName": "Door",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "CanPurchaseItem(BasePlayer buyer, Item item4, System.Action\u003CBasePlayer, Item\u003E onItemPurchased, VendingMachine vendingMachine, ItemContainer targetContainer)",
    "MethodSignature": "DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions, ItemContainer targetContainer, Action\u003CBasePlayer, Item\u003E onCurrencyRemoved, Action\u003CBasePlayer, Item\u003E onItemPurchased, MarketTerminal droneMarketTerminal)",
    "MethodSourseCode": "\n\tpublic bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action\u003CBasePlayer, Item\u003E onCurrencyRemoved = null, Action\u003CBasePlayer, Item\u003E onItemPurchased = null, MarketTerminal droneMarketTerminal = null)\n\t{\n\t\tif (sellOrderId \u003C 0 || sellOrderId \u003E= sellOrders.sellOrders.Count)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (targetContainer == null \u0026\u0026 Vector3.Distance(buyer.transform.position, base.transform.position) \u003E 4f)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnVendingTransaction\u0022, this, buyer, sellOrderId, numberOfTransactions, targetContainer);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];\n\t\tList\u003CItem\u003E obj2 = Facepunch.Pool.Get\u003CList\u003CItem\u003E\u003E();\n\t\tGetItemsToSell(sellOrder, obj2);\n\t\tif (obj2 == null || obj2.Count == 0)\n\t\t{\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tnumberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);\n\t\tint num = sellOrder.itemToSellAmount * numberOfTransactions;\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellOrder.itemToSellID);\n\t\tItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(sellOrder.currencyID);\n\t\tif (!itemDefinition.IsAllowed(CurrentEraRestriction) || !itemDefinition2.IsAllowed(CurrentEraRestriction))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (itemDefinition == NPCVendingMachine.ScrapItem \u0026\u0026 sellOrder.receivedQuantityMultiplier != 1f)\n\t\t{\n\t\t\tnum = GetTotalReceivedMerchandiseForOrder(sellOrder.itemToSellAmount, sellOrder.receivedQuantityMultiplier) * numberOfTransactions;\n\t\t}\n\t\tint num2 = obj2.Sum((Item x) =\u003E x.amount);\n\t\tif (num \u003E num2)\n\t\t{\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tint num3 = 0;\n\t\tusing PooledList\u003CItem\u003E pooledList2 = Facepunch.Pool.Get\u003CPooledList\u003CItem\u003E\u003E();\n\t\tusing (PooledList\u003CItem\u003E pooledList = Facepunch.Pool.Get\u003CPooledList\u003CItem\u003E\u003E())\n\t\t{\n\t\t\tbuyer.inventory.FindItemsByItemID(pooledList, sellOrder.currencyIsBP ? blueprintBaseDef.itemid : sellOrder.currencyID);\n\t\t\tfor (int i = 0; i \u003C pooledList.Count; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tItem item = pooledList[i];\n\t\t\t\tif ((!sellOrder.currencyIsBP || item.blueprintTarget == sellOrder.currencyID) \u0026\u0026 (!item.hasCondition || (item.conditionNormalized \u003E= 0.5f \u0026\u0026 item.maxConditionNormalized \u003E 0.5f)) \u0026\u0026 item.GetItemVolume() \u003C= maxCurrencyVolume)\n\t\t\t\t{\n\t\t\t\t\tpooledList2.Add(item);\n\t\t\t\t\tnum3 \u002B= item.amount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pooledList2.Count == 0)\n\t\t{\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tint num4 = GetTotalPriceForOrder(sellOrder) * numberOfTransactions;\n\t\tif (num3 \u003C num4)\n\t\t{\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\ttransactionActive = true;\n\t\tint num5 = 0;\n\t\tfor (int j = 0; j \u003C pooledList2.Count; j\u002B\u002B)\n\t\t{\n\t\t\tItem item2 = pooledList2[j];\n\t\t\tint num6 = Mathf.Min(num4 - num5, item2.amount);\n\t\t\tItem item3 = ((item2.amount \u003E num6) ? item2.SplitItem(num6) : item2);\n\t\t\tTakeCurrencyItem(item3);\n\t\t\tonCurrencyRemoved?.Invoke(buyer, item3);\n\t\t\tnum5 \u002B= num6;\n\t\t\tif (num5 \u003E= num4)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint num7 = 0;\n\t\tforeach (Item item5 in obj2)\n\t\t{\n\t\t\tint num8 = num - num7;\n\t\t\tItem item4 = ((item5.amount \u003E num8) ? item5.SplitItem(num8) : item5);\n\t\t\tif (item4 == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022Vending machine error, contact developers!\u0022);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum7 \u002B= item4.amount;\n\t\t\t\tobject obj3 = Interface.CallHook(\u0022CanPurchaseItem\u0022, buyer, item4, onItemPurchased, this, targetContainer);\n\t\t\t\tif (obj3 != null)\n\t\t\t\t{\n\t\t\t\t\tif (!(obj3 is bool))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn (bool)obj3;\n\t\t\t\t}\n\t\t\t\tRecordSaleAnalytics(item4, sellOrderId, sellOrder.currencyAmountPerItem);\n\t\t\t\tif (targetContainer == null)\n\t\t\t\t{\n\t\t\t\t\tGiveSoldItem(item4, buyer);\n\t\t\t\t}\n\t\t\t\telse if (!item4.MoveToContainer(targetContainer))\n\t\t\t\t{\n\t\t\t\t\titem4.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);\n\t\t\t\t}\n\t\t\t\tif (ShouldRecordStats)\n\t\t\t\t{\n\t\t\t\t\tRegisterCustomer(buyer.userID);\n\t\t\t\t}\n\t\t\t\tonItemPurchased?.Invoke(buyer, item4);\n\t\t\t}\n\t\t\tif (num7 \u003E= num)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFacepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, num, sellOrder.itemToSellIsBP, sellOrder.currencyID, num5, sellOrder.currencyIsBP, numberOfTransactions, sellOrder.priceMultiplier, droneMarketTerminal);\n\t\tif (ShouldRecordStats)\n\t\t{\n\t\t\tAddPurchaseHistory(sellOrder.itemToSellID, num, sellOrder.currencyID, num5, sellOrder.itemToSellIsBP, sellOrder.currencyIsBP);\n\t\t}\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\tUpdateEmptyFlag();\n\t\ttransactionActive = false;\n\t\treturn true;\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 95
  },
  {
    "HookSignature": "OnTeamUpdated(ulong currentTeam, ProtoBuf.PlayerTeam playerTeam2, BasePlayer basePlayer)",
    "MethodSignature": "TeamUpdate(bool fullTeamUpdate)",
    "MethodSourseCode": "\n\tpublic void TeamUpdate(bool fullTeamUpdate)\n\t{\n\t\tif (!RelationshipManager.TeamsEnabled() || !IsConnected || currentTeam == 0L)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tRelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(currentTeam);\n\t\tif (playerTeam == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = 0;\n\t\tint num2 = 0;\n\t\tusing PlayerTeam playerTeam2 = Facepunch.Pool.Get\u003CPlayerTeam\u003E();\n\t\tplayerTeam2.teamLeader = playerTeam.teamLeader;\n\t\tplayerTeam2.teamID = playerTeam.teamID;\n\t\tplayerTeam2.teamName = playerTeam.teamName;\n\t\tplayerTeam2.members = Facepunch.Pool.Get\u003CList\u003CPlayerTeam.TeamMember\u003E\u003E();\n\t\tplayerTeam2.teamLifetime = playerTeam.teamLifetime;\n\t\tplayerTeam2.teamPings = Facepunch.Pool.Get\u003CList\u003CMapNote\u003E\u003E();\n\t\tforeach (ulong member in playerTeam.members)\n\t\t{\n\t\t\tBasePlayer basePlayer = RelationshipManager.FindByID(member);\n\t\t\tif ((bool)basePlayer \u0026\u0026 basePlayer.IsInTutorial)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPlayerTeam.TeamMember teamMember = Facepunch.Pool.Get\u003CPlayerTeam.TeamMember\u003E();\n\t\t\tteamMember.displayName = ((basePlayer != null) ? basePlayer.displayName : (SingletonComponent\u003CServerMgr\u003E.Instance.persistance.GetPlayerName(member) ?? \u0022DEAD\u0022));\n\t\t\tteamMember.healthFraction = ((basePlayer != null \u0026\u0026 basePlayer.IsAlive()) ? basePlayer.healthFraction : 0f);\n\t\t\tteamMember.position = ((basePlayer != null) ? basePlayer.transform.position : Vector3.zero);\n\t\t\tteamMember.online = basePlayer != null \u0026\u0026 !basePlayer.IsSleeping();\n\t\t\tteamMember.wounded = basePlayer != null \u0026\u0026 basePlayer.IsWounded();\n\t\t\tif ((!sentInstrumentTeamAchievement || !sentSummerTeamAchievement) \u0026\u0026 basePlayer != null)\n\t\t\t{\n\t\t\t\tif ((bool)basePlayer.GetHeldEntity() \u0026\u0026 basePlayer.GetHeldEntity().IsInstrument())\n\t\t\t\t{\n\t\t\t\t\tnum\u002B\u002B;\n\t\t\t\t}\n\t\t\t\tif (basePlayer.isMounted)\n\t\t\t\t{\n\t\t\t\t\tif (basePlayer.GetMounted().IsInstrument())\n\t\t\t\t\t{\n\t\t\t\t\t\tnum\u002B\u002B;\n\t\t\t\t\t}\n\t\t\t\t\tif (basePlayer.GetMounted().IsSummerDlcVehicle)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum2\u002B\u002B;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (num \u003E= 4 \u0026\u0026 !sentInstrumentTeamAchievement)\n\t\t\t\t{\n\t\t\t\t\tGiveAchievement(\u0022TEAM_INSTRUMENTS\u0022);\n\t\t\t\t\tsentInstrumentTeamAchievement = true;\n\t\t\t\t}\n\t\t\t\tif (num2 \u003E= 4)\n\t\t\t\t{\n\t\t\t\t\tGiveAchievement(\u0022SUMMER_INFLATABLE\u0022);\n\t\t\t\t\tsentSummerTeamAchievement = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tteamMember.userID = member;\n\t\t\tplayerTeam2.members.Add(teamMember);\n\t\t\tif (basePlayer != null)\n\t\t\t{\n\t\t\t\tif (basePlayer.State.pings != null \u0026\u0026 basePlayer.State.pings.Count \u003E 0 \u0026\u0026 basePlayer != this)\n\t\t\t\t{\n\t\t\t\t\tplayerTeam2.teamPings.AddRange(basePlayer.State.pings);\n\t\t\t\t}\n\t\t\t\tif (fullTeamUpdate \u0026\u0026 basePlayer != this)\n\t\t\t\t{\n\t\t\t\t\tbasePlayer.TeamUpdate(fullTeamUpdate: false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tplayerTeam2.leaderMapNotes = Facepunch.Pool.Get\u003CList\u003CMapNote\u003E\u003E();\n\t\tPlayerState playerState = SingletonComponent\u003CServerMgr\u003E.Instance.playerStateManager.Get(playerTeam.teamLeader);\n\t\tif (playerState?.pointsOfInterest != null)\n\t\t{\n\t\t\tforeach (MapNote item in playerState.pointsOfInterest)\n\t\t\t{\n\t\t\t\tplayerTeam2.leaderMapNotes.Add(item);\n\t\t\t}\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnTeamUpdated\u0022, currentTeam, playerTeam2, this) == null)\n\t\t{\n\t\t\tClientRPC(RpcTarget.PlayerAndSpectators(\u0022CLIENT_ReceiveTeamInfo\u0022, this), playerTeam2);\n\t\t\tif (playerTeam2.leaderMapNotes != null)\n\t\t\t{\n\t\t\t\tplayerTeam2.leaderMapNotes.Clear();\n\t\t\t}\n\t\t\tif (playerTeam2.teamPings != null)\n\t\t\t{\n\t\t\t\tplayerTeam2.teamPings.Clear();\n\t\t\t}\n\t\t\tBasePlayer basePlayer2 = FindByID(playerTeam.teamLeader);\n\t\t\tif (fullTeamUpdate \u0026\u0026 basePlayer2 != null \u0026\u0026 basePlayer2 != this)\n\t\t\t{\n\t\t\t\tbasePlayer2.TeamUpdate(fullTeamUpdate: false);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 85
  },
  {
    "HookSignature": "InitLogging()",
    "MethodSignature": "StartupShared()",
    "MethodSourseCode": "\n\tprivate void StartupShared()\n\t{\n\t\tInterface.CallHook(\u0022InitLogging\u0022);\n\t\tItemManager.Initialize();\n\t}\n",
    "ClassName": "Bootstrap",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnAttacked(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022IOnBasePlayerAttacked\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat oldHealth = base.health;\n\t\tif (InSafeZone() \u0026\u0026 !IsHostile() \u0026\u0026 info.Initiator != null \u0026\u0026 info.Initiator != this)\n\t\t{\n\t\t\tinfo.damageTypes.ScaleAll(0f);\n\t\t}\n\t\tif (base.isServer)\n\t\t{\n\t\t\tHitArea boneArea = info.boneArea;\n\t\t\tif (boneArea != (HitArea)(-1))\n\t\t\t{\n\t\t\t\tList\u003CItem\u003E obj = Facepunch.Pool.Get\u003CList\u003CItem\u003E\u003E();\n\t\t\t\tobj.AddRange(inventory.containerWear.itemList);\n\t\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tItem item = obj[i];\n\t\t\t\t\tif (item != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tItemModWearable component = item.info.GetComponent\u003CItemModWearable\u003E();\n\t\t\t\t\t\tif (!(component == null) \u0026\u0026 component.ProtectsArea(boneArea))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem.OnAttacked(info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFacepunch.Pool.Free(ref obj, freeElements: false);\n\t\t\t\tinventory.ServerUpdate(0f);\n\t\t\t}\n\t\t}\n\t\tbase.OnAttacked(info);\n\t\tif (base.isServer \u0026\u0026 base.isServer \u0026\u0026 info.hasDamage)\n\t\t{\n\t\t\tif (!info.damageTypes.Has(DamageType.Bleeding) \u0026\u0026 info.damageTypes.IsBleedCausing() \u0026\u0026 !IsWounded() \u0026\u0026 !IsImmortalTo(info) \u0026\u0026 !info.damageTypes.Has(DamageType.BeeSting))\n\t\t\t{\n\t\t\t\tfloat num = ((modifiers != null) ? Mathf.Clamp01(1f - modifiers.GetValue(Modifier.ModifierType.Clotting)) : 1f);\n\t\t\t\tmetabolism.bleeding.Add(info.damageTypes.Total() * 0.2f * num);\n\t\t\t}\n\t\t\tif (isMounted)\n\t\t\t{\n\t\t\t\tGetMounted().MounteeTookDamage(this, info);\n\t\t\t}\n\t\t\tCheckDeathCondition(info);\n\t\t\tif (net != null \u0026\u0026 net.connection != null)\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022TakeDamageHit\u0022, this));\n\t\t\t}\n\t\t\tstring text = StringPool.Get(info.HitBone);\n\t\t\tbool flag = Vector3.Dot((info.PointEnd - info.PointStart).normalized, eyes.BodyForward()) \u003E 0.4f;\n\t\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\n\t\t\tif ((bool)initiatorPlayer \u0026\u0026 !info.damageTypes.IsMeleeType())\n\t\t\t{\n\t\t\t\tinitiatorPlayer.LifeStoryShotHit(info.Weapon);\n\t\t\t}\n\t\t\tif (info.isHeadshot)\n\t\t\t{\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tSignalBroadcast(Signal.Flinch_RearHead, string.Empty);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSignalBroadcast(Signal.Flinch_Head, string.Empty);\n\t\t\t\t}\n\t\t\t\tif (!initiatorPlayer || !initiatorPlayer.limitNetworking)\n\t\t\t\t{\n\t\t\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/headshot.prefab\u0022, this, 0u, new Vector3(0f, 2f, 0f), Vector3.zero, (initiatorPlayer != null) ? initiatorPlayer.net.connection : null);\n\t\t\t\t}\n\t\t\t\tif ((bool)initiatorPlayer)\n\t\t\t\t{\n\t\t\t\t\tinitiatorPlayer.stats.Add(\u0022headshot\u0022, 1, (Stats)5);\n\t\t\t\t\tif (initiatorPlayer.IsBeingSpectated)\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (BaseEntity child in initiatorPlayer.children)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (child is BasePlayer basePlayer)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbasePlayer.ClientRPC(RpcTarget.Player(\u0022SpectatedPlayerHeadshot\u0022, basePlayer));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (flag)\n\t\t\t{\n\t\t\t\tSignalBroadcast(Signal.Flinch_RearTorso, string.Empty);\n\t\t\t}\n\t\t\telse if (text == \u0022spine\u0022 || text == \u0022spine2\u0022)\n\t\t\t{\n\t\t\t\tSignalBroadcast(Signal.Flinch_Stomach, string.Empty);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSignalBroadcast(Signal.Flinch_Chest, string.Empty);\n\t\t\t}\n\t\t}\n\t\tif (stats != null)\n\t\t{\n\t\t\tif (IsWounded())\n\t\t\t{\n\t\t\t\tstats.combat.LogAttack(info, \u0022wounded\u0022, oldHealth);\n\t\t\t}\n\t\t\telse if (IsDead())\n\t\t\t{\n\t\t\t\tstats.combat.LogAttack(info, \u0022killed\u0022, oldHealth);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstats.combat.LogAttack(info, \u0022\u0022, oldHealth);\n\t\t\t}\n\t\t}\n\t\tif (ConVar.Global.cinematicGingerbreadCorpses)\n\t\t{\n\t\t\tinfo.HitMaterial = ConVar.Global.GingerbreadMaterialID();\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanDestroyLock(BasePlayer player, ModularCar modularCar, BaseVehicleModule viaModule)",
    "MethodSignature": "PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule)",
    "MethodSourseCode": "\n\tpublic bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanDestroyLock\u0022, player, this, viaModule);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn CarLock.PlayerCanDestroyLock(viaModule);\n\t}\n",
    "ClassName": "ModularCar",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityFromOwnerCheck(BaseEntity ent, BasePlayer player, uint id, string debugName, bool includeMounted)",
    "MethodSignature": "Test(uint id, string debugName, BaseEntity ent, BasePlayer player, bool includeMounted)",
    "MethodSourseCode": "\n\t\t\tpublic static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, bool includeMounted)\n\t\t\t{\n\t\t\t\tif (ent == null || player == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (ent.net == null || player.net == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnEntityFromOwnerCheck\u0022, ent, player, id, debugName, includeMounted);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tif (ent.net.ID == player.net.ID)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (ent.parentEntity.uid != player.net.ID)\n\t\t\t\t{\n\t\t\t\t\tBaseEntity parentEntity = ent.GetParentEntity();\n\t\t\t\t\tif (parentEntity != null \u0026\u0026 parentEntity.parentEntity.uid == player.net.ID)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (includeMounted)\n\t\t\t\t\t{\n\t\t\t\t\t\tBaseMountable baseMountable = ent as BaseMountable;\n\t\t\t\t\t\tif (baseMountable == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbaseMountable = ent.parentEntity.Get(serverside: true) as BaseMountable;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (baseMountable != null \u0026\u0026 baseMountable.GetMounted()?.net?.ID == player.net.ID)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnRackedWeaponUnload(Item slot, BasePlayer player, WeaponRack weaponRack)",
    "MethodSignature": "UnloadWeapon(BasePlayer player, int mountSlotIndex)",
    "MethodSourseCode": "\n\tprivate void UnloadWeapon(BasePlayer player, int mountSlotIndex)\n\t{\n\t\tif (player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);\n\t\tif (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\n\t\tif (slot == null || Interface.CallHook(\u0022OnRackedWeaponUnload\u0022, slot, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity heldEntity = slot.GetHeldEntity();\n\t\tif (!(heldEntity == null))\n\t\t{\n\t\t\tBaseProjectile component = heldEntity.GetComponent\u003CBaseProjectile\u003E();\n\t\t\tif (!(component == null))\n\t\t\t{\n\t\t\t\tItemDefinition ammoType = component.primaryMagazine.ammoType;\n\t\t\t\tcomponent.UnloadAmmo(slot, player);\n\t\t\t\tSetSlotAmmoDetails(weaponAtIndex, slot);\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022PlayAmmoSound\u0022, player), ammoType.itemid, 1);\n\t\t\t\tInterface.CallHook(\u0022OnRackedWeaponUnloaded\u0022, slot, player, this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "WeaponRack",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnWireConnect(BasePlayer player, IOEntity iOEntity, int inputIndex, IOEntity iOEntity2, int outputIndex, System.Collections.Generic.List\u003CUnityEngine.Vector3\u003E wireConnectionMessageLinePoints, System.Collections.Generic.List\u003Cfloat\u003E slackLevels)",
    "MethodSignature": "RPC_MakeConnection(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server.FromOwner(false)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\tpublic void RPC_MakeConnection(RPCMessage rpc)\n\t{\n\t\tBasePlayer player = rpc.player;\n\t\tif (!CanPlayerUseWires(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tWireConnectionMessage wireConnectionMessage = rpc.read.Proto\u003CWireConnectionMessage\u003E();\n\t\tList\u003CVector3\u003E linePoints = wireConnectionMessage.linePoints;\n\t\tint inputIndex = wireConnectionMessage.inputIndex;\n\t\tint outputIndex = wireConnectionMessage.outputIndex;\n\t\tIOEntity iOEntity = new EntityRef\u003CIOEntity\u003E(wireConnectionMessage.inputID).Get(serverside: true);\n\t\tIOEntity iOEntity2 = new EntityRef\u003CIOEntity\u003E(wireConnectionMessage.outputID).Get(serverside: true);\n\t\tif (iOEntity == null || iOEntity2 == null || !ValidateLine(linePoints, iOEntity, iOEntity2, player, outputIndex) || inputIndex \u003E= iOEntity.inputs.Length || outputIndex \u003E= iOEntity2.outputs.Length || iOEntity.inputs[inputIndex].connectedTo.Get() != null || iOEntity2.outputs[outputIndex].connectedTo.Get() != null || (iOEntity.inputs[inputIndex].rootConnectionsOnly \u0026\u0026 !iOEntity2.IsRootEntity()) || !CanModifyEntity(player, iOEntity) || !CanModifyEntity(player, iOEntity2))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003Cfloat\u003E slackLevels = wireConnectionMessage.slackLevels;\n\t\tIOEntity.LineAnchor[] array = new IOEntity.LineAnchor[wireConnectionMessage.lineAnchors.Count];\n\t\tfor (int i = 0; i \u003C wireConnectionMessage.lineAnchors.Count; i\u002B\u002B)\n\t\t{\n\t\t\tWireLineAnchorInfo wireLineAnchorInfo = wireConnectionMessage.lineAnchors[i];\n\t\t\tarray[i].entityRef = new EntityRef\u003CDoor\u003E(wireLineAnchorInfo.parentID);\n\t\t\tarray[i].boneName = wireLineAnchorInfo.boneName;\n\t\t\tarray[i].index = (int)wireLineAnchorInfo.index;\n\t\t\tarray[i].position = wireLineAnchorInfo.position;\n\t\t}\n\t\tWireColour wireColour = IntToColour(wireConnectionMessage.wireColor);\n\t\tif (Interface.CallHook(\u0022OnWireConnect\u0022, player, iOEntity, inputIndex, iOEntity2, outputIndex, wireConnectionMessage.linePoints, slackLevels) == null)\n\t\t{\n\t\t\tif (wireColour == WireColour.Invisible \u0026\u0026 !player.IsInCreativeMode)\n\t\t\t{\n\t\t\t\twireColour = DefaultColor;\n\t\t\t}\n\t\t\tiOEntity2.ConnectTo(iOEntity, outputIndex, inputIndex, linePoints, slackLevels, array, wireColour);\n\t\t\tif (wireType == IOEntity.IOType.Industrial)\n\t\t\t{\n\t\t\t\tiOEntity.NotifyIndustrialNetworkChanged();\n\t\t\t\tiOEntity2.NotifyIndustrialNetworkChanged();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "WireTool",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "OnVehicleModulesAssign(ModularCar modularCar, Rust.Modular.ItemModVehicleModule[] modularCarPresetConfigSocketItemDefs)",
    "MethodSignature": "SpawnPreassignedModules()",
    "MethodSourseCode": "\n\tpublic void SpawnPreassignedModules()\n\t{\n\t\tif (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];\n\t\tif (Interface.CallHook(\u0022OnVehicleModulesAssign\u0022, this, modularCarPresetConfig.socketItemDefs) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C modularCarPresetConfig.socketItemDefs.Length; i\u002B\u002B)\n\t\t{\n\t\t\tItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];\n\t\t\tif (itemModVehicleModule != null \u0026\u0026 base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(itemModVehicleModule.GetComponent\u003CItemDefinition\u003E(), 1, 0uL);\n\t\t\t\tfloat num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);\n\t\t\t\titem.condition = item.maxCondition * num;\n\t\t\t\tif (!TryAddModule(item))\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnVehicleModulesAssigned\u0022, this, modularCarPresetConfig.socketItemDefs);\n\t\tInvoke(HandleAdminBonus, 0f);\n\t}\n",
    "ClassName": "ModularCar",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnThreatLevelUpdate(BasePlayer basePlayer)",
    "MethodSignature": "EnsureUpdated()",
    "MethodSourseCode": "\n\tpublic void EnsureUpdated()\n\t{\n\t\tif (UnityEngine.Time.realtimeSinceStartup - lastUpdateTime \u003C 30f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tlastUpdateTime = UnityEngine.Time.realtimeSinceStartup;\n\t\tcachedThreatLevel = 0f;\n\t\tif (IsSleeping() || Interface.CallHook(\u0022OnThreatLevelUpdate\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (inventory.containerWear.itemList.Count \u003E 2)\n\t\t{\n\t\t\tcachedThreatLevel \u002B= 1f;\n\t\t}\n\t\tforeach (Item item in inventory.containerBelt.itemList)\n\t\t{\n\t\t\tBaseEntity heldEntity = item.GetHeldEntity();\n\t\t\tif ((bool)heldEntity \u0026\u0026 heldEntity is BaseProjectile \u0026\u0026 !(heldEntity is BowWeapon))\n\t\t\t{\n\t\t\t\tcachedThreatLevel \u002B= 2f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnFireworkDamage(BaseFirework baseFirework, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnAttacked(HitInfo info)\n\t{\n\t\tbase.OnAttacked(info);\n\t\tif (base.isServer \u0026\u0026 Interface.CallHook(\u0022OnFireworkDamage\u0022, this, info) == null \u0026\u0026 info.damageTypes.Has(DamageType.Heat))\n\t\t{\n\t\t\tStaggeredTryLightFuse();\n\t\t}\n\t}\n",
    "ClassName": "BaseFirework",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnVendingShopOpen(InvisibleVendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "OnConversationAction(BasePlayer player, string action)",
    "MethodSourseCode": "\n\tpublic virtual void OnConversationAction(BasePlayer player, string action)\n\t{\n\t\tif (action == \u0022openvending\u0022)\n\t\t{\n\t\t\tInvisibleVendingMachine vendingMachine = GetVendingMachine();\n\t\t\tif (vendingMachine != null \u0026\u0026 Vector3.Distance(player.transform.position, base.transform.position) \u003C 5f)\n\t\t\t{\n\t\t\t\tForceEndConversation(player);\n\t\t\t\tif (Interface.CallHook(\u0022OnVendingShopOpen\u0022, vendingMachine, player) == null)\n\t\t\t\t{\n\t\t\t\t\tvendingMachine.PlayerOpenLoot(player, \u0022vendingmachine.customer\u0022, doPositionChecks: false);\n\t\t\t\t\tInterface.CallHook(\u0022OnVendingShopOpened\u0022, vendingMachine, player);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(\u0022scrap\u0022);\n\t\tNPCConversationResultAction[] array = conversationResultActions;\n\t\tforeach (NPCConversationResultAction nPCConversationResultAction in array)\n\t\t{\n\t\t\tif (!(nPCConversationResultAction.action == action))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCleanupConversingPlayers();\n\t\t\tforeach (BasePlayer conversingPlayer in conversingPlayers)\n\t\t\t{\n\t\t\t\tif (!(conversingPlayer == player) \u0026\u0026 !(conversingPlayer == null))\n\t\t\t\t{\n\t\t\t\t\tint speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex(\u0022startbusy\u0022);\n\t\t\t\t\tForceSpeechNode(conversingPlayer, speechNodeIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint num = nPCConversationResultAction.scrapCost;\n\t\t\tusing PooledList\u003CItem\u003E pooledList = Facepunch.Pool.Get\u003CPooledList\u003CItem\u003E\u003E();\n\t\t\tplayer.inventory.FindItemsByItemID(pooledList, itemDefinition.itemid);\n\t\t\tforeach (Item item in pooledList)\n\t\t\t{\n\t\t\t\tnum -= item.amount;\n\t\t\t}\n\t\t\tif (num \u003E 0)\n\t\t\t{\n\t\t\t\tint speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex(\u0022toopoor\u0022);\n\t\t\t\tForceSpeechNode(player, speechNodeIndex2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);\n\t\t\tnum = nPCConversationResultAction.scrapCost;\n\t\t\tforeach (Item item2 in pooledList)\n\t\t\t{\n\t\t\t\tint num2 = Mathf.Min(num, item2.amount);\n\t\t\t\titem2.UseItem(num2);\n\t\t\t\tnum -= num2;\n\t\t\t\tif (num \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastActionPlayer = player;\n\t\t\tBroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);\n\t\t\tlastActionPlayer = null;\n\t\t\tbreak;\n\t\t}\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnCrateSpawned(PatrolHelicopter patrolHelicopter, BaseEntity baseEntity2)",
    "MethodSignature": "OnDied(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnDied(HitInfo info)\n\t{\n\t\tif (base.isClient)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tCreateExplosionMarker(10f);\n\t\tEffect.server.Run(explosionEffect.resourcePath, base.transform.position, Vector3.up, null, broadcast: true);\n\t\tVector3 vector = myAI.GetLastMoveDir() * myAI.GetMoveSpeed() * 0.75f;\n\t\tGameObject gibSource = servergibs.Get().GetComponent\u003CServerGib\u003E()._gibSource;\n\t\tList\u003CServerGib\u003E list = ServerGib.CreateGibs(servergibs.resourcePath, base.gameObject, gibSource, vector, 3f);\n\t\tif (info.damageTypes.GetMajorityDamageType() != DamageType.Decay)\n\t\t{\n\t\t\tfor (int i = 0; i \u003C 12 - maxCratesToSpawn; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, base.transform.position, base.transform.rotation);\n\t\t\t\tif (!baseEntity)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfloat minInclusive = 3f;\n\t\t\t\tfloat maxInclusive = 10f;\n\t\t\t\tVector3 onUnitSphere = UnityEngine.Random.onUnitSphere;\n\t\t\t\tbaseEntity.transform.position = base.transform.position \u002B new Vector3(0f, 1.5f, 0f) \u002B onUnitSphere * UnityEngine.Random.Range(-4f, 4f);\n\t\t\t\tCollider component = baseEntity.GetComponent\u003CCollider\u003E();\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t\tbaseEntity.SetVelocity(vector \u002B onUnitSphere * UnityEngine.Random.Range(minInclusive, maxInclusive));\n\t\t\t\tforeach (ServerGib item in list)\n\t\t\t\t{\n\t\t\t\t\tUnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j \u003C maxCratesToSpawn; j\u002B\u002B)\n\t\t{\n\t\t\tVector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;\n\t\t\tVector3 pos = base.transform.position \u002B new Vector3(0f, 1.5f, 0f) \u002B onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);\n\t\t\tBaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));\n\t\t\tbaseEntity2.Spawn();\n\t\t\tLootContainer lootContainer = baseEntity2 as LootContainer;\n\t\t\tif ((bool)lootContainer)\n\t\t\t{\n\t\t\t\tlootContainer.Invoke(lootContainer.RemoveMe, 1800f);\n\t\t\t}\n\t\t\tCollider component2 = baseEntity2.GetComponent\u003CCollider\u003E();\n\t\t\tRigidbody rigidbody = baseEntity2.gameObject.AddComponent\u003CRigidbody\u003E();\n\t\t\trigidbody.useGravity = true;\n\t\t\trigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;\n\t\t\trigidbody.mass = 2f;\n\t\t\trigidbody.interpolation = RigidbodyInterpolation.Interpolate;\n\t\t\trigidbody.velocity = vector \u002B onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);\n\t\t\trigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);\n\t\t\trigidbody.drag = 0.5f * (rigidbody.mass / 5f);\n\t\t\trigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);\n\t\t\tFireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;\n\t\t\tif ((bool)fireBall)\n\t\t\t{\n\t\t\t\tfireBall.SetParent(baseEntity2);\n\t\t\t\tfireBall.Spawn();\n\t\t\t\tfireBall.GetComponent\u003CRigidbody\u003E().isKinematic = true;\n\t\t\t\tfireBall.GetComponent\u003CCollider\u003E().enabled = false;\n\t\t\t}\n\t\t\tbaseEntity2.SendMessage(\u0022SetLockingEnt\u0022, fireBall.gameObject, SendMessageOptions.DontRequireReceiver);\n\t\t\tforeach (ServerGib item2 in list)\n\t\t\t{\n\t\t\t\tUnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnCrateSpawned\u0022, this, baseEntity2);\n\t\t}\n\t\tbase.OnDied(info);\n\t}\n",
    "ClassName": "PatrolHelicopter",
    "HookLineInvoke": 68
  },
  {
    "HookSignature": "OnPayForUpgrade(BasePlayer player, BuildingBlock buildingBlock, ConstructionGrade g)",
    "MethodSignature": "PayForUpgrade(ConstructionGrade g, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void PayForUpgrade(ConstructionGrade g, BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPayForUpgrade\u0022, player, this, g) != null || (player.IsInCreativeMode \u0026\u0026 Creative.freeBuild))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003CItem\u003E list = new List\u003CItem\u003E();\n\t\tforeach (ItemAmount item in g.CostToBuild(grade))\n\t\t{\n\t\t\tplayer.inventory.Take(list, item.itemid, (int)item.amount);\n\t\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.itemid);\n\t\t\tFacepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, \u0022upgrade_block\u0022, itemDefinition.shortname, (int)item.amount, this, null, safezone: false, null, player.userID);\n\t\t\tplayer.Command(\u0022note.inv \u0022 \u002B item.itemid \u002B \u0022 \u0022 \u002B item.amount * -1f);\n\t\t}\n\t\tforeach (Item item2 in list)\n\t\t{\n\t\t\titem2.Remove();\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnCupboardAuthorize(ulong num, BasePlayer rpcPlayer, BuildingPrivlidge buildingPrivlidge)",
    "MethodSignature": "AddAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void AddAuthorize(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 CanAdministrate(rpc.player))\n\t\t{\n\t\t\tulong num = rpc.read.UInt64();\n\t\t\tif (Interface.CallHook(\u0022IOnCupboardAuthorize\u0022, num, rpc.player, this) == null)\n\t\t\t{\n\t\t\t\tAddPlayer(rpc.player, num);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnItemCraftFinished(ItemCraftTask task, Item item2, ItemCrafter itemCrafter)",
    "MethodSignature": "FinishCrafting(ItemCraftTask task)",
    "MethodSourseCode": "\n\tpublic void FinishCrafting(ItemCraftTask task)\n\t{\n\t\ttask.amount--;\n\t\ttask.numCrafted\u002B\u002B;\n\t\tulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);\n\t\tItem item2 = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);\n\t\titem2.amount = task.blueprint.amountToCreate;\n\t\tint amount = item2.amount;\n\t\t_ = owner.currentCraftLevel;\n\t\tbool inSafezone = owner.InSafeZone();\n\t\tif (item2.hasCondition \u0026\u0026 task.conditionScale != 1f)\n\t\t{\n\t\t\titem2.maxCondition *= task.conditionScale;\n\t\t\titem2.condition = item2.maxCondition;\n\t\t}\n\t\titem2.OnVirginSpawn(owner);\n\t\titem2.SetItemOwnership(owner, ItemOwnershipPhrases.CraftedPhrase);\n\t\tforeach (ItemAmount ingredient in task.blueprint.GetIngredients())\n\t\t{\n\t\t\tint num = (int)ingredient.amount;\n\t\t\tif (task.takenItems == null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tforeach (Item takenItem in task.takenItems)\n\t\t\t{\n\t\t\t\tif (takenItem.info == ingredient.itemDef)\n\t\t\t\t{\n\t\t\t\t\tint num2 = Mathf.Min(takenItem.amount, num);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnCraftMaterialConsumed(takenItem.info.shortname, num, base.baseEntity, task.workbenchEntity, inSafezone, item2.info.shortname);\n\t\t\t\t\ttakenItem.UseItem(num);\n\t\t\t\t\tnum -= num2;\n\t\t\t\t}\n\t\t\t\tif (num \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttask.takenItems?.RemoveAll((Item item) =\u003E item.amount == 0);\n\t\tFacepunch.Rust.Analytics.Azure.OnCraftItem(item2.info.shortname, item2.amount, base.baseEntity, task.workbenchEntity, inSafezone);\n\t\towner.Command(\u0022note.craft_done\u0022, task.taskUID, 1, task.amount);\n\t\tInterface.CallHook(\u0022OnItemCraftFinished\u0022, task, item2, this);\n\t\tif (task.instanceData != null)\n\t\t{\n\t\t\titem2.instanceData = task.instanceData;\n\t\t}\n\t\tif (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))\n\t\t{\n\t\t\towner.GiveAchievement(task.blueprint.UnlockAchievment);\n\t\t}\n\t\towner.ProcessMissionEvent(BaseMission.MissionEventType.CRAFT_ITEM, item2.info.itemid, amount);\n\t\tif (owner.inventory.GiveItem(item2))\n\t\t{\n\t\t\towner.Command(\u0022note.inv\u0022, item2.info.itemid, amount);\n\t\t\treturn;\n\t\t}\n\t\tItemContainer itemContainer = containers.First();\n\t\towner.Command(\u0022note.inv\u0022, item2.info.itemid, amount);\n\t\towner.Command(\u0022note.inv\u0022, item2.info.itemid, -item2.amount);\n\t\titem2.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 43
  },
  {
    "HookSignature": "OnStructureDemolish(DecayEntity decayEntity, BasePlayer msgPlayer, bool true)",
    "MethodSignature": "DoImmediateDemolish(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void DoImmediateDemolish(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 msg.player.IsAdmin \u0026\u0026 Interface.CallHook(\u0022OnStructureDemolish\u0022, this, msg.player, true) == null)\n\t\t{\n\t\t\tStabilityEntity stabilityEntity = this as StabilityEntity;\n\t\t\tif (stabilityEntity != null)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, stabilityEntity);\n\t\t\t}\n\t\t\tKill(DestroyMode.Gib);\n\t\t}\n\t}\n",
    "ClassName": "DecayEntity",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnMapMarkerAdded(BasePlayer basePlayer, ProtoBuf.MapNote mapNote)",
    "MethodSignature": "Server_AddMarker(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.FromOwner(false)]\n\t[RPC_Server.CallsPerSecond(8uL)]\n\t[RPC_Server]\n\tpublic void Server_AddMarker(RPCMessage msg)\n\t{\n\t\tMapNote mapNote = msg.read.Proto\u003CMapNote\u003E();\n\t\tif (Interface.CallHook(\u0022OnMapMarkerAdd\u0022, this, mapNote) != null || !CanUseMapMarkers)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (State.pointsOfInterest == null)\n\t\t{\n\t\t\tState.pointsOfInterest = Facepunch.Pool.Get\u003CList\u003CMapNote\u003E\u003E();\n\t\t}\n\t\tif (State.pointsOfInterest.Count \u003E= ConVar.Server.maximumMapMarkers)\n\t\t{\n\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, false, ConVar.Server.maximumMapMarkers.ToString());\n\t\t\treturn;\n\t\t}\n\t\tif (mapNote.label == \u0022auto-name\u0022)\n\t\t{\n\t\t\tint num = FindUnusedNumberName();\n\t\t\tif (num != -1)\n\t\t\t{\n\t\t\t\tmapNote.label = num.ToString();\n\t\t\t}\n\t\t}\n\t\tValidateMapNote(mapNote);\n\t\tif (mapNote.colourIndex == -1)\n\t\t{\n\t\t\tmapNote.colourIndex = FindUnusedPointOfInterestColour();\n\t\t}\n\t\tState.pointsOfInterest.Add(mapNote);\n\t\tDirtyPlayerState();\n\t\tSendMarkersToClient();\n\t\tTeamUpdate();\n\t\tInterface.CallHook(\u0022OnMapMarkerAdded\u0022, this, mapNote);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 37
  },
  {
    "HookSignature": "OnDemoRecordingStopped(string netConnectionRecordFilename, BasePlayer basePlayer)",
    "MethodSignature": "StopDemoRecording()",
    "MethodSourseCode": "\n\tpublic void StopDemoRecording()\n\t{\n\t\tif (net != null \u0026\u0026 net.connection != null \u0026\u0026 net.connection.IsRecording \u0026\u0026 Interface.CallHook(\u0022OnDemoRecordingStop\u0022, net.connection.recordFilename, this) == null)\n\t\t{\n\t\t\tDebug.Log(ToString() \u002B \u0022 recording stopped: \u0022 \u002B net.connection.RecordFilename);\n\t\t\tnet.connection.StopRecording();\n\t\t\tCancelInvoke(MonitorDemoRecording);\n\t\t\tInterface.CallHook(\u0022OnDemoRecordingStopped\u0022, net.connection.recordFilename, this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnRecyclerToggle(Recycler recycler, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void SVSwitch(RPCMessage msg)\n\t{\n\t\tbool flag = msg.read.Bit();\n\t\tif (flag == IsOn() || msg.player == null || Interface.CallHook(\u0022OnRecyclerToggle\u0022, this, msg.player) != null || (!flag \u0026\u0026 onlyOneUser \u0026\u0026 msg.player.inventory.loot.entitySource != this) || (flag \u0026\u0026 !HasRecyclable()))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tforeach (Item item in base.inventory.itemList)\n\t\t\t{\n\t\t\t\titem.CollectedForCrafting(msg.player);\n\t\t\t}\n\t\t\tStartRecycling();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStopRecycling();\n\t\t}\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnEntityKill(BaseNetworkable baseNetworkable)",
    "MethodSignature": "Kill(DestroyMode mode)",
    "MethodSourseCode": "\n\tpublic void Kill(DestroyMode mode = DestroyMode.None)\n\t{\n\t\tif (IsDestroyed)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Calling kill - but already IsDestroyed!? \u0022 \u002B this);\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnEntityKill\u0022, this) == null)\n\t\t{\n\t\t\tEntityProfiler.killed\u002B\u002B;\n\t\t\tif (EntityProfiler.mode \u003E= 2)\n\t\t\t{\n\t\t\t\tEntityProfiler.OnKilled(this);\n\t\t\t}\n\t\t\tOnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);\n\t\t\tOnKilled();\n\t\t\tDoEntityDestroy();\n\t\t\tTerminateOnClient(mode);\n\t\t\tTerminateOnServer();\n\t\t\tEntityDestroy();\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnSprayRemove(SprayCanSpray sprayCanSpray, BasePlayer player)",
    "MethodSignature": "Server_RequestWaterClear(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tprivate void Server_RequestWaterClear(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 Menu_WaterClear_ShowIf(player) \u0026\u0026 Interface.CallHook(\u0022OnSprayRemove\u0022, this, player) == null)\n\t\t{\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "SprayCanSpray",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnCodeChange(ModularCar carOccupant, BasePlayer player, string text)",
    "MethodSignature": "RPC_RequestNewCode(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_RequestNewCode(RPCMessage msg)\n\t{\n\t\tif (!HasOccupant || !carOccupant.CarLock.HasALock)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null))\n\t\t{\n\t\t\tstring text = msg.read.String();\n\t\t\tif (Interface.CallHook(\u0022OnCodeChange\u0022, carOccupant, player, text) == null \u0026\u0026 carOccupant.CarLock.TrySetNewCode(text, player.userID))\n\t\t\t{\n\t\t\t\tEffect.server.Run(changeLockCodeEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnItemStacked(Item slot2, Item item, ItemContainer newcontainer, int num2)",
    "MethodSignature": "MoveToContainer(ItemContainer newcontainer, int iTargetPos, bool allowStack, bool ignoreStackLimit, BasePlayer sourcePlayer, bool allowSwap)",
    "MethodSourseCode": "\n\tpublic bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)\n\t{\n\t\tusing (TimeWarning.New(\u0022MoveToContainer\u0022))\n\t\t{\n\t\t\tBasePlayer playerOwner = newcontainer.playerOwner;\n\t\t\tif (playerOwner != null \u0026\u0026 playerOwner.IsDead() \u0026\u0026 parent != null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbool flag = iTargetPos == -1;\n\t\t\tItemContainer itemContainer = parent;\n\t\t\tif (iTargetPos == -1)\n\t\t\t{\n\t\t\t\tif (allowStack \u0026\u0026 info.stackable \u003E 1)\n\t\t\t\t{\n\t\t\t\t\tBufferList\u003CItem\u003E obj = Facepunch.Pool.Get\u003CBufferList\u003CItem\u003E\u003E();\n\t\t\t\t\tnewcontainer.FindItemsByItemID(info.itemid, obj);\n\t\t\t\t\tforeach (Item item3 in obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (item3.position \u003E iTargetPos \u0026\u0026 item3.CanStack(this) \u0026\u0026 (ignoreStackLimit || item3.amount \u003C item3.MaxStackable()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiTargetPos = item3.position;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Pool.Free(ref obj, freeElements: false);\n\t\t\t\t}\n\t\t\t\tif (iTargetPos == -1 \u0026\u0026 newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)\n\t\t\t\t{\n\t\t\t\t\tiTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);\n\t\t\t\t\tif (iTargetPos == int.MinValue)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (iTargetPos == -1)\n\t\t\t\t{\n\t\t\t\t\tif (newcontainer == parent)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tbool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) \u0026\u0026 info.isWearable;\n\t\t\t\t\tItemModWearable itemModWearable = info.ItemModWearable;\n\t\t\t\t\tfor (int i = 0; i \u003C newcontainer.capacity; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tItem slot = newcontainer.GetSlot(i);\n\t\t\t\t\t\tif (slot == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (CanMoveTo(newcontainer, i))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiTargetPos = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag2 \u0026\u0026 slot != null \u0026\u0026 !slot.info.ItemModWearable.CanExistWith(itemModWearable))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiTargetPos = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (newcontainer.HasAvailableSlotsDefined \u0026\u0026 DoItemSlotsConflict(slot))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiTargetPos = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag2 \u0026\u0026 iTargetPos == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tiTargetPos = newcontainer.capacity - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iTargetPos == -1)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!CanMoveTo(newcontainer, iTargetPos))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (iTargetPos \u003E= 0 \u0026\u0026 newcontainer.SlotTaken(this, iTargetPos))\n\t\t\t{\n\t\t\t\tItem slot2 = newcontainer.GetSlot(iTargetPos);\n\t\t\t\tif (slot2 == this)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (allowStack \u0026\u0026 slot2 != null)\n\t\t\t\t{\n\t\t\t\t\tint num = slot2.MaxStackable();\n\t\t\t\t\tif (slot2.CanStack(this))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ignoreStackLimit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum = int.MaxValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (slot2.amount \u003E= num)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint num2 = Mathf.Min(num - slot2.amount, amount);\n\t\t\t\t\t\tslot2.amount \u002B= num2;\n\t\t\t\t\t\tif (slot2.instanceData != null \u0026\u0026 instanceData != null \u0026\u0026 (bool)info.GetComponent\u003CItemModFoodSpoiling\u003E())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tslot2.instanceData.dataFloat = Mathf.Min(slot2.instanceData.dataFloat, instanceData.dataFloat);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewcontainer.onItemAddedToStack?.Invoke(slot2, num2);\n\t\t\t\t\t\tamount -= num2;\n\t\t\t\t\t\tslot2.MarkDirty();\n\t\t\t\t\t\tInterface.CallHook(\u0022OnItemStacked\u0022, slot2, this, newcontainer, num2);\n\t\t\t\t\t\tMarkDirty();\n\t\t\t\t\t\tMigrateItemOwnership(slot2, num2);\n\t\t\t\t\t\tif (amount \u003C= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRemoveFromWorld();\n\t\t\t\t\t\t\tRemoveFromContainer();\n\t\t\t\t\t\t\tRemove();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (parent != null \u0026\u0026 allowSwap \u0026\u0026 slot2 != null)\n\t\t\t\t{\n\t\t\t\t\tItemContainer itemContainer2 = parent;\n\t\t\t\t\tint iTargetPos2 = position;\n\t\t\t\t\tItemContainer newcontainer2 = slot2.parent;\n\t\t\t\t\tint num3 = slot2.position;\n\t\t\t\t\tif (!slot2.CanMoveTo(itemContainer2, iTargetPos2))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (itemContainer2.maxStackSize \u003E 0 \u0026\u0026 slot2.amount \u003E itemContainer2.maxStackSize)\n\t\t\t\t\t{\n\t\t\t\t\t\tItem item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);\n\t\t\t\t\t\tif (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tslot2.amount \u002B= item.amount;\n\t\t\t\t\t\t\titem.MigrateItemOwnership(slot2, item.amount);\n\t\t\t\t\t\t\titem.Remove();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBaseEntity entityOwner = GetEntityOwner();\n\t\t\t\t\tBaseEntity entityOwner2 = slot2.GetEntityOwner();\n\t\t\t\t\tRemoveFromContainer();\n\t\t\t\t\tslot2.RemoveFromContainer();\n\t\t\t\t\tRemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);\n\t\t\t\t\tslot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);\n\t\t\t\t\tif (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))\n\t\t\t\t\t{\n\t\t\t\t\t\tRemoveFromContainer();\n\t\t\t\t\t\tslot2.RemoveFromContainer();\n\t\t\t\t\t\tSetParent(itemContainer2);\n\t\t\t\t\t\tposition = iTargetPos2;\n\t\t\t\t\t\tslot2.SetParent(newcontainer2);\n\t\t\t\t\t\tslot2.position = num3;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (parent == newcontainer)\n\t\t\t{\n\t\t\t\tif (iTargetPos \u003E= 0 \u0026\u0026 iTargetPos != position \u0026\u0026 !parent.SlotTaken(this, iTargetPos))\n\t\t\t\t{\n\t\t\t\t\tnewcontainer.onItemPositionChanged?.Invoke(this, position, iTargetPos);\n\t\t\t\t\tposition = iTargetPos;\n\t\t\t\t\tMarkDirty();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (newcontainer.maxStackSize \u003E 0 \u0026\u0026 newcontainer.maxStackSize \u003C amount)\n\t\t\t{\n\t\t\t\tItem item2 = SplitItem(newcontainer.maxStackSize);\n\t\t\t\tif (item2 != null \u0026\u0026 !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) \u0026\u0026 (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))\n\t\t\t\t{\n\t\t\t\t\tDroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;\n\t\t\t\t\tif (droppedItem != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdroppedItem.DroppedBy = sourcePlayer?.userID ?? ((EncryptedValue\u003Culong\u003E)0uL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tInterface.CallHook(\u0022OnItemStacked\u0022, item2, this, newcontainer);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!newcontainer.CanAccept(this))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tBaseEntity entityOwner3 = GetEntityOwner();\n\t\t\tRemoveFromContainer();\n\t\t\tRemoveFromWorld();\n\t\t\tRemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);\n\t\t\tposition = iTargetPos;\n\t\t\tSetParent(newcontainer);\n\t\t\treturn true;\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 109
  },
  {
    "HookSignature": "OnTeamMemberPromote(RelationshipManager.PlayerTeam relationshipManager.PlayerTeam, ulong newTeamLeader)",
    "MethodSignature": "SetTeamLeader(ulong newTeamLeader)",
    "MethodSourseCode": "\n\t\tpublic void SetTeamLeader(ulong newTeamLeader)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnTeamMemberPromote\u0022, this, newTeamLeader) == null)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnTeamChanged(\u0022promoted\u0022, teamID, teamLeader, newTeamLeader, members);\n\t\t\t\tteamLeader = newTeamLeader;\n\t\t\t\tMarkDirty();\n\t\t\t}\n\t\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBookmarksSendControl(ComputerStation computerStation, BasePlayer player, string text)",
    "MethodSignature": "SendControlBookmarks(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void SendControlBookmarks(BasePlayer player)\n\t{\n\t\tif (!(player == null))\n\t\t{\n\t\t\tstring text = GenerateControlBookmarkString();\n\t\t\tif (Interface.CallHook(\u0022OnBookmarksSendControl\u0022, this, player, text) == null)\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022ReceiveBookmarks\u0022, player), text);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanChangeGrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum iGrade, ulong iSkin)",
    "MethodSignature": "CanChangeToGrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanChangeToGrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanChangeGrade\u0022, player, this, iGrade, iSkin);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player.IsInCreativeMode \u0026\u0026 Creative.freeBuild)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (HasUpgradePrivilege(iGrade, iSkin, player))\n\t\t{\n\t\t\treturn !IsUpgradeBlocked();\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDoorOpened(Door door, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_OpenDoor(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprotected void RPC_OpenDoor(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract(usableWhileCrawling: true) || !canHandOpen || IsOpen() || IsBusy() || IsLocked() || IsInvoking(DelayedDoorOpening))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (rpc.player.IsWounded())\n\t\t{\n\t\t\tif (!woundedOpens.ContainsKey(rpc.player) || !((float)woundedOpens[rpc.player] \u003E 2.5f))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twoundedOpens.Remove(rpc.player);\n\t\t}\n\t\tBaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;\n\t\tif (baseLock != null)\n\t\t{\n\t\t\tif (!baseLock.OnTryToOpen(rpc.player))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (baseLock.IsLocked() \u0026\u0026 UnityEngine.Time.realtimeSinceStartup - decayResetTimeLast \u003E 60f)\n\t\t\t{\n\t\t\t\tBuildingBlock buildingBlock = FindLinkedEntity\u003CBuildingBlock\u003E();\n\t\t\t\tif ((bool)buildingBlock)\n\t\t\t\t{\n\t\t\t\t\tDecay.BuildingDecayTouch(buildingBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDecay.RadialDecayTouch(base.transform.position, 40f, 2097408);\n\t\t\t\t}\n\t\t\t\tdecayResetTimeLast = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t}\n\t\t}\n\t\tif (canReverseOpen)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved1, base.transform.InverseTransformPoint(rpc.player.transform.position).x \u003E 0f, recursive: false, networkupdate: false);\n\t\t}\n\t\tif (ShouldDelayOpen(rpc.player, out var delay))\n\t\t{\n\t\t\tInvoke(DelayedDoorOpening, delay);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t}\n\t\tif (isSecurityDoor \u0026\u0026 NavMeshLink != null)\n\t\t{\n\t\t\tSetNavMeshLinkEnabled(wantsOn: true);\n\t\t}\n\t\tif (checkPhysBoxesOnOpen)\n\t\t{\n\t\t\tStartCheckingForBlockages(isOpening: true);\n\t\t}\n\t\tFacepunch.Rust.Analytics.Azure.OnBaseInteract(rpc.player, this);\n\t\tOnPlayerOpenedDoor(rpc.player);\n\t\tInterface.CallHook(\u0022OnDoorOpened\u0022, this, rpc.player);\n\t}\n",
    "ClassName": "Door",
    "HookLineInvoke": 61
  },
  {
    "HookSignature": "OnOvenStarted(BaseOven baseOven)",
    "MethodSignature": "StartCooking()",
    "MethodSourseCode": "\n\tpublic virtual void StartCooking()\n\t{\n\t\tif (Interface.CallHook(\u0022OnOvenStart\u0022, this) == null \u0026\u0026 (FindBurnable() != null || CanRunWithNoFuel))\n\t\t{\n\t\t\tbase.inventory.temperature = cookingTemperature;\n\t\t\tUpdateAttachmentTemperature();\n\t\t\tInvokeRepeating(Cook, 0.5f, 0.5f);\n\t\t\tif (visualFood)\n\t\t\t{\n\t\t\t\tInvokeRepeating(CookVisuals, 0f, 0.05f);\n\t\t\t}\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tInterface.CallHook(\u0022OnOvenStarted\u0022, this);\n\t\t\tif (hasOpenFlame)\n\t\t\t{\n\t\t\t\tSingletonComponent\u003CNpcFireManager\u003E.Instance.Add(this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "IOnPlayerConnected(BasePlayer basePlayer)",
    "MethodSignature": "PlayerInit(Network.Connection c)",
    "MethodSourseCode": "\n\tpublic void PlayerInit(Network.Connection c)\n\t{\n\t\tusing (TimeWarning.New(\u0022PlayerInit\u0022, 10))\n\t\t{\n\t\t\tCancelInvoke(base.KillMessage);\n\t\t\tCancelInvoke(OfflineMetabolism);\n\t\t\tSetPlayerFlag(PlayerFlags.Connected, b: true);\n\t\t\tactivePlayerList.Add(this);\n\t\t\tif (ConVar.Server.UsePlayerUpdateJobs)\n\t\t\t{\n\t\t\t\tplayerCache.Add(this);\n\t\t\t\tTickCache.Expand(playerCache.Players.Length);\n\t\t\t}\n\t\t\tbots.Remove(this);\n\t\t\tuserID = c.userid;\n\t\t\tUserIDString = userID.Get().ToString();\n\t\t\tdisplayName = c.username;\n\t\t\tc.player = this;\n\t\t\tsecondsConnected = 0;\n\t\t\tcurrentTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userID)?.teamID ?? 0;\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.persistance.SetPlayerName(userID, displayName);\n\t\t\tVector3 position = base.transform.position;\n\t\t\ttickInterpolator.Reset(position);\n\t\t\tif (ConVar.Server.UsePlayerUpdateJobs)\n\t\t\t{\n\t\t\t\tTickCache.Reset(this, position);\n\t\t\t}\n\t\t\ttickHistory.Reset(position);\n\t\t\teyeHistory.Clear();\n\t\t\tlastTickTime = 0f;\n\t\t\tlastInputTime = 0f;\n\t\t\tSetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);\n\t\t\tstats.Init();\n\t\t\tInvokeRandomized(StatSave, UnityEngine.Random.Range(5f, 10f), 30f, UnityEngine.Random.Range(0f, 6f));\n\t\t\tpreviousLifeStory = SingletonComponent\u003CServerMgr\u003E.Instance.persistance.GetLastLifeStory(userID);\n\t\t\tSetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel != 0);\n\t\t\tSetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));\n\t\t\tif (IsDead() \u0026\u0026 net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))\n\t\t\t{\n\t\t\t\tSendNetworkGroupChange();\n\t\t\t}\n\t\t\tnet.OnConnected(c);\n\t\t\tnet.StartSubscriber();\n\t\t\tif (ServerOcclusion.OcclusionEnabled \u0026\u0026 SupportsServerOcclusion() \u0026\u0026 ServerOcclusion.Occludees.TryGetValue(net.group, out var value))\n\t\t\t{\n\t\t\t\toccludees = value;\n\t\t\t}\n\t\t\tSendAsSnapshot(net.connection);\n\t\t\tGlobalNetworkHandler.server.StartSendingSnapshot(this);\n\t\t\tClientRPC(RpcTarget.Player(\u0022StartLoading\u0022, this));\n\t\t\tif ((bool)BaseGameMode.GetActiveGameMode(serverside: true))\n\t\t\t{\n\t\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerConnected(this);\n\t\t\t}\n\t\t\tif (net != null)\n\t\t\t{\n\t\t\t\tEACServer.OnStartLoading(net.connection);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022IOnPlayerConnected\u0022, this);\n\t\t\tif (IsAdmin)\n\t\t\t{\n\t\t\t\tif (ConVar.AntiHack.noclip_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.noclip_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.speedhack_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.speedhack_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.flyhack_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.flyhack_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.projectile_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.projectile_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.melee_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.eye_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.eye_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tCommand(\u0022debug.setinvis_ui\u0022, base.limitNetworking);\n\t\t\t}\n\t\t\tinventory.crafting.SendToOwner();\n\t\t\tif (TerrainMeta.Path != null \u0026\u0026 TerrainMeta.Path.OceanPatrolFar != null)\n\t\t\t{\n\t\t\t\tSendCargoPatrolPath();\n\t\t\t}\n\t\t\tif (currentTeam == 0L \u0026\u0026 RelationshipManager.ServerInstance.HasPendingInvite(userID, out var foundTeamID) \u0026\u0026 RelationshipManager.ServerInstance.GetTeamLeaderInfo(foundTeamID, out var leaderDisplayName, out var leaderID))\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022CLIENT_PendingInvite\u0022, this), leaderDisplayName, leaderID, foundTeamID);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 59
  },
  {
    "HookSignature": "OnPatrolHelicopterKill(PatrolHelicopter patrolHelicopter, HitInfo info)",
    "MethodSignature": "Hurt(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void Hurt(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPatrolHelicopterTakeDamage\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = false;\n\t\tif (info.damageTypes.Total() \u003E= base.health)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnPatrolHelicopterKill\u0022, this, info) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbase.health = 10000f;\n\t\t\tmyAI.CriticalDamage();\n\t\t\tflag = true;\n\t\t}\n\t\tbase.Hurt(info);\n\t\tif (flag)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tmyAI.OtherDamaged(info);\n\t\tweakspot[] array = weakspots;\n\t\tforeach (weakspot weakspot in array)\n\t\t{\n\t\t\tstring[] bonenames = weakspot.bonenames;\n\t\t\tforeach (string str in bonenames)\n\t\t\t{\n\t\t\t\tif (info.HitBone == StringPool.Get(str))\n\t\t\t\t{\n\t\t\t\t\tweakspot.Hurt(info.damageTypes.Total(), info);\n\t\t\t\t\tmyAI.WeakspotDamaged(weakspot, info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PatrolHelicopter",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnVendingShopOpened(NPCVendingMachine vendingMachine, BasePlayer msgPlayer)",
    "MethodSignature": "SV_OpenMenu(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void SV_OpenMenu(RPCMessage msg)\n\t{\n\t\tif (vendingMachine == null)\n\t\t{\n\t\t\tvendingMachine = GetComponentInChildren\u003CNPCVendingMachine\u003E();\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnVendingShopOpen\u0022, vendingMachine, msg.player) == null)\n\t\t{\n\t\t\tvendingMachine.OpenShop(msg.player);\n\t\t\tInterface.CallHook(\u0022OnVendingShopOpened\u0022, vendingMachine, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "TravellingVendor",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnNpcConversationRespond(NPCTalking nPCTalking, BasePlayer player, ConversationData conversationFor, ConversationData.ResponseNode responseNode)",
    "MethodSignature": "Server_ResponsePressed(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\tpublic void Server_ResponsePressed(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint num = msg.read.Int32();\n\t\tint num2 = msg.read.Int32();\n\t\tuint id = msg.read.UInt32();\n\t\tConversationData conversationFor = GetConversationFor(player);\n\t\tif (conversationFor == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (conversationFor.speeches[num].shortname == \u0022generic_mission_provider_list\u0022)\n\t\t{\n\t\t\tnum2 = 0;\n\t\t}\n\t\tif (conversationFor.speeches[num].shortname == \u0022generic_mission_provider_list_mission_preview\u0022 \u0026\u0026 num2 == 0)\n\t\t{\n\t\t\tBaseMission genericMissionById = GetGenericMissionById(id);\n\t\t\tif (genericMissionById != null \u0026\u0026 player.CanAcceptMission(genericMissionById))\n\t\t\t{\n\t\t\t\tTryAssignMissionToPlayer(genericMissionById, player);\n\t\t\t}\n\t\t}\n\t\tConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\n\t\tif (responseNode == null || Interface.CallHook(\u0022OnNpcConversationRespond\u0022, this, player, conversationFor, responseNode) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (responseNode.conditions.Length != 0)\n\t\t{\n\t\t\tUpdateFlags();\n\t\t}\n\t\tbool flag = responseNode.PassesConditions(player, this);\n\t\tif (flag)\n\t\t{\n\t\t\tstring actionString = responseNode.GetActionString();\n\t\t\tif (!string.IsNullOrEmpty(actionString))\n\t\t\t{\n\t\t\t\tOnConversationAction(player, actionString);\n\t\t\t}\n\t\t}\n\t\tint speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));\n\t\tif (speechNodeIndex == -1)\n\t\t{\n\t\t\tForceEndConversation(player);\n\t\t\treturn;\n\t\t}\n\t\tForceSpeechNode(player, speechNodeIndex);\n\t\tInterface.CallHook(\u0022OnNpcConversationResponded\u0022, this, player, conversationFor, responseNode);\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "CanBeTargeted(BasePlayer component, GunTrap gunTrap)",
    "MethodSignature": "CheckTrigger()",
    "MethodSourseCode": "\n\tpublic bool CheckTrigger()\n\t{\n\t\tHashSet\u003CBaseEntity\u003E entityContents = trigger.entityContents;\n\t\tif (entityContents == null || entityContents.Count == 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!CanFire())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tList\u003CRaycastHit\u003E obj = Pool.Get\u003CList\u003CRaycastHit\u003E\u003E();\n\t\tBuildingPrivlidge cachedTc = GetCachedTc();\n\t\tbool flag = false;\n\t\tforeach (BaseEntity item in entityContents)\n\t\t{\n\t\t\tBasePlayer component = item.GetComponent\u003CBasePlayer\u003E();\n\t\t\tif (component.IsSleeping() || !component.IsAlive() || (!(cachedTc == null) \u0026\u0026 cachedTc.IsAuthed(component)))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tobject obj2 = Interface.CallHook(\u0022CanBeTargeted\u0022, component, this);\n\t\t\tif (obj2 is bool)\n\t\t\t{\n\t\t\t\tPool.FreeUnmanaged(ref obj);\n\t\t\t\treturn (bool)obj2;\n\t\t\t}\n\t\t\tobj.Clear();\n\t\t\tGamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);\n\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(obj[i]);\n\t\t\t\tif (entity != null \u0026\u0026 (entity == this || entity.EqualNetID(this)))\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tPool.FreeUnmanaged(ref obj);\n\t\treturn flag;\n\t}\n",
    "ClassName": "GunTrap",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnContainerDropItems(ItemContainer container)",
    "MethodSignature": "DropItems(ItemContainer container, Vector3 position)",
    "MethodSourseCode": "\tpublic static void DropItems(ItemContainer container, Vector3 position)\n\t{\n\t\tif (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook(\u0022OnContainerDropItems\u0022, container) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = 0.25f;\n\t\tItem[] array = container.itemList.ToArray();\n\t\tforeach (Item item in array)\n\t\t{\n\t\t\tfloat num2 = UnityEngine.Random.Range(0f, 2f);\n\t\t\titem.RemoveFromContainer();\n\t\t\tBaseEntity baseEntity = item.CreateWorldObject(position \u002B new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));\n\t\t\tif (baseEntity == null)\n\t\t\t{\n\t\t\t\titem.Remove();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (baseEntity is DroppedItem droppedItem \u0026\u0026 container.entityOwner is LootContainer)\n\t\t\t{\n\t\t\t\tdroppedItem.DropReason = DroppedItem.DropReasonEnum.Loot;\n\t\t\t}\n\t\t\tif (num2 \u003E 0f)\n\t\t\t{\n\t\t\t\tbaseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);\n\t\t\t\tbaseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DropUtil",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRemoteIdentifierUpdate(PoweredRemoteControlEntity poweredRemoteControlEntity, string newID)",
    "MethodSignature": "UpdateIdentifier(string newID, bool clientSend)",
    "MethodSourseCode": "\n\tpublic void UpdateIdentifier(string newID, bool clientSend = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnRemoteIdentifierUpdate\u0022, this, newID) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t_ = rcIdentifier;\n\t\tif (base.isServer)\n\t\t{\n\t\t\tif (!RemoteControlEntity.IDInUse(newID))\n\t\t\t{\n\t\t\t\trcIdentifier = newID;\n\t\t\t}\n\t\t\tif (!Rust.Application.isLoadingSave)\n\t\t\t{\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PoweredRemoteControlEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSignLocked(Signage signage, BasePlayer msgPlayer)",
    "MethodSignature": "LockSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void LockSign(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanUpdateSign(msg.player))\n\t\t{\n\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t\tbase.OwnerID = msg.player.userID;\n\t\t\tInterface.CallHook(\u0022OnSignLocked\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "Signage",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnDemoRecordingStarted(string text, BasePlayer basePlayer)",
    "MethodSignature": "StartDemoRecording()",
    "MethodSourseCode": "\n\tpublic void StartDemoRecording()\n\t{\n\t\tif (net != null \u0026\u0026 net.connection != null \u0026\u0026 !net.connection.IsRecording)\n\t\t{\n\t\t\tstring text = $\u0022demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem\u0022;\n\t\t\tif (Interface.CallHook(\u0022OnDemoRecordingStart\u0022, text, this) == null)\n\t\t\t{\n\t\t\t\tDebug.Log(ToString() \u002B \u0022 recording started: \u0022 \u002B text);\n\t\t\t\tnet.connection.StartRecording(text, new Demo.Header\n\t\t\t\t{\n\t\t\t\t\tversion = Demo.Version,\n\t\t\t\t\tlevel = UnityEngine.Application.loadedLevelName,\n\t\t\t\t\tlevelSeed = World.Seed,\n\t\t\t\t\tlevelSize = World.Size,\n\t\t\t\t\tchecksum = World.Checksum,\n\t\t\t\t\tlocalclient = userID,\n\t\t\t\t\tposition = eyes.position,\n\t\t\t\t\trotation = eyes.HeadForward(),\n\t\t\t\t\tlevelUrl = World.Url,\n\t\t\t\t\trecordedTime = DateTime.Now.ToBinary()\n\t\t\t\t});\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tSendGlobalSnapshot();\n\t\t\t\tSendFullSnapshot();\n\t\t\t\tSendEntityUpdate();\n\t\t\t\tTreeManager.SendSnapshot(this);\n\t\t\t\tServerMgr.SendReplicatedVars(net.connection);\n\t\t\t\tInvokeRepeating(MonitorDemoRecording, 10f, 10f);\n\t\t\t\tInterface.CallHook(\u0022OnDemoRecordingStarted\u0022, text, this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 29
  },
  {
    "HookSignature": "OnEntityDestroy(BradleyAPC bradleyAPC)",
    "MethodSignature": "OnDied(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnDied(HitInfo info)\n\t{\n\t\tif (base.isClient || Interface.CallHook(\u0022OnEntityDestroy\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tCreateExplosionMarker(10f);\n\t\tEffect.server.Run(explosionEffect.resourcePath, mainTurretEyePos.transform.position, Vector3.up, null, broadcast: true);\n\t\tVector3 zero = Vector3.zero;\n\t\tGameObject gibSource = servergibs.Get().GetComponent\u003CServerGib\u003E()._gibSource;\n\t\tList\u003CServerGib\u003E list = ServerGib.CreateGibs(servergibs.resourcePath, base.gameObject, gibSource, zero, 3f);\n\t\tfor (int i = 0; i \u003C 12 - maxCratesToSpawn; i\u002B\u002B)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, base.transform.position, base.transform.rotation);\n\t\t\tif (!baseEntity)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfloat minInclusive = 3f;\n\t\t\tfloat maxInclusive = 10f;\n\t\t\tVector3 onUnitSphere = UnityEngine.Random.onUnitSphere;\n\t\t\tbaseEntity.transform.position = base.transform.position \u002B new Vector3(0f, 1.5f, 0f) \u002B onUnitSphere * UnityEngine.Random.Range(-4f, 4f);\n\t\t\tCollider component = baseEntity.GetComponent\u003CCollider\u003E();\n\t\t\tbaseEntity.Spawn();\n\t\t\tbaseEntity.SetVelocity(zero \u002B onUnitSphere * UnityEngine.Random.Range(minInclusive, maxInclusive));\n\t\t\tforeach (ServerGib item in list)\n\t\t\t{\n\t\t\t\tUnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j \u003C maxCratesToSpawn; j\u002B\u002B)\n\t\t{\n\t\t\tVector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;\n\t\t\tonUnitSphere2.y = 0f;\n\t\t\tonUnitSphere2.Normalize();\n\t\t\tVector3 pos = base.transform.position \u002B new Vector3(0f, 1.5f, 0f) \u002B onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);\n\t\t\tBaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));\n\t\t\tbaseEntity2.Spawn();\n\t\t\tLootContainer lootContainer = baseEntity2 as LootContainer;\n\t\t\tif ((bool)lootContainer)\n\t\t\t{\n\t\t\t\tlootContainer.Invoke(lootContainer.RemoveMe, 1800f);\n\t\t\t}\n\t\t\tCollider component2 = baseEntity2.GetComponent\u003CCollider\u003E();\n\t\t\tRigidbody rigidbody = baseEntity2.gameObject.AddComponent\u003CRigidbody\u003E();\n\t\t\trigidbody.useGravity = true;\n\t\t\trigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;\n\t\t\trigidbody.mass = 2f;\n\t\t\trigidbody.interpolation = RigidbodyInterpolation.Interpolate;\n\t\t\trigidbody.velocity = zero \u002B onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);\n\t\t\trigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);\n\t\t\trigidbody.drag = 0.5f * (rigidbody.mass / 5f);\n\t\t\trigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);\n\t\t\tFireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;\n\t\t\tif ((bool)fireBall)\n\t\t\t{\n\t\t\t\tfireBall.SetParent(baseEntity2);\n\t\t\t\tfireBall.Spawn();\n\t\t\t\tfireBall.GetComponent\u003CRigidbody\u003E().isKinematic = true;\n\t\t\t\tfireBall.GetComponent\u003CCollider\u003E().enabled = false;\n\t\t\t}\n\t\t\tbaseEntity2.SendMessage(\u0022SetLockingEnt\u0022, fireBall.gameObject, SendMessageOptions.DontRequireReceiver);\n\t\t\tforeach (ServerGib item2 in list)\n\t\t\t{\n\t\t\t\tUnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnCrateSpawned\u0022, this, baseEntity2);\n\t\t}\n\t\tKillSpawnedScientists();\n\t\tif (info != null \u0026\u0026 info.InitiatorPlayer != null \u0026\u0026 info.InitiatorPlayer.serverClan != null)\n\t\t{\n\t\t\tinfo.InitiatorPlayer.AddClanScore(ClanScoreEventType.DestroyedBradley);\n\t\t}\n\t\tbase.OnDied(info);\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHorseHitch(HitchTrough.IHitchable hitchable, HitchTrough.HitchSpot spot)",
    "MethodSignature": "AttemptToHitch(IHitchable hitchable, HitchSpot spot)",
    "MethodSourseCode": "\n\tpublic bool AttemptToHitch(IHitchable hitchable, HitchSpot spot = null)\n\t{\n\t\tif (hitchable == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (spot == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = hitchable as BaseEntity;\n\t\t\tif (baseEntity != null)\n\t\t\t{\n\t\t\t\tspot = GetClosestSpot(baseEntity.transform.position);\n\t\t\t}\n\t\t}\n\t\tif (spot != null)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnHorseHitch\u0022, hitchable, spot);\n\t\t\tif (obj is bool)\n\t\t\t{\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\tspot.SetOccupiedBy(hitchable);\n\t\t\thitchable.SetHitch(this, spot);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "HitchTrough",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnHelicopterTarget(HelicopterTurret helicopterTurret, BaseCombatEntity newTarget)",
    "MethodSignature": "SetTarget(BaseCombatEntity newTarget)",
    "MethodSourseCode": "\n\tpublic void SetTarget(BaseCombatEntity newTarget)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterTarget\u0022, this, newTarget) == null)\n\t\t{\n\t\t\t_target = newTarget;\n\t\t\tUpdateTargetVisibility();\n\t\t}\n\t}\n",
    "ClassName": "HelicopterTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemUnwrap(Item item, BasePlayer player, ItemModUnwrap itemModUnwrap)",
    "MethodSignature": "ServerCommand(Item item, string command, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void ServerCommand(Item item, string command, BasePlayer player)\n\t{\n\t\tif (command == \u0022unwrap\u0022 \u0026\u0026 item.amount \u003E 0 \u0026\u0026 Interface.CallHook(\u0022OnItemUnwrap\u0022, item, player, this) == null)\n\t\t{\n\t\t\titem.UseItem();\n\t\t\tint num = UnityEngine.Random.Range(minTries, maxTries \u002B 1);\n\t\t\tItemOwnershipShare ownership = default(ItemOwnershipShare);\n\t\t\tif (OwnershipPhrase != null \u0026\u0026 !string.IsNullOrEmpty(OwnershipPhrase.token))\n\t\t\t{\n\t\t\t\tItemOwnershipShare itemOwnershipShare = default(ItemOwnershipShare);\n\t\t\t\titemOwnershipShare.username = player.displayName;\n\t\t\t\titemOwnershipShare.reason = OwnershipPhrase.token;\n\t\t\t\townership = itemOwnershipShare;\n\t\t\t}\n\t\t\tfor (int i = 0; i \u003C num; i\u002B\u002B)\n\t\t\t{\n\t\t\t\trevealList.SpawnIntoContainer(player.inventory.containerMain, ownership, player.inventory.containerBelt);\n\t\t\t}\n\t\t\tif (successEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(successEffect.resourcePath, player.eyes.position);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ItemModUnwrap",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSiegeWeaponDoorOpen(BatteringRam batteringRam, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_OpenDoor(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(2uL)]\n\t[RPC_Server.MaxDistance(3f)]\n\tprotected void RPC_OpenDoor(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract(usableWhileCrawling: true) \u0026\u0026 CanOpenDoor() \u0026\u0026 Interface.CallHook(\u0022OnSiegeWeaponDoorOpen\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tOpenDoor();\n\t\t}\n\t}\n",
    "ClassName": "BatteringRam",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnHelicopterDropCrate(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "DropCrate()",
    "MethodSourseCode": "\n\tpublic void DropCrate()\n\t{\n\t\tif (numCrates \u003E 0)\n\t\t{\n\t\t\tVector3 pos = base.transform.position \u002B Vector3.down * 5f;\n\t\t\tQuaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnHelicopterDropCrate\u0022, this);\n\t\t\t\tbaseEntity.SendMessage(\u0022SetWasDropped\u0022);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t\tnumCrates--;\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnAdventGiftAward(AdventCalendar adventCalendar, BasePlayer player)",
    "MethodSignature": "AwardGift(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void AwardGift(BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnAdventGiftAward\u0022, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDateTime now = DateTime.Now;\n\t\tint num = ((overrideAdventCalendarDay \u003E 0) ? overrideAdventCalendarDay : now.Day) - startDay;\n\t\tif (((overrideAdventCalendarMonth \u003E 0) ? overrideAdventCalendarMonth : now.Month) != startMonth || num \u003C 0 || num \u003E= days.Length)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!playerRewardHistory.ContainsKey(player.userID))\n\t\t{\n\t\t\tplayerRewardHistory.Add(player.userID, new List\u003Cint\u003E());\n\t\t}\n\t\tplayerRewardHistory[player.userID].Add(num);\n\t\tEffect.server.Run(giftEffect.resourcePath, player.transform.position);\n\t\tif (num \u003E= 0 \u0026\u0026 num \u003C crosses.Length)\n\t\t{\n\t\t\tEffect.server.Run(boxCloseEffect.resourcePath, base.transform.position \u002B Vector3.up * 1.5f);\n\t\t}\n\t\tDayReward dayReward = days[num];\n\t\tItemAmount[] rewards = dayReward.rewards;\n\t\tif (ConVar.Server.Era != 0 \u0026\u0026 dayReward.alternativeRewards != null)\n\t\t{\n\t\t\tAlternativeReward[] alternativeRewards = dayReward.alternativeRewards;\n\t\t\tforeach (AlternativeReward alternativeReward in alternativeRewards)\n\t\t\t{\n\t\t\t\tif (alternativeReward.era == ConVar.Server.Era)\n\t\t\t\t{\n\t\t\t\t\trewards = alternativeReward.rewards;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tforeach (ItemAmount itemAmount in rewards)\n\t\t{\n\t\t\tif (itemAmount.itemDef.IsAllowed(EraRestriction.Loot))\n\t\t\t{\n\t\t\t\tplayer.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL).SetItemOwnership(player, ItemOwnershipPhrases.AdventCalendar), GiveItemReason.PickedUp);\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnAdventGiftAwarded\u0022, this, player);\n\t}\n",
    "ClassName": "AdventCalendar",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcRadioChatter(ScientistNPC scientistNPC)",
    "MethodSignature": "PlayRadioChatter()",
    "MethodSourseCode": "\n\tpublic void PlayRadioChatter()\n\t{\n\t\tif (RadioChatterEffects.Length != 0)\n\t\t{\n\t\t\tif (base.IsDestroyed || base.transform == null)\n\t\t\t{\n\t\t\t\tCancelInvoke(PlayRadioChatter);\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnNpcRadioChatter\u0022, this) == null)\n\t\t\t{\n\t\t\t\tEffect.server.Run(RadioChatterEffects[UnityEngine.Random.Range(0, RadioChatterEffects.Length)].resourcePath, this, StringPool.Get(\u0022head\u0022), Vector3.zero, Vector3.zero);\n\t\t\t\tQueueRadioChatter();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ScientistNPC",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnRackedWeaponSwapped(Item item, WeaponRackSlot weaponAtIndex, BasePlayer player, WeaponRack weaponRack)",
    "MethodSignature": "SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)",
    "MethodSourseCode": "\n\tprivate void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)\n\t{\n\t\tItem item = player.GetHeldEntity()?.GetItem();\n\t\tif (item == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tWorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);\n\t\tif (forItemDef == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);\n\t\tif (weaponAtIndex != null)\n\t\t{\n\t\t\tint mountSlotIndex = gridCellIndex;\n\t\t\tif (CustomRackType != 0)\n\t\t\t{\n\t\t\t\tgridCellIndex = 0;\n\t\t\t}\n\t\t\tint bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);\n\t\t\tif (bestPlacementCellIndex != -1 \u0026\u0026 Interface.CallHook(\u0022OnRackedWeaponSwap\u0022, item, weaponAtIndex, player, this) == null)\n\t\t\t{\n\t\t\t\titem.RemoveFromContainer();\n\t\t\t\tGivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);\n\t\t\t\tMountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);\n\t\t\t\tItemManager.DoRemoves();\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tInterface.CallHook(\u0022OnRackedWeaponSwapped\u0022, item, weaponAtIndex, player, this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "WeaponRack",
    "HookLineInvoke": 29
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, DroppedItemContainer droppedItemContainer)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t\tif (inventory == null || inventory.itemList == null || inventory.itemList.Count == 0)\n\t\t{\n\t\t\tKill();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tResetRemovalTime();\n\t\t\tSetFlag(Flags.Open, b: false);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tEvaluateBagConditions();\n\t}\n",
    "ClassName": "DroppedItemContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanDesignFirework(BasePlayer player, PatternFirework patternFirework)",
    "MethodSignature": "PlayerCanModify(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate bool PlayerCanModify(BasePlayer player)\n\t{\n\t\tif (player == null || !player.CanInteract())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanDesignFirework\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tBuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();\n\t\tif (buildingPrivilege != null \u0026\u0026 !buildingPrivilege.CanAdministrate(player))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PatternFirework",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanMountEntity(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "MountPlayer(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void MountPlayer(BasePlayer player)\n\t{\n\t\tif (!(_mounted != null) \u0026\u0026 !(mountAnchor == null) \u0026\u0026 Interface.CallHook(\u0022CanMountEntity\u0022, player, this) == null)\n\t\t{\n\t\t\tplayer.EnsureDismounted();\n\t\t\t_mounted = player;\n\t\t\tTransform transform = mountAnchor;\n\t\t\tplayer.SetMounted(this);\n\t\t\tplayer.MovePosition(transform.position);\n\t\t\tplayer.transform.rotation = transform.rotation;\n\t\t\tplayer.ServerRotation = transform.rotation;\n\t\t\tplayer.OverrideViewAngles(transform.rotation.eulerAngles);\n\t\t\t_mounted.eyes.NetworkUpdate(transform.rotation);\n\t\t\tplayer.SendNetworkUpdateImmediate();\n\t\t\tFacepunch.Rust.Analytics.Azure.OnMountEntity(player, this, VehicleParent());\n\t\t\tOnPlayerMounted();\n\t\t\tInterface.CallHook(\u0022OnEntityMounted\u0022, this, player);\n\t\t\tif (allowedGestures == MountGestureType.None \u0026\u0026 player.InGesture)\n\t\t\t{\n\t\t\t\tplayer.Server_CancelGesture();\n\t\t\t}\n\t\t\telse if (allowedGestures == MountGestureType.UpperBody \u0026\u0026 player.InGesture \u0026\u0026 player.CurrentGestureIsFullBody)\n\t\t\t{\n\t\t\t\tplayer.Server_CancelGesture();\n\t\t\t}\n\t\t\tif (this.IsValid() \u0026\u0026 player.IsValid())\n\t\t\t{\n\t\t\t\tplayer.ProcessMissionEvent(BaseMission.MissionEventType.MOUNT_ENTITY, net.ID, 1f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSiegeWeaponFire(BatteringRam batteringRam, BasePlayer player)",
    "MethodSignature": "SERVER_WantsAttack(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void SERVER_WantsAttack(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tBasePlayer driver = GetDriver();\n\t\tif (!(driver == null) \u0026\u0026 !(player == null) \u0026\u0026 !(driver != player) \u0026\u0026 CanAttack() \u0026\u0026 !driver.InSafeZone() \u0026\u0026 Interface.CallHook(\u0022OnSiegeWeaponFire\u0022, this, player) == null)\n\t\t{\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022CLIENT_Attack\u0022));\n\t\t\tInvoke(delegate\n\t\t\t{\n\t\t\t\tScanEntities(driver);\n\t\t\t}, 2f);\n\t\t\tSetFlag(Flags.Busy, b: true);\n\t\t\tInvoke(delegate\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Busy, b: false);\n\t\t\t}, timeBetweenFire);\n\t\t}\n\t}\n",
    "ClassName": "BatteringRam",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnCupboardDeauthorize(BuildingPrivlidge buildingPrivlidge, BasePlayer rpcPlayer)",
    "MethodSignature": "RemoveSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RemoveSelfAuthorize(RPCMessage rpc)\n\t{\n\t\tRPCMessage rpc2 = rpc;\n\t\tif (rpc2.player.CanInteract() \u0026\u0026 CanAdministrate(rpc2.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardDeauthorize\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.RemoveWhere((PlayerNameID x) =\u003E x.userid == (ulong)rpc2.player.userID);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022removed\u0022, rpc2.player.userID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnSamSiteModeToggle(SamSite samSite, BasePlayer player, bool flag)",
    "MethodSignature": "ToggleDefenderMode(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(1uL)]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tprivate void ToggleDefenderMode(RPCMessage msg)\n\t{\n\t\tif (staticRespawn)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 player.CanBuild())\n\t\t{\n\t\t\tbool flag = msg.read.Bit();\n\t\t\tif (flag != IsInDefenderMode() \u0026\u0026 Interface.CallHook(\u0022OnSamSiteModeToggle\u0022, this, player, flag) == null)\n\t\t\t{\n\t\t\t\tSetFlag(Flag_ManuallySetMode, flag);\n\t\t\t\tSetFlag(Flag_TargetMode, flag);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SamSite",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnRfFrequencyChange(Detonator detonator, int freq, BasePlayer player)",
    "MethodSignature": "ServerSetFrequency(BasePlayer player, int freq)",
    "MethodSourseCode": "\n\tpublic void ServerSetFrequency(BasePlayer player, int freq)\n\t{\n\t\tif (player == null || GetOwnerPlayer() != player || UnityEngine.Time.time \u003C nextChangeTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\tif (RFManager.IsReserved(freq))\n\t\t{\n\t\t\tRFManager.ReserveErrorPrint(player);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, freq, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem ownerItem = GetOwnerItem();\n\t\t\tRFManager.ChangeFrequency(frequency, freq, this, isListener: false, IsOn());\n\t\t\tfrequency = freq;\n\t\t\tSendNetworkUpdate();\n\t\t\tItem item = GetItem();\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tif (item.instanceData == null)\n\t\t\t\t{\n\t\t\t\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\n\t\t\t\t\titem.instanceData.ShouldPool = false;\n\t\t\t\t}\n\t\t\t\titem.instanceData.dataInt = frequency;\n\t\t\t\titem.MarkDirty();\n\t\t\t}\n\t\t\townerItem?.LoseCondition(ownerItem.maxCondition * 0.01f);\n\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, freq, player);\n\t\t}\n\t}\n",
    "ClassName": "Detonator",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnTeamDisband(RelationshipManager.PlayerTeam teamToDisband)",
    "MethodSignature": "DisbandTeam(PlayerTeam teamToDisband)",
    "MethodSourseCode": "\n\tpublic void DisbandTeam(PlayerTeam teamToDisband)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTeamDisband\u0022, teamToDisband) == null)\n\t\t{\n\t\t\tteams.Remove(teamToDisband.teamID);\n\t\t\tInterface.CallHook(\u0022OnTeamDisbanded\u0022, teamToDisband);\n\t\t\tFacepunch.Pool.Free(ref teamToDisband);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, ResourceContainer resourceContainer)",
    "MethodSignature": "StartLootingContainer(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\t[BaseEntity.RPC_Server.IsVisible(3f)]\n\t[BaseEntity.RPC_Server]\n\tprivate void StartLootingContainer(BaseEntity.RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 lootable \u0026\u0026 Interface.CallHook(\u0022CanLootEntity\u0022, player, this) == null \u0026\u0026 player.inventory.loot.StartLootingEntity(base.baseEntity))\n\t\t{\n\t\t\tlastAccessTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\tplayer.inventory.loot.AddContainer(container);\n\t\t}\n\t}\n",
    "ClassName": "ResourceContainer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnHammerHit(BasePlayer ownerPlayer, HitInfo info)",
    "MethodSignature": "DoAttackShared(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void DoAttackShared(HitInfo info)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tBaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;\n\t\tif (baseCombatEntity != null \u0026\u0026 ownerPlayer != null \u0026\u0026 base.isServer)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnHammerHit\u0022, ownerPlayer, info) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tusing (TimeWarning.New(\u0022DoRepair\u0022, 50))\n\t\t\t{\n\t\t\t\tbaseCombatEntity.DoRepair(ownerPlayer);\n\t\t\t}\n\t\t}\n\t\tinfo.DoDecals = false;\n\t\tif (base.isServer)\n\t\t{\n\t\t\tEffect.server.ImpactEffect(info);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEffect.client.ImpactEffect(info);\n\t\t}\n\t\tStartAttackCooldown(repeatDelay);\n\t}\n",
    "ClassName": "Hammer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnDigitalClockRing(DigitalClock digitalClock)",
    "MethodSignature": "Ring()",
    "MethodSourseCode": "\n\tprivate void Ring()\n\t{\n\t\tif (Interface.CallHook(\u0022OnDigitalClockRing\u0022, this) == null)\n\t\t{\n\t\t\tisRinging = true;\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022RPC_StartRinging\u0022));\n\t\t\tInvoke(StopRinging, 5f);\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "DigitalClock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSignLocked(PhotoFrame photoFrame, BasePlayer msgPlayer)",
    "MethodSignature": "LockSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tpublic void LockSign(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanUpdateSign(msg.player))\n\t\t{\n\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t\tbase.OwnerID = msg.player.userID;\n\t\t\tInterface.CallHook(\u0022OnSignLocked\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "PhotoFrame",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnHelicopterOutOfCrates(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "OutOfCrates()",
    "MethodSourseCode": "\n\tpublic bool OutOfCrates()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnHelicopterOutOfCrates\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn numCrates \u003C= 0;\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHuntEventEnd(EggHuntEvent eggHuntEvent)",
    "MethodSignature": "Update()",
    "MethodSourseCode": "\n\tpublic void Update()\n\t{\n\t\ttimeAlive \u002B= UnityEngine.Time.deltaTime;\n\t\tif (base.isServer \u0026\u0026 !base.IsDestroyed)\n\t\t{\n\t\t\tif (timeAlive - warmupTime \u003E durationSeconds - warnTime)\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved1, b: true);\n\t\t\t}\n\t\t\tif (timeAlive - warmupTime \u003E durationSeconds \u0026\u0026 !IsInvoking(Cooldown) \u0026\u0026 Interface.CallHook(\u0022OnHuntEventEnd\u0022, this) == null)\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved2, b: true);\n\t\t\t\tCleanupEggs();\n\t\t\t\tPrintWinnersAndAward();\n\t\t\t\tInvoke(Cooldown, 10f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "EggHuntEvent",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "IOnNpcTarget(BaseNpc baseNpc, BaseEntity target)",
    "MethodSignature": "GetWantsToAttack(BaseEntity target)",
    "MethodSourseCode": "\n\tpublic float GetWantsToAttack(BaseEntity target)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022IOnNpcTarget\u0022, this, target);\n\t\tif (obj is float)\n\t\t{\n\t\t\treturn (float)obj;\n\t\t}\n\t\treturn WantsToAttack(target);\n\t}\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnInventoryAmmoItemFind(PlayerInventory ownerPlayerInventory, ItemDefinition fuelType)",
    "MethodSignature": "GetAmmo()",
    "MethodSourseCode": "\n\tpublic Item GetAmmo()\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnInventoryAmmoItemFind\u0022, ownerPlayer.inventory, fuelType);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\treturn ownerPlayer.inventory.FindItemByItemName(fuelType.shortname);\n\t}\n",
    "ClassName": "Chainsaw",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnHorseUnhitch(HitchTrough.IHitchable hitchable, HitchTrough.HitchSpot hitchSpot)",
    "MethodSignature": "UnHitch(IHitchable hitchable)",
    "MethodSourseCode": "\n\tpublic void UnHitch(IHitchable hitchable)\n\t{\n\t\tHitchSpot[] array = hitchSpots;\n\t\tforeach (HitchSpot hitchSpot in array)\n\t\t{\n\t\t\tif (hitchSpot.GetHitchable(base.isServer) == hitchable)\n\t\t\t{\n\t\t\t\tif (Interface.CallHook(\u0022OnHorseUnhitch\u0022, hitchable, hitchSpot) != null)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\thitchSpot.SetOccupiedBy(null);\n\t\t\t\thitchable.SetHitch(null, null);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "HitchTrough",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnVehicleLockRequest(ModularCarGarage modularCarGarage, BasePlayer player, string text)",
    "MethodSignature": "RPC_RequestAddLock(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_RequestAddLock(RPCMessage msg)\n\t{\n\t\tif (!HasOccupant || carOccupant.CarLock.HasALock)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tif (player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (Interface.CallHook(\u0022OnVehicleLockRequest\u0022, this, player, text) == null)\n\t\t{\n\t\t\tItemAmount itemAmount = lockResourceCost;\n\t\t\tif ((float)player.inventory.GetAmount(itemAmount.itemDef.itemid) \u003E= itemAmount.amount \u0026\u0026 carOccupant.CarLock.TryAddALock(text, player.userID))\n\t\t\t{\n\t\t\t\tplayer.inventory.Take(null, itemAmount.itemDef.itemid, Mathf.CeilToInt(itemAmount.amount));\n\t\t\t\tEffect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnNpcEquipWeapon(NPCPlayer nPCPlayer, Item slot)",
    "MethodSignature": "EquipWeapon(bool skipDeployDelay)",
    "MethodSourseCode": "\n\tpublic virtual void EquipWeapon(bool skipDeployDelay = false)\n\t{\n\t\tif (base.inventory == null || base.inventory.containerBelt == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem slot = base.inventory.containerBelt.GetSlot(0);\n\t\tif (Interface.CallHook(\u0022OnNpcEquipWeapon\u0022, this, slot) != null || slot == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUpdateActiveItem(base.inventory.containerBelt.GetSlot(0).uid);\n\t\tBaseEntity heldEntity = slot.GetHeldEntity();\n\t\tif (!(heldEntity != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tAttackEntity component = heldEntity.GetComponent\u003CAttackEntity\u003E();\n\t\tif (component != null)\n\t\t{\n\t\t\tif (skipDeployDelay)\n\t\t\t{\n\t\t\t\tcomponent.ResetAttackCooldown();\n\t\t\t}\n\t\t\tcomponent.TopUpAmmo();\n\t\t}\n\t}\n",
    "ClassName": "NPCPlayer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnSamSiteTargetScan(SamSite samSite, System.Collections.Generic.List\u003CSamSite.ISamSiteTarget\u003E obj)",
    "MethodSignature": "TargetScan()",
    "MethodSourseCode": "\n\tpublic void TargetScan()\n\t{\n\t\tif (!IsPowered())\n\t\t{\n\t\t\tlastTargetVisibleTime = 0f;\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Time.time \u003E lastTargetVisibleTime \u002B 3f)\n\t\t{\n\t\t\tClearTarget();\n\t\t}\n\t\tif (!staticRespawn)\n\t\t{\n\t\t\tint num = ((ammoItem != null \u0026\u0026 ammoItem.parent == base.inventory) ? ammoItem.amount : 0);\n\t\t\tbool flag = lastAmmoCount \u003C lowAmmoThreshold;\n\t\t\tbool flag2 = num \u003C lowAmmoThreshold;\n\t\t\tif (num != lastAmmoCount \u0026\u0026 flag != flag2)\n\t\t\t{\n\t\t\t\tMarkIODirty();\n\t\t\t}\n\t\t\tlastAmmoCount = num;\n\t\t}\n\t\tif (HasValidTarget() || IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003CISamSiteTarget\u003E obj = Facepunch.Pool.Get\u003CList\u003CISamSiteTarget\u003E\u003E();\n\t\tif (Interface.CallHook(\u0022OnSamSiteTargetScan\u0022, this, obj) == null)\n\t\t{\n\t\t\tif (!IsInDefenderMode())\n\t\t\t{\n\t\t\t\tAddTargetSet(obj, targetTypeVehicle.scanRadius);\n\t\t\t}\n\t\t\tAddMLRSRockets(obj, targetTypeMissile.scanRadius);\n\t\t}\n\t\tISamSiteTarget samSiteTarget = null;\n\t\tforeach (ISamSiteTarget item in obj)\n\t\t{\n\t\t\tif (!item.isClient \u0026\u0026 !(item.CenterPoint().y \u003C eyePoint.transform.position.y) \u0026\u0026 item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) \u0026\u0026 item.IsValidSAMTarget(staticRespawn) \u0026\u0026 Interface.CallHook(\u0022OnSamSiteTarget\u0022, this, item) == null)\n\t\t\t{\n\t\t\t\tsamSiteTarget = item;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ObjectEx.IsUnityNull(samSiteTarget) \u0026\u0026 currentTarget != samSiteTarget)\n\t\t{\n\t\t\tlockOnTime = UnityEngine.Time.time \u002B 0.5f;\n\t\t}\n\t\tSetTarget(samSiteTarget);\n\t\tif (!ObjectEx.IsUnityNull(currentTarget))\n\t\t{\n\t\t\tlastTargetVisibleTime = UnityEngine.Time.time;\n\t\t}\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t\tif (ObjectEx.IsUnityNull(currentTarget))\n\t\t{\n\t\t\tCancelInvoke(WeaponTick);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);\n\t\t}\n\t}\n",
    "ClassName": "SamSite",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnExperimentStarted(Workbench workbench, BasePlayer player)",
    "MethodSignature": "RPC_BeginExperiment(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_BeginExperiment(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (player == null || IsWorking())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;\n\t\tint num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);\n\t\tfor (int i = 0; i \u003C experimentalItems.subSpawn.Length; i\u002B\u002B)\n\t\t{\n\t\t\tint num2 = i \u002B num;\n\t\t\tif (num2 \u003E= experimentalItems.subSpawn.Length)\n\t\t\t{\n\t\t\t\tnum2 -= experimentalItems.subSpawn.Length;\n\t\t\t}\n\t\t\tItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;\n\t\t\tif ((bool)itemDef.Blueprint \u0026\u0026 !itemDef.Blueprint.defaultBlueprint \u0026\u0026 itemDef.Blueprint.userCraftable \u0026\u0026 itemDef.Blueprint.isResearchable \u0026\u0026 !itemDef.Blueprint.NeedsSteamItem \u0026\u0026 !itemDef.Blueprint.NeedsSteamDLC \u0026\u0026 !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))\n\t\t\t{\n\t\t\t\tpendingBlueprint = itemDef;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pendingBlueprint == null)\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022You have already unlocked everything for this workbench tier.\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnExperimentStart\u0022, this, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem slot = base.inventory.GetSlot(0);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tif (!slot.MoveToContainer(player.inventory.containerMain))\n\t\t\t\t{\n\t\t\t\t\tslot.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t}\n\t\t\tif (experimentStartEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tCancelInvoke(ExperimentComplete);\n\t\t\tInvoke(ExperimentComplete, 5f);\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnExperimentStarted\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 54
  },
  {
    "HookSignature": "OnNpcDuck(HumanNPC humanNPC)",
    "MethodSignature": "SetDucked(bool flag)",
    "MethodSourseCode": "\n\tpublic void SetDucked(bool flag)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcDuck\u0022, this) == null)\n\t\t{\n\t\t\tmodelState.ducked = flag;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "HumanNPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfFrequencyChange(PagerEntity pagerEntity, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild() \u0026\u0026 !(UnityEngine.Time.time \u003C nextChangeTime))\n\t\t{\n\t\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: true);\n\t\t\t\tfrequency = num;\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PagerEntity",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnHorseLead(RidableHorse ridableHorse, BasePlayer player)",
    "MethodSignature": "SERVER_Lead(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(1uL)]\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void SERVER_Lead(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = msg.read.Bool();\n\t\tif (flag)\n\t\t{\n\t\t\tif (!CanLead(player))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse if (!CanStopLead(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnHorseLead\u0022, this, player) == null)\n\t\t{\n\t\t\tSetLeading(flag ? player : null);\n\t\t}\n\t}\n",
    "ClassName": "RidableHorse",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnBigWheelWin(BigWheelGame bigWheelGame, Item slot, BigWheelBettingTerminal terminal, int num)",
    "MethodSignature": "Payout()",
    "MethodSourseCode": "\n\tpublic void Payout()\n\t{\n\t\tHitNumber currentHitType = GetCurrentHitType();\n\t\tGuid value = Guid.NewGuid();\n\t\tforeach (BigWheelBettingTerminal terminal in terminals)\n\t\t{\n\t\t\tif (terminal.isClient)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool flag = false;\n\t\t\tbool flag2 = false;\n\t\t\tItem slot = terminal.inventory.GetSlot((int)currentHitType.hitType);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\n\t\t\t\tint amount = slot.amount;\n\t\t\t\tif (Interface.CallHook(\u0022OnBigWheelWin\u0022, this, slot, terminal, num) == null)\n\t\t\t\t{\n\t\t\t\t\tslot.amount \u002B= slot.amount * num;\n\t\t\t\t\tslot.RemoveFromContainer();\n\t\t\t\t\tslot.MoveToContainer(terminal.inventory, 5);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i \u003C 5; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tItem slot2 = terminal.inventory.GetSlot(i);\n\t\t\t\tif (slot2 != null \u0026\u0026 Interface.CallHook(\u0022OnBigWheelLoss\u0022, this, slot2, terminal) == null)\n\t\t\t\t{\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);\n\t\t\t\t\tslot2.Remove();\n\t\t\t\t\tflag2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag || flag2)\n\t\t\t{\n\t\t\t\tterminal.ClientRPC(RpcTarget.NetworkGroup(\u0022WinOrLoseSound\u0022), flag);\n\t\t\t}\n\t\t}\n\t\tItemManager.DoRemoves();\n\t\tSetTerminalsLocked(isLocked: false);\n\t}\n",
    "ClassName": "BigWheelGame",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnBookmarkInput(ComputerStation computerStation, BasePlayer player, InputState inputState)",
    "MethodSignature": "PlayerServerInput(InputState inputState, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void PlayerServerInput(InputState inputState, BasePlayer player)\n\t{\n\t\tbase.PlayerServerInput(inputState, player);\n\t\tif (HasFlag(Flags.Reserved2) \u0026\u0026 currentlyControllingEnt.IsValid(serverside: true) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkInput\u0022, this, player, inputState) == null)\n\t\t{\n\t\t\tcurrentlyControllingEnt.Get(serverside: true).GetComponent\u003CIRemoteControllable\u003E().UserInput(inputState, new CameraViewerId(player.userID, 0L));\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPhotoCaptured(PhotoEntity photoEntity, Item item, BasePlayer player, byte[] array)",
    "MethodSignature": "TakePhoto(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner(false)]\n\t[RPC_Server.CallsPerSecond(3uL)]\n\tprivate void TakePhoto(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tItem item = GetItem();\n\t\tif (player == null || item == null || item.condition \u003C= 0f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (array.Length \u003E 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item2 = ItemManager.Create(photoItem, 1, 0uL);\n\t\tif (item2 == null)\n\t\t{\n\t\t\tDebug.LogError(\u0022Failed to create photo item\u0022);\n\t\t\treturn;\n\t\t}\n\t\titem2.SetItemOwnership(msg.player, ItemOwnershipPhrases.Photographed);\n\t\tif (!item2.instanceData.subEntity.IsValid)\n\t\t{\n\t\t\titem2.Remove();\n\t\t\tDebug.LogError(\u0022Photo has no sub-entity\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);\n\t\tif (baseNetworkable == null)\n\t\t{\n\t\t\titem2.Remove();\n\t\t\tDebug.LogError(\u0022Sub-entity was not found\u0022);\n\t\t}\n\t\telse if (!(baseNetworkable is PhotoEntity photoEntity))\n\t\t{\n\t\t\titem2.Remove();\n\t\t\tDebug.LogError(\u0022Sub-entity is not a photo\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnPhotoCapture\u0022, photoEntity, item, player, array) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tphotoEntity.SetImageData(player.userID, array);\n\t\t\tif (!player.inventory.GiveItem(item2))\n\t\t\t{\n\t\t\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity());\n\t\t\t}\n\t\t\tEffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));\n\t\t\tif (HasFlag(Flags.Reserved5))\n\t\t\t{\n\t\t\t\tEffectNetwork.Send(new Effect(flashEffect.resourcePath, localFlash.transform.position, localFlash.transform.forward, msg.connection));\n\t\t\t}\n\t\t\tif (!hasSentAchievement \u0026\u0026 !string.IsNullOrEmpty(\u0022SUMMER_PAPARAZZI\u0022))\n\t\t\t{\n\t\t\t\tVector3 position = GetOwnerPlayer().eyes.position;\n\t\t\t\tVector3 vector = GetOwnerPlayer().eyes.HeadForward();\n\t\t\t\tList\u003CBasePlayer\u003E obj = Facepunch.Pool.Get\u003CList\u003CBasePlayer\u003E\u003E();\n\t\t\t\tVis.Entities(position \u002B vector * 5f, 5f, obj, 131072);\n\t\t\t\tforeach (BasePlayer item3 in obj)\n\t\t\t\t{\n\t\t\t\t\tif (item3.isServer \u0026\u0026 item3 != GetOwnerPlayer() \u0026\u0026 item3.IsVisible(GetOwnerPlayer().eyes.position))\n\t\t\t\t\t{\n\t\t\t\t\t\thasSentAchievement = true;\n\t\t\t\t\t\tGetOwnerPlayer().GiveAchievement(\u0022SUMMER_PAPARAZZI\u0022);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t\t\t}\n\t\t\titem.LoseCondition(1f);\n\t\t\tInterface.CallHook(\u0022OnPhotoCaptured\u0022, photoEntity, item, player, array);\n\t\t}\n\t}\n",
    "ClassName": "InstantCameraTool",
    "HookLineInvoke": 75
  },
  {
    "HookSignature": "IOnRconInitialize()",
    "MethodSignature": "Initialize()",
    "MethodSourseCode": "\n\tpublic static void Initialize()\n\t{\n\t\tif (Interface.CallHook(\u0022IOnRconInitialize\u0022) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (Port == 0)\n\t\t{\n\t\t\tPort = Server.port;\n\t\t}\n\t\tPassword = CommandLine.GetSwitch(\u0022-rcon.password\u0022, CommandLine.GetSwitch(\u0022\u002Brcon.password\u0022, \u0022\u0022));\n\t\tif (Password.Length \u003C 8)\n\t\t{\n\t\t\tUnityEngine.Debug.Log(\u0022\\r\\n*******************************************************\\r\\n**                                                   **\\r\\n** RCON password length is very insecure.            **\\r\\n** Support for passwords less than 8 characters may  **\\r\\n** be removed in the future.                         **\\r\\n**                                                   **\\r\\n*******************************************************\\r\\n\u0022);\n\t\t}\n\t\tswitch (Password.ToLower())\n\t\t{\n\t\tcase \u0022changeme\u0022:\n\t\tcase \u0022abc123\u0022:\n\t\tcase \u0022qwerty\u0022:\n\t\tcase \u0022qwerty123\u0022:\n\t\tcase \u0022123456\u0022:\n\t\tcase \u0022000000\u0022:\n\t\tcase \u0022password123\u0022:\n\t\tcase \u0022password\u0022:\n\t\tcase \u0022\u0022:\n\t\t\tUnityEngine.Debug.Log(\u0022\\r\\n*******************************************************\\r\\n**                                                   **\\r\\n** RCON password is very insecure, RCON is disabled. **\\r\\n**                                                   **\\r\\n*******************************************************\\r\\n\u0022);\n\t\t\treturn;\n\t\t}\n\t\tOutput.OnMessage \u002B= OnMessage;\n\t\tif (Web)\n\t\t{\n\t\t\tlistenerNew = new Listener();\n\t\t\tstring serverFolder = Server.GetServerFolder(\u0022cfg\u0022);\n\t\t\tlistenerNew.BansFile = serverFolder \u002B \u0022/rcon-bans.cfg\u0022;\n\t\t\tif (!string.IsNullOrEmpty(Ip))\n\t\t\t{\n\t\t\t\tlistenerNew.Address = Ip;\n\t\t\t}\n\t\t\tlistenerNew.Password = Password;\n\t\t\tlistenerNew.Port = Port;\n\t\t\tlistenerNew.SslCertificate = CommandLine.GetSwitch(\u0022-rcon.ssl\u0022, CommandLine.GetSwitch(\u0022\u002Brcon.ssl\u0022, null));\n\t\t\tlistenerNew.SslCertificatePassword = CommandLine.GetSwitch(\u0022-rcon.sslpwd\u0022, CommandLine.GetSwitch(\u0022\u002Brcon.sslpwd\u0022, null));\n\t\t\tlistenerNew.OnMessage = delegate(IPAddress ip, int id, string msg)\n\t\t\t{\n\t\t\t\tCommand item = JsonConvert.DeserializeObject\u003CCommand\u003E(msg);\n\t\t\t\titem.Ip = ip;\n\t\t\t\titem.ConnectionId = id;\n\t\t\t\tCommands.Enqueue(item);\n\t\t\t};\n\t\t\tlistenerNew.Start();\n\t\t\tUnityEngine.Debug.Log($\u0022WebSocket RCON Started on {Ip}:{Port}\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlistener = new RConListener();\n\t\t\tUnityEngine.Debug.Log(\u0022RCON Started on \u0022 \u002B Port);\n\t\t\tUnityEngine.Debug.Log(\u0022\\r\\n*********************************************************************\\r\\n**                                                                 **\\r\\n** Source engine style TCP RCON is deprecated and will be removed. **\\r\\n** Please switch to Websocket RCON by setting rcon.web to true     **\\r\\n**                                                                 **\\r\\n*********************************************************************\u0022);\n\t\t}\n\t}\n",
    "ClassName": "RCon",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityActiveCheck(BaseEntity ent, BasePlayer player, uint id, string debugName)",
    "MethodSignature": "Test(uint id, string debugName, BaseEntity ent, BasePlayer player)",
    "MethodSourseCode": "\t\t\tpublic static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)\n\t\t\t{\n\t\t\t\tif (ent == null || player == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (ent.net == null || player.net == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnEntityActiveCheck\u0022, ent, player, id, debugName);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tif (ent.net.ID == player.net.ID)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (ent.parentEntity.uid != player.net.ID)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tItem activeItem = player.GetActiveItem();\n\t\t\t\tif (activeItem == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (activeItem.GetHeldEntity() != ent)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnWireClear(BasePlayer ply, IOEntity iOEntity, int clearIndex, IOEntity iOEntity2, bool isInput)",
    "MethodSignature": "AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)",
    "MethodSourseCode": "\n\tpublic static bool AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)\n\t{\n\t\tIOEntity iOEntity = ((clearEnt != null) ? clearEnt.GetComponent\u003CIOEntity\u003E() : null);\n\t\tIOEntity iOEntity2 = (IOEntity)(object)(isInput ? iOEntity.inputs[clearIndex] : iOEntity.outputs[clearIndex]);\n\t\tif (((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get() == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tiOEntity2 = ((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get();\n\t\tobject obj = Interface.CallHook(\u0022OnWireClear\u0022, ply, iOEntity, clearIndex, iOEntity2, isInput);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (iOEntity == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (ply != null \u0026\u0026 !CanModifyEntity(ply, iOEntity))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn iOEntity.Disconnect(clearIndex, isInput);\n\t}\n",
    "ClassName": "WireTool",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanElevatorLiftMove(ElevatorLift elevatorLift)",
    "MethodSignature": "CanMove()",
    "MethodSourseCode": "\n\tpublic bool CanMove()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanElevatorLiftMove\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (VehicleTrigger.HasContents \u0026\u0026 VehicleTrigger.entityContents != null)\n\t\t{\n\t\t\tforeach (BaseEntity entityContent in VehicleTrigger.entityContents)\n\t\t\t{\n\t\t\t\tif (!vehiclePrefabWhitelist.Contains(entityContent.prefabID))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ElevatorLift",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnInterferenceOthersUpdate(AutoTurret autoTurret)",
    "MethodSignature": "UpdateInterferenceOnOthers()",
    "MethodSourseCode": "\n\tpublic void UpdateInterferenceOnOthers()\n\t{\n\t\tif (Interface.CallHook(\u0022OnInterferenceOthersUpdate\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (AutoTurret nearbyTurret in nearbyTurrets)\n\t\t{\n\t\t\tif (nearbyTurret != null)\n\t\t\t{\n\t\t\t\tnearbyTurret.TryRegisterForInterferenceUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBookmarkAdd(ComputerStation computerStation, BasePlayer player, string text)",
    "MethodSignature": "AddBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void AddBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player) || isStatic)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Time.realtimeSinceStartup \u003C nextAddTime)\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022Slow down...\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (controlBookmarks.Count \u003E= 128)\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022Too many bookmarks, delete some\u0022);\n\t\t\treturn;\n\t\t}\n\t\tnextAddTime = UnityEngine.Time.realtimeSinceStartup \u002B 1f;\n\t\tstring text = msg.read.String();\n\t\tif (Interface.CallHook(\u0022OnBookmarkAdd\u0022, this, player, text) == null)\n\t\t{\n\t\t\tForceAddBookmark(text);\n\t\t\tSendControlBookmarks(player);\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnItemStacked(Item item2, Item item, ItemContainer newcontainer)",
    "MethodSignature": "MoveToContainer(ItemContainer newcontainer, int iTargetPos, bool allowStack, bool ignoreStackLimit, BasePlayer sourcePlayer, bool allowSwap)",
    "MethodSourseCode": "\n\tpublic bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)\n\t{\n\t\tusing (TimeWarning.New(\u0022MoveToContainer\u0022))\n\t\t{\n\t\t\tBasePlayer playerOwner = newcontainer.playerOwner;\n\t\t\tif (playerOwner != null \u0026\u0026 playerOwner.IsDead() \u0026\u0026 parent != null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbool flag = iTargetPos == -1;\n\t\t\tItemContainer itemContainer = parent;\n\t\t\tif (iTargetPos == -1)\n\t\t\t{\n\t\t\t\tif (allowStack \u0026\u0026 info.stackable \u003E 1)\n\t\t\t\t{\n\t\t\t\t\tBufferList\u003CItem\u003E obj = Facepunch.Pool.Get\u003CBufferList\u003CItem\u003E\u003E();\n\t\t\t\t\tnewcontainer.FindItemsByItemID(info.itemid, obj);\n\t\t\t\t\tforeach (Item item3 in obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (item3.position \u003E iTargetPos \u0026\u0026 item3.CanStack(this) \u0026\u0026 (ignoreStackLimit || item3.amount \u003C item3.MaxStackable()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiTargetPos = item3.position;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Pool.Free(ref obj, freeElements: false);\n\t\t\t\t}\n\t\t\t\tif (iTargetPos == -1 \u0026\u0026 newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)\n\t\t\t\t{\n\t\t\t\t\tiTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);\n\t\t\t\t\tif (iTargetPos == int.MinValue)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (iTargetPos == -1)\n\t\t\t\t{\n\t\t\t\t\tif (newcontainer == parent)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tbool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) \u0026\u0026 info.isWearable;\n\t\t\t\t\tItemModWearable itemModWearable = info.ItemModWearable;\n\t\t\t\t\tfor (int i = 0; i \u003C newcontainer.capacity; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tItem slot = newcontainer.GetSlot(i);\n\t\t\t\t\t\tif (slot == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (CanMoveTo(newcontainer, i))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiTargetPos = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag2 \u0026\u0026 slot != null \u0026\u0026 !slot.info.ItemModWearable.CanExistWith(itemModWearable))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiTargetPos = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (newcontainer.HasAvailableSlotsDefined \u0026\u0026 DoItemSlotsConflict(slot))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiTargetPos = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag2 \u0026\u0026 iTargetPos == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tiTargetPos = newcontainer.capacity - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iTargetPos == -1)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!CanMoveTo(newcontainer, iTargetPos))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (iTargetPos \u003E= 0 \u0026\u0026 newcontainer.SlotTaken(this, iTargetPos))\n\t\t\t{\n\t\t\t\tItem slot2 = newcontainer.GetSlot(iTargetPos);\n\t\t\t\tif (slot2 == this)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (allowStack \u0026\u0026 slot2 != null)\n\t\t\t\t{\n\t\t\t\t\tint num = slot2.MaxStackable();\n\t\t\t\t\tif (slot2.CanStack(this))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ignoreStackLimit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum = int.MaxValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (slot2.amount \u003E= num)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint num2 = Mathf.Min(num - slot2.amount, amount);\n\t\t\t\t\t\tslot2.amount \u002B= num2;\n\t\t\t\t\t\tif (slot2.instanceData != null \u0026\u0026 instanceData != null \u0026\u0026 (bool)info.GetComponent\u003CItemModFoodSpoiling\u003E())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tslot2.instanceData.dataFloat = Mathf.Min(slot2.instanceData.dataFloat, instanceData.dataFloat);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewcontainer.onItemAddedToStack?.Invoke(slot2, num2);\n\t\t\t\t\t\tamount -= num2;\n\t\t\t\t\t\tslot2.MarkDirty();\n\t\t\t\t\t\tInterface.CallHook(\u0022OnItemStacked\u0022, slot2, this, newcontainer, num2);\n\t\t\t\t\t\tMarkDirty();\n\t\t\t\t\t\tMigrateItemOwnership(slot2, num2);\n\t\t\t\t\t\tif (amount \u003C= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRemoveFromWorld();\n\t\t\t\t\t\t\tRemoveFromContainer();\n\t\t\t\t\t\t\tRemove();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (parent != null \u0026\u0026 allowSwap \u0026\u0026 slot2 != null)\n\t\t\t\t{\n\t\t\t\t\tItemContainer itemContainer2 = parent;\n\t\t\t\t\tint iTargetPos2 = position;\n\t\t\t\t\tItemContainer newcontainer2 = slot2.parent;\n\t\t\t\t\tint num3 = slot2.position;\n\t\t\t\t\tif (!slot2.CanMoveTo(itemContainer2, iTargetPos2))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (itemContainer2.maxStackSize \u003E 0 \u0026\u0026 slot2.amount \u003E itemContainer2.maxStackSize)\n\t\t\t\t\t{\n\t\t\t\t\t\tItem item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);\n\t\t\t\t\t\tif (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tslot2.amount \u002B= item.amount;\n\t\t\t\t\t\t\titem.MigrateItemOwnership(slot2, item.amount);\n\t\t\t\t\t\t\titem.Remove();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBaseEntity entityOwner = GetEntityOwner();\n\t\t\t\t\tBaseEntity entityOwner2 = slot2.GetEntityOwner();\n\t\t\t\t\tRemoveFromContainer();\n\t\t\t\t\tslot2.RemoveFromContainer();\n\t\t\t\t\tRemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);\n\t\t\t\t\tslot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);\n\t\t\t\t\tif (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))\n\t\t\t\t\t{\n\t\t\t\t\t\tRemoveFromContainer();\n\t\t\t\t\t\tslot2.RemoveFromContainer();\n\t\t\t\t\t\tSetParent(itemContainer2);\n\t\t\t\t\t\tposition = iTargetPos2;\n\t\t\t\t\t\tslot2.SetParent(newcontainer2);\n\t\t\t\t\t\tslot2.position = num3;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (parent == newcontainer)\n\t\t\t{\n\t\t\t\tif (iTargetPos \u003E= 0 \u0026\u0026 iTargetPos != position \u0026\u0026 !parent.SlotTaken(this, iTargetPos))\n\t\t\t\t{\n\t\t\t\t\tnewcontainer.onItemPositionChanged?.Invoke(this, position, iTargetPos);\n\t\t\t\t\tposition = iTargetPos;\n\t\t\t\t\tMarkDirty();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (newcontainer.maxStackSize \u003E 0 \u0026\u0026 newcontainer.maxStackSize \u003C amount)\n\t\t\t{\n\t\t\t\tItem item2 = SplitItem(newcontainer.maxStackSize);\n\t\t\t\tif (item2 != null \u0026\u0026 !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) \u0026\u0026 (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))\n\t\t\t\t{\n\t\t\t\t\tDroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;\n\t\t\t\t\tif (droppedItem != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdroppedItem.DroppedBy = sourcePlayer?.userID ?? ((EncryptedValue\u003Culong\u003E)0uL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tInterface.CallHook(\u0022OnItemStacked\u0022, item2, this, newcontainer);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!newcontainer.CanAccept(this))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tBaseEntity entityOwner3 = GetEntityOwner();\n\t\t\tRemoveFromContainer();\n\t\t\tRemoveFromWorld();\n\t\t\tRemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);\n\t\t\tposition = iTargetPos;\n\t\t\tSetParent(newcontainer);\n\t\t\treturn true;\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 189
  },
  {
    "HookSignature": "OnTreeMarkerHit(TreeEntity treeEntity, HitInfo info)",
    "MethodSignature": "DidHitMarker(HitInfo info)",
    "MethodSourseCode": "\n\tpublic bool DidHitMarker(HitInfo info)\n\t{\n\t\tif (xMarker == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnTreeMarkerHit\u0022, this, info);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (PrefabAttribute.server.Find\u003CTreeMarkerData\u003E(prefabID) != null)\n\t\t{\n\t\t\tif (new Bounds(xMarker.transform.position, Vector3.one * 0.2f).Contains(info.HitPositionWorld))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tVector3 lhs = Vector3Ex.Direction2D(base.transform.position, xMarker.transform.position);\n\t\t\tVector3 attackNormal = info.attackNormal;\n\t\t\tfloat num = Vector3.Dot(lhs, attackNormal);\n\t\t\tfloat num2 = Vector3.Distance(xMarker.transform.position, info.HitPositionWorld);\n\t\t\tif (num \u003E= 0.3f \u0026\u0026 num2 \u003C= 0.2f)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "TreeEntity",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnLiquidVesselFill(BaseLiquidVessel baseLiquidVessel, BasePlayer ownerPlayer, LiquidContainer facingLiquidContainer)",
    "MethodSignature": "FillCheck()",
    "MethodSourseCode": "\n\tpublic void FillCheck()\n\t{\n\t\tif (base.isClient)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat f = (UnityEngine.Time.realtimeSinceStartup - lastFillTime) * fillMlPerSec;\n\t\tVector3 pos = ownerPlayer.transform.position - new Vector3(0f, 1f, 0f);\n\t\tLiquidContainer facingLiquidContainer = GetFacingLiquidContainer();\n\t\tif (Interface.CallHook(\u0022OnLiquidVesselFill\u0022, this, ownerPlayer, facingLiquidContainer) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (facingLiquidContainer == null \u0026\u0026 CanFillFromWorld())\n\t\t{\n\t\t\tItem contents = GetContents();\n\t\t\tItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(pos);\n\t\t\tif (contents != null \u0026\u0026 contents.info.itemid != itemDefinition.itemid)\n\t\t\t{\n\t\t\t\tif ((float)timeSinceLastToast \u003E 5f)\n\t\t\t\t{\n\t\t\t\t\tDebug.Log(\u0022pushing toast\u0022);\n\t\t\t\t\ttimeSinceLastToast = 0f;\n\t\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Red_Normal, DifferentLiquidType, false);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAddLiquid(itemDefinition, Mathf.FloorToInt(f));\n\t\t}\n\t\telse if (facingLiquidContainer != null \u0026\u0026 facingLiquidContainer.HasLiquidItem())\n\t\t{\n\t\t\tint num = Mathf.CeilToInt((1f - HeldFraction()) * (float)MaxHoldable());\n\t\t\tif (num \u003E 0)\n\t\t\t{\n\t\t\t\tGetContents();\n\t\t\t\tItem liquidItem = facingLiquidContainer.GetLiquidItem();\n\t\t\t\tint num2 = Mathf.Min(Mathf.CeilToInt(f), Mathf.Min(liquidItem.amount, num));\n\t\t\t\tAddLiquid(liquidItem.info, num2);\n\t\t\t\tliquidItem.UseItem(num2);\n\t\t\t\tfacingLiquidContainer.OpenTap(2f);\n\t\t\t}\n\t\t}\n\t\tlastFillTime = UnityEngine.Time.realtimeSinceStartup;\n\t}\n",
    "ClassName": "BaseLiquidVessel",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "CanEntityBeHostile(BasePlayer basePlayer)",
    "MethodSignature": "IsHostile()",
    "MethodSourseCode": "\n\tpublic override bool IsHostile()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanEntityBeHostile\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn State.unHostileTimestamp \u003E TimeEx.currentTimestamp;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUseLockedEntity(BasePlayer player, KeyLock keyLock)",
    "MethodSignature": "OnTryToOpen(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool OnTryToOpen(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseLockedEntity\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (HasLockPermission(player))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn !IsLocked();\n\t}\n",
    "ClassName": "KeyLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfFrequencyChanged(RFReceiver rFReceiver, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(3uL)]\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild())\n\t\t{\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tnum = RFManager.ClampFrequency(num);\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: true);\n\t\t\t\tfrequency = num;\n\t\t\t\tMarkDirty();\n\t\t\t\tSendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFReceiver",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnPlayerSpectate(BasePlayer basePlayer, string spectateFilter)",
    "MethodSignature": "StartSpectating()",
    "MethodSourseCode": "\n\tpublic void StartSpectating()\n\t{\n\t\tif (!IsSpectating() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSpectate\u0022, this, spectateFilter) == null)\n\t\t{\n\t\t\tSetPlayerFlag(PlayerFlags.Spectating, b: true);\n\t\t\tUnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);\n\t\t\tCancelInvoke(InventoryUpdate);\n\t\t\tChatMessage(\u0022Becoming Spectator\u0022);\n\t\t\tUpdateSpectateTarget(spectateFilter);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanSeeStash(BasePlayer basePlayer, StashContainer nearbyStashEntity)",
    "MethodSignature": "CheckStashRevealInvoke()",
    "MethodSourseCode": "\n\tprivate void CheckStashRevealInvoke()\n\t{\n\t\tfor (int i = 0; i \u003C nearbyStashes.Count; i\u002B\u002B)\n\t\t{\n\t\t\tNearbyStash nearbyStash = nearbyStashes[i];\n\t\t\tif (nearbyStash.Entity == null || nearbyStash.Entity.IsDestroyed)\n\t\t\t{\n\t\t\t\tnearbyStashes.RemoveAt(i);\n\t\t\t}\n\t\t\telse if (nearbyStash.Entity.IsHidden() \u0026\u0026 nearbyStash.Entity.PlayerInRange(this))\n\t\t\t{\n\t\t\t\tnearbyStash.LookingAtTime \u002B= StashContainer.PlayerDetectionTickRate;\n\t\t\t\tif (nearbyStash.LookingAtTime \u003E= nearbyStash.Entity.uncoverTime)\n\t\t\t\t{\n\t\t\t\t\tif (Interface.CallHook(\u0022CanSeeStash\u0022, this, nearbyStash.Entity) != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnearbyStash.Entity.SetHidden(isHidden: false);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);\n\t\t\t\t\tInterface.CallHook(\u0022OnStashExposed\u0022, nearbyStash.Entity, this);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnearbyStash.LookingAtTime = 0f;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnDispenserBonusReceived(ResourceDispenser resourceDispenser, BasePlayer player, Item item)",
    "MethodSignature": "AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)",
    "MethodSourseCode": "\n\tpublic void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)\n\t{\n\t\tif (forceFullFinishBonus)\n\t\t{\n\t\t\tfraction = 1f;\n\t\t}\n\t\tSendMessage(\u0022FinishBonusAssigned\u0022, SendMessageOptions.DontRequireReceiver);\n\t\tif (fraction \u003C= 0f || finishBonus == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (ItemAmount finishBonu in finishBonus)\n\t\t{\n\t\t\tint num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));\n\t\t\tint num2 = CalculateGatherBonus(player, finishBonu, num);\n\t\t\tItem item = ItemManager.Create(finishBonu.itemDef, num \u002B num2, 0uL);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnDispenserBonus\u0022, this, player, item);\n\t\t\t\tif (obj is Item)\n\t\t\t\t{\n\t\t\t\t\titem = (Item)obj;\n\t\t\t\t}\n\t\t\t\tApplyItemOwnership(player, item);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);\n\t\t\t\tInterface.CallHook(\u0022OnDispenserBonusReceived\u0022, this, player, item);\n\t\t\t\twhile (item.amount \u003E item.MaxStackable())\n\t\t\t\t{\n\t\t\t\t\tItem item2 = item.SplitItem(item.MaxStackable());\n\t\t\t\t\tplayer.GiveItem(item2, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t\t\t}\n\t\t\t\tplayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ResourceDispenser",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "OnFlameThrowerBurn(FlameThrower flameThrower, BaseEntity baseEntity)",
    "MethodSignature": "FlameTick()",
    "MethodSourseCode": "\n\tpublic void FlameTick()\n\t{\n\t\tfloat num = UnityEngine.Time.realtimeSinceStartup - lastFlameTick;\n\t\tlastFlameTick = UnityEngine.Time.realtimeSinceStartup;\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSingletonComponent\u003CNpcFireManager\u003E.Instance.Move(this);\n\t\tReduceAmmo(num);\n\t\tSendNetworkUpdate();\n\t\tRay ray = ownerPlayer.eyes.BodyRay();\n\t\tVector3 origin = ray.origin;\n\t\tRaycastHit hitInfo;\n\t\tbool num2 = UnityEngine.Physics.SphereCast(ray, 0.3f, out hitInfo, flameRange, 1218652417);\n\t\tif (!num2)\n\t\t{\n\t\t\thitInfo.point = origin \u002B ray.direction * flameRange;\n\t\t}\n\t\tfloat num3 = (ownerPlayer.IsNpc ? npcDamageScale : 1f);\n\t\tfloat amount = damagePerSec[0].amount;\n\t\tdamagePerSec[0].amount = amount * num * num3;\n\t\tint num4 = 2146305;\n\t\tint layers = 133376;\n\t\tif (!ownerPlayer.IsNpc)\n\t\t{\n\t\t\tnum4 |= 0x800;\n\t\t}\n\t\tDamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, num4, useLineOfSight: true, ignoreAI: false, ignoreAttackingPlayer: true, extendedLineOfSight: true);\n\t\tdamagePerSec[0].amount = damagePerSec[0].amount * playerDamageMultiplier;\n\t\tDamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, layers, useLineOfSight: true, ignoreAI: false, ignoreAttackingPlayer: true, extendedLineOfSight: true);\n\t\tdamagePerSec[0].amount = amount;\n\t\tif (num2 \u0026\u0026 UnityEngine.Time.realtimeSinceStartup \u003E= nextFlameTime \u0026\u0026 hitInfo.distance \u003E 1.1f)\n\t\t{\n\t\t\tnextFlameTime = UnityEngine.Time.realtimeSinceStartup \u002B (ownerPlayer.IsNpc ? 0.25f : 0.45f);\n\t\t\tVector3 vector = hitInfo.point - ray.direction * 0.25f;\n\t\t\tVector3 vector2 = vector \u002B new Vector3(0f, 0.2f, 0f);\n\t\t\tbool flag = !GamePhysics.CheckSphere(vector, 0.1f, 1084293377);\n\t\t\tif (!flag \u0026\u0026 GamePhysics.LineOfSight(vector, vector2, 1084293377))\n\t\t\t{\n\t\t\t\tvector = vector2;\n\t\t\t\tflag = !GamePhysics.CheckSphere(vector, 0.1f, 1084293377);\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, vector);\n\t\t\t\tif ((bool)baseEntity)\n\t\t\t\t{\n\t\t\t\t\tInterface.CallHook(\u0022OnFlameThrowerBurn\u0022, this, baseEntity);\n\t\t\t\t\tbaseEntity.creatorEntity = ownerPlayer;\n\t\t\t\t\tFireBall fireBall = baseEntity as FireBall;\n\t\t\t\t\tif (fireBall != null \u0026\u0026 ownerPlayer.IsNpc)\n\t\t\t\t\t{\n\t\t\t\t\t\tfireBall.ignoreNPC = true;\n\t\t\t\t\t}\n\t\t\t\t\tbaseEntity.Spawn();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ammo == 0)\n\t\t{\n\t\t\tSetFlameState(wantsOn: false);\n\t\t}\n\t\tItem ownerItem = GetOwnerItem();\n\t\tif (ownerItem != null \u0026\u0026 !base.UsingInfiniteAmmoCheat \u0026\u0026 !ownerPlayer.IsNpc)\n\t\t{\n\t\t\townerItem.LoseCondition(num);\n\t\t}\n\t}\n",
    "ClassName": "FlameThrower",
    "HookLineInvoke": 50
  },
  {
    "HookSignature": "OnPlayerBanned(Network.Connection connection, string actionReasonDetailsString)",
    "MethodSignature": "OnClientActionRequired(OnClientActionRequiredCallbackInfo data)",
    "MethodSourseCode": "\n\tprivate static void OnClientActionRequired(ref OnClientActionRequiredCallbackInfo data)\n\t{\n\t\tusing (TimeWarning.New(\u0022OnClientActionRequired\u0022, 10))\n\t\t{\n\t\t\tIntPtr clientHandle = data.ClientHandle;\n\t\t\tConnection connection = GetConnection(clientHandle);\n\t\t\tif (connection == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022[EAC] Status update for invalid client: \u0022 \u002B clientHandle);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (data.ClientAction != AntiCheatCommonClientAction.RemovePlayer)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tUtf8String actionReasonDetailsString = data.ActionReasonDetailsString;\n\t\t\t\tif (connection.IsDevelopmentBuild())\n\t\t\t\t{\n\t\t\t\t\tDebug.LogWarning(\u0022[EAC] Remove player action skipped for unprotected client: \u0022 \u002B connection.ToString());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tDebug.Log($\u0022[EAC] Kicking {connection.userid} / {connection.username} ({actionReasonDetailsString})\u0022);\n\t\t\t\tconnection.authStatusEAC = \u0022eac\u0022;\n\t\t\t\tNetwork.Net.sv.Kick(connection, \u0022EAC: \u0022 \u002B actionReasonDetailsString);\n\t\t\t\tOxide.Core.Interface.CallHook(\u0022OnPlayerKicked\u0022, connection, actionReasonDetailsString.ToString());\n\t\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned || data.ActionReasonCode == AntiCheatCommonClientActionReason.TemporaryBanned)\n\t\t\t\t{\n\t\t\t\t\tconnection.authStatusEAC = \u0022eacbanned\u0022;\n\t\t\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 2, 0, \u0022\u003Ccolor=#fff\u003ESERVER\u003C/color\u003E Kicking \u0022 \u002B connection.username \u002B \u0022 (banned by anticheat)\u0022);\n\t\t\t\t\tOxide.Core.Interface.CallHook(\u0022OnPlayerBanned\u0022, connection, actionReasonDetailsString.ToString());\n\t\t\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned)\n\t\t\t\t\t{\n\t\t\t\t\t\tEntity.DeleteBy(connection.userid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tUnregisterClientOptions unregisterClientOptions = default(UnregisterClientOptions);\n\t\t\t\tunregisterClientOptions.ClientHandle = clientHandle;\n\t\t\t\tUnregisterClientOptions options = unregisterClientOptions;\n\t\t\t\tInterface.UnregisterClient(ref options);\n\t\t\t\tclient2connection.TryRemove((uint)(int)clientHandle, out var _);\n\t\t\t\tconnection2client.TryRemove(connection, out var _);\n\t\t\t\tconnection2status.TryRemove(connection, out var _);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "EACServer",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnEntityLeave(TriggerBase triggerBase, BaseEntity ent)",
    "MethodSignature": "OnEntityLeave(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic virtual void OnEntityLeave(BaseEntity ent)\n\t{\n\t\tif (entityContents != null \u0026\u0026 Interface.CallHook(\u0022OnEntityLeave\u0022, this, ent) == null)\n\t\t{\n\t\t\tentityContents.Remove(ent);\n\t\t\tOnEntityLeaveTrigger?.Invoke(ent);\n\t\t}\n\t}\n",
    "ClassName": "TriggerBase",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHelicopterStrafeEnter(PatrolHelicopterAI patrolHelicopterAI, UnityEngine.Vector3 strafeTargetTransformPosition, BasePlayer strafeTarget)",
    "MethodSignature": "StartStrafe(BasePlayer strafeTarget, bool shouldUseNapalm)",
    "MethodSourseCode": "\n\tprivate void StartStrafe(BasePlayer strafeTarget, bool shouldUseNapalm = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterStrafeEnter\u0022, this, strafeTarget.transform.position, strafeTarget) == null)\n\t\t{\n\t\t\tstrafe_target = strafeTarget;\n\t\t\tget_out_of_strafe_distance = UnityEngine.Random.Range(13f, 17f);\n\t\t\tif (CanUseNapalm() \u0026\u0026 shouldUseNapalm)\n\t\t\t{\n\t\t\t\tpassNapalm = shouldUseNapalm;\n\t\t\t\tuseNapalm = true;\n\t\t\t\tlastNapalmTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t}\n\t\t\tlastStrafeTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t_currentState = aiState.STRAFE;\n\t\t\tRefreshTargetPosition();\n\t\t\tnumRocketsLeft = 12 \u002B UnityEngine.Random.Range(-1, 1);\n\t\t\tlastRocketTime = 0f;\n\t\t\tmovementLockingAiming = true;\n\t\t\tVector3 randomOffset = GetRandomOffset(strafe_target_position, 175f, 192.5f);\n\t\t\tSetTargetDestination(randomOffset, 10f);\n\t\t\tSetIdealRotation(GetYawRotationTo(randomOffset));\n\t\t\tputtingDistance = true;\n\t\t}\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerDismountFailed(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "RPC_WantsDismount(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void RPC_WantsDismount(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!HasValidDismountPosition(player))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerDismountFailed\u0022, player, this);\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnPlayerWantsDismount\u0022, player, this) == null \u0026\u0026 (!(player != null) || !player.IsRestrained))\n\t\t{\n\t\t\tAttemptDismount(player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnPhoneAnswered(PhoneController phoneController, PhoneController activeCallTo)",
    "MethodSignature": "AnswerPhone(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void AnswerPhone(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (IsInvoking(TimeOutDialing))\n\t\t{\n\t\t\tCancelInvoke(TimeOutDialing);\n\t\t}\n\t\tif (!(activeCallTo == null))\n\t\t{\n\t\t\tBasePlayer player = msg.player;\n\t\t\tif (Interface.CallHook(\u0022OnPhoneAnswer\u0022, this, activeCallTo) == null)\n\t\t\t{\n\t\t\t\tUpdateServerPlayer(player);\n\t\t\t\tBeginCall();\n\t\t\t\tactiveCallTo.BeginCall();\n\t\t\t\tInterface.CallHook(\u0022OnPhoneAnswered\u0022, this, activeCallTo);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "CanCastFishingRod(BasePlayer ownerPlayer, BaseFishingRod baseFishingRod, Item currentLure, UnityEngine.Vector3 pos)",
    "MethodSignature": "Server_RequestCast(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void Server_RequestCast(RPCMessage msg)\n\t{\n\t\tVector3 pos = msg.read.Vector3();\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tItem currentLure = GetCurrentLure();\n\t\tif (currentLure == null)\n\t\t{\n\t\t\tFailedCast(FailReason.NoLure);\n\t\t\treturn;\n\t\t}\n\t\tif (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))\n\t\t{\n\t\t\tFailedCast(reason);\n\t\t\treturn;\n\t\t}\n\t\tItemModCompostable component = (ItemModCompostable)Interface.CallHook(\u0022CanCastFishingRod\u0022, ownerPlayer, this, currentLure, pos);\n\t\tif (!(component is bool) || (bool)(object)component)\n\t\t{\n\t\t\tFishingBobber component2 = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position \u002B Vector3.up * 2.8f \u002B ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent\u003CFishingBobber\u003E();\n\t\t\tcomponent2.transform.forward = GetOwnerPlayer().eyes.BodyForward();\n\t\t\tcomponent2.Spawn();\n\t\t\tcomponent2.InitialiseBobber(ownerPlayer, surfaceBody, pos, 150f);\n\t\t\tint usedLureAmount = 0;\n\t\t\tif (FishLookup.Instance != null)\n\t\t\t{\n\t\t\t\tcurrentFishTarget = FishLookup.Instance.GetFish(component2.transform.position, surfaceBody, currentLure, out fishableModifier, lastFish, out usedLureAmount);\n\t\t\t}\n\t\t\tlureUsed = currentLure.info;\n\t\t\tcurrentLure.UseItem(usedLureAmount);\n\t\t\tlastFish = fishableModifier;\n\t\t\tcurrentBobber.Set(component2);\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_ReceiveCastPoint\u0022), component2.net.ID);\n\t\t\townerPlayer.SignalBroadcast(Signal.Attack);\n\t\t\tcatchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));\n\t\t\tcatchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;\n\t\t\tfloat val = (lureUsed.TryGetComponent\u003CItemModCompostable\u003E(out component) ? component.BaitValue : 0f);\n\t\t\tval = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);\n\t\t\tcatchTime = Mathf.Clamp((float)catchTime - val, 3f, 20f);\n\t\t\tplayerStartPosition = ownerPlayer.transform.position;\n\t\t\tSetFlag(Flags.Busy, b: true);\n\t\t\tCurrentState = CatchState.Waiting;\n\t\t\tInvokeRepeating(CatchProcess, 0f, 0f);\n\t\t\tinQueue = false;\n\t\t\tBasePlayer ownerPlayer2 = GetOwnerPlayer();\n\t\t\tif (ownerPlayer2 != null)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnStartFish(ownerPlayer2, currentLure, pos);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnFishingRodCast\u0022, this, ownerPlayer, currentLure);\n\t\t}\n\t}\n",
    "ClassName": "BaseFishingRod",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnExcavatorSuppliesRequest(ExcavatorSignalComputer excavatorSignalComputer, BasePlayer rpcPlayer)",
    "MethodSignature": "RequestSupplies(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\t[RPC_Server]\n\tpublic void RequestSupplies(RPCMessage rpc)\n\t{\n\t\tif (HasFlag(Flags.Reserved7) \u0026\u0026 IsPowered() \u0026\u0026 chargePower \u003E= chargeNeededForSupplies \u0026\u0026 Interface.CallHook(\u0022OnExcavatorSuppliesRequest\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(supplyPlanePrefab.resourcePath);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tVector3 position = dropPoints[UnityEngine.Random.Range(0, dropPoints.Length)].position;\n\t\t\t\tVector3 vector = new Vector3(UnityEngine.Random.Range(-3f, 3f), 0f, UnityEngine.Random.Range(-3f, 3f));\n\t\t\t\tbaseEntity.SendMessage(\u0022InitDropPosition\u0022, position \u002B vector, SendMessageOptions.DontRequireReceiver);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnExcavatorSuppliesRequested\u0022, this, rpc.player, baseEntity);\n\t\t\tchargePower -= chargeNeededForSupplies;\n\t\t\tSetFlag(Flags.Reserved7, b: false);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "ExcavatorSignalComputer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnItemAddedToContainer(ItemContainer itemContainer, Item item)",
    "MethodSignature": "Insert(Item item)",
    "MethodSourseCode": "\n\tpublic bool Insert(Item item)\n\t{\n\t\tif (itemList.Contains(item))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsFull())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\titemList.Add(item);\n\t\titem.parent = this;\n\t\tif (!FindPosition(item))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tMarkDirty();\n\t\tif (onItemAddedRemoved != null)\n\t\t{\n\t\t\tonItemAddedRemoved(item, arg2: true);\n\t\t}\n\t\tItemContainer itemContainer = parent?.parent;\n\t\tif (itemContainer != null \u0026\u0026 itemContainer.onItemContentsChanged != null)\n\t\t{\n\t\t\titemContainer.onItemContentsChanged(item, arg2: true);\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemAddedToContainer\u0022, this, item);\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemContainer",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnRfListenerRemove(IRFObject obj, int frequency)",
    "MethodSignature": "RemoveListener(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void RemoveListener(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfListenerRemove\u0022, obj, frequency) == null \u0026\u0026 GetListenerSet(frequency).Remove(obj))\n\t\t{\n\t\t\tobj.RFSignalUpdate(on: false);\n\t\t\tInterface.CallHook(\u0022OnRfListenerRemoved\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnCorpsePopulate(NPCPlayer nPCPlayer, NPCPlayerCorpse nPCPlayerCorpse)",
    "MethodSignature": "CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List\u003CTriggerBase\u003E triggersOnDeath, bool forceServerSide)",
    "MethodSourseCode": "\n\tpublic override BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List\u003CTriggerBase\u003E triggersOnDeath, bool forceServerSide = false)\n\t{\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tNPCPlayerCorpse nPCPlayerCorpse = DropCorpse(CorpsePath, flagsOnDeath, modelState) as NPCPlayerCorpse;\n\t\t\tif ((bool)nPCPlayerCorpse)\n\t\t\t{\n\t\t\t\tif (NavAgent != null)\n\t\t\t\t{\n\t\t\t\t\tnPCPlayerCorpse.transform.position \u002B= Vector3.down * NavAgent.baseOffset;\n\t\t\t\t}\n\t\t\t\tnPCPlayerCorpse.SetLootableIn(2f);\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);\n\t\t\t\tif (CopyInventoryToCorpse)\n\t\t\t\t{\n\t\t\t\t\tnPCPlayerCorpse.TakeFrom(this, base.inventory.containerMain, base.inventory.containerWear, base.inventory.containerBelt);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnPCPlayerCorpse.CreateEmptyContainer(base.inventory.containerMain.capacity);\n\t\t\t\t}\n\t\t\t\tnPCPlayerCorpse.playerName = OverrideCorpseName;\n\t\t\t\tnPCPlayerCorpse.playerSteamID = userID;\n\t\t\t\tnPCPlayerCorpse.Spawn();\n\t\t\t\tif (ShouldCorpseTakeChildren)\n\t\t\t\t{\n\t\t\t\t\tnPCPlayerCorpse.TakeChildren(this);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i \u003C nPCPlayerCorpse.containers.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tItemContainer itemContainer = nPCPlayerCorpse.containers[i];\n\t\t\t\t\tif (!KeepCorpseClothingIntact || i != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\titemContainer.Clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnCorpsePopulate\u0022, this, nPCPlayerCorpse);\n\t\t\t\tif (obj is BaseCorpse)\n\t\t\t\t{\n\t\t\t\t\treturn (BaseCorpse)obj;\n\t\t\t\t}\n\t\t\t\tApplyLoot(nPCPlayerCorpse);\n\t\t\t}\n\t\t\treturn nPCPlayerCorpse;\n\t\t}\n\t}\n",
    "ClassName": "NPCPlayer",
    "HookLineInvoke": 38
  },
  {
    "HookSignature": "OnRfListenerAdded(IRFObject obj, int frequency)",
    "MethodSignature": "AddListener(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void AddListener(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfListenerAdd\u0022, obj, frequency) == null \u0026\u0026 GetListenerSet(frequency).Add(obj))\n\t\t{\n\t\t\tbool value;\n\t\t\tbool on = _isFrequencyBroadcasting.TryGetValue(frequency, out value) \u0026\u0026 value;\n\t\t\tobj.RFSignalUpdate(on);\n\t\t\tInterface.CallHook(\u0022OnRfListenerAdded\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnLootSpawn(LootContainer lootContainer)",
    "MethodSignature": "SpawnLoot()",
    "MethodSourseCode": "\n\tpublic virtual void SpawnLoot()\n\t{\n\t\tif (base.inventory == null)\n\t\t{\n\t\t\tDebug.Log(\u0022CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tbase.inventory.Clear();\n\t\tItemManager.DoRemoves();\n\t\tif (Interface.CallHook(\u0022OnLootSpawn\u0022, this) == null)\n\t\t{\n\t\t\tPopulateLoot();\n\t\t\tif (shouldRefreshContents)\n\t\t\t{\n\t\t\t\tInvoke(SpawnLoot, UnityEngine.Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "LootContainer",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanSetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipManager.RelationshipType type, int weight)",
    "MethodSignature": "SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipType type, int weight, bool sendImmediate)",
    "MethodSourseCode": "\n\tpublic void SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipType type, int weight = 1, bool sendImmediate = false)\n\t{\n\t\tif (!contacts)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tulong num = player.userID.Get();\n\t\tulong num2 = otherPlayer.userID.Get();\n\t\tif (player == null || player == otherPlayer || player.IsNpc || (otherPlayer != null \u0026\u0026 otherPlayer.IsNpc) || Interface.CallHook(\u0022CanSetRelationship\u0022, player, otherPlayer, type, weight) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPlayerRelationships playerRelationships = GetRelationships(num);\n\t\tif (!CleanupOldContacts(playerRelationships, num))\n\t\t{\n\t\t\tCleanupOldContacts(playerRelationships, num, RelationshipType.Enemy);\n\t\t}\n\t\tPlayerRelationshipInfo relations = playerRelationships.GetRelations(num2);\n\t\tbool flag = false;\n\t\tif (relations.type != type)\n\t\t{\n\t\t\tflag = true;\n\t\t\trelations.weight = 0;\n\t\t}\n\t\trelations.type = type;\n\t\trelations.weight \u002B= weight;\n\t\tfloat num3 = UnityEngine.Time.realtimeSinceStartup - relations.lastMugshotTime;\n\t\tif (flag || relations.mugshotCrc == 0 || num3 \u003E= mugshotUpdateInterval)\n\t\t{\n\t\t\tbool flag2 = otherPlayer.IsAlive();\n\t\t\tbool num4 = player.SecondsSinceAttacked \u003E 10f \u0026\u0026 !player.IsAiming;\n\t\t\tfloat num5 = 100f;\n\t\t\tif (num4)\n\t\t\t{\n\t\t\t\tVector3 normalized = (otherPlayer.eyes.position - player.eyes.position).normalized;\n\t\t\t\tbool flag3 = Vector3.Dot(player.eyes.HeadForward(), normalized) \u003E= 0.6f;\n\t\t\t\tfloat num6 = Vector3Ex.Distance2D(player.transform.position, otherPlayer.transform.position);\n\t\t\t\tif (flag2 \u0026\u0026 num6 \u003C num5 \u0026\u0026 flag3)\n\t\t\t\t{\n\t\t\t\t\tClientRPC(RpcTarget.Player(\u0022CLIENT_DoMugshot\u0022, player), num2);\n\t\t\t\t\trelations.lastMugshotTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sendImmediate)\n\t\t{\n\t\t\tSendRelationshipsFor(player);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMarkRelationshipsDirtyFor(player);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnQuarryToggled(MiningQuarry miningQuarry, BasePlayer msgPlayer)",
    "MethodSignature": "StopEngine(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void StopEngine(RPCMessage msg)\n\t{\n\t\tMiningQuarry miningQuarry = GetParentEntity() as MiningQuarry;\n\t\tif ((bool)miningQuarry \u0026\u0026 Interface.CallHook(\u0022OnQuarryToggle\u0022, miningQuarry, msg.player) == null)\n\t\t{\n\t\t\tminingQuarry.EngineSwitch(isOn: false);\n\t\t\tInterface.CallHook(\u0022OnQuarryToggled\u0022, miningQuarry, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "EngineSwitch",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnTrapArm(BearTrap bearTrap, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_Arm(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_Arm(RPCMessage rpc)\n\t{\n\t\tif (!Armed() \u0026\u0026 Interface.CallHook(\u0022OnTrapArm\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tArm();\n\t\t}\n\t}\n",
    "ClassName": "BearTrap",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnNpcTarget(BaseEntity owner, BaseEntity entity)",
    "MethodSignature": "GetNearest(List\u003CBaseEntity\u003E entities, float rangeFraction)",
    "MethodSourseCode": "\n\tprivate BaseEntity GetNearest(List\u003CBaseEntity\u003E entities, float rangeFraction)\n\t{\n\t\tif (entities == null || entities.Count == 0)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tfloat num = float.PositiveInfinity;\n\t\tBaseEntity result = null;\n\t\tforeach (BaseEntity entity in entities)\n\t\t{\n\t\t\tif (!(entity == null) \u0026\u0026 !(entity.Health() \u003C= 0f) \u0026\u0026 Interface.CallHook(\u0022OnNpcTarget\u0022, owner, entity) == null)\n\t\t\t{\n\t\t\t\tfloat num2 = Vector3.Distance(entity.transform.position, owner.transform.position);\n\t\t\t\tif (num2 \u003C= rangeFraction * maxRange \u0026\u0026 num2 \u003C num)\n\t\t\t\t{\n\t\t\t\t\tresult = entity;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "AIBrainSenses",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnVehicleModuleDeselected(ModularCarGarage modularCarGarage, BasePlayer player)",
    "MethodSignature": "RPC_DeselectedLootItem(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void RPC_DeselectedLootItem(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (player.inventory.loot.IsLooting() \u0026\u0026 !(player.inventory.loot.entitySource != this))\n\t\t{\n\t\t\tif (player.inventory.loot.RemoveContainerAt(3))\n\t\t\t{\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnVehicleModuleDeselected\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnWildlifeTrap(WildlifeTrap wildlifeTrap, TrappableWildlife trapped)",
    "MethodSignature": "TrapWildlife(TrappableWildlife trapped)",
    "MethodSourseCode": "\n\tpublic void TrapWildlife(TrappableWildlife trapped)\n\t{\n\t\tif (Interface.CallHook(\u0022OnWildlifeTrap\u0022, this, trapped) == null)\n\t\t{\n\t\t\tItem item = ItemManager.Create(trapped.inventoryObject, UnityEngine.Random.Range(trapped.minToCatch, trapped.maxToCatch \u002B 1), 0uL);\n\t\t\tif (base.LastLootedByPlayer != null)\n\t\t\t{\n\t\t\t\titem.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.SurvivalTrap);\n\t\t\t}\n\t\t\tif (!item.MoveToContainer(base.inventory))\n\t\t\t{\n\t\t\t\titem.Remove();\n\t\t\t\tOnTrappedWildlife(setFlag: false);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOnTrappedWildlife(setFlag: true);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "WildlifeTrap",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSolarPanelSunUpdate(SolarPanel solarPanel, int num)",
    "MethodSignature": "SunUpdate()",
    "MethodSourseCode": "\n\tpublic void SunUpdate()\n\t{\n\t\tint num = currentEnergy;\n\t\tif (TOD_Sky.Instance.IsNight)\n\t\t{\n\t\t\tnum = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tVector3 sunDirection = TOD_Sky.Instance.SunDirection;\n\t\t\tfloat value = Vector3.Dot(sunSampler.forward, sunDirection);\n\t\t\tfloat num2 = Mathf.InverseLerp(dot_minimum, dot_maximum, value);\n\t\t\tif (num2 \u003E 0f \u0026\u0026 !IsVisible(sunSampler.position \u002B sunDirection * 100f, 101f))\n\t\t\t{\n\t\t\t\tnum2 = 0f;\n\t\t\t}\n\t\t\tnum = Mathf.FloorToInt((float)maximalPowerOutput * num2 * base.healthFraction);\n\t\t}\n\t\tbool num3 = currentEnergy != num;\n\t\tcurrentEnergy = num;\n\t\tif (num3 \u0026\u0026 Interface.CallHook(\u0022OnSolarPanelSunUpdate\u0022, this, num) == null)\n\t\t{\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "SolarPanel",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnEntityEnter(TriggerComfort triggerComfort, BaseEntity ent)",
    "MethodSignature": "OnEntityEnter(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic override void OnEntityEnter(BaseEntity ent)\n\t{\n\t\tif ((ent is BasePlayer || ent is RidableHorse || ent is RidableHorse) \u0026\u0026 Interface.CallHook(\u0022OnEntityEnter\u0022, this, ent) == null)\n\t\t{\n\t\t\t_entities.Add(ent);\n\t\t}\n\t}\n",
    "ClassName": "TriggerComfort",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnExcavatorSuppliesRequested(ExcavatorSignalComputer excavatorSignalComputer, BasePlayer rpcPlayer, BaseEntity baseEntity)",
    "MethodSignature": "RequestSupplies(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\t[RPC_Server]\n\tpublic void RequestSupplies(RPCMessage rpc)\n\t{\n\t\tif (HasFlag(Flags.Reserved7) \u0026\u0026 IsPowered() \u0026\u0026 chargePower \u003E= chargeNeededForSupplies \u0026\u0026 Interface.CallHook(\u0022OnExcavatorSuppliesRequest\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(supplyPlanePrefab.resourcePath);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tVector3 position = dropPoints[UnityEngine.Random.Range(0, dropPoints.Length)].position;\n\t\t\t\tVector3 vector = new Vector3(UnityEngine.Random.Range(-3f, 3f), 0f, UnityEngine.Random.Range(-3f, 3f));\n\t\t\t\tbaseEntity.SendMessage(\u0022InitDropPosition\u0022, position \u002B vector, SendMessageOptions.DontRequireReceiver);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnExcavatorSuppliesRequested\u0022, this, rpc.player, baseEntity);\n\t\t\tchargePower -= chargeNeededForSupplies;\n\t\t\tSetFlag(Flags.Reserved7, b: false);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "ExcavatorSignalComputer",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnNewSave(string strFilename)",
    "MethodSignature": "Load(string strFilename, bool allowOutOfDateSaves)",
    "MethodSourseCode": "\n\tpublic static bool Load(string strFilename = \u0022\u0022, bool allowOutOfDateSaves = false)\n\t{\n\t\tSaveCreatedTime = DateTime.UtcNow;\n\t\ttry\n\t\t{\n\t\t\tif (strFilename == \u0022\u0022)\n\t\t\t{\n\t\t\t\tstrFilename = World.SaveFolderName \u002B \u0022/\u0022 \u002B World.SaveFileName;\n\t\t\t}\n\t\t\tif (!File.Exists(strFilename))\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnNewSave\u0022, strFilename);\n\t\t\t\tif (!File.Exists(\u0022TestSaves/\u0022 \u002B strFilename))\n\t\t\t\t{\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\u0022Couldn\u0027t load \u0022 \u002B strFilename \u002B \u0022 - file doesn\u0027t exist\u0022);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tstrFilename = \u0022TestSaves/\u0022 \u002B strFilename;\n\t\t\t}\n\t\t\tList\u003CBaseEntity\u003E list = FindMapEntities();\n\t\t\tDictionary\u003CBaseEntity, ProtoBuf.Entity\u003E dictionary = new Dictionary\u003CBaseEntity, ProtoBuf.Entity\u003E();\n\t\t\tusing (FileStream fileStream = File.OpenRead(strFilename))\n\t\t\t{\n\t\t\t\tusing BinaryReader binaryReader = new BinaryReader(fileStream);\n\t\t\t\tSaveCreatedTime = File.GetCreationTime(strFilename);\n\t\t\t\tif (binaryReader.ReadSByte() != 83 || binaryReader.ReadSByte() != 65 || binaryReader.ReadSByte() != 86 || binaryReader.ReadSByte() != 82)\n\t\t\t\t{\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\u0022Invalid save (missing header)\u0022);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (binaryReader.PeekChar() == 74)\n\t\t\t\t{\n\t\t\t\t\tbinaryReader.ReadChar();\n\t\t\t\t\tWipeId = JsonConvert.DeserializeObject\u003CSaveExtraData\u003E(binaryReader.ReadString()).WipeId;\n\t\t\t\t}\n\t\t\t\tif (binaryReader.PeekChar() == 68)\n\t\t\t\t{\n\t\t\t\t\tbinaryReader.ReadChar();\n\t\t\t\t\tSaveCreatedTime = Epoch.ToDateTime(binaryReader.ReadInt32());\n\t\t\t\t}\n\t\t\t\tif (binaryReader.ReadUInt32() != 270)\n\t\t\t\t{\n\t\t\t\t\tif (allowOutOfDateSaves)\n\t\t\t\t\t{\n\t\t\t\t\t\tUnityEngine.Debug.LogWarning(\u0022This save is from an older (possibly incompatible) version!\u0022);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tUnityEngine.Debug.LogWarning(\u0022This save is from an older version. It might not load properly.\u0022);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tClearMapEntities(list);\n\t\t\t\tAssert.IsTrue(BaseEntity.saveList.Count == 0, \u0022BaseEntity.saveList isn\u0027t empty!\u0022);\n\t\t\t\tNetwork.Net.sv.Reset();\n\t\t\t\tRust.Application.isLoadingSave = true;\n\t\t\t\tHashSet\u003CNetworkableId\u003E hashSet = new HashSet\u003CNetworkableId\u003E();\n\t\t\t\twhile (fileStream.Position \u003C fileStream.Length)\n\t\t\t\t{\n\t\t\t\t\tRCon.Update();\n\t\t\t\t\tuint num = binaryReader.ReadUInt32();\n\t\t\t\t\tlong position = fileStream.Position;\n\t\t\t\t\tProtoBuf.Entity entData = Facepunch.Pool.Get\u003CProtoBuf.Entity\u003E();\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tentData.ReadFromStream(fileStream, (int)num);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception exception)\n\t\t\t\t\t{\n\t\t\t\t\t\tUnityEngine.Debug.LogWarning(\u0022Skipping entity since it could not be deserialized - stream position: \u0022 \u002B position \u002B \u0022 size: \u0022 \u002B num);\n\t\t\t\t\t\tUnityEngine.Debug.LogException(exception);\n\t\t\t\t\t\tfileStream.Position = position \u002B num;\n\t\t\t\t\t\tFacepunch.Pool.Free(ref entData);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (entData.basePlayer != null \u0026\u0026 dictionary.Any((KeyValuePair\u003CBaseEntity, ProtoBuf.Entity\u003E x) =\u003E x.Value.basePlayer != null \u0026\u0026 x.Value.basePlayer.userid == entData.basePlayer.userid))\n\t\t\t\t\t{\n\t\t\t\t\t\tstring[] obj = new string[5] { \u0022Skipping entity \u0022, null, null, null, null };\n\t\t\t\t\t\tNetworkableId uid = entData.baseNetworkable.uid;\n\t\t\t\t\t\tobj[1] = uid.ToString();\n\t\t\t\t\t\tobj[2] = \u0022 - it\u0027s a player \u0022;\n\t\t\t\t\t\tobj[3] = entData.basePlayer.userid.ToString();\n\t\t\t\t\t\tobj[4] = \u0022 who is in the save multiple times\u0022;\n\t\t\t\t\t\tUnityEngine.Debug.LogWarning(string.Concat(obj));\n\t\t\t\t\t\tFacepunch.Pool.Free(ref entData);\n\t\t\t\t\t}\n\t\t\t\t\telse if (entData.baseNetworkable.uid.IsValid \u0026\u0026 hashSet.Contains(entData.baseNetworkable.uid))\n\t\t\t\t\t{\n\t\t\t\t\t\tstring[] obj2 = new string[5] { \u0022Skipping entity \u0022, null, null, null, null };\n\t\t\t\t\t\tNetworkableId uid = entData.baseNetworkable.uid;\n\t\t\t\t\t\tobj2[1] = uid.ToString();\n\t\t\t\t\t\tobj2[2] = \u0022 \u0022;\n\t\t\t\t\t\tobj2[3] = StringPool.Get(entData.baseNetworkable.prefabID);\n\t\t\t\t\t\tobj2[4] = \u0022 - uid is used multiple times\u0022;\n\t\t\t\t\t\tUnityEngine.Debug.LogWarning(string.Concat(obj2));\n\t\t\t\t\t\tFacepunch.Pool.Free(ref entData);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (entData.baseNetworkable.uid.IsValid)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thashSet.Add(entData.baseNetworkable.uid);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(StringPool.Get(entData.baseNetworkable.prefabID), entData.baseEntity.pos, Quaternion.Euler(entData.baseEntity.rot));\n\t\t\t\t\t\tif ((bool)baseEntity)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbaseEntity.InitLoad(entData.baseNetworkable.uid);\n\t\t\t\t\t\t\tbaseEntity.PreServerLoad();\n\t\t\t\t\t\t\tdictionary.Add(baseEntity, entData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022Spawning \u0022 \u002B list.Count \u002B \u0022 entities from map\u0022);\n\t\t\tforeach (BaseEntity item in list)\n\t\t\t{\n\t\t\t\tif (!(item == null))\n\t\t\t\t{\n\t\t\t\t\titem.SpawnAsMapEntity();\n\t\t\t\t}\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022\\tdone.\u0022);\n\t\t\tDebugEx.Log(\u0022Spawning \u0022 \u002B dictionary.Count \u002B \u0022 entities from save\u0022);\n\t\t\tobject obj3 = Interface.CallHook(\u0022OnSaveLoad\u0022, dictionary);\n\t\t\tif (obj3 is bool)\n\t\t\t{\n\t\t\t\treturn (bool)obj3;\n\t\t\t}\n\t\t\tBaseNetworkable.LoadInfo info = default(BaseNetworkable.LoadInfo);\n\t\t\tinfo.fromDisk = true;\n\t\t\tStopwatch stopwatch = Stopwatch.StartNew();\n\t\t\tint num2 = 0;\n\t\t\tforeach (KeyValuePair\u003CBaseEntity, ProtoBuf.Entity\u003E item2 in dictionary)\n\t\t\t{\n\t\t\t\tBaseEntity key = item2.Key;\n\t\t\t\tif (key == null)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tRCon.Update();\n\t\t\t\tinfo.msg = item2.Value;\n\t\t\t\tkey.Spawn();\n\t\t\t\tkey.Load(info);\n\t\t\t\tif (key.IsValid())\n\t\t\t\t{\n\t\t\t\t\tnum2\u002B\u002B;\n\t\t\t\t\tif (stopwatch.Elapsed.TotalMilliseconds \u003E 2000.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstopwatch.Reset();\n\t\t\t\t\t\tstopwatch.Start();\n\t\t\t\t\t\tDebugEx.Log(\u0022\\t\u0022 \u002B num2 \u002B \u0022 / \u0022 \u002B dictionary.Count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022\\tdone.\u0022);\n\t\t\tDebugEx.Log(\u0022Postprocessing \u0022 \u002B list.Count \u002B \u0022 entities from map\u0022);\n\t\t\tforeach (BaseEntity item3 in list)\n\t\t\t{\n\t\t\t\tif (!(item3 == null))\n\t\t\t\t{\n\t\t\t\t\titem3.PostMapEntitySpawn();\n\t\t\t\t}\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022\\tdone.\u0022);\n\t\t\tDebugEx.Log(\u0022Postprocessing \u0022 \u002B list.Count \u002B \u0022 entities from save\u0022);\n\t\t\tforeach (KeyValuePair\u003CBaseEntity, ProtoBuf.Entity\u003E item4 in dictionary)\n\t\t\t{\n\t\t\t\tBaseEntity key2 = item4.Key;\n\t\t\t\tif (!(key2 == null))\n\t\t\t\t{\n\t\t\t\t\tRCon.Update();\n\t\t\t\t\tif (key2.IsValid())\n\t\t\t\t\t{\n\t\t\t\t\t\tkey2.UpdateNetworkGroup();\n\t\t\t\t\t\tkey2.PostServerLoad();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022\\tdone.\u0022);\n\t\t\tforeach (KeyValuePair\u003CBaseEntity, ProtoBuf.Entity\u003E item5 in dictionary)\n\t\t\t{\n\t\t\t\tProtoBuf.Entity obj4 = item5.Value;\n\t\t\t\tFacepunch.Pool.Free(ref obj4);\n\t\t\t}\n\t\t\tdictionary.Clear();\n\t\t\tif ((bool)SingletonComponent\u003CSpawnHandler\u003E.Instance)\n\t\t\t{\n\t\t\t\tDebugEx.Log(\u0022Enforcing SpawnPopulation Limits\u0022);\n\t\t\t\tSingletonComponent\u003CSpawnHandler\u003E.Instance.EnforceLimits();\n\t\t\t\tDebugEx.Log(\u0022\\tdone.\u0022);\n\t\t\t}\n\t\t\tInitializeWipeId();\n\t\t\tRust.Application.isLoadingSave = false;\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception exception2)\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning(\u0022Error loading save (\u0022 \u002B strFilename \u002B \u0022)\u0022);\n\t\t\tUnityEngine.Debug.LogException(exception2);\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "ClassName": "SaveRestore",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnFuelCheck(EntityFuelSystem entityFuelSystem)",
    "MethodSignature": "HasFuel(bool forceCheck)",
    "MethodSourseCode": "\n\tpublic bool HasFuel(bool forceCheck = false)\n\t{\n\t\tif (Time.time \u003E nextFuelCheckTime || forceCheck)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnFuelCheck\u0022, this);\n\t\t\tif (obj is bool)\n\t\t\t{\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\tcachedHasFuel = (float)GetFuelAmount() \u003E 0f;\n\t\t\tnextFuelCheckTime = Time.time \u002B UnityEngine.Random.Range(1f, 2f);\n\t\t}\n\t\treturn cachedHasFuel;\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanAssignBed(BasePlayer msgPlayer, SleepingBag sleepingBag, ulong num)",
    "MethodSignature": "AssignToFriend(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void AssignToFriend(RPCMessage msg)\n\t{\n\t\tif (!msg.player.CanInteract() || deployerUserID != (ulong)msg.player.userID || !canReassignToFriends)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tulong num = msg.read.UInt64();\n\t\tif (num == 0L || Interface.CallHook(\u0022CanAssignBed\u0022, msg.player, this, num) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ConVar.Server.max_sleeping_bags \u003E 0)\n\t\t{\n\t\t\tCanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, num);\n\t\t\tif (canAssignBedResult.HasValue)\n\t\t\t{\n\t\t\t\tBasePlayer basePlayer = RelationshipManager.FindByID(num);\n\t\t\t\tif (canAssignBedResult.Value.Result == BagResultType.TooManyBags)\n\t\t\t\t{\n\t\t\t\t\tif (basePlayer == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedNoPlayerPhrase, false);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstring playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);\n\t\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedPhrase, false, playerNameStreamSafe);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (canAssignBedResult.Value.Result == BagResultType.BagBlocked)\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, bedAssigningBlocked, false);\n\t\t\t\t}\n\t\t\t\telse if (canAssignBedResult.Value.Result == BagResultType.TargetIsPlayingTutorial)\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, tutorialPhrase, false);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbasePlayer?.ShowToast(GameTip.Styles.Blue_Long, assignedBagPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, (GetSleepingBagCount(msg.player.userID) - 1).ToString(), canAssignBedResult.Value.Max.ToString());\n\t\t\t\t}\n\t\t\t\tif (canAssignBedResult.Value.Result != 0)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tulong num2 = deployerUserID;\n\t\tdeployerUserID = num;\n\t\tNotifyPlayer(num2);\n\t\tNotifyPlayer(deployerUserID);\n\t\tOnBagChangedOwnership(this, num2);\n\t\tFacepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, num);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanUpdateSign(BasePlayer player, Signage signage)",
    "MethodSignature": "CanUpdateSign(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanUpdateSign(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUpdateSign\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player.IsAdmin || player.IsDeveloper)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (!player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsLocked())\n\t\t{\n\t\t\treturn (ulong)player.userID == base.OwnerID;\n\t\t}\n\t\tif (!HeldEntityCheck(player))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Signage",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCupboardDeauthorize(VehiclePrivilege vehiclePrivilege, BasePlayer rpcPlayer)",
    "MethodSignature": "RemoveSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void RemoveSelfAuthorize(RPCMessage rpc)\n\t{\n\t\tRPCMessage rpc2 = rpc;\n\t\tif (rpc2.player.CanInteract() \u0026\u0026 IsDriver(rpc2.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardDeauthorize\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.RemoveAll((PlayerNameID x) =\u003E x.userid == (ulong)rpc2.player.userID);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022removed\u0022, rpc2.player.userID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "VehiclePrivilege",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnHuntEventStart(EggHuntEvent eggHuntEvent)",
    "MethodSignature": "StartEvent()",
    "MethodSourseCode": "\n\tprivate void StartEvent()\n\t{\n\t\tif (Interface.CallHook(\u0022OnHuntEventStart\u0022, this) == null)\n\t\t{\n\t\t\tint count = BasePlayer.activePlayerList.Count;\n\t\t\tif (includeBots)\n\t\t\t{\n\t\t\t\tcount = GetCombinedPlayerList(wantBots: true).Count;\n\t\t\t}\n\t\t\tif (initialSpawnIndex \u003C= count)\n\t\t\t{\n\t\t\t\teggSpawningFrameBudget = float.PositiveInfinity;\n\t\t\t}\n\t\t\tEnableEggs();\n\t\t}\n\t}\n",
    "ClassName": "EggHuntEvent",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBoomboxToggle(BoomBox boomBox, BasePlayer msgPlayer, bool flag)",
    "MethodSignature": "ServerTogglePlay(BaseEntity.RPCMessage msg, bool bypassPower)",
    "MethodSourseCode": "\n\tpublic void ServerTogglePlay(BaseEntity.RPCMessage msg, bool bypassPower = false)\n\t{\n\t\tif (IsPowered() || bypassPower)\n\t\t{\n\t\t\tbool flag = msg.read.ReadByte() == 1;\n\t\t\tif (Interface.CallHook(\u0022OnBoomboxToggle\u0022, this, msg.player, flag) == null)\n\t\t\t{\n\t\t\t\tServerTogglePlay(flag);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BoomBox",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnFireworkDesignChange(PatternFirework patternFirework, ProtoBuf.PatternFirework.Design design, BasePlayer rpcPlayer)",
    "MethodSignature": "ServerSetFireworkDesign(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(5uL)]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tprivate void ServerSetFireworkDesign(RPCMessage rpc)\n\t{\n\t\tif (!PlayerCanModify(rpc.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tProtoBuf.PatternFirework.Design design = rpc.read.Proto\u003CProtoBuf.PatternFirework.Design\u003E();\n\t\tif (Interface.CallHook(\u0022OnFireworkDesignChange\u0022, this, design, rpc.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (design?.stars != null)\n\t\t{\n\t\t\twhile (design.stars.Count \u003E MaxStars)\n\t\t\t{\n\t\t\t\tint index = design.stars.Count - 1;\n\t\t\t\tdesign.stars[index].Dispose();\n\t\t\t\tdesign.stars.RemoveAt(index);\n\t\t\t}\n\t\t\tforeach (ProtoBuf.PatternFirework.Star star in design.stars)\n\t\t\t{\n\t\t\t\tstar.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));\n\t\t\t\tstar.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);\n\t\t\t}\n\t\t\tdesign.editedBy = rpc.player.userID;\n\t\t}\n\t\tDesign?.Dispose();\n\t\tDesign = design;\n\t\tInterface.CallHook(\u0022OnFireworkDesignChanged\u0022, this, design, rpc.player);\n\t\tSendNetworkUpdateImmediate();\n\t}\n",
    "ClassName": "PatternFirework",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnAdventGiftAwarded(AdventCalendar adventCalendar, BasePlayer player)",
    "MethodSignature": "AwardGift(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void AwardGift(BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnAdventGiftAward\u0022, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDateTime now = DateTime.Now;\n\t\tint num = ((overrideAdventCalendarDay \u003E 0) ? overrideAdventCalendarDay : now.Day) - startDay;\n\t\tif (((overrideAdventCalendarMonth \u003E 0) ? overrideAdventCalendarMonth : now.Month) != startMonth || num \u003C 0 || num \u003E= days.Length)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!playerRewardHistory.ContainsKey(player.userID))\n\t\t{\n\t\t\tplayerRewardHistory.Add(player.userID, new List\u003Cint\u003E());\n\t\t}\n\t\tplayerRewardHistory[player.userID].Add(num);\n\t\tEffect.server.Run(giftEffect.resourcePath, player.transform.position);\n\t\tif (num \u003E= 0 \u0026\u0026 num \u003C crosses.Length)\n\t\t{\n\t\t\tEffect.server.Run(boxCloseEffect.resourcePath, base.transform.position \u002B Vector3.up * 1.5f);\n\t\t}\n\t\tDayReward dayReward = days[num];\n\t\tItemAmount[] rewards = dayReward.rewards;\n\t\tif (ConVar.Server.Era != 0 \u0026\u0026 dayReward.alternativeRewards != null)\n\t\t{\n\t\t\tAlternativeReward[] alternativeRewards = dayReward.alternativeRewards;\n\t\t\tforeach (AlternativeReward alternativeReward in alternativeRewards)\n\t\t\t{\n\t\t\t\tif (alternativeReward.era == ConVar.Server.Era)\n\t\t\t\t{\n\t\t\t\t\trewards = alternativeReward.rewards;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tforeach (ItemAmount itemAmount in rewards)\n\t\t{\n\t\t\tif (itemAmount.itemDef.IsAllowed(EraRestriction.Loot))\n\t\t\t{\n\t\t\t\tplayer.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL).SetItemOwnership(player, ItemOwnershipPhrases.AdventCalendar), GiveItemReason.PickedUp);\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnAdventGiftAwarded\u0022, this, player);\n\t}\n",
    "ClassName": "AdventCalendar",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "OnFrankensteinPetWake(FrankensteinTable frankensteinTable, BasePlayer owner)",
    "MethodSignature": "WakeFrankenstein(BasePlayer owner)",
    "MethodSourseCode": "\n\tprivate void WakeFrankenstein(BasePlayer owner)\n\t{\n\t\tif (!(owner == null) \u0026\u0026 CanStartCreating(owner) \u0026\u0026 Interface.CallHook(\u0022OnFrankensteinPetWake\u0022, this, owner) == null)\n\t\t{\n\t\t\twaking = true;\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tStartCoroutine(DelayWakeFrankenstein(owner));\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022CL_WakeFrankenstein\u0022));\n\t\t}\n\t}\n",
    "ClassName": "FrankensteinTable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUseHelicopter(BasePlayer player, CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "AttemptMount(BasePlayer player, bool doMountChecks)",
    "MethodSourseCode": "\n\tpublic override void AttemptMount(BasePlayer player, bool doMountChecks = true)\n\t{\n\t\tif (Interface.CallHook(\u0022CanUseHelicopter\u0022, player, this) == null)\n\t\t{\n\t\t\tbase.AttemptMount(player, doMountChecks);\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUseLockedEntity(BasePlayer player, CodeLock codeLock)",
    "MethodSignature": "OnTryToOpen(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool OnTryToOpen(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseLockedEntity\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!IsLocked())\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))\n\t\t{\n\t\t\tDoEffect(effectUnlocked.resourcePath);\n\t\t\treturn true;\n\t\t}\n\t\tDoEffect(effectDenied.resourcePath);\n\t\treturn false;\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSwitchToggled(IndustrialConveyor industrialConveyor, BasePlayer msgPlayer)",
    "MethodSignature": "SvSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(2uL)]\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void SvSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tSetSwitch(!IsOn());\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "IndustrialConveyor",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "IOnLoseCondition(Item item, float amount)",
    "MethodSignature": "LoseCondition(float amount)",
    "MethodSourseCode": "\n\tpublic void LoseCondition(float amount)\n\t{\n\t\tif (hasCondition \u0026\u0026 !Debugging.disablecondition \u0026\u0026 Interface.CallHook(\u0022IOnLoseCondition\u0022, this, amount) == null)\n\t\t{\n\t\t\tfloat num = condition;\n\t\t\tcondition -= amount;\n\t\t\tif (ConVar.Global.developer \u003E 0)\n\t\t\t{\n\t\t\t\tDebug.Log(info.shortname \u002B \u0022 was damaged by: \u0022 \u002B amount \u002B \u0022cond is: \u0022 \u002B condition \u002B \u0022/\u0022 \u002B maxCondition);\n\t\t\t}\n\t\t\tif (condition \u003C= 0f \u0026\u0026 condition \u003C num)\n\t\t\t{\n\t\t\t\tOnBroken();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerRecover(BasePlayer basePlayer)",
    "MethodSignature": "RecoverFromWounded()",
    "MethodSourseCode": "\n\tpublic void RecoverFromWounded()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerRecover\u0022, this) == null)\n\t\t{\n\t\t\tif (IsCrawling())\n\t\t\t{\n\t\t\t\tbase.health = UnityEngine.Random.Range(2f, 6f) \u002B healingWhileCrawling;\n\t\t\t}\n\t\t\thealingWhileCrawling = 0f;\n\t\t\tSetPlayerFlag(PlayerFlags.Wounded, b: false);\n\t\t\tSetPlayerFlag(PlayerFlags.Incapacitated, b: false);\n\t\t\tif ((bool)BaseGameMode.GetActiveGameMode(base.isServer))\n\t\t\t{\n\t\t\t\tBaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPlayerRecovered\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, IndustrialCrafter industrialCrafter)",
    "MethodSignature": "PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)",
    "MethodSourseCode": "\n\tpublic virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = \u0022\u0022, bool doPositionChecks = true)\n\t{\n\t\tif (Interface.CallHook(\u0022CanLootEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (NeedsBuildingPrivilegeToUse \u0026\u0026 !player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (OnlyOneUser \u0026\u0026 IsOpen())\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022Already in use\u0022);\n\t\t\treturn false;\n\t\t}\n\t\tif (player.inventory.loot.StartLootingEntity(this, doPositionChecks))\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\tplayer.inventory.loot.AddContainer(_inventory);\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022RPC_OpenLootPanel\u0022, player), LootPanelName);\n\t\t\tSendNetworkUpdate();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "IndustrialCrafter",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRackedWeaponLoad(Item slot, ItemDefinition itemDefinition, BasePlayer player, WeaponRack weaponRack)",
    "MethodSignature": "LoadWeaponAmmo(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tprivate void LoadWeaponAmmo(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!player)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint gridIndex = msg.read.Int32();\n\t\tint num = msg.read.Int32();\n\t\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);\n\t\tif (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\n\t\tif (slot == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity heldEntity = slot.GetHeldEntity();\n\t\tif (heldEntity == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseProjectile component = heldEntity.GetComponent\u003CBaseProjectile\u003E();\n\t\tif (component == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);\n\t\tif (itemDefinition == null || Interface.CallHook(\u0022OnRackedWeaponLoad\u0022, slot, itemDefinition, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (itemDefinition == SnowballGun.SnowballInventoryItem)\n\t\t{\n\t\t\titemDefinition = SnowballGun.SnowballAmmoItem;\n\t\t\tif (!(itemDefinition != null))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnum = itemDefinition.itemid;\n\t\t}\n\t\tif (itemDefinition == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemModProjectile component2 = itemDefinition.GetComponent\u003CItemModProjectile\u003E();\n\t\tif (!(component2 == null) \u0026\u0026 component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))\n\t\t{\n\t\t\tif (num != component.primaryMagazine.ammoType.itemid \u0026\u0026 component.primaryMagazine.contents \u003E 0)\n\t\t\t{\n\t\t\t\tplayer.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));\n\t\t\t\tcomponent.SetAmmoCount(0);\n\t\t\t}\n\t\t\tcomponent.primaryMagazine.ammoType = itemDefinition;\n\t\t\tcomponent.TryReloadMagazine(player.inventory);\n\t\t\tSetSlotAmmoDetails(weaponAtIndex, slot);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tClientRPC(RpcTarget.Player(\u0022PlayAmmoSound\u0022, player), itemDefinition.itemid, 0);\n\t\t\tInterface.CallHook(\u0022OnRackedWeaponLoaded\u0022, slot, itemDefinition, player, this);\n\t\t}\n\t}\n",
    "ClassName": "WeaponRack",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnBigWheelLoss(BigWheelGame bigWheelGame, Item slot2, BigWheelBettingTerminal terminal)",
    "MethodSignature": "Payout()",
    "MethodSourseCode": "\n\tpublic void Payout()\n\t{\n\t\tHitNumber currentHitType = GetCurrentHitType();\n\t\tGuid value = Guid.NewGuid();\n\t\tforeach (BigWheelBettingTerminal terminal in terminals)\n\t\t{\n\t\t\tif (terminal.isClient)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool flag = false;\n\t\t\tbool flag2 = false;\n\t\t\tItem slot = terminal.inventory.GetSlot((int)currentHitType.hitType);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\n\t\t\t\tint amount = slot.amount;\n\t\t\t\tif (Interface.CallHook(\u0022OnBigWheelWin\u0022, this, slot, terminal, num) == null)\n\t\t\t\t{\n\t\t\t\t\tslot.amount \u002B= slot.amount * num;\n\t\t\t\t\tslot.RemoveFromContainer();\n\t\t\t\t\tslot.MoveToContainer(terminal.inventory, 5);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i \u003C 5; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tItem slot2 = terminal.inventory.GetSlot(i);\n\t\t\t\tif (slot2 != null \u0026\u0026 Interface.CallHook(\u0022OnBigWheelLoss\u0022, this, slot2, terminal) == null)\n\t\t\t\t{\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);\n\t\t\t\t\tslot2.Remove();\n\t\t\t\t\tflag2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag || flag2)\n\t\t\t{\n\t\t\t\tterminal.ClientRPC(RpcTarget.NetworkGroup(\u0022WinOrLoseSound\u0022), flag);\n\t\t\t}\n\t\t}\n\t\tItemManager.DoRemoves();\n\t\tSetTerminalsLocked(isLocked: false);\n\t}\n",
    "ClassName": "BigWheelGame",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnInventoryItemsTake(PlayerInventory playerInventory, System.Collections.Generic.List\u003CItem\u003E collect, int itemid, int amount)",
    "MethodSignature": "Take(List\u003CItem\u003E collect, int itemid, int amount)",
    "MethodSourseCode": "\n\tpublic int Take(List\u003CItem\u003E collect, int itemid, int amount)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnInventoryItemsTake\u0022, this, collect, itemid, amount);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tint num = 0;\n\t\tif (containerMain != null)\n\t\t{\n\t\t\tint num2 = containerMain.Take(collect, itemid, amount);\n\t\t\tnum \u002B= num2;\n\t\t\tamount -= num2;\n\t\t}\n\t\tif (amount \u003C= 0)\n\t\t{\n\t\t\treturn num;\n\t\t}\n\t\tif (containerBelt != null)\n\t\t{\n\t\t\tint num3 = containerBelt.Take(collect, itemid, amount);\n\t\t\tnum \u002B= num3;\n\t\t\tamount -= num3;\n\t\t}\n\t\tif (amount \u003C= 0)\n\t\t{\n\t\t\treturn num;\n\t\t}\n\t\tif (containerWear != null)\n\t\t{\n\t\t\tint num4 = containerWear.Take(collect, itemid, amount);\n\t\t\tnum \u002B= num4;\n\t\t\tamount -= num4;\n\t\t}\n\t\treturn num;\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemDropped(Item item, BaseEntity baseEntity)",
    "MethodSignature": "Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation)",
    "MethodSourseCode": "\n\tpublic BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))\n\t{\n\t\tulong droppedBy = GetRootContainer()?.playerOwner?.userID ?? ((EncryptedValue\u003Culong\u003E)0uL);\n\t\tRemoveFromWorld();\n\t\tif (info.AlignWorldModelOnDrop)\n\t\t{\n\t\t\trotation = Quaternion.Euler(0f, Quaternion.LookRotation(vVelocity.normalized, Vector3.up).eulerAngles.y, 0f);\n\t\t\trotation = Quaternion.Euler(info.WorldModelDropOffset) * rotation;\n\t\t}\n\t\tBaseEntity baseEntity = null;\n\t\tif (vPos != Vector3.zero \u0026\u0026 !info.HasFlag(ItemDefinition.Flag.NoDropping))\n\t\t{\n\t\t\tbaseEntity = CreateWorldObject(vPos, rotation);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.SetVelocity(vVelocity);\n\t\t\t}\n\t\t\tif (baseEntity is DroppedItem droppedItem)\n\t\t\t{\n\t\t\t\tdroppedItem.DroppedBy = droppedBy;\n\t\t\t\tif (info.AdjustCenterOfMassOnDrop)\n\t\t\t\t{\n\t\t\t\t\tdroppedItem.Rigidbody.centerOfMass = info.DropCenterOfMass;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tRemove();\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemDropped\u0022, this, baseEntity);\n\t\tRemoveFromContainer();\n\t\treturn baseEntity;\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnRfListenerRemoved(IRFObject obj, int frequency)",
    "MethodSignature": "RemoveListener(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void RemoveListener(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfListenerRemove\u0022, obj, frequency) == null \u0026\u0026 GetListenerSet(frequency).Remove(obj))\n\t\t{\n\t\t\tobj.RFSignalUpdate(on: false);\n\t\t\tInterface.CallHook(\u0022OnRfListenerRemoved\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnVendingTransaction(VendingMachine vendingMachine, BasePlayer buyer, int sellOrderId, int numberOfTransactions, ItemContainer targetContainer)",
    "MethodSignature": "DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions, ItemContainer targetContainer, Action\u003CBasePlayer, Item\u003E onCurrencyRemoved, Action\u003CBasePlayer, Item\u003E onItemPurchased, MarketTerminal droneMarketTerminal)",
    "MethodSourseCode": "\n\tpublic bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action\u003CBasePlayer, Item\u003E onCurrencyRemoved = null, Action\u003CBasePlayer, Item\u003E onItemPurchased = null, MarketTerminal droneMarketTerminal = null)\n\t{\n\t\tif (sellOrderId \u003C 0 || sellOrderId \u003E= sellOrders.sellOrders.Count)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (targetContainer == null \u0026\u0026 Vector3.Distance(buyer.transform.position, base.transform.position) \u003E 4f)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnVendingTransaction\u0022, this, buyer, sellOrderId, numberOfTransactions, targetContainer);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];\n\t\tList\u003CItem\u003E obj2 = Facepunch.Pool.Get\u003CList\u003CItem\u003E\u003E();\n\t\tGetItemsToSell(sellOrder, obj2);\n\t\tif (obj2 == null || obj2.Count == 0)\n\t\t{\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tnumberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);\n\t\tint num = sellOrder.itemToSellAmount * numberOfTransactions;\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellOrder.itemToSellID);\n\t\tItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(sellOrder.currencyID);\n\t\tif (!itemDefinition.IsAllowed(CurrentEraRestriction) || !itemDefinition2.IsAllowed(CurrentEraRestriction))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (itemDefinition == NPCVendingMachine.ScrapItem \u0026\u0026 sellOrder.receivedQuantityMultiplier != 1f)\n\t\t{\n\t\t\tnum = GetTotalReceivedMerchandiseForOrder(sellOrder.itemToSellAmount, sellOrder.receivedQuantityMultiplier) * numberOfTransactions;\n\t\t}\n\t\tint num2 = obj2.Sum((Item x) =\u003E x.amount);\n\t\tif (num \u003E num2)\n\t\t{\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tint num3 = 0;\n\t\tusing PooledList\u003CItem\u003E pooledList2 = Facepunch.Pool.Get\u003CPooledList\u003CItem\u003E\u003E();\n\t\tusing (PooledList\u003CItem\u003E pooledList = Facepunch.Pool.Get\u003CPooledList\u003CItem\u003E\u003E())\n\t\t{\n\t\t\tbuyer.inventory.FindItemsByItemID(pooledList, sellOrder.currencyIsBP ? blueprintBaseDef.itemid : sellOrder.currencyID);\n\t\t\tfor (int i = 0; i \u003C pooledList.Count; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tItem item = pooledList[i];\n\t\t\t\tif ((!sellOrder.currencyIsBP || item.blueprintTarget == sellOrder.currencyID) \u0026\u0026 (!item.hasCondition || (item.conditionNormalized \u003E= 0.5f \u0026\u0026 item.maxConditionNormalized \u003E 0.5f)) \u0026\u0026 item.GetItemVolume() \u003C= maxCurrencyVolume)\n\t\t\t\t{\n\t\t\t\t\tpooledList2.Add(item);\n\t\t\t\t\tnum3 \u002B= item.amount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pooledList2.Count == 0)\n\t\t{\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tint num4 = GetTotalPriceForOrder(sellOrder) * numberOfTransactions;\n\t\tif (num3 \u003C num4)\n\t\t{\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\ttransactionActive = true;\n\t\tint num5 = 0;\n\t\tfor (int j = 0; j \u003C pooledList2.Count; j\u002B\u002B)\n\t\t{\n\t\t\tItem item2 = pooledList2[j];\n\t\t\tint num6 = Mathf.Min(num4 - num5, item2.amount);\n\t\t\tItem item3 = ((item2.amount \u003E num6) ? item2.SplitItem(num6) : item2);\n\t\t\tTakeCurrencyItem(item3);\n\t\t\tonCurrencyRemoved?.Invoke(buyer, item3);\n\t\t\tnum5 \u002B= num6;\n\t\t\tif (num5 \u003E= num4)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint num7 = 0;\n\t\tforeach (Item item5 in obj2)\n\t\t{\n\t\t\tint num8 = num - num7;\n\t\t\tItem item4 = ((item5.amount \u003E num8) ? item5.SplitItem(num8) : item5);\n\t\t\tif (item4 == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022Vending machine error, contact developers!\u0022);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum7 \u002B= item4.amount;\n\t\t\t\tobject obj3 = Interface.CallHook(\u0022CanPurchaseItem\u0022, buyer, item4, onItemPurchased, this, targetContainer);\n\t\t\t\tif (obj3 != null)\n\t\t\t\t{\n\t\t\t\t\tif (!(obj3 is bool))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn (bool)obj3;\n\t\t\t\t}\n\t\t\t\tRecordSaleAnalytics(item4, sellOrderId, sellOrder.currencyAmountPerItem);\n\t\t\t\tif (targetContainer == null)\n\t\t\t\t{\n\t\t\t\t\tGiveSoldItem(item4, buyer);\n\t\t\t\t}\n\t\t\t\telse if (!item4.MoveToContainer(targetContainer))\n\t\t\t\t{\n\t\t\t\t\titem4.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);\n\t\t\t\t}\n\t\t\t\tif (ShouldRecordStats)\n\t\t\t\t{\n\t\t\t\t\tRegisterCustomer(buyer.userID);\n\t\t\t\t}\n\t\t\t\tonItemPurchased?.Invoke(buyer, item4);\n\t\t\t}\n\t\t\tif (num7 \u003E= num)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFacepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, num, sellOrder.itemToSellIsBP, sellOrder.currencyID, num5, sellOrder.currencyIsBP, numberOfTransactions, sellOrder.priceMultiplier, droneMarketTerminal);\n\t\tif (ShouldRecordStats)\n\t\t{\n\t\t\tAddPurchaseHistory(sellOrder.itemToSellID, num, sellOrder.currencyID, num5, sellOrder.itemToSellIsBP, sellOrder.currencyIsBP);\n\t\t}\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\tUpdateEmptyFlag();\n\t\ttransactionActive = false;\n\t\treturn true;\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPlayerAttack(BasePlayer basePlayer, HitInfo hitInfo)",
    "MethodSignature": "OnProjectileAttack(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner(false)]\n\tpublic void OnProjectileAttack(RPCMessage msg)\n\t{\n\t\tusing PlayerProjectileAttack playerProjectileAttack = msg.read.Proto\u003CPlayerProjectileAttack\u003E();\n\t\tif (playerProjectileAttack == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPlayerAttack playerAttack = playerProjectileAttack.playerAttack;\n\t\tHitInfo hitInfo = new HitInfo();\n\t\thitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);\n\t\thitInfo.Initiator = this;\n\t\thitInfo.ProjectileID = playerAttack.projectileID;\n\t\thitInfo.ProjectileDistance = playerProjectileAttack.hitDistance;\n\t\thitInfo.ProjectileVelocity = playerProjectileAttack.hitVelocity;\n\t\thitInfo.ProjectileTravelTime = playerProjectileAttack.travelTime;\n\t\thitInfo.Predicted = msg.connection;\n\t\tif (hitInfo.IsNaNOrInfinity() || float.IsNaN(playerProjectileAttack.travelTime) || float.IsInfinity(playerProjectileAttack.travelTime))\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Contains NaN (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_nan\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!firedProjectiles.TryGetValue(playerAttack.projectileID, out var value))\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Missing ID (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022, logToAnalytics: false);\n\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_invalid\u0022);\n\t\t\treturn;\n\t\t}\n\t\thitInfo.ProjectileHits = value.hits;\n\t\thitInfo.ProjectileIntegrity = value.integrity;\n\t\thitInfo.ProjectileTrajectoryMismatch = value.trajectoryMismatch;\n\t\tif (value.integrity \u003C= 0f)\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Integrity is zero (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_integrity\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (value.firedTime \u003C UnityEngine.Time.realtimeSinceStartup - 8f)\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Lifetime is zero (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_lifetime\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (value.ricochets \u003E 0)\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile is ricochet (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_ricochet\u0022);\n\t\t\treturn;\n\t\t}\n\t\thitInfo.Weapon = value.weaponSource;\n\t\thitInfo.WeaponPrefab = value.weaponPrefab;\n\t\thitInfo.ProjectilePrefab = value.projectilePrefab;\n\t\thitInfo.damageProperties = value.projectilePrefab.damageProperties;\n\t\tVector3 position = value.position;\n\t\tVector3 initialPositionOffset = value.initialPositionOffset;\n\t\tVector3 positionOffset = value.positionOffset;\n\t\tVector3 velocity = value.velocity;\n\t\tfloat partialTime = value.partialTime;\n\t\tfloat travelTime = value.travelTime;\n\t\tfloat num = Mathf.Clamp(playerProjectileAttack.travelTime, value.travelTime, 8f);\n\t\tVector3 gravity = UnityEngine.Physics.gravity * value.projectilePrefab.gravityModifier;\n\t\tfloat drag = value.projectilePrefab.drag;\n\t\tBaseEntity hitEntity = hitInfo.HitEntity;\n\t\tBasePlayer basePlayer = hitEntity as BasePlayer;\n\t\tbool flag = basePlayer != null;\n\t\tbool flag2 = flag \u0026\u0026 basePlayer.IsSleeping();\n\t\tbool flag3 = flag \u0026\u0026 basePlayer.IsWounded();\n\t\tbool flag4 = flag \u0026\u0026 basePlayer.isMounted;\n\t\tbool flag5 = flag \u0026\u0026 basePlayer.HasParent();\n\t\tbool flag6 = hitEntity != null;\n\t\tbool flag7 = flag6 \u0026\u0026 hitEntity.IsNpc;\n\t\tbool flag8 = hitInfo.HitMaterial == Projectile.WaterMaterialID();\n\t\tbool flag9;\n\t\tint num15;\n\t\tVector3 position2;\n\t\tVector3 pointStart;\n\t\tVector3 hitPositionWorld;\n\t\tVector3 vector;\n\t\tbool flag10;\n\t\tint num32;\n\t\tif (value.protection \u003E 0)\n\t\t{\n\t\t\tflag9 = true;\n\t\t\tfloat num2 = 1f \u002B ConVar.AntiHack.projectile_forgiveness;\n\t\t\tfloat num3 = 1f - ConVar.AntiHack.projectile_forgiveness;\n\t\t\tfloat projectile_clientframes = ConVar.AntiHack.projectile_clientframes;\n\t\t\tfloat projectile_serverframes = ConVar.AntiHack.projectile_serverframes;\n\t\t\tfloat num4 = Mathx.Decrement(value.firedTime);\n\t\t\tfloat num5 = Mathf.Clamp(Mathx.Increment(UnityEngine.Time.realtimeSinceStartup) - num4, 0f, 8f);\n\t\t\tfloat num6 = num;\n\t\t\tfloat num7 = (value.desyncLifeTime = Mathf.Abs(num5 - num6));\n\t\t\tfloat num8 = Mathf.Min(num5, num6);\n\t\t\tfloat num9 = projectile_clientframes / 60f;\n\t\t\tfloat num10 = projectile_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);\n\t\t\tfloat num11 = (desyncTimeClamped \u002B num8 \u002B num9 \u002B num10) * num2;\n\t\t\tfloat num12 = ((value.protection \u003E= 6) ? ((desyncTimeClamped \u002B num9 \u002B num10) * num2) : num11);\n\t\t\tfloat num13 = (num5 - desyncTimeClamped - num9 - num10) * num3;\n\t\t\tfloat num14 = Vector3.Distance(value.initialPosition, hitInfo.HitPositionWorld);\n\t\t\tnum15 = 1075904512;\n\t\t\tif (ConVar.AntiHack.projectile_terraincheck)\n\t\t\t{\n\t\t\t\tnum15 |= 0x800000;\n\t\t\t}\n\t\t\tif (ConVar.AntiHack.projectile_vehiclecheck)\n\t\t\t{\n\t\t\t\tnum15 |= 0x8000000;\n\t\t\t}\n\t\t\tif (flag6 \u0026\u0026 net.group != null \u0026\u0026 hitEntity.net != null \u0026\u0026 hitEntity.net.group != null \u0026\u0026 !net.subscriber.IsSubscribed(hitEntity.net.group))\n\t\t\t{\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Entity out of network range\u0022);\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_network_range\u0022);\n\t\t\t\tflag9 = false;\n\t\t\t}\n\t\t\tif (flag \u0026\u0026 hitInfo.boneArea == (HitArea)(-1))\n\t\t\t{\n\t\t\t\tstring text = hitInfo.ProjectilePrefab.name;\n\t\t\t\tstring text2 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Bone is invalid (\u0022 \u002B text \u002B \u0022 on \u0022 \u002B text2 \u002B \u0022 bone \u0022 \u002B hitInfo.HitBone \u002B \u0022)\u0022);\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_bone\u0022);\n\t\t\t\tflag9 = false;\n\t\t\t}\n\t\t\tif (flag8)\n\t\t\t{\n\t\t\t\tif (flag6)\n\t\t\t\t{\n\t\t\t\t\tstring text3 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text4 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile water hit on entity (\u0022 \u002B text3 \u002B \u0022 on \u0022 \u002B text4 \u002B \u0022)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022water_entity\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t\tif (!WaterLevel.Test(hitInfo.HitPositionWorld - 0.5f * Vector3.up, waves: true, volumes: true, this))\n\t\t\t\t{\n\t\t\t\t\tstring text5 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text6 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile water level (\u0022 \u002B text5 \u002B \u0022 on \u0022 \u002B text6 \u002B \u0022)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022water_level\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value.protection \u003E= 2)\n\t\t\t{\n\t\t\t\tif (flag6 || (value.protection \u003C 6 \u0026\u0026 flag))\n\t\t\t\t{\n\t\t\t\t\tfloat num16 = hitEntity.MaxVelocity() \u002B hitEntity.GetParentVelocity().magnitude;\n\t\t\t\t\tfloat num17 = hitEntity.BoundsPadding() \u002B num12 * num16;\n\t\t\t\t\tfloat num18 = (value.entityDistance = hitEntity.Distance(hitInfo.HitPositionWorld));\n\t\t\t\t\tif (num18 \u003E num17)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text7 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\t\tstring shortPrefabName = hitEntity.ShortPrefabName;\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Entity too far away (\u0022 \u002B text7 \u002B \u0022 on \u0022 \u002B shortPrefabName \u002B \u0022 with \u0022 \u002B num18 \u002B \u0022m \u003E \u0022 \u002B num17 \u002B \u0022m in \u0022 \u002B num12 \u002B \u0022s)\u0022);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022entity_distance\u0022);\n\t\t\t\t\t\tflag9 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value.protection \u003E= 6 \u0026\u0026 flag9 \u0026\u0026 flag \u0026\u0026 !flag7 \u0026\u0026 !flag2 \u0026\u0026 !flag3 \u0026\u0026 !flag4 \u0026\u0026 !flag5)\n\t\t\t\t{\n\t\t\t\t\tfloat magnitude = basePlayer.GetParentVelocity().magnitude;\n\t\t\t\t\tfloat num19 = basePlayer.BoundsPadding() \u002B num12 * magnitude \u002B ConVar.AntiHack.tickhistoryforgiveness;\n\t\t\t\t\tfloat num20 = (value.entityDistance = basePlayer.tickHistory.Distance(basePlayer, hitInfo.HitPositionWorld));\n\t\t\t\t\tif (num20 \u003E num19)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text8 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\t\tstring shortPrefabName2 = basePlayer.ShortPrefabName;\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Player too far away (\u0022 \u002B text8 \u002B \u0022 on \u0022 \u002B shortPrefabName2 \u002B \u0022 with \u0022 \u002B num20 \u002B \u0022m \u003E \u0022 \u002B num19 \u002B \u0022m in \u0022 \u002B num12 \u002B \u0022s)\u0022);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022player_distance\u0022);\n\t\t\t\t\t\tflag9 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value.protection \u003E= 1)\n\t\t\t{\n\t\t\t\tfloat num21 = (flag6 ? (hitEntity.MaxVelocity() \u002B hitEntity.GetParentVelocity().magnitude) : 0f);\n\t\t\t\tfloat num22 = (flag6 ? (num12 * num21) : 0f);\n\t\t\t\tfloat magnitude2 = value.initialVelocity.magnitude;\n\t\t\t\tfloat num23 = hitInfo.ProjectilePrefab.initialDistance \u002B num11 * magnitude2;\n\t\t\t\tfloat num24 = hitInfo.ProjectileDistance \u002B 1f \u002B positionOffset.magnitude \u002B num22 \u002B estimatedVelocity.magnitude;\n\t\t\t\tif (num14 \u003E num23)\n\t\t\t\t{\n\t\t\t\t\tstring text9 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text10 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile too fast (\u0022 \u002B text9 \u002B \u0022 on \u0022 \u002B text10 \u002B \u0022 with \u0022 \u002B num14 \u002B \u0022m \u003E \u0022 \u002B num23 \u002B \u0022m in \u0022 \u002B num11 \u002B \u0022s)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_maxspeed\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t\tif (num14 \u003E num24)\n\t\t\t\t{\n\t\t\t\t\tstring text11 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text12 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile too far away (\u0022 \u002B text11 \u002B \u0022 on \u0022 \u002B text12 \u002B \u0022 with \u0022 \u002B num14 \u002B \u0022m \u003E \u0022 \u002B num24 \u002B \u0022m in \u0022 \u002B num11 \u002B \u0022s)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_distance\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t\tif (num7 \u003E ConVar.AntiHack.projectile_desync)\n\t\t\t\t{\n\t\t\t\t\tstring text13 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text14 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile desync (\u0022 \u002B text13 \u002B \u0022 on \u0022 \u002B text14 \u002B \u0022 with \u0022 \u002B num7 \u002B \u0022s \u003E \u0022 \u002B ConVar.AntiHack.projectile_desync \u002B \u0022s)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_desync\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value.protection \u003E= 4)\n\t\t\t{\n\t\t\t\tfloat num25 = 0f;\n\t\t\t\tif (flag6)\n\t\t\t\t{\n\t\t\t\t\tfloat num26 = hitEntity.GetParentVelocity().magnitude;\n\t\t\t\t\tif (hitEntity is CargoShip || hitEntity is Tugboat)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum26 \u002B= hitEntity.MaxVelocity();\n\t\t\t\t\t}\n\t\t\t\t\tnum25 = num12 * num26;\n\t\t\t\t}\n\t\t\t\tSimulateProjectile(ref position, ref velocity, ref partialTime, num - travelTime, gravity, drag, out var prevPosition, out var prevVelocity);\n\t\t\t\tLine line = new Line(prevPosition - prevVelocity, position \u002B prevVelocity);\n\t\t\t\tfloat num27 = (value.startPointMismatch = Mathf.Max(line.Distance(hitInfo.PointStart) - initialPositionOffset.magnitude - num25, 0f));\n\t\t\t\tfloat num28 = (value.endPointMismatch = Mathf.Max(line.Distance(hitInfo.HitPositionWorld) - initialPositionOffset.magnitude - num25, 0f));\n\t\t\t\tif (num27 \u003E ConVar.AntiHack.projectile_trajectory)\n\t\t\t\t{\n\t\t\t\t\tstring text15 = value.projectilePrefab.name;\n\t\t\t\t\tstring text16 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Start position trajectory (\u0022 \u002B text15 \u002B \u0022 on \u0022 \u002B text16 \u002B \u0022 with \u0022 \u002B num27 \u002B \u0022m \u003E \u0022 \u002B ConVar.AntiHack.projectile_trajectory \u002B \u0022m)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022trajectory_start\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t\tif (num28 \u003E ConVar.AntiHack.projectile_trajectory)\n\t\t\t\t{\n\t\t\t\t\tstring text17 = value.projectilePrefab.name;\n\t\t\t\t\tstring text18 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022End position trajectory (\u0022 \u002B text17 \u002B \u0022 on \u0022 \u002B text18 \u002B \u0022 with \u0022 \u002B num28 \u002B \u0022m \u003E \u0022 \u002B ConVar.AntiHack.projectile_trajectory \u002B \u0022m)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022trajectory_end\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t\tif (hitInfo.ProjectileTrajectoryMismatch \u003E ConVar.AntiHack.projectile_trajectory_update)\n\t\t\t\t{\n\t\t\t\t\tstring text19 = value.projectilePrefab.name;\n\t\t\t\t\tstring text20 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Update position trajectory (\u0022 \u002B text19 \u002B \u0022 on \u0022 \u002B text20 \u002B \u0022 with \u0022 \u002B hitInfo.ProjectileTrajectoryMismatch \u002B \u0022m \u003E \u0022 \u002B ConVar.AntiHack.projectile_trajectory_update \u002B \u0022m)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022trajectory_update_total\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t\thitInfo.ProjectileVelocity = velocity;\n\t\t\t\tif (playerProjectileAttack.hitVelocity != Vector3.zero \u0026\u0026 velocity != Vector3.zero)\n\t\t\t\t{\n\t\t\t\t\tfloat num29 = Vector3.Angle(playerProjectileAttack.hitVelocity, velocity);\n\t\t\t\t\tfloat num30 = playerProjectileAttack.hitVelocity.magnitude / velocity.magnitude;\n\t\t\t\t\tif (num29 \u003E ConVar.AntiHack.projectile_anglechange)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text21 = value.projectilePrefab.name;\n\t\t\t\t\t\tstring text22 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Trajectory angle change (\u0022 \u002B text21 \u002B \u0022 on \u0022 \u002B text22 \u002B \u0022 with \u0022 \u002B num29 \u002B \u0022deg \u003E \u0022 \u002B ConVar.AntiHack.projectile_anglechange \u002B \u0022deg)\u0022);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022angle_change\u0022);\n\t\t\t\t\t\tflag9 = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (num30 \u003E ConVar.AntiHack.projectile_velocitychange)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text23 = value.projectilePrefab.name;\n\t\t\t\t\t\tstring text24 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Trajectory velocity change (\u0022 \u002B text23 \u002B \u0022 on \u0022 \u002B text24 \u002B \u0022 with \u0022 \u002B num30 \u002B \u0022 \u003E \u0022 \u002B ConVar.AntiHack.projectile_velocitychange \u002B \u0022)\u0022);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022velocity_change\u0022);\n\t\t\t\t\t\tflag9 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfloat magnitude3 = velocity.magnitude;\n\t\t\t\tfloat num31 = num13 * magnitude3;\n\t\t\t\tif (num14 \u003C num31)\n\t\t\t\t{\n\t\t\t\t\tstring text25 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text26 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile too slow (\u0022 \u002B text25 \u002B \u0022 on \u0022 \u002B text26 \u002B \u0022 with \u0022 \u002B num14 \u002B \u0022m \u003C \u0022 \u002B num31 \u002B \u0022m in \u0022 \u002B num13 \u002B \u0022s)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_minspeed\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value.protection \u003E= 3)\n\t\t\t{\n\t\t\t\tposition2 = value.position;\n\t\t\t\tpointStart = hitInfo.PointStart;\n\t\t\t\thitPositionWorld = hitInfo.HitPositionWorld;\n\t\t\t\tif (!flag8)\n\t\t\t\t{\n\t\t\t\t\thitPositionWorld -= hitInfo.ProjectileVelocity.normalized * 0.001f;\n\t\t\t\t}\n\t\t\t\tvector = hitInfo.PositionOnRay(hitPositionWorld);\n\t\t\t\tVector3 vector2 = Vector3.zero;\n\t\t\t\tVector3 vector3 = Vector3.zero;\n\t\t\t\tif (ConVar.AntiHack.projectile_backtracking \u003E 0f)\n\t\t\t\t{\n\t\t\t\t\tvector2 = (pointStart - position2).normalized * ConVar.AntiHack.projectile_backtracking;\n\t\t\t\t\tvector3 = (vector - pointStart).normalized * ConVar.AntiHack.projectile_backtracking;\n\t\t\t\t}\n\t\t\t\tflag10 = GamePhysics.LineOfSight(position2 - vector2, pointStart \u002B vector2, num15, value.lastEntityHit) \u0026\u0026 GamePhysics.LineOfSight(pointStart - vector3, vector, num15, value.lastEntityHit) \u0026\u0026 GamePhysics.LineOfSight(vector, hitPositionWorld, num15, value.lastEntityHit);\n\t\t\t\tbool flag11 = true;\n\t\t\t\tif (flag10)\n\t\t\t\t{\n\t\t\t\t\tflag11 = GamePhysics.LineOfSight(position2, hitPositionWorld, num15, value.lastEntityHit) \u0026\u0026 GamePhysics.LineOfSight(hitPositionWorld, position2, num15, value.lastEntityHit);\n\t\t\t\t}\n\t\t\t\tbool flag12 = true;\n\t\t\t\tif (flag10)\n\t\t\t\t{\n\t\t\t\t\tList\u003CVector3\u003E simulatedPositions = value.simulatedPositions;\n\t\t\t\t\tif (simulatedPositions.Count \u003E ConVar.AntiHack.projectile_update_limit)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag12 = false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsimulatedPositions.Add(position2);\n\t\t\t\t\t\tfor (int i = 1; i \u003C simulatedPositions.Count; i\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!GamePhysics.LineOfSight(simulatedPositions[i - 1], simulatedPositions[i], num15, value.lastEntityHit) || !GamePhysics.LineOfSight(simulatedPositions[i], simulatedPositions[i - 1], num15, value.lastEntityHit))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflag12 = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag10)\n\t\t\t\t{\n\t\t\t\t\tif (!(value.simulatedPositions.Count \u003E 1 \u0026\u0026 flag12))\n\t\t\t\t\t{\n\t\t\t\t\t\tnum32 = ((value.simulatedPositions.Count \u003C= 1 \u0026\u0026 flag11) ? 1 : 0);\n\t\t\t\t\t\tif (num32 == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgoto IL_12b6;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnum32 = 1;\n\t\t\t\t\t}\n\t\t\t\t\tstats.Add(\u0022hit_\u0022 \u002B (flag6 ? hitEntity.Categorize() : \u0022world\u0022) \u002B \u0022_direct_los\u0022, 1, Stats.Server);\n\t\t\t\t\tgoto IL_1314;\n\t\t\t\t}\n\t\t\t\tnum32 = 0;\n\t\t\t\tgoto IL_12b6;\n\t\t\t}\n\t\t\tgoto IL_1586;\n\t\t}\n\t\tgoto IL_159c;\n\t\tIL_159c:\n\t\tvalue.position = hitInfo.HitPositionWorld;\n\t\tvalue.velocity = playerProjectileAttack.hitVelocity;\n\t\tvalue.travelTime = num;\n\t\tvalue.partialTime = partialTime;\n\t\tvalue.hits\u002B\u002B;\n\t\tvalue.lastEntityHit = hitEntity;\n\t\tvalue.simulatedPositions.Clear();\n\t\tvalue.simulatedPositions.Add(position);\n\t\thitInfo.ProjectilePrefab.CalculateDamage(hitInfo, value.projectileModifier, value.integrity);\n\t\tif (flag8)\n\t\t{\n\t\t\tif (hitInfo.ProjectilePrefab.waterIntegrityLoss \u003E 0f)\n\t\t\t{\n\t\t\t\tvalue.integrity = Mathf.Clamp01(value.integrity - hitInfo.ProjectilePrefab.waterIntegrityLoss);\n\t\t\t}\n\t\t}\n\t\telse if (hitInfo.ProjectilePrefab.penetrationPower \u003C= 0f || !flag6)\n\t\t{\n\t\t\tvalue.integrity = 0f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat num33 = hitEntity.PenetrationResistance(hitInfo) / hitInfo.ProjectilePrefab.penetrationPower;\n\t\t\tvalue.integrity = Mathf.Clamp01(value.integrity - num33);\n\t\t}\n\t\tif (flag6)\n\t\t{\n\t\t\tstats.Add(value.itemMod.category \u002B \u0022_hit_\u0022 \u002B hitEntity.Categorize(), 1);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerAttack\u0022, this, hitInfo) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (value.integrity \u003C= 0f)\n\t\t{\n\t\t\tif (hitInfo.ProjectilePrefab.remainInWorld)\n\t\t\t{\n\t\t\t\tCreateWorldProjectile(hitInfo, value.itemDef, value.itemMod, hitInfo.ProjectilePrefab, value.pickupItem);\n\t\t\t}\n\t\t\tif (value.hits \u003C= ConVar.AntiHack.projectile_impactspawndepth)\n\t\t\t{\n\t\t\t\tvalue.itemMod.ServerProjectileHit(hitInfo);\n\t\t\t}\n\t\t}\n\t\telse if (value.hits == ConVar.AntiHack.projectile_impactspawndepth)\n\t\t{\n\t\t\tvalue.itemMod.ServerProjectileHit(hitInfo);\n\t\t}\n\t\tfiredProjectiles[playerAttack.projectileID] = value;\n\t\tif (flag6)\n\t\t{\n\t\t\tif (value.hits \u003C= ConVar.AntiHack.projectile_damagedepth)\n\t\t\t{\n\t\t\t\thitEntity.OnAttacked(hitInfo);\n\t\t\t\tvalue.itemMod.ServerProjectileHitEntity(hitInfo);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022ricochet\u0022);\n\t\t\t}\n\t\t}\n\t\tProjectile.CustomEffectData clientEffectData = value.projectilePrefab.clientEffectData;\n\t\tbool playDefaultHitEffects = value.projectilePrefab.playDefaultHitEffects;\n\t\tGameObjectRef clientEffectPrefab = value.projectilePrefab.clientEffectPrefab;\n\t\tif (!clientEffectData.UseCustomEffect || playDefaultHitEffects)\n\t\t{\n\t\t\tEffect.server.ImpactEffect(hitInfo);\n\t\t}\n\t\tif (clientEffectData.UseCustomEffect)\n\t\t{\n\t\t\tstring text27 = null;\n\t\t\tif (clientEffectPrefab != null \u0026\u0026 clientEffectPrefab.isValid)\n\t\t\t{\n\t\t\t\ttext27 = clientEffectPrefab.resourcePath;\n\t\t\t}\n\t\t\tif (text27 != null)\n\t\t\t{\n\t\t\t\tEffect.server.ImpactEffect(hitInfo, text27);\n\t\t\t}\n\t\t}\n\t\thitInfo.DoHitEffects = hitInfo.ProjectilePrefab.doDefaultHitEffects;\n\t\tSingletonComponent\u003CNpcNoiseManager\u003E.Instance.OnProjectileHit(this, hitInfo);\n\t\treturn;\n\t\tIL_12b6:\n\t\tstats.Add(\u0022hit_\u0022 \u002B (flag6 ? hitEntity.Categorize() : \u0022world\u0022) \u002B \u0022_indirect_los\u0022, 1, Stats.Server);\n\t\tgoto IL_1314;\n\t\tIL_1314:\n\t\tif (num32 == 0)\n\t\t{\n\t\t\tstring text28 = hitInfo.ProjectilePrefab.name;\n\t\t\tstring text29 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\tstring description = ((!flag10) ? \u0022projectile_los\u0022 : \u0022projectile_los_detailed\u0022);\n\t\t\tstring[] obj = new string[12]\n\t\t\t{\n\t\t\t\t\u0022Line of sight (\u0022, text28, \u0022 on \u0022, text29, \u0022) \u0022, null, null, null, null, null,\n\t\t\t\tnull, null\n\t\t\t};\n\t\t\tVector3 vector4 = position2;\n\t\t\tobj[5] = vector4.ToString();\n\t\t\tobj[6] = \u0022 \u0022;\n\t\t\tvector4 = pointStart;\n\t\t\tobj[7] = vector4.ToString();\n\t\t\tobj[8] = \u0022 \u0022;\n\t\t\tvector4 = vector;\n\t\t\tobj[9] = vector4.ToString();\n\t\t\tobj[10] = \u0022 \u0022;\n\t\t\tvector4 = hitPositionWorld;\n\t\t\tobj[11] = vector4.ToString();\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat(obj));\n\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\tstats.combat.LogInvalid(hitInfo, description);\n\t\t\tflag9 = false;\n\t\t}\n\t\tif (flag9 \u0026\u0026 flag \u0026\u0026 !flag7)\n\t\t{\n\t\t\tVector3 hitPositionWorld2 = hitInfo.HitPositionWorld;\n\t\t\tVector3 position3 = basePlayer.eyes.position;\n\t\t\tVector3 vector5 = basePlayer.CenterPoint();\n\t\t\tfloat projectile_losforgiveness = ConVar.AntiHack.projectile_losforgiveness;\n\t\t\tbool flag13 = GamePhysics.LineOfSight(hitPositionWorld2, position3, num15, 0f, projectile_losforgiveness) \u0026\u0026 GamePhysics.LineOfSight(position3, hitPositionWorld2, num15, projectile_losforgiveness, 0f);\n\t\t\tif (!flag13)\n\t\t\t{\n\t\t\t\tflag13 = GamePhysics.LineOfSight(hitPositionWorld2, vector5, num15, 0f, projectile_losforgiveness) \u0026\u0026 GamePhysics.LineOfSight(vector5, hitPositionWorld2, num15, projectile_losforgiveness, 0f);\n\t\t\t}\n\t\t\tif (!flag13)\n\t\t\t{\n\t\t\t\tstring text30 = hitInfo.ProjectilePrefab.name;\n\t\t\t\tstring text31 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\tstring[] obj2 = new string[12]\n\t\t\t\t{\n\t\t\t\t\t\u0022Line of sight (\u0022, text30, \u0022 on \u0022, text31, \u0022) \u0022, null, null, null, null, null,\n\t\t\t\t\tnull, null\n\t\t\t\t};\n\t\t\t\tVector3 vector4 = hitPositionWorld2;\n\t\t\t\tobj2[5] = vector4.ToString();\n\t\t\t\tobj2[6] = \u0022 \u0022;\n\t\t\t\tvector4 = position3;\n\t\t\t\tobj2[7] = vector4.ToString();\n\t\t\t\tobj2[8] = \u0022 or \u0022;\n\t\t\t\tvector4 = hitPositionWorld2;\n\t\t\t\tobj2[9] = vector4.ToString();\n\t\t\t\tobj2[10] = \u0022 \u0022;\n\t\t\t\tvector4 = vector5;\n\t\t\t\tobj2[11] = vector4.ToString();\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat(obj2));\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_los\u0022);\n\t\t\t\tflag9 = false;\n\t\t\t}\n\t\t}\n\t\tgoto IL_1586;\n\t\tIL_1586:\n\t\tif (!flag9)\n\t\t{\n\t\t\tAntiHack.AddViolation(this, AntiHackType.ProjectileHack, ConVar.AntiHack.projectile_penalty);\n\t\t\treturn;\n\t\t}\n\t\tgoto IL_159c;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 392
  },
  {
    "HookSignature": "OnTerrainCreate(TerrainGenerator terrainGenerator)",
    "MethodSignature": "CreateTerrain(int heightmapResolution, int alphamapResolution)",
    "MethodSourseCode": "\n\tpublic GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)\n\t{\n\t\tInterface.CallHook(\u0022OnTerrainCreate\u0022, this);\n\t\tTerrain component = Terrain.CreateTerrainGameObject(new TerrainData\n\t\t{\n\t\t\tbaseMapResolution = GetBaseMapRes(),\n\t\t\theightmapResolution = heightmapResolution,\n\t\t\talphamapResolution = alphamapResolution,\n\t\t\tsize = new Vector3(World.Size, 1000f, World.Size)\n\t\t}).GetComponent\u003CTerrain\u003E();\n\t\tcomponent.transform.position = base.transform.position \u002B new Vector3((float)(0L - (long)World.Size) * 0.5f, 0f, (float)(0L - (long)World.Size) * 0.5f);\n\t\tcomponent.drawInstanced = false;\n\t\tcomponent.castShadows = config.CastShadows;\n\t\tcomponent.materialType = Terrain.MaterialType.Custom;\n\t\tcomponent.materialTemplate = config.Material;\n\t\tcomponent.gameObject.tag = base.gameObject.tag;\n\t\tcomponent.gameObject.layer = base.gameObject.layer;\n\t\tcomponent.gameObject.GetComponent\u003CTerrainCollider\u003E().sharedMaterial = config.GenericMaterial;\n\t\tTerrainMeta terrainMeta = component.gameObject.AddComponent\u003CTerrainMeta\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainPhysics\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainColors\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainCollision\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainBiomeMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainAlphaMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainHeightMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainSplatMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainTopologyMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainWaterMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainPlacementMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainPath\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainTexturing\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainWaterFlowMap\u003E();\n\t\tterrainMeta.terrain = component;\n\t\tterrainMeta.config = config;\n\t\tObject.DestroyImmediate(base.gameObject);\n\t\treturn component.gameObject;\n\t}\n",
    "ClassName": "TerrainGenerator",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanEntityBeHostile(BaseCombatEntity baseCombatEntity)",
    "MethodSignature": "IsHostile()",
    "MethodSourseCode": "\n\tpublic virtual bool IsHostile()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanEntityBeHostile\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn unHostileTime \u003E UnityEngine.Time.realtimeSinceStartup;\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerDisconnected(BasePlayer basePlayer, string strReason)",
    "MethodSignature": "OnDisconnected(string strReason, Network.Connection connection)",
    "MethodSourseCode": "\n\tpublic void OnDisconnected(string strReason, Network.Connection connection)\n\t{\n\t\tFacepunch.Rust.Analytics.Azure.OnPlayerDisconnected(connection, strReason);\n\t\tGlobalNetworkHandler.server.OnClientDisconnected(connection);\n\t\tconnectionQueue.TryAddReservedSlot(connection);\n\t\tconnectionQueue.RemoveConnection(connection);\n\t\tConnectionAuth.OnDisconnect(connection);\n\t\tif (connection.authStatusSteam == \u0022ok\u0022)\n\t\t{\n\t\t\tPlatformService.Instance.EndPlayerSession(connection.userid);\n\t\t}\n\t\tEACServer.OnLeaveGame(connection);\n\t\tBasePlayer basePlayer = connection.player as BasePlayer;\n\t\tif (basePlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerDisconnected\u0022, basePlayer, strReason);\n\t\t\tbasePlayer.OnDisconnected();\n\t\t}\n\t\tif (connection.authStatusNexus == \u0022ok\u0022)\n\t\t{\n\t\t\tNexusServer.Logout(connection.userid);\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnMlrsFiringEnded(MLRS mLRS)",
    "MethodSignature": "EndFiring()",
    "MethodSourseCode": "\n\tpublic void EndFiring()\n\t{\n\t\tCancelInvoke(FireNextRocket);\n\t\trocketOwnerRef.Set(null);\n\t\tif (TryGetAimingModule(out var item))\n\t\t{\n\t\t\titem.LoseCondition(1f);\n\t\t}\n\t\tSetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);\n\t\tSetFlag(Flags.Broken, b: true, recursive: false, networkupdate: false);\n\t\tSendNetworkUpdate_Flags();\n\t\ttimeSinceBroken = 0f;\n\t\tInterface.CallHook(\u0022OnMlrsFiringEnded\u0022, this);\n\t}\n",
    "ClassName": "MLRS",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnBookmarkControlEnded(ComputerStation computerStation, BasePlayer ply, BaseEntity baseEntity)",
    "MethodSignature": "StopControl(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic void StopControl(BasePlayer ply)\n\t{\n\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\tif ((bool)baseEntity)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnBookmarkControlEnd\u0022, this, ply, baseEntity) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbaseEntity.GetComponent\u003CIRemoteControllable\u003E().StopControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t}\n\t\tif ((bool)ply)\n\t\t{\n\t\t\tply.net.SwitchSecondaryGroup(null);\n\t\t\tply.SetRcEntityPosition(null);\n\t\t}\n\t\tcurrentlyControllingEnt.uid = default(NetworkableId);\n\t\tcurrentPlayerID = 0uL;\n\t\tSetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);\n\t\tSendNetworkUpdate();\n\t\tSendControlBookmarks(ply);\n\t\tCancelInvoke(ControlCheck);\n\t\tInterface.CallHook(\u0022OnBookmarkControlEnded\u0022, this, ply, baseEntity);\n\t\tCancelInvoke(CheckCCTVAchievement);\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnInventoryItemsCount(PlayerInventory playerInventory, int itemid)",
    "MethodSignature": "GetAmount(int itemid)",
    "MethodSourseCode": "\n\tpublic int GetAmount(int itemid)\n\t{\n\t\tif (itemid == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnInventoryItemsCount\u0022, this, itemid);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tint num = 0;\n\t\tif (containerMain != null)\n\t\t{\n\t\t\tnum \u002B= containerMain.GetAmount(itemid, onlyUsableAmounts: true);\n\t\t}\n\t\tif (containerBelt != null)\n\t\t{\n\t\t\tnum \u002B= containerBelt.GetAmount(itemid, onlyUsableAmounts: true);\n\t\t}\n\t\tif (containerWear != null)\n\t\t{\n\t\t\tnum \u002B= containerWear.GetAmount(itemid, onlyUsableAmounts: true);\n\t\t}\n\t\treturn num;\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnMapMarkersCleared(BasePlayer basePlayer)",
    "MethodSignature": "Server_ClearMapMarkers(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\t[RPC_Server.FromOwner(false)]\n\tpublic void Server_ClearMapMarkers(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMapMarkersClear\u0022, this, State.pointsOfInterest) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tServerCurrentDeathNote?.Dispose();\n\t\tServerCurrentDeathNote = null;\n\t\tif (State.pointsOfInterest != null)\n\t\t{\n\t\t\tforeach (MapNote item in State.pointsOfInterest)\n\t\t\t{\n\t\t\t\titem?.Dispose();\n\t\t\t}\n\t\t\tState.pointsOfInterest.Clear();\n\t\t}\n\t\tDirtyPlayerState();\n\t\tTeamUpdate();\n\t\tInterface.CallHook(\u0022OnMapMarkersCleared\u0022, this);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnServerInitialize()",
    "MethodSignature": "Initialize(bool loadSave, string saveFile, bool allowOutOfDateSaves, bool skipInitialSpawn)",
    "MethodSourseCode": "\n\tpublic bool Initialize(bool loadSave = true, string saveFile = \u0022\u0022, bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)\n\t{\n\t\tInterface.CallHook(\u0022OnServerInitialize\u0022);\n\t\tpersistance = new UserPersistance(ConVar.Server.rootFolder);\n\t\tplayerStateManager = new PlayerStateManager(persistance);\n\t\tTutorialIsland.GenerateIslandSpawnPoints(loadingSave: true);\n\t\tBasePlayer.InitInternalState();\n\t\tif ((bool)SingletonComponent\u003CSpawnHandler\u003E.Instance)\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022SpawnHandler.UpdateDistributions\u0022))\n\t\t\t{\n\t\t\t\tSingletonComponent\u003CSpawnHandler\u003E.Instance.UpdateDistributions();\n\t\t\t}\n\t\t}\n\t\tif (loadSave)\n\t\t{\n\t\t\tWorld.LoadedFromSave = true;\n\t\t\tWorld.LoadedFromSave = (skipInitialSpawn = SaveRestore.Load(saveFile, allowOutOfDateSaves));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSaveRestore.SaveCreatedTime = DateTime.UtcNow;\n\t\t\tWorld.LoadedFromSave = false;\n\t\t}\n\t\tif (!World.LoadedFromSave)\n\t\t{\n\t\t\tSaveRestore.SpawnMapEntities(SaveRestore.FindMapEntities());\n\t\t}\n\t\tSaveRestore.InitializeWipeId();\n\t\tif ((bool)SingletonComponent\u003CSpawnHandler\u003E.Instance)\n\t\t{\n\t\t\tif (!skipInitialSpawn)\n\t\t\t{\n\t\t\t\tusing (TimeWarning.New(\u0022SpawnHandler.InitialSpawn\u0022, 200))\n\t\t\t\t{\n\t\t\t\t\tSingletonComponent\u003CSpawnHandler\u003E.Instance.InitialSpawn();\n\t\t\t\t}\n\t\t\t}\n\t\t\tusing (TimeWarning.New(\u0022SpawnHandler.StartSpawnTick\u0022, 200))\n\t\t\t{\n\t\t\t\tSingletonComponent\u003CSpawnHandler\u003E.Instance.StartSpawnTick();\n\t\t\t}\n\t\t}\n\t\tCreateImportantEntities();\n\t\tauth = GetComponent\u003CConnectionAuth\u003E();\n\t\tFacepunch.Rust.Analytics.Azure.Initialize();\n\t\treturn World.LoadedFromSave;\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, WorldItem worldItem)",
    "MethodSignature": "RPC_OpenLoot(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void RPC_OpenLoot(RPCMessage rpc)\n\t{\n\t\tif (item == null || item.contents == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemModContainer component = item.info.GetComponent\u003CItemModContainer\u003E();\n\t\tif (!(component == null) \u0026\u0026 component.canLootInWorld)\n\t\t{\n\t\t\tBasePlayer player = rpc.player;\n\t\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 CanOpenInSafeZone(player) \u0026\u0026 Interface.CallHook(\u0022CanLootEntity\u0022, player, this) == null \u0026\u0026 player.inventory.loot.StartLootingEntity(this))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\t\tplayer.inventory.loot.AddContainer(item.contents);\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022RPC_OpenLootPanel\u0022, player), \u0022generic_resizable\u0022);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "WorldItem",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnAirdrop(CargoPlane cargoPlane, UnityEngine.Vector3 newDropPosition)",
    "MethodSignature": "UpdateDropPosition(Vector3 newDropPosition)",
    "MethodSourseCode": "\n\tpublic void UpdateDropPosition(Vector3 newDropPosition)\n\t{\n\t\tfloat x = TerrainMeta.Size.x;\n\t\tfloat y = TerrainMeta.HighestPoint.y \u002B 250f;\n\t\tstartPos = Vector3Ex.Range(-1f, 1f);\n\t\tstartPos.y = 0f;\n\t\tstartPos.Normalize();\n\t\tstartPos *= x * 2f;\n\t\tstartPos.y = y;\n\t\tendPos = startPos * -1f;\n\t\tendPos.y = startPos.y;\n\t\tstartPos \u002B= newDropPosition;\n\t\tendPos \u002B= newDropPosition;\n\t\tsecondsToTake = Vector3.Distance(startPos, endPos) / 50f;\n\t\tsecondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);\n\t\tbase.transform.position = startPos;\n\t\tbase.transform.rotation = Quaternion.LookRotation(endPos - startPos);\n\t\tdropPosition = newDropPosition;\n\t\tInterface.CallHook(\u0022OnAirdrop\u0022, this, newDropPosition);\n\t}\n",
    "ClassName": "CargoPlane",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "CanBeHomingTargeted(RoadFlare roadFlare)",
    "MethodSignature": "IsValidHomingTarget()",
    "MethodSourseCode": "\n\tpublic bool IsValidHomingTarget()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeHomingTargeted\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RoadFlare",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDebrisSpawn(DecayEntity decayEntity, UnityEngine.Vector3 localPos, UnityEngine.Quaternion rot, bool dropToTerrain)",
    "MethodSignature": "SpawnDebris(Vector3 localPos, Quaternion rot, bool dropToTerrain)",
    "MethodSourseCode": "\n\tprivate void SpawnDebris(Vector3 localPos, Quaternion rot, bool dropToTerrain)\n\t{\n\t\tif (Interface.CallHook(\u0022OnDebrisSpawn\u0022, this, localPos, rot, dropToTerrain) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 vector = base.transform.TransformPoint(localPos);\n\t\tif (dropToTerrain \u0026\u0026 UnityEngine.Physics.Raycast(vector, Vector3.down, out var hitInfo, 6f, 8388608))\n\t\t{\n\t\t\tfloat num = vector.y - hitInfo.point.y;\n\t\t\tvector.y = hitInfo.point.y;\n\t\t\tlocalPos.y -= num;\n\t\t}\n\t\tList\u003CDebrisEntity\u003E obj = Facepunch.Pool.Get\u003CList\u003CDebrisEntity\u003E\u003E();\n\t\tVis.Entities(vector, 0.1f, obj, 256);\n\t\tif (obj.Count \u003E 0)\n\t\t{\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(debrisPrefab.resourcePath, base.transform.TransformPoint(localPos), base.transform.rotation * rot);\n\t\tif ((bool)baseEntity)\n\t\t{\n\t\t\tbaseEntity.SetParent(parentEntity.Get(serverside: true), worldPositionStays: true);\n\t\t\tbaseEntity.Spawn();\n\t\t}\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t}\n",
    "ClassName": "DecayEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)",
    "MethodSignature": "ToStream(Stream stream, SaveInfo saveInfo)",
    "MethodSourseCode": "\n\tpublic void ToStream(Stream stream, SaveInfo saveInfo)\n\t{\n\t\tusing (saveInfo.msg = Facepunch.Pool.Get\u003CProtoBuf.Entity\u003E())\n\t\t{\n\t\t\tSave(saveInfo);\n\t\t\tif (saveInfo.msg.baseEntity == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(this?.ToString() \u002B \u0022: ToStream - no BaseEntity!?\u0022);\n\t\t\t}\n\t\t\tif (saveInfo.msg.baseNetworkable == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(this?.ToString() \u002B \u0022: ToStream - no baseNetworkable!?\u0022);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022IOnEntitySaved\u0022, this, saveInfo);\n\t\t\tsaveInfo.msg.WriteToStream(stream);\n\t\t\tPostSave(saveInfo);\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDef)",
    "MethodSignature": "RefreshSellOrderStockLevel(ItemDefinition itemDef)",
    "MethodSourseCode": "\n\tpublic void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)\n\t{\n\t\tint num = 0;\n\t\tforeach (ProtoBuf.VendingMachine.SellOrder sellOrder in sellOrders.sellOrders)\n\t\t{\n\t\t\tif (!(itemDef == null) \u0026\u0026 itemDef.itemid != sellOrder.itemToSellID)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tList\u003CItem\u003E obj = Facepunch.Pool.Get\u003CList\u003CItem\u003E\u003E();\n\t\t\tGetItemsToSell(sellOrder, obj);\n\t\t\tint num2 = sellOrder.itemToSellAmount;\n\t\t\tif (ItemManager.FindItemDefinition(sellOrder.itemToSellID) == NPCVendingMachine.ScrapItem \u0026\u0026 sellOrder.receivedQuantityMultiplier != 1f)\n\t\t\t{\n\t\t\t\tnum2 = GetTotalPriceForOrder(num2, sellOrder.receivedQuantityMultiplier);\n\t\t\t}\n\t\t\tint inStock;\n\t\t\tif (obj.Count \u003C 0)\n\t\t\t{\n\t\t\t\tinStock = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tList\u003CItem\u003E source = obj;\n\t\t\t\tFunc\u003CItem, int\u003E selector = (Item x) =\u003E x.amount;\n\t\t\t\tInterface.CallHook(\u0022OnRefreshVendingStock\u0022, this, itemDef);\n\t\t\t\tinStock = source.Sum(selector) / num2;\n\t\t\t}\n\t\t\tsellOrder.inStock = inStock;\n\t\t\tfloat itemCondition = 0f;\n\t\t\tfloat itemConditionMax = 0f;\n\t\t\tint instanceData = 0;\n\t\t\tList\u003Cint\u003E list = Facepunch.Pool.Get\u003CList\u003Cint\u003E\u003E();\n\t\t\tint totalAttachmentSlots = 0;\n\t\t\tint ammoType = 0;\n\t\t\tint ammoCount = 0;\n\t\t\tif (obj.Count \u003E 0)\n\t\t\t{\n\t\t\t\tif (obj[0].hasCondition)\n\t\t\t\t{\n\t\t\t\t\titemCondition = obj[0].condition;\n\t\t\t\t\titemConditionMax = obj[0].maxCondition;\n\t\t\t\t}\n\t\t\t\tif (obj[0].info != null \u0026\u0026 (obj[0].info.amountType == ItemDefinition.AmountType.Genetics || obj[0].info.amountType == ItemDefinition.AmountType.NucleusGrades) \u0026\u0026 obj[0].instanceData != null)\n\t\t\t\t{\n\t\t\t\t\tinstanceData = obj[0].instanceData.dataInt;\n\t\t\t\t\tsellOrder.inStock = obj[0].amount;\n\t\t\t\t}\n\t\t\t\tif (obj[0].contents != null \u0026\u0026 obj[0].contents.capacity \u003E 0 \u0026\u0026 obj[0].contents.HasFlag(ItemContainer.Flag.ShowSlotsOnIcon))\n\t\t\t\t{\n\t\t\t\t\tforeach (Item item in obj[0].contents.itemList)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist.Add(item.info.itemid);\n\t\t\t\t\t}\n\t\t\t\t\ttotalAttachmentSlots = obj[0].contents.capacity;\n\t\t\t\t}\n\t\t\t\tif (obj[0].GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)\n\t\t\t\t{\n\t\t\t\t\tammoCount = baseProjectile.primaryMagazine.contents;\n\t\t\t\t\tif (baseProjectile.primaryMagazine.ammoType != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tammoType = baseProjectile.primaryMagazine.ammoType.itemid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsellOrder.ammoType = ammoType;\n\t\t\tsellOrder.ammoCount = ammoCount;\n\t\t\tsellOrder.itemCondition = itemCondition;\n\t\t\tsellOrder.itemConditionMax = itemConditionMax;\n\t\t\tsellOrder.instanceData = instanceData;\n\t\t\tif (sellOrder.attachmentsList != null)\n\t\t\t{\n\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref sellOrder.attachmentsList);\n\t\t\t}\n\t\t\tsellOrder.attachmentsList = list;\n\t\t\tsellOrder.totalAttachmentSlots = totalAttachmentSlots;\n\t\t\tsellOrder.priceMultiplier = GetDiscountForSlot(num, sellOrder);\n\t\t\tsellOrder.receivedQuantityMultiplier = GetReceivedQuantityMultiplier(num, sellOrder);\n\t\t\tnum\u002B\u002B;\n\t\t\tFacepunch.Pool.Free(ref obj, freeElements: false);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "CanLockerAcceptItem(Locker locker, Item item, int targetSlot)",
    "MethodSignature": "ItemFilter(Item item, int targetSlot)",
    "MethodSourseCode": "\n\tpublic override bool ItemFilter(Item item, int targetSlot)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanLockerAcceptItem\u0022, this, item, targetSlot);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!base.ItemFilter(item, targetSlot))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tbool num = item.IsBackpack();\n\t\tbool flag = IsBackpackSlot(targetSlot);\n\t\tif (num != flag)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (isTransferringIndustrialItem \u0026\u0026 GetRowType(targetSlot) == RowType.Belt \u0026\u0026 item.info.category == ItemCategory.Attire)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.info.category == ItemCategory.Attire)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn GetRowType(targetSlot) == RowType.Belt;\n\t}\n",
    "ClassName": "Locker",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPhoneCallStart(PhoneController phoneController, PhoneController activeCallTo, BasePlayer currentPlayer)",
    "MethodSignature": "BeginCall()",
    "MethodSourseCode": "\n\tpublic void BeginCall()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneCallStart\u0022, this, activeCallTo, currentPlayer) == null)\n\t\t{\n\t\t\tif (IsMobile \u0026\u0026 activeCallTo != null \u0026\u0026 !activeCallTo.RequirePower)\n\t\t\t{\n\t\t\t\t_ = currentPlayer != null;\n\t\t\t}\n\t\t\tSetPhoneStateWithPlayer(Telephone.CallState.InProcess);\n\t\t\tInvoke(TimeOutCall, TelephoneManager.MaxCallLength);\n\t\t\tInterface.CallHook(\u0022OnPhoneCallStarted\u0022, this, activeCallTo, currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnWeaponModChange(BaseProjectile baseProjectile, BasePlayer getOwnerPlayer)",
    "MethodSignature": "DelayedModsChanged()",
    "MethodSourseCode": "\n\tpublic void DelayedModsChanged()\n\t{\n\t\tif (Interface.CallHook(\u0022OnWeaponModChange\u0022, this, GetOwnerPlayer()) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = Mathf.CeilToInt(ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) =\u003E x.magazineCapacity, (ProjectileWeaponMod.Modifier y) =\u003E y.scalar, 1f) * (float)primaryMagazine.definition.builtInSize);\n\t\tif (num == primaryMagazine.capacity)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (primaryMagazine.contents \u003E 0 \u0026\u0026 primaryMagazine.contents \u003E num)\n\t\t{\n\t\t\t_ = primaryMagazine.ammoType;\n\t\t\tint contents = primaryMagazine.contents;\n\t\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\t\tItemContainer itemContainer = null;\n\t\t\tif (ownerPlayer != null)\n\t\t\t{\n\t\t\t\titemContainer = ownerPlayer.inventory.containerMain;\n\t\t\t}\n\t\t\telse if (GetCachedItem() != null)\n\t\t\t{\n\t\t\t\titemContainer = GetCachedItem().parent;\n\t\t\t}\n\t\t\tSetAmmoCount(0);\n\t\t\tif (itemContainer != null)\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(primaryMagazine.ammoType, contents, 0uL);\n\t\t\t\tif (!item.MoveToContainer(itemContainer))\n\t\t\t\t{\n\t\t\t\t\tVector3 vPos = base.transform.position;\n\t\t\t\t\tif (itemContainer.entityOwner != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvPos = itemContainer.entityOwner.transform.position \u002B Vector3.up * 0.25f;\n\t\t\t\t\t}\n\t\t\t\t\titem.Drop(vPos, Vector3.up * 5f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprimaryMagazine.capacity = num;\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNoGoZoneAdded(PatrolHelicopterAI patrolHelicopterAI, PatrolHelicopterAI.DangerZone zone)",
    "MethodSignature": "NoGoZoneAdded(DangerZone zone)",
    "MethodSourseCode": "\n\tprivate void NoGoZoneAdded(DangerZone zone)\n\t{\n\t\tif (use_danger_zones \u0026\u0026 Interface.CallHook(\u0022OnNoGoZoneAdded\u0022, this, zone) == null \u0026\u0026 !zone.IsInMonument)\n\t\t{\n\t\t\tClearTargets();\n\t\t\tExitCurrentState();\n\t\t\tState_Flee_Enter();\n\t\t}\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnElevatorMove(Elevator elevator, int targetFloor)",
    "MethodSignature": "RequestMoveLiftTo(int targetFloor, float timeToTravel, Elevator fromElevator)",
    "MethodSourseCode": "\n\tpublic bool RequestMoveLiftTo(int targetFloor, out float timeToTravel, Elevator fromElevator)\n\t{\n\t\ttimeToTravel = 0f;\n\t\tif (Interface.CallHook(\u0022OnElevatorMove\u0022, this, targetFloor) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsBusy())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsStatic \u0026\u0026 ioEntity != null \u0026\u0026 !ioEntity.IsPowered())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsValidFloor(targetFloor))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tint num = LiftPositionToFloor();\n\t\tif (num == targetFloor)\n\t\t{\n\t\t\tOpenDoorsAtFloor(num);\n\t\t\treturn false;\n\t\t}\n\t\tif (!liftEntity.IsValid(base.isServer))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tElevatorLift elevatorLift = liftEntity.Get(base.isServer);\n\t\tif (!elevatorLift.CanMove())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tVector3 worldSpaceFloorPosition = GetWorldSpaceFloorPosition(targetFloor);\n\t\tif (!GamePhysics.LineOfSight(elevatorLift.transform.position, worldSpaceFloorPosition, 2097152))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tOnMoveBegin();\n\t\ttimeToTravel = TimeToTravelDistance(Mathf.Abs(elevatorLift.transform.position.y - worldSpaceFloorPosition.y));\n\t\tLeanTween.moveY(elevatorLift.gameObject, worldSpaceFloorPosition.y, timeToTravel).delay = LiftMoveDelay;\n\t\ttimeToTravel \u002B= LiftMoveDelay;\n\t\tSetFlag(Flags.Busy, b: true);\n\t\tif (targetFloor \u003C Floor)\n\t\t{\n\t\t\televatorLift.ToggleHurtTrigger(state: true);\n\t\t}\n\t\televatorLift.SetFlag(Flags.Busy, b: true);\n\t\tInvoke(ClearBusy, timeToTravel \u002B 1f);\n\t\televatorLift.NotifyNewFloor(targetFloor, Floor);\n\t\tEntityLinkBroadcast(delegate(Elevator elevatorEnt)\n\t\t{\n\t\t\televatorEnt.SetFlag(Flags.Busy, b: true);\n\t\t}, (ConstructionSocket socket) =\u003E socket.socketType == ConstructionSocket.Type.Elevator);\n\t\tif (ioEntity != null)\n\t\t{\n\t\t\tioEntity.SetFlag(Flags.Busy, b: true);\n\t\t\tioEntity.SendChangedToRoot(forceUpdate: true);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Elevator",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnGrowableStateChange(GrowableEntity growableEntity, PlantProperties.State state)",
    "MethodSignature": "ChangeState(PlantProperties.State state, bool resetAge, bool loading)",
    "MethodSourseCode": "\n\tpublic void ChangeState(PlantProperties.State state, bool resetAge, bool loading = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnGrowableStateChange\u0022, this, state) != null || (base.isServer \u0026\u0026 State == state))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tState = state;\n\t\tif (!base.isServer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!loading)\n\t\t{\n\t\t\tif (currentStage.resources \u003E 0f)\n\t\t\t{\n\t\t\t\tyieldPool = currentStage.yield;\n\t\t\t}\n\t\t\tif (state == PlantProperties.State.Crossbreed)\n\t\t\t{\n\t\t\t\tif (Properties.CrossBreedEffect.isValid)\n\t\t\t\t{\n\t\t\t\t\tEffect.server.Run(Properties.CrossBreedEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t\t}\n\t\t\t\tGrowableGenetics.CrossBreed(this);\n\t\t\t}\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tif (resetAge)\n\t\t{\n\t\t\tstageAge = 0f;\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCargoShipEgress(CargoShip cargoShip)",
    "MethodSignature": "StartEgress()",
    "MethodSourseCode": "\n\tpublic void StartEgress()\n\t{\n\t\tif (!isDoingHarborApproach \u0026\u0026 !egressing)\n\t\t{\n\t\t\tegressing = true;\n\t\t\tif (Interface.CallHook(\u0022OnCargoShipEgress\u0022, this) == null)\n\t\t\t{\n\t\t\t\tCancelInvoke(PlayHorn);\n\t\t\t\tradiation.SetActive(value: true);\n\t\t\t\tSetFlag(Flags.Reserved8, b: true);\n\t\t\t\tInvokeRepeating(UpdateRadiation, 10f, 1f);\n\t\t\t\tInvoke(DelayedDestroy, 60f * egress_duration_minutes);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CargoShip",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnItemRecycle(Item slot, Recycler recycler)",
    "MethodSignature": "RecycleThink()",
    "MethodSourseCode": "\n\tpublic void RecycleThink()\n\t{\n\t\tbool flag = false;\n\t\tfloat num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);\n\t\tint num2 = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tif (num2 \u003C 6)\n\t\t\t{\n\t\t\t\tItem slot = base.inventory.GetSlot(num2);\n\t\t\t\tif (!CanBeRecycled(slot))\n\t\t\t\t{\n\t\t\t\t\tnum2\u002B\u002B;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Interface.CallHook(\u0022OnItemRecycle\u0022, slot, this) != null)\n\t\t\t\t{\n\t\t\t\t\tif (!HasRecyclable())\n\t\t\t\t\t{\n\t\t\t\t\t\tStopRecycling();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (slot.hasCondition)\n\t\t\t\t{\n\t\t\t\t\tnum = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));\n\t\t\t\t}\n\t\t\t\tint num3 = 1;\n\t\t\t\tif (slot.amount \u003E 1)\n\t\t\t\t{\n\t\t\t\t\tnum3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnItemRecycleAmount\u0022, slot, num3, this);\n\t\t\t\tif (obj is int)\n\t\t\t\t{\n\t\t\t\t\tnum3 = (int)obj;\n\t\t\t\t}\n\t\t\t\tif (slot.info.Blueprint.scrapFromRecycle \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tfloat num4 = slot.info.Blueprint.scrapFromRecycle * num3;\n\t\t\t\t\tif (slot.MaxStackable() == 1 \u0026\u0026 slot.hasCondition)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum4 *= slot.conditionNormalized;\n\t\t\t\t\t}\n\t\t\t\t\tfloat num5 = num / 0.5f;\n\t\t\t\t\tnum4 *= num5;\n\t\t\t\t\tint num6 = Mathf.FloorToInt(num4);\n\t\t\t\t\tfloat num7 = num4 - (float)num6;\n\t\t\t\t\tscrapRemainder \u002B= num7;\n\t\t\t\t\tif (scrapRemainder \u003E= 1f)\n\t\t\t\t\t{\n\t\t\t\t\t\tint num8 = Mathf.FloorToInt(scrapRemainder);\n\t\t\t\t\t\tscrapRemainder -= num8;\n\t\t\t\t\t\tnum6 \u002B= num8;\n\t\t\t\t\t}\n\t\t\t\t\tif (num6 \u003E= 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tItem item = ItemManager.CreateByName(\u0022scrap\u0022, num6, 0uL);\n\t\t\t\t\t\tif (base.LastLootedByPlayer != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);\n\t\t\t\t\t\tMoveItemToOutput(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))\n\t\t\t\t{\n\t\t\t\t\tList\u003CBasePlayer\u003E obj2 = Facepunch.Pool.Get\u003CList\u003CBasePlayer\u003E\u003E();\n\t\t\t\t\tVis.Entities(base.transform.position, 3f, obj2, 131072);\n\t\t\t\t\tforeach (BasePlayer item3 in obj2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (item3.IsAlive() \u0026\u0026 !item3.IsSleeping() \u0026\u0026 item3.inventory.loot.entitySource == this)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);\n\t\t\t\t\t\t\titem3.stats.Save();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\t\t\t}\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);\n\t\t\t\tslot.UseItem(num3);\n\t\t\t\tforeach (ItemAmount ingredient in slot.info.Blueprint.GetIngredients())\n\t\t\t\t{\n\t\t\t\t\tif (ingredient.itemDef.shortname == \u0022scrap\u0022)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfloat num9 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num3;\n\t\t\t\t\tint num10 = Mathf.FloorToInt(num9);\n\t\t\t\t\tfloat num11 = num9 - (float)num10;\n\t\t\t\t\tif (num11 \u003E float.Epsilon \u0026\u0026 UnityEngine.Random.Range(0f, 1f) \u003C= num11)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum10\u002B\u002B;\n\t\t\t\t\t}\n\t\t\t\t\tif (num10 \u003C= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint num12 = Mathf.CeilToInt((float)num10 / (float)ingredient.itemDef.stackable);\n\t\t\t\t\tfor (int i = 0; i \u003C num12; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ingredient.itemDef.IsAllowed(EraRestriction.Recycle))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint num13 = ((num10 \u003E ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num10);\n\t\t\t\t\t\t\tItem item2 = ItemManager.Create(ingredient.itemDef, num13, 0uL);\n\t\t\t\t\t\t\tif (base.LastLootedByPlayer != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\titem2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);\n\t\t\t\t\t\t\tif (!MoveItemToOutput(item2))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum10 -= num13;\n\t\t\t\t\t\t\tif (num10 \u003C= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag || !HasRecyclable())\n\t\t\t{\n\t\t\t\tStopRecycling();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnRfBroadcasterRemoved(IRFObject obj, int frequency)",
    "MethodSignature": "RemoveBroadcaster(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void RemoveBroadcaster(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfBroadcasterRemove\u0022, obj, frequency) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tHashSet\u003CIRFObject\u003E broadcasterSet = GetBroadcasterSet(frequency);\n\t\tif (broadcasterSet.RemoveWhere((IRFObject b) =\u003E b == null || !BaseEntityEx.IsValidEntityReference(b)) \u003E 0)\n\t\t{\n\t\t\tDebug.LogWarning($\u0022Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.\u0022);\n\t\t}\n\t\tif (broadcasterSet.Remove(obj))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnRfBroadcasterRemoved\u0022, obj, frequency);\n\t\t\tif (broadcasterSet.Count == 0)\n\t\t\t{\n\t\t\t\t_isFrequencyBroadcasting[frequency] = false;\n\t\t\t\tUpdateListenersForFrequency(frequency, isBroadcasting: false);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnAmmoSwitch(BaseProjectile baseProjectile, BasePlayer ownerPlayer, ItemDefinition itemDefinition)",
    "MethodSignature": "SwitchAmmoTo(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void SwitchAmmoTo(RPCMessage msg)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = msg.read.Int32();\n\t\tif (num == primaryMagazine.ammoType.itemid)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);\n\t\tif (itemDefinition == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemModProjectile component = itemDefinition.GetComponent\u003CItemModProjectile\u003E();\n\t\tif ((bool)component \u0026\u0026 component.IsAmmo(primaryMagazine.definition.ammoTypes) \u0026\u0026 Interface.CallHook(\u0022OnAmmoSwitch\u0022, this, ownerPlayer, itemDefinition) == null)\n\t\t{\n\t\t\tif (primaryMagazine.contents \u003E 0)\n\t\t\t{\n\t\t\t\townerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));\n\t\t\t\tSetAmmoCount(0);\n\t\t\t}\n\t\t\tprimaryMagazine.ammoType = itemDefinition;\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tItemManager.DoRemoves();\n\t\t\townerPlayer.inventory.ServerUpdate(0f);\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnPhoneDialFailed(PhoneController phoneController, Telephone.DialFailReason reason, BasePlayer currentPlayer)",
    "MethodSignature": "OnDialFailed(Telephone.DialFailReason reason)",
    "MethodSourseCode": "\n\tpublic void OnDialFailed(Telephone.DialFailReason reason)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneDialFail\u0022, this, reason, currentPlayer) == null)\n\t\t{\n\t\t\tSetPhoneState(Telephone.CallState.Idle);\n\t\t\tbase.baseEntity.ClientRPC(RpcTarget.NetworkGroup(\u0022ClientOnDialFailed\u0022), (int)reason);\n\t\t\tactiveCallTo = null;\n\t\t\tif (IsInvoking(TimeOutCall))\n\t\t\t{\n\t\t\t\tCancelInvoke(TimeOutCall);\n\t\t\t}\n\t\t\tif (IsInvoking(TriggerTimeOut))\n\t\t\t{\n\t\t\t\tCancelInvoke(TriggerTimeOut);\n\t\t\t}\n\t\t\tif (IsInvoking(TimeOutDialing))\n\t\t\t{\n\t\t\t\tCancelInvoke(TimeOutDialing);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPhoneDialFailed\u0022, this, reason, currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnExcavatorMiningToggled(ExcavatorArm excavatorArm)",
    "MethodSignature": "BeginMining()",
    "MethodSourseCode": "\n\tpublic void BeginMining()\n\t{\n\t\tif (!IsPowered())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetFlag(Flags.On, b: true);\n\t\tInvokeRepeating(ProduceResources, resourceProductionTickRate, resourceProductionTickRate);\n\t\tif (UnityEngine.Time.time \u003E nextNotificationTime)\n\t\t{\n\t\t\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\n\t\t\t{\n\t\t\t\tif (!activePlayer.IsNpc \u0026\u0026 activePlayer.IsConnected \u0026\u0026 !activePlayer.IsInTutorial)\n\t\t\t\t{\n\t\t\t\t\tactivePlayer.ShowToast(GameTip.Styles.Server_Event, excavatorPhrase, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnextNotificationTime = UnityEngine.Time.time \u002B 60f;\n\t\t}\n\t\tExcavatorServerEffects.SetMining(isMining: true);\n\t\texcavatorStartTime = GetNetworkTime();\n\t\tInterface.CallHook(\u0022OnExcavatorMiningToggled\u0022, this);\n\t}\n",
    "ClassName": "ExcavatorArm",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnEyePosValidate(AttackEntity attackEntity, BasePlayer player, UnityEngine.Vector3 eyePos, bool checkLineOfSight)",
    "MethodSignature": "ValidateEyePos(BasePlayer player, Vector3 eyePos, bool checkLineOfSight)",
    "MethodSourseCode": "\n\tprotected bool ValidateEyePos(BasePlayer player, Vector3 eyePos, bool checkLineOfSight = true)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnEyePosValidate\u0022, this, player, eyePos, checkLineOfSight);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tbool flag = true;\n\t\tif (eyePos.IsNaNOrInfinity())\n\t\t{\n\t\t\tstring shortPrefabName = base.ShortPrefabName;\n\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, \u0022Contains NaN (\u0022 \u002B shortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022eye_nan\u0022);\n\t\t\tflag = false;\n\t\t}\n\t\tif (ConVar.AntiHack.eye_protection \u003E 0)\n\t\t{\n\t\t\tif (ConVar.AntiHack.eye_protection \u003E= 1)\n\t\t\t{\n\t\t\t\tfloat num = player.GetParentVelocity().magnitude \u002B player.GetMountVelocity().magnitude;\n\t\t\t\tfloat num2 = ((((player.HasParent() || player.isMounted) ? ConVar.AntiHack.eye_distance_parented_mounted_forgiveness : 0f) \u002B player.estimatedSpeed \u003E 0f) ? ConVar.AntiHack.eye_forgiveness : 0f);\n\t\t\t\tfloat num3 = num \u002B num2;\n\t\t\t\tfloat num4 = player.tickHistory.Distance(player, eyePos);\n\t\t\t\tif (num4 \u003E num3)\n\t\t\t\t{\n\t\t\t\t\tstring shortPrefabName2 = base.ShortPrefabName;\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, \u0022Distance (\u0022 \u002B shortPrefabName2 \u002B \u0022 on attack with \u0022 \u002B num4 \u002B \u0022m \u003E \u0022 \u002B num3 \u002B \u0022m)\u0022);\n\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022eye_distance\u0022);\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ConVar.AntiHack.eye_protection \u003E= 3)\n\t\t\t{\n\t\t\t\tfloat num5 = Mathf.Abs(player.GetMountVelocity().y \u002B player.GetParentVelocity().y) \u002B BasePlayer.GetJumpHeight();\n\t\t\t\tfloat num6 = Mathf.Abs(player.eyes.position.y - eyePos.y);\n\t\t\t\tif (num6 \u003E num5)\n\t\t\t\t{\n\t\t\t\t\tstring shortPrefabName3 = base.ShortPrefabName;\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, \u0022Altitude (\u0022 \u002B shortPrefabName3 \u002B \u0022 on attack with \u0022 \u002B num6 \u002B \u0022m \u003E \u0022 \u002B num5 \u002B \u0022m)\u0022);\n\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022eye_altitude\u0022);\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (checkLineOfSight)\n\t\t\t{\n\t\t\t\tint num7 = 2162688;\n\t\t\t\tif (ConVar.AntiHack.eye_terraincheck)\n\t\t\t\t{\n\t\t\t\t\tnum7 |= 0x800000;\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.eye_vehiclecheck)\n\t\t\t\t{\n\t\t\t\t\tnum7 |= 0x8000000;\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.eye_protection \u003E= 2)\n\t\t\t\t{\n\t\t\t\t\tVector3 center = player.eyes.center;\n\t\t\t\t\tVector3 position = player.eyes.position;\n\t\t\t\t\tVector3 vector = eyePos;\n\t\t\t\t\tif (!GamePhysics.LineOfSightRadius(center, position, num7, ConVar.AntiHack.eye_losradius) || !GamePhysics.LineOfSightRadius(position, vector, num7, ConVar.AntiHack.eye_losradius))\n\t\t\t\t\t{\n\t\t\t\t\t\tstring shortPrefabName4 = base.ShortPrefabName;\n\t\t\t\t\t\tstring[] obj2 = new string[8] { \u0022Line of sight (\u0022, shortPrefabName4, \u0022 on attack) \u0022, null, null, null, null, null };\n\t\t\t\t\t\tVector3 vector2 = center;\n\t\t\t\t\t\tobj2[3] = vector2.ToString();\n\t\t\t\t\t\tobj2[4] = \u0022 \u0022;\n\t\t\t\t\t\tvector2 = position;\n\t\t\t\t\t\tobj2[5] = vector2.ToString();\n\t\t\t\t\t\tobj2[6] = \u0022 \u0022;\n\t\t\t\t\t\tvector2 = vector;\n\t\t\t\t\t\tobj2[7] = vector2.ToString();\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj2));\n\t\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022eye_los\u0022);\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.eye_protection \u003E= 4 \u0026\u0026 !player.HasParent())\n\t\t\t\t{\n\t\t\t\t\tVector3 position2 = player.eyes.position;\n\t\t\t\t\tVector3 vector3 = eyePos;\n\t\t\t\t\tfloat num8 = Vector3.Distance(position2, vector3);\n\t\t\t\t\tCollider col;\n\t\t\t\t\tif (num8 \u003E ConVar.AntiHack.eye_noclip_cutoff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (AntiHack.TestNoClipping(player, position2, vector3, BasePlayer.NoClipRadius(ConVar.AntiHack.eye_noclip_margin), ConVar.AntiHack.eye_noclip_backtracking, out col, vehicleLayer: false, null, forceCast: true))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName5 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring[] obj3 = new string[6] { \u0022NoClip (\u0022, shortPrefabName5, \u0022 on attack) \u0022, null, null, null };\n\t\t\t\t\t\t\tVector3 vector2 = position2;\n\t\t\t\t\t\t\tobj3[3] = vector2.ToString();\n\t\t\t\t\t\t\tobj3[4] = \u0022 \u0022;\n\t\t\t\t\t\t\tvector2 = vector3;\n\t\t\t\t\t\t\tobj3[5] = vector2.ToString();\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj3));\n\t\t\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022eye_noclip\u0022);\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (num8 \u003E 0.01f \u0026\u0026 AntiHack.TestNoClipping(player, position2, vector3, 0.1f, ConVar.AntiHack.eye_noclip_backtracking, out col, vehicleLayer: false, null, forceCast: true))\n\t\t\t\t\t{\n\t\t\t\t\t\tstring shortPrefabName6 = base.ShortPrefabName;\n\t\t\t\t\t\tstring[] obj4 = new string[6] { \u0022NoClip (\u0022, shortPrefabName6, \u0022 on attack) \u0022, null, null, null };\n\t\t\t\t\t\tVector3 vector2 = position2;\n\t\t\t\t\t\tobj4[3] = vector2.ToString();\n\t\t\t\t\t\tobj4[4] = \u0022 \u0022;\n\t\t\t\t\t\tvector2 = vector3;\n\t\t\t\t\t\tobj4[5] = vector2.ToString();\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj4));\n\t\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022eye_noclip\u0022);\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tAntiHack.AddViolation(player, AntiHackType.EyeHack, ConVar.AntiHack.eye_penalty);\n\t\t\t}\n\t\t\telse if (ConVar.AntiHack.eye_protection \u003E= 5 \u0026\u0026 !player.HasParent() \u0026\u0026 !player.isMounted)\n\t\t\t{\n\t\t\t\tplayer.eyeHistory.PushBack(eyePos);\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n",
    "ClassName": "AttackEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHelicopterRetire(PatrolHelicopterAI patrolHelicopterAI)",
    "MethodSignature": "Retire()",
    "MethodSourseCode": "\n\tpublic void Retire()\n\t{\n\t\tif (!isRetiring \u0026\u0026 Interface.CallHook(\u0022OnHelicopterRetire\u0022, this) == null)\n\t\t{\n\t\t\tInvoke(DestroyMe, 240f);\n\t\t\tfloat x = TerrainMeta.Size.x;\n\t\t\tfloat y = 200f;\n\t\t\tVector3 newPos = Vector3Ex.Range(-1f, 1f);\n\t\t\tnewPos.y = 0f;\n\t\t\tnewPos.Normalize();\n\t\t\tnewPos *= x * 20f;\n\t\t\tnewPos.y = y;\n\t\t\tExitCurrentState();\n\t\t\tisRetiring = true;\n\t\t\tState_Move_Enter(newPos);\n\t\t}\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHealingItemUse(MedicalTool medicalTool, BasePlayer player)",
    "MethodSignature": "GiveEffectsTo(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate void GiveEffectsTo(BasePlayer player)\n\t{\n\t\tif (!player)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition ownerItemDefinition = GetOwnerItemDefinition();\n\t\tItemModConsumable component = ownerItemDefinition.GetComponent\u003CItemModConsumable\u003E();\n\t\tif (!component)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022No consumable for medicaltool :\u0022 \u002B base.name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnHealingItemUse\u0022, this, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\t\tFacepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);\n\t\t\tif (player != ownerPlayer)\n\t\t\t{\n\t\t\t\tif (Interface.CallHook(\u0022OnPlayerRevive\u0022, GetOwnerPlayer(), player) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (player.IsWounded() \u0026\u0026 canRevive)\n\t\t\t\t{\n\t\t\t\t\tplayer.StopWounded(ownerPlayer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach (ItemModConsumable.ConsumableEffect effect in component.effects)\n\t\t\t{\n\t\t\t\tif (effect.type == MetabolismAttribute.Type.Health)\n\t\t\t\t{\n\t\t\t\t\tplayer.health \u002B= effect.amount;\n\t\t\t\t\tplayer.ProcessMissionEvent(BaseMission.MissionEventType.HEAL, prefabID, effect.amount);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (player is BasePet)\n\t\t\t{\n\t\t\t\tplayer.SendNetworkUpdateImmediate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MedicalTool",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnPlayerLanded(BasePlayer basePlayer, float num)",
    "MethodSignature": "ApplyFallDamageFromVelocity(float velocity)",
    "MethodSourseCode": "\n\tpublic void ApplyFallDamageFromVelocity(float velocity)\n\t{\n\t\tif (IsGod())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = Mathf.InverseLerp(-15f, -100f, velocity);\n\t\tif (num != 0f \u0026\u0026 Interface.CallHook(\u0022OnPlayerLand\u0022, this, num) == null)\n\t\t{\n\t\t\tfloat num2 = ((modifiers != null) ? Mathf.Clamp01(1f - modifiers.GetValue(Modifier.ModifierType.Clotting)) : 1f);\n\t\t\tmetabolism.bleeding.Add(num * 0.5f * num2);\n\t\t\tfloat num3 = num * 500f;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num3);\n\t\t\tHurt(num3, DamageType.Fall);\n\t\t\tif (num3 \u003E 20f \u0026\u0026 fallDamageEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(fallDamageEffect.resourcePath, base.transform.position, Vector3.zero);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPlayerLanded\u0022, this, num);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "CanUnlock(BasePlayer rpcPlayer, KeyLock keyLock)",
    "MethodSignature": "RPC_Unlock(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f, CheckParent = true)]\n\t[RPC_Server]\n\tprivate void RPC_Unlock(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanUnlock\u0022, rpc.player, this) == null \u0026\u0026 HasLockPermission(rpc.player))\n\t\t{\n\t\t\tSetFlag(Flags.Locked, b: false);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "KeyLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnScientistInitialized(BradleyAPC bradleyAPC, ScientistNPC scientist, UnityEngine.Vector3 spawnPos)",
    "MethodSignature": "InitScientist(ScientistNPC scientist, Vector3 spawnPos, BasePlayer triggerPlayer, bool roadSpawned, bool startChasing)",
    "MethodSourseCode": "\n\tprivate void InitScientist(ScientistNPC scientist, Vector3 spawnPos, BasePlayer triggerPlayer, bool roadSpawned, bool startChasing)\n\t{\n\t\tif (scientist == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tscientist.transform.position = spawnPos;\n\t\tif (!scientist.Brain.Navigator.PlaceOnNavMesh(0.2f))\n\t\t{\n\t\t\tactiveScientists.Remove(scientist);\n\t\t\tscientist.Kill();\n\t\t\treturn;\n\t\t}\n\t\tif (triggerPlayer != null)\n\t\t{\n\t\t\tscientist.Brain.Events.Memory.Entity.Set(triggerPlayer, 0);\n\t\t\tscientist.Brain.Senses.Memory.SetKnown(triggerPlayer, scientist, null);\n\t\t\tscientist.Brain.Events.Memory.Position.Set(scientist.Brain.Navigator.transform.position, 7);\n\t\t\tscientist.Brain.Events.Memory.Position.Set(scientist.Brain.Navigator.transform.position, 4);\n\t\t\tscientist.Brain.Events.Memory.Entity.Set(this, 7);\n\t\t\tAttackEntity attackEntity = scientist.GetAttackEntity();\n\t\t\tif (SetScientistChaseBasedOnWeapon \u0026\u0026 attackEntity != null \u0026\u0026 !attackEntity.CanUseAtLongRange)\n\t\t\t{\n\t\t\t\tstartChasing = true;\n\t\t\t}\n\t\t\tscientist.Brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint = startChasing;\n\t\t\tscientist.Brain.Navigator.CanUseRandomMovePointIfNonFound = !startChasing;\n\t\t\tif (startChasing)\n\t\t\t{\n\t\t\t\tscientist.Brain.SwitchToState(AIState.Chase, 6);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tscientist.Brain.SwitchToState(AIState.TakeCover, 4);\n\t\t\t}\n\t\t\tscientist.Brain.Think(0f);\n\t\t}\n\t\tInterface.CallHook(\u0022OnScientistInitialized\u0022, this, scientist, spawnPos);\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 38
  },
  {
    "HookSignature": "OnExplosiveThrown(BasePlayer msgPlayer, BaseEntity baseEntity, ThrownWeapon thrownWeapon)",
    "MethodSignature": "DoThrow(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server]\n\tprivate void DoThrow(RPCMessage msg)\n\t{\n\t\tif (!HasItemAmount() || HasAttackCooldown())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 vector = msg.read.Vector3();\n\t\tVector3 normalized = msg.read.Vector3().normalized;\n\t\tfloat num = Mathf.Clamp01(msg.read.Float());\n\t\tif (normalized.IsNaNOrInfinity() || num.IsNaNOrInfinity())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (msg.player.isMounted || msg.player.HasParent())\n\t\t{\n\t\t\tvector = msg.player.eyes.position;\n\t\t}\n\t\telse if (!ValidateEyePos(msg.player, vector))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!canThrowUnderwater \u0026\u0026 msg.player.IsHeadUnderwater())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation((overrideAngle == Vector3.zero) ? (-normalized) : overrideAngle));\n\t\tif (!(baseEntity == null))\n\t\t{\n\t\t\tItem ownerItem = GetOwnerItem();\n\t\t\tif (ownerItem != null \u0026\u0026 ownerItem.instanceData != null \u0026\u0026 ownerItem.HasFlag(Item.Flag.IsOn))\n\t\t\t{\n\t\t\t\tbaseEntity.gameObject.SendMessage(\u0022SetFrequency\u0022, GetOwnerItem().instanceData.dataInt, SendMessageOptions.DontRequireReceiver);\n\t\t\t}\n\t\t\tbaseEntity.SetCreatorEntity(msg.player);\n\t\t\tbaseEntity.skinID = skinID;\n\t\t\tbaseEntity.SetVelocity(GetInheritedVelocity(msg.player, normalized) \u002B normalized * maxThrowVelocity * num \u002B msg.player.estimatedVelocity * 0.5f);\n\t\t\tif (tumbleVelocity \u003E 0f)\n\t\t\t{\n\t\t\t\tbaseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)) * tumbleVelocity);\n\t\t\t}\n\t\t\tbaseEntity.Spawn();\n\t\t\tif (baseEntity is TimedExplosive timedExplosive)\n\t\t\t{\n\t\t\t\tItemOwnershipShare itemOwnership = ownerItem.TakeOwnershipShare();\n\t\t\t\ttimedExplosive.ItemOwnership = itemOwnership;\n\t\t\t\ttimedExplosive.SetCreator(msg.player);\n\t\t\t}\n\t\t\tSetUpThrownWeapon(baseEntity);\n\t\t\tStartAttackCooldown(repeatDelay);\n\t\t\tInterface.CallHook(\u0022OnExplosiveThrown\u0022, msg.player, baseEntity, this);\n\t\t\tUseItemAmount(1, reduceItemOwnership: false);\n\t\t}\n\t}\n",
    "ClassName": "ThrownWeapon",
    "HookLineInvoke": 52
  },
  {
    "HookSignature": "OnXmasGiftsDistribute(XMasRefill xMasRefill, BasePlayer player)",
    "MethodSignature": "DistributeGiftsForPlayer(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool DistributeGiftsForPlayer(BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnXmasGiftsDistribute\u0022, this, player) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tint num = GiftsPerPlayer();\n\t\tint num2 = GiftSpawnAttempts();\n\t\tfor (int i = 0; i \u003C num2; i\u002B\u002B)\n\t\t{\n\t\t\tif (num \u003C= 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVector2 vector = UnityEngine.Random.insideUnitCircle * GiftRadius();\n\t\t\tVector3 pos = player.transform.position \u002B new Vector3(vector.x, 10f, vector.y);\n\t\t\tQuaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);\n\t\t\tif (DropToGround(ref pos))\n\t\t\t{\n\t\t\t\tstring resourcePath = giftPrefabs[UnityEngine.Random.Range(0, giftPrefabs.Length)].resourcePath;\n\t\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(resourcePath, pos, rot);\n\t\t\t\tif ((bool)baseEntity)\n\t\t\t\t{\n\t\t\t\t\tbaseEntity.Spawn();\n\t\t\t\t\tnum--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "XMasRefill",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanRagdollDismount(BaseRagdoll baseRagdoll, BasePlayer player)",
    "MethodSignature": "AllowPlayerInstigatedDismount(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool AllowPlayerInstigatedDismount(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanRagdollDismount\u0022, this, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "BaseRagdoll",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnMapMarkersClear(BasePlayer basePlayer, System.Collections.Generic.List\u003CProtoBuf.MapNote\u003E StatePointsOfInterest)",
    "MethodSignature": "Server_ClearMapMarkers(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\t[RPC_Server.FromOwner(false)]\n\tpublic void Server_ClearMapMarkers(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMapMarkersClear\u0022, this, State.pointsOfInterest) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tServerCurrentDeathNote?.Dispose();\n\t\tServerCurrentDeathNote = null;\n\t\tif (State.pointsOfInterest != null)\n\t\t{\n\t\t\tforeach (MapNote item in State.pointsOfInterest)\n\t\t\t{\n\t\t\t\titem?.Dispose();\n\t\t\t}\n\t\t\tState.pointsOfInterest.Clear();\n\t\t}\n\t\tDirtyPlayerState();\n\t\tTeamUpdate();\n\t\tInterface.CallHook(\u0022OnMapMarkersCleared\u0022, this);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnClientDisconnect(Network.Connection packetConnection, string text)",
    "MethodSignature": "ReadDisconnectReason(Message packet)",
    "MethodSourseCode": "\n\tpublic void ReadDisconnectReason(Message packet)\n\t{\n\t\tstring text = packet.read.String(4096);\n\t\tstring text2 = packet.connection.ToString();\n\t\tif (!string.IsNullOrEmpty(text) \u0026\u0026 !string.IsNullOrEmpty(text2))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnClientDisconnect\u0022, packet.connection, text);\n\t\t\tDebugEx.Log(text2 \u002B \u0022 disconnecting: \u0022 \u002B text);\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnSiegeWeaponFire(Ballista ballistaOwner, BasePlayer player)",
    "MethodSignature": "SERVER_FireClientProjectile(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(1uL)]\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.FromOwner(true)]\n\tprivate void SERVER_FireClientProjectile(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!VerifyClientRPC(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!IsLoaded() || magazine.contents != 1 || player != GetMounted() || !CanFire() || player.InSafeZone() || Interface.CallHook(\u0022OnSiegeWeaponFire\u0022, ballistaOwner, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItemDefinition ammoType = magazine.ammoType;\n\t\t\tif (ammoType == null)\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.LogInvalid(player, null, \u0022item_missing\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItemModProjectile component = ammoType.GetComponent\u003CItemModProjectile\u003E();\n\t\t\tif (!(component == null))\n\t\t\t{\n\t\t\t\tusing (ProjectileShoot projectileShoot = msg.read.Proto\u003CProjectileShoot\u003E())\n\t\t\t\t{\n\t\t\t\t\tif (projectileShoot.projectiles.Count != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Projectile count mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\t\t\tplayer.stats.combat.LogInvalid(player, null, \u0022count_mismatch\u0022);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tplayer.CleanupExpiredProjectiles();\n\t\t\t\t\t\tGuid projectileGroupId = Guid.NewGuid();\n\t\t\t\t\t\tforeach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Duplicate ID (\u0022 \u002B projectile.projectileID \u002B \u0022)\u0022);\n\t\t\t\t\t\t\t\tplayer.stats.combat.LogInvalid(player, null, \u0022duplicate_id\u0022);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (ValidateFirePos(player, projectile.startPos))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, null, ammoType, projectileGroupId, Vector3.zero);\n\t\t\t\t\t\t\t\tEffect effect = new Effect();\n\t\t\t\t\t\t\t\teffect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);\n\t\t\t\t\t\t\t\teffect.scale = 1f;\n\t\t\t\t\t\t\t\teffect.pooledString = component.projectileObject.resourcePath;\n\t\t\t\t\t\t\t\teffect.number = projectile.seed;\n\t\t\t\t\t\t\t\tEffectNetwork.Send(effect);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSendAimDirImmediate(force: true);\n\t\t\t\t\t\tplayer.MarkHostileFor();\n\t\t\t\t\t\tSignalBroadcast(Signal.Attack, string.Empty, msg.connection);\n\t\t\t\t\t\tmagazine.contents = 0;\n\t\t\t\t\t\treloadProgress = 0f;\n\t\t\t\t\t\tSetFlag(Flags.Reserved5, b: false);\n\t\t\t\t\t\tif (HasOwner())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tballistaOwner.RefreshLastUseTime();\n\t\t\t\t\t\t\tballistaOwner.OnFired();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSingletonComponent\u003CNpcNoiseManager\u003E.Instance.OnWeaponShot(player, null);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, null, \u0022mod_missing\u0022);\n\t\t}\n\t}\n",
    "ClassName": "BallistaGun",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnEngineStatsRefresh(VehicleModuleEngine vehicleModuleEngine, Rust.Modular.EngineStorage engineStorage)",
    "MethodSignature": "RefreshPerformanceStats(EngineStorage engineStorage)",
    "MethodSourseCode": "\n\tpublic void RefreshPerformanceStats(EngineStorage engineStorage)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEngineStatsRefresh\u0022, this, engineStorage) == null)\n\t\t{\n\t\t\tif (engineStorage == null)\n\t\t\t{\n\t\t\t\tIsUsable = false;\n\t\t\t\tPerformanceFractionAcceleration = 0f;\n\t\t\t\tPerformanceFractionTopSpeed = 0f;\n\t\t\t\tPerformanceFractionFuelEconomy = 0f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIsUsable = engineStorage.isUsable;\n\t\t\t\tPerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);\n\t\t\t\tPerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);\n\t\t\t\tPerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);\n\t\t\t}\n\t\t\tOverallPerformanceFraction = (PerformanceFractionAcceleration \u002B PerformanceFractionTopSpeed \u002B PerformanceFractionFuelEconomy) / 3f;\n\t\t\tInterface.CallHook(\u0022OnEngineStatsRefreshed\u0022, this, engineStorage);\n\t\t}\n\t}\n",
    "ClassName": "VehicleModuleEngine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerHandcuff(BasePlayer victim, BasePlayer handcuffer)",
    "MethodSignature": "SV_HandcuffVictim(BasePlayer victim, BasePlayer handcuffer)",
    "MethodSourseCode": "\n\tprivate void SV_HandcuffVictim(BasePlayer victim, BasePlayer handcuffer)\n\t{\n\t\tif (victim == null || handcuffer == null || victim.IsRestrained || (!victim.CurrentGestureIsSurrendering \u0026\u0026 !victim.IsWounded()) || Vector3.Distance(victim.transform.position, handcuffer.transform.position) \u003E UseDistance)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem ownerItem = GetOwnerItem();\n\t\tif (ownerItem == null || Interface.CallHook(\u0022OnPlayerHandcuff\u0022, victim, handcuffer) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tvictim.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, b: true);\n\t\tvictim.SendNetworkUpdateImmediate();\n\t\townerItem.SetFlag(Item.Flag.IsOn, b: true);\n\t\tbool flag = true;\n\t\tif (!ownerItem.MoveToContainer(victim.inventory.containerBelt))\n\t\t{\n\t\t\tItem slot = victim.inventory.containerBelt.GetSlot(0);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tif (!slot.MoveToContainer(victim.inventory.containerMain))\n\t\t\t\t{\n\t\t\t\t\tif (slot.contents != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot.contents.SetLocked(isLocked: false, lockSubItems: true);\n\t\t\t\t\t}\n\t\t\t\t\tslot.DropAndTossUpwards(victim.transform.position);\n\t\t\t\t}\n\t\t\t\tif (!ownerItem.MoveToContainer(victim.inventory.containerBelt))\n\t\t\t\t{\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!flag)\n\t\t{\n\t\t\townerItem.SetFlag(Item.Flag.IsOn, b: false);\n\t\t\tvictim.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, b: false);\n\t\t}\n\t\townerItem.MarkDirty();\n\t\tif (flag)\n\t\t{\n\t\t\tvictim.Server_CancelGesture();\n\t\t\tif (victim.IsBot)\n\t\t\t{\n\t\t\t\tInventory.EquipItemInSlot(victim, 0);\n\t\t\t}\n\t\t\tvictim.ClientRPC(RpcTarget.Player(\u0022SetActiveBeltSlot\u0022, victim), ownerItem.position, ownerItem.uid);\n\t\t\tSetLocked(flag: true, victim, ownerItem);\n\t\t\tEffect.server.Run(lockEffect.resourcePath, victim, 0u, Vector3.zero, Vector3.zero);\n\t\t\tInterface.CallHook(\u0022OnPlayerHandcuffed\u0022, victim, handcuffer);\n\t\t}\n\t}\n",
    "ClassName": "Handcuffs",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnOvenStart(BaseOven baseOven)",
    "MethodSignature": "StartCooking()",
    "MethodSourseCode": "\n\tpublic virtual void StartCooking()\n\t{\n\t\tif (Interface.CallHook(\u0022OnOvenStart\u0022, this) == null \u0026\u0026 (FindBurnable() != null || CanRunWithNoFuel))\n\t\t{\n\t\t\tbase.inventory.temperature = cookingTemperature;\n\t\t\tUpdateAttachmentTemperature();\n\t\t\tInvokeRepeating(Cook, 0.5f, 0.5f);\n\t\t\tif (visualFood)\n\t\t\t{\n\t\t\t\tInvokeRepeating(CookVisuals, 0f, 0.05f);\n\t\t\t}\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tInterface.CallHook(\u0022OnOvenStarted\u0022, this);\n\t\t\tif (hasOpenFlame)\n\t\t\t{\n\t\t\t\tSingletonComponent\u003CNpcFireManager\u003E.Instance.Add(this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTurretModeToggle(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "SERVER_Peacekeeper(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tprivate void SERVER_Peacekeeper(RPCMessage rpc)\n\t{\n\t\tif (IsAuthed(rpc.player) \u0026\u0026 Interface.CallHook(\u0022OnTurretModeToggle\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tSetPeacekeepermode(isOn: true);\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanUseFuel(EntityFuelSystem entityFuelSystem, StorageContainer fuelContainer, float seconds, float fuelUsedPerSecond)",
    "MethodSignature": "TryUseFuel(float seconds, float fuelUsedPerSecond)",
    "MethodSourseCode": "\n\tpublic int TryUseFuel(float seconds, float fuelUsedPerSecond)\n\t{\n\t\tStorageContainer fuelContainer = GetFuelContainer();\n\t\tobject obj = Interface.CallHook(\u0022CanUseFuel\u0022, this, fuelContainer, seconds, fuelUsedPerSecond);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tif (fuelContainer == null)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tItem slot = fuelContainer.inventory.GetSlot(0);\n\t\tif (slot == null || slot.amount \u003C 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tpendingFuel \u002B= seconds * fuelUsedPerSecond;\n\t\tif (pendingFuel \u003E= 1f)\n\t\t{\n\t\t\tint num = Mathf.FloorToInt(pendingFuel);\n\t\t\tslot.UseItem(num);\n\t\t\tFacepunch.Rust.Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, num, \u0022fuel_system\u0022);\n\t\t\tpendingFuel -= num;\n\t\t\treturn num;\n\t\t}\n\t\treturn 0;\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnVehicleModuleSelect(Item vehicleItem, ModularCarGarage modularCarGarage, BasePlayer player)",
    "MethodSignature": "RPC_SelectedLootItem(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void RPC_SelectedLootItem(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tItemId itemUID = msg.read.ItemID();\n\t\tif (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem vehicleItem = carOccupant.GetVehicleItem(itemUID);\n\t\tif (vehicleItem == null || Interface.CallHook(\u0022OnVehicleModuleSelect\u0022, vehicleItem, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = player.inventory.loot.RemoveContainerAt(3);\n\t\tif (TryGetModuleForItem(vehicleItem, out var result))\n\t\t{\n\t\t\tif (result is VehicleModuleStorage vehicleModuleStorage)\n\t\t\t{\n\t\t\t\tIItemContainerEntity container = vehicleModuleStorage.GetContainer();\n\t\t\t\tif (!ObjectEx.IsUnityNull(container))\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.loot.AddContainer(container.inventory);\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (result is VehicleModuleCamper vehicleModuleCamper)\n\t\t\t{\n\t\t\t\tIItemContainerEntity container2 = vehicleModuleCamper.GetContainer();\n\t\t\t\tif (!ObjectEx.IsUnityNull(container2))\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.loot.AddContainer(container2.inventory);\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t}\n\t\tInterface.CallHook(\u0022OnVehicleModuleSelected\u0022, vehicleItem, this, player);\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "CanCreateWorldProjectile(HitInfo info, ItemDefinition itemDef)",
    "MethodSignature": "CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)",
    "MethodSourseCode": "\n\tprotected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)\n\t{\n\t\tif (Interface.CallHook(\u0022CanCreateWorldProjectile\u0022, info, itemDef) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 projectileVelocity = info.ProjectileVelocity;\n\t\tItem item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));\n\t\tif (Interface.CallHook(\u0022OnWorldProjectileCreate\u0022, info, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = null;\n\t\tif (!info.DidHit)\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\treturn;\n\t\t}\n\t\tif (projectilePrefab.breakProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.breakProbability)\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\treturn;\n\t\t}\n\t\tif (projectilePrefab.conditionLoss \u003E 0f)\n\t\t{\n\t\t\titem.LoseCondition(projectilePrefab.conditionLoss * 100f);\n\t\t\tif (item.isBroken)\n\t\t\t{\n\t\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (projectilePrefab.stickProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.stickProbability)\n\t\t{\n\t\t\tbaseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));\n\t\t\tDroppedItem droppedItem = baseEntity as DroppedItem;\n\t\t\tif (droppedItem != null)\n\t\t\t{\n\t\t\t\tdroppedItem.StickIn();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbaseEntity.GetComponent\u003CRigidbody\u003E().isKinematic = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tRigidbody component = baseEntity.GetComponent\u003CRigidbody\u003E();\n\t\t\tcomponent.AddForce(projectileVelocity.normalized * 200f);\n\t\t\tcomponent.WakeUp();\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnActiveItemChanged(BasePlayer basePlayer, Item activeItem, Item activeItem2)",
    "MethodSignature": "UpdateActiveItem(ItemId itemID)",
    "MethodSourseCode": "\n\tpublic void UpdateActiveItem(ItemId itemID)\n\t{\n\t\tAssert.IsTrue(base.isServer, \u0022Realm should be server!\u0022);\n\t\tif (svActiveItemID == itemID)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (equippingBlocked)\n\t\t{\n\t\t\titemID = default(ItemId);\n\t\t}\n\t\tItem item = inventory.containerBelt.FindItemByUID(itemID);\n\t\tif (IsItemHoldRestricted(item))\n\t\t{\n\t\t\titemID = default(ItemId);\n\t\t}\n\t\tItem activeItem = GetActiveItem();\n\t\tif (Interface.CallHook(\u0022OnActiveItemChange\u0022, this, activeItem, itemID) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tsvActiveItemID = default(ItemId);\n\t\tif (activeItem != null)\n\t\t{\n\t\t\tHeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;\n\t\t\tif (heldEntity != null)\n\t\t\t{\n\t\t\t\theldEntity.SetHeld(bHeld: false);\n\t\t\t}\n\t\t}\n\t\tsvActiveItemID = itemID;\n\t\tSendNetworkUpdate();\n\t\tItem activeItem2 = GetActiveItem();\n\t\tif (activeItem2 != null)\n\t\t{\n\t\t\tHeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;\n\t\t\tif (heldEntity2 != null)\n\t\t\t{\n\t\t\t\theldEntity2.SetHeld(bHeld: true);\n\t\t\t}\n\t\t\tNotifyGesturesNewItemEquipped();\n\t\t}\n\t\tinventory.UpdatedVisibleHolsteredItems();\n\t\tInterface.CallHook(\u0022OnActiveItemChanged\u0022, this, activeItem, activeItem2);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "OnPlayerSleepEnd(BasePlayer basePlayer)",
    "MethodSignature": "EndSleeping()",
    "MethodSourseCode": "\n\tpublic virtual void EndSleeping()\n\t{\n\t\tif (IsSleeping() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSleepEnd\u0022, this) == null)\n\t\t{\n\t\t\tif (IsRestrained)\n\t\t\t{\n\t\t\t\tinventory.SetLockedByRestraint(flag: true);\n\t\t\t}\n\t\t\tSetPlayerFlag(PlayerFlags.Sleeping, b: false);\n\t\t\tsleepStartTime = -1f;\n\t\t\tsleepingPlayerList.Remove(this);\n\t\t\tif ((ulong)userID \u003C 10000000 \u0026\u0026 !bots.Contains(this))\n\t\t\t{\n\t\t\t\tbots.Add(this);\n\t\t\t}\n\t\t\tCancelInvoke(ScheduledDeath);\n\t\t\tInvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));\n\t\t\tif (RelationshipManager.TeamsEnabled())\n\t\t\t{\n\t\t\t\tInvokeRandomized(TeamUpdate, 1f, 4f, 1f);\n\t\t\t}\n\t\t\tInvokeRandomized(UpdateClanLastSeen, 300f, 300f, 60f);\n\t\t\tEnablePlayerCollider();\n\t\t\tAddPlayerRigidbody();\n\t\t\tSetServerFall(wantsOn: false);\n\t\t\tRunOfflineMetabolism(state: false);\n\t\t\tif (HasParent())\n\t\t\t{\n\t\t\t\tSetParent(null, worldPositionStays: true);\n\t\t\t\tRemoveFromTriggers();\n\t\t\t\tForceUpdateTriggers();\n\t\t\t}\n\t\t\tinventory.containerMain.OnChanged();\n\t\t\tinventory.containerBelt.OnChanged();\n\t\t\tinventory.containerWear.OnChanged();\n\t\t\tInterface.CallHook(\u0022OnPlayerSleepEnded\u0022, this);\n\t\t\tEACServer.LogPlayerSpawn(this);\n\t\t\tif (TotalPingCount \u003E 0)\n\t\t\t{\n\t\t\t\tSendPingsToClient();\n\t\t\t}\n\t\t\tif (TutorialIsland.ShouldPlayerBeAskedToStartTutorial(this))\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022PromptToStartTutorial\u0022, this));\n\t\t\t}\n\t\t\tif (AntiHack.TestNoClipping(this, base.transform.position, base.transform.position, NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _))\n\t\t\t{\n\t\t\t\tForceCastNoClip();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPhoneDialFail(PhoneController phoneController, Telephone.DialFailReason reason, BasePlayer currentPlayer)",
    "MethodSignature": "OnDialFailed(Telephone.DialFailReason reason)",
    "MethodSourseCode": "\n\tpublic void OnDialFailed(Telephone.DialFailReason reason)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneDialFail\u0022, this, reason, currentPlayer) == null)\n\t\t{\n\t\t\tSetPhoneState(Telephone.CallState.Idle);\n\t\t\tbase.baseEntity.ClientRPC(RpcTarget.NetworkGroup(\u0022ClientOnDialFailed\u0022), (int)reason);\n\t\t\tactiveCallTo = null;\n\t\t\tif (IsInvoking(TimeOutCall))\n\t\t\t{\n\t\t\t\tCancelInvoke(TimeOutCall);\n\t\t\t}\n\t\t\tif (IsInvoking(TriggerTimeOut))\n\t\t\t{\n\t\t\t\tCancelInvoke(TriggerTimeOut);\n\t\t\t}\n\t\t\tif (IsInvoking(TimeOutDialing))\n\t\t\t{\n\t\t\t\tCancelInvoke(TimeOutDialing);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPhoneDialFailed\u0022, this, reason, currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerCorpseSpawned(BasePlayer basePlayer, PlayerCorpse playerCorpse)",
    "MethodSignature": "CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List\u003CTriggerBase\u003E triggersOnDeath, bool forceServerSide)",
    "MethodSourseCode": "\n\tpublic virtual BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List\u003CTriggerBase\u003E triggersOnDeath, bool forceServerSide = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerCorpseSpawn\u0022, this) != null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tstring strCorpsePrefab = ((!(ConVar.Physics.serversideragdolls || forceServerSide)) ? \u0022assets/prefabs/player/player_corpse.prefab\u0022 : \u0022assets/prefabs/player/player_corpse_new.prefab\u0022);\n\t\t\tbool flag = false;\n\t\t\tif (ConVar.Global.cinematicGingerbreadCorpses)\n\t\t\t{\n\t\t\t\tforeach (Item item in inventory.containerWear.itemList)\n\t\t\t\t{\n\t\t\t\t\tif (item != null \u0026\u0026 item.info.TryGetComponent\u003CItemCorpseOverride\u003E(out var component))\n\t\t\t\t\t{\n\t\t\t\t\t\tstrCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) \u003E 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);\n\t\t\t\t\t\tflag = component.BlockWearableCopy;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab, posOnDeath, rotOnDeath, flagsOnDeath, modelState) as PlayerCorpse;\n\t\t\tif ((bool)playerCorpse)\n\t\t\t{\n\t\t\t\tplayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tif (!flag)\n\t\t\t\t{\n\t\t\t\t\tplayerCorpse.TakeFrom(this, inventory.containerMain, inventory.containerWear, inventory.containerBelt);\n\t\t\t\t}\n\t\t\t\tplayerCorpse.playerName = displayName;\n\t\t\t\tplayerCorpse.streamerName = RandomUsernames.Get(userID);\n\t\t\t\tplayerCorpse.playerSteamID = userID;\n\t\t\t\tplayerCorpse.underwearSkin = GetUnderwearSkin();\n\t\t\t\tif (!CollectionEx.IsNullOrEmpty(triggersOnDeath))\n\t\t\t\t{\n\t\t\t\t\tforeach (TriggerBase item2 in triggersOnDeath)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (item2 is TriggerParent triggerParent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttriggerParent.ForceParentEarly(playerCorpse);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tplayerCorpse.Spawn();\n\t\t\t\tplayerCorpse.TakeChildren(this);\n\t\t\t\tResourceDispenser component2 = playerCorpse.GetComponent\u003CResourceDispenser\u003E();\n\t\t\t\tint num = 2;\n\t\t\t\tif (lifeStory != null)\n\t\t\t\t{\n\t\t\t\t\tnum \u002B= Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);\n\t\t\t\t}\n\t\t\t\tcomponent2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition(\u0022fat.animal\u0022), num));\n\t\t\t\tInterface.CallHook(\u0022OnPlayerCorpseSpawned\u0022, this, playerCorpse);\n\t\t\t\treturn playerCorpse;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t\tstatic float GetFloatBasedOnUserID(ulong steamid, ulong seed)\n\t\t{\n\t\t\tUnityEngine.Random.State state = UnityEngine.Random.state;\n\t\t\tUnityEngine.Random.InitState((int)(seed \u002B steamid));\n\t\t\tfloat result = UnityEngine.Random.Range(0f, 1f);\n\t\t\tUnityEngine.Random.state = state;\n\t\t\treturn result;\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 54
  },
  {
    "HookSignature": "OnLootPlayer(BasePlayer basePlayer, BasePlayer player)",
    "MethodSignature": "RPC_LootPlayer(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_LootPlayer(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 CanBeLooted(player) \u0026\u0026 player.inventory.loot.StartLootingEntity(this))\n\t\t{\n\t\t\tplayer.inventory.loot.AddContainer(inventory.containerMain);\n\t\t\tplayer.inventory.loot.AddContainer(inventory.containerWear);\n\t\t\tplayer.inventory.loot.AddContainer(inventory.containerBelt);\n\t\t\tInterface.CallHook(\u0022OnLootPlayer\u0022, this, player);\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tplayer.RadioactiveLootCheck(player.inventory.loot.containers);\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022RPC_OpenLootPanel\u0022, player), \u0022player_corpse\u0022);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "CanWaterBallSplash(ItemDefinition liquidDef, UnityEngine.Vector3 position, float radius, int amount, bool funWater)",
    "MethodSignature": "DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount, bool funWater)",
    "MethodSourseCode": "\n\tpublic static bool DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount, bool funWater = false)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanWaterBallSplash\u0022, liquidDef, position, radius, amount, funWater);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tList\u003CBaseEntity\u003E obj2 = Pool.Get\u003CList\u003CBaseEntity\u003E\u003E();\n\t\tVis.Entities(position, radius, obj2, 1220225811);\n\t\tint num = 0;\n\t\tint num2 = amount;\n\t\tbool flag = false;\n\t\twhile (amount \u003E 0 \u0026\u0026 num \u003C 3)\n\t\t{\n\t\t\tList\u003CISplashable\u003E obj3 = Pool.Get\u003CList\u003CISplashable\u003E\u003E();\n\t\t\tforeach (BaseEntity item in obj2)\n\t\t\t{\n\t\t\t\tif (item.isClient || !(item is ISplashable splashable) || obj3.Contains(splashable) || !splashable.WantsSplash(liquidDef, amount))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool flag2 = true;\n\t\t\t\tbool flag3 = item is PlanterBox;\n\t\t\t\tbool flag4 = item is TimedExplosive;\n\t\t\t\tif (flag3 || flag4)\n\t\t\t\t{\n\t\t\t\t\tVector3 vector = Vector3.zero;\n\t\t\t\t\tif (flag3)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector = Vector3.up;\n\t\t\t\t\t}\n\t\t\t\t\tif (!GamePhysics.LineOfSight(item.transform.position \u002B vector, position, 2097152))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag2 = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (flag2)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag2)\n\t\t\t\t{\n\t\t\t\t\tobj3.Add(splashable);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (obj3.Count == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint b = Mathf.CeilToInt(amount / obj3.Count);\n\t\t\tforeach (ISplashable item2 in obj3)\n\t\t\t{\n\t\t\t\tif (!flag || !(item2 is BasePlayer))\n\t\t\t\t{\n\t\t\t\t\tint num3 = 0;\n\t\t\t\t\tBasePlayer basePlayer = item2 as BasePlayer;\n\t\t\t\t\tnum3 = ((!((object)basePlayer != null \u0026\u0026 funWater)) ? item2.DoSplash(liquidDef, Mathf.Min(amount, b)) : basePlayer.DoSplashFunWater(liquidDef, Mathf.Min(amount, b)));\n\t\t\t\t\tamount -= num3;\n\t\t\t\t\tif (amount \u003C= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPool.FreeUnmanaged(ref obj3);\n\t\t\tnum\u002B\u002B;\n\t\t}\n\t\tPool.FreeUnmanaged(ref obj2);\n\t\treturn amount \u003C num2;\n\t}\n",
    "ClassName": "WaterBall",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanCheckFuel(EntityFuelSystem entityFuelSystem, StorageContainer fuelContainer, BasePlayer player)",
    "MethodSignature": "IsInFuelInteractionRange(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool IsInFuelInteractionRange(BasePlayer player)\n\t{\n\t\tStorageContainer fuelContainer = GetFuelContainer();\n\t\tobject obj = Interface.CallHook(\u0022CanCheckFuel\u0022, this, fuelContainer, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (fuelContainer != null)\n\t\t{\n\t\t\tfloat num = 0f;\n\t\t\tif (isServer)\n\t\t\t{\n\t\t\t\tnum = 3f;\n\t\t\t}\n\t\t\treturn fuelContainer.Distance(player.eyes.position) \u003C= num;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnRfFrequencyChange(RFBroadcaster rFBroadcaster, int freq, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(3uL)]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!CanChangeFrequency(msg.player) || UnityEngine.Time.time \u003C nextChangeTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\tint freq = msg.read.Int32();\n\t\tfreq = RFManager.ClampFrequency(freq);\n\t\tif (RFManager.IsReserved(freq))\n\t\t{\n\t\t\tRFManager.ReserveErrorPrint(msg.player);\n\t\t\treturn;\n\t\t}\n\t\tRFManager.ChangeFrequency(frequency, freq, this, isListener: false, IsPowered());\n\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, freq, msg.player) == null)\n\t\t{\n\t\t\tfrequency = freq;\n\t\t\tMarkDirty();\n\t\t\tSendNetworkUpdate();\n\t\t\tHurt(MaxHealth() * 0.01f, DamageType.Decay, this);\n\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, freq, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "RFBroadcaster",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnSwitchToggle(IndustrialConveyor industrialConveyor, BasePlayer msgPlayer)",
    "MethodSignature": "SvSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(2uL)]\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void SvSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tSetSwitch(!IsOn());\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "IndustrialConveyor",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerSleep(BasePlayer basePlayer)",
    "MethodSignature": "StartSleeping()",
    "MethodSourseCode": "\n\tpublic virtual void StartSleeping()\n\t{\n\t\tif (!IsSleeping())\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerSleep\u0022, this);\n\t\t\tif (IsRestrained)\n\t\t\t{\n\t\t\t\tinventory.SetLockedByRestraint(flag: false);\n\t\t\t}\n\t\t\tif (InSafeZone() \u0026\u0026 !IsInvoking(ScheduledDeath))\n\t\t\t{\n\t\t\t\tInvoke(ScheduledDeath, NPCAutoTurret.sleeperhostiledelay);\n\t\t\t}\n\t\t\tBaseMountable baseMountable = GetMounted();\n\t\t\tif (baseMountable != null \u0026\u0026 !AllowSleeperMounting(baseMountable))\n\t\t\t{\n\t\t\t\tEnsureDismounted();\n\t\t\t}\n\t\t\tSetPlayerFlag(PlayerFlags.Sleeping, b: true);\n\t\t\tsleepStartTime = UnityEngine.Time.time;\n\t\t\tsleepingPlayerList.TryAdd(this);\n\t\t\tbots.Remove(this);\n\t\t\tCancelInvoke(InventoryUpdate);\n\t\t\tCancelInvoke(TeamUpdate);\n\t\t\tCancelInvoke(UpdateClanLastSeen);\n\t\t\tinventory.loot.Clear();\n\t\t\tinventory.containerMain.OnChanged();\n\t\t\tinventory.containerBelt.OnChanged();\n\t\t\tinventory.containerWear.OnChanged();\n\t\t\tEnablePlayerCollider();\n\t\t\tif (!IsLoadingAfterTransfer())\n\t\t\t{\n\t\t\t\tRemovePlayerRigidbody();\n\t\t\t\tTurnOffAllLights();\n\t\t\t}\n\t\t\tSetServerFall(wantsOn: true);\n\t\t\tRunOfflineMetabolism(state: true);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnNetworkGroupEntered(BaseNetworkable baseNetworkable, Network.Visibility.Group group)",
    "MethodSignature": "OnNetworkGroupEnter(Group group)",
    "MethodSourseCode": "\n\tpublic virtual void OnNetworkGroupEnter(Group group)\n\t{\n\t\tInterface.CallHook(\u0022OnNetworkGroupEntered\u0022, this, group);\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnServerRestart(string strNotice, int iSeconds)",
    "MethodSignature": "RestartServer(string strNotice, int iSeconds)",
    "MethodSourseCode": "\n\tpublic static void RestartServer(string strNotice, int iSeconds)\n\t{\n\t\tif (SingletonComponent\u003CServerMgr\u003E.Instance == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (SingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine != null)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnServerRestartInterrupt\u0022) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tShowToastToAllClients(GameTip.Styles.Server_Event, RESTART_INTERRUPTED_PHRASE, false);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.StopCoroutine(SingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine = null;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnServerRestart\u0022, strNotice, iSeconds) == null)\n\t\t{\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine = SingletonComponent\u003CServerMgr\u003E.Instance.ServerRestartWarning(strNotice, iSeconds);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.StartCoroutine(SingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.UpdateServerInformation();\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "CanCatchFish(BasePlayer ownerPlayer, BaseFishingRod baseFishingRod, Item item)",
    "MethodSignature": "CatchProcessBudgeted()",
    "MethodSourseCode": "\n\tprivate void CatchProcessBudgeted()\n\t{\n\t\tinQueue = false;\n\t\tFishingBobber fishingBobber = currentBobber.Get(serverside: true);\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)\n\t\t{\n\t\t\tServer_Cancel(FailReason.UserRequested);\n\t\t\treturn;\n\t\t}\n\t\tVector3 position = ownerPlayer.transform.position;\n\t\tfloat num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));\n\t\tfloat num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));\n\t\tif (num \u003E ((num2 \u003E 1.2f) ? 60f : 180f))\n\t\t{\n\t\t\tServer_Cancel(FailReason.BadAngle);\n\t\t\treturn;\n\t\t}\n\t\tif (num2 \u003E 1.2f \u0026\u0026 (float)lastSightCheck \u003E 0.4f)\n\t\t{\n\t\t\tif (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))\n\t\t\t{\n\t\t\t\tServer_Cancel(FailReason.Obstructed);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastSightCheck = 0f;\n\t\t}\n\t\tif (Vector3.Distance(position, fishingBobber.transform.position) \u003E MaxCastDistance * 2f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TooFarAway);\n\t\t\treturn;\n\t\t}\n\t\tif (Vector3.Distance(playerStartPosition, position) \u003E 1f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.PlayerMoved);\n\t\t\treturn;\n\t\t}\n\t\tif (CurrentState == CatchState.Waiting)\n\t\t{\n\t\t\tif ((float)catchTime \u003C 0f)\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_HookedSomething\u0022));\n\t\t\t\tCurrentState = CatchState.Catching;\n\t\t\t\tfishingBobber.SetFlag(Flags.Reserved1, b: true);\n\t\t\t\tnextFishStateChange = 0f;\n\t\t\t\tfishCatchDuration = 0f;\n\t\t\t\tstrainTimer = 0f;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tFishState fishState = currentFishState;\n\t\tif ((float)nextFishStateChange \u003C 0f)\n\t\t{\n\t\t\tfloat num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);\n\t\t\tif (currentFishState != 0)\n\t\t\t{\n\t\t\t\tcurrentFishState = (FishState)0;\n\t\t\t\tnextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 \u002B 1f);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003C 50)\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState = FishState.PullingLeft;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState = FishState.PullingRight;\n\t\t\t\t}\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003E 60 \u0026\u0026 Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) \u003C MaxCastDistance - 2f)\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState |= FishState.PullingBack;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((float)fishCatchDuration \u003E 120f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TimeOut);\n\t\t\treturn;\n\t\t}\n\t\tbool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);\n\t\tbool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);\n\t\tbool flag3 = HasReelInInput(ownerPlayer.serverInput);\n\t\tif (flag2 \u0026\u0026 flag)\n\t\t{\n\t\t\tflag2 = (flag = false);\n\t\t}\n\t\tUpdateFlags(flag2, flag, flag3);\n\t\tif (CurrentState == CatchState.Waiting)\n\t\t{\n\t\t\tflag = (flag2 = (flag3 = false));\n\t\t}\n\t\tif (flag2 \u0026\u0026 !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\n\t\t{\n\t\t\tflag2 = false;\n\t\t}\n\t\tif (flag \u0026\u0026 !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\n\t\t{\n\t\t\tflag = false;\n\t\t}\n\t\tfloat value = ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f);\n\t\tfishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier, value);\n\t\tbool flag4 = false;\n\t\tfloat num4 = 0f;\n\t\tif (flag3 || flag2 || flag)\n\t\t{\n\t\t\tflag4 = true;\n\t\t\tnum4 = 0.5f;\n\t\t}\n\t\tif (currentFishState != 0 \u0026\u0026 flag4)\n\t\t{\n\t\t\tif (currentFishState.Contains(FishState.PullingBack) \u0026\u0026 flag3)\n\t\t\t{\n\t\t\t\tnum4 = 1.5f;\n\t\t\t}\n\t\t\telse if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) \u0026\u0026 flag3)\n\t\t\t{\n\t\t\t\tnum4 = 1.2f;\n\t\t\t}\n\t\t\telse if (currentFishState.Contains(FishState.PullingLeft) \u0026\u0026 flag)\n\t\t\t{\n\t\t\t\tnum4 = 0.8f;\n\t\t\t}\n\t\t\telse if (currentFishState.Contains(FishState.PullingRight) \u0026\u0026 flag2)\n\t\t\t{\n\t\t\t\tnum4 = 0.8f;\n\t\t\t}\n\t\t}\n\t\tif (flag3 \u0026\u0026 currentFishState != 0)\n\t\t{\n\t\t\tnum4 \u002B= 1f;\n\t\t}\n\t\tnum4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;\n\t\tnum4 -= ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f) - 1f;\n\t\tif (flag4)\n\t\t{\n\t\t\tstrainTimer \u002B= UnityEngine.Time.deltaTime * num4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);\n\t\t}\n\t\tfloat num5 = strainTimer / 6f;\n\t\tSetFlag(Flags.Reserved1, flag4 \u0026\u0026 num5 \u003E 0.25f);\n\t\tif ((float)lastStrainUpdate \u003E 0.4f || fishState != currentFishState)\n\t\t{\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_UpdateFishState\u0022), (int)currentFishState, num5);\n\t\t\tlastStrainUpdate = 0f;\n\t\t}\n\t\tif (strainTimer \u003E 7f || ForceFail)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TensionBreak);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!(num2 \u003C= FishCatchDistance) \u0026\u0026 !ForceSuccess)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tCurrentState = CatchState.Caught;\n\t\t\tif (currentFishTarget != null)\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(currentFishTarget, 1, 0uL);\n\t\t\t\titem.SetItemOwnership(ownerPlayer, ItemOwnershipPhrases.Fishing);\n\t\t\t\tobject obj = Interface.CallHook(\u0022CanCatchFish\u0022, ownerPlayer, this, item);\n\t\t\t\tif (obj is bool \u0026\u0026 !(bool)obj)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobject obj2 = Interface.CallHook(\u0022OnFishCatch\u0022, item, this, ownerPlayer);\n\t\t\t\tif (obj2 is Item \u0026\u0026 obj2 as Item != item)\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t\titem = (Item)obj2;\n\t\t\t\t}\n\t\t\t\townerPlayer.GiveItem(item, GiveItemReason.Crafted);\n\t\t\t\tif (currentFishTarget.shortname == \u0022skull.human\u0022)\n\t\t\t\t{\n\t\t\t\t\titem.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));\n\t\t\t\t}\n\t\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 !string.IsNullOrEmpty(fishableModifier.SteamStatName))\n\t\t\t\t{\n\t\t\t\t\townerPlayer.stats.Add(fishableModifier.SteamStatName, 1);\n\t\t\t\t\townerPlayer.stats.Save(forceSteamSave: true);\n\t\t\t\t\tFishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);\n\t\t\t\t}\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnCaughtFish(ownerPlayer, item);\n\t\t\t}\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_OnCaughtFish\u0022), currentFishTarget.itemid);\n\t\t\townerPlayer.SignalBroadcast(Signal.Alt_Attack);\n\t\t\tInvoke(ResetLine, 6f);\n\t\t\tfishingBobber.Kill();\n\t\t\tcurrentBobber.Set(null);\n\t\t\tCancelInvoke(CatchProcess);\n\t\t\tInterface.CallHook(\u0022OnFishCaught\u0022, currentFishTarget, this, ownerPlayer);\n\t\t}\n\t}\n",
    "ClassName": "BaseFishingRod",
    "HookLineInvoke": 166
  },
  {
    "HookSignature": "OnNpcConversationEnded(NPCTalking nPCTalking, BasePlayer player)",
    "MethodSignature": "OnConversationEnded(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void OnConversationEnded(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnNpcConversationEnded\u0022, this, player);\n\t\tif (conversingPlayers.Contains(player))\n\t\t{\n\t\t\tconversingPlayers.Remove(player);\n\t\t}\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnArcadeScoreAdded(BaseArcadeMachine baseArcadeMachine, BasePlayer player, int score)",
    "MethodSignature": "AddScore(BasePlayer player, int score)",
    "MethodSourseCode": "\n\tpublic void AddScore(BasePlayer player, int score)\n\t{\n\t\tScoreEntry scoreEntry = new ScoreEntry();\n\t\tscoreEntry.displayName = player.displayName;\n\t\tscoreEntry.score = score;\n\t\tscoreEntry.playerID = player.userID;\n\t\tscores.Add(scoreEntry);\n\t\tscores.Sort((ScoreEntry a, ScoreEntry b) =\u003E b.score.CompareTo(a.score));\n\t\tscores.TrimExcess();\n\t\tSendNetworkUpdate();\n\t\tInterface.CallHook(\u0022OnArcadeScoreAdded\u0022, this, player, score);\n\t}\n",
    "ClassName": "BaseArcadeMachine",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPlanterBoxFertilize(PlanterBox planterBox)",
    "MethodSignature": "FertilizeGrowables()",
    "MethodSourseCode": "\n\tpublic void FertilizeGrowables()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlanterBoxFertilize\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = GetFertilizerCount();\n\t\tif (num \u003C= 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (BaseEntity child in children)\n\t\t{\n\t\t\tif (child == null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tGrowableEntity growableEntity = child as GrowableEntity;\n\t\t\tif (!(growableEntity == null) \u0026\u0026 !growableEntity.Fertilized \u0026\u0026 ConsumeFertilizer())\n\t\t\t{\n\t\t\t\tgrowableEntity.Fertilize();\n\t\t\t\tnum--;\n\t\t\t\tif (num == 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlanterBox",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnLiftUse(ProceduralLift proceduralLift, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_UseLift(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_UseLift(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 Interface.CallHook(\u0022OnLiftUse\u0022, this, rpc.player) == null \u0026\u0026 !IsBusy())\n\t\t{\n\t\t\tMoveToFloor((floorIndex \u002B 1) % stops.Length);\n\t\t}\n\t}\n",
    "ClassName": "ProceduralLift",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnTrapSnapped(BaseTrapTrigger baseTrapTrigger, UnityEngine.GameObject obj, UnityEngine.Collider col)",
    "MethodSignature": "OnObjectAdded(GameObject obj, Collider col)",
    "MethodSourseCode": "\n\tinternal override void OnObjectAdded(GameObject obj, Collider col)\n\t{\n\t\tInterface.CallHook(\u0022OnTrapSnapped\u0022, this, obj, col);\n\t\tbase.OnObjectAdded(obj, col);\n\t\t_trap.ObjectEntered(obj);\n\t}\n",
    "ClassName": "BaseTrapTrigger",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDispenserGathered(ResourceDispenser resourceDispenser, BasePlayer entity, Item item)",
    "MethodSignature": "GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)",
    "MethodSourseCode": "\n\tprivate void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)\n\t{\n\t\tif (itemAmt.amount == 0f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();\n\t\tfloat num2 = itemAmt.startAmount / startingItemCounts;\n\t\tfloat f = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);\n\t\tf = Mathf.Round(f);\n\t\tfloat num3 = f * destroyFraction * 2f;\n\t\tif (itemAmt.amount \u003C= f \u002B num3)\n\t\t{\n\t\t\tfloat num4 = (f \u002B num3) / itemAmt.amount;\n\t\t\tf /= num4;\n\t\t\tnum3 /= num4;\n\t\t}\n\t\titemAmt.amount -= Mathf.Floor(f);\n\t\titemAmt.amount -= Mathf.Floor(num3);\n\t\tif (f \u003C 1f)\n\t\t{\n\t\t\tf = ((UnityEngine.Random.Range(0f, 1f) \u003C= f) ? 1f : 0f);\n\t\t\titemAmt.amount = 0f;\n\t\t}\n\t\tif (itemAmt.amount \u003C 0f)\n\t\t{\n\t\t\titemAmt.amount = 0f;\n\t\t}\n\t\tif (!(f \u003E= 1f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num5 = CalculateGatherBonus(entity, itemAmt, f);\n\t\tint iAmount = Mathf.FloorToInt(f) \u002B num5;\n\t\tItem item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);\n\t\tif (Interface.CallHook(\u0022OnDispenserGather\u0022, this, entity, item) == null \u0026\u0026 item != null)\n\t\t{\n\t\t\tApplyItemOwnership(entity, item);\n\t\t\tOverrideOwnership(item, attackWeapon);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);\n\t\t\tInterface.CallHook(\u0022OnDispenserGathered\u0022, this, entity, item);\n\t\t\twhile (item.amount \u003E item.MaxStackable())\n\t\t\t{\n\t\t\t\tItem item2 = item.SplitItem(item.MaxStackable());\n\t\t\t\tentity.GiveItem(item2, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t\t}\n\t\t\tentity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t}\n\t}\n",
    "ClassName": "ResourceDispenser",
    "HookLineInvoke": 41
  },
  {
    "HookSignature": "OnTurretDeauthorize(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "RemoveSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void RemoveSelfAuthorize(RPCMessage rpc)\n\t{\n\t\tRPCMessage rpc2 = rpc;\n\t\tif (!booting \u0026\u0026 !IsOnline() \u0026\u0026 IsAuthed(rpc2.player) \u0026\u0026 Interface.CallHook(\u0022OnTurretDeauthorize\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.RemoveWhere((PlayerNameID x) =\u003E x.userid == (ulong)rpc2.player.userID);\n\t\t\tauthDirty = true;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022removed\u0022, rpc2.player.userID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnTurretAssign(AutoTurret autoTurret, ulong num, BasePlayer msgPlayer)",
    "MethodSignature": "AssignToFriend(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void AssignToFriend(RPCMessage msg)\n\t{\n\t\tif (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tulong num = msg.read.UInt64();\n\t\tif (num != 0L \u0026\u0026 !IsAuthed(num) \u0026\u0026 Interface.CallHook(\u0022OnTurretAssign\u0022, this, num, msg.player) == null)\n\t\t{\n\t\t\tstring username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);\n\t\t\tPlayerNameID playerNameID = new PlayerNameID();\n\t\t\tplayerNameID.userid = num;\n\t\t\tplayerNameID.username = username;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022added\u0022, num);\n\t\t\tauthorizedPlayers.Add(playerNameID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnTurretAssigned\u0022, this, num, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnStructureUpgraded(BuildingBlock buildingBlock, BasePlayer msgPlayer, BuildingGrade.Enum constructionGradeGradeBaseType, ulong constructionGradeGradeBaseSkin)",
    "MethodSignature": "DoUpgradeToGrade(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void DoUpgradeToGrade(RPCMessage msg)\n\t{\n\t\tif (!msg.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tConstructionGrade constructionGrade = blockDefinition.GetGrade((BuildingGrade.Enum)msg.read.Int32(), msg.read.UInt64());\n\t\tif (constructionGrade == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!CanChangeToGrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))\n\t\t{\n\t\t\tif (!(DeployVolume.LastDeployHit != null))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBaseEntity baseEntity = GameObjectEx.ToBaseEntity(DeployVolume.LastDeployHit);\n\t\t\tif (baseEntity != null \u0026\u0026 baseEntity is BasePlayer basePlayer)\n\t\t\t{\n\t\t\t\tulong currentTeam = msg.player.currentTeam;\n\t\t\t\tif (currentTeam != 0L \u0026\u0026 currentTeam == basePlayer.currentTeam)\n\t\t\t\t{\n\t\t\t\t\tstring playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, false, playerNameStreamSafe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnStructureUpgrade\u0022, this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin) != null || !CanAffordUpgrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (base.SecondsSinceAttacked \u003C 30f)\n\t\t\t{\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString(\u0022N0\u0022));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!constructionGrade.gradeBase.alwaysUnlock \u0026\u0026 constructionGrade.gradeBase.skin != 0L \u0026\u0026 !msg.player.blueprints.steamInventory.HasItem((int)constructionGrade.gradeBase.skin))\n\t\t\t{\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.SkinNotOwned, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tPayForUpgrade(constructionGrade, msg.player);\n\t\t\tif (msg.player != null)\n\t\t\t{\n\t\t\t\tplayerCustomColourToApply = GetShippingContainerBlockColourForPlayer(msg.player);\n\t\t\t}\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022DoUpgradeEffect\u0022), (int)constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);\n\t\t\tBuildingGrade.Enum @enum = grade;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, constructionGrade.gradeBase.type, playerCustomColourToApply, constructionGrade.gradeBase.skin);\n\t\t\tOnSkinChanged(skinID, constructionGrade.gradeBase.skin);\n\t\t\tChangeGrade(constructionGrade.gradeBase.type, playEffect: true);\n\t\t\tif (msg.player != null \u0026\u0026 @enum != constructionGrade.gradeBase.type)\n\t\t\t{\n\t\t\t\tmsg.player.ProcessMissionEvent(BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE, new BaseMission.MissionEventPayload\n\t\t\t\t{\n\t\t\t\t\tNetworkIdentifier = net.ID,\n\t\t\t\t\tIntIdentifier = (int)constructionGrade.gradeBase.type\n\t\t\t\t}, 1f);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnStructureUpgraded\u0022, this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);\n\t\t\ttimePlaced = GetNetworkTime();\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 65
  },
  {
    "HookSignature": "OnLootItem(BasePlayer getComponent\u003CBasePlayer\u003E, Item item)",
    "MethodSignature": "StartLootingItem(Item item)",
    "MethodSourseCode": "\n\tpublic void StartLootingItem(Item item)\n\t{\n\t\tClear();\n\t\tif (item != null \u0026\u0026 item.contents != null)\n\t\t{\n\t\t\tPositionChecks = true;\n\t\t\tcontainers.Add(item.contents);\n\t\t\titem.contents.onDirty \u002B= MarkDirty;\n\t\t\titemSource = item;\n\t\t\tentitySource = item.GetWorldEntity();\n\t\t\tInterface.CallHook(\u0022OnLootItem\u0022, GetComponent\u003CBasePlayer\u003E(), item);\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "IOnPlayerChat(ulong userId, string username, string strChatText, ConVar.Chat.ChatChannel targetChannel, BasePlayer player)",
    "MethodSignature": "sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player)",
    "MethodSourseCode": "\n\tinternal static async ValueTask\u003Cbool\u003E sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)\n\t{\n\t\tif (!player)\n\t\t{\n\t\t\tplayer = null;\n\t\t}\n\t\tif (!enabled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player != null \u0026\u0026 player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif ((ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None) == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tstring strChatText = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (strChatText.Length \u003E 128)\n\t\t{\n\t\t\tstrChatText = strChatText.Substring(0, 128);\n\t\t}\n\t\tif (strChatText.Length \u003C= 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022IOnPlayerChat\u0022, userId, username, strChatText, targetChannel, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (strChatText.StartsWith(\u0022/\u0022) || strChatText.StartsWith(\u0022\\\\\u0022))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tstrChatText = strChatText.EscapeRichText();\n\t\tif (Server.emojiOwnershipCheck \u0026\u0026 strChatText.Contains(\u0022:\u0022) \u0026\u0026 player != null)\n\t\t{\n\t\t\tList\u003C(TmProEmojiRedirector.EmojiSub, int)\u003E obj2 = Facepunch.Pool.Get\u003CList\u003C(TmProEmojiRedirector.EmojiSub, int)\u003E\u003E();\n\t\t\tTmProEmojiRedirector.FindEmojiSubstitutions(strChatText, RustEmojiLibrary.Instance, obj2, richText: false, isServer: true);\n\t\t\tforeach (var item in obj2)\n\t\t\t{\n\t\t\t\tif (!item.Item1.targetEmojiResult.CanBeUsedBy(player, player.userID))\n\t\t\t\t{\n\t\t\t\t\tstrChatText = strChatText.Replace(\u0022:\u0022 \u002B item.Item1.targetEmoji \u002B \u0022:\u0022, string.Empty);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\t\tif (strChatText.Length \u003C= 0)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (serverlog)\n\t\t{\n\t\t\tServerConsole.PrintColoured(ConsoleColor.DarkYellow, \u0022[\u0022 \u002B targetChannel.ToString() \u002B \u0022] \u0022 \u002B username \u002B \u0022: \u0022, ConsoleColor.DarkGreen, strChatText);\n\t\t\tstring text = player?.ToString() ?? $\u0022{username}[{userId}]\u0022;\n\t\t\tswitch (targetChannel)\n\t\t\t{\n\t\t\tcase ChatChannel.Team:\n\t\t\t\tDebugEx.Log(\u0022[TEAM CHAT] \u0022 \u002B text \u002B \u0022 : \u0022 \u002B strChatText);\n\t\t\t\tbreak;\n\t\t\tcase ChatChannel.Cards:\n\t\t\t\tDebugEx.Log(\u0022[CARDS CHAT] \u0022 \u002B text \u002B \u0022 : \u0022 \u002B strChatText);\n\t\t\t\tbreak;\n\t\t\tcase ChatChannel.Clan:\n\t\t\t\tDebugEx.Log(\u0022[CLAN CHAT] \u0022 \u002B text \u002B \u0022 : \u0022 \u002B strChatText);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDebugEx.Log(\u0022[CHAT] \u0022 \u002B text \u002B \u0022 : \u0022 \u002B strChatText);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring strName = username.EscapeRichText();\n\t\tstring nameColor = GetNameColor(userId, player);\n\t\tChatEntry ce = default(ChatEntry);\n\t\tce.Channel = targetChannel;\n\t\tce.Message = strChatText;\n\t\tce.UserId = ((player != null) ? player.UserIDString : userId.ToString());\n\t\tce.Username = username;\n\t\tce.Color = nameColor;\n\t\tce.Time = Epoch.Current;\n\t\tRecord(ce);\n\t\tswitch (targetChannel)\n\t\t{\n\t\tcase ChatChannel.Cards:\n\t\t{\n\t\t\tif (player == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!player.isMounted)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tBaseCardGameEntity baseCardGameEntity = player.GetMountedVehicle() as BaseCardGameEntity;\n\t\t\tif (baseCardGameEntity == null || !(baseCardGameEntity.GameController?.IsAtTable(player) ?? false))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList\u003CNetwork.Connection\u003E obj3 = Facepunch.Pool.Get\u003CList\u003CNetwork.Connection\u003E\u003E();\n\t\t\tbaseCardGameEntity.GameController?.GetConnectionsInGame(obj3);\n\t\t\tif (obj3.Count \u003E 0)\n\t\t\t{\n\t\t\t\tConsoleNetwork.SendClientCommand(obj3, \u0022chat.add2\u0022, 3, userId, strChatText, strName, nameColor, 1f);\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj3);\n\t\t\treturn true;\n\t\t}\n\t\tcase ChatChannel.Global:\n\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add2\u0022, 0, userId, strChatText, strName, nameColor, 1f);\n\t\t\treturn true;\n\t\tcase ChatChannel.Local:\n\t\t{\n\t\t\tif (!(player != null))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfloat num = localChatRange * localChatRange;\n\t\t\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\n\t\t\t{\n\t\t\t\tfloat sqrMagnitude = (activePlayer.transform.position - player.transform.position).sqrMagnitude;\n\t\t\t\tif (!(sqrMagnitude \u003E num))\n\t\t\t\t{\n\t\t\t\t\tConsoleNetwork.SendClientCommand(activePlayer.net.connection, \u0022chat.add2\u0022, 4, userId, strChatText, strName, nameColor, Mathf.Clamp01(sqrMagnitude / num \u002B 0.2f));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tcase ChatChannel.Team:\n\t\t{\n\t\t\tRelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userId);\n\t\t\tif (playerTeam == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList\u003CNetwork.Connection\u003E onlineMemberConnections = playerTeam.GetOnlineMemberConnections();\n\t\t\tif (onlineMemberConnections != null)\n\t\t\t{\n\t\t\t\tConsoleNetwork.SendClientCommand(onlineMemberConnections, \u0022chat.add2\u0022, 1, userId, strChatText, strName, nameColor, 1f);\n\t\t\t}\n\t\t\tplayerTeam.BroadcastTeamChat(userId, strName, strChatText, nameColor);\n\t\t\treturn true;\n\t\t}\n\t\tcase ChatChannel.Clan:\n\t\t{\n\t\t\tClanManager serverInstance = ClanManager.ServerInstance;\n\t\t\tif (serverInstance == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (player != null \u0026\u0026 player.clanId == 0L)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tClanValueResult\u003CIClan\u003E clanValueResult = ((!(player != null) || player.clanId == 0L) ? (await serverInstance.Backend.GetByMember(userId)) : (await serverInstance.Backend.Get(player.clanId)));\n\t\t\t\tClanValueResult\u003CIClan\u003E clanValueResult2 = clanValueResult;\n\t\t\t\tif (!clanValueResult2.IsSuccess)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (await clanValueResult2.Value.SendChatMessage(strName, strChatText, userId) != ClanResult.Success)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception message2)\n\t\t\t{\n\t\t\t\tDebug.LogError(message2);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "Chat",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnNpcTarget(HumanNPC humanNPC, BaseEntity player)",
    "MethodSignature": "GetBestTarget()",
    "MethodSourseCode": "\n\tpublic BaseEntity GetBestTarget()\n\t{\n\t\tBaseEntity result = null;\n\t\tfloat num = -1f;\n\t\tforeach (BaseEntity player in Brain.Senses.Players)\n\t\t{\n\t\t\tif (!(player == null) \u0026\u0026 !(player.Health() \u003C= 0f) \u0026\u0026 Interface.CallHook(\u0022OnNpcTarget\u0022, this, player) == null)\n\t\t\t{\n\t\t\t\tfloat value = Vector3.Distance(player.transform.position, base.transform.position);\n\t\t\t\tfloat num2 = 1f - Mathf.InverseLerp(1f, Brain.SenseRange, value);\n\t\t\t\tfloat value2 = Vector3.Dot((player.transform.position - base.eyes.position).normalized, base.eyes.BodyForward());\n\t\t\t\tnum2 \u002B= Mathf.InverseLerp(Brain.VisionCone, 1f, value2) / 2f;\n\t\t\t\tnum2 \u002B= (Brain.Senses.Memory.IsLOS(player) ? 2f : 0f);\n\t\t\t\tif (num2 \u003E num)\n\t\t\t\t{\n\t\t\t\t\tresult = player;\n\t\t\t\t\tnum = num2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "HumanNPC",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnAnimalDungProduced(RidableHorse ridableHorse, Item item)",
    "MethodSignature": "DoDung()",
    "MethodSourseCode": "\n\tprivate void DoDung()\n\t{\n\t\tdungProduction -= 1f;\n\t\tif (Interface.CallHook(\u0022OnAnimalDungProduce\u0022, this) == null)\n\t\t{\n\t\t\tQuaternion rotation = Quaternion.Euler(UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-180f, 180f));\n\t\t\tVector3 vVelocity = new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), UnityEngine.Random.Range(-1f, -3f), UnityEngine.Random.Range(-0.5f, 0.5f));\n\t\t\tItem item = ItemManager.Create(dungItem, 1, 0uL);\n\t\t\titem.SetItemOwnership(currentBreed.breedName.english, ItemOwnershipPhrases.Pooped);\n\t\t\titem.Drop(dungSpawnPoint.position \u002B UnityEngine.Random.insideUnitSphere * 0.1f, vVelocity, rotation);\n\t\t\tInterface.CallHook(\u0022OnAnimalDungProduced\u0022, this, item);\n\t\t}\n\t}\n",
    "ClassName": "RidableHorse",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, DroppedItemContainer droppedItemContainer)",
    "MethodSignature": "RPC_OpenLoot(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tprivate void RPC_OpenLoot(RPCMessage rpc)\n\t{\n\t\tif (inventory != null)\n\t\t{\n\t\t\tBasePlayer player = rpc.player;\n\t\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 Interface.CallHook(\u0022CanLootEntity\u0022, player, this) == null \u0026\u0026 player.inventory.loot.StartLootingEntity(this))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\t\tplayer.inventory.loot.AddContainer(inventory);\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022RPC_OpenLootPanel\u0022, player), lootPanelName);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DroppedItemContainer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnPlayerRespawned(BasePlayer basePlayer)",
    "MethodSignature": "RespawnAt(Vector3 position, Quaternion rotation, BaseEntity spawnPointEntity)",
    "MethodSourseCode": "\n\tpublic void RespawnAt(Vector3 position, Quaternion rotation, BaseEntity spawnPointEntity = null)\n\t{\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif ((bool)activeGameMode \u0026\u0026 !activeGameMode.CanPlayerRespawn(this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetPlayerFlag(PlayerFlags.Wounded, b: false);\n\t\tSetPlayerFlag(PlayerFlags.Incapacitated, b: false);\n\t\tSetPlayerFlag(PlayerFlags.Unused2, b: false);\n\t\tSetPlayerFlag(PlayerFlags.Unused1, b: false);\n\t\tSetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);\n\t\tSetPlayerFlag(PlayerFlags.DisplaySash, b: false);\n\t\trespawnId = Guid.NewGuid().ToString(\u0022N\u0022);\n\t\tServerPerformance.spawns\u002B\u002B;\n\t\tSetParent(null, worldPositionStays: true);\n\t\tbase.transform.SetPositionAndRotation(position, rotation);\n\t\ttickInterpolator.Reset(position);\n\t\tif (ConVar.Server.UsePlayerUpdateJobs \u0026\u0026 StableIndex != -1)\n\t\t{\n\t\t\tTickCache.Reset(this, position);\n\t\t}\n\t\ttickHistory.Reset(position);\n\t\teyeHistory.Clear();\n\t\tForceUpdateTriggers();\n\t\testimatedVelocity = Vector3.zero;\n\t\testimatedSpeed = 0f;\n\t\testimatedSpeed2D = 0f;\n\t\tlastTickTime = 0f;\n\t\tStopWounded();\n\t\tResetWoundingVars();\n\t\tStopSpectating();\n\t\tUpdateNetworkGroup();\n\t\tEnablePlayerCollider();\n\t\tRemovePlayerRigidbody();\n\t\tStartSleeping();\n\t\tLifeStoryStart();\n\t\tmetabolism.Reset();\n\t\tif (modifiers != null)\n\t\t{\n\t\t\tif (Player.keepteaondeath)\n\t\t\t{\n\t\t\t\tmodifiers.RemoveAllExceptFromSource(Modifier.ModifierSource.Tea);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmodifiers.RemoveAll();\n\t\t\t}\n\t\t}\n\t\tInitializeHealth(StartHealth(), StartMaxHealth());\n\t\tbool flag = false;\n\t\tif (ConVar.Server.respawnWithLoadout)\n\t\t{\n\t\t\tstring infoString = GetInfoString(\u0022client.respawnloadout\u0022, string.Empty);\n\t\t\tif (!string.IsNullOrEmpty(infoString) \u0026\u0026 Inventory.LoadLoadout(infoString, out var so))\n\t\t\t{\n\t\t\t\tso.LoadItemsOnTo(this);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tif (!flag)\n\t\t{\n\t\t\tinventory.GiveDefaultItems();\n\t\t}\n\t\tSendNetworkUpdateImmediate();\n\t\tClientRPC(RpcTarget.Player(\u0022StartLoading\u0022, this));\n\t\tFacepunch.Rust.Analytics.Azure.OnPlayerRespawned(this, spawnPointEntity);\n\t\tif ((bool)activeGameMode)\n\t\t{\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerRespawn(this);\n\t\t}\n\t\tif (IsConnected)\n\t\t{\n\t\t\tEACServer.OnStartLoading(net.connection);\n\t\t}\n\t\tInterface.CallHook(\u0022OnPlayerRespawned\u0022, this);\n\t\tProcessMissionEvent(BaseMission.MissionEventType.RESPAWN, 0, 0f);\n\t\tPlayerInjureState = GetInjureState();\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 76
  },
  {
    "HookSignature": "OnItemRecycleAmount(Item slot, int num3, Recycler recycler)",
    "MethodSignature": "RecycleThink()",
    "MethodSourseCode": "\n\tpublic void RecycleThink()\n\t{\n\t\tbool flag = false;\n\t\tfloat num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);\n\t\tint num2 = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tif (num2 \u003C 6)\n\t\t\t{\n\t\t\t\tItem slot = base.inventory.GetSlot(num2);\n\t\t\t\tif (!CanBeRecycled(slot))\n\t\t\t\t{\n\t\t\t\t\tnum2\u002B\u002B;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Interface.CallHook(\u0022OnItemRecycle\u0022, slot, this) != null)\n\t\t\t\t{\n\t\t\t\t\tif (!HasRecyclable())\n\t\t\t\t\t{\n\t\t\t\t\t\tStopRecycling();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (slot.hasCondition)\n\t\t\t\t{\n\t\t\t\t\tnum = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));\n\t\t\t\t}\n\t\t\t\tint num3 = 1;\n\t\t\t\tif (slot.amount \u003E 1)\n\t\t\t\t{\n\t\t\t\t\tnum3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnItemRecycleAmount\u0022, slot, num3, this);\n\t\t\t\tif (obj is int)\n\t\t\t\t{\n\t\t\t\t\tnum3 = (int)obj;\n\t\t\t\t}\n\t\t\t\tif (slot.info.Blueprint.scrapFromRecycle \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tfloat num4 = slot.info.Blueprint.scrapFromRecycle * num3;\n\t\t\t\t\tif (slot.MaxStackable() == 1 \u0026\u0026 slot.hasCondition)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum4 *= slot.conditionNormalized;\n\t\t\t\t\t}\n\t\t\t\t\tfloat num5 = num / 0.5f;\n\t\t\t\t\tnum4 *= num5;\n\t\t\t\t\tint num6 = Mathf.FloorToInt(num4);\n\t\t\t\t\tfloat num7 = num4 - (float)num6;\n\t\t\t\t\tscrapRemainder \u002B= num7;\n\t\t\t\t\tif (scrapRemainder \u003E= 1f)\n\t\t\t\t\t{\n\t\t\t\t\t\tint num8 = Mathf.FloorToInt(scrapRemainder);\n\t\t\t\t\t\tscrapRemainder -= num8;\n\t\t\t\t\t\tnum6 \u002B= num8;\n\t\t\t\t\t}\n\t\t\t\t\tif (num6 \u003E= 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tItem item = ItemManager.CreateByName(\u0022scrap\u0022, num6, 0uL);\n\t\t\t\t\t\tif (base.LastLootedByPlayer != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);\n\t\t\t\t\t\tMoveItemToOutput(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))\n\t\t\t\t{\n\t\t\t\t\tList\u003CBasePlayer\u003E obj2 = Facepunch.Pool.Get\u003CList\u003CBasePlayer\u003E\u003E();\n\t\t\t\t\tVis.Entities(base.transform.position, 3f, obj2, 131072);\n\t\t\t\t\tforeach (BasePlayer item3 in obj2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (item3.IsAlive() \u0026\u0026 !item3.IsSleeping() \u0026\u0026 item3.inventory.loot.entitySource == this)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);\n\t\t\t\t\t\t\titem3.stats.Save();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\t\t\t}\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);\n\t\t\t\tslot.UseItem(num3);\n\t\t\t\tforeach (ItemAmount ingredient in slot.info.Blueprint.GetIngredients())\n\t\t\t\t{\n\t\t\t\t\tif (ingredient.itemDef.shortname == \u0022scrap\u0022)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfloat num9 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num3;\n\t\t\t\t\tint num10 = Mathf.FloorToInt(num9);\n\t\t\t\t\tfloat num11 = num9 - (float)num10;\n\t\t\t\t\tif (num11 \u003E float.Epsilon \u0026\u0026 UnityEngine.Random.Range(0f, 1f) \u003C= num11)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum10\u002B\u002B;\n\t\t\t\t\t}\n\t\t\t\t\tif (num10 \u003C= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint num12 = Mathf.CeilToInt((float)num10 / (float)ingredient.itemDef.stackable);\n\t\t\t\t\tfor (int i = 0; i \u003C num12; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ingredient.itemDef.IsAllowed(EraRestriction.Recycle))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint num13 = ((num10 \u003E ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num10);\n\t\t\t\t\t\t\tItem item2 = ItemManager.Create(ingredient.itemDef, num13, 0uL);\n\t\t\t\t\t\t\tif (base.LastLootedByPlayer != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\titem2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);\n\t\t\t\t\t\t\tif (!MoveItemToOutput(item2))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum10 -= num13;\n\t\t\t\t\t\t\tif (num10 \u003C= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag || !HasRecyclable())\n\t\t\t{\n\t\t\t\tStopRecycling();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "CanUpdateSign(BasePlayer player, PhotoFrame photoFrame)",
    "MethodSignature": "CanUpdateSign(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanUpdateSign(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUpdateSign\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player.IsAdmin || player.IsDeveloper)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (!player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsLocked())\n\t\t{\n\t\t\treturn (ulong)player.userID == base.OwnerID;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PhotoFrame",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanAccessVendingMachine(DeliveryDroneConfig config, VendingMachine vendingMachine)",
    "MethodSignature": "GetDeliveryEligibleVendingMachines.IsEligible(VendingMachine vendingMachine, Vector3 offset, int n)",
    "MethodSourseCode": "\t\tbool IsEligible(VendingMachine vendingMachine, Vector3 offset, int n)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022CanAccessVendingMachine\u0022, config, vendingMachine);\n\t\t\tif (obj is bool)\n\t\t\t{\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\tif (vendingMachine is NPCVendingMachine)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!vendingMachine.IsBroadcasting())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!config.IsVendingMachineAccessible(vendingMachine, offset, out var _))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n",
    "ClassName": "MarketTerminal",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnClientCommand(Network.Connection packetConnection, string text)",
    "MethodSignature": "OnClientCommand(Message packet)",
    "MethodSourseCode": "\n\tinternal static void OnClientCommand(Message packet)\n\t{\n\t\tif (packet.read.Unread \u003E ConVar.Server.maxpacketsize_command)\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning(\u0022Dropping client command due to size\u0022);\n\t\t\treturn;\n\t\t}\n\t\ttimer.Restart();\n\t\tstring text = packet.read.StringRaw();\n\t\tif (packet.connection == null || !packet.connection.connected)\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning(\u0022Client without connection tried to run command: \u0022 \u002B text);\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnClientCommand\u0022, packet.connection, text) == null)\n\t\t{\n\t\t\tstring text2 = ConsoleSystem.Run(ConsoleSystem.Option.Server.FromConnection(packet.connection).Quiet(), text);\n\t\t\tif (!string.IsNullOrEmpty(text2))\n\t\t\t{\n\t\t\t\tSendClientReply(packet.connection, text2);\n\t\t\t}\n\t\t\tif (timer.Elapsed \u003E RuntimeProfiler.ConsoleCommandWarningThreshold)\n\t\t\t{\n\t\t\t\tLagSpikeProfiler.ConsoleCommand(timer.Elapsed, packet, text);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ConsoleNetwork",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnPayForPlacement(BasePlayer player, WallpaperPlanner wallpaperPlanner, Construction component)",
    "MethodSignature": "PayForPlacement(BasePlayer player, Construction component)",
    "MethodSourseCode": "\n\tpublic override void PayForPlacement(BasePlayer player, Construction component)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPayForPlacement\u0022, player, this, component) == null \u0026\u0026 (!player.IsInCreativeMode || !Creative.freeBuild))\n\t\t{\n\t\t\tplayer.inventory.Take(null, placementPrice.itemid, (int)placementPrice.amount);\n\t\t\tplayer.Command(\u0022note.inv\u0022, placementPrice.itemid, (int)placementPrice.amount * -1);\n\t\t}\n\t}\n",
    "ClassName": "WallpaperPlanner",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerColliderEnable(BasePlayer basePlayer, UnityEngine.CapsuleCollider playerCollider)",
    "MethodSignature": "EnablePlayerCollider()",
    "MethodSourseCode": "\n\tpublic void EnablePlayerCollider()\n\t{\n\t\tif (!playerCollider.enabled \u0026\u0026 Interface.CallHook(\u0022OnPlayerColliderEnable\u0022, this, playerCollider) == null)\n\t\t{\n\t\t\tRefreshColliderSize(forced: true);\n\t\t\tplayerCollider.enabled = true;\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnMissionFailed(BaseMission baseMission, BaseMission.MissionInstance instance, BasePlayer assignee, BaseMission.MissionFailReason failReason)",
    "MethodSignature": "MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)",
    "MethodSourseCode": "\n\tpublic virtual void MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)\n\t{\n\t\tif (!instance.GetMission().completeSilently)\n\t\t{\n\t\t\tassignee.ChatMessage(\u0022You have failed the mission : \u0022 \u002B missionName.english);\n\t\t}\n\t\tDoMissionEffect(failedEffect.resourcePath, assignee);\n\t\tFacepunch.Rust.Analytics.Azure.OnMissionComplete(assignee, this, failReason);\n\t\tinstance.status = MissionStatus.Failed;\n\t\tMissionEnded(instance, assignee);\n\t\tInterface.CallHook(\u0022OnMissionFailed\u0022, this, instance, assignee, failReason);\n\t\tif (failReason == MissionFailReason.ResetPlayerState)\n\t\t{\n\t\t\tinstance.endTime = 0f;\n\t\t\tinstance.status = MissionStatus.Default;\n\t\t\tassignee.MissionDirty();\n\t\t}\n\t}\n",
    "ClassName": "BaseMission",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnNpcGiveSoldItem(NPCVendingMachine nPCVendingMachine, Item soldItem, BasePlayer buyer)",
    "MethodSignature": "GiveSoldItem(Item soldItem, BasePlayer buyer)",
    "MethodSourseCode": "\n\tpublic override void GiveSoldItem(Item soldItem, BasePlayer buyer)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcGiveSoldItem\u0022, this, soldItem, buyer) == null)\n\t\t{\n\t\t\tsoldItem.SetItemOwnership(buyer, ItemOwnershipPhrases.VendorSale);\n\t\t\tbase.GiveSoldItem(soldItem, buyer);\n\t\t}\n\t}\n",
    "ClassName": "NPCVendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDispenserGather(ResourceDispenser resourceDispenser, BasePlayer entity, Item item)",
    "MethodSignature": "GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)",
    "MethodSourseCode": "\n\tprivate void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)\n\t{\n\t\tif (itemAmt.amount == 0f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();\n\t\tfloat num2 = itemAmt.startAmount / startingItemCounts;\n\t\tfloat f = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);\n\t\tf = Mathf.Round(f);\n\t\tfloat num3 = f * destroyFraction * 2f;\n\t\tif (itemAmt.amount \u003C= f \u002B num3)\n\t\t{\n\t\t\tfloat num4 = (f \u002B num3) / itemAmt.amount;\n\t\t\tf /= num4;\n\t\t\tnum3 /= num4;\n\t\t}\n\t\titemAmt.amount -= Mathf.Floor(f);\n\t\titemAmt.amount -= Mathf.Floor(num3);\n\t\tif (f \u003C 1f)\n\t\t{\n\t\t\tf = ((UnityEngine.Random.Range(0f, 1f) \u003C= f) ? 1f : 0f);\n\t\t\titemAmt.amount = 0f;\n\t\t}\n\t\tif (itemAmt.amount \u003C 0f)\n\t\t{\n\t\t\titemAmt.amount = 0f;\n\t\t}\n\t\tif (!(f \u003E= 1f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num5 = CalculateGatherBonus(entity, itemAmt, f);\n\t\tint iAmount = Mathf.FloorToInt(f) \u002B num5;\n\t\tItem item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);\n\t\tif (Interface.CallHook(\u0022OnDispenserGather\u0022, this, entity, item) == null \u0026\u0026 item != null)\n\t\t{\n\t\t\tApplyItemOwnership(entity, item);\n\t\t\tOverrideOwnership(item, attackWeapon);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);\n\t\t\tInterface.CallHook(\u0022OnDispenserGathered\u0022, this, entity, item);\n\t\t\twhile (item.amount \u003E item.MaxStackable())\n\t\t\t{\n\t\t\t\tItem item2 = item.SplitItem(item.MaxStackable());\n\t\t\t\tentity.GiveItem(item2, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t\t}\n\t\t\tentity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t}\n\t}\n",
    "ClassName": "ResourceDispenser",
    "HookLineInvoke": 36
  },
  {
    "HookSignature": "OnWildlifeTrap(SurvivalFishTrap survivalFishTrap, ItemDefinition itemDefinition)",
    "MethodSignature": "TrapThink()",
    "MethodSourseCode": "\n\tpublic override void TrapThink()\n\t{\n\t\tItemDefinition itemDefinition = null;\n\t\tItem item = null;\n\t\tint usedLureAmount = 0;\n\t\tusing (List\u003CItem\u003E.Enumerator enumerator = base.inventory.itemList.GetEnumerator())\n\t\t{\n\t\t\tif (enumerator.MoveNext())\n\t\t\t{\n\t\t\t\tItem current = enumerator.Current;\n\t\t\t\tif ((current.info.TryGetComponent\u003CItemModCompostable\u003E(out var component) ? component.BaitValue : 0f) \u003E 0f)\n\t\t\t\t{\n\t\t\t\t\titem = current;\n\t\t\t\t\titemDefinition = FishLookup.Instance.GetFish(base.transform.position, cachedWaterBody, current, out var _, current.info.GetComponent\u003CItemModFishable\u003E(), out usedLureAmount, 5f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\titem?.UseItem(usedLureAmount);\n\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= trapSuccessRate || !(itemDefinition != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tbypassItemFilter = true;\n\t\t\tif (Interface.CallHook(\u0022OnWildlifeTrap\u0022, this, itemDefinition) == null)\n\t\t\t{\n\t\t\t\tItem item2 = ItemManager.Create(itemDefinition, 1, 0uL);\n\t\t\t\tif (base.LastLootedByPlayer != null)\n\t\t\t\t{\n\t\t\t\t\titem2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.SurvivalTrap);\n\t\t\t\t}\n\t\t\t\tif (!item2.MoveToContainer(base.inventory))\n\t\t\t\t{\n\t\t\t\t\titem2.Drop(base.transform.position, Vector3.zero, Quaternion.identity);\n\t\t\t\t}\n\t\t\t\tOnTrappedWildlife(setFlag: true);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tbypassItemFilter = false;\n\t\t}\n\t}\n",
    "ClassName": "SurvivalFishTrap",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "OnLockRemove(ModularCar carOccupant, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_RequestRemoveLock(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_RequestRemoveLock(RPCMessage msg)\n\t{\n\t\tif (HasOccupant \u0026\u0026 carOccupant.CarLock.HasALock \u0026\u0026 Interface.CallHook(\u0022OnLockRemove\u0022, carOccupant, msg.player) == null)\n\t\t{\n\t\t\tcarOccupant.CarLock.RemoveLock();\n\t\t\tEffect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnVendingShopOpen(VendingMachine vendingMachine, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_OpenShop(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_OpenShop(RPCMessage msg)\n\t{\n\t\tif (OccupiedCheck(msg.player) \u0026\u0026 Interface.CallHook(\u0022OnVendingShopOpen\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tOpenShop(msg.player);\n\t\t\tInterface.CallHook(\u0022OnVendingShopOpened\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerKicked(BasePlayer basePlayer, string reason, bool reserveSlot)",
    "MethodSignature": "Kick(string reason, bool reserveSlot)",
    "MethodSourseCode": "\n\tpublic void Kick(string reason, bool reserveSlot = true)\n\t{\n\t\tif (IsConnected)\n\t\t{\n\t\t\tnet.connection.canReserveSlot = reserveSlot;\n\t\t\tNetwork.Net.sv.Kick(net.connection, reason);\n\t\t\tInterface.CallHook(\u0022OnPlayerKicked\u0022, this, reason, reserveSlot);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, LootableCorpse lootableCorpse)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t\tResetRemovalTime();\n\t\tSetFlag(Flags.Open, b: false);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "LootableCorpse",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLock(BasePlayer player, KeyLock keyLock)",
    "MethodSignature": "Lock(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate void Lock(BasePlayer player)\n\t{\n\t\tif (!(player == null) \u0026\u0026 player.CanInteract() \u0026\u0026 !IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanLock\u0022, player, this) == null \u0026\u0026 HasLockPermission(player))\n\t\t{\n\t\t\tLockLock(player);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "KeyLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntitySpawned(BaseNetworkable baseNetworkable)",
    "MethodSignature": "Spawn()",
    "MethodSourseCode": "\n\tpublic virtual void Spawn()\n\t{\n\t\tEntityProfiler.spawned\u002B\u002B;\n\t\tif (EntityProfiler.mode \u003E= 2)\n\t\t{\n\t\t\tEntityProfiler.OnSpawned(this);\n\t\t}\n\t\tSpawnShared();\n\t\tif (net == null)\n\t\t{\n\t\t\tnet = Network.Net.sv.CreateNetworkable();\n\t\t}\n\t\tcreationFrame = UnityEngine.Time.frameCount;\n\t\tPreInitShared();\n\t\tInitShared();\n\t\tServerInit();\n\t\tPostInitShared();\n\t\tUpdateNetworkGroup();\n\t\tServerInitPostNetworkGroupAssign();\n\t\tisSpawned = true;\n\t\tInterface.CallHook(\u0022OnEntitySpawned\u0022, this);\n\t\tSendNetworkUpdateImmediate(justCreated: true);\n\t\tInvoke(SendGlobalNetworkUpdate, 0f);\n\t\tif (Rust.Application.isLoading \u0026\u0026 !Rust.Application.isLoadingSave)\n\t\t{\n\t\t\tbase.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnSwitchToggle(FuelGenerator fuelGenerator, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool generatorState = msg.read.Bit();\n\t\t\tSetGeneratorState(generatorState);\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "FuelGenerator",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerSetInfo(Network.Connection netConnection, string key, string val)",
    "MethodSignature": "SetInfo(string key, string val)",
    "MethodSourseCode": "\n\tpublic virtual void SetInfo(string key, string val)\n\t{\n\t\tif (IsConnected)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerSetInfo\u0022, net.connection, key, val);\n\t\t\tnet.connection.info.Set(key, val);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanBeWounded(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "EligibleForWounding(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual bool EligibleForWounding(HitInfo info)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeWounded\u0022, this, info);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!ConVar.Server.woundingenabled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsWounded())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsSleeping())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (isMounted)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (info == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsWounded() \u0026\u0026 UnityEngine.Time.realtimeSinceStartup - lastWoundedStartTime \u003C ConVar.Server.rewounddelay)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif ((bool)activeGameMode \u0026\u0026 !activeGameMode.allowWounding)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (triggers != null)\n\t\t{\n\t\t\tfor (int i = 0; i \u003C triggers.Count; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tif (triggers[i] is IHurtTrigger)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (info.WeaponPrefab is BaseMelee)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (info.WeaponPrefab is BaseProjectile)\n\t\t{\n\t\t\treturn !info.isHeadshot;\n\t\t}\n\t\treturn info.damageTypes.GetMajorityDamageType() switch\n\t\t{\n\t\t\tDamageType.Suicide =\u003E false, \n\t\t\tDamageType.Fall =\u003E true, \n\t\t\tDamageType.Bite =\u003E true, \n\t\t\tDamageType.Bleeding =\u003E true, \n\t\t\tDamageType.Hunger =\u003E true, \n\t\t\tDamageType.Thirst =\u003E true, \n\t\t\tDamageType.Poison =\u003E true, \n\t\t\t_ =\u003E false, \n\t\t};\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTeamDisbanded(RelationshipManager.PlayerTeam teamToDisband)",
    "MethodSignature": "DisbandTeam(PlayerTeam teamToDisband)",
    "MethodSourseCode": "\n\tpublic void DisbandTeam(PlayerTeam teamToDisband)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTeamDisband\u0022, teamToDisband) == null)\n\t\t{\n\t\t\tteams.Remove(teamToDisband.teamID);\n\t\t\tInterface.CallHook(\u0022OnTeamDisbanded\u0022, teamToDisband);\n\t\t\tFacepunch.Pool.Free(ref teamToDisband);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, ItemBasedFlowRestrictor itemBasedFlowRestrictor)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t}\n",
    "ClassName": "ItemBasedFlowRestrictor",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSupplyDropLanded(SupplyDrop supplyDrop)",
    "MethodSignature": "OnCollisionEnter(Collision collision)",
    "MethodSourseCode": "\n\tprivate void OnCollisionEnter(Collision collision)\n\t{\n\t\tbool flag = ((1 \u003C\u003C collision.collider.gameObject.layer) \u0026 0x40A10111) \u003E 0;\n\t\tif (((1 \u003C\u003C collision.collider.gameObject.layer) \u0026 0x8000000) \u003E 0 \u0026\u0026 CollisionEx.GetEntity(collision) is Tugboat)\n\t\t{\n\t\t\tflag = true;\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tRemoveParachute();\n\t\t\tMakeLootable();\n\t\t}\n\t\tInterface.CallHook(\u0022OnSupplyDropLanded\u0022, this);\n\t}\n",
    "ClassName": "SupplyDrop",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnExperimentEnd(Workbench workbench)",
    "MethodSignature": "ExperimentComplete()",
    "MethodSourseCode": "\n\tpublic void ExperimentComplete()\n\t{\n\t\tItem experimentResourceItem = GetExperimentResourceItem();\n\t\tint scrapForExperiment = GetScrapForExperiment();\n\t\tif (pendingBlueprint == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Pending blueprint was null!\u0022);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnExperimentEnd\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (experimentResourceItem != null \u0026\u0026 experimentResourceItem.amount \u003E= scrapForExperiment \u0026\u0026 pendingBlueprint != null)\n\t\t{\n\t\t\texperimentResourceItem.UseItem(scrapForExperiment);\n\t\t\tItem item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);\n\t\t\titem.blueprintTarget = pendingBlueprint.itemid;\n\t\t\tcreatingBlueprint = true;\n\t\t\tif (!item.MoveToContainer(base.inventory, 0))\n\t\t\t{\n\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t}\n\t\t\tcreatingBlueprint = false;\n\t\t\tif (experimentSuccessEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t}\n\t\tSetFlag(Flags.On, b: false);\n\t\tpendingBlueprint = null;\n\t\tbase.inventory.SetLocked(isLocked: false);\n\t\tSendNetworkUpdate();\n\t\tInterface.CallHook(\u0022OnExperimentEnded\u0022, this);\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnQuarryToggle(MiningQuarry miningQuarry, BasePlayer msgPlayer)",
    "MethodSignature": "StopEngine(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void StopEngine(RPCMessage msg)\n\t{\n\t\tMiningQuarry miningQuarry = GetParentEntity() as MiningQuarry;\n\t\tif ((bool)miningQuarry \u0026\u0026 Interface.CallHook(\u0022OnQuarryToggle\u0022, miningQuarry, msg.player) == null)\n\t\t{\n\t\t\tminingQuarry.EngineSwitch(isOn: false);\n\t\t\tInterface.CallHook(\u0022OnQuarryToggled\u0022, miningQuarry, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "EngineSwitch",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnHotAirBalloonToggle(HotAirBalloon hotAirBalloon, BasePlayer msgPlayer)",
    "MethodSignature": "EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHotAirBalloonToggle\u0022, this, msg.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 (!OnlyOwnerAccessible() || !(player != creatorEntity)))\n\t\t{\n\t\t\tbool b = msg.read.Bit();\n\t\t\tSetFlag(Flags.On, b);\n\t\t\tif (IsOn())\n\t\t\t{\n\t\t\t\tInvoke(ScheduleOff, 60f);\n\t\t\t\tInterface.CallHook(\u0022OnHotAirBalloonToggled\u0022, this, msg.player);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCancelInvoke(ScheduleOff);\n\t\t\t\tInterface.CallHook(\u0022OnHotAirBalloonToggled\u0022, this, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "HotAirBalloon",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanBeTargeted(BaseCombatEntity potentialtarget, HelicopterTurret helicopterTurret)",
    "MethodSignature": "InFiringArc(BaseCombatEntity potentialtarget)",
    "MethodSourseCode": "\n\tpublic bool InFiringArc(BaseCombatEntity potentialtarget)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeTargeted\u0022, potentialtarget, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn AngleToTarget(potentialtarget) \u003C 80f;\n\t}\n",
    "ClassName": "HelicopterTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFreeableContainerRelease(FreeableLootContainer freeableLootContainer, BasePlayer ply)",
    "MethodSignature": "Release(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic void Release(BasePlayer ply)\n\t{\n\t\tif (Interface.CallHook(\u0022OnFreeableContainerRelease\u0022, this, ply) == null)\n\t\t{\n\t\t\tGetRB().isKinematic = false;\n\t\t\tbuoyancy.enabled = true;\n\t\t\tbuoyancy.buoyancyScale = 1f;\n\t\t\tSetFlag(Flags.Reserved8, b: false);\n\t\t\tif (freedEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(freedEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tif (ply != null \u0026\u0026 !ply.IsNpc \u0026\u0026 ply.IsConnected \u0026\u0026 net != null)\n\t\t\t{\n\t\t\t\tply.ProcessMissionEvent(BaseMission.MissionEventType.FREE_CRATE, net.ID, 1f);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnFreeUnderwaterCrate(ply, this);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnFreeableContainerReleased\u0022, this, ply);\n\t\t}\n\t}\n",
    "ClassName": "FreeableLootContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSiegeWeaponDoorClose(BatteringRam batteringRam, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_CloseDoor(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.CallsPerSecond(2uL)]\n\tprotected void RPC_CloseDoor(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract(usableWhileCrawling: true) \u0026\u0026 CanCloseDoor() \u0026\u0026 Interface.CallHook(\u0022OnSiegeWeaponDoorClose\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tCloseDoor();\n\t\t}\n\t}\n",
    "ClassName": "BatteringRam",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnEntityEnter(TriggerBase triggerBase, BaseEntity ent)",
    "MethodSignature": "OnEntityEnter(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic virtual void OnEntityEnter(BaseEntity ent)\n\t{\n\t\tif (!(ent == null))\n\t\t{\n\t\t\tif (entityContents == null)\n\t\t\t{\n\t\t\t\tentityContents = new HashSet\u003CBaseEntity\u003E();\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnEntityEnter\u0022, this, ent) == null)\n\t\t\t{\n\t\t\t\tentityContents.Add(ent);\n\t\t\t\tOnEntityEnterTrigger?.Invoke(ent);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "TriggerBase",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnMaxStackable(Item item)",
    "MethodSignature": "MaxStackable()",
    "MethodSourseCode": "\n\tpublic int MaxStackable()\n\t{\n\t\tint num = info.stackable;\n\t\tif (parent != null \u0026\u0026 parent.maxStackSize \u003E 0)\n\t\t{\n\t\t\tnum = Mathf.Min(parent.maxStackSize, num);\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnMaxStackable\u0022, this);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\treturn num;\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnMlrsFire(MLRS mLRS, BasePlayer owner)",
    "MethodSignature": "Fire(BasePlayer owner)",
    "MethodSourseCode": "\n\tpublic void Fire(BasePlayer owner)\n\t{\n\t\tUpdateStorageState();\n\t\tif (CanFire \u0026\u0026 !(GetMounted() == null) \u0026\u0026 Interface.CallHook(\u0022OnMlrsFire\u0022, this, owner) == null)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved6, b: true);\n\t\t\tradiusModIndex = 0;\n\t\t\tnextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);\n\t\t\trocketOwnerRef.Set(owner);\n\t\t\tInvokeRepeating(FireNextRocket, 0f, 0.5f);\n\t\t\tInterface.CallHook(\u0022OnMlrsFired\u0022, this, owner);\n\t\t}\n\t}\n",
    "ClassName": "MLRS",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnEngineStart(MotorRowboat motorRowboat, BasePlayer driver)",
    "MethodSignature": "EngineToggle(bool wantsOn)",
    "MethodSourseCode": "\n\tpublic void EngineToggle(bool wantsOn)\n\t{\n\t\tif (!fuelSystem.HasFuel(forceCheck: true))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer driver = GetDriver();\n\t\tif (!wantsOn || Interface.CallHook(\u0022OnEngineStart\u0022, this, driver) == null)\n\t\t{\n\t\t\tSetFlag(Flags.On, wantsOn);\n\t\t\tif (wantsOn)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnEngineStarted\u0022, this, driver);\n\t\t\t}\n\t\t\tif (wantsOn)\n\t\t\t{\n\t\t\t\trigidBody.WakeUp();\n\t\t\t\tbuoyancy.Wake();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MotorRowboat",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnActiveItemChange(BasePlayer basePlayer, Item activeItem, ItemId itemID)",
    "MethodSignature": "UpdateActiveItem(ItemId itemID)",
    "MethodSourseCode": "\n\tpublic void UpdateActiveItem(ItemId itemID)\n\t{\n\t\tAssert.IsTrue(base.isServer, \u0022Realm should be server!\u0022);\n\t\tif (svActiveItemID == itemID)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (equippingBlocked)\n\t\t{\n\t\t\titemID = default(ItemId);\n\t\t}\n\t\tItem item = inventory.containerBelt.FindItemByUID(itemID);\n\t\tif (IsItemHoldRestricted(item))\n\t\t{\n\t\t\titemID = default(ItemId);\n\t\t}\n\t\tItem activeItem = GetActiveItem();\n\t\tif (Interface.CallHook(\u0022OnActiveItemChange\u0022, this, activeItem, itemID) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tsvActiveItemID = default(ItemId);\n\t\tif (activeItem != null)\n\t\t{\n\t\t\tHeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;\n\t\t\tif (heldEntity != null)\n\t\t\t{\n\t\t\t\theldEntity.SetHeld(bHeld: false);\n\t\t\t}\n\t\t}\n\t\tsvActiveItemID = itemID;\n\t\tSendNetworkUpdate();\n\t\tItem activeItem2 = GetActiveItem();\n\t\tif (activeItem2 != null)\n\t\t{\n\t\t\tHeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;\n\t\t\tif (heldEntity2 != null)\n\t\t\t{\n\t\t\t\theldEntity2.SetHeld(bHeld: true);\n\t\t\t}\n\t\t\tNotifyGesturesNewItemEquipped();\n\t\t}\n\t\tinventory.UpdatedVisibleHolsteredItems();\n\t\tInterface.CallHook(\u0022OnActiveItemChanged\u0022, this, activeItem, activeItem2);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer rpcPlayer, int num, int num2)",
    "MethodSignature": "BuyItem(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(5uL)]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void BuyItem(RPCMessage rpc)\n\t{\n\t\tif (!OccupiedCheck(rpc.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = rpc.read.Int32();\n\t\tint num2 = rpc.read.Int32();\n\t\tif (IsVending())\n\t\t{\n\t\t\trpc.player.ShowToast(GameTip.Styles.Red_Normal, WaitForVendingMessage, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnBuyVendingItem\u0022, this, rpc.player, num, num2) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint num3 = 0;\n\t\t\tfor (int i = 0; i \u003C sellOrders.sellOrders.Count; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellOrders.sellOrders[i].itemToSellID);\n\t\t\t\tItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(sellOrders.sellOrders[i].currencyID);\n\t\t\t\tif (itemDefinition.IsAllowed(CurrentEraRestriction) \u0026\u0026 itemDefinition2.IsAllowed(CurrentEraRestriction))\n\t\t\t\t{\n\t\t\t\t\tif (num3 == num)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnum3\u002B\u002B;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSetPendingOrder(rpc.player, num, num2);\n\t\t\tInvoke(CompletePendingOrder, GetBuyDuration());\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, StorageContainer storageContainer)",
    "MethodSignature": "PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)",
    "MethodSourseCode": "\n\tpublic virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = \u0022\u0022, bool doPositionChecks = true)\n\t{\n\t\tif (Interface.CallHook(\u0022CanLootEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsLocked() || IsTransferring())\n\t\t{\n\t\t\tplayer.ShowToast(GameTip.Styles.Red_Normal, LockedMessage, false);\n\t\t\treturn false;\n\t\t}\n\t\tif (onlyOneUser \u0026\u0026 IsOpen())\n\t\t{\n\t\t\tplayer.ShowToast(GameTip.Styles.Red_Normal, InUseMessage, false);\n\t\t\treturn false;\n\t\t}\n\t\tif (panelToOpen == \u0022\u0022)\n\t\t{\n\t\t\tpanelToOpen = panelName;\n\t\t}\n\t\tif (!CanOpenLootPanel(player, panelToOpen))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player.inventory.loot.StartLootingEntity(this, doPositionChecks))\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\tAddContainers(player.inventory.loot);\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\u0022RPC_OpenLootPanel\u0022, player), panelToOpen);\n\t\t\tSendNetworkUpdate();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "StorageContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanHelicopterStrafe(PatrolHelicopterAI patrolHelicopterAI)",
    "MethodSignature": "CanStrafe()",
    "MethodSourseCode": "\n\tpublic bool CanStrafe()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterStrafe\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (UnityEngine.Time.realtimeSinceStartup - lastStrafeTime \u003E= UnityEngine.Random.Range(15f, 25f))\n\t\t{\n\t\t\treturn CanInterruptState();\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSupplyDropDropped(BaseEntity baseEntity, CargoPlane cargoPlane)",
    "MethodSignature": "Update()",
    "MethodSourseCode": "\n\tprivate void Update()\n\t{\n\t\tif (!base.isServer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tsecondsTaken \u002B= Time.deltaTime;\n\t\tfloat num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);\n\t\tif (!dropped \u0026\u0026 num \u003E= 0.5f)\n\t\t{\n\t\t\tdropped = true;\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, base.transform.position);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.globalBroadcast = true;\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t\tInterface.CallHook(\u0022OnSupplyDropDropped\u0022, baseEntity, this);\n\t\t\t}\n\t\t}\n\t\tbase.transform.position = Vector3.Lerp(startPos, endPos, num);\n\t\tbase.transform.hasChanged = true;\n\t\tif (num \u003E= 1f)\n\t\t{\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "CargoPlane",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnCrateHackEnd(HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "HackProgress()",
    "MethodSourseCode": "\n\tpublic void HackProgress()\n\t{\n\t\thackSeconds \u002B= 1f;\n\t\tif (hackSeconds \u003E requiredHackSeconds)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnCrateHackEnd\u0022, this);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnLockedCrateFinished(originalHackerPlayerId, this);\n\t\t\tif (originalHackerPlayer != null \u0026\u0026 originalHackerPlayer.serverClan != null)\n\t\t\t{\n\t\t\t\toriginalHackerPlayer.AddClanScore(ClanScoreEventType.HackedCrate);\n\t\t\t}\n\t\t\tRefreshDecay();\n\t\t\tSetFlag(Flags.Reserved2, b: true);\n\t\t\tisLootable = true;\n\t\t\tCancelInvoke(HackProgress);\n\t\t}\n\t\tClientRPC(RpcTarget.NetworkGroup(\u0022UpdateHackProgress\u0022), (int)hackSeconds, (int)requiredHackSeconds);\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanPickupEntity(BasePlayer player, BaseCombatEntity baseCombatEntity)",
    "MethodSignature": "CanPickup(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanPickup(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanPickupEntity\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tbool flag = pickup.enabled \u0026\u0026 (!pickup.requireBuildingPrivilege || player.CanBuild()) \u0026\u0026 (!pickup.requireHammer || player.IsHoldingEntity\u003CHammer\u003E()) \u0026\u0026 player != null \u0026\u0026 !player.IsInTutorial;\n\t\tif (flag)\n\t\t{\n\t\t\tPickupVolume[] volumes = PrefabAttribute.server.FindAll\u003CPickupVolume\u003E(prefabID);\n\t\t\tif (PickupVolume.Check(base.transform.position, base.transform.rotation, volumes, this))\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanAcceptItem(ItemContainer itemContainer, Item item, int targetPos)",
    "MethodSignature": "CanAcceptItem(Item item, int targetPos)",
    "MethodSourseCode": "\n\tpublic CanAcceptResult CanAcceptItem(Item item, int targetPos)\n\t{\n\t\tif (canAcceptItem != null \u0026\u0026 !canAcceptItem(item, targetPos))\n\t\t{\n\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t}\n\t\tif (isServer \u0026\u0026 availableSlots != null \u0026\u0026 availableSlots.Count \u003E 0)\n\t\t{\n\t\t\tif (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)\n\t\t\t{\n\t\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t\t}\n\t\t\tif (item.isBroken)\n\t\t\t{\n\t\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t\t}\n\t\t\tint num = 0;\n\t\t\tforeach (ItemSlot availableSlot in availableSlots)\n\t\t\t{\n\t\t\t\tnum |= (int)availableSlot;\n\t\t\t}\n\t\t\tif (((uint)num \u0026 (uint)item.info.occupySlots) != (uint)item.info.occupySlots)\n\t\t\t{\n\t\t\t\treturn CanAcceptResult.CannotAcceptRightNow;\n\t\t\t}\n\t\t}\n\t\tif ((allowedContents \u0026 item.info.itemType) != item.info.itemType)\n\t\t{\n\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t}\n\t\tif (HasLimitedAllowedItems)\n\t\t{\n\t\t\tbool flag = false;\n\t\t\tfor (int i = 0; i \u003C onlyAllowedItems.Length; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tif (onlyAllowedItems[i] == item.info)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t\t}\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanAcceptItem\u0022, this, item, targetPos);\n\t\tif (obj is CanAcceptResult)\n\t\t{\n\t\t\treturn (CanAcceptResult)obj;\n\t\t}\n\t\tif (blockedItems != null \u0026\u0026 blockedItems.Contains(item.info))\n\t\t{\n\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t}\n\t\tif (item.GetItemVolume() \u003E containerVolume)\n\t\t{\n\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t}\n\t\treturn CanAcceptResult.CanAccept;\n\t}\n",
    "ClassName": "ItemContainer",
    "HookLineInvoke": 47
  },
  {
    "HookSignature": "CanPickupLock(BasePlayer rpcPlayer, BaseLock baseLock)",
    "MethodSignature": "RPC_TakeLock(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f, CheckParent = true)]\n\t[RPC_Server]\n\tpublic void RPC_TakeLock(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 CanRemove \u0026\u0026 Interface.CallHook(\u0022CanPickupLock\u0022, rpc.player, this) == null \u0026\u0026 !IsLocked())\n\t\t{\n\t\t\tItem item = ItemManager.Create(itemType, 1, skinID);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\trpc.player.GiveItem(item);\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityPickedUp(rpc.player, this);\n\t\t\tBaseEntity baseEntity = GetParentEntity();\n\t\t\tif (baseEntity != null \u0026\u0026 baseEntity.GetSlot(Slot.Lock) == this)\n\t\t\t{\n\t\t\t\tbaseEntity.SetSlot(Slot.Lock, null);\n\t\t\t}\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "BaseLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerAssist(BasePlayer basePlayer, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_Assist(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_Assist(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 !(msg.player == this) \u0026\u0026 IsWounded() \u0026\u0026 Interface.CallHook(\u0022OnPlayerAssist\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tStopWounded(msg.player);\n\t\t\tmsg.player.stats.Add(\u0022wounded_assisted\u0022, 1, (Stats)5);\n\t\t\tstats.Add(\u0022wounded_healed\u0022, 1);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanDeployItem(BasePlayer msgPlayer, Deployer deployer, NetworkableId networkableId)",
    "MethodSignature": "DoDeploy(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void DoDeploy(RPCMessage msg)\n\t{\n\t\tif (!msg.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDeployable deployable = GetDeployable();\n\t\tif (deployable == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tRay ray = msg.read.Ray();\n\t\tNetworkableId networkableId = msg.read.EntityID();\n\t\tif (Interface.CallHook(\u0022CanDeployItem\u0022, msg.player, this, networkableId) == null)\n\t\t{\n\t\t\tif (deployable.toSlot)\n\t\t\t{\n\t\t\t\tDoDeploy_Slot(deployable, ray, networkableId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDoDeploy_Regular(deployable, ray);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Deployer",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnCupboardClearList(BuildingPrivlidge buildingPrivlidge, BasePlayer rpcPlayer)",
    "MethodSignature": "ClearList(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void ClearList(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 CanAdministrate(rpc.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardClearList\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.Clear();\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnNpcConversationResponded(NPCTalking nPCTalking, BasePlayer player, ConversationData conversationFor, ConversationData.ResponseNode responseNode)",
    "MethodSignature": "Server_ResponsePressed(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\tpublic void Server_ResponsePressed(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint num = msg.read.Int32();\n\t\tint num2 = msg.read.Int32();\n\t\tuint id = msg.read.UInt32();\n\t\tConversationData conversationFor = GetConversationFor(player);\n\t\tif (conversationFor == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (conversationFor.speeches[num].shortname == \u0022generic_mission_provider_list\u0022)\n\t\t{\n\t\t\tnum2 = 0;\n\t\t}\n\t\tif (conversationFor.speeches[num].shortname == \u0022generic_mission_provider_list_mission_preview\u0022 \u0026\u0026 num2 == 0)\n\t\t{\n\t\t\tBaseMission genericMissionById = GetGenericMissionById(id);\n\t\t\tif (genericMissionById != null \u0026\u0026 player.CanAcceptMission(genericMissionById))\n\t\t\t{\n\t\t\t\tTryAssignMissionToPlayer(genericMissionById, player);\n\t\t\t}\n\t\t}\n\t\tConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\n\t\tif (responseNode == null || Interface.CallHook(\u0022OnNpcConversationRespond\u0022, this, player, conversationFor, responseNode) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (responseNode.conditions.Length != 0)\n\t\t{\n\t\t\tUpdateFlags();\n\t\t}\n\t\tbool flag = responseNode.PassesConditions(player, this);\n\t\tif (flag)\n\t\t{\n\t\t\tstring actionString = responseNode.GetActionString();\n\t\t\tif (!string.IsNullOrEmpty(actionString))\n\t\t\t{\n\t\t\t\tOnConversationAction(player, actionString);\n\t\t\t}\n\t\t}\n\t\tint speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));\n\t\tif (speechNodeIndex == -1)\n\t\t{\n\t\t\tForceEndConversation(player);\n\t\t\treturn;\n\t\t}\n\t\tForceSpeechNode(player, speechNodeIndex);\n\t\tInterface.CallHook(\u0022OnNpcConversationResponded\u0022, this, player, conversationFor, responseNode);\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 52
  },
  {
    "HookSignature": "OnRackedWeaponSwap(Item item, WeaponRackSlot weaponAtIndex, BasePlayer player, WeaponRack weaponRack)",
    "MethodSignature": "SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)",
    "MethodSourseCode": "\n\tprivate void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)\n\t{\n\t\tItem item = player.GetHeldEntity()?.GetItem();\n\t\tif (item == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tWorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);\n\t\tif (forItemDef == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);\n\t\tif (weaponAtIndex != null)\n\t\t{\n\t\t\tint mountSlotIndex = gridCellIndex;\n\t\t\tif (CustomRackType != 0)\n\t\t\t{\n\t\t\t\tgridCellIndex = 0;\n\t\t\t}\n\t\t\tint bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);\n\t\t\tif (bestPlacementCellIndex != -1 \u0026\u0026 Interface.CallHook(\u0022OnRackedWeaponSwap\u0022, item, weaponAtIndex, player, this) == null)\n\t\t\t{\n\t\t\t\titem.RemoveFromContainer();\n\t\t\t\tGivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);\n\t\t\t\tMountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);\n\t\t\t\tItemManager.DoRemoves();\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tInterface.CallHook(\u0022OnRackedWeaponSwapped\u0022, item, weaponAtIndex, player, this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "WeaponRack",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnBoomboxStationUpdated(BoomBox boomBox, string text, BasePlayer msgPlayer)",
    "MethodSignature": "Server_UpdateRadioIP(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void Server_UpdateRadioIP(BaseEntity.RPCMessage msg)\n\t{\n\t\tstring text = msg.read.String();\n\t\tif (Interface.CallHook(\u0022OnBoomboxStationUpdate\u0022, this, text, msg.player) == null \u0026\u0026 IsStationValid(text))\n\t\t{\n\t\t\tif (msg.player != null)\n\t\t\t{\n\t\t\t\tulong assignedRadioBy = msg.player.userID.Get();\n\t\t\t\tAssignedRadioBy = assignedRadioBy;\n\t\t\t}\n\t\t\tCurrentRadioIp = text;\n\t\t\tbase.baseEntity.ClientRPC(RpcTarget.NetworkGroup(\u0022OnRadioIPChanged\u0022), CurrentRadioIp);\n\t\t\tInterface.CallHook(\u0022OnBoomboxStationUpdated\u0022, this, text, msg.player);\n\t\t\tif (IsOn())\n\t\t\t{\n\t\t\t\tServerTogglePlay(play: false);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BoomBox",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnItemDeployed(Deployer deployer, BaseEntity baseEntity, BaseEntity baseEntity2)",
    "MethodSignature": "DoDeploy_Slot(Deployable deployable, Ray ray, NetworkableId entityID)",
    "MethodSourseCode": "\n\tpublic void DoDeploy_Slot(Deployable deployable, Ray ray, NetworkableId entityID)\n\t{\n\t\tif (!HasItemAmount())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!ownerPlayer.CanBuild())\n\t\t{\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;\n\t\tif (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ownerPlayer.Distance(baseEntity) \u003E 3f)\n\t\t{\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.TooFarAway, false);\n\t\t\treturn;\n\t\t}\n\t\tif (!ownerPlayer.CanBuild(baseEntity.WorldSpaceBounds()))\n\t\t{\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);\n\t\t\treturn;\n\t\t}\n\t\tif (ownerPlayer.IsInTutorial)\n\t\t{\n\t\t\tTutorialIsland currentTutorialIsland = ownerPlayer.GetCurrentTutorialIsland();\n\t\t\tif (currentTutorialIsland != null \u0026\u0026 !currentTutorialIsland.CheckPlacement(ownerPlayer, deployable, baseEntity.transform.position, baseEntity.transform.rotation))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tItem ownerItem = GetOwnerItem();\n\t\tItemModDeployable modDeployable = GetModDeployable();\n\t\tBaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);\n\t\tif (baseEntity2 != null)\n\t\t{\n\t\t\tbaseEntity2.skinID = ownerItem.skin;\n\t\t\tbaseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));\n\t\t\tbaseEntity2.OwnerID = ownerPlayer.userID;\n\t\t\tbaseEntity2.OnDeployed(baseEntity, ownerPlayer, ownerItem);\n\t\t\tbaseEntity2.Spawn();\n\t\t\tbaseEntity.SetSlot(deployable.slot, baseEntity2);\n\t\t\tif (deployable.placeEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tif (ownerPlayer.IsInTutorial)\n\t\t\t{\n\t\t\t\tTutorialIsland currentTutorialIsland2 = ownerPlayer.GetCurrentTutorialIsland();\n\t\t\t\tif (currentTutorialIsland2 != null)\n\t\t\t\t{\n\t\t\t\t\tcurrentTutorialIsland2.OnPlayerBuiltConstruction(ownerPlayer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (GetOwnerItemDefinition() != null)\n\t\t\t{\n\t\t\t\townerPlayer.ProcessMissionEvent(BaseMission.MissionEventType.DEPLOY, new BaseMission.MissionEventPayload\n\t\t\t\t{\n\t\t\t\t\tWorldPosition = baseEntity2.transform.position,\n\t\t\t\t\tUintIdentifier = baseEntity2.prefabID,\n\t\t\t\t\tIntIdentifier = GetOwnerItemDefinition().itemid\n\t\t\t\t}, 1f);\n\t\t\t}\n\t\t}\n\t\tmodDeployable.OnDeployed(baseEntity2, ownerPlayer);\n\t\tInterface.CallHook(\u0022OnItemDeployed\u0022, this, baseEntity, baseEntity2);\n\t\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity2, ownerPlayer);\n\t\tif (!ownerPlayer.IsInCreativeMode || !Creative.freeBuild)\n\t\t{\n\t\t\tUseItemAmount(1);\n\t\t}\n\t}\n",
    "ClassName": "Deployer",
    "HookLineInvoke": 74
  },
  {
    "HookSignature": "OnCrateDropped(HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "SetWasDropped()",
    "MethodSourseCode": "\n\tpublic void SetWasDropped()\n\t{\n\t\twasDropped = true;\n\t\tInterface.CallHook(\u0022OnCrateDropped\u0022, this);\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnClientAuth(Network.Connection packetConnection)",
    "MethodSignature": "OnGiveUserInformation(Message packet)",
    "MethodSourseCode": "\n\tprivate void OnGiveUserInformation(Message packet)\n\t{\n\t\tif (packet.connection.state != 0)\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid connection state\u0022);\n\t\t\treturn;\n\t\t}\n\t\tpacket.connection.state = Network.Connection.State.Connecting;\n\t\tif (packet.read.UInt8() != 228)\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Connection Protocol\u0022);\n\t\t\treturn;\n\t\t}\n\t\tpacket.connection.userid = packet.read.UInt64();\n\t\tpacket.connection.protocol = packet.read.UInt32();\n\t\tpacket.connection.os = packet.read.String(128);\n\t\tpacket.connection.username = packet.read.String();\n\t\tif (string.IsNullOrEmpty(packet.connection.os))\n\t\t{\n\t\t\tthrow new Exception(\u0022Invalid OS\u0022);\n\t\t}\n\t\tif (string.IsNullOrEmpty(packet.connection.username))\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Username\u0022);\n\t\t\treturn;\n\t\t}\n\t\tpacket.connection.username = packet.connection.username.Replace(\u0027\\n\u0027, \u0027 \u0027).Replace(\u0027\\r\u0027, \u0027 \u0027).Replace(\u0027\\t\u0027, \u0027 \u0027)\n\t\t\t.Trim();\n\t\tif (string.IsNullOrEmpty(packet.connection.username))\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Username\u0022);\n\t\t\treturn;\n\t\t}\n\t\tstring text = string.Empty;\n\t\tstring branch = ConVar.Server.branch;\n\t\tif (packet.read.Unread \u003E= 4)\n\t\t{\n\t\t\ttext = packet.read.String(128);\n\t\t}\n\t\tInterface.CallHook(\u0022OnClientAuth\u0022, packet.connection);\n\t\tif (branch != string.Empty \u0026\u0026 branch != text)\n\t\t{\n\t\t\tDebugEx.Log(\u0022Kicking \u0022 \u002B packet.connection?.ToString() \u002B \u0022 - their branch is \u0027\u0022 \u002B text \u002B \u0022\u0027 not \u0027\u0022 \u002B branch \u002B \u0022\u0027\u0022);\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Wrong Steam Beta: Requires \u0027\u0022 \u002B branch \u002B \u0022\u0027 branch!\u0022);\n\t\t}\n\t\telse if (packet.connection.protocol \u003E 2594)\n\t\t{\n\t\t\tDebugEx.Log(\u0022Kicking \u0022 \u002B packet.connection?.ToString() \u002B \u0022 - their protocol is \u0022 \u002B packet.connection.protocol \u002B \u0022 not \u0022 \u002B 2594);\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Wrong Connection Protocol: Server update required!\u0022);\n\t\t}\n\t\telse if (packet.connection.protocol \u003C 2594)\n\t\t{\n\t\t\tDebugEx.Log(\u0022Kicking \u0022 \u002B packet.connection?.ToString() \u002B \u0022 - their protocol is \u0022 \u002B packet.connection.protocol \u002B \u0022 not \u0022 \u002B 2594);\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Wrong Connection Protocol: Client update required!\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpacket.connection.token = packet.read.BytesWithSize(512u);\n\t\t\tif (packet.connection.token == null || packet.connection.token.Length \u003C 1)\n\t\t\t{\n\t\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Token\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpacket.connection.anticheatId = packet.read.StringRaw(128);\n\t\t\tpacket.connection.anticheatToken = packet.read.StringRaw(2048);\n\t\t\tpacket.connection.clientChangeset = packet.read.Int32();\n\t\t\tpacket.connection.clientBuildTime = packet.read.Int64();\n\t\t\tauth.OnNewConnection(packet.connection);\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 40
  },
  {
    "HookSignature": "OnMlrsRocketFired(MLRS mLRS, ServerProjectile projectile)",
    "MethodSignature": "FireNextRocket()",
    "MethodSourseCode": "\n\tpublic void FireNextRocket()\n\t{\n\t\tRocketAmmoCount = GetRocketContainer().inventory.GetAmmoAmount(AmmoTypes.MLRS_ROCKET);\n\t\tif (nextRocketIndex \u003C 0 || nextRocketIndex \u003E= RocketAmmoCount || IsBroken())\n\t\t{\n\t\t\tEndFiring();\n\t\t\treturn;\n\t\t}\n\t\tStorageContainer rocketContainer = GetRocketContainer();\n\t\tVector3 firingPos = firingPoint.position \u002B firingPoint.rotation * rocketTubes[nextRocketIndex].firingOffset;\n\t\tfloat num = 1f;\n\t\tif (radiusModIndex \u003C radiusMods.Length)\n\t\t{\n\t\t\tnum = radiusMods[radiusModIndex];\n\t\t}\n\t\tradiusModIndex\u002B\u002B;\n\t\tVector2 vector = UnityEngine.Random.insideUnitCircle * (targetAreaRadius - RocketDamageRadius) * num;\n\t\tVector3 target = TrueHitPos \u002B new Vector3(vector.x, 0f, vector.y);\n\t\tfloat requiredGravity;\n\t\tVector3 aimToTarget = Ballistics.GetAimToTarget(firingPoint.position, target, rocketSpeed, vRotMax, rocketBaseGravity, minRange, out requiredGravity);\n\t\tif (TryFireProjectile(rocketContainer, AmmoTypes.MLRS_ROCKET, firingPos, aimToTarget, rocketOwnerRef.Get(serverside: true) as BasePlayer, 0f, 0f, out var projectile))\n\t\t{\n\t\t\tprojectile.gravityModifier = requiredGravity / (0f - UnityEngine.Physics.gravity.y);\n\t\t\tInterface.CallHook(\u0022OnMlrsRocketFired\u0022, this, projectile);\n\t\t\tnextRocketIndex--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEndFiring();\n\t\t}\n\t}\n",
    "ClassName": "MLRS",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnRfFrequencyChanged(RFBroadcaster rFBroadcaster, int freq, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(3uL)]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!CanChangeFrequency(msg.player) || UnityEngine.Time.time \u003C nextChangeTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\tint freq = msg.read.Int32();\n\t\tfreq = RFManager.ClampFrequency(freq);\n\t\tif (RFManager.IsReserved(freq))\n\t\t{\n\t\t\tRFManager.ReserveErrorPrint(msg.player);\n\t\t\treturn;\n\t\t}\n\t\tRFManager.ChangeFrequency(frequency, freq, this, isListener: false, IsPowered());\n\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, freq, msg.player) == null)\n\t\t{\n\t\t\tfrequency = freq;\n\t\t\tMarkDirty();\n\t\t\tSendNetworkUpdate();\n\t\t\tHurt(MaxHealth() * 0.01f, DamageType.Decay, this);\n\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, freq, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "RFBroadcaster",
    "HookLineInvoke": 25
  },
  {
    "HookSignature": "OnOutputUpdate(IOEntity iOEntity)",
    "MethodSignature": "UpdateOutputs()",
    "MethodSourseCode": "\n\tpublic virtual void UpdateOutputs()\n\t{\n\t\tif (Interface.CallHook(\u0022OnOutputUpdate\u0022, this) != null || !ShouldUpdateOutputs() || !ensureOutputsUpdated)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tensureOutputsUpdated = false;\n\t\tusing (TimeWarning.New(\u0022ProcessIOOutputs\u0022))\n\t\t{\n\t\t\tfor (int i = 0; i \u003C outputs.Length; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tIOSlot iOSlot = outputs[i];\n\t\t\t\tbool flag = true;\n\t\t\t\tIOEntity iOEntity = iOSlot.connectedTo.Get();\n\t\t\t\tif (!(iOEntity != null))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ioType == IOType.Fluidic \u0026\u0026 !DisregardGravityRestrictionsOnLiquid \u0026\u0026 !iOEntity.DisregardGravityRestrictionsOnLiquid)\n\t\t\t\t{\n\t\t\t\t\tusing (TimeWarning.New(\u0022FluidOutputProcessing\u0022))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!iOEntity.AllowLiquidPassthrough(this, base.transform.TransformPoint(iOSlot.handlePosition)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint passthroughAmount = GetPassthroughAmount(i);\n\t\t\t\tiOEntity.UpdateFromInput(flag ? passthroughAmount : 0, iOSlot.connectedToSlot);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "IOEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnMapMarkerAdd(BasePlayer basePlayer, ProtoBuf.MapNote mapNote)",
    "MethodSignature": "Server_AddMarker(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.FromOwner(false)]\n\t[RPC_Server.CallsPerSecond(8uL)]\n\t[RPC_Server]\n\tpublic void Server_AddMarker(RPCMessage msg)\n\t{\n\t\tMapNote mapNote = msg.read.Proto\u003CMapNote\u003E();\n\t\tif (Interface.CallHook(\u0022OnMapMarkerAdd\u0022, this, mapNote) != null || !CanUseMapMarkers)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (State.pointsOfInterest == null)\n\t\t{\n\t\t\tState.pointsOfInterest = Facepunch.Pool.Get\u003CList\u003CMapNote\u003E\u003E();\n\t\t}\n\t\tif (State.pointsOfInterest.Count \u003E= ConVar.Server.maximumMapMarkers)\n\t\t{\n\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, false, ConVar.Server.maximumMapMarkers.ToString());\n\t\t\treturn;\n\t\t}\n\t\tif (mapNote.label == \u0022auto-name\u0022)\n\t\t{\n\t\t\tint num = FindUnusedNumberName();\n\t\t\tif (num != -1)\n\t\t\t{\n\t\t\t\tmapNote.label = num.ToString();\n\t\t\t}\n\t\t}\n\t\tValidateMapNote(mapNote);\n\t\tif (mapNote.colourIndex == -1)\n\t\t{\n\t\t\tmapNote.colourIndex = FindUnusedPointOfInterestColour();\n\t\t}\n\t\tState.pointsOfInterest.Add(mapNote);\n\t\tDirtyPlayerState();\n\t\tSendMarkersToClient();\n\t\tTeamUpdate();\n\t\tInterface.CallHook(\u0022OnMapMarkerAdded\u0022, this, mapNote);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnSensorDetect(HBHFSensor hBHFSensor, BasePlayer basePlayer)",
    "MethodSignature": "UpdatePassthroughAmount()",
    "MethodSourseCode": "\n\tpublic void UpdatePassthroughAmount()\n\t{\n\t\tif (base.isClient || !IsPowered())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = detectedPlayers;\n\t\tdetectedPlayers = 0;\n\t\tif (myTrigger.entityContents != null \u0026\u0026 myTrigger.entityContents.Count \u003E 0)\n\t\t{\n\t\t\tBuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();\n\t\t\tforeach (BaseEntity entityContent in myTrigger.entityContents)\n\t\t\t{\n\t\t\t\tif (entityContent is BasePlayer basePlayer \u0026\u0026 Interface.CallHook(\u0022OnSensorDetect\u0022, this, basePlayer) == null \u0026\u0026 !(basePlayer == null) \u0026\u0026 !basePlayer.IsDead() \u0026\u0026 !basePlayer.IsSleeping() \u0026\u0026 basePlayer.isServer)\n\t\t\t\t{\n\t\t\t\t\tbool flag = buildingPrivilege != null \u0026\u0026 buildingPrivilege.IsAuthed(basePlayer);\n\t\t\t\t\tif ((!flag || ShouldIncludeAuthorized()) \u0026\u0026 (flag || ShouldIncludeOthers()) \u0026\u0026 entityContent.IsVisible(base.transform.position \u002B base.transform.forward * 0.1f, range))\n\t\t\t\t\t{\n\t\t\t\t\t\tdetectedPlayers\u002B\u002B;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num != detectedPlayers)\n\t\t{\n\t\t\tMarkDirty();\n\t\t\tif (detectedPlayers \u003E num)\n\t\t\t{\n\t\t\t\tEffect.server.Run(detectUp.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t\telse if (detectedPlayers \u003C num)\n\t\t\t{\n\t\t\t\tEffect.server.Run(detectDown.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "HBHFSensor",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnInventoryItemFind(PlayerInventory playerInventory, int id)",
    "MethodSignature": "FindItemByItemID(int id)",
    "MethodSourseCode": "\n\tpublic Item FindItemByItemID(int id)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnInventoryItemFind\u0022, this, id);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\tif (containerMain != null)\n\t\t{\n\t\t\tItem item = containerMain.FindItemByItemID(id);\n\t\t\tif (item != null \u0026\u0026 item.IsValid())\n\t\t\t{\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\t\tif (containerBelt != null)\n\t\t{\n\t\t\tItem item2 = containerBelt.FindItemByItemID(id);\n\t\t\tif (item2 != null \u0026\u0026 item2.IsValid())\n\t\t\t{\n\t\t\t\treturn item2;\n\t\t\t}\n\t\t}\n\t\tif (containerWear != null)\n\t\t{\n\t\t\tItem item3 = containerWear.FindItemByItemID(id);\n\t\t\tif (item3 != null \u0026\u0026 item3.IsValid())\n\t\t\t{\n\t\t\t\treturn item3;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemAction(Item item, string text, BasePlayer msgPlayer)",
    "MethodSignature": "ItemCmd(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\t[BaseEntity.RPC_Server.FromOwner(false)]\n\t[BaseEntity.RPC_Server]\n\tprivate void ItemCmd(BaseEntity.RPCMessage msg)\n\t{\n\t\tif ((msg.player != null \u0026\u0026 msg.player.IsWounded()) || base.baseEntity.IsTransferring())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemId id = msg.read.ItemID();\n\t\tstring text = msg.read.String();\n\t\tItem item = FindItemByUID(id);\n\t\tif (item == null || Interface.CallHook(\u0022OnItemAction\u0022, item, text, msg.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity entityOwner = item.GetEntityOwner();\n\t\tif ((entityOwner != null \u0026\u0026 entityOwner == msg.player \u0026\u0026 msg.player.IsRestrainedOrSurrendering) || item.IsLocked() || (item.parent != null \u0026\u0026 item.parent.IsLocked()) || !CanMoveItemsFrom(item.GetEntityOwner(), item))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (text == \u0022drop\u0022)\n\t\t{\n\t\t\tint num = item.amount;\n\t\t\tif (msg.read.Unread \u003E= 4)\n\t\t\t{\n\t\t\t\tnum = msg.read.Int32();\n\t\t\t}\n\t\t\tif (!msg.player.isMounted \u0026\u0026 !msg.player.HasParent() \u0026\u0026 !GamePhysics.LineOfSight(msg.player.transform.position, msg.player.eyes.position, 1218519041))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbase.baseEntity.stats.Add(\u0022item_drop\u0022, 1, (Stats)5);\n\t\t\tif (num \u003C item.amount)\n\t\t\t{\n\t\t\t\tItem item2 = item.SplitItem(num);\n\t\t\t\tItemContainer parent = item.parent;\n\t\t\t\tif (item2 != null)\n\t\t\t\t{\n\t\t\t\t\tVector3 dropVelocity = GetDropVelocity(msg);\n\t\t\t\t\tDroppedItem droppedItem = item2.Drop(base.baseEntity.GetDropPosition(), dropVelocity) as DroppedItem;\n\t\t\t\t\tif (droppedItem != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdroppedItem.DropReason = DroppedItem.DropReasonEnum.Player;\n\t\t\t\t\t\tdroppedItem.DroppedBy = base.baseEntity.userID;\n\t\t\t\t\t\tdroppedItem.DroppedTime = DateTime.UtcNow;\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem, DroppedItem.DropReasonEnum.Player);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparent?.onItemRemovedFromStack?.Invoke(item, num);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tVector3 dropVelocity2 = GetDropVelocity(msg);\n\t\t\t\tItemContainer parent2 = item.parent;\n\t\t\t\tDroppedItem droppedItem2 = item.Drop(base.baseEntity.GetDropPosition(), dropVelocity2) as DroppedItem;\n\t\t\t\tif (droppedItem2 != null)\n\t\t\t\t{\n\t\t\t\t\tdroppedItem2.DropReason = DroppedItem.DropReasonEnum.Player;\n\t\t\t\t\tdroppedItem2.DroppedBy = base.baseEntity.userID;\n\t\t\t\t\tdroppedItem2.DroppedTime = DateTime.UtcNow;\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem2, DroppedItem.DropReasonEnum.Player);\n\t\t\t\t}\n\t\t\t\tparent2?.onItemAddedRemoved?.Invoke(item, arg2: false);\n\t\t\t}\n\t\t\tbase.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, \u0022drop_item\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem.ServerCommand(text, base.baseEntity);\n\t\t\tItemManager.DoRemoves();\n\t\t\tServerUpdate(0f);\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnSignContentCopied(SignContent signContent, ISignage s, IUGCBrowserEntity b)",
    "MethodSignature": "CopyInfoToSign(ISignage s, IUGCBrowserEntity b)",
    "MethodSourseCode": "\n\tpublic void CopyInfoToSign(ISignage s, IUGCBrowserEntity b)\n\t{\n\t\tFileStorage.server.ReassignEntityId(net.ID, s.NetworkID);\n\t\ts.SetTextureCRCs(textureIDs);\n\t\tb.EditingHistory.Clear();\n\t\tforeach (ulong item in editHistory)\n\t\t{\n\t\t\tb.EditingHistory.Add(item);\n\t\t}\n\t\tInterface.CallHook(\u0022OnSignContentCopied\u0022, this, s, b);\n\t}\n",
    "ClassName": "SignContent",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnEntityPickedUp(BaseCombatEntity baseCombatEntity, Item createdItem, BasePlayer player)",
    "MethodSignature": "OnPickedUp(Item createdItem, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void OnPickedUp(Item createdItem, BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnEntityPickedUp\u0022, this, createdItem, player);\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnOvenToggle(BaseOven baseOven, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprotected virtual void SVSwitch(RPCMessage msg)\n\t{\n\t\tbool flag = msg.read.Bit();\n\t\tif (Interface.CallHook(\u0022OnOvenToggle\u0022, this, msg.player) != null || flag == IsOn() || (needsBuildingPrivilegeToUse \u0026\u0026 !msg.player.CanBuild()))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tStartCooking();\n\t\t\tif (msg.player != null)\n\t\t\t{\n\t\t\t\tmsg.player.ProcessMissionEvent(BaseMission.MissionEventType.STARTOVEN, new BaseMission.MissionEventPayload\n\t\t\t\t{\n\t\t\t\t\tUintIdentifier = prefabID,\n\t\t\t\t\tNetworkIdentifier = net.ID\n\t\t\t\t}, 1f);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStopCooking();\n\t\t}\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnBuildingPrivilege(BaseEntity baseEntity, OBB obb, bool cached, float cacheDuration, BuildingPrivlidge exclude)",
    "MethodSignature": "GetBuildingPrivilege(OBB obb, bool cached, float cacheDuration, BuildingPrivlidge exclude)",
    "MethodSourseCode": "\n\tpublic BuildingPrivlidge GetBuildingPrivilege(OBB obb, bool cached, float cacheDuration = 1f, BuildingPrivlidge exclude = null)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnBuildingPrivilege\u0022, this, obb, cached, cacheDuration, exclude);\n\t\tif (obj is BuildingPrivlidge)\n\t\t{\n\t\t\treturn (BuildingPrivlidge)obj;\n\t\t}\n\t\tif (cached \u0026\u0026 cachedBuildingPrivilegeTime != 0f \u0026\u0026 UnityEngine.Time.time - cachedBuildingPrivilegeTime \u003C cacheDuration)\n\t\t{\n\t\t\treturn cachedBuildingPrivilege;\n\t\t}\n\t\tBuildingBlock other = null;\n\t\tBuildingPrivlidge buildingPrivlidge = null;\n\t\tList\u003CBuildingBlock\u003E obj2 = Facepunch.Pool.Get\u003CList\u003CBuildingBlock\u003E\u003E();\n\t\tVis.Entities(obb.position, 16f \u002B obb.extents.magnitude, obj2, 2097152);\n\t\tuint num = ((exclude != null) ? exclude.buildingID : 0u);\n\t\tfor (int i = 0; i \u003C obj2.Count; i\u002B\u002B)\n\t\t{\n\t\t\tBuildingBlock buildingBlock = obj2[i];\n\t\t\tif (buildingBlock.isServer != base.isServer || !buildingBlock.IsOlderThan(other) || obb.Distance(buildingBlock.WorldSpaceBounds()) \u003E 16f)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tBuildingManager.Building building = buildingBlock.GetBuilding();\n\t\t\tif (building != null \u0026\u0026 (num == 0 || num != building.ID))\n\t\t\t{\n\t\t\t\tBuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();\n\t\t\t\tif (!(dominatingBuildingPrivilege == null))\n\t\t\t\t{\n\t\t\t\t\tother = buildingBlock;\n\t\t\t\t\tbuildingPrivlidge = dominatingBuildingPrivilege;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\n\t\tcachedBuildingPrivilegeTime = UnityEngine.Time.time;\n\t\tcachedBuildingPrivilege = buildingPrivlidge;\n\t\treturn cachedBuildingPrivilege;\n\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnGiveSoldItem(VendingMachine vendingMachine, Item soldItem, BasePlayer buyer)",
    "MethodSignature": "GiveSoldItem(Item soldItem, BasePlayer buyer)",
    "MethodSourseCode": "\n\tpublic virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)\n\t{\n\t\tif (Interface.CallHook(\u0022OnGiveSoldItem\u0022, this, soldItem, buyer) == null)\n\t\t{\n\t\t\twhile (soldItem.amount \u003E soldItem.MaxStackable())\n\t\t\t{\n\t\t\t\tItem item = soldItem.SplitItem(soldItem.MaxStackable());\n\t\t\t\tbuyer.GiveItem(item, GiveItemReason.PickedUp);\n\t\t\t}\n\t\t\tbuyer.GiveItem(soldItem, GiveItemReason.PickedUp);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnVehicleModuleMove(BaseVehicleModule moduleForItem, BaseModularVehicle baseModularVehicle, BasePlayer player)",
    "MethodSignature": "CanMoveFrom(BasePlayer player, Item item)",
    "MethodSourseCode": "\n\tpublic bool CanMoveFrom(BasePlayer player, Item item)\n\t{\n\t\tBaseVehicleModule moduleForItem = GetModuleForItem(item);\n\t\tif (moduleForItem != null)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnVehicleModuleMove\u0022, moduleForItem, this, player);\n\t\t\tif (obj != null)\n\t\t\t{\n\t\t\t\tif (!(obj is bool))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\treturn moduleForItem.CanBeMovedNow();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseModularVehicle",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPhotoCapture(PhotoEntity photoEntity, Item item, BasePlayer player, byte[] array)",
    "MethodSignature": "TakePhoto(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner(false)]\n\t[RPC_Server.CallsPerSecond(3uL)]\n\tprivate void TakePhoto(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tItem item = GetItem();\n\t\tif (player == null || item == null || item.condition \u003C= 0f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (array.Length \u003E 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item2 = ItemManager.Create(photoItem, 1, 0uL);\n\t\tif (item2 == null)\n\t\t{\n\t\t\tDebug.LogError(\u0022Failed to create photo item\u0022);\n\t\t\treturn;\n\t\t}\n\t\titem2.SetItemOwnership(msg.player, ItemOwnershipPhrases.Photographed);\n\t\tif (!item2.instanceData.subEntity.IsValid)\n\t\t{\n\t\t\titem2.Remove();\n\t\t\tDebug.LogError(\u0022Photo has no sub-entity\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);\n\t\tif (baseNetworkable == null)\n\t\t{\n\t\t\titem2.Remove();\n\t\t\tDebug.LogError(\u0022Sub-entity was not found\u0022);\n\t\t}\n\t\telse if (!(baseNetworkable is PhotoEntity photoEntity))\n\t\t{\n\t\t\titem2.Remove();\n\t\t\tDebug.LogError(\u0022Sub-entity is not a photo\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnPhotoCapture\u0022, photoEntity, item, player, array) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tphotoEntity.SetImageData(player.userID, array);\n\t\t\tif (!player.inventory.GiveItem(item2))\n\t\t\t{\n\t\t\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity());\n\t\t\t}\n\t\t\tEffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));\n\t\t\tif (HasFlag(Flags.Reserved5))\n\t\t\t{\n\t\t\t\tEffectNetwork.Send(new Effect(flashEffect.resourcePath, localFlash.transform.position, localFlash.transform.forward, msg.connection));\n\t\t\t}\n\t\t\tif (!hasSentAchievement \u0026\u0026 !string.IsNullOrEmpty(\u0022SUMMER_PAPARAZZI\u0022))\n\t\t\t{\n\t\t\t\tVector3 position = GetOwnerPlayer().eyes.position;\n\t\t\t\tVector3 vector = GetOwnerPlayer().eyes.HeadForward();\n\t\t\t\tList\u003CBasePlayer\u003E obj = Facepunch.Pool.Get\u003CList\u003CBasePlayer\u003E\u003E();\n\t\t\t\tVis.Entities(position \u002B vector * 5f, 5f, obj, 131072);\n\t\t\t\tforeach (BasePlayer item3 in obj)\n\t\t\t\t{\n\t\t\t\t\tif (item3.isServer \u0026\u0026 item3 != GetOwnerPlayer() \u0026\u0026 item3.IsVisible(GetOwnerPlayer().eyes.position))\n\t\t\t\t\t{\n\t\t\t\t\t\thasSentAchievement = true;\n\t\t\t\t\t\tGetOwnerPlayer().GiveAchievement(\u0022SUMMER_PAPARAZZI\u0022);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\n\t\t\t}\n\t\t\titem.LoseCondition(1f);\n\t\t\tInterface.CallHook(\u0022OnPhotoCaptured\u0022, photoEntity, item, player, array);\n\t\t}\n\t}\n",
    "ClassName": "InstantCameraTool",
    "HookLineInvoke": 43
  },
  {
    "HookSignature": "OnItemUnlock(Item item)",
    "MethodSignature": "LockUnlock(bool bNewState)",
    "MethodSourseCode": "\n\tpublic void LockUnlock(bool bNewState)\n\t{\n\t\tif (HasFlag(Flag.IsLocked) != bNewState \u0026\u0026 (!bNewState || Interface.CallHook(\u0022OnItemLock\u0022, this) == null) \u0026\u0026 (bNewState || Interface.CallHook(\u0022OnItemUnlock\u0022, this) == null))\n\t\t{\n\t\t\tSetFlag(Flag.IsLocked, bNewState);\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcTargetSense(BaseEntity owner, BaseEntity ent, AIBrainSenses brainSenses)",
    "MethodSignature": "SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)",
    "MethodSourseCode": "\n\tpublic void SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcTargetSense\u0022, owner, ent, brainSenses) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIAISenses iAISenses = owner as IAISenses;\n\t\tBasePlayer basePlayer = ent as BasePlayer;\n\t\tif (basePlayer != null \u0026\u0026 PlayerIgnoreList.Contains(basePlayer))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = false;\n\t\tif (iAISenses != null \u0026\u0026 iAISenses.IsThreat(ent))\n\t\t{\n\t\t\tflag = true;\n\t\t\tif (brainSenses != null)\n\t\t\t{\n\t\t\t\tbrainSenses.LastThreatTimestamp = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i \u003C All.Count; i\u002B\u002B)\n\t\t{\n\t\t\tif (All[i].Entity == ent)\n\t\t\t{\n\t\t\t\tSeenInfo value = All[i];\n\t\t\t\tvalue.Position = ent.transform.position;\n\t\t\t\tvalue.Timestamp = Mathf.Max(UnityEngine.Time.realtimeSinceStartup, value.Timestamp);\n\t\t\t\tAll[i] = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (basePlayer != null)\n\t\t{\n\t\t\tif (AI.ignoreplayers \u0026\u0026 !basePlayer.IsNpc)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tPlayers.Add(ent);\n\t\t}\n\t\tif (iAISenses != null)\n\t\t{\n\t\t\tif (iAISenses.IsTarget(ent))\n\t\t\t{\n\t\t\t\tTargets.Add(ent);\n\t\t\t}\n\t\t\tif (iAISenses.IsFriendly(ent))\n\t\t\t{\n\t\t\t\tFriendlies.Add(ent);\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tThreats.Add(ent);\n\t\t\t}\n\t\t}\n\t\tAll.Add(new SeenInfo\n\t\t{\n\t\t\tEntity = ent,\n\t\t\tPosition = ent.transform.position,\n\t\t\tTimestamp = UnityEngine.Time.realtimeSinceStartup\n\t\t});\n\t}\n",
    "ClassName": "SimpleAIMemory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnButtonPress(PressButton pressButton, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_Press(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Press(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnButtonPress\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tPress();\n\t\t}\n\t}\n",
    "ClassName": "PressButton",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnNpcConversationStart(NPCTalking nPCTalking, BasePlayer ply, ConversationData conversationFor)",
    "MethodSignature": "Server_BeginTalking(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic void Server_BeginTalking(BasePlayer ply)\n\t{\n\t\tif (!CanTalkTo(ply))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tCleanupConversingPlayers();\n\t\tOnConversationStarted(ply);\n\t\tConversationData conversationFor = GetConversationFor(ply);\n\t\tif (conversationFor != null)\n\t\t{\n\t\t\tif (conversingPlayers.Contains(ply))\n\t\t\t{\n\t\t\t\tOnConversationEnded(ply);\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnNpcConversationStart\u0022, this, ply, conversationFor) == null)\n\t\t\t{\n\t\t\t\tconversingPlayers.Add(ply);\n\t\t\t\tUpdateFlags();\n\t\t\t\tClientRPC(RpcTarget.Player(\u0022Client_StartConversation\u0022, ply), GetConversationIndex(conversationFor.shortname), GetConversationStartSpeech(ply));\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnGrowableGather(GrowableEntity growableEntity, BasePlayer player, bool eat)",
    "MethodSignature": "PickFruit(BasePlayer player, bool eat)",
    "MethodSourseCode": "\n\tpublic void PickFruit(BasePlayer player, bool eat = false)\n\t{\n\t\tif (!CanPick() || Interface.CallHook(\u0022OnGrowableGather\u0022, this, player, eat) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tharvests\u002B\u002B;\n\t\tGiveFruit(player, CurrentPickAmount, eat);\n\t\tRandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find\u003CRandomItemDispenser\u003E(prefabID);\n\t\tif (randomItemDispenser != null)\n\t\t{\n\t\t\trandomItemDispenser.DistributeItems(player, base.transform.position);\n\t\t}\n\t\tResetSeason();\n\t\tif (Properties.pickEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t}\n\t\tif (harvests \u003E= Properties.maxHarvests)\n\t\t{\n\t\t\tif (Properties.disappearAfterHarvest)\n\t\t\t{\n\t\t\t\tTellPlanter();\n\t\t\t\tDie();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tChangeState(PlantProperties.State.Dying, resetAge: true);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tChangeState(PlantProperties.State.Mature, resetAge: true);\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanReceiveCall(PhoneController phoneController)",
    "MethodSignature": "CanReceiveCall()",
    "MethodSourseCode": "\n\tprivate bool CanReceiveCall()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanReceiveCall\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (RequirePower \u0026\u0026 !IsPowered())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (RequireParent \u0026\u0026 !base.baseEntity.HasParent())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBookmarkControlStarted(ComputerStation computerStation, BasePlayer player, string text, IRemoteControllable remoteControllable)",
    "MethodSignature": "BeginControllingBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void BeginControllingBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);\n\t\tif (remoteControllable == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity ent = remoteControllable.GetEnt();\n\t\tif (ent == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022RC identifier \u0022 \u002B text \u002B \u0022 was found but has a null or destroyed entity, this should never happen\u0022);\n\t\t}\n\t\telse if (remoteControllable.CanControl(player.userID) \u0026\u0026 !(Vector3.Distance(base.transform.position, ent.transform.position) \u003E= remoteControllable.MaxRange) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkControl\u0022, this, player, text, remoteControllable) == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tIRemoteControllable component = baseEntity.GetComponent\u003CIRemoteControllable\u003E();\n\t\t\t\tcomponent?.StopControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t\t\tInterface.CallHook(\u0022OnBookmarkControlEnded\u0022, this, player, component);\n\t\t\t}\n\t\t\tplayer.net.SwitchSecondaryGroup(ent.net.group);\n\t\t\tplayer.SetRcEntityPosition(ent.transform.position);\n\t\t\tcurrentlyControllingEnt.uid = ent.net.ID;\n\t\t\tcurrentPlayerID = player.userID;\n\t\t\tbool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t\tSetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tSendControlBookmarks(player);\n\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 remoteControllable.GetEnt() is CCTV_RC)\n\t\t\t{\n\t\t\t\tInvokeRepeating(CheckCCTVAchievement, 1f, 3f);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnBookmarkControlStarted\u0022, this, player, text, remoteControllable);\n\t\t\tInvokeRepeating(ControlCheck, 0f, 0f);\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 45
  },
  {
    "HookSignature": "IOnServerShutdown()",
    "MethodSignature": "Shutdown()",
    "MethodSourseCode": "\n\tinternal void Shutdown()\n\t{\n\t\tInterface.CallHook(\u0022IOnServerShutdown\u0022);\n\t\tBasePlayer[] array = BasePlayer.activePlayerList.ToArray();\n\t\tfor (int i = 0; i \u003C array.Length; i\u002B\u002B)\n\t\t{\n\t\t\tarray[i].Kick(\u0022Server Shutting Down\u0022);\n\t\t}\n\t\tConsoleSystem.Run(ConsoleSystem.Option.Server, \u0022server.save\u0022);\n\t\tConsoleSystem.Run(ConsoleSystem.Option.Server, \u0022server.writecfg\u0022);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnPlayerBanned(Network.Connection connection, AuthResponse Status)",
    "MethodSignature": "OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)",
    "MethodSourseCode": "\n\tinternal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)\n\t{\n\t\tif (Auth_Steam.ValidateConnecting(SteamId, OwnerId, Status))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tNetwork.Connection connection = Network.Net.sv.connections.FirstOrDefault((Network.Connection x) =\u003E x.userid == SteamId);\n\t\tif (connection == null)\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning($\u0022Steam gave us a {Status} ticket response for unconnected id {SteamId}\u0022);\n\t\t\treturn;\n\t\t}\n\t\tswitch (Status)\n\t\t{\n\t\tcase AuthResponse.OK:\n\t\t\tUnityEngine.Debug.LogWarning($\u0022Steam gave us a \u0027ok\u0027 ticket response for already connected id {SteamId}\u0022);\n\t\t\treturn;\n\t\tcase AuthResponse.TimedOut:\n\t\t\treturn;\n\t\tcase AuthResponse.VACBanned:\n\t\tcase AuthResponse.PublisherBanned:\n\t\t\tif (!bannedPlayerNotices.Contains(SteamId))\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022IOnPlayerBanned\u0022, connection, Status);\n\t\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 2, 0, \u0022\u003Ccolor=#fff\u003ESERVER\u003C/color\u003E Kicking \u0022 \u002B connection.username.EscapeRichText() \u002B \u0022 (banned by anticheat)\u0022);\n\t\t\t\tbannedPlayerNotices.Add(SteamId);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tUnityEngine.Debug.Log($\u0022Kicking {connection.ipaddress}/{connection.userid}/{connection.username} (Steam Status \\\u0022{Status.ToString()}\\\u0022)\u0022);\n\t\tconnection.authStatusSteam = Status.ToString();\n\t\tNetwork.Net.sv.Kick(connection, \u0022Steam: \u0022 \u002B Status);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnTeamInvite(BasePlayer basePlayer, BasePlayer basePlayer2)",
    "MethodSignature": "sendinvite(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void sendinvite(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tPlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);\n\t\tif (playerTeam == null || playerTeam.GetLeader() == null || playerTeam.GetLeader() != basePlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tulong uLong = arg.GetULong(0, 0uL);\n\t\tif (uLong == 0L)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer2 = BaseNetworkable.serverEntities.Find(new NetworkableId(uLong)) as BasePlayer;\n\t\tif ((bool)basePlayer2 \u0026\u0026 basePlayer2 != basePlayer \u0026\u0026 !basePlayer2.IsNpc \u0026\u0026 basePlayer2.currentTeam == 0L)\n\t\t{\n\t\t\tfloat num = 7f;\n\t\t\tif (!(Vector3.Distance(basePlayer2.transform.position, basePlayer.transform.position) \u003E num) \u0026\u0026 Interface.CallHook(\u0022OnTeamInvite\u0022, basePlayer, basePlayer2) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.SendInvite(basePlayer2);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, ContainerIOEntity containerIOEntity)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t\tSetFlag(Flags.Open, b: false);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "ContainerIOEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUseMailbox(BasePlayer player, Mailbox mailbox)",
    "MethodSignature": "PlayerIsOwner(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool PlayerIsOwner(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseMailbox\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn player.CanBuild();\n\t}\n",
    "ClassName": "Mailbox",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHotAirBalloonToggled(HotAirBalloon hotAirBalloon, BasePlayer msgPlayer)",
    "MethodSignature": "EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHotAirBalloonToggle\u0022, this, msg.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 (!OnlyOwnerAccessible() || !(player != creatorEntity)))\n\t\t{\n\t\t\tbool b = msg.read.Bit();\n\t\t\tSetFlag(Flags.On, b);\n\t\t\tif (IsOn())\n\t\t\t{\n\t\t\t\tInvoke(ScheduleOff, 60f);\n\t\t\t\tInterface.CallHook(\u0022OnHotAirBalloonToggled\u0022, this, msg.player);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCancelInvoke(ScheduleOff);\n\t\t\t\tInterface.CallHook(\u0022OnHotAirBalloonToggled\u0022, this, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "HotAirBalloon",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnDroppedItemCombined(DroppedItem droppedItem)",
    "MethodSignature": "OnDroppedOn(DroppedItem di)",
    "MethodSourseCode": "\n\tpublic void OnDroppedOn(DroppedItem di)\n\t{\n\t\tif (item == null || di.item == null || Interface.CallHook(\u0022CanCombineDroppedItem\u0022, this, di) != null || di.item.info != item.info || (di.item.IsBlueprint() \u0026\u0026 di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition \u0026\u0026 di.item.condition != di.item.maxCondition) || (item.hasCondition \u0026\u0026 item.condition != item.maxCondition))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (di.item.info != null)\n\t\t{\n\t\t\tif (di.item.info.amountType == ItemDefinition.AmountType.Genetics)\n\t\t\t{\n\t\t\t\tint num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));\n\t\t\t\tint num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));\n\t\t\t\tif (num != num2)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((di.item.info.GetComponent\u003CItemModSign\u003E() != null \u0026\u0026 ItemModAssociatedEntity\u003CSignContent\u003E.GetAssociatedEntity(di.item) != null) || (item.info != null \u0026\u0026 item.info.GetComponent\u003CItemModSign\u003E() != null \u0026\u0026 ItemModAssociatedEntity\u003CSignContent\u003E.GetAssociatedEntity(item) != null))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (Item.BlockStackFoodItem(item, di.item))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num3 = di.item.amount \u002B item.amount;\n\t\tif (num3 \u003C= item.MaxStackable() \u0026\u0026 num3 != 0)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnDroppedItemCombined\u0022, this);\n\t\t\tif (di.DropReason == DropReasonEnum.Player)\n\t\t\t{\n\t\t\t\tDropReason = DropReasonEnum.Player;\n\t\t\t}\n\t\t\tdi.item.MigrateItemOwnership(item, di.item.amount);\n\t\t\tdi.DestroyItem();\n\t\t\tdi.Kill();\n\t\t\tint worldModelIndex = item.info.GetWorldModelIndex(item.amount);\n\t\t\titem.amount = num3;\n\t\t\titem.MarkDirty();\n\t\t\tif (GetDespawnDuration() \u003C float.PositiveInfinity)\n\t\t\t{\n\t\t\t\tInvoke(IdleDestroy, GetDespawnDuration());\n\t\t\t}\n\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/notice/stack.world.fx.prefab\u0022, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\tint worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);\n\t\t\tif (worldModelIndex != worldModelIndex2)\n\t\t\t{\n\t\t\t\titem.Drop(base.transform.position, Vector3.zero, base.transform.rotation);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DroppedItem",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnWaterPurified(WaterPurifier waterPurifier, float timeCooked)",
    "MethodSignature": "ConvertWater(float timeCooked)",
    "MethodSourseCode": "\n\tprotected void ConvertWater(float timeCooked)\n\t{\n\t\tItem slot = waterStorage.inventory.GetSlot(0);\n\t\tif ((stopWhenOutputFull \u0026\u0026 slot != null \u0026\u0026 slot.amount \u003E= slot.MaxStackable()) || Interface.CallHook(\u0022OnWaterPurify\u0022, this, timeCooked) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = timeCooked * ((float)waterToProcessPerMinute / 60f);\n\t\tif (slot != null)\n\t\t{\n\t\t\tfloat num2 = Mathf.Max(slot.MaxStackable() - slot.amount, 0);\n\t\t\tnum = Mathf.Min(num, num2 * (float)freshWaterRatio);\n\t\t}\n\t\tdirtyWaterProcssed \u002B= num;\n\t\tif (dirtyWaterProcssed \u003E= 1f)\n\t\t{\n\t\t\tItem slot2 = base.inventory.GetSlot(0);\n\t\t\tint num3 = Mathf.Min(Mathf.FloorToInt(dirtyWaterProcssed), slot2.amount);\n\t\t\tnum = num3;\n\t\t\tslot2.UseItem(num3);\n\t\t\tdirtyWaterProcssed -= num3;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tpendingFreshWater \u002B= num / (float)freshWaterRatio;\n\t\tif (!(pendingFreshWater \u003E= 1f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num4 = Mathf.FloorToInt(pendingFreshWater);\n\t\tpendingFreshWater -= num4;\n\t\tItem slot3 = waterStorage.inventory.GetSlot(0);\n\t\tif (slot3 != null \u0026\u0026 slot3.info != freshWater)\n\t\t{\n\t\t\tslot3.RemoveFromContainer();\n\t\t\tslot3.Remove();\n\t\t}\n\t\tif (slot3 == null)\n\t\t{\n\t\t\tItem item = ItemManager.Create(freshWater, num4, 0uL);\n\t\t\tif (!item.MoveToContainer(waterStorage.inventory))\n\t\t\t{\n\t\t\t\titem.Remove();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tslot3.amount \u002B= num4;\n\t\t\tslot3.amount = Mathf.Clamp(slot3.amount, 0, waterStorage.maxStackSize);\n\t\t\twaterStorage.inventory.MarkDirty();\n\t\t}\n\t\tInterface.CallHook(\u0022OnWaterPurified\u0022, this, timeCooked);\n\t\twaterStorage.SendNetworkUpdate();\n\t}\n",
    "ClassName": "WaterPurifier",
    "HookLineInvoke": 51
  },
  {
    "HookSignature": "OnFishCaught(ItemDefinition currentFishTarget, BaseFishingRod baseFishingRod, BasePlayer ownerPlayer)",
    "MethodSignature": "CatchProcessBudgeted()",
    "MethodSourseCode": "\n\tprivate void CatchProcessBudgeted()\n\t{\n\t\tinQueue = false;\n\t\tFishingBobber fishingBobber = currentBobber.Get(serverside: true);\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)\n\t\t{\n\t\t\tServer_Cancel(FailReason.UserRequested);\n\t\t\treturn;\n\t\t}\n\t\tVector3 position = ownerPlayer.transform.position;\n\t\tfloat num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));\n\t\tfloat num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));\n\t\tif (num \u003E ((num2 \u003E 1.2f) ? 60f : 180f))\n\t\t{\n\t\t\tServer_Cancel(FailReason.BadAngle);\n\t\t\treturn;\n\t\t}\n\t\tif (num2 \u003E 1.2f \u0026\u0026 (float)lastSightCheck \u003E 0.4f)\n\t\t{\n\t\t\tif (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))\n\t\t\t{\n\t\t\t\tServer_Cancel(FailReason.Obstructed);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastSightCheck = 0f;\n\t\t}\n\t\tif (Vector3.Distance(position, fishingBobber.transform.position) \u003E MaxCastDistance * 2f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TooFarAway);\n\t\t\treturn;\n\t\t}\n\t\tif (Vector3.Distance(playerStartPosition, position) \u003E 1f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.PlayerMoved);\n\t\t\treturn;\n\t\t}\n\t\tif (CurrentState == CatchState.Waiting)\n\t\t{\n\t\t\tif ((float)catchTime \u003C 0f)\n\t\t\t{\n\t\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_HookedSomething\u0022));\n\t\t\t\tCurrentState = CatchState.Catching;\n\t\t\t\tfishingBobber.SetFlag(Flags.Reserved1, b: true);\n\t\t\t\tnextFishStateChange = 0f;\n\t\t\t\tfishCatchDuration = 0f;\n\t\t\t\tstrainTimer = 0f;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tFishState fishState = currentFishState;\n\t\tif ((float)nextFishStateChange \u003C 0f)\n\t\t{\n\t\t\tfloat num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);\n\t\t\tif (currentFishState != 0)\n\t\t\t{\n\t\t\t\tcurrentFishState = (FishState)0;\n\t\t\t\tnextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 \u002B 1f);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003C 50)\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState = FishState.PullingLeft;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState = FishState.PullingRight;\n\t\t\t\t}\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003E 60 \u0026\u0026 Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) \u003C MaxCastDistance - 2f)\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState |= FishState.PullingBack;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((float)fishCatchDuration \u003E 120f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TimeOut);\n\t\t\treturn;\n\t\t}\n\t\tbool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);\n\t\tbool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);\n\t\tbool flag3 = HasReelInInput(ownerPlayer.serverInput);\n\t\tif (flag2 \u0026\u0026 flag)\n\t\t{\n\t\t\tflag2 = (flag = false);\n\t\t}\n\t\tUpdateFlags(flag2, flag, flag3);\n\t\tif (CurrentState == CatchState.Waiting)\n\t\t{\n\t\t\tflag = (flag2 = (flag3 = false));\n\t\t}\n\t\tif (flag2 \u0026\u0026 !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\n\t\t{\n\t\t\tflag2 = false;\n\t\t}\n\t\tif (flag \u0026\u0026 !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\n\t\t{\n\t\t\tflag = false;\n\t\t}\n\t\tfloat value = ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f);\n\t\tfishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier, value);\n\t\tbool flag4 = false;\n\t\tfloat num4 = 0f;\n\t\tif (flag3 || flag2 || flag)\n\t\t{\n\t\t\tflag4 = true;\n\t\t\tnum4 = 0.5f;\n\t\t}\n\t\tif (currentFishState != 0 \u0026\u0026 flag4)\n\t\t{\n\t\t\tif (currentFishState.Contains(FishState.PullingBack) \u0026\u0026 flag3)\n\t\t\t{\n\t\t\t\tnum4 = 1.5f;\n\t\t\t}\n\t\t\telse if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) \u0026\u0026 flag3)\n\t\t\t{\n\t\t\t\tnum4 = 1.2f;\n\t\t\t}\n\t\t\telse if (currentFishState.Contains(FishState.PullingLeft) \u0026\u0026 flag)\n\t\t\t{\n\t\t\t\tnum4 = 0.8f;\n\t\t\t}\n\t\t\telse if (currentFishState.Contains(FishState.PullingRight) \u0026\u0026 flag2)\n\t\t\t{\n\t\t\t\tnum4 = 0.8f;\n\t\t\t}\n\t\t}\n\t\tif (flag3 \u0026\u0026 currentFishState != 0)\n\t\t{\n\t\t\tnum4 \u002B= 1f;\n\t\t}\n\t\tnum4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;\n\t\tnum4 -= ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f) - 1f;\n\t\tif (flag4)\n\t\t{\n\t\t\tstrainTimer \u002B= UnityEngine.Time.deltaTime * num4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);\n\t\t}\n\t\tfloat num5 = strainTimer / 6f;\n\t\tSetFlag(Flags.Reserved1, flag4 \u0026\u0026 num5 \u003E 0.25f);\n\t\tif ((float)lastStrainUpdate \u003E 0.4f || fishState != currentFishState)\n\t\t{\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_UpdateFishState\u0022), (int)currentFishState, num5);\n\t\t\tlastStrainUpdate = 0f;\n\t\t}\n\t\tif (strainTimer \u003E 7f || ForceFail)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TensionBreak);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!(num2 \u003C= FishCatchDistance) \u0026\u0026 !ForceSuccess)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tCurrentState = CatchState.Caught;\n\t\t\tif (currentFishTarget != null)\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(currentFishTarget, 1, 0uL);\n\t\t\t\titem.SetItemOwnership(ownerPlayer, ItemOwnershipPhrases.Fishing);\n\t\t\t\tobject obj = Interface.CallHook(\u0022CanCatchFish\u0022, ownerPlayer, this, item);\n\t\t\t\tif (obj is bool \u0026\u0026 !(bool)obj)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobject obj2 = Interface.CallHook(\u0022OnFishCatch\u0022, item, this, ownerPlayer);\n\t\t\t\tif (obj2 is Item \u0026\u0026 obj2 as Item != item)\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t\titem = (Item)obj2;\n\t\t\t\t}\n\t\t\t\townerPlayer.GiveItem(item, GiveItemReason.Crafted);\n\t\t\t\tif (currentFishTarget.shortname == \u0022skull.human\u0022)\n\t\t\t\t{\n\t\t\t\t\titem.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));\n\t\t\t\t}\n\t\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 !string.IsNullOrEmpty(fishableModifier.SteamStatName))\n\t\t\t\t{\n\t\t\t\t\townerPlayer.stats.Add(fishableModifier.SteamStatName, 1);\n\t\t\t\t\townerPlayer.stats.Save(forceSteamSave: true);\n\t\t\t\t\tFishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);\n\t\t\t\t}\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnCaughtFish(ownerPlayer, item);\n\t\t\t}\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\u0022Client_OnCaughtFish\u0022), currentFishTarget.itemid);\n\t\t\townerPlayer.SignalBroadcast(Signal.Alt_Attack);\n\t\t\tInvoke(ResetLine, 6f);\n\t\t\tfishingBobber.Kill();\n\t\t\tcurrentBobber.Set(null);\n\t\t\tCancelInvoke(CatchProcess);\n\t\t\tInterface.CallHook(\u0022OnFishCaught\u0022, currentFishTarget, this, ownerPlayer);\n\t\t}\n\t}\n",
    "ClassName": "BaseFishingRod",
    "HookLineInvoke": 196
  },
  {
    "HookSignature": "CanCombineDroppedItem(DroppedItem droppedItem, DroppedItem di)",
    "MethodSignature": "OnDroppedOn(DroppedItem di)",
    "MethodSourseCode": "\n\tpublic void OnDroppedOn(DroppedItem di)\n\t{\n\t\tif (item == null || di.item == null || Interface.CallHook(\u0022CanCombineDroppedItem\u0022, this, di) != null || di.item.info != item.info || (di.item.IsBlueprint() \u0026\u0026 di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition \u0026\u0026 di.item.condition != di.item.maxCondition) || (item.hasCondition \u0026\u0026 item.condition != item.maxCondition))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (di.item.info != null)\n\t\t{\n\t\t\tif (di.item.info.amountType == ItemDefinition.AmountType.Genetics)\n\t\t\t{\n\t\t\t\tint num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));\n\t\t\t\tint num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));\n\t\t\t\tif (num != num2)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((di.item.info.GetComponent\u003CItemModSign\u003E() != null \u0026\u0026 ItemModAssociatedEntity\u003CSignContent\u003E.GetAssociatedEntity(di.item) != null) || (item.info != null \u0026\u0026 item.info.GetComponent\u003CItemModSign\u003E() != null \u0026\u0026 ItemModAssociatedEntity\u003CSignContent\u003E.GetAssociatedEntity(item) != null))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (Item.BlockStackFoodItem(item, di.item))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num3 = di.item.amount \u002B item.amount;\n\t\tif (num3 \u003C= item.MaxStackable() \u0026\u0026 num3 != 0)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnDroppedItemCombined\u0022, this);\n\t\t\tif (di.DropReason == DropReasonEnum.Player)\n\t\t\t{\n\t\t\t\tDropReason = DropReasonEnum.Player;\n\t\t\t}\n\t\t\tdi.item.MigrateItemOwnership(item, di.item.amount);\n\t\t\tdi.DestroyItem();\n\t\t\tdi.Kill();\n\t\t\tint worldModelIndex = item.info.GetWorldModelIndex(item.amount);\n\t\t\titem.amount = num3;\n\t\t\titem.MarkDirty();\n\t\t\tif (GetDespawnDuration() \u003C float.PositiveInfinity)\n\t\t\t{\n\t\t\t\tInvoke(IdleDestroy, GetDespawnDuration());\n\t\t\t}\n\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/notice/stack.world.fx.prefab\u0022, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\tint worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);\n\t\t\tif (worldModelIndex != worldModelIndex2)\n\t\t\t{\n\t\t\t\titem.Drop(base.transform.position, Vector3.zero, base.transform.rotation);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DroppedItem",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBookmarkControlEnded(ComputerStation computerStation, BasePlayer player, IRemoteControllable component)",
    "MethodSignature": "BeginControllingBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void BeginControllingBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);\n\t\tif (remoteControllable == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity ent = remoteControllable.GetEnt();\n\t\tif (ent == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022RC identifier \u0022 \u002B text \u002B \u0022 was found but has a null or destroyed entity, this should never happen\u0022);\n\t\t}\n\t\telse if (remoteControllable.CanControl(player.userID) \u0026\u0026 !(Vector3.Distance(base.transform.position, ent.transform.position) \u003E= remoteControllable.MaxRange) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkControl\u0022, this, player, text, remoteControllable) == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tIRemoteControllable component = baseEntity.GetComponent\u003CIRemoteControllable\u003E();\n\t\t\t\tcomponent?.StopControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t\t\tInterface.CallHook(\u0022OnBookmarkControlEnded\u0022, this, player, component);\n\t\t\t}\n\t\t\tplayer.net.SwitchSecondaryGroup(ent.net.group);\n\t\t\tplayer.SetRcEntityPosition(ent.transform.position);\n\t\t\tcurrentlyControllingEnt.uid = ent.net.ID;\n\t\t\tcurrentPlayerID = player.userID;\n\t\t\tbool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t\tSetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tSendControlBookmarks(player);\n\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 remoteControllable.GetEnt() is CCTV_RC)\n\t\t\t{\n\t\t\t\tInvokeRepeating(CheckCCTVAchievement, 1f, 3f);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnBookmarkControlStarted\u0022, this, player, text, remoteControllable);\n\t\t\tInvokeRepeating(ControlCheck, 0f, 0f);\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnFireBallDamage(FireBall fireBall, BaseCombatEntity item, HitInfo hitInfo)",
    "MethodSignature": "DoRadialDamage()",
    "MethodSourseCode": "\n\tpublic void DoRadialDamage()\n\t{\n\t\tList\u003CBaseCombatEntity\u003E obj = Pool.Get\u003CList\u003CBaseCombatEntity\u003E\u003E();\n\t\tVector3 position = base.transform.position \u002B new Vector3(0f, radius * 0.75f, 0f);\n\t\tVis.Entities(position, radius, obj, AttackLayers, QueryTriggerInteraction.Ignore);\n\t\tHitInfo hitInfo = new HitInfo();\n\t\thitInfo.DoHitEffects = true;\n\t\thitInfo.DidHit = true;\n\t\thitInfo.HitBone = 0u;\n\t\thitInfo.Initiator = ((creatorEntity == null) ? GameObjectEx.ToBaseEntity(base.gameObject) : creatorEntity);\n\t\thitInfo.PointStart = base.transform.position;\n\t\tforeach (BaseCombatEntity item in obj)\n\t\t{\n\t\t\tif (!(item == null) \u0026\u0026 item.isServer \u0026\u0026 item.IsAlive() \u0026\u0026 (!ignoreNPC || !item.IsNpc) \u0026\u0026 item.IsVisible(position))\n\t\t\t{\n\t\t\t\tif (item is BasePlayer)\n\t\t\t\t{\n\t\t\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/impacts/additive/fire.prefab\u0022, item, 0u, new Vector3(0f, 1f, 0f), Vector3.up);\n\t\t\t\t}\n\t\t\t\thitInfo.PointEnd = item.transform.position;\n\t\t\t\thitInfo.HitPositionWorld = item.transform.position;\n\t\t\t\thitInfo.damageTypes.Set(DamageType.Heat, damagePerSecond * tickRate);\n\t\t\t\tInterface.CallHook(\u0022OnFireBallDamage\u0022, this, item, hitInfo);\n\t\t\t\titem.OnAttacked(hitInfo);\n\t\t\t}\n\t\t}\n\t\tPool.FreeUnmanaged(ref obj);\n\t}\n",
    "ClassName": "FireBall",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnInterferenceUpdate(AutoTurret autoTurret)",
    "MethodSignature": "UpdateInterference()",
    "MethodSourseCode": "\n\tpublic void UpdateInterference()\n\t{\n\t\tif (!IsOn() || Interface.CallHook(\u0022OnInterferenceUpdate\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = 0f;\n\t\tforeach (AutoTurret nearbyTurret in nearbyTurrets)\n\t\t{\n\t\t\tif (!nearbyTurret.isClient \u0026\u0026 nearbyTurret.IsValid() \u0026\u0026 nearbyTurret.gameObject.activeSelf \u0026\u0026 !nearbyTurret.EqualNetID(net.ID) \u0026\u0026 nearbyTurret.IsOn() \u0026\u0026 !nearbyTurret.HasInterference())\n\t\t\t{\n\t\t\t\tnum \u002B= 1f;\n\t\t\t}\n\t\t}\n\t\tSetFlag(Flags.OnFire, num \u003E= (float)Sentry.maxinterference);\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnGroupTitleSet(string groupName, string groupTitle)",
    "MethodSignature": "SetGroupTitle(string groupName, string groupTitle)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022SetGroupTitle\u0022)]\n\tpublic bool SetGroupTitle(string groupName, string groupTitle)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!groupsData.TryGetValue(groupName, out var value))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (value.Title == groupTitle)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tvalue.Title = groupTitle;\n\t\tInterface.CallHook(\u0022OnGroupTitleSet\u0022, groupName, groupTitle);\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnUserPermissionRevoked(string playerId, string permission)",
    "MethodSignature": "RevokeUserPermission(string playerId, string permission)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RevokeUserPermission\u0022)]\n\tpublic void RevokeUserPermission(string playerId, string permission)\n\t{\n\t\tif (string.IsNullOrEmpty(permission))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserData userData = GetUserData(playerId);\n\t\tif (permission.EndsWith(\u0022*\u0022))\n\t\t{\n\t\t\tif (permission.Equals(\u0022*\u0022))\n\t\t\t{\n\t\t\t\tif (userData.Perms.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tuserData.Perms.Clear();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tuserData.Perms.RemoveWhere((string p) =\u003E p.StartsWith(permission.TrimEnd(new char[1] { \u0027*\u0027 }), StringComparison.OrdinalIgnoreCase));\n\t\t\t_ = 0;\n\t\t}\n\t\telse if (userData.Perms.Remove(permission))\n\t\t{\n\t\t\tInterface.Call(\u0022OnUserPermissionRevoked\u0022, playerId, permission);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnUserGroupRemoved(string playerId, string groupName)",
    "MethodSignature": "RemoveUserGroup(string playerId, string groupName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RemoveUserGroup\u0022)]\n\tpublic void RemoveUserGroup(string playerId, string groupName)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserData userData = GetUserData(playerId);\n\t\tif (groupName.Equals(\u0022*\u0022))\n\t\t{\n\t\t\tif (userData.Groups.Count \u003E 0)\n\t\t\t{\n\t\t\t\tuserData.Groups.Clear();\n\t\t\t}\n\t\t}\n\t\telse if (userData.Groups.Remove(groupName))\n\t\t{\n\t\t\tInterface.Call(\u0022OnUserGroupRemoved\u0022, playerId, groupName);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnGroupRankSet(string groupName, int groupRank)",
    "MethodSignature": "SetGroupRank(string groupName, int groupRank)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022SetGroupRank\u0022)]\n\tpublic bool SetGroupRank(string groupName, int groupRank)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!groupsData.TryGetValue(groupName, out var value))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (value.Rank == groupRank)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tvalue.Rank = groupRank;\n\t\tInterface.CallHook(\u0022OnGroupRankSet\u0022, groupName, groupRank);\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnGroupDeleted(string groupName)",
    "MethodSignature": "RemoveGroup(string groupName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RemoveGroup\u0022)]\n\tpublic bool RemoveGroup(string groupName)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tbool flag = groupsData.Remove(groupName);\n\t\tif (flag)\n\t\t{\n\t\t\tforeach (GroupData item in groupsData.Values.Where((GroupData g) =\u003E g.ParentGroup == groupName))\n\t\t\t{\n\t\t\t\titem.ParentGroup = string.Empty;\n\t\t\t}\n\t\t}\n\t\tif (usersData.Values.Aggregate(seed: false, (bool current, UserData userData) =\u003E current | userData.Groups.Remove(groupName)))\n\t\t{\n\t\t\tSaveUsers();\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnGroupDeleted\u0022, groupName);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnGroupParentSet(string groupName, string parentGroupName)",
    "MethodSignature": "SetGroupParent(string groupName, string parentGroupName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022SetGroupParent\u0022)]\n\tpublic bool SetGroupParent(string groupName, string parentGroupName)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!groupsData.TryGetValue(groupName, out var value))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (string.IsNullOrEmpty(parentGroupName))\n\t\t{\n\t\t\tvalue.ParentGroup = null;\n\t\t\treturn true;\n\t\t}\n\t\tif (!GroupExists(parentGroupName) || groupName.Equals(parentGroupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!string.IsNullOrEmpty(value.ParentGroup) \u0026\u0026 value.ParentGroup.Equals(parentGroupName))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (HasCircularParent(groupName, parentGroupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tvalue.ParentGroup = parentGroupName;\n\t\tInterface.CallHook(\u0022OnGroupParentSet\u0022, groupName, parentGroupName);\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnPermissionRegistered(string permission, Oxide.Core.Plugins.Plugin owner)",
    "MethodSignature": "RegisterPermission(string permission, Plugin owner)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RegisterPermission\u0022)]\n\tpublic void RegisterPermission(string permission, Plugin owner)\n\t{\n\t\tif (string.IsNullOrEmpty(permission))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (PermissionExists(permission))\n\t\t{\n\t\t\tInterface.Oxide.LogWarning(\u0022Duplicate permission registered \u0027{0}\u0027 (by plugin \u0027{1}\u0027)\u0022, permission, owner.Title);\n\t\t\treturn;\n\t\t}\n\t\tif (!registeredPermissions.TryGetValue(owner, out var value))\n\t\t{\n\t\t\tvalue = new HashSet\u003Cstring\u003E(StringComparer.OrdinalIgnoreCase);\n\t\t\tregisteredPermissions.Add(owner, value);\n\t\t\towner.OnRemovedFromManager.Add(owner_OnRemovedFromManager);\n\t\t}\n\t\tvalue.Add(permission);\n\t\tInterface.CallHook(\u0022OnPermissionRegistered\u0022, permission, owner);\n\t\tif (!permission.StartsWith(owner.Name \u002B \u0022.\u0022, StringComparison.OrdinalIgnoreCase) \u0026\u0026 !owner.IsCorePlugin)\n\t\t{\n\t\t\tInterface.Oxide.LogWarning(\u0022Missing plugin name prefix \u0027{0}\u0027 for permission \u0027{1}\u0027 (by plugin \u0027{2}\u0027)\u0022, owner.Name.ToLower(), permission, owner.Title);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnPluginLoaded(Oxide.Core.Plugins.Plugin plugin)",
    "MethodSignature": "PluginLoaded(Plugin plugin)",
    "MethodSourseCode": "\n\tpublic bool PluginLoaded(Plugin plugin)\n\t{\n\t\tplugin.OnError \u002B= plugin_OnError;\n\t\ttry\n\t\t{\n\t\t\tplugin.Loader?.PluginErrors.Remove(plugin.Name);\n\t\t\tRootPluginManager.AddPlugin(plugin);\n\t\t\tif (plugin.Loader != null \u0026\u0026 plugin.Loader.PluginErrors.ContainsKey(plugin.Name))\n\t\t\t{\n\t\t\t\tUnloadPlugin(plugin.Name);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tplugin.IsLoaded = true;\n\t\t\tCallHook(\u0022OnPluginLoaded\u0022, plugin);\n\t\t\tLogInfo(\u0022Loaded plugin {0} v{1} by {2}\u0022, plugin.Title, plugin.Version, plugin.Author);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tif (plugin.Loader != null)\n\t\t\t{\n\t\t\t\tplugin.Loader.PluginErrors[plugin.Name] = ex.Message;\n\t\t\t}\n\t\t\tLogException($\u0022Could not initialize plugin \u0027{plugin.Name} v{plugin.Version}\u0027\u0022, ex);\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "ClassName": "OxideMod",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnGroupCreated(string groupName, string groupTitle, int groupRank)",
    "MethodSignature": "CreateGroup(string groupName, string groupTitle, int groupRank)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022CreateGroup\u0022)]\n\tpublic bool CreateGroup(string groupName, string groupTitle, int groupRank)\n\t{\n\t\tif (GroupExists(groupName) || string.IsNullOrEmpty(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tGroupData value = new GroupData\n\t\t{\n\t\t\tTitle = groupTitle,\n\t\t\tRank = groupRank\n\t\t};\n\t\tgroupsData.Add(groupName, value);\n\t\tInterface.CallHook(\u0022OnGroupCreated\u0022, groupName, groupTitle, groupRank);\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnUserPermissionGranted(string playerId, string permission)",
    "MethodSignature": "GrantUserPermission(string playerId, string permission, Plugin owner)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022GrantUserPermission\u0022)]\n\tpublic void GrantUserPermission(string playerId, string permission, Plugin owner)\n\t{\n\t\tif (!PermissionExists(permission, owner))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserData userData = GetUserData(playerId);\n\t\tif (permission.EndsWith(\u0022*\u0022))\n\t\t{\n\t\t\tHashSet\u003Cstring\u003E value;\n\t\t\tif (owner == null)\n\t\t\t{\n\t\t\t\tvalue = new HashSet\u003Cstring\u003E(registeredPermissions.Values.SelectMany((HashSet\u003Cstring\u003E v) =\u003E v));\n\t\t\t}\n\t\t\telse if (!registeredPermissions.TryGetValue(owner, out value))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (permission.Equals(\u0022*\u0022))\n\t\t\t{\n\t\t\t\tvalue.Aggregate(seed: false, (bool c, string s) =\u003E c | userData.Perms.Add(s));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalue.Where((string p) =\u003E p.StartsWith(permission.TrimEnd(new char[1] { \u0027*\u0027 }), StringComparison.OrdinalIgnoreCase)).Aggregate(seed: false, (bool c, string s) =\u003E c | userData.Perms.Add(s));\n\t\t}\n\t\telse if (userData.Perms.Add(permission))\n\t\t{\n\t\t\tInterface.Call(\u0022OnUserPermissionGranted\u0022, playerId, permission);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 29
  },
  {
    "HookSignature": "OnRconCommand(System.Net.IPEndPoint connectionUserEndPoint, string text, string[] array2)",
    "MethodSignature": "OnMessage(MessageEventArgs e, WebSocketContext connection)",
    "MethodSourseCode": "\n\tprivate void OnMessage(MessageEventArgs e, WebSocketContext connection)\n\t{\n\t\tif (covalence == null)\n\t\t{\n\t\t\tInterface.Oxide.LogError(\u0022[Rcon] Failed to process command, Covalence is null\u0022);\n\t\t\treturn;\n\t\t}\n\t\tRemoteMessage message = RemoteMessage.GetMessage(e.Data);\n\t\tif (message == null)\n\t\t{\n\t\t\tInterface.Oxide.LogError(\u0022[Rcon] Failed to process command, RemoteMessage is null\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (string.IsNullOrEmpty(message.Message))\n\t\t{\n\t\t\tInterface.Oxide.LogError(\u0022[Rcon] Failed to process command, RemoteMessage.Text is not set\u0022);\n\t\t\treturn;\n\t\t}\n\t\tstring[] array = CommandLine.Split(message.Message);\n\t\tstring text = array[0].ToLower();\n\t\tstring[] array2 = array.Skip(1).ToArray();\n\t\tif (Interface.CallHook(\u0022OnRconCommand\u0022, connection.UserEndPoint, text, array2) == null)\n\t\t{\n\t\t\tIServer obj = covalence.Server;\n\t\t\tobject[] args = array2;\n\t\t\tobj.Command(text, args);\n\t\t}\n\t}\n",
    "ClassName": "RemoteConsole",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnGroupPermissionGranted(string groupName, string permission)",
    "MethodSignature": "GrantGroupPermission(string groupName, string permission, Plugin owner)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022GrantGroupPermission\u0022)]\n\tpublic void GrantGroupPermission(string groupName, string permission, Plugin owner)\n\t{\n\t\tif (!PermissionExists(permission, owner) || !GroupExists(groupName) || !groupsData.TryGetValue(groupName, out var groupData))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (permission.EndsWith(\u0022*\u0022))\n\t\t{\n\t\t\tHashSet\u003Cstring\u003E value;\n\t\t\tif (owner == null)\n\t\t\t{\n\t\t\t\tvalue = new HashSet\u003Cstring\u003E(registeredPermissions.Values.SelectMany((HashSet\u003Cstring\u003E v) =\u003E v));\n\t\t\t}\n\t\t\telse if (!registeredPermissions.TryGetValue(owner, out value))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (permission.Equals(\u0022*\u0022))\n\t\t\t{\n\t\t\t\tvalue.Aggregate(seed: false, (bool c, string s) =\u003E c | groupData.Perms.Add(s));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalue.Where((string p) =\u003E p.StartsWith(permission.TrimEnd(new char[1] { \u0027*\u0027 }), StringComparison.OrdinalIgnoreCase)).Aggregate(seed: false, (bool c, string s) =\u003E c | groupData.Perms.Add(s));\n\t\t}\n\t\telse if (groupData.Perms.Add(permission))\n\t\t{\n\t\t\tInterface.Call(\u0022OnGroupPermissionGranted\u0022, groupName, permission);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnUserNameUpdated(string playerId, string lastSeenNickname, string obj)",
    "MethodSignature": "UpdateNickname(string playerId, string playerName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022UpdateNickname\u0022)]\n\tpublic void UpdateNickname(string playerId, string playerName)\n\t{\n\t\tif (UserExists(playerId))\n\t\t{\n\t\t\tUserData userData = GetUserData(playerId);\n\t\t\tstring lastSeenNickname = userData.LastSeenNickname;\n\t\t\tstring obj = playerName.Sanitize();\n\t\t\tuserData.LastSeenNickname = playerName.Sanitize();\n\t\t\tInterface.CallHook(\u0022OnUserNameUpdated\u0022, playerId, lastSeenNickname, obj);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnGroupPermissionRevoked(string groupName, string permission)",
    "MethodSignature": "RevokeGroupPermission(string groupName, string permission)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RevokeGroupPermission\u0022)]\n\tpublic void RevokeGroupPermission(string groupName, string permission)\n\t{\n\t\tif (!GroupExists(groupName) || string.IsNullOrEmpty(permission) || !groupsData.TryGetValue(groupName, out var value))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (permission.EndsWith(\u0022*\u0022))\n\t\t{\n\t\t\tif (permission.Equals(\u0022*\u0022))\n\t\t\t{\n\t\t\t\tif (value.Perms.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tvalue.Perms.Clear();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalue.Perms.RemoveWhere((string p) =\u003E p.StartsWith(permission.TrimEnd(new char[1] { \u0027*\u0027 }), StringComparison.OrdinalIgnoreCase));\n\t\t\t_ = 0;\n\t\t}\n\t\telse if (value.Perms.Remove(permission))\n\t\t{\n\t\t\tInterface.Call(\u0022OnGroupPermissionRevoked\u0022, groupName, permission);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "Init()",
    "MethodSignature": "HandleAddedToManager(PluginManager manager)",
    "MethodSourseCode": "\n\tpublic override void HandleAddedToManager(PluginManager manager)\n\t{\n\t\tbase.HandleAddedToManager(manager);\n\t\tforeach (string key in Hooks.Keys)\n\t\t{\n\t\t\tSubscribe(key);\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tOnCallHook(\u0022Init\u0022, null);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tInterface.Oxide.LogException($\u0022Failed to initialize plugin \u0027{base.Name} v{base.Version}\u0027\u0022, ex);\n\t\t\tif (base.Loader != null)\n\t\t\t{\n\t\t\t\tbase.Loader.PluginErrors[base.Name] = ex.Message;\n\t\t\t}\n\t\t}\n\t\tType[] nestedTypes = GetType().GetNestedTypes(BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);\n\t\tforeach (Type type in nestedTypes)\n\t\t{\n\t\t\tif (type.GetCustomAttributes(typeof(AutoPatchAttribute), inherit: false).Length \u003C 1)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tList\u003CMethodInfo\u003E list = HarmonyInstance.CreateClassProcessor(type)?.Patch();\n\t\t\t\tif (list == null || list.Count == 0)\n\t\t\t\t{\n\t\t\t\t\tInterface.Oxide.LogWarning(\u0022[\u0022 \u002B base.Title \u002B \u0022] AutoPatch attribute found on \u0027\u0022 \u002B type.Name \u002B \u0022\u0027 but no HarmonyPatch methods found. Skipping.\u0022);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tforeach (MethodInfo item in list)\n\t\t\t\t{\n\t\t\t\t\tInterface.Oxide.LogInfo(\u0022[\u0022 \u002B base.Title \u002B \u0022] Automatically Harmony patched \u0027\u0022 \u002B (item?.Name ?? \u0022unknown\u0022) \u002B \u0022\u0027 method. (\u0022 \u002B type.Name \u002B \u0022)\u0022);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tInterface.Oxide.LogException(\u0022[\u0022 \u002B base.Title \u002B \u0022] Failed to automatically Harmony patch \u0027\u0022 \u002B type.Name \u002B \u0022\u0027\u0022, ex2);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CSPlugin",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "LoadDefaultMessages()",
    "MethodSignature": "LoadDefaultMessages()",
    "MethodSourseCode": "\n\tprotected virtual void LoadDefaultMessages()\n\t{\n\t\tCallHook(\u0022LoadDefaultMessages\u0022, null);\n\t}\n",
    "ClassName": "Plugin",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "LoadDefaultConfig()",
    "MethodSignature": "LoadDefaultConfig()",
    "MethodSourseCode": "\n\tprotected virtual void LoadDefaultConfig()\n\t{\n\t\tCallHook(\u0022LoadDefaultConfig\u0022, null);\n\t}\n",
    "ClassName": "Plugin",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPluginUnloaded(Oxide.Core.Plugins.Plugin plugin)",
    "MethodSignature": "UnloadPlugin(string name)",
    "MethodSourseCode": "\n\tpublic bool UnloadPlugin(string name)\n\t{\n\t\tPlugin plugin = RootPluginManager.GetPlugin(name);\n\t\tif (plugin == null || (plugin.IsCorePlugin \u0026\u0026 !IsShuttingDown))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\textensionManager.GetPluginLoaders().SingleOrDefault((PluginLoader l) =\u003E l.LoadedPlugins.ContainsKey(name))?.Unloading(plugin);\n\t\tRootPluginManager.RemovePlugin(plugin);\n\t\tif (plugin.IsLoaded)\n\t\t{\n\t\t\tCallHook(\u0022OnPluginUnloaded\u0022, plugin);\n\t\t}\n\t\tplugin.IsLoaded = false;\n\t\tLogInfo(\u0022Unloaded plugin {0} v{1} by {2}\u0022, plugin.Title, plugin.Version, plugin.Author);\n\t\treturn true;\n\t}\n",
    "ClassName": "OxideMod",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnUserGroupAdded(string playerId, string groupName)",
    "MethodSignature": "AddUserGroup(string playerId, string groupName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022AddUserGroup\u0022)]\n\tpublic void AddUserGroup(string playerId, string groupName)\n\t{\n\t\tif (GroupExists(groupName) \u0026\u0026 GetUserData(playerId).Groups.Add(groupName))\n\t\t{\n\t\t\tInterface.Call(\u0022OnUserGroupAdded\u0022, playerId, groupName);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnServerShutdown()",
    "MethodSignature": "OnApplicationQuit()",
    "MethodSourseCode": "\n\tprivate void OnApplicationQuit()\n\t{\n\t\tif (!oxideMod.IsShuttingDown)\n\t\t{\n\t\t\tInterface.Call(\u0022OnServerShutdown\u0022);\n\t\t\tInterface.Oxide.OnShutdown();\n\t\t}\n\t}\n",
    "ClassName": "UnityScript",
    "HookLineInvoke": 5
  }
]