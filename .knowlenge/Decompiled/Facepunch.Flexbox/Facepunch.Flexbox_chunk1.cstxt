using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		MonoScriptData result = default(MonoScriptData);
		result.FilePathsData = new byte[936]
		{
			0, 0, 0, 1, 0, 0, 0, 50, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 70, 108, 101, 120, 98, 111,
			120, 92, 70, 108, 101, 120, 65, 108, 105, 103,
			110, 83, 101, 108, 102, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 52, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 70, 108, 101, 120, 98, 111, 120, 92,
			70, 108, 101, 120, 65, 115, 112, 101, 99, 116,
			82, 97, 116, 105, 111, 46, 99, 115, 0, 0,
			0, 2, 0, 0, 0, 56, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 70, 108, 101, 120, 98, 111, 120, 92,
			70, 108, 101, 120, 67, 104, 105, 108, 100, 69,
			110, 117, 109, 101, 114, 97, 98, 108, 101, 46,
			99, 115, 0, 0, 0, 2, 0, 0, 0, 55,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 70, 108, 101, 120,
			98, 111, 120, 92, 70, 108, 101, 120, 67, 111,
			108, 117, 109, 110, 115, 69, 108, 101, 109, 101,
			110, 116, 46, 99, 115, 0, 0, 0, 2, 0,
			0, 0, 48, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 70,
			108, 101, 120, 98, 111, 120, 92, 70, 108, 101,
			120, 69, 108, 101, 109, 101, 110, 116, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 52, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 46, 70, 108, 101, 120, 98,
			111, 120, 92, 70, 108, 101, 120, 69, 108, 101,
			109, 101, 110, 116, 66, 97, 115, 101, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 57, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 46, 70, 108, 101, 120, 98,
			111, 120, 92, 70, 108, 101, 120, 71, 114, 97,
			112, 104, 105, 99, 84, 114, 97, 110, 115, 102,
			111, 114, 109, 46, 99, 115, 0, 0, 0, 1,
			0, 0, 0, 54, 92, 65, 115, 115, 101, 116,
			115, 92, 80, 108, 117, 103, 105, 110, 115, 92,
			70, 97, 99, 101, 112, 117, 110, 99, 104, 46,
			70, 108, 101, 120, 98, 111, 120, 92, 70, 108,
			101, 120, 76, 97, 121, 111, 117, 116, 77, 97,
			110, 97, 103, 101, 114, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 47, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 70, 108, 101, 120, 98, 111, 120, 92,
			70, 108, 101, 120, 76, 101, 110, 103, 116, 104,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			48, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 70, 97, 99,
			101, 112, 117, 110, 99, 104, 46, 70, 108, 101,
			120, 98, 111, 120, 92, 70, 108, 101, 120, 80,
			97, 100, 100, 105, 110, 103, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 53, 92, 65, 115,
			115, 101, 116, 115, 92, 80, 108, 117, 103, 105,
			110, 115, 92, 70, 97, 99, 101, 112, 117, 110,
			99, 104, 46, 70, 108, 101, 120, 98, 111, 120,
			92, 70, 108, 101, 120, 83, 99, 111, 112, 101,
			100, 85, 112, 100, 97, 116, 101, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 45, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 70, 108, 101, 120, 98, 111,
			120, 92, 70, 108, 101, 120, 84, 101, 120, 116,
			46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
			51, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 70, 97, 99,
			101, 112, 117, 110, 99, 104, 46, 70, 108, 101,
			120, 98, 111, 120, 92, 70, 108, 101, 120, 84,
			114, 97, 110, 115, 105, 116, 105, 111, 110, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 48,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 70, 108, 101, 120,
			98, 111, 120, 92, 70, 108, 101, 120, 85, 116,
			105, 108, 105, 116, 121, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 46, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 70, 108, 101, 120, 98, 111, 120, 92,
			70, 108, 101, 120, 86, 97, 108, 117, 101, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 46,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 70, 108, 101, 120,
			98, 111, 120, 92, 73, 70, 108, 101, 120, 78,
			111, 100, 101, 46, 99, 115
		};
		result.TypesData = new byte[796]
		{
			0, 0, 0, 0, 31, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 46, 70, 108, 101, 120, 98,
			111, 120, 124, 70, 108, 101, 120, 65, 108, 105,
			103, 110, 83, 101, 108, 102, 0, 0, 0, 0,
			33, 70, 97, 99, 101, 112, 117, 110, 99, 104,
			46, 70, 108, 101, 120, 98, 111, 120, 124, 70,
			108, 101, 120, 65, 115, 112, 101, 99, 116, 82,
			97, 116, 105, 111, 0, 0, 0, 0, 37, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 70,
			108, 101, 120, 98, 111, 120, 124, 70, 108, 101,
			120, 67, 104, 105, 108, 100, 69, 110, 117, 109,
			101, 114, 97, 98, 108, 101, 0, 0, 0, 0,
			37, 70, 97, 99, 101, 112, 117, 110, 99, 104,
			46, 70, 108, 101, 120, 98, 111, 120, 124, 70,
			108, 101, 120, 67, 104, 105, 108, 100, 69, 110,
			117, 109, 101, 114, 97, 116, 111, 114, 0, 0,
			0, 0, 36, 70, 97, 99, 101, 112, 117, 110,
			99, 104, 46, 70, 108, 101, 120, 98, 111, 120,
			124, 70, 108, 101, 120, 67, 111, 108, 117, 109,
			110, 115, 69, 108, 101, 109, 101, 110, 116, 0,
			0, 0, 0, 53, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 70, 108, 101, 120, 98, 111,
			120, 46, 70, 108, 101, 120, 67, 111, 108, 117,
			109, 110, 115, 69, 108, 101, 109, 101, 110, 116,
			124, 67, 111, 108, 117, 109, 110, 80, 97, 114,
			97, 109, 101, 116, 101, 114, 115, 0, 0, 0,
			0, 29, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 70, 108, 101, 120, 98, 111, 120, 124,
			70, 108, 101, 120, 69, 108, 101, 109, 101, 110,
			116, 0, 0, 0, 0, 51, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 70, 108, 101, 120,
			98, 111, 120, 46, 70, 108, 101, 120, 69, 108,
			101, 109, 101, 110, 116, 124, 67, 104, 105, 108,
			100, 83, 105, 122, 105, 110, 103, 80, 97, 114,
			97, 109, 101, 116, 101, 114, 115, 0, 0, 0,
			0, 33, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 70, 108, 101, 120, 98, 111, 120, 124,
			70, 108, 101, 120, 69, 108, 101, 109, 101, 110,
			116, 66, 97, 115, 101, 0, 0, 0, 0, 38,
			70, 97, 99, 101, 112, 117, 110, 99, 104, 46,
			70, 108, 101, 120, 98, 111, 120, 124, 70, 108,
			101, 120, 71, 114, 97, 112, 104, 105, 99, 84,
			114, 97, 110, 115, 102, 111, 114, 109, 0, 0,
			0, 0, 35, 70, 97, 99, 101, 112, 117, 110,
			99, 104, 46, 70, 108, 101, 120, 98, 111, 120,
			124, 70, 108, 101, 120, 76, 97, 121, 111, 117,
			116, 77, 97, 110, 97, 103, 101, 114, 0, 0,
			0, 0, 28, 70, 97, 99, 101, 112, 117, 110,
			99, 104, 46, 70, 108, 101, 120, 98, 111, 120,
			124, 70, 108, 101, 120, 76, 101, 110, 103, 116,
			104, 0, 0, 0, 0, 29, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 70, 108, 101, 120,
			98, 111, 120, 124, 70, 108, 101, 120, 80, 97,
			100, 100, 105, 110, 103, 0, 0, 0, 0, 34,
			70, 97, 99, 101, 112, 117, 110, 99, 104, 46,
			70, 108, 101, 120, 98, 111, 120, 124, 70, 108,
			101, 120, 83, 99, 111, 112, 101, 100, 85, 112,
			100, 97, 116, 101, 0, 0, 0, 0, 26, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 70,
			108, 101, 120, 98, 111, 120, 124, 70, 108, 101,
			120, 84, 101, 120, 116, 0, 0, 0, 0, 32,
			70, 97, 99, 101, 112, 117, 110, 99, 104, 46,
			70, 108, 101, 120, 98, 111, 120, 124, 70, 108,
			101, 120, 84, 114, 97, 110, 115, 105, 116, 105,
			111, 110, 0, 0, 0, 0, 43, 70, 97, 99,
			101, 112, 117, 110, 99, 104, 46, 70, 108, 101,
			120, 98, 111, 120, 46, 70, 108, 101, 120, 84,
			114, 97, 110, 115, 105, 116, 105, 111, 110, 124,
			68, 101, 102, 105, 110, 105, 116, 105, 111, 110,
			0, 0, 0, 0, 37, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 46, 70, 108, 101, 120, 98,
			111, 120, 46, 85, 116, 105, 108, 105, 116, 121,
			124, 70, 108, 101, 120, 85, 116, 105, 108, 105,
			116, 121, 0, 0, 0, 0, 27, 70, 97, 99,
			101, 112, 117, 110, 99, 104, 46, 70, 108, 101,
			120, 98, 111, 120, 124, 70, 108, 101, 120, 86,
			97, 108, 117, 101, 0, 0, 0, 0, 27, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 70,
			108, 101, 120, 98, 111, 120, 124, 73, 70, 108,
			101, 120, 78, 111, 100, 101
		};
		result.TotalFiles = 16;
		result.TotalTypes = 20;
		result.IsEditorOnly = false;
		return result;
	}
}


public enum FlexDirection
{
	Row,
	RowReverse,
	Column,
	ColumnReverse
}


public enum FlexJustify
{
	Start,
	End,
	Center,
	SpaceBetween,
	SpaceAround,
	SpaceEvenly
}


public enum FlexAlign
{
	Start,
	End,
	Center,
	Stretch
}


using System;
using Facepunch.Flexbox;

[Serializable]
public struct FlexAlignSelf
{
	public bool HasValue;

	public FlexAlign Value;

	internal FlexAlign GetValueOrDefault(FlexAlign defaultValue)
	{
		if (!HasValue)
		{
			return defaultValue;
		}
		return Value;
	}
}


using Facepunch.Flexbox;
using UnityEngine;

[ExecuteAlways]
[RequireComponent(typeof(RectTransform))]
[DisallowMultipleComponent]
public class FlexAspectRatio : MonoBehaviour, IFlexNode
{
	[Tooltip("Controls the initial size of the element before factoring in grow/shrink.")]
	public FlexLength Basis;

	[Min(0f)]
	[Tooltip("How much this flex element should grow relative to its siblings.")]
	public int Grow = 1;

	[Min(0f)]
	[Tooltip("How much this flex element should shrink relative to its siblings.")]
	public int Shrink = 1;

	[Tooltip("Optionally override the parent's cross axis alignment for this element.")]
	public FlexAlignSelf AlignSelf;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength MinWidth;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength MaxWidth;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength MinHeight;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength MaxHeight;

	[Tooltip("The aspect ratio to constrain to - X:Y.")]
	public Vector2 AspectRatio = new Vector2(16f, 9f);

	private float _preferredWidth;

	private float _preferredHeight;

	RectTransform IFlexNode.Transform => (RectTransform)((Component)this).transform;

	bool IFlexNode.IsActive => ((Behaviour)this).isActiveAndEnabled;

	bool IFlexNode.IsAbsolute => false;

	bool IFlexNode.IsDirty => true;

	FlexLength IFlexNode.MinWidth => MinWidth;

	FlexLength IFlexNode.MaxWidth => MaxWidth;

	FlexLength IFlexNode.MinHeight => MinHeight;

	FlexLength IFlexNode.MaxHeight => MaxHeight;

	FlexLength IFlexNode.Basis => Basis;

	int IFlexNode.Grow => Grow;

	int IFlexNode.Shrink => Shrink;

	FlexAlignSelf IFlexNode.AlignSelf => AlignSelf;

	protected void OnEnable()
	{
		SetLayoutDirty();
	}

	protected void OnDisable()
	{
		SetLayoutDirty();
	}

	public void SetLayoutDirty()
	{
		Transform parent = ((Component)this).transform.parent;
		IFlexNode flexNode = default(IFlexNode);
		if ((Object)(object)parent != (Object)null && ((Component)parent).TryGetComponent<IFlexNode>(ref flexNode) && flexNode.IsActive)
		{
			flexNode.SetLayoutDirty();
		}
	}

	void IFlexNode.SetupTransform()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		RectTransform val = (RectTransform)((Component)this).transform;
		((Transform)val).localRotation = Quaternion.identity;
		val.pivot = new Vector2(0f, 1f);
		val.anchorMin = new Vector2(0f, 1f);
		val.anchorMax = new Vector2(0f, 1f);
	}

	void IFlexNode.SetLayoutDirty(bool force)
	{
		if (force || ((Behaviour)this).isActiveAndEnabled)
		{
			SetLayoutDirty();
		}
	}

	void IFlexNode.MeasureHorizontal()
	{
		_preferredWidth = ((MinWidth.HasValue && MinWidth.Unit == FlexUnit.Pixels) ? MinWidth.Value : 1f);
		_preferredHeight = ((MinHeight.HasValue && MinHeight.Unit == FlexUnit.Pixels) ? MinHeight.Value : 1f);
	}

	void IFlexNode.LayoutHorizontal(float maxWidth, float maxHeight)
	{
	}

	void IFlexNode.MeasureVertical()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		float num = ((AspectRatio.x > 0f && AspectRatio.y > 0f) ? (AspectRatio.x / AspectRatio.y) : 1f);
		Vector2 sizeDelta = ((RectTransform)((Component)this).transform).sizeDelta;
		_preferredHeight = sizeDelta.x / num;
	}

	void IFlexNode.LayoutVertical(float maxWidth, float maxHeight)
	{
	}

	void IFlexNode.GetScale(out float scaleX, out float scaleY)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localScale = ((Transform)(RectTransform)((Component)this).transform).localScale;
		scaleX = localScale.x;
		scaleY = localScale.y;
	}

	void IFlexNode.GetPreferredSize(out float preferredWidth, out float preferredHeight)
	{
		preferredWidth = _preferredWidth;
		preferredHeight = _preferredHeight;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch.Flexbox;

internal struct FlexChildEnumerable : IEnumerable<IFlexNode>, IEnumerable
{
	private readonly FlexElementBase _parent;

	private readonly bool _reversed;

	public FlexChildEnumerable(FlexElementBase parent, bool reversed)
	{
		_parent = parent;
		_reversed = reversed;
	}

	public FlexChildEnumerator GetEnumerator()
	{
		return new FlexChildEnumerator(_parent, _reversed);
	}

	IEnumerator<IFlexNode> IEnumerable<IFlexNode>.GetEnumerator()
	{
		throw new NotSupportedException();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		throw new NotSupportedException();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch.Flexbox;
using UnityEngine;

internal struct FlexChildEnumerator : IEnumerator<IFlexNode>, IEnumerator, IDisposable
{
	private readonly Transform _parent;

	private readonly int _childCount;

	private readonly bool _reversed;

	private int _index;

	public IFlexNode Current { get; private set; }

	object IEnumerator.Current => Current;

	public FlexChildEnumerator(FlexElementBase parent, bool reversed)
	{
		_parent = ((Component)parent).transform;
		_childCount = _parent.childCount;
		_reversed = reversed;
		_index = (reversed ? (_childCount - 1) : 0);
		Current = null;
	}

	public bool MoveNext()
	{
		IFlexNode flexNode = default(IFlexNode);
		while (true)
		{
			if (_reversed ? (_index < 0) : (_index >= _childCount))
			{
				Current = null;
				return false;
			}
			if (((Component)_parent.GetChild(_index)).gameObject.TryGetComponent<IFlexNode>(ref flexNode) && flexNode.IsActive && !flexNode.IsAbsolute)
			{
				break;
			}
			_index += ((!_reversed) ? 1 : (-1));
		}
		Current = flexNode;
		_index += ((!_reversed) ? 1 : (-1));
		return true;
	}

	public void Reset()
	{
	}

	public void Dispose()
	{
	}
}


using System;
using Facepunch.Flexbox;
using UnityEngine;
using UnityEngine.Serialization;

[ExecuteAlways]
[RequireComponent(typeof(RectTransform))]
[DisallowMultipleComponent]
public class FlexColumnsElement : FlexElementBase
{
	private struct ColumnParameters
	{
		public float Height;

		public float Offset;
	}

	[Tooltip("Spacing to add from this elements borders to where children are laid out.")]
	public FlexPadding Padding;

	[Min(0f)]
	[Tooltip("Spacing to add between each child flex item.")]
	public float Gap;

	[Tooltip("Enable this to use a fixed number of columns.")]
	public bool FixedColumnCount;

	[Min(1f)]
	[Tooltip("The number of columns to use when using a fixed number of columns.")]
	public int ColumnCount = 1;

	[Min(1f)]
	[Tooltip("The minimum width of each column when not using a fixed number of columns.")]
	[FormerlySerializedAs("ColumnWidth")]
	public int ColumnMinWidth = 100;

	private int _calculatedColumnCount;

	private ColumnParameters[] _columnParams = Array.Empty<ColumnParameters>();

	protected override void MeasureHorizontalImpl()
	{
		float num = 0f;
		float scaleY;
		if (FixedColumnCount && ColumnCount > 0)
		{
			int num2 = Mathf.Min(ColumnCount, Children.Count);
			Span<float> span = stackalloc float[num2];
			int num3 = 0;
			foreach (IFlexNode child in Children)
			{
				if (child.IsDirty)
				{
					child.MeasureHorizontal();
				}
				child.GetScale(out var scaleX, out scaleY);
				child.GetPreferredSize(out var preferredWidth, out scaleY);
				span[num3] = Mathf.Max(span[num3], preferredWidth * scaleX);
				num3++;
				if (num3 >= num2)
				{
					num3 = 0;
				}
			}
			bool flag = true;
			for (int i = 0; i < num2; i++)
			{
				float num4 = (flag ? 0f : Gap);
				num += span[i] + num4;
				if (flag)
				{
					flag = false;
				}
			}
		}
		else
		{
			bool flag2 = true;
			foreach (IFlexNode child2 in Children)
			{
				if (child2.IsDirty)
				{
					child2.MeasureHorizontal();
				}
				child2.GetScale(out var scaleX2, out scaleY);
				child2.GetPreferredSize(out var preferredWidth2, out scaleY);
				float num5 = (flag2 ? 0f : Gap);
				num += preferredWidth2 * scaleX2 + num5;
				if (flag2)
				{
					flag2 = false;
				}
			}
		}
		float num6 = ((Basis.HasValue && Basis.Unit == FlexUnit.Pixels) ? Basis.Value : 0f);
		float num7 = ((MinWidth.HasValue && MinWidth.Unit == FlexUnit.Pixels) ? MinWidth.Value : 0f);
		float num8 = ((MaxWidth.HasValue && MaxWidth.Unit == FlexUnit.Pixels) ? MaxWidth.Value : float.PositiveInfinity);
		float num9 = Padding.left + Padding.right;
		PrefWidth = Mathf.Clamp(num + num9, Mathf.Max(num7, num6), num8);
	}

	protected override void LayoutHorizontalImpl(float maxWidth, float maxHeight)
	{
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		float num = maxWidth - Padding.left - Padding.right;
		_calculatedColumnCount = (FixedColumnCount ? ColumnCount : Mathf.Max(Mathf.FloorToInt((num + Gap) / ((float)ColumnMinWidth + Gap)), 1));
		int num2 = Mathf.Max(_calculatedColumnCount - 1, 0);
		float num3 = (num - Gap * (float)num2) / (float)_calculatedColumnCount;
		int num4 = 0;
		foreach (IFlexNode child in Children)
		{
			float num5 = FlexElementBase.CalculateLengthValue(child.MinWidth, num, 0f);
			float num6 = FlexElementBase.CalculateLengthValue(child.MaxWidth, num, float.PositiveInfinity);
			float num7 = Mathf.Clamp(num3, num5, num6);
			child.LayoutHorizontal(num7, float.PositiveInfinity);
			RectTransform transform = child.Transform;
			Vector2 sizeDelta = transform.sizeDelta;
			transform.sizeDelta = new Vector2(num7, sizeDelta.y);
			Vector2 anchoredPosition = transform.anchoredPosition;
			transform.anchoredPosition = new Vector2(Padding.left + (num3 + Gap) * (float)num4, anchoredPosition.y);
			num4++;
			if (num4 >= _calculatedColumnCount)
			{
				num4 = 0;
			}
		}
	}

	protected override void MeasureVerticalImpl()
	{
		EnsureColumnParamsSize();
		for (int i = 0; i < _calculatedColumnCount; i++)
		{
			_columnParams[i].Height = 0f;
		}
		int num = 0;
		bool flag = true;
		foreach (IFlexNode child in Children)
		{
			if (child.IsDirty)
			{
				child.MeasureVertical();
			}
			child.GetScale(out var scaleX, out var scaleY);
			child.GetPreferredSize(out scaleX, out var preferredHeight);
			float num2 = (flag ? 0f : Gap);
			_columnParams[num].Height += preferredHeight * scaleY + num2;
			num++;
			if (num >= _calculatedColumnCount)
			{
				num = 0;
				flag = false;
			}
		}
		float num3 = ((Basis.HasValue && Basis.Unit == FlexUnit.Pixels) ? Basis.Value : 0f);
		float num4 = ((MinHeight.HasValue && MinHeight.Unit == FlexUnit.Pixels) ? MinHeight.Value : 0f);
		float num5 = ((MaxHeight.HasValue && MaxHeight.Unit == FlexUnit.Pixels) ? MaxHeight.Value : float.PositiveInfinity);
		float num6 = 0f;
		for (int j = 0; j < _calculatedColumnCount; j++)
		{
			float height = _columnParams[j].Height;
			if (height > num6)
			{
				num6 = height;
			}
		}
		float num7 = Padding.top + Padding.bottom;
		PrefHeight = Mathf.Clamp(num6 + num7, Mathf.Max(num4, num3), num5);
	}

	protected override void LayoutVerticalImpl(float maxWidth, float maxHeight)
	{
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		float fillValue = maxHeight - Padding.top - Padding.bottom;
		EnsureColumnParamsSize();
		for (int i = 0; i < _calculatedColumnCount; i++)
		{
			_columnParams[i].Offset = 0f;
		}
		int num = 0;
		foreach (IFlexNode child in Children)
		{
			ref ColumnParameters reference = ref _columnParams[num];
			float num2 = FlexElementBase.CalculateLengthValue(child.MinHeight, fillValue, 0f);
			float num3 = FlexElementBase.CalculateLengthValue(child.MaxHeight, fillValue, float.PositiveInfinity);
			child.GetPreferredSize(out var _, out var preferredHeight);
			float num4 = Mathf.Clamp(preferredHeight, num2, num3);
			child.LayoutVertical(float.PositiveInfinity, num4);
			RectTransform transform = child.Transform;
			Vector2 sizeDelta = transform.sizeDelta;
			transform.sizeDelta = new Vector2(sizeDelta.x, num4);
			Vector2 anchoredPosition = transform.anchoredPosition;
			transform.anchoredPosition = new Vector2(anchoredPosition.x, 0f - (Padding.top + reference.Offset));
			reference.Offset += num4 + Gap;
			num++;
			if (num >= _calculatedColumnCount)
			{
				num = 0;
			}
		}
	}

	private void EnsureColumnParamsSize()
	{
		if (_columnParams.Length < _calculatedColumnCount)
		{
			Array.Resize(ref _columnParams, _calculatedColumnCount);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch.Flexbox;
using UnityEngine;

[ExecuteAlways]
[RequireComponent(typeof(RectTransform))]
[DisallowMultipleComponent]
public class FlexElement : FlexElementBase
{
	private struct ChildSizingParameters
	{
		public float Size;

		public float MinSize;

		public float MaxSize;

		public bool IsFlexible;

		public float Scale;
	}

	private static readonly List<IFlexNode> SizingChildren = new List<IFlexNode>();

	[Tooltip("The direction to layout children in. This determines which axis is the main axis.")]
	public FlexDirection FlexDirection;

	[Tooltip("Where to start laying out children on the main axis.")]
	public FlexJustify JustifyContent;

	[Tooltip("How to align child flex elements on the cross axis.")]
	public FlexAlign AlignItems = FlexAlign.Stretch;

	[Tooltip("Spacing to add from this elements borders to where children are laid out.")]
	public FlexPadding Padding;

	[Min(0f)]
	[Tooltip("Spacing to add between each child flex item.")]
	public float Gap;

	private ChildSizingParameters[] _childSizes = Array.Empty<ChildSizingParameters>();

	private bool IsHorizontal
	{
		get
		{
			if (FlexDirection != 0)
			{
				return FlexDirection == FlexDirection.RowReverse;
			}
			return true;
		}
	}

	protected override bool IsReversed
	{
		get
		{
			if (FlexDirection != FlexDirection.RowReverse)
			{
				return FlexDirection == FlexDirection.ColumnReverse;
			}
			return true;
		}
	}

	protected override void MeasureHorizontalImpl()
	{
		if (IsHorizontal)
		{
			MeasureMainAxis();
		}
		else
		{
			MeasureCrossAxis();
		}
	}

	protected override void LayoutHorizontalImpl(float maxWidth, float maxHeight)
	{
		if (IsHorizontal)
		{
			LayoutMainAxis(maxWidth, maxHeight);
		}
		else
		{
			LayoutCrossAxis(maxWidth, maxHeight);
		}
	}

	protected override void MeasureVerticalImpl()
	{
		if (IsHorizontal)
		{
			MeasureCrossAxis();
		}
		else
		{
			MeasureMainAxis();
		}
	}

	protected override void LayoutVerticalImpl(float maxWidth, float maxHeight)
	{
		if (IsHorizontal)
		{
			LayoutCrossAxis(maxWidth, maxHeight);
		}
		else
		{
			LayoutMainAxis(maxWidth, maxHeight);
		}
	}

	private void MeasureMainAxis()
	{
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		bool isHorizontal = IsHorizontal;
		ref float reference = ref FlexElementBase.Pick(isHorizontal, ref PrefWidth, ref PrefHeight);
		float num = (isHorizontal ? (Padding.left + Padding.right) : (Padding.top + Padding.bottom));
		float num2 = 0f;
		bool flag = true;
		foreach (IFlexNode child in Children)
		{
			if (child.IsDirty)
			{
				if (isHorizontal)
				{
					child.MeasureHorizontal();
				}
				else
				{
					child.MeasureVertical();
				}
			}
			child.GetScale(out var scaleX, out var scaleY);
			child.GetPreferredSize(out var preferredWidth, out var preferredHeight);
			float num3 = (flag ? 0f : Gap);
			num2 = ((!isHorizontal) ? (num2 + (preferredHeight * scaleY + num3)) : (num2 + (preferredWidth * scaleX + num3)));
			if (flag)
			{
				flag = false;
			}
		}
		FlexLength flexLength = (isHorizontal ? MinWidth : MinHeight);
		FlexLength flexLength2 = (isHorizontal ? MaxWidth : MaxHeight);
		float num4 = ((Basis.HasValue && Basis.Unit == FlexUnit.Pixels) ? Basis.Value : 0f);
		float num5 = ((flexLength.HasValue && flexLength.Unit == FlexUnit.Pixels) ? flexLength.Value : 0f);
		float num6 = ((flexLength2.HasValue && flexLength2.Unit == FlexUnit.Pixels) ? flexLength2.Value : float.PositiveInfinity);
		reference = Mathf.Clamp(num2 + num, Mathf.Max(num5, num4), num6);
		if (IsAbsolute)
		{
			Rect rect = ((RectTransform)((Component)this).transform).rect;
			if (isHorizontal && !AutoSizeX)
			{
				reference = ((Rect)(ref rect)).width;
			}
			else if (!isHorizontal && !AutoSizeY)
			{
				reference = ((Rect)(ref rect)).height;
			}
		}
	}

	private void LayoutMainAxis(float maxWidth, float maxHeight)
	{
		//IL_0508: Unknown result type (might be due to invalid IL or missing references)
		//IL_050d: Unknown result type (might be due to invalid IL or missing references)
		//IL_052f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0536: Unknown result type (might be due to invalid IL or missing references)
		//IL_0513: Unknown result type (might be due to invalid IL or missing references)
		//IL_0521: Unknown result type (might be due to invalid IL or missing references)
		//IL_0541: Unknown result type (might be due to invalid IL or missing references)
		//IL_0546: Unknown result type (might be due to invalid IL or missing references)
		//IL_055d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0564: Unknown result type (might be due to invalid IL or missing references)
		//IL_054b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		bool isHorizontal2 = IsHorizontal;
		bool isReversed2 = IsReversed;
		float innerSize = (isHorizontal2 ? (maxWidth - Padding.left - Padding.right) : (maxHeight - Padding.top - Padding.bottom));
		int num = Mathf.Max(Children.Count - 1, 0);
		float fillValue = innerSize - Gap * (float)num;
		SizingChildren.Clear();
		if (_childSizes.Length < Children.Count)
		{
			Array.Resize(ref _childSizes, Children.Count);
		}
		int num2 = 0;
		int num3 = 0;
		float num4 = 0f;
		bool flag = true;
		for (int i = 0; i < Children.Count; i++)
		{
			IFlexNode flexNode = Children[i];
			ref ChildSizingParameters reference = ref _childSizes[i];
			float num5 = FlexElementBase.CalculateLengthValue(isHorizontal2 ? flexNode.MinWidth : flexNode.MinHeight, fillValue, 0f);
			float num6 = FlexElementBase.CalculateLengthValue(isHorizontal2 ? flexNode.MaxWidth : flexNode.MaxHeight, fillValue, float.PositiveInfinity);
			bool flag2 = num5 < num6;
			flexNode.GetPreferredSize(out var preferredWidth, out var preferredHeight);
			float defaultValue = (isHorizontal2 ? preferredWidth : preferredHeight);
			flexNode.GetScale(out var scaleX, out var scaleY);
			float num7 = (isHorizontal2 ? scaleX : scaleY);
			num2 += flexNode.Grow;
			num3 += flexNode.Shrink;
			float num8 = (reference.Size = Mathf.Clamp(FlexElementBase.CalculateLengthValue(flexNode.Basis, fillValue, defaultValue), num5, num6));
			reference.MinSize = num5;
			reference.MaxSize = num6;
			reference.IsFlexible = flag2;
			reference.Scale = num7;
			SizingChildren.Add(flag2 ? flexNode : null);
			num4 += num8 * num7;
			if (flag)
			{
				flag = false;
			}
			else
			{
				num4 += Gap;
			}
		}
		float growthAllowance = Mathf.Max(innerSize - num4, 0f);
		float shrinkAllowance = Mathf.Max(num4 - innerSize, 0f);
		while (SizingChildren.Exists((IFlexNode n) => n != null))
		{
			int growSum = num2;
			int shrinkSum = num3;
			for (int j = 0; j < SizingChildren.Count; j++)
			{
				IFlexNode child = SizingChildren[j];
				if (child != null)
				{
					ref ChildSizingParameters reference2 = ref _childSizes[j];
					bool flag3 = true;
					if (growthAllowance > 0f && child.Grow > 0 && reference2.IsFlexible)
					{
						flag3 = TakeGrowth(ref reference2.Size, reference2.MaxSize, reference2.Scale);
					}
					else if (shrinkAllowance > 0f && child.Shrink > 0 && reference2.IsFlexible)
					{
						flag3 = TakeShrink(ref reference2.Size, reference2.MinSize, reference2.Scale);
					}
					if (flag3)
					{
						SizingChildren[j] = null;
					}
				}
				bool TakeGrowth(ref float value, float maxValue, float scale)
				{
					float num13 = (float)child.Grow / (float)growSum * growthAllowance;
					float num14 = Mathf.Clamp(maxValue - value, 0f, num13);
					value += ((scale > 0f) ? (num14 / scale) : 0f);
					growthAllowance -= num14;
					growSum -= child.Grow;
					return num14 <= float.Epsilon;
				}
				bool TakeShrink(ref float value, float minValue, float scale)
				{
					float num15 = (float)child.Shrink / (float)shrinkSum * shrinkAllowance;
					float num16 = Mathf.Clamp(value - minValue, 0f, num15);
					value -= ((scale > 0f) ? (num16 / scale) : 0f);
					shrinkAllowance -= num16;
					shrinkSum -= child.Shrink;
					return num16 <= float.Epsilon;
				}
			}
		}
		float actualMainSize = Gap * (float)num;
		for (int k = 0; k < Children.Count; k++)
		{
			actualMainSize += _childSizes[k].Size * _childSizes[k].Scale;
		}
		actualMainSize = Mathf.Min(actualMainSize, innerSize);
		float num9 = 0f;
		float extraOffset = 0f;
		if (JustifyContent == FlexJustify.SpaceBetween && num > 0)
		{
			num9 = (innerSize - actualMainSize) / (float)num;
			actualMainSize = innerSize;
		}
		else if (JustifyContent == FlexJustify.SpaceAround)
		{
			num9 = (innerSize - actualMainSize) / (float)(num + 1);
			extraOffset = num9 / 2f;
			actualMainSize = innerSize;
		}
		else if (JustifyContent == FlexJustify.SpaceEvenly)
		{
			num9 = (extraOffset = (innerSize - actualMainSize) / (float)(num + 2));
			actualMainSize = innerSize;
		}
		float num10 = Gap + num9;
		float num11 = GetMainAxisStart(isHorizontal2, isReversed2);
		for (int l = 0; l < Children.Count; l++)
		{
			IFlexNode flexNode2 = Children[l];
			ref ChildSizingParameters reference3 = ref _childSizes[l];
			if (isHorizontal2)
			{
				flexNode2.LayoutHorizontal(reference3.Size, float.PositiveInfinity);
			}
			else
			{
				flexNode2.LayoutVertical(float.PositiveInfinity, reference3.Size);
			}
			RectTransform transform = flexNode2.Transform;
			Vector2 sizeDelta = transform.sizeDelta;
			transform.sizeDelta = (isHorizontal2 ? new Vector2(reference3.Size, sizeDelta.y) : new Vector2(sizeDelta.x, reference3.Size));
			Vector2 anchoredPosition = transform.anchoredPosition;
			transform.anchoredPosition = (isHorizontal2 ? new Vector2(num11, anchoredPosition.y) : new Vector2(anchoredPosition.x, num11));
			float num12 = reference3.Size * reference3.Scale;
			num11 += (isHorizontal2 ? (num12 + num10) : (0f - num12 - num10));
		}
		float GetMainAxisStart(bool isHorizontal, bool isReversed)
		{
			switch (JustifyContent)
			{
			case FlexJustify.Start:
			case FlexJustify.SpaceBetween:
			case FlexJustify.SpaceAround:
			case FlexJustify.SpaceEvenly:
				if (!isHorizontal)
				{
					return 0f - (isReversed ? (innerSize - actualMainSize + Padding.top + extraOffset) : (Padding.top + extraOffset));
				}
				if (!isReversed)
				{
					return Padding.left + extraOffset;
				}
				return innerSize - actualMainSize + Padding.left + extraOffset;
			case FlexJustify.End:
				if (!isHorizontal)
				{
					return 0f - (isReversed ? Padding.top : (innerSize - actualMainSize + Padding.top));
				}
				if (!isReversed)
				{
					return innerSize - actualMainSize + Padding.left;
				}
				return Padding.left;
			case FlexJustify.Center:
				if (!isHorizontal)
				{
					return 0f - (innerSize - actualMainSize) / 2f - Padding.top;
				}
				return (innerSize - actualMainSize) / 2f + Padding.left;
			default:
				throw new NotSupportedException(JustifyContent.ToString());
			}
		}
	}

	private void MeasureCrossAxis()
	{
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		bool isHorizontal = IsHorizontal;
		ref float reference = ref FlexElementBase.Pick(isHorizontal, ref PrefHeight, ref PrefWidth);
		float num = (isHorizontal ? (Padding.top + Padding.bottom) : (Padding.left + Padding.right));
		float num2 = 0f;
		foreach (IFlexNode child in Children)
		{
			if (child.IsDirty)
			{
				if (isHorizontal)
				{
					child.MeasureVertical();
				}
				else
				{
					child.MeasureHorizontal();
				}
			}
			child.GetScale(out var scaleX, out var scaleY);
			child.GetPreferredSize(out var preferredWidth, out var preferredHeight);
			num2 = ((!isHorizontal) ? Mathf.Max(num2, preferredWidth * scaleX) : Mathf.Max(num2, preferredHeight * scaleY));
		}
		if (IsAbsolute && !AutoSizeY && isHorizontal)
		{
			Rect rect = ((RectTransform)((Component)this).transform).rect;
			reference = ((Rect)(ref rect)).height;
			return;
		}
		if (IsAbsolute && !AutoSizeX && !isHorizontal)
		{
			Rect rect2 = ((RectTransform)((Component)this).transform).rect;
			reference = ((Rect)(ref rect2)).width;
			return;
		}
		FlexLength flexLength = (isHorizontal ? MinHeight : MinWidth);
		FlexLength flexLength2 = (isHorizontal ? MaxHeight : MaxWidth);
		float num3 = ((flexLength.HasValue && flexLength.Unit == FlexUnit.Pixels) ? flexLength.Value : 0f);
		float num4 = ((flexLength2.HasValue && flexLength2.Unit == FlexUnit.Pixels) ? flexLength2.Value : float.PositiveInfinity);
		reference = Mathf.Clamp(num2 + num, num3, num4);
	}

	private void LayoutCrossAxis(float maxWidth, float maxHeight)
	{
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		bool isHorizontal2 = IsHorizontal;
		float innerSize = (isHorizontal2 ? (maxHeight - Padding.top - Padding.bottom) : (maxWidth - Padding.left - Padding.right));
		foreach (IFlexNode child in Children)
		{
			child.GetScale(out var scaleX, out var scaleY);
			child.GetPreferredSize(out var preferredWidth, out var preferredHeight);
			float num = (isHorizontal2 ? scaleY : scaleX);
			float num2 = ((num > 0f) ? (innerSize / num) : 0f);
			FlexAlign valueOrDefault = child.AlignSelf.GetValueOrDefault(AlignItems);
			float num3 = FlexElementBase.CalculateLengthValue(isHorizontal2 ? child.MinHeight : child.MinWidth, num2, 0f);
			float num4 = FlexElementBase.CalculateLengthValue(isHorizontal2 ? child.MaxHeight : child.MaxWidth, num2, float.PositiveInfinity);
			float num5 = (isHorizontal2 ? preferredHeight : preferredWidth);
			float num6 = Mathf.Clamp((valueOrDefault == FlexAlign.Stretch) ? num2 : num5, num3, num4);
			float num7 = (isHorizontal2 ? float.PositiveInfinity : num6);
			float num8 = (isHorizontal2 ? num6 : float.PositiveInfinity);
			if (isHorizontal2)
			{
				child.LayoutVertical(num7, num8);
			}
			else
			{
				child.LayoutHorizontal(num7, num8);
			}
			float num9 = GetCrossAxis(valueOrDefault, isHorizontal2, num7 * scaleX, num8 * scaleY);
			RectTransform transform = child.Transform;
			Vector2 sizeDelta = transform.sizeDelta;
			transform.sizeDelta = (isHorizontal2 ? new Vector2(sizeDelta.x, num6) : new Vector2(num6, sizeDelta.y));
			Vector2 anchoredPosition = transform.anchoredPosition;
			transform.anchoredPosition = (isHorizontal2 ? new Vector2(anchoredPosition.x, num9) : new Vector2(num9, anchoredPosition.y));
		}
		float GetCrossAxis(FlexAlign align, bool isHorizontal, float childWidth, float childHeight)
		{
			switch (align)
			{
			case FlexAlign.Start:
			case FlexAlign.Stretch:
				if (!isHorizontal)
				{
					return Padding.left;
				}
				return 0f - Padding.top;
			case FlexAlign.End:
				if (!isHorizontal)
				{
					return innerSize + Padding.left - childWidth;
				}
				return 0f - innerSize - Padding.top + childHeight;
			case FlexAlign.Center:
				if (!isHorizontal)
				{
					return innerSize / 2f - childWidth / 2f + Padding.left;
				}
				return 0f - (innerSize / 2f - childHeight / 2f + Padding.top);
			default:
				throw new NotSupportedException(AlignItems.ToString());
			}
		}
	}
}


using System.Collections.Generic;
using Facepunch.Flexbox;
using Facepunch.Flexbox.Utility;
using UnityEngine;
using UnityEngine.EventSystems;

public abstract class FlexElementBase : UIBehaviour, IFlexNode
{
	[Tooltip("Controls the initial size of the element before factoring in grow/shrink.")]
	public FlexLength Basis;

	[Min(0f)]
	[Tooltip("How much this flex element should grow relative to its siblings.")]
	public int Grow;

	[Min(0f)]
	[Tooltip("How much this flex element should shrink relative to its siblings.")]
	public int Shrink = 1;

	[Tooltip("Optionally override the parent's cross axis alignment for this element.")]
	public FlexAlignSelf AlignSelf;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength MinWidth;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength MaxWidth;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength MinHeight;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength MaxHeight;

	[Tooltip("Overrides for the preferred dimensions of this flex element. Useful for things like images which would normally have a preferred size of zero.")]
	public FlexValue OverridePreferredWidth;

	[Tooltip("Overrides for the preferred dimensions of this flex element. Useful for things like images which would normally have a preferred size of zero.")]
	public FlexValue OverridePreferredHeight;

	[Tooltip("Absolute elements act as the root container for any number of flex elements.")]
	public bool IsAbsolute;

	[Tooltip("Automatically resize an absolute element to match the size of its children.")]
	public bool AutoSizeX;

	[Tooltip("Automatically resize an absolute element to match the size of its children.")]
	public bool AutoSizeY;

	protected bool IsDirty;

	protected bool IsDoingLayout;

	protected float PrefWidth;

	protected float PrefHeight;

	protected readonly List<IFlexNode> Children = new List<IFlexNode>();

	protected virtual bool IsReversed => false;

	RectTransform IFlexNode.Transform => (RectTransform)((Component)this).transform;

	bool IFlexNode.IsActive => ((UIBehaviour)this).IsActive();

	bool IFlexNode.IsAbsolute => IsAbsolute;

	bool IFlexNode.IsDirty => IsDirty;

	FlexLength IFlexNode.MinWidth => MinWidth;

	FlexLength IFlexNode.MaxWidth => MaxWidth;

	FlexLength IFlexNode.MinHeight => MinHeight;

	FlexLength IFlexNode.MaxHeight => MaxHeight;

	FlexLength IFlexNode.Basis => Basis;

	int IFlexNode.Grow => Grow;

	int IFlexNode.Shrink => Shrink;

	FlexAlignSelf IFlexNode.AlignSelf => AlignSelf;

	internal void PerformLayout()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Expected O, but got Unknown
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		RectTransform val = (RectTransform)((Component)this).transform;
		Rect rect = val.rect;
		float width = ((Rect)(ref rect)).width;
		float height = ((Rect)(ref rect)).height;
		bool flag = !IsAbsolute && FlexUtility.IsPrefabRoot(((Component)this).gameObject);
		bool flag2 = (IsAbsolute && AutoSizeX) || flag;
		bool flag3 = (IsAbsolute && AutoSizeY) || flag;
		((IFlexNode)this).MeasureHorizontal();
		((IFlexNode)this).LayoutHorizontal(flag2 ? PrefWidth : width, flag3 ? PrefHeight : height);
		((IFlexNode)this).MeasureVertical();
		((IFlexNode)this).LayoutVertical(flag2 ? PrefWidth : width, flag3 ? PrefHeight : height);
		IsDoingLayout = true;
		try
		{
			if (flag2)
			{
				val.SetSizeWithCurrentAnchors((Axis)0, PrefWidth);
			}
			if (flag3)
			{
				val.SetSizeWithCurrentAnchors((Axis)1, PrefHeight);
			}
		}
		finally
		{
			IsDoingLayout = false;
		}
	}

	public void SetLayoutDirty(bool force = false)
	{
		if (force || (!IsDoingLayout && ((UIBehaviour)this).IsActive()))
		{
			IsDirty = true;
			Transform parent = ((Component)this).transform.parent;
			IFlexNode flexNode = default(IFlexNode);
			if (IsAbsolute || (Object)(object)parent == (Object)null || !((Component)parent).TryGetComponent<IFlexNode>(ref flexNode))
			{
				FlexLayoutManager.EnqueueLayout(this);
			}
			else
			{
				flexNode.SetLayoutDirty(force);
			}
		}
	}

	protected abstract void MeasureHorizontalImpl();

	protected abstract void LayoutHorizontalImpl(float maxWidth, float maxHeight);

	protected abstract void MeasureVerticalImpl();

	protected abstract void LayoutVerticalImpl(float maxWidth, float maxHeight);

	void IFlexNode.SetupTransform()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (!IsAbsolute)
		{
			RectTransform val = (RectTransform)((Component)this).transform;
			((Transform)val).localRotation = Quaternion.identity;
			val.pivot = new Vector2(0f, 1f);
			val.anchorMin = new Vector2(0f, 1f);
			val.anchorMax = new Vector2(0f, 1f);
		}
	}

	void IFlexNode.MeasureHorizontal()
	{
		Children.Clear();
		foreach (IFlexNode item in new FlexChildEnumerable(this, IsReversed))
		{
			Children.Add(item);
			item.SetupTransform();
		}
		MeasureHorizontalImpl();
	}

	void IFlexNode.LayoutHorizontal(float maxWidth, float maxHeight)
	{
		IsDoingLayout = true;
		try
		{
			LayoutHorizontalImpl(maxWidth, maxHeight);
		}
		finally
		{
			IsDoingLayout = false;
		}
	}

	void IFlexNode.MeasureVertical()
	{
		MeasureVerticalImpl();
	}

	void IFlexNode.LayoutVertical(float maxWidth, float maxHeight)
	{
		IsDoingLayout = true;
		try
		{
			LayoutVerticalImpl(maxWidth, maxHeight);
			IsDirty = false;
		}
		finally
		{
			IsDoingLayout = false;
		}
	}

	void IFlexNode.GetScale(out float scaleX, out float scaleY)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localScale = ((Transform)(RectTransform)((Component)this).transform).localScale;
		scaleX = localScale.x;
		scaleY = localScale.y;
	}

	void IFlexNode.GetPreferredSize(out float preferredWidth, out float preferredHeight)
	{
		preferredWidth = Mathf.Clamp(OverridePreferredWidth.GetOrDefault(PrefWidth), MinWidth.GetValueOrDefault(0f), MaxWidth.GetValueOrDefault(float.PositiveInfinity));
		preferredHeight = Mathf.Clamp(OverridePreferredHeight.GetOrDefault(PrefHeight), MinHeight.GetValueOrDefault(0f), MaxHeight.GetValueOrDefault(float.PositiveInfinity));
	}

	protected override void OnEnable()
	{
		SetLayoutDirty(force: true);
	}

	protected override void OnDisable()
	{
		SetLayoutDirty(force: true);
	}

	protected override void OnRectTransformDimensionsChange()
	{
		SetLayoutDirty();
	}

	protected override void OnBeforeTransformParentChanged()
	{
		SetLayoutDirty();
	}

	protected override void OnTransformParentChanged()
	{
		SetLayoutDirty();
	}

	protected virtual void OnTransformChildrenChanged()
	{
		SetLayoutDirty();
	}

	protected static ref T Pick<T>(bool value, ref T ifTrue, ref T ifFalse)
	{
		if (value)
		{
			return ref ifTrue;
		}
		return ref ifFalse;
	}

	protected static float CalculateLengthValue(in FlexLength length, float fillValue, float defaultValue)
	{
		if (!length.HasValue)
		{
			return defaultValue;
		}
		if (length.Unit != FlexUnit.Percent)
		{
			return length.Value;
		}
		return length.Value / 100f * fillValue;
	}
}


using System;
using System.Collections.Generic;
using Facepunch.Flexbox;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
[DisallowMultipleComponent]
[ExecuteAlways]
public class FlexGraphicTransform : UIBehaviour, IMeshModifier
{
	[Range(0f, 1f)]
	public float OriginX = 0.5f;

	[Range(0f, 1f)]
	public float OriginY = 0.5f;

	public float TranslateX;

	public float TranslateY;

	public float ScaleX = 1f;

	public float ScaleY = 1f;

	public float Rotate;

	private static readonly Dictionary<TextMeshProUGUI, FlexGraphicTransform> TextMeshProTransformers;

	private static readonly List<TMP_SubMeshUI> SubMeshUIs;

	private static readonly List<Mesh> Meshes;

	private static readonly VertexHelper VertexHelper;

	private static readonly List<Vector3> Vertices;

	private static readonly List<int> Indices;

	private static readonly List<Color32> Colors;

	private static readonly List<Vector2> Uv0;

	private static readonly List<Vector2> Uv1;

	private static readonly List<Vector3> Normals;

	private static readonly List<Vector4> Tangents;

	private FlexGraphicTransform _parent;

	private RectTransform _rt;

	private Graphic _graphic;

	private TextMeshProUGUI _textMeshPro;

	private CanvasRenderer _canvasRenderer;

	private Matrix4x4 transformationMatrix
	{
		get
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			Vector2 val = new Vector2(OriginX, OriginY) - _rt.pivot;
			Rect rect = _rt.rect;
			Vector2 val2 = val * ((Rect)(ref rect)).size;
			Matrix4x4 val3 = Matrix4x4.Translate(new Vector3(val2.x, val2.y, 0f));
			Matrix4x4 val4 = Matrix4x4.TRS(new Vector3(TranslateX, TranslateY, 0f), Quaternion.Euler(0f, 0f, Rotate), new Vector3(ScaleX, ScaleY, 1f));
			Matrix4x4 val5 = val3 * val4 * ((Matrix4x4)(ref val3)).inverse;
			if (!((Object)(object)_parent != (Object)null))
			{
				return val5;
			}
			return _parent.transformationMatrix * val5;
		}
	}

	static FlexGraphicTransform()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Expected O, but got Unknown
		TextMeshProTransformers = new Dictionary<TextMeshProUGUI, FlexGraphicTransform>();
		SubMeshUIs = new List<TMP_SubMeshUI>();
		Meshes = new List<Mesh>();
		VertexHelper = new VertexHelper();
		Vertices = new List<Vector3>();
		Indices = new List<int>();
		Colors = new List<Color32>();
		Uv0 = new List<Vector2>();
		Uv1 = new List<Vector2>();
		Normals = new List<Vector3>();
		Tangents = new List<Vector4>();
		TMPro_EventManager.TEXT_CHANGED_EVENT.Add((Action<Object>)delegate(Object obj)
		{
			TextMeshProUGUI val = (TextMeshProUGUI)(object)((obj is TextMeshProUGUI) ? obj : null);
			if (val != null && TextMeshProTransformers.TryGetValue(val, out var value))
			{
				value.ModifyTextMeshPro();
			}
		});
	}

	protected override void Awake()
	{
		((UIBehaviour)this).Awake();
		UpdateParent();
		_rt = ((Component)this).GetComponent<RectTransform>();
		_graphic = ((Component)this).GetComponent<Graphic>();
		_textMeshPro = ((Component)this).GetComponent<TextMeshProUGUI>();
		_canvasRenderer = ((Component)this).GetComponent<CanvasRenderer>();
	}

	private void UpdateParent()
	{
		_parent = (((Object)(object)((Component)this).transform.parent != (Object)null) ? ((Component)((Component)this).transform.parent).GetComponent<FlexGraphicTransform>() : null);
	}

	protected override void OnEnable()
	{
		((UIBehaviour)this).OnEnable();
		if ((Object)(object)_textMeshPro != (Object)null)
		{
			TextMeshProTransformers.Add(_textMeshPro, this);
		}
		SetVerticesDirty();
	}

	protected override void OnDisable()
	{
		if ((Object)(object)_textMeshPro != (Object)null)
		{
			TextMeshProTransformers.Remove(_textMeshPro);
		}
		SetVerticesDirty();
		((UIBehaviour)this).OnDisable();
	}

	protected override void OnDidApplyAnimationProperties()
	{
		SetVerticesDirty();
		((UIBehaviour)this).OnDidApplyAnimationProperties();
	}

	protected override void OnTransformParentChanged()
	{
		((UIBehaviour)this).OnTransformParentChanged();
		UpdateParent();
	}

	public void SetVerticesDirty()
	{
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_textMeshPro != (Object)null && ((TMP_Text)_textMeshPro).textInfo?.meshInfo != null)
		{
			TMP_MeshInfo[] meshInfo = ((TMP_Text)_textMeshPro).textInfo.meshInfo;
			foreach (TMP_MeshInfo val in meshInfo)
			{
				Mesh mesh = val.mesh;
				if ((Object)(object)mesh != (Object)null)
				{
					mesh.Clear();
					mesh.vertices = val.vertices;
					mesh.uv = val.uvs0;
					mesh.uv2 = val.uvs2;
					mesh.colors32 = val.colors32;
					mesh.normals = val.normals;
					mesh.tangents = val.tangents;
					mesh.triangles = val.triangles;
				}
			}
			if ((Object)(object)_canvasRenderer != (Object)null)
			{
				_canvasRenderer.SetMesh(((TMP_Text)_textMeshPro).mesh);
				((Component)_textMeshPro).GetComponentsInChildren<TMP_SubMeshUI>(false, SubMeshUIs);
				foreach (TMP_SubMeshUI subMeshUI in SubMeshUIs)
				{
					subMeshUI.canvasRenderer.SetMesh(subMeshUI.mesh);
				}
				SubMeshUIs.Clear();
			}
			((TMP_Text)_textMeshPro).havePropertiesChanged = true;
		}
		else if ((Object)(object)_graphic != (Object)null)
		{
			_graphic.SetVerticesDirty();
		}
		FlexGraphicTransform flexGraphicTransform = default(FlexGraphicTransform);
		foreach (Transform item in ((Component)this).transform)
		{
			if (((Component)item).TryGetComponent<FlexGraphicTransform>(ref flexGraphicTransform) && ((Behaviour)flexGraphicTransform).isActiveAndEnabled)
			{
				flexGraphicTransform.SetVerticesDirty();
			}
		}
	}

	public void ModifyMesh(Mesh mesh)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		VertexHelper val = new VertexHelper(mesh);
		try
		{
			ModifyMesh(val);
			val.FillMesh(mesh);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ModifyMesh(VertexHelper vh)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_rt == (Object)null)
		{
			_rt = ((Component)this).GetComponent<RectTransform>();
		}
		Matrix4x4 val = transformationMatrix;
		UIVertex val2 = default(UIVertex);
		int currentVertCount = vh.currentVertCount;
		for (int i = 0; i < currentVertCount; i++)
		{
			vh.PopulateUIVertex(ref val2, i);
			val2.position = ((Matrix4x4)(ref val)).MultiplyPoint(val2.position);
			vh.SetUIVertex(val2, i);
		}
	}

	private void ModifyTextMeshPro()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_textMeshPro == (Object)null || !((Behaviour)this).isActiveAndEnabled)
		{
			return;
		}
		Meshes.Clear();
		TMP_MeshInfo[] meshInfo = ((TMP_Text)_textMeshPro).textInfo.meshInfo;
		foreach (TMP_MeshInfo val in meshInfo)
		{
			Meshes.Add(val.mesh);
		}
		foreach (Mesh mesh in Meshes)
		{
			if ((Object)(object)mesh != (Object)null)
			{
				CopyIntoVertexHelper(mesh);
				ModifyMesh(VertexHelper);
				VertexHelper.FillMesh(mesh);
			}
		}
		if ((Object)(object)_canvasRenderer != (Object)null)
		{
			_canvasRenderer.SetMesh(((TMP_Text)_textMeshPro).mesh);
			((Component)this).GetComponentsInChildren<TMP_SubMeshUI>(false, SubMeshUIs);
			foreach (TMP_SubMeshUI subMeshUI in SubMeshUIs)
			{
				subMeshUI.canvasRenderer.SetMesh(subMeshUI.mesh);
			}
			SubMeshUIs.Clear();
		}
		Meshes.Clear();
	}

	private static void CopyIntoVertexHelper(Mesh mesh)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		VertexHelper.Clear();
		mesh.GetVertices(Vertices);
		mesh.GetIndices(Indices, 0);
		mesh.GetColors(Colors);
		mesh.GetUVs(0, Uv0);
		mesh.GetUVs(1, Uv1);
		mesh.GetNormals(Normals);
		mesh.GetTangents(Tangents);
		for (int i = 0; i < Vertices.Count; i++)
		{
			VertexHelper.AddVert(Vertices[i], Colors[i], Uv0[i], Uv1[i], Normals[i], Tangents[i]);
		}
		for (int j = 0; j < Indices.Count; j += 3)
		{
			VertexHelper.AddTriangle(Indices[j], Indices[j + 1], Indices[j + 2]);
		}
	}
}


using System.Collections.Generic;
using Facepunch.Flexbox;
using UnityEngine;

[ExecuteAlways]
[DefaultExecutionOrder(-100)]
public class FlexLayoutManager : MonoBehaviour
{
	internal static readonly HashSet<FlexElementBase> ActiveScopedUpdates = new HashSet<FlexElementBase>();

	private static readonly List<FlexElementBase> DirtyElements = new List<FlexElementBase>();

	private static readonly List<FlexElementBase> UpdatingElements = new List<FlexElementBase>();

	public static FlexLayoutManager Instance { get; private set; }

	public void OnEnable()
	{
		if ((Object)(object)Instance != (Object)null)
		{
			Debug.LogWarning((object)"Cannot have multiple FlexLayoutManager!", (Object)(object)this);
		}
		else
		{
			Instance = this;
		}
	}

	public void OnDisable()
	{
		if ((Object)(object)Instance == (Object)(object)this)
		{
			Instance = null;
		}
	}

	public void LateUpdate()
	{
		FlushQueue();
	}

	private static bool IsServerEnvironment()
	{
		return true;
	}

	public static void EnqueueLayout(FlexElementBase element)
	{
		if (IsServerEnvironment() || (Object)(object)element == (Object)null)
		{
			return;
		}
		if ((Object)(object)Instance == (Object)null)
		{
			Debug.LogWarning((object)"There is no FlexLayoutManager!");
			return;
		}
		if (!((Behaviour)Instance).isActiveAndEnabled)
		{
			Debug.LogWarning((object)"FlexLayoutManager is not active!");
		}
		if (!DirtyElements.Contains(element) && !ActiveScopedUpdates.Contains(element))
		{
			DirtyElements.Add(element);
		}
	}

	internal static void LayoutImmediate(FlexElementBase element)
	{
		if (!((Object)(object)element == (Object)null) && element.IsAbsolute)
		{
			DirtyElements.Remove(element);
			element.PerformLayout();
		}
	}

	private static void FlushQueue()
	{
		if (DirtyElements.Count == 0)
		{
			return;
		}
		UpdatingElements.AddRange(DirtyElements);
		DirtyElements.Clear();
		try
		{
			foreach (FlexElementBase updatingElement in UpdatingElements)
			{
				if ((Object)(object)updatingElement != (Object)null)
				{
					updatingElement.PerformLayout();
				}
			}
		}
		finally
		{
			UpdatingElements.Clear();
		}
	}
}


using System;
using Facepunch.Flexbox;

[Serializable]
public struct FlexLength
{
	public bool HasValue;

	public float Value;

	public FlexUnit Unit;

	public float GetValueOrDefault(float defaultValue)
	{
		if (!HasValue || Unit != 0)
		{
			return defaultValue;
		}
		return Value;
	}
}


using UnityEngine;

public enum FlexUnit
{
	[InspectorName("px")]
	Pixels,
	[InspectorName("%")]
	Percent
}


using System;

[Serializable]
public struct FlexPadding
{
	public float left;

	public float right;

	public float top;

	public float bottom;

	public FlexPadding(float value)
	{
		left = (right = (top = (bottom = value)));
	}

	public FlexPadding(float left, float right, float top, float bottom)
	{
		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;
	}
}


using System;
using Facepunch.Flexbox;
using UnityEngine;

public readonly struct FlexScopedUpdate : IDisposable
{
	private readonly FlexElementBase _element;

	public FlexScopedUpdate(FlexElementBase element)
	{
		if ((Object)(object)element == (Object)null)
		{
			throw new ArgumentNullException("element");
		}
		if (!element.IsAbsolute)
		{
			throw new ArgumentException("Scoped updates can only be started for absolute flex elements.");
		}
		if (!FlexLayoutManager.ActiveScopedUpdates.Add(element))
		{
			throw new InvalidOperationException("A scoped update is already active for this flex element.");
		}
		_element = element;
	}

	public void Dispose()
	{
		FlexLayoutManager.ActiveScopedUpdates.Remove(_element);
		FlexLayoutManager.LayoutImmediate(_element);
	}
}


using Facepunch.Flexbox;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[ExecuteAlways]
[RequireComponent(typeof(RectTransform))]
[DisallowMultipleComponent]
public class FlexText : TextMeshProUGUI, IFlexNode
{
	[Tooltip("Controls the initial size of the element before factoring in grow/shrink.")]
	public FlexLength Basis;

	[Min(0f)]
	[Tooltip("How much this flex element should grow relative to its siblings.")]
	public int Grow = 1;

	[Min(0f)]
	[Tooltip("How much this flex element should shrink relative to its siblings.")]
	public int Shrink = 1;

	[Tooltip("Optionally override the parent's cross axis alignment for this element.")]
	public FlexAlignSelf AlignSelf;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength MinWidth;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength MaxWidth;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength MinHeight;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength MaxHeight;

	private bool _isDirty;

	private float _preferredWidth;

	private float _preferredHeight;

	RectTransform IFlexNode.Transform => (RectTransform)((TMP_Text)this).transform;

	bool IFlexNode.IsActive => ((Behaviour)this).isActiveAndEnabled;

	bool IFlexNode.IsAbsolute => false;

	bool IFlexNode.IsDirty => _isDirty;

	FlexLength IFlexNode.MinWidth => MinWidth;

	FlexLength IFlexNode.MaxWidth => MaxWidth;

	FlexLength IFlexNode.MinHeight => MinHeight;

	FlexLength IFlexNode.MaxHeight => MaxHeight;

	FlexLength IFlexNode.Basis => Basis;

	int IFlexNode.Grow => Grow;

	int IFlexNode.Shrink => Shrink;

	FlexAlignSelf IFlexNode.AlignSelf => AlignSelf;

	protected override void OnEnable()
	{
		((TextMeshProUGUI)this).OnEnable();
		((Graphic)this).SetLayoutDirty();
	}

	protected override void OnDisable()
	{
		((TextMeshProUGUI)this).OnDisable();
		((Graphic)this).SetLayoutDirty();
	}

	public override void SetLayoutDirty()
	{
		_isDirty = true;
		((TextMeshProUGUI)this).SetLayoutDirty();
		Transform parent = ((TMP_Text)this).transform.parent;
		IFlexNode flexNode = default(IFlexNode);
		if ((Object)(object)parent != (Object)null && ((Component)parent).TryGetComponent<IFlexNode>(ref flexNode) && flexNode.IsActive)
		{
			flexNode.SetLayoutDirty();
		}
	}

	void IFlexNode.SetupTransform()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		RectTransform val = (RectTransform)((TMP_Text)this).transform;
		((Transform)val).localRotation = Quaternion.identity;
		val.pivot = new Vector2(0f, 1f);
		val.anchorMin = new Vector2(0f, 1f);
		val.anchorMax = new Vector2(0f, 1f);
	}

	void IFlexNode.SetLayoutDirty(bool force)
	{
		if (force || ((UIBehaviour)this).IsActive())
		{
			((Graphic)this).SetLayoutDirty();
		}
	}

	void IFlexNode.MeasureHorizontal()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		float valueOrDefault = MaxWidth.GetValueOrDefault(float.PositiveInfinity);
		float valueOrDefault2 = MaxHeight.GetValueOrDefault(float.PositiveInfinity);
		Vector2 preferredValues = ((TMP_Text)this).GetPreferredValues(valueOrDefault, valueOrDefault2);
		_preferredWidth = Mathf.Max(Mathf.Min(preferredValues.x, valueOrDefault), MinWidth.GetValueOrDefault(0f));
		_preferredHeight = Mathf.Max(Mathf.Min(preferredValues.y, valueOrDefault2), MinHeight.GetValueOrDefault(0f));
	}

	void IFlexNode.LayoutHorizontal(float maxWidth, float maxHeight)
	{
	}

	void IFlexNode.MeasureVertical()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Vector2 sizeDelta = ((RectTransform)((TMP_Text)this).transform).sizeDelta;
		float valueOrDefault = MaxWidth.GetValueOrDefault(float.PositiveInfinity);
		float valueOrDefault2 = MaxHeight.GetValueOrDefault(float.PositiveInfinity);
		Vector2 preferredValues = ((TMP_Text)this).GetPreferredValues(sizeDelta.x, valueOrDefault2);
		_preferredWidth = Mathf.Max(Mathf.Min(preferredValues.x, valueOrDefault), MinWidth.GetValueOrDefault(0f));
		_preferredHeight = Mathf.Max(Mathf.Min(preferredValues.y, valueOrDefault2), MinHeight.GetValueOrDefault(0f));
	}

	void IFlexNode.LayoutVertical(float maxWidth, float maxHeight)
	{
		_isDirty = false;
	}

	void IFlexNode.GetScale(out float scaleX, out float scaleY)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localScale = ((Transform)(RectTransform)((TMP_Text)this).transform).localScale;
		scaleX = localScale.x;
		scaleY = localScale.y;
	}

	void IFlexNode.GetPreferredSize(out float preferredWidth, out float preferredHeight)
	{
		preferredWidth = _preferredWidth;
		preferredHeight = _preferredHeight;
	}
}


using System;
using System.Collections.Generic;
using Facepunch.Flexbox;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class FlexTransition : FacepunchBehaviour
{
	public enum TransitionProperty
	{
		PaddingLeft = 0,
		PaddingRight = 1,
		PaddingTop = 2,
		PaddingBottom = 3,
		Gap = 4,
		MinWidth = 5,
		MinHeight = 6,
		MaxWidth = 7,
		MaxHeight = 8,
		ScaleX = 100,
		ScaleY = 101,
		ImageColor = 102,
		TextColor = 103,
		CanvasAlpha = 104,
		RotationZ = 105,
		ScaleXY = 106,
		TransformTranslateX = 200,
		TransformTranslateY = 201,
		TransformScaleX = 202,
		TransformScaleY = 203,
		TransformRotate = 204
	}

	[Serializable]
	public struct Definition
	{
		public TransitionProperty Property;

		public Object Object;

		public float FromFloat;

		public float ToFloat;

		public Color FromColor;

		public Color ToColor;

		[Min(0f)]
		public float Duration;

		public LeanTweenType Ease;

		public AnimationCurve Curve;
	}

	public Definition[] Transitions;

	[SerializeField]
	private bool _playOnAwake;

	private readonly List<int> _pendingIds = new List<int>();

	private bool _currentState;

	private bool _hasSwitchedState;

	public void Awake()
	{
		if (!_hasSwitchedState)
		{
			SwitchState(enabled: false, animate: false);
		}
	}

	public void Start()
	{
		if (_playOnAwake)
		{
			PlayOneOff();
		}
	}

	public void SwitchState(bool enabled, bool animate)
	{
		_currentState = enabled;
		_hasSwitchedState = true;
		if (Transitions == null || Transitions.Length == 0)
		{
			return;
		}
		foreach (int pendingId in _pendingIds)
		{
			LeanTween.cancel(pendingId);
		}
		_pendingIds.Clear();
		for (int i = 0; i < Transitions.Length; i++)
		{
			LTDescr val = RunTransitionImpl(in Transitions[i], animate);
			if (val != null)
			{
				_pendingIds.Add(val.uniqueId);
			}
		}
	}

	public void SwitchState(bool enabled)
	{
		SwitchState(enabled, animate: true);
	}

	public void ToggleState()
	{
		SwitchState(!_currentState);
	}

	public void PlayOneOff()
	{
		_currentState = true;
		_hasSwitchedState = true;
		if (Transitions == null || Transitions.Length == 0)
		{
			return;
		}
		foreach (int pendingId in _pendingIds)
		{
			LeanTween.cancel(pendingId);
		}
		_pendingIds.Clear();
		for (int i = 0; i < Transitions.Length; i++)
		{
			LTDescr val = RunTransitionImpl(in Transitions[i], animate: true);
			if (val != null)
			{
				_pendingIds.Add(val.uniqueId);
			}
		}
	}

	public void PlayPop()
	{
		if (Transitions == null || Transitions.Length == 0)
		{
			return;
		}
		_hasSwitchedState = true;
		_currentState = true;
		foreach (int pendingId in _pendingIds)
		{
			LeanTween.cancel(pendingId);
		}
		_pendingIds.Clear();
		float num = 0f;
		for (int i = 0; i < Transitions.Length; i++)
		{
			LTDescr val = RunTransitionImpl(in Transitions[i], animate: true);
			if (val != null)
			{
				_pendingIds.Add(val.uniqueId);
				num = Mathf.Max(num, Transitions[i].Duration);
			}
		}
		((FacepunchBehaviour)this).Invoke((Action)RestoreState, num);
	}

	private void RestoreState()
	{
		SwitchState(enabled: false, animate: true);
	}

	private LTDescr RunTransitionImpl(in Definition transition, bool animate)
	{
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0816: Unknown result type (might be due to invalid IL or missing references)
		//IL_081d: Invalid comparison between Unknown and I4
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_031e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0830: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0439: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		LTDescr val = null;
		switch (transition.Property)
		{
		case TransitionProperty.ScaleX:
		{
			FlexElement flexElement5 = transition.Object as FlexElement;
			if ((Object)(object)flexElement5 == (Object)null)
			{
				break;
			}
			float num11 = (_currentState ? transition.ToFloat : transition.FromFloat);
			if (animate)
			{
				val = LeanTween.scaleX(((Component)flexElement5).gameObject, num11, transition.Duration).setOnUpdate((Action<float, object>)delegate(float value, object obj)
				{
					if (obj is FlexElement flexElement6)
					{
						flexElement6.SetLayoutDirty();
					}
				}, (object)flexElement5);
			}
			else
			{
				Vector3 localScale3 = ((Component)flexElement5).transform.localScale;
				localScale3.x = num11;
				((Component)flexElement5).transform.localScale = localScale3;
				flexElement5.SetLayoutDirty();
			}
			break;
		}
		case TransitionProperty.ScaleY:
		{
			FlexElement flexElement3 = transition.Object as FlexElement;
			if ((Object)(object)flexElement3 == (Object)null)
			{
				break;
			}
			float num9 = (_currentState ? transition.ToFloat : transition.FromFloat);
			if (animate)
			{
				val = LeanTween.scaleY(((Component)flexElement3).gameObject, num9, transition.Duration).setOnUpdate((Action<float, object>)delegate(float value, object obj)
				{
					FlexElement flexElement4 = (FlexElement)obj;
					if ((Object)(object)flexElement4 != (Object)null)
					{
						flexElement4.SetLayoutDirty();
					}
				}, (object)flexElement3);
			}
			else
			{
				Vector3 localScale2 = ((Component)flexElement3).transform.localScale;
				localScale2.y = num9;
				((Component)flexElement3).transform.localScale = localScale2;
				flexElement3.SetLayoutDirty();
			}
			break;
		}
		case TransitionProperty.ScaleXY:
		{
			FlexElement flexElement = transition.Object as FlexElement;
			if ((Object)(object)flexElement == (Object)null)
			{
				break;
			}
			float num3 = (_currentState ? transition.ToFloat : transition.FromFloat);
			if (animate)
			{
				val = LeanTween.scale(((Component)flexElement).gameObject, new Vector3(num3, num3, ((Component)flexElement).transform.localScale.z), transition.Duration).setOnUpdate((Action<Vector3, object>)delegate(Vector3 value, object obj)
				{
					if (obj is FlexElement flexElement2)
					{
						flexElement2.SetLayoutDirty();
					}
				}, (object)flexElement);
			}
			else
			{
				Vector3 localScale = ((Component)flexElement).transform.localScale;
				localScale.x = num3;
				localScale.y = num3;
				((Component)flexElement).transform.localScale = localScale;
				flexElement.SetLayoutDirty();
			}
			break;
		}
		case TransitionProperty.ImageColor:
		{
			Object @object = transition.Object;
			Image val2 = (Image)(object)((@object is Image) ? @object : null);
			if ((Object)(object)val2 == (Object)null)
			{
				break;
			}
			Color color = ((Graphic)val2).color;
			Color val3 = (_currentState ? transition.ToColor : transition.FromColor);
			if (animate)
			{
				val = LeanTween.value(((Component)val2).gameObject, color, val3, transition.Duration).setOnUpdateParam((object)val2).setOnUpdateColor((Action<Color, object>)delegate(Color value, object obj)
				{
					//IL_000b: Unknown result type (might be due to invalid IL or missing references)
					Image val4 = (Image)((obj is Image) ? obj : null);
					if (val4 != null)
					{
						((Graphic)val4).color = value;
					}
				});
			}
			else
			{
				((Graphic)val2).color = val3;
			}
			break;
		}
		case TransitionProperty.TextColor:
		{
			Object object4 = transition.Object;
			TMP_Text val7 = (TMP_Text)(object)((object4 is TMP_Text) ? object4 : null);
			if ((Object)(object)val7 == (Object)null)
			{
				break;
			}
			Color color2 = ((Graphic)val7).color;
			Color val8 = (_currentState ? transition.ToColor : transition.FromColor);
			if (animate)
			{
				val = LeanTween.value(((Component)val7).gameObject, color2, val8, transition.Duration).setOnUpdateParam((object)val7).setOnUpdateColor((Action<Color, object>)delegate(Color value, object state)
				{
					//IL_000b: Unknown result type (might be due to invalid IL or missing references)
					TMP_Text val9 = (TMP_Text)((state is TMP_Text) ? state : null);
					if (val9 != null)
					{
						((Graphic)val9).color = value;
					}
				});
			}
			else
			{
				((Graphic)val7).color = val8;
			}
			break;
		}
		case TransitionProperty.CanvasAlpha:
		{
			Object object2 = transition.Object;
			CanvasGroup val5 = (CanvasGroup)(object)((object2 is CanvasGroup) ? object2 : null);
			if (!((Object)(object)val5 == (Object)null))
			{
				float num6 = (_currentState ? transition.ToFloat : transition.FromFloat);
				if (animate)
				{
					val = LeanTween.alphaCanvas(val5, num6, transition.Duration).setEase(transition.Ease);
				}
				else
				{
					val5.alpha = num6;
				}
			}
			break;
		}
		case TransitionProperty.RotationZ:
		{
			Object object3 = transition.Object;
			Transform val6 = (Transform)(object)((object3 is Transform) ? object3 : null);
			if (!((Object)(object)val6 == (Object)null))
			{
				float num8 = (_currentState ? transition.ToFloat : transition.FromFloat);
				if (animate)
				{
					val = LeanTween.rotateZ(((Component)val6).gameObject, num8, transition.Duration);
					break;
				}
				Vector3 eulerAngles = val6.eulerAngles;
				eulerAngles.z = num8;
				val6.localEulerAngles = eulerAngles;
			}
			break;
		}
		case TransitionProperty.TransformTranslateX:
		{
			FlexGraphicTransform flexGraphicTransform = transition.Object as FlexGraphicTransform;
			if ((Object)(object)flexGraphicTransform == (Object)null)
			{
				break;
			}
			float translateX = flexGraphicTransform.TranslateX;
			float num2 = (_currentState ? transition.ToFloat : transition.FromFloat);
			if (animate)
			{
				val = LeanTween.value(((Component)flexGraphicTransform).gameObject, translateX, num2, transition.Duration).setOnUpdateParam((object)flexGraphicTransform).setOnUpdateObject((Action<float, object>)delegate(float value, object state)
				{
					if (state is FlexGraphicTransform flexGraphicTransform2)
					{
						flexGraphicTransform2.TranslateX = value;
						flexGraphicTransform2.SetVerticesDirty();
					}
				});
			}
			else
			{
				flexGraphicTransform.TranslateX = num2;
				flexGraphicTransform.SetVerticesDirty();
			}
			break;
		}
		case TransitionProperty.TransformTranslateY:
		{
			FlexGraphicTransform flexGraphicTransform9 = transition.Object as FlexGraphicTransform;
			if ((Object)(object)flexGraphicTransform9 == (Object)null)
			{
				break;
			}
			float translateY = flexGraphicTransform9.TranslateY;
			float num10 = (_currentState ? transition.ToFloat : transition.FromFloat);
			if (animate)
			{
				val = LeanTween.value(((Component)flexGraphicTransform9).gameObject, translateY, num10, transition.Duration).setOnUpdateParam((object)flexGraphicTransform9).setOnUpdateObject((Action<float, object>)delegate(float value, object state)
				{
					if (state is FlexGraphicTransform flexGraphicTransform10)
					{
						flexGraphicTransform10.TranslateY = value;
						flexGraphicTransform10.SetVerticesDirty();
					}
				});
			}
			else
			{
				flexGraphicTransform9.TranslateY = num10;
				flexGraphicTransform9.SetVerticesDirty();
			}
			break;
		}
		case TransitionProperty.TransformScaleX:
		{
			FlexGraphicTransform flexGraphicTransform5 = transition.Object as FlexGraphicTransform;
			if ((Object)(object)flexGraphicTransform5 == (Object)null)
			{
				break;
			}
			float scaleX = flexGraphicTransform5.ScaleX;
			float num5 = (_currentState ? transition.ToFloat : transition.FromFloat);
			if (animate)
			{
				val = LeanTween.value(((Component)flexGraphicTransform5).gameObject, scaleX, num5, transition.Duration).setOnUpdateParam((object)flexGraphicTransform5).setOnUpdateObject((Action<float, object>)delegate(float value, object state)
				{
					if (state is FlexGraphicTransform flexGraphicTransform6)
					{
						flexGraphicTransform6.ScaleX = value;
						flexGraphicTransform6.SetVerticesDirty();
					}
				});
			}
			else
			{
				flexGraphicTransform5.ScaleX = num5;
				flexGraphicTransform5.SetVerticesDirty();
			}
			break;
		}
		case TransitionProperty.TransformScaleY:
		{
			FlexGraphicTransform flexGraphicTransform3 = transition.Object as FlexGraphicTransform;
			if ((Object)(object)flexGraphicTransform3 == (Object)null)
			{
				break;
			}
			float scaleY = flexGraphicTransform3.ScaleY;
			float num4 = (_currentState ? transition.ToFloat : transition.FromFloat);
			if (animate)
			{
				val = LeanTween.value(((Component)flexGraphicTransform3).gameObject, scaleY, num4, transition.Duration).setOnUpdateParam((object)flexGraphicTransform3).setOnUpdateObject((Action<float, object>)delegate(float value, object state)
				{
					if (state is FlexGraphicTransform flexGraphicTransform4)
					{
						flexGraphicTransform4.ScaleY = value;
						flexGraphicTransform4.SetVerticesDirty();
					}
				});
			}
			else
			{
				flexGraphicTransform3.ScaleY = num4;
				flexGraphicTransform3.SetVerticesDirty();
			}
			break;
		}
		case TransitionProperty.TransformRotate:
		{
			FlexGraphicTransform flexGraphicTransform7 = transition.Object as FlexGraphicTransform;
			if ((Object)(object)flexGraphicTransform7 == (Object)null)
			{
				break;
			}
			float rotate = flexGraphicTransform7.Rotate;
			float num7 = (_currentState ? transition.ToFloat : transition.FromFloat);
			if (animate)
			{
				val = LeanTween.value(((Component)flexGraphicTransform7).gameObject, rotate, num7, transition.Duration).setOnUpdateParam((object)flexGraphicTransform7).setOnUpdateObject((Action<float, object>)delegate(float value, object state)
				{
					if (state is FlexGraphicTransform flexGraphicTransform8)
					{
						flexGraphicTransform8.Rotate = value;
						flexGraphicTransform8.SetVerticesDirty();
					}
				});
			}
			else
			{
				flexGraphicTransform7.Rotate = num7;
				flexGraphicTransform7.SetVerticesDirty();
			}
			break;
		}
		default:
		{
			FlexElement element = transition.Object as FlexElement;
			if ((Object)(object)element == (Object)null)
			{
				break;
			}
			TransitionProperty property = transition.Property;
			float num = (_currentState ? transition.ToFloat : transition.FromFloat);
			if (animate)
			{
				val = LeanTween.value(((Component)element).gameObject, Property(element, property), num, transition.Duration).setOnUpdate((Action<float, object>)delegate(float newValue, object _)
				{
					if ((Object)(object)element != (Object)null)
					{
						Property(element, property) = newValue;
						element.SetLayoutDirty();
					}
				}, (object)this);
			}
			else
			{
				Property(element, property) = num;
				element.SetLayoutDirty();
			}
			break;
		}
		}
		if (val != null)
		{
			if ((int)transition.Ease == 38)
			{
				val.setEase(transition.Curve);
			}
			else
			{
				val.setEase(transition.Ease);
			}
		}
		return val;
	}

	private static ref float Property(FlexElement element, TransitionProperty property)
	{
		return property switch
		{
			TransitionProperty.PaddingLeft => ref element.Padding.left, 
			TransitionProperty.PaddingRight => ref element.Padding.right, 
			TransitionProperty.PaddingTop => ref element.Padding.top, 
			TransitionProperty.PaddingBottom => ref element.Padding.bottom, 
			TransitionProperty.Gap => ref element.Gap, 
			TransitionProperty.MinWidth => ref element.MinWidth.Value, 
			TransitionProperty.MinHeight => ref element.MinHeight.Value, 
			TransitionProperty.MaxWidth => ref element.MaxWidth.Value, 
			TransitionProperty.MaxHeight => ref element.MaxHeight.Value, 
			_ => throw new NotSupportedException(string.Format("{0} {1}", "TransitionProperty", property)), 
		};
	}

	public float GetTransitionTime()
	{
		float num = 0f;
		Definition[] transitions = Transitions;
		for (int i = 0; i < transitions.Length; i++)
		{
			Definition definition = transitions[i];
			if (definition.Duration > num)
			{
				num = definition.Duration;
			}
		}
		return num;
	}
}


using System;

[Serializable]
public struct FlexValue
{
	public bool HasValue;

	public float Value;

	public float GetOrDefault(float defaultValue)
	{
		if (!HasValue)
		{
			return defaultValue;
		}
		return Value;
	}
}


using Facepunch.Flexbox;
using UnityEngine;

public interface IFlexNode
{
	RectTransform Transform { get; }

	bool IsActive { get; }

	bool IsAbsolute { get; }

	bool IsDirty { get; }

	FlexLength MinWidth { get; }

	FlexLength MaxWidth { get; }

	FlexLength MinHeight { get; }

	FlexLength MaxHeight { get; }

	int Grow { get; }

	int Shrink { get; }

	FlexLength Basis { get; }

	FlexAlignSelf AlignSelf { get; }

	void SetupTransform();

	void SetLayoutDirty(bool force = false);

	void MeasureHorizontal();

	void LayoutHorizontal(float maxWidth, float maxHeight);

	void MeasureVertical();

	void LayoutVertical(float maxWidth, float maxHeight);

	void GetScale(out float scaleX, out float scaleY);

	void GetPreferredSize(out float preferredWidth, out float preferredHeight);
}


using UnityEngine;

public static class FlexUtility
{
	public static bool IsPrefabRoot(GameObject gameObject)
	{
		return false;
	}
}


private struct MonoScriptData
{
	public byte[] FilePathsData;

	public byte[] TypesData;

	public int TotalTypes;

	public int TotalFiles;

	public bool IsEditorOnly;
}


private struct ColumnParameters
{
	public float Height;

	public float Offset;
}


private struct ChildSizingParameters
{
	public float Size;

	public float MinSize;

	public float MaxSize;

	public bool IsFlexible;

	public float Scale;
}


public enum TransitionProperty
{
	PaddingLeft = 0,
	PaddingRight = 1,
	PaddingTop = 2,
	PaddingBottom = 3,
	Gap = 4,
	MinWidth = 5,
	MinHeight = 6,
	MaxWidth = 7,
	MaxHeight = 8,
	ScaleX = 100,
	ScaleY = 101,
	ImageColor = 102,
	TextColor = 103,
	CanvasAlpha = 104,
	RotationZ = 105,
	ScaleXY = 106,
	TransformTranslateX = 200,
	TransformTranslateY = 201,
	TransformScaleX = 202,
	TransformScaleY = 203,
	TransformRotate = 204
}


using System;
using UnityEngine;

[Serializable]
public struct Definition
{
	public TransitionProperty Property;

	public Object Object;

	public float FromFloat;

	public float ToFloat;

	public Color FromColor;

	public Color ToColor;

	[Min(0f)]
	public float Duration;

	public LeanTweenType Ease;

	public AnimationCurve Curve;
}


