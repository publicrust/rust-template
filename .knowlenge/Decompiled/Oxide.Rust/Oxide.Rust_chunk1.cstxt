using Oxide.Plugins;

public static class RustExtensionMethods
{
	public static bool IsSteamId(this EncryptedValue<ulong> userID)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return ExtensionMethods.IsSteamId(EncryptedValue<ulong>.op_Implicit(userID));
	}
}


using System;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Libraries;
using Oxide.Plugins;
using UnityEngine;

public abstract class RustPlugin : CSharpPlugin
{
	protected Command cmd = Interface.Oxide.GetLibrary<Command>((string)null);

	protected Rust rust = Interface.Oxide.GetLibrary<Rust>((string)null);

	protected Item Item = Interface.Oxide.GetLibrary<Item>((string)null);

	protected Player Player = Interface.Oxide.GetLibrary<Player>((string)null);

	protected Server Server = Interface.Oxide.GetLibrary<Server>((string)null);

	public override void HandleAddedToManager(PluginManager manager)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Expected O, but got Unknown
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		FieldInfo[] fields = ((object)this).GetType().GetFields(BindingFlags.Instance | BindingFlags.NonPublic);
		foreach (FieldInfo fieldInfo in fields)
		{
			if (fieldInfo.GetCustomAttributes(typeof(OnlinePlayersAttribute), inherit: true).Length != 0)
			{
				PluginFieldInfo val = new PluginFieldInfo((Plugin)(object)this, fieldInfo);
				if (val.GenericArguments.Length != 2 || val.GenericArguments[0] != typeof(BasePlayer))
				{
					((CSharpPlugin)this).Puts("The " + fieldInfo.Name + " field is not a Hash with a BasePlayer key! (online players will not be tracked)", Array.Empty<object>());
				}
				else if (!val.LookupMethod("Add", val.GenericArguments))
				{
					((CSharpPlugin)this).Puts("The " + fieldInfo.Name + " field does not support adding BasePlayer keys! (online players will not be tracked)", Array.Empty<object>());
				}
				else if (!val.LookupMethod("Remove", new Type[1] { typeof(BasePlayer) }))
				{
					((CSharpPlugin)this).Puts("The " + fieldInfo.Name + " field does not support removing BasePlayer keys! (online players will not be tracked)", Array.Empty<object>());
				}
				else if (val.GenericArguments[1].GetField("Player") == null)
				{
					((CSharpPlugin)this).Puts("The " + val.GenericArguments[1].Name + " class does not have a public Player field! (online players will not be tracked)", Array.Empty<object>());
				}
				else if (!val.HasValidConstructor(new Type[1] { typeof(BasePlayer) }))
				{
					((CSharpPlugin)this).Puts("The " + fieldInfo.Name + " field is using a class which contains no valid constructor (online players will not be tracked)", Array.Empty<object>());
				}
				else
				{
					base.onlinePlayerFields.Add(val);
				}
			}
		}
		MethodInfo[] methods = ((object)this).GetType().GetMethods(BindingFlags.Instance | BindingFlags.NonPublic);
		foreach (MethodInfo methodInfo in methods)
		{
			object[] customAttributes = methodInfo.GetCustomAttributes(typeof(ConsoleCommandAttribute), inherit: true);
			if (customAttributes.Length != 0)
			{
				object obj = customAttributes[0];
				ConsoleCommandAttribute val2 = (ConsoleCommandAttribute)((obj is ConsoleCommandAttribute) ? obj : null);
				if (val2 != null)
				{
					cmd.AddConsoleCommand(val2.Command, (Plugin)(object)this, methodInfo.Name);
				}
				continue;
			}
			customAttributes = methodInfo.GetCustomAttributes(typeof(ChatCommandAttribute), inherit: true);
			if (customAttributes.Length != 0)
			{
				object obj2 = customAttributes[0];
				ChatCommandAttribute val3 = (ChatCommandAttribute)((obj2 is ChatCommandAttribute) ? obj2 : null);
				if (val3 != null)
				{
					cmd.AddChatCommand(val3.Command, (Plugin)(object)this, methodInfo.Name);
				}
			}
		}
		if (base.onlinePlayerFields.Count > 0)
		{
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					AddOnlinePlayer(current);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		((CSharpPlugin)this).HandleAddedToManager(manager);
	}

	[HookMethod("OnPlayerConnected")]
	private void base_OnPlayerConnected(BasePlayer player)
	{
		AddOnlinePlayer(player);
	}

	[HookMethod("OnPlayerDisconnected")]
	private void base_OnPlayerDisconnected(BasePlayer player, string reason)
	{
		((CSharpPlugin)this).NextTick((Action)delegate
		{
			foreach (PluginFieldInfo onlinePlayerField in base.onlinePlayerFields)
			{
				onlinePlayerField.Call("Remove", new object[1] { player });
			}
		});
	}

	private void AddOnlinePlayer(BasePlayer player)
	{
		foreach (PluginFieldInfo onlinePlayerField in base.onlinePlayerFields)
		{
			Type type = onlinePlayerField.GenericArguments[1];
			object obj = ((type.GetConstructor(new Type[1] { typeof(BasePlayer) }) == null) ? Activator.CreateInstance(type) : Activator.CreateInstance(type, player));
			type.GetField("Player").SetValue(obj, player);
			onlinePlayerField.Call("Add", new object[2] { player, obj });
		}
	}

	protected void PrintToConsole(BasePlayer player, string format, params object[] args)
	{
		if (((BaseNetworkable)(player?)).net != null)
		{
			player.SendConsoleCommand("echo " + ((args.Length != 0) ? string.Format(format, args) : format), Array.Empty<object>());
		}
	}

	protected void PrintToConsole(string format, params object[] args)
	{
		if (BasePlayer.activePlayerList.Count >= 1)
		{
			ConsoleNetwork.BroadcastToAllClients("echo " + ((args.Length != 0) ? string.Format(format, args) : format), Array.Empty<object>());
		}
	}

	protected void PrintToChat(BasePlayer player, string format, params object[] args)
	{
		if (((BaseNetworkable)(player?)).net != null)
		{
			player.SendConsoleCommand("chat.add", new object[3]
			{
				2,
				0,
				(args.Length != 0) ? string.Format(format, args) : format
			});
		}
	}

	protected void PrintToChat(string format, params object[] args)
	{
		if (BasePlayer.activePlayerList.Count >= 1)
		{
			ConsoleNetwork.BroadcastToAllClients("chat.add", new object[3]
			{
				2,
				0,
				(args.Length != 0) ? string.Format(format, args) : format
			});
		}
	}

	protected void SendReply(Arg arg, string format, params object[] args)
	{
		MonoBehaviour obj = arg.Connection?.player;
		BasePlayer val = (BasePlayer)(object)((obj is BasePlayer) ? obj : null);
		string text = ((args.Length != 0) ? string.Format(format, args) : format);
		if (((BaseNetworkable)(val?)).net != null)
		{
			val.SendConsoleCommand("echo " + text, Array.Empty<object>());
		}
		else
		{
			((CSharpPlugin)this).Puts(text, Array.Empty<object>());
		}
	}

	protected void SendReply(BasePlayer player, string format, params object[] args)
	{
		PrintToChat(player, format, args);
	}

	protected void SendWarning(Arg arg, string format, params object[] args)
	{
		MonoBehaviour obj = arg.Connection?.player;
		BasePlayer val = (BasePlayer)(object)((obj is BasePlayer) ? obj : null);
		string text = ((args.Length != 0) ? string.Format(format, args) : format);
		if (((BaseNetworkable)(val?)).net != null)
		{
			val.SendConsoleCommand("echo " + text, Array.Empty<object>());
		}
		else
		{
			Debug.LogWarning((object)text);
		}
	}

	protected void SendError(Arg arg, string format, params object[] args)
	{
		MonoBehaviour obj = arg.Connection?.player;
		BasePlayer val = (BasePlayer)(object)((obj is BasePlayer) ? obj : null);
		string text = ((args.Length != 0) ? string.Format(format, args) : format);
		if (((BaseNetworkable)(val?)).net != null)
		{
			val.SendConsoleCommand("echo " + text, Array.Empty<object>());
		}
		else
		{
			Debug.LogError((object)text);
		}
	}

	protected void ForcePlayerPosition(BasePlayer player, Vector3 destination)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		player.MovePosition(destination);
		if (!player.IsSpectating() || (double)Vector3.Distance(((Component)player).transform.position, destination) > 25.0)
		{
			((BaseEntity)player).ClientRPC(RpcTarget.Player("ForcePositionTo", player), destination);
		}
		else
		{
			((BaseNetworkable)player).SendNetworkUpdate((NetworkQueue)1);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Extensions;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Core.RemoteConsole;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Libraries;
using Oxide.Game.Rust.Libraries.Covalence;
using Rust.Ai.Gen2;
using Steamworks;
using UnityEngine;

public class RustCore : CSPlugin
{
	internal readonly Command cmdlib = Interface.Oxide.GetLibrary<Command>((string)null);

	internal readonly Lang lang = Interface.Oxide.GetLibrary<Lang>((string)null);

	internal readonly Permission permission = Interface.Oxide.GetLibrary<Permission>((string)null);

	internal readonly Player Player = Interface.Oxide.GetLibrary<Player>((string)null);

	internal static readonly RustCovalenceProvider Covalence = RustCovalenceProvider.Instance;

	internal readonly PluginManager pluginManager = Interface.Oxide.RootPluginManager;

	internal readonly IServer Server = Covalence.CreateServer();

	internal readonly RustExtension Extension;

	internal bool serverInitialized;

	internal bool isPlayerTakingDamage;

	internal static string ipPattern = ":{1}[0-9]{1}\\d*";

	private static readonly DateTime Eoy = new DateTime(2025, 12, 31);

	internal static IEnumerable<string> RestrictedCommands => new string[4] { "ownerid", "moderatorid", "removeowner", "removemoderator" };

	[HookMethod("GrantCommand")]
	private void GrantCommand(IPlayer player, string command, string[] args)
	{
		if (!PermissionsLoaded(player))
		{
			return;
		}
		if (args.Length < 3)
		{
			player.Reply(lang.GetMessage("CommandUsageGrant", (Plugin)(object)this, player.Id));
			return;
		}
		string text = args[0];
		string text2 = ExtensionMethods.Sanitize(args[1]);
		string text3 = args[2];
		if (!permission.PermissionExists(text3, (Plugin)null))
		{
			player.Reply(string.Format(lang.GetMessage("PermissionNotFound", (Plugin)(object)this, player.Id), text3));
		}
		else if (text.Equals("group"))
		{
			if (!permission.GroupExists(text2))
			{
				player.Reply(string.Format(lang.GetMessage("GroupNotFound", (Plugin)(object)this, player.Id), text2));
				return;
			}
			if (permission.GroupHasPermission(text2, text3))
			{
				player.Reply(string.Format(lang.GetMessage("GroupAlreadyHasPermission", (Plugin)(object)this, player.Id), text2, text3));
				return;
			}
			permission.GrantGroupPermission(text2, text3, (Plugin)null);
			player.Reply(string.Format(lang.GetMessage("GroupPermissionGranted", (Plugin)(object)this, player.Id), text2, text3));
		}
		else if (text.Equals("user"))
		{
			IPlayer[] array = Covalence.PlayerManager.FindPlayers(text2).ToArray();
			if (array.Length > 1)
			{
				player.Reply(string.Format(lang.GetMessage("PlayersFound", (Plugin)(object)this, player.Id), string.Join(", ", array.Select((IPlayer p) => p.Name).ToArray())));
				return;
			}
			IPlayer val = ((array.Length == 1) ? array[0] : null);
			if (val == null && !permission.UserIdValid(text2))
			{
				player.Reply(string.Format(lang.GetMessage("PlayerNotFound", (Plugin)(object)this, player.Id), text2));
				return;
			}
			string text4 = text2;
			if (val != null)
			{
				text4 = val.Id;
				text2 = val.Name;
				permission.UpdateNickname(text4, text2);
			}
			if (permission.UserHasPermission(text2, text3))
			{
				player.Reply(string.Format(lang.GetMessage("PlayerAlreadyHasPermission", (Plugin)(object)this, player.Id), text4, text3));
				return;
			}
			permission.GrantUserPermission(text4, text3, (Plugin)null);
			player.Reply(string.Format(lang.GetMessage("PlayerPermissionGranted", (Plugin)(object)this, player.Id), text2 + " (" + text4 + ")", text3));
		}
		else
		{
			player.Reply(lang.GetMessage("CommandUsageGrant", (Plugin)(object)this, player.Id));
		}
	}

	[HookMethod("GroupCommand")]
	private void GroupCommand(IPlayer player, string command, string[] args)
	{
		if (!PermissionsLoaded(player))
		{
			return;
		}
		if (args.Length < 2)
		{
			player.Reply(lang.GetMessage("CommandUsageGroup", (Plugin)(object)this, player.Id));
			player.Reply(lang.GetMessage("CommandUsageGroupParent", (Plugin)(object)this, player.Id));
			player.Reply(lang.GetMessage("CommandUsageGroupRemove", (Plugin)(object)this, player.Id));
			return;
		}
		string text = args[0];
		string text2 = args[1];
		string text3 = ((args.Length >= 3) ? args[2] : "");
		int num = ((args.Length == 4) ? int.Parse(args[3]) : 0);
		if (text.Equals("add"))
		{
			if (permission.GroupExists(text2))
			{
				player.Reply(string.Format(lang.GetMessage("GroupAlreadyExists", (Plugin)(object)this, player.Id), text2));
				return;
			}
			permission.CreateGroup(text2, text3, num);
			player.Reply(string.Format(lang.GetMessage("GroupCreated", (Plugin)(object)this, player.Id), text2));
		}
		else if (text.Equals("remove"))
		{
			if (!permission.GroupExists(text2))
			{
				player.Reply(string.Format(lang.GetMessage("GroupNotFound", (Plugin)(object)this, player.Id), text2));
				return;
			}
			permission.RemoveGroup(text2);
			player.Reply(string.Format(lang.GetMessage("GroupDeleted", (Plugin)(object)this, player.Id), text2));
		}
		else if (text.Equals("set"))
		{
			if (!permission.GroupExists(text2))
			{
				player.Reply(string.Format(lang.GetMessage("GroupNotFound", (Plugin)(object)this, player.Id), text2));
				return;
			}
			permission.SetGroupTitle(text2, text3);
			permission.SetGroupRank(text2, num);
			player.Reply(string.Format(lang.GetMessage("GroupChanged", (Plugin)(object)this, player.Id), text2));
		}
		else if (text.Equals("parent"))
		{
			if (args.Length <= 2)
			{
				player.Reply(lang.GetMessage("CommandUsageGroupParent", (Plugin)(object)this, player.Id));
				return;
			}
			if (!permission.GroupExists(text2))
			{
				player.Reply(string.Format(lang.GetMessage("GroupNotFound", (Plugin)(object)this, player.Id), text2));
				return;
			}
			string text4 = args[2];
			if (!string.IsNullOrEmpty(text4) && !permission.GroupExists(text4))
			{
				player.Reply(string.Format(lang.GetMessage("GroupParentNotFound", (Plugin)(object)this, player.Id), text4));
			}
			else if (permission.SetGroupParent(text2, text4))
			{
				player.Reply(string.Format(lang.GetMessage("GroupParentChanged", (Plugin)(object)this, player.Id), text2, text4));
			}
			else
			{
				player.Reply(string.Format(lang.GetMessage("GroupParentNotChanged", (Plugin)(object)this, player.Id), text2));
			}
		}
		else
		{
			player.Reply(lang.GetMessage("CommandUsageGroup", (Plugin)(object)this, player.Id));
			player.Reply(lang.GetMessage("CommandUsageGroupParent", (Plugin)(object)this, player.Id));
			player.Reply(lang.GetMessage("CommandUsageGroupRemove", (Plugin)(object)this, player.Id));
		}
	}

	[HookMethod("LangCommand")]
	private void LangCommand(IPlayer player, string command, string[] args)
	{
		if (args.Length < 1)
		{
			player.Reply(lang.GetMessage("CommandUsageLang", (Plugin)(object)this, player.Id));
			return;
		}
		string text = args[0];
		try
		{
			text = new CultureInfo(text)?.TwoLetterISOLanguageName;
		}
		catch (CultureNotFoundException)
		{
			player.Reply(lang.GetMessage("InvalidLanguageName", (Plugin)(object)this, player.Id), text, Array.Empty<object>());
			return;
		}
		if (player.IsServer)
		{
			lang.SetServerLanguage(text);
			player.Reply(string.Format(lang.GetMessage("ServerLanguage", (Plugin)(object)this, player.Id), lang.GetServerLanguage()));
		}
		else
		{
			lang.SetLanguage(text, player.Id);
			player.Reply(string.Format(lang.GetMessage("PlayerLanguage", (Plugin)(object)this, player.Id), text));
		}
	}

	[HookMethod("LoadCommand")]
	private void LoadCommand(IPlayer player, string command, string[] args)
	{
		if (args.Length < 1)
		{
			player.Reply(lang.GetMessage("CommandUsageLoad", (Plugin)(object)this, player.Id));
			return;
		}
		if (args[0].Equals("*") || args[0].Equals("all"))
		{
			Interface.Oxide.LoadAllPlugins(false);
			return;
		}
		foreach (string text in args)
		{
			if (!string.IsNullOrEmpty(text))
			{
				Interface.Oxide.LoadPlugin(text);
				pluginManager.GetPlugin(text);
			}
		}
	}

	[HookMethod("PluginsCommand")]
	private void PluginsCommand(IPlayer player)
	{
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		Plugin[] array = (from pl in pluginManager.GetPlugins()
			where !pl.IsCorePlugin
			select pl).ToArray();
		HashSet<string> second = new HashSet<string>(array.Select((Plugin pl) => pl.Name));
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		foreach (PluginLoader pluginLoader in Interface.Oxide.GetPluginLoaders())
		{
			foreach (string item in pluginLoader.ScanDirectory(Interface.Oxide.PluginDirectory).Except(second))
			{
				dictionary[item] = (pluginLoader.PluginErrors.TryGetValue(item, out var value) ? value : "Unloaded");
			}
		}
		if (array.Length + dictionary.Count < 1)
		{
			player.Reply(lang.GetMessage("NoPluginsFound", (Plugin)(object)this, player.Id));
			return;
		}
		string text = $"Listing {array.Length + dictionary.Count} plugins:";
		int num = 1;
		foreach (Plugin item2 in array.Where((Plugin p) => p.Filename != null))
		{
			text += $"\n  {num++:00} \"{item2.Title}\" ({item2.Version}) by {item2.Author} ({item2.TotalHookTime:0.00}s / {FormatBytes(item2.TotalHookMemory)}) - {ExtensionMethods.Basename(item2.Filename, (string)null)}";
		}
		foreach (string key in dictionary.Keys)
		{
			text += $"\n  {num++:00} {key} - {dictionary[key]}";
		}
		player.Reply(text);
	}

	private static string FormatBytes(long bytes)
	{
		if (bytes < 1024)
		{
			return $"{bytes:0} B";
		}
		if (bytes < 1048576)
		{
			return $"{bytes / 1024:0} KB";
		}
		if (bytes < 1073741824)
		{
			return $"{bytes / 1048576:0} MB";
		}
		return $"{bytes / 1073741824:0} GB";
	}

	[HookMethod("ReloadCommand")]
	private void ReloadCommand(IPlayer player, string command, string[] args)
	{
		if (args.Length < 1)
		{
			player.Reply(lang.GetMessage("CommandUsageReload", (Plugin)(object)this, player.Id));
			return;
		}
		if (args[0].Equals("*") || args[0].Equals("all"))
		{
			Interface.Oxide.ReloadAllPlugins((IList<string>)null);
			return;
		}
		foreach (string text in args)
		{
			if (!string.IsNullOrEmpty(text))
			{
				Interface.Oxide.ReloadPlugin(text);
			}
		}
	}

	[HookMethod("RevokeCommand")]
	private void RevokeCommand(IPlayer player, string command, string[] args)
	{
		if (!PermissionsLoaded(player))
		{
			return;
		}
		if (args.Length < 3)
		{
			player.Reply(lang.GetMessage("CommandUsageRevoke", (Plugin)(object)this, player.Id));
			return;
		}
		string text = args[0];
		string text2 = ExtensionMethods.Sanitize(args[1]);
		string text3 = args[2];
		if (text.Equals("group"))
		{
			if (!permission.GroupExists(text2))
			{
				player.Reply(string.Format(lang.GetMessage("GroupNotFound", (Plugin)(object)this, player.Id), text2));
				return;
			}
			if (!permission.GroupHasPermission(text2, text3))
			{
				player.Reply(string.Format(lang.GetMessage("GroupDoesNotHavePermission", (Plugin)(object)this, player.Id), text2, text3));
				return;
			}
			permission.RevokeGroupPermission(text2, text3);
			player.Reply(string.Format(lang.GetMessage("GroupPermissionRevoked", (Plugin)(object)this, player.Id), text2, text3));
		}
		else if (text.Equals("user"))
		{
			IPlayer[] array = Covalence.PlayerManager.FindPlayers(text2).ToArray();
			if (array.Length > 1)
			{
				player.Reply(string.Format(lang.GetMessage("PlayersFound", (Plugin)(object)this, player.Id), string.Join(", ", array.Select((IPlayer p) => p.Name).ToArray())));
				return;
			}
			IPlayer val = ((array.Length == 1) ? array[0] : null);
			if (val == null && !permission.UserIdValid(text2))
			{
				player.Reply(string.Format(lang.GetMessage("PlayerNotFound", (Plugin)(object)this, player.Id), text2));
				return;
			}
			string text4 = text2;
			if (val != null)
			{
				text4 = val.Id;
				text2 = val.Name;
				permission.UpdateNickname(text4, text2);
			}
			if (!permission.UserHasPermission(text4, text3))
			{
				player.Reply(string.Format(lang.GetMessage("PlayerDoesNotHavePermission", (Plugin)(object)this, player.Id), text2, text3));
				return;
			}
			permission.RevokeUserPermission(text4, text3);
			player.Reply(string.Format(lang.GetMessage("PlayerPermissionRevoked", (Plugin)(object)this, player.Id), text2 + " (" + text4 + ")", text3));
		}
		else
		{
			player.Reply(lang.GetMessage("CommandUsageRevoke", (Plugin)(object)this, player.Id));
		}
	}

	[HookMethod("ShowCommand")]
	private void ShowCommand(IPlayer player, string command, string[] args)
	{
		if (!PermissionsLoaded(player))
		{
			return;
		}
		if (args.Length < 1)
		{
			player.Reply(lang.GetMessage("CommandUsageShow", (Plugin)(object)this, player.Id));
			player.Reply(lang.GetMessage("CommandUsageShowName", (Plugin)(object)this, player.Id));
			return;
		}
		string text = args[0];
		string text2 = ((args.Length == 2) ? ExtensionMethods.Sanitize(args[1]) : string.Empty);
		if (text.Equals("perms"))
		{
			player.Reply(string.Format(lang.GetMessage("Permissions", (Plugin)(object)this, player.Id) + ":\n" + string.Join(", ", permission.GetPermissions())));
		}
		else if (text.Equals("perm"))
		{
			if (args.Length < 2 || string.IsNullOrEmpty(text2))
			{
				player.Reply(lang.GetMessage("CommandUsageShow", (Plugin)(object)this, player.Id));
				player.Reply(lang.GetMessage("CommandUsageShowName", (Plugin)(object)this, player.Id));
				return;
			}
			string[] permissionUsers = permission.GetPermissionUsers(text2);
			string[] permissionGroups = permission.GetPermissionGroups(text2);
			string text3 = string.Format(lang.GetMessage("PermissionPlayers", (Plugin)(object)this, player.Id), text2) + ":\n";
			text3 += ((permissionUsers.Length != 0) ? string.Join(", ", permissionUsers) : lang.GetMessage("NoPermissionPlayers", (Plugin)(object)this, player.Id));
			text3 = text3 + "\n\n" + string.Format(lang.GetMessage("PermissionGroups", (Plugin)(object)this, player.Id), text2) + ":\n";
			text3 += ((permissionGroups.Length != 0) ? string.Join(", ", permissionGroups) : lang.GetMessage("NoPermissionGroups", (Plugin)(object)this, player.Id));
			player.Reply(text3);
		}
		else if (text.Equals("user"))
		{
			if (args.Length < 2 || string.IsNullOrEmpty(text2))
			{
				player.Reply(lang.GetMessage("CommandUsageShow", (Plugin)(object)this, player.Id));
				player.Reply(lang.GetMessage("CommandUsageShowName", (Plugin)(object)this, player.Id));
				return;
			}
			IPlayer[] array = Covalence.PlayerManager.FindPlayers(text2).ToArray();
			if (array.Length > 1)
			{
				player.Reply(string.Format(lang.GetMessage("PlayersFound", (Plugin)(object)this, player.Id), string.Join(", ", array.Select((IPlayer p) => p.Name).ToArray())));
				return;
			}
			IPlayer val = ((array.Length == 1) ? array[0] : null);
			if (val == null && !permission.UserIdValid(text2))
			{
				player.Reply(string.Format(lang.GetMessage("PlayerNotFound", (Plugin)(object)this, player.Id), text2));
				return;
			}
			string text4 = text2;
			if (val != null)
			{
				text4 = val.Id;
				text2 = val.Name;
				permission.UpdateNickname(text4, text2);
				text2 = text2 + " (" + text4 + ")";
			}
			string[] userPermissions = permission.GetUserPermissions(text4);
			string[] userGroups = permission.GetUserGroups(text4);
			string text5 = string.Format(lang.GetMessage("PlayerPermissions", (Plugin)(object)this, player.Id), text2) + ":\n";
			text5 += ((userPermissions.Length != 0) ? string.Join(", ", userPermissions) : lang.GetMessage("NoPlayerPermissions", (Plugin)(object)this, player.Id));
			text5 = text5 + "\n\n" + string.Format(lang.GetMessage("PlayerGroups", (Plugin)(object)this, player.Id), text2) + ":\n";
			text5 += ((userGroups.Length != 0) ? string.Join(", ", userGroups) : lang.GetMessage("NoPlayerGroups", (Plugin)(object)this, player.Id));
			player.Reply(text5);
		}
		else if (text.Equals("group"))
		{
			if (args.Length < 2 || string.IsNullOrEmpty(text2))
			{
				player.Reply(lang.GetMessage("CommandUsageShow", (Plugin)(object)this, player.Id));
				player.Reply(lang.GetMessage("CommandUsageShowName", (Plugin)(object)this, player.Id));
				return;
			}
			if (!permission.GroupExists(text2))
			{
				player.Reply(string.Format(lang.GetMessage("GroupNotFound", (Plugin)(object)this, player.Id), text2));
				return;
			}
			string[] usersInGroup = permission.GetUsersInGroup(text2);
			string[] groupPermissions = permission.GetGroupPermissions(text2, false);
			string text6 = string.Format(lang.GetMessage("GroupPlayers", (Plugin)(object)this, player.Id), text2) + ":\n";
			text6 += ((usersInGroup.Length != 0) ? string.Join(", ", usersInGroup) : lang.GetMessage("NoPlayersInGroup", (Plugin)(object)this, player.Id));
			text6 = text6 + "\n\n" + string.Format(lang.GetMessage("GroupPermissions", (Plugin)(object)this, player.Id), text2) + ":\n";
			text6 += ((groupPermissions.Length != 0) ? string.Join(", ", groupPermissions) : lang.GetMessage("NoGroupPermissions", (Plugin)(object)this, player.Id));
			string groupParent = permission.GetGroupParent(text2);
			while (permission.GroupExists(groupParent))
			{
				text6 = text6 + "\n" + string.Format(lang.GetMessage("ParentGroupPermissions", (Plugin)(object)this, player.Id), groupParent) + ":\n";
				text6 += string.Join(", ", permission.GetGroupPermissions(groupParent, false));
				groupParent = permission.GetGroupParent(groupParent);
			}
			player.Reply(text6);
		}
		else if (text.Equals("groups"))
		{
			player.Reply(string.Format(lang.GetMessage("Groups", (Plugin)(object)this, player.Id) + ":\n" + string.Join(", ", permission.GetGroups())));
		}
		else
		{
			player.Reply(lang.GetMessage("CommandUsageShow", (Plugin)(object)this, player.Id));
			player.Reply(lang.GetMessage("CommandUsageShowName", (Plugin)(object)this, player.Id));
		}
	}

	[HookMethod("UnloadCommand")]
	private void UnloadCommand(IPlayer player, string command, string[] args)
	{
		if (args.Length < 1)
		{
			player.Reply(lang.GetMessage("CommandUsageUnload", (Plugin)(object)this, player.Id));
			return;
		}
		if (args[0].Equals("*") || args[0].Equals("all"))
		{
			Interface.Oxide.UnloadAllPlugins((IList<string>)null);
			return;
		}
		foreach (string text in args)
		{
			if (!string.IsNullOrEmpty(text))
			{
				Interface.Oxide.UnloadPlugin(text);
			}
		}
	}

	[HookMethod("UserGroupCommand")]
	private void UserGroupCommand(IPlayer player, string command, string[] args)
	{
		if (!PermissionsLoaded(player))
		{
			return;
		}
		if (args.Length < 3)
		{
			player.Reply(lang.GetMessage("CommandUsageUserGroup", (Plugin)(object)this, player.Id));
			return;
		}
		string text = args[0];
		string text2 = ExtensionMethods.Sanitize(args[1]);
		string text3 = args[2];
		IPlayer[] array = Covalence.PlayerManager.FindPlayers(text2).ToArray();
		if (array.Length > 1)
		{
			player.Reply(string.Format(lang.GetMessage("PlayersFound", (Plugin)(object)this, player.Id), string.Join(", ", array.Select((IPlayer p) => p.Name).ToArray())));
			return;
		}
		IPlayer val = ((array.Length == 1) ? array[0] : null);
		if (val == null && !permission.UserIdValid(text2))
		{
			player.Reply(string.Format(lang.GetMessage("PlayerNotFound", (Plugin)(object)this, player.Id), text2));
			return;
		}
		string text4 = text2;
		if (val != null)
		{
			text4 = val.Id;
			text2 = val.Name;
			permission.UpdateNickname(text4, text2);
			text2 = text2 + "(" + text4 + ")";
		}
		if (!permission.GroupExists(text3))
		{
			player.Reply(string.Format(lang.GetMessage("GroupNotFound", (Plugin)(object)this, player.Id), text3));
		}
		else if (text.Equals("add"))
		{
			permission.AddUserGroup(text4, text3);
			player.Reply(string.Format(lang.GetMessage("PlayerAddedToGroup", (Plugin)(object)this, player.Id), text2, text3));
		}
		else if (text.Equals("remove"))
		{
			permission.RemoveUserGroup(text4, text3);
			player.Reply(string.Format(lang.GetMessage("PlayerRemovedFromGroup", (Plugin)(object)this, player.Id), text2, text3));
		}
		else
		{
			player.Reply(lang.GetMessage("CommandUsageUserGroup", (Plugin)(object)this, player.Id));
		}
	}

	[HookMethod("VersionCommand")]
	private void VersionCommand(IPlayer player)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (player.IsServer)
		{
			string format = "Oxide.Rust Version: {0}\nOxide.Rust Branch: {1}";
			player.Reply(string.Format(format, RustExtension.AssemblyVersion, ((Extension)Extension).Branch));
			return;
		}
		string format2 = Covalence.FormatText(lang.GetMessage("Version", (Plugin)(object)this, player.Id));
		player.Reply(string.Format(format2, RustExtension.AssemblyVersion, Covalence.GameName, Server.Version, Server.Protocol));
	}

	[HookMethod("SaveCommand")]
	private void SaveCommand(IPlayer player)
	{
		if (PermissionsLoaded(player) && player.IsAdmin)
		{
			Interface.Oxide.OnSave();
			Covalence.PlayerManager.SavePlayerData();
			player.Reply(lang.GetMessage("DataSaved", (Plugin)(object)this, player.Id));
		}
	}

	public RustCore()
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		Extension = Interface.Oxide.GetExtension<RustExtension>();
		((Plugin)this).Title = "Rust";
		((Plugin)this).Author = ((Extension)Extension).Author;
		((Plugin)this).Version = ((Extension)Extension).Version;
	}

	private bool PermissionsLoaded(IPlayer player)
	{
		if (!permission.IsLoaded)
		{
			player.Reply(string.Format(lang.GetMessage("PermissionsNotLoaded", (Plugin)(object)this, player.Id), ((Library)permission).LastException.Message));
			return false;
		}
		return true;
	}

	[HookMethod("Init")]
	private void Init()
	{
		RemoteLogger.SetTag("game", ((Plugin)this).Title.ToLower());
		RemoteLogger.SetTag("game version", Server.Version);
		((Plugin)this).AddCovalenceCommand(new string[3] { "oxide.plugins", "o.plugins", "plugins" }, "PluginsCommand", "oxide.plugins");
		((Plugin)this).AddCovalenceCommand(new string[3] { "oxide.load", "o.load", "plugin.load" }, "LoadCommand", "oxide.load");
		((Plugin)this).AddCovalenceCommand(new string[3] { "oxide.reload", "o.reload", "plugin.reload" }, "ReloadCommand", "oxide.reload");
		((Plugin)this).AddCovalenceCommand(new string[3] { "oxide.unload", "o.unload", "plugin.unload" }, "UnloadCommand", "oxide.unload");
		((Plugin)this).AddCovalenceCommand(new string[3] { "oxide.grant", "o.grant", "perm.grant" }, "GrantCommand", "oxide.grant");
		((Plugin)this).AddCovalenceCommand(new string[3] { "oxide.group", "o.group", "perm.group" }, "GroupCommand", "oxide.group");
		((Plugin)this).AddCovalenceCommand(new string[3] { "oxide.revoke", "o.revoke", "perm.revoke" }, "RevokeCommand", "oxide.revoke");
		((Plugin)this).AddCovalenceCommand(new string[3] { "oxide.show", "o.show", "perm.show" }, "ShowCommand", "oxide.show");
		((Plugin)this).AddCovalenceCommand(new string[3] { "oxide.usergroup", "o.usergroup", "perm.usergroup" }, "UserGroupCommand", "oxide.usergroup");
		((Plugin)this).AddCovalenceCommand(new string[3] { "oxide.lang", "o.lang", "lang" }, "LangCommand", (string[])null);
		((Plugin)this).AddCovalenceCommand(new string[2] { "oxide.save", "o.save" }, "SaveCommand", (string[])null);
		((Plugin)this).AddCovalenceCommand(new string[2] { "oxide.version", "o.version" }, "VersionCommand", (string[])null);
		foreach (KeyValuePair<string, Dictionary<string, string>> language in Localization.languages)
		{
			lang.RegisterMessages(language.Value, (Plugin)(object)this, language.Key);
		}
		if (!permission.IsLoaded)
		{
			return;
		}
		int num = 0;
		foreach (string defaultGroup in Interface.Oxide.Config.Options.DefaultGroups)
		{
			if (!permission.GroupExists(defaultGroup))
			{
				permission.CreateGroup(defaultGroup, defaultGroup, num++);
			}
		}
		permission.RegisterValidate((Func<string, bool>)((string s) => ulong.TryParse(s, out var result) && ((result == 0L) ? 1 : ((int)Math.Floor(Math.Log10(result) + 1.0))) >= 17));
		permission.CleanUp();
	}

	[HookMethod("OnPluginLoaded")]
	private void OnPluginLoaded(Plugin plugin)
	{
		if (serverInitialized)
		{
			plugin.CallHook("OnServerInitialized", new object[1] { false });
		}
	}

	[HookMethod("IOnServerInitialized")]
	private void IOnServerInitialized()
	{
		if (!serverInitialized)
		{
			Analytics.Collect();
			if (!Interface.Oxide.Config.Options.Modded)
			{
				Interface.Oxide.LogWarning("The server is currently listed under Community. Please be aware that Facepunch only allows admin tools (that do not affect gameplay) under the Community section", Array.Empty<object>());
			}
			serverInitialized = true;
			Interface.CallHook("OnServerInitialized", (object)serverInitialized);
		}
	}

	[HookMethod("OnServerSave")]
	private void OnServerSave()
	{
		Interface.Oxide.OnSave();
		Covalence.PlayerManager.SavePlayerData();
	}

	[HookMethod("IOnServerShutdown")]
	private void IOnServerShutdown()
	{
		Interface.Oxide.CallHook("OnServerShutdown", Array.Empty<object>());
		Interface.Oxide.OnShutdown();
		Covalence.PlayerManager.SavePlayerData();
	}

	private void ParseCommand(string argstr, out string command, out string[] args)
	{
		List<string> list = new List<string>();
		StringBuilder stringBuilder = new StringBuilder();
		bool flag = false;
		foreach (char c in argstr)
		{
			if (c == '"')
			{
				if (flag)
				{
					string text = stringBuilder.ToString().Trim();
					if (!string.IsNullOrEmpty(text))
					{
						list.Add(text);
					}
					stringBuilder.Clear();
					flag = false;
				}
				else
				{
					flag = true;
				}
			}
			else if (char.IsWhiteSpace(c) && !flag)
			{
				string text2 = stringBuilder.ToString().Trim();
				if (!string.IsNullOrEmpty(text2))
				{
					list.Add(text2);
				}
				stringBuilder.Clear();
			}
			else
			{
				stringBuilder.Append(c);
			}
		}
		if (stringBuilder.Length > 0)
		{
			string text3 = stringBuilder.ToString().Trim();
			if (!string.IsNullOrEmpty(text3))
			{
				list.Add(text3);
			}
		}
		if (list.Count == 0)
		{
			command = null;
			args = null;
		}
		else
		{
			command = list[0];
			list.RemoveAt(0);
			args = list.ToArray();
		}
	}

	public static BasePlayer FindPlayer(string nameOrIdOrIp)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer result = null;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (string.IsNullOrEmpty(current.UserIDString))
				{
					continue;
				}
				if (current.UserIDString.Equals(nameOrIdOrIp))
				{
					return current;
				}
				if (!string.IsNullOrEmpty(current.displayName))
				{
					if (current.displayName.Equals(nameOrIdOrIp, StringComparison.OrdinalIgnoreCase))
					{
						return current;
					}
					if (StringEx.Contains(current.displayName, nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
					{
						result = current;
					}
					Networkable net = ((BaseNetworkable)current).net;
					if (((net != null) ? net.connection : null) != null && ((BaseNetworkable)current).net.connection.ipaddress.Equals(nameOrIdOrIp))
					{
						return current;
					}
					Networkable net2 = ((BaseNetworkable)current).net;
					if (((net2 != null) ? net2.connection : null) != null && ((object)(NetworkableId)(ref ((BaseNetworkable)current).net.ID)/*cast due to .constrained prefix*/).Equals((object?)nameOrIdOrIp))
					{
						return current;
					}
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current2 = enumerator.Current;
				if (string.IsNullOrEmpty(current2.UserIDString))
				{
					continue;
				}
				if (current2.UserIDString.Equals(nameOrIdOrIp))
				{
					return current2;
				}
				if (!string.IsNullOrEmpty(current2.displayName))
				{
					if (current2.displayName.Equals(nameOrIdOrIp, StringComparison.OrdinalIgnoreCase))
					{
						return current2;
					}
					if (StringEx.Contains(current2.displayName, nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
					{
						result = current2;
					}
				}
			}
			return result;
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static BasePlayer FindPlayerByName(string name)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer result = null;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!string.IsNullOrEmpty(current.displayName))
				{
					if (current.displayName.Equals(name, StringComparison.OrdinalIgnoreCase))
					{
						return current;
					}
					if (StringEx.Contains(current.displayName, name, CompareOptions.OrdinalIgnoreCase))
					{
						result = current;
					}
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current2 = enumerator.Current;
				if (!string.IsNullOrEmpty(current2.displayName))
				{
					if (current2.displayName.Equals(name, StringComparison.OrdinalIgnoreCase))
					{
						return current2;
					}
					if (StringEx.Contains(current2.displayName, name, CompareOptions.OrdinalIgnoreCase))
					{
						result = current2;
					}
				}
			}
			return result;
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static BasePlayer FindPlayerById(ulong id)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (EncryptedValue<ulong>.op_Implicit(current.userID) == id)
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current2 = enumerator.Current;
				if (EncryptedValue<ulong>.op_Implicit(current2.userID) == id)
				{
					return current2;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public static BasePlayer FindPlayerByIdString(string id)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!string.IsNullOrEmpty(current.UserIDString) && current.UserIDString.Equals(id))
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current2 = enumerator.Current;
				if (!string.IsNullOrEmpty(current2.UserIDString) && current2.UserIDString.Equals(id))
				{
					return current2;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	[HookMethod("IOnBaseCombatEntityHurt")]
	private object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
	{
		if (!(entity is BasePlayer))
		{
			return Interface.CallHook("OnEntityTakeDamage", (object)entity, (object)hitInfo);
		}
		return null;
	}

	[HookMethod("IOnNpcTarget")]
	private object IOnNpcTarget(BaseNpc npc, BaseEntity target)
	{
		if (Interface.CallHook("OnNpcTarget", (object)npc, (object)target) != null)
		{
			npc.SetFact((Facts)0, (byte)0, true, true);
			npc.SetFact((Facts)1, (byte)3, true, true);
			npc.SetFact((Facts)20, (byte)1, true, true);
			npc.playerTargetDecisionStartTime = 0f;
			return 0f;
		}
		return null;
	}

	[HookMethod("IOnNpcTarget")]
	private object IOnNpcTarget(SenseComponent sense, BaseEntity target)
	{
		if (!Object.op_Implicit((Object)(object)sense) || !Object.op_Implicit((Object)(object)target))
		{
			return null;
		}
		BaseEntity baseEntity = ((EntityComponent<BaseEntity>)(object)sense).baseEntity;
		if (!Object.op_Implicit((Object)(object)baseEntity))
		{
			return null;
		}
		if (Interface.CallHook("OnNpcTarget", (object)baseEntity, (object)target) != null)
		{
			return false;
		}
		return null;
	}

	[HookMethod("IOnEntitySaved")]
	private void IOnEntitySaved(BaseNetworkable baseNetworkable, SaveInfo saveInfo)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (serverInitialized && saveInfo.forConnection != null)
		{
			Interface.CallHook("OnEntitySaved", (object)baseNetworkable, (object)saveInfo);
		}
	}

	[HookMethod("IOnLoseCondition")]
	private object IOnLoseCondition(Item item, float amount)
	{
		object[] array = new object[2] { item, amount };
		Interface.CallHook("OnLoseCondition", array);
		amount = (float)array[1];
		float condition = item.condition;
		item.condition -= amount;
		if (item.condition <= 0f && item.condition < condition)
		{
			item.OnBroken();
		}
		return true;
	}

	[HookMethod("ICanPickupEntity")]
	private object ICanPickupEntity(BasePlayer basePlayer, BaseEntity entity)
	{
		object obj = Interface.CallHook("CanPickupEntity", (object)basePlayer, (object)entity);
		if (!(obj is bool) || (bool)obj)
		{
			return null;
		}
		return true;
	}

	[HookMethod("IOnBasePlayerAttacked")]
	private object IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)
	{
		if (!serverInitialized || (Object)(object)basePlayer == (Object)null || hitInfo == null || ((BaseCombatEntity)basePlayer).IsDead() || isPlayerTakingDamage || basePlayer is NPCPlayer)
		{
			return null;
		}
		if (Interface.CallHook("OnEntityTakeDamage", (object)basePlayer, (object)hitInfo) != null)
		{
			return true;
		}
		isPlayerTakingDamage = true;
		try
		{
			((BaseEntity)basePlayer).OnAttacked(hitInfo);
		}
		finally
		{
			isPlayerTakingDamage = false;
		}
		return true;
	}

	[HookMethod("IOnBasePlayerHurt")]
	private object IOnBasePlayerHurt(BasePlayer basePlayer, HitInfo hitInfo)
	{
		if (!isPlayerTakingDamage)
		{
			return Interface.CallHook("OnEntityTakeDamage", (object)basePlayer, (object)hitInfo);
		}
		return null;
	}

	[HookMethod("OnServerUserSet")]
	private void OnServerUserSet(ulong steamId, UserGroup group, string playerName, string reason, long expiry)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Invalid comparison between Unknown and I4
		if (serverInitialized && (int)group == 3)
		{
			string text = steamId.ToString();
			IPlayer val = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", (object)playerName, (object)steamId, (object)(((val != null) ? val.Address : null) ?? "0"), (object)reason, (object)expiry);
			Interface.CallHook("OnUserBanned", (object)playerName, (object)text, (object)(((val != null) ? val.Address : null) ?? "0"), (object)reason, (object)expiry);
		}
	}

	[HookMethod("OnServerUserRemove")]
	private void OnServerUserRemove(ulong steamId)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Invalid comparison between Unknown and I4
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && (int)ServerUsers.users[steamId].group == 3)
		{
			string text = steamId.ToString();
			IPlayer val = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", (object)(((val != null) ? val.Name : null) ?? "Unnamed"), (object)steamId, (object)(((val != null) ? val.Address : null) ?? "0"));
			Interface.CallHook("OnUserUnbanned", (object)(((val != null) ? val.Name : null) ?? "Unnamed"), (object)text, (object)(((val != null) ? val.Address : null) ?? "0"));
		}
	}

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string text2 = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj = Interface.CallHook("CanClientLogin", (object)connection);
		object obj2 = Interface.CallHook("CanUserLogin", (object)username, (object)text, (object)text2);
		object obj3 = ((obj == null) ? obj2 : obj);
		if (obj3 is string || (obj3 is bool && !(bool)obj3))
		{
			ConnectionAuth.Reject(connection, (obj3 is string) ? obj3.ToString() : lang.GetMessage("ConnectionRejected", (Plugin)(object)this, text), (string)null);
			return true;
		}
		object obj4 = Interface.CallHook("OnUserApprove", (object)connection);
		object result = Interface.CallHook("OnUserApproved", (object)username, (object)text, (object)text2);
		if (obj4 != null)
		{
			return obj4;
		}
		return result;
	}

	[HookMethod("IOnPlayerBanned")]
	private void IOnPlayerBanned(Connection connection, AuthResponse status)
	{
		Interface.CallHook("OnPlayerBanned", (object)connection, (object)((object)(AuthResponse)(ref status)/*cast due to .constrained prefix*/).ToString());
	}

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, ChatChannel channel, BasePlayer basePlayer)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		string chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);
		if (chatCommandPrefix != null)
		{
			TryRunPlayerCommand(basePlayer, message, chatCommandPrefix);
			return false;
		}
		message = StringEx.EscapeRichText(message, false);
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", (object)playerId, (object)playerName, (object)message, (object)channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", (object)basePlayer, (object)message, (object)channel);
		object result = Interface.CallHook("OnUserChat", (object)basePlayer.IPlayer, (object)message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", (object)basePlayer, (object)command, (object)args);
			Interface.CallHook("OnApplicationCommand", (object)basePlayer.IPlayer, (object)command, (object)args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", (object)basePlayer, (object)command, (object)args);
		object obj2 = Interface.CallHook("OnUserCommand", (object)basePlayer.IPlayer, (object)command, (object)args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", (Plugin)(object)this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string text3 = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string name = ex2.GetType().Name;
				text2 = (name + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + name);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					text3 = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, text3, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace), Array.Empty<object>());
		}
	}

	[HookMethod("OnClientAuth")]
	private void OnClientAuth(Connection connection)
	{
		connection.username = Regex.Replace(connection.username, "<[^>]*>", string.Empty);
	}

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(((BaseNetworkable)basePlayer).net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot((BaseNetworkable)(object)CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer val = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (val != null)
		{
			basePlayer.IPlayer = val;
			Interface.CallHook("OnUserConnected", (object)val);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", new object[1] { basePlayer });
	}

	[HookMethod("OnPlayerDisconnected")]
	private void OnPlayerDisconnected(BasePlayer basePlayer, string reason)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserDisconnected", (object)iPlayer, (object)reason);
		}
		Covalence.PlayerManager.PlayerDisconnected(basePlayer);
	}

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		MonoBehaviour player = connection.player;
		BasePlayer val2 = (BasePlayer)(object)((player is BasePlayer) ? player : null);
		if ((Object)(object)val2 != (Object)null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", (object)val2, (object)val);
			if (val2.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", (object)val2.IPlayer, (object)val);
			}
		}
	}

	[HookMethod("OnPlayerKicked")]
	private void OnPlayerKicked(BasePlayer basePlayer, string reason)
	{
		if (basePlayer.IPlayer != null)
		{
			Interface.CallHook("OnUserKicked", (object)basePlayer.IPlayer, (object)reason);
		}
	}

	[HookMethod("OnPlayerRespawn")]
	private object OnPlayerRespawn(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer == null)
		{
			return null;
		}
		return Interface.CallHook("OnUserRespawn", (object)iPlayer);
	}

	[HookMethod("OnPlayerRespawned")]
	private void OnPlayerRespawned(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserRespawned", (object)iPlayer);
		}
	}

	[HookMethod("IOnRconMessage")]
	private object IOnRconMessage(IPAddress ipAddress, string command)
	{
		if (ipAddress != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (string.IsNullOrEmpty(message?.Message))
			{
				return null;
			}
			if (Interface.CallHook("OnRconMessage", (object)ipAddress, (object)message) != null)
			{
				return true;
			}
			string[] array = CommandLine.Split(message.Message);
			if (array.Length >= 1)
			{
				string text = array[0].ToLower();
				string[] array2 = array.Skip(1).ToArray();
				if (Interface.CallHook("OnRconCommand", (object)ipAddress, (object)text, (object)array2) != null)
				{
					return true;
				}
			}
		}
		return null;
	}

	[HookMethod("IOnRconInitialize")]
	private object IOnRconInitialize()
	{
		if (!Interface.Oxide.Config.Rcon.Enabled)
		{
			return null;
		}
		return true;
	}

	[HookMethod("IOnRunCommandLine")]
	private object IOnRunCommandLine()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		foreach (KeyValuePair<string, string> @switch in CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string text2 = @switch.Key.Substring(1);
			Option unrestricted = Option.Unrestricted;
			((Option)(ref unrestricted)).PrintOutput = false;
			ConsoleSystem.Run(unrestricted, text2, new object[1] { text });
		}
		return false;
	}

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(Arg arg)
	{
		if (arg == null || (arg.Connection != null && (Object)(object)ArgEx.Player(arg) == (Object)null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay" || arg.cmd.FullName == "chat.localsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", (object)arg);
		object obj2 = Interface.CallHook("OnServerCommand", (object)arg.cmd.FullName, (object)RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

	[HookMethod("OnServerInformationUpdated")]
	private void OnServerInformationUpdated()
	{
		SteamServer.GameTags += ",^o";
		if (Interface.Oxide.Config.Options.Modded)
		{
			SteamServer.GameTags += "^z";
		}
	}

	[HookMethod("IOnCupboardAuthorize")]
	private object IOnCupboardAuthorize(ulong userID, BasePlayer player, BuildingPrivlidge privlidge)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		if (userID == EncryptedValue<ulong>.op_Implicit(player.userID))
		{
			if (Interface.CallHook("OnCupboardAuthorize", (object)privlidge, (object)player) != null)
			{
				return true;
			}
		}
		else if (Interface.CallHook("OnCupboardAssign", (object)privlidge, (object)userID, (object)player) != null)
		{
			return true;
		}
		return null;
	}

	[HookMethod("OnTeamMemberPromote")]
	private void OnTeamMemberPromote(PlayerTeam team, ulong newTeamLeader)
	{
		BasePlayer val = BasePlayer.FindByID(newTeamLeader);
		if ((Object)(object)val != (Object)null)
		{
			Interface.Oxide.CallDeprecatedHook("OnTeamPromote", "OnTeamMemberPromote(PlayerTeam team, ulong userId)", Eoy, new object[2] { team, val });
		}
	}
}


using System;
using System.Net;
using System.Reflection;
using System.Threading.Tasks;
using JSON;
using Oxide.Core;
using Oxide.Core.Extensions;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Libraries;
using Oxide.Plugins;

public class RustExtension : Extension
{
	private const string OxideRustReleaseListUrl = "https://api.github.com/repos/OxideMod/Oxide.Rust/releases";

	internal static Assembly Assembly = Assembly.GetExecutingAssembly();

	internal static AssemblyName AssemblyName = Assembly.GetName();

	internal static VersionNumber AssemblyVersion = new VersionNumber(AssemblyName.Version.Major, AssemblyName.Version.Minor, AssemblyName.Version.Build);

	internal static string AssemblyAuthors = ((AssemblyCompanyAttribute)Attribute.GetCustomAttribute(Assembly, typeof(AssemblyCompanyAttribute), inherit: false)).Company;

	private static readonly WebClient WebClient = new WebClient();

	private static VersionNumber LatestExtVersion = AssemblyVersion;

	public static string[] Filter = new string[18]
	{
		"alphamapResolution is clamped to the range of", "AngryAnt Behave version", "Floating point textures aren't supported on this device", "HDR RenderTexture format is not supported on this platform.", "Image Effects are not supported on this platform.", "Missing projectileID", "Motion vectors not supported on a platform that does not support", "The image effect Main Camera", "The image effect effect -", "Unable to find shaders",
		"Unsupported encoding: 'utf8'", "Warning, null renderer for ScaleRenderer!", "[AmplifyColor]", "[AmplifyOcclusion]", "[CoverageQueries] Disabled due to unsupported", "[CustomProbe]", "[Manifest] URI IS", "[SpawnHandler] populationCounts"
	};

	public override bool IsGameExtension => true;

	public override string Name => "Rust";

	public override string Author => AssemblyAuthors;

	public override VersionNumber Version => AssemblyVersion;

	public override string[] DefaultReferences => new string[35]
	{
		"0Harmony", "Facepunch.Network", "Facepunch.Steamworks.Posix64", "Facepunch.System", "Facepunch.UnityEngine", "Facepunch.Steamworks.Win64", "Rust.Data", "Rust.FileSystem", "Rust.Clans", "Rust.Clans.Local",
		"Rust.Global", "Rust.Localization", "Rust.Platform", "Rust.Platform.Common", "Rust.Platform.Steam", "Rust.Workshop", "Rust.World", "System.Drawing", "UnityEngine.AIModule", "UnityEngine.AssetBundleModule",
		"UnityEngine.CoreModule", "UnityEngine.GridModule", "UnityEngine.ImageConversionModule", "UnityEngine.PhysicsModule", "UnityEngine.TerrainModule", "UnityEngine.TerrainPhysicsModule", "UnityEngine.UI", "UnityEngine.UIModule", "UnityEngine.UIElementsModule", "UnityEngine.UnityWebRequestAudioModule",
		"UnityEngine.UnityWebRequestModule", "UnityEngine.UnityWebRequestTextureModule", "UnityEngine.UnityWebRequestWWWModule", "UnityEngine.VehiclesModule", "netstandard"
	};

	public override string[] WhitelistAssemblies => new string[20]
	{
		"Assembly-CSharp", "Assembly-CSharp-firstpass", "DestMath", "Facepunch.Network", "Facepunch.System", "Facepunch.UnityEngine", "mscorlib", "Oxide.Core", "Oxide.Rust", "RustBuild",
		"Rust.Data", "Rust.FileSystem", "Rust.Global", "Rust.Localization", "Rust.Localization", "Rust.Platform.Common", "Rust.Platform.Steam", "System", "System.Core", "UnityEngine"
	};

	public override string[] WhitelistNamespaces => new string[14]
	{
		"ConVar", "Dest", "Facepunch", "Network", "Oxide.Game.Rust.Cui", "ProtoBuf", "PVT", "Rust", "Steamworks", "System.Collections",
		"System.Security.Cryptography", "System.Text", "System.Threading.Monitor", "UnityEngine"
	};

	public RustExtension(ExtensionManager manager)
		: base(manager)
	{
	}

	public override void Load()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		((Extension)this).Manager.RegisterLibrary("Rust", (Library)(object)new Rust());
		((Extension)this).Manager.RegisterLibrary("Command", (Library)(object)new Command());
		((Extension)this).Manager.RegisterLibrary("Item", (Library)(object)new Item());
		((Extension)this).Manager.RegisterLibrary("Player", (Library)(object)new Player());
		((Extension)this).Manager.RegisterLibrary("Server", (Library)(object)new Server());
		((Extension)this).Manager.RegisterPluginLoader((PluginLoader)(object)new RustPluginLoader());
		if (Environment.OSVersion.Platform == PlatformID.Unix)
		{
			Cleanup.Add("Facepunch.Steamworks.Win64.dll");
		}
		WebClient.Headers["User-Agent"] = $"Oxide.Rust {((Extension)this).Version}";
	}

	public override void LoadPluginWatchers(string directory)
	{
	}

	public override void OnModLoad()
	{
		CSharpPluginLoader.PluginReferences.UnionWith(((Extension)this).DefaultReferences);
	}

	public void GetLatestVersion(Action<VersionNumber, Exception> callback)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (callback == null)
		{
			throw new ArgumentNullException("callback", "Callback cannot be null");
		}
		if (LatestExtVersion > AssemblyVersion)
		{
			callback(LatestExtVersion, null);
			return;
		}
		GetLatestExtensionVersion().ContinueWith(delegate(Task<VersionNumber> task)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			if (task.Exception == null)
			{
				LatestExtVersion = task.Result;
			}
			callback(LatestExtVersion, task.Exception?.InnerException);
		});
	}

	private async Task<VersionNumber> GetLatestExtensionVersion()
	{
		string obj = await WebClient.DownloadStringTaskAsync("https://api.github.com/repos/OxideMod/Oxide.Rust/releases");
		if (string.IsNullOrWhiteSpace(obj))
		{
			throw new Exception("Could not retrieve latest Oxide.Rust version from GitHub API");
		}
		string @string = Array.Parse(obj)[0].Obj.GetString("tag_name", "");
		if (string.IsNullOrWhiteSpace(@string))
		{
			throw new Exception("Tag name is undefined");
		}
		return ParseVersionNumber(@string);
	}

	private VersionNumber ParseVersionNumber(string versionString)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		string[] array = versionString.Split(new char[1] { '.' }, StringSplitOptions.RemoveEmptyEntries);
		int num = int.Parse(array[0]);
		int num2 = int.Parse(array[1]);
		int num3 = int.Parse(array[2]);
		return new VersionNumber(num, num2, num3);
	}
}


using System;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;

public class RustPluginLoader : PluginLoader
{
	public override Type[] CorePlugins => new Type[1] { typeof(RustCore) };
}


using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

public static class CuiHelper
{
	public static string ToJson(List<CuiElement> elements, bool format = false)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		return JsonConvert.SerializeObject((object)elements, (Formatting)(format ? 1 : 0), new JsonSerializerSettings
		{
			DefaultValueHandling = (DefaultValueHandling)1
		}).Replace("\\n", "\n");
	}

	public static List<CuiElement> FromJson(string json)
	{
		return JsonConvert.DeserializeObject<List<CuiElement>>(json);
	}

	public static string GetGuid()
	{
		return Guid.NewGuid().ToString().Replace("-", string.Empty);
	}

	public static bool AddUi(BasePlayer player, List<CuiElement> elements)
	{
		return AddUi(player, ToJson(elements));
	}

	public static bool AddUi(BasePlayer player, string json)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetworkable)(player?)).net != null && Interface.CallHook("CanUseUI", (object)player, (object)json) == null)
		{
			((BaseEntity)CommunityEntity.ServerInstance).ClientRPC(RpcTarget.Player("AddUI", ((BaseNetworkable)player).net.connection), json);
			return true;
		}
		return false;
	}

	public static bool DestroyUi(BasePlayer player, string elem)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetworkable)(player?)).net != null)
		{
			Interface.CallHook("OnDestroyUI", (object)player, (object)elem);
			((BaseEntity)CommunityEntity.ServerInstance).ClientRPC(RpcTarget.Player("DestroyUI", ((BaseNetworkable)player).net.connection), elem);
			return true;
		}
		return false;
	}

	public static void SetColor(this ICuiColor elem, Color color)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		elem.Color = $"{color.r} {color.g} {color.b} {color.a}";
	}

	public static Color GetColor(this ICuiColor elem)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ColorEx.Parse(elem.Color);
	}
}


using System.Collections.Generic;
using Oxide.Game.Rust.Cui;

public class CuiElementContainer : List<CuiElement>
{
	public string Add(CuiButton button, string parent = "Hud", string name = null, string destroyUi = null)
	{
		if (string.IsNullOrEmpty(name))
		{
			name = CuiHelper.GetGuid();
		}
		Add(new CuiElement
		{
			Name = name,
			Parent = parent,
			FadeOut = button.FadeOut,
			DestroyUi = destroyUi,
			Components = 
			{
				(ICuiComponent)button.Button,
				(ICuiComponent)button.RectTransform
			}
		});
		if (!string.IsNullOrEmpty(button.Text.Text))
		{
			Add(new CuiElement
			{
				Parent = name,
				FadeOut = button.FadeOut,
				Components = 
				{
					(ICuiComponent)button.Text,
					(ICuiComponent)new CuiRectTransformComponent()
				}
			});
		}
		return name;
	}

	public string Add(CuiLabel label, string parent = "Hud", string name = null, string destroyUi = null)
	{
		if (string.IsNullOrEmpty(name))
		{
			name = CuiHelper.GetGuid();
		}
		Add(new CuiElement
		{
			Name = name,
			Parent = parent,
			FadeOut = label.FadeOut,
			DestroyUi = destroyUi,
			Components = 
			{
				(ICuiComponent)label.Text,
				(ICuiComponent)label.RectTransform
			}
		});
		return name;
	}

	public string Add(CuiPanel panel, string parent = "Hud", string name = null, string destroyUi = null)
	{
		if (string.IsNullOrEmpty(name))
		{
			name = CuiHelper.GetGuid();
		}
		CuiElement cuiElement = new CuiElement
		{
			Name = name,
			Parent = parent,
			FadeOut = panel.FadeOut,
			DestroyUi = destroyUi
		};
		if (panel.Image != null)
		{
			cuiElement.Components.Add(panel.Image);
		}
		if (panel.RawImage != null)
		{
			cuiElement.Components.Add(panel.RawImage);
		}
		cuiElement.Components.Add(panel.RectTransform);
		if (panel.CursorEnabled)
		{
			cuiElement.Components.Add(new CuiNeedsCursorComponent());
		}
		if (panel.KeyboardEnabled)
		{
			cuiElement.Components.Add(new CuiNeedsKeyboardComponent());
		}
		Add(cuiElement);
		return name;
	}

	public string ToJson()
	{
		return ToString();
	}

	public override string ToString()
	{
		return CuiHelper.ToJson(this);
	}
}


using Oxide.Game.Rust.Cui;

public class CuiButton
{
	public CuiButtonComponent Button { get; } = new CuiButtonComponent();

	public CuiRectTransformComponent RectTransform { get; } = new CuiRectTransformComponent();

	public CuiTextComponent Text { get; } = new CuiTextComponent();

	public float FadeOut { get; set; }
}


using Oxide.Game.Rust.Cui;

public class CuiPanel
{
	public CuiImageComponent Image { get; set; } = new CuiImageComponent();

	public CuiRawImageComponent RawImage { get; set; }

	public CuiRectTransformComponent RectTransform { get; } = new CuiRectTransformComponent();

	public bool CursorEnabled { get; set; }

	public bool KeyboardEnabled { get; set; }

	public float FadeOut { get; set; }
}


using Oxide.Game.Rust.Cui;

public class CuiLabel
{
	public CuiTextComponent Text { get; } = new CuiTextComponent();

	public CuiRectTransformComponent RectTransform { get; } = new CuiRectTransformComponent();

	public float FadeOut { get; set; }
}


using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;

public class CuiElement
{
	[JsonProperty("name")]
	public string Name { get; set; }

	[JsonProperty("parent")]
	public string Parent { get; set; }

	[JsonProperty(/*Could not decode attribute arguments.*/)]
	public string DestroyUi { get; set; }

	[JsonProperty("components")]
	public List<ICuiComponent> Components { get; } = new List<ICuiComponent>();

	[JsonProperty("fadeOut")]
	public float FadeOut { get; set; }

	[JsonProperty(/*Could not decode attribute arguments.*/)]
	public bool Update { get; set; }
}


using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;

[JsonConverter(typeof(ComponentConverter))]
public interface ICuiComponent
{
	[JsonProperty("type")]
	string Type { get; }
}


using Newtonsoft.Json;

public interface ICuiColor
{
	[JsonProperty("color")]
	string Color { get; set; }
}


using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Game.Rust.Cui;
using UnityEngine;

public class CuiTextComponent : ICuiComponent, ICuiColor
{
	public string Type => "UnityEngine.UI.Text";

	[JsonProperty("text")]
	public string Text { get; set; }

	[JsonProperty("fontSize")]
	public int FontSize { get; set; }

	[JsonProperty("font")]
	public string Font { get; set; }

	[JsonConverter(typeof(StringEnumConverter))]
	[JsonProperty("align")]
	public TextAnchor Align { get; set; }

	public string Color { get; set; }

	[JsonConverter(typeof(StringEnumConverter))]
	[JsonProperty("verticalOverflow")]
	public VerticalWrapMode VerticalOverflow { get; set; }

	[JsonProperty("fadeIn")]
	public float FadeIn { get; set; }
}


using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Game.Rust.Cui;
using UnityEngine.UI;

public class CuiImageComponent : ICuiComponent, ICuiColor
{
	public string Type => "UnityEngine.UI.Image";

	[JsonProperty("sprite")]
	public string Sprite { get; set; }

	[JsonProperty("material")]
	public string Material { get; set; }

	public string Color { get; set; }

	[JsonConverter(typeof(StringEnumConverter))]
	[JsonProperty("imagetype")]
	public Type ImageType { get; set; }

	[JsonProperty("png")]
	public string Png { get; set; }

	[JsonProperty("fadeIn")]
	public float FadeIn { get; set; }

	[JsonProperty("itemid")]
	public int ItemId { get; set; }

	[JsonProperty("skinid")]
	public ulong SkinId { get; set; }
}


using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;

public class CuiRawImageComponent : ICuiComponent, ICuiColor
{
	public string Type => "UnityEngine.UI.RawImage";

	[JsonProperty("sprite")]
	public string Sprite { get; set; }

	public string Color { get; set; }

	[JsonProperty("material")]
	public string Material { get; set; }

	[JsonProperty("url")]
	public string Url { get; set; }

	[JsonProperty("png")]
	public string Png { get; set; }

	[JsonProperty("steamid")]
	public string SteamId { get; set; }

	[JsonProperty("fadeIn")]
	public float FadeIn { get; set; }
}


using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Game.Rust.Cui;
using UnityEngine.UI;

public class CuiButtonComponent : ICuiComponent, ICuiColor
{
	public string Type => "UnityEngine.UI.Button";

	[JsonProperty("command")]
	public string Command { get; set; }

	[JsonProperty("close")]
	public string Close { get; set; }

	[JsonProperty("sprite")]
	public string Sprite { get; set; }

	[JsonProperty("material")]
	public string Material { get; set; }

	public string Color { get; set; }

	[JsonConverter(typeof(StringEnumConverter))]
	[JsonProperty("imagetype")]
	public Type ImageType { get; set; }

	[JsonProperty("fadeIn")]
	public float FadeIn { get; set; }
}


using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;

public class CuiOutlineComponent : ICuiComponent, ICuiColor
{
	public string Type => "UnityEngine.UI.Outline";

	public string Color { get; set; }

	[JsonProperty("distance")]
	public string Distance { get; set; }

	[JsonProperty("useGraphicAlpha")]
	public bool UseGraphicAlpha { get; set; }
}


using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using UnityEngine.UI;

public class CuiInputFieldComponent : ICuiComponent, ICuiColor
{
	public string Type => "UnityEngine.UI.InputField";

	[JsonProperty("text")]
	public string Text { get; set; } = string.Empty;

	[JsonProperty("fontSize")]
	public int FontSize { get; set; }

	[JsonProperty("font")]
	public string Font { get; set; }

	[JsonConverter(typeof(StringEnumConverter))]
	[JsonProperty("align")]
	public TextAnchor Align { get; set; }

	public string Color { get; set; }

	[JsonProperty("characterLimit")]
	public int CharsLimit { get; set; }

	[JsonProperty("command")]
	public string Command { get; set; }

	[JsonProperty("password")]
	public bool IsPassword { get; set; }

	[JsonProperty("readOnly")]
	public bool ReadOnly { get; set; }

	[JsonProperty("needsKeyboard")]
	public bool NeedsKeyboard { get; set; }

	[JsonConverter(typeof(StringEnumConverter))]
	[JsonProperty("lineType")]
	public LineType LineType { get; set; }

	[JsonProperty("autofocus")]
	public bool Autofocus { get; set; }

	[JsonProperty("hudMenuInput")]
	public bool HudMenuInput { get; set; }
}


using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Game.Rust.Cui;

public class CuiCountdownComponent : ICuiComponent
{
	public string Type => "Countdown";

	[JsonProperty("endTime")]
	public float EndTime { get; set; }

	[JsonProperty("startTime")]
	public float StartTime { get; set; }

	[JsonProperty("step")]
	public float Step { get; set; }

	[JsonProperty("interval")]
	public float Interval { get; set; }

	[JsonConverter(typeof(StringEnumConverter))]
	[JsonProperty("timerFormat")]
	public TimerFormat TimerFormat { get; set; }

	[JsonProperty("numberFormat")]
	public string NumberFormat { get; set; }

	[JsonProperty("destroyIfDone")]
	public bool DestroyIfDone { get; set; }

	[JsonProperty("command")]
	public string Command { get; set; }

	[JsonProperty("fadeIn")]
	public float FadeIn { get; set; }
}


public enum TimerFormat
{
	None,
	SecondsHundreth,
	MinutesSeconds,
	MinutesSecondsHundreth,
	HoursMinutes,
	HoursMinutesSeconds,
	HoursMinutesSecondsMilliseconds,
	HoursMinutesSecondsTenths,
	DaysHoursMinutes,
	DaysHoursMinutesSeconds,
	Custom
}


using Oxide.Game.Rust.Cui;

public class CuiNeedsCursorComponent : ICuiComponent
{
	public string Type => "NeedsCursor";
}


using Oxide.Game.Rust.Cui;

public class CuiNeedsKeyboardComponent : ICuiComponent
{
	public string Type => "NeedsKeyboard";
}


using Oxide.Game.Rust.Cui;

public class CuiRectTransformComponent : CuiRectTransform, ICuiComponent
{
	public string Type => "RectTransform";
}


using Newtonsoft.Json;

public class CuiRectTransform
{
	[JsonProperty("anchormin")]
	public string AnchorMin { get; set; }

	[JsonProperty("anchormax")]
	public string AnchorMax { get; set; }

	[JsonProperty("offsetmin")]
	public string OffsetMin { get; set; }

	[JsonProperty("offsetmax")]
	public string OffsetMax { get; set; }
}


using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Game.Rust.Cui;
using UnityEngine.UI;

public class CuiScrollViewComponent : ICuiComponent
{
	public string Type => "UnityEngine.UI.ScrollView";

	[JsonProperty("contentTransform")]
	public CuiRectTransform ContentTransform { get; set; }

	[JsonProperty("horizontal")]
	public bool Horizontal { get; set; }

	[JsonProperty("vertical")]
	public bool Vertical { get; set; }

	[JsonProperty("movementType")]
	[JsonConverter(typeof(StringEnumConverter))]
	public MovementType MovementType { get; set; }

	[JsonProperty("elasticity")]
	public float Elasticity { get; set; }

	[JsonProperty("inertia")]
	public bool Inertia { get; set; }

	[JsonProperty("decelerationRate")]
	public float DecelerationRate { get; set; }

	[JsonProperty("scrollSensitivity")]
	public float ScrollSensitivity { get; set; }

	[JsonProperty("horizontalScrollbar")]
	public CuiScrollbar HorizontalScrollbar { get; set; }

	[JsonProperty("verticalScrollbar")]
	public CuiScrollbar VerticalScrollbar { get; set; }
}


using Newtonsoft.Json;

public class CuiScrollbar
{
	[JsonProperty("invert")]
	public bool Invert { get; set; }

	[JsonProperty("autoHide")]
	public bool AutoHide { get; set; }

	[JsonProperty("handleSprite")]
	public string HandleSprite { get; set; }

	[JsonProperty("size")]
	public float Size { get; set; }

	[JsonProperty("handleColor")]
	public string HandleColor { get; set; }

	[JsonProperty("highlightColor")]
	public string HighlightColor { get; set; }

	[JsonProperty("pressedColor")]
	public string PressedColor { get; set; }

	[JsonProperty("trackSprite")]
	public string TrackSprite { get; set; }

	[JsonProperty("trackColor")]
	public string TrackColor { get; set; }
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Game.Rust.Cui;

public class ComponentConverter : JsonConverter
{
	public override bool CanWrite => false;

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		throw new NotImplementedException();
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		JObject val = JObject.Load(reader);
		Type typeFromHandle;
		switch (((object)val["type"]).ToString())
		{
		case "UnityEngine.UI.Text":
			typeFromHandle = typeof(CuiTextComponent);
			break;
		case "UnityEngine.UI.Image":
			typeFromHandle = typeof(CuiImageComponent);
			break;
		case "UnityEngine.UI.RawImage":
			typeFromHandle = typeof(CuiRawImageComponent);
			break;
		case "UnityEngine.UI.Button":
			typeFromHandle = typeof(CuiButtonComponent);
			break;
		case "UnityEngine.UI.Outline":
			typeFromHandle = typeof(CuiOutlineComponent);
			break;
		case "UnityEngine.UI.InputField":
			typeFromHandle = typeof(CuiInputFieldComponent);
			break;
		case "Countdown":
			typeFromHandle = typeof(CuiCountdownComponent);
			break;
		case "NeedsCursor":
			typeFromHandle = typeof(CuiNeedsCursorComponent);
			break;
		case "NeedsKeyboard":
			typeFromHandle = typeof(CuiNeedsKeyboardComponent);
			break;
		case "RectTransform":
			typeFromHandle = typeof(CuiRectTransformComponent);
			break;
		case "UnityEngine.UI.ScrollView":
			typeFromHandle = typeof(CuiScrollViewComponent);
			break;
		default:
			return null;
		}
		object obj = Activator.CreateInstance(typeFromHandle);
		serializer.Populate(((JToken)val).CreateReader(), obj);
		return obj;
	}

	public override bool CanConvert(Type objectType)
	{
		return objectType == typeof(ICuiComponent);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Libraries;

public class Command : Library
{
	internal struct PluginCallback
	{
		public readonly Plugin Plugin;

		public readonly string Name;

		public Func<Arg, bool> Call;

		public PluginCallback(Plugin plugin, string name)
		{
			Plugin = plugin;
			Name = name;
			Call = null;
		}

		public PluginCallback(Plugin plugin, Func<Arg, bool> callback)
		{
			Plugin = plugin;
			Call = callback;
			Name = null;
		}
	}

	internal class ConsoleCommand
	{
		public readonly string Name;

		public PluginCallback Callback;

		public readonly Command RustCommand;

		public Action<Arg> OriginalCallback;

		internal readonly Permission permission = Interface.Oxide.GetLibrary<Permission>((string)null);

		public ConsoleCommand(string name)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Expected O, but got Unknown
			Name = name;
			string[] array = Name.Split(new char[1] { '.' });
			RustCommand = new Command
			{
				Name = array[1],
				Parent = array[0],
				FullName = name,
				ServerUser = true,
				ServerAdmin = true,
				Client = true,
				ClientInfo = false,
				Variable = false,
				Call = HandleCommand
			};
		}

		public void AddCallback(Plugin plugin, string name)
		{
			Callback = new PluginCallback(plugin, name);
		}

		public void AddCallback(Plugin plugin, Func<Arg, bool> callback)
		{
			Callback = new PluginCallback(plugin, callback);
		}

		public void HandleCommand(Arg arg)
		{
			Plugin plugin = Callback.Plugin;
			if (plugin != null)
			{
				plugin.TrackStart();
			}
			Callback.Call(arg);
			Plugin plugin2 = Callback.Plugin;
			if (plugin2 != null)
			{
				plugin2.TrackEnd();
			}
		}
	}

	internal class ChatCommand
	{
		public readonly string Name;

		public readonly Plugin Plugin;

		private readonly Action<BasePlayer, string, string[]> _callback;

		public ChatCommand(string name, Plugin plugin, Action<BasePlayer, string, string[]> callback)
		{
			Name = name;
			Plugin = plugin;
			_callback = callback;
		}

		public void HandleCommand(BasePlayer sender, string name, string[] args)
		{
			Plugin plugin = Plugin;
			if (plugin != null)
			{
				plugin.TrackStart();
			}
			_callback?.Invoke(sender, name, args);
			Plugin plugin2 = Plugin;
			if (plugin2 != null)
			{
				plugin2.TrackEnd();
			}
		}
	}

	internal readonly Dictionary<string, ConsoleCommand> consoleCommands;

	internal readonly Dictionary<string, ChatCommand> chatCommands;

	private readonly Dictionary<Plugin, Callback<Plugin, PluginManager>> pluginRemovedFromManager;

	public Command()
	{
		consoleCommands = new Dictionary<string, ConsoleCommand>();
		chatCommands = new Dictionary<string, ChatCommand>();
		pluginRemovedFromManager = new Dictionary<Plugin, Callback<Plugin, PluginManager>>();
	}

	[LibraryFunction("AddChatCommand")]
	public void AddChatCommand(string name, Plugin plugin, string callback)
	{
		AddChatCommand(name, plugin, delegate(BasePlayer player, string command, string[] args)
		{
			plugin.CallHook(callback, new object[3] { player, command, args });
		});
	}

	public void AddChatCommand(string command, Plugin plugin, Action<BasePlayer, string, string[]> callback)
	{
		string text = command.ToLowerInvariant();
		if (!CanOverrideCommand(command, "chat"))
		{
			string text2 = ((plugin != null) ? plugin.Name : null) ?? "An unknown plugin";
			Interface.Oxide.LogError("{0} tried to register command '{1}', this command already exists and cannot be overridden!", new object[2] { text2, text });
			return;
		}
		if (chatCommands.TryGetValue(text, out var value))
		{
			Plugin plugin2 = value.Plugin;
			string text3 = ((plugin2 != null) ? plugin2.Name : null) ?? "an unknown plugin";
			string text4 = ((plugin != null) ? plugin.Name : null) ?? "An unknown plugin";
			string text5 = text4 + " has replaced the '" + text + "' chat command previously registered by " + text3;
			Interface.Oxide.LogWarning(text5, Array.Empty<object>());
		}
		if (RustCore.Covalence.CommandSystem.registeredCommands.TryGetValue(text, out var value2))
		{
			Plugin source = value2.Source;
			string text6 = ((source != null) ? source.Name : null) ?? "an unknown plugin";
			string text7 = ((plugin != null) ? plugin.Name : null) ?? "An unknown plugin";
			string text8 = text7 + " has replaced the '" + text + "' command previously registered by " + text6;
			Interface.Oxide.LogWarning(text8, Array.Empty<object>());
			RustCore.Covalence.CommandSystem.UnregisterCommand(text, value2.Source);
		}
		value = new ChatCommand(text, plugin, callback);
		chatCommands[text] = value;
		if (plugin != null && !pluginRemovedFromManager.ContainsKey(plugin))
		{
			pluginRemovedFromManager[plugin] = ((Event<Plugin, PluginManager>)(object)plugin.OnRemovedFromManager).Add((Action<Plugin, PluginManager>)plugin_OnRemovedFromManager);
		}
	}

	[LibraryFunction("AddConsoleCommand")]
	public void AddConsoleCommand(string command, Plugin plugin, string callback)
	{
		AddConsoleCommand(command, plugin, (Arg arg) => plugin.CallHook(callback, new object[1] { arg }) != null);
	}

	public void AddConsoleCommand(string command, Plugin plugin, Func<Arg, bool> callback)
	{
		if (plugin != null && !pluginRemovedFromManager.ContainsKey(plugin))
		{
			pluginRemovedFromManager[plugin] = ((Event<Plugin, PluginManager>)(object)plugin.OnRemovedFromManager).Add((Action<Plugin, PluginManager>)plugin_OnRemovedFromManager);
		}
		string[] array = command.Split(new char[1] { '.' });
		string text = ((array.Length >= 2) ? array[0].Trim() : "global");
		string text2 = ((array.Length >= 2) ? string.Join(".", array.Skip(1).ToArray()) : array[0].Trim());
		string text3 = text + "." + text2;
		ConsoleCommand consoleCommand = new ConsoleCommand(text3);
		if (!CanOverrideCommand((text == "global") ? text2 : text3, "console"))
		{
			string text4 = ((plugin != null) ? plugin.Name : null) ?? "An unknown plugin";
			Interface.Oxide.LogError("{0} tried to register command '{1}', this command already exists and cannot be overridden!", new object[2] { text4, text3 });
			return;
		}
		if (consoleCommands.TryGetValue(text3, out var value))
		{
			if (value.OriginalCallback != null)
			{
				consoleCommand.OriginalCallback = value.OriginalCallback;
			}
			Plugin plugin2 = value.Callback.Plugin;
			string text5 = ((plugin2 != null) ? plugin2.Name : null) ?? "an unknown plugin";
			string text6 = ((plugin != null) ? plugin.Name : null) ?? "An unknown plugin";
			string text7 = text6 + " has replaced the '" + command + "' console command previously registered by " + text5;
			Interface.Oxide.LogWarning(text7, Array.Empty<object>());
			Server.Dict.Remove(value.RustCommand.FullName);
			if (text == "global")
			{
				Server.GlobalDict.Remove(value.RustCommand.Name);
			}
			Index.All = Server.Dict.Values.ToArray();
		}
		if (RustCore.Covalence.CommandSystem.registeredCommands.TryGetValue((text == "global") ? text2 : text3, out var value2))
		{
			if (value2.OriginalCallback != null)
			{
				consoleCommand.OriginalCallback = value2.OriginalCallback;
			}
			Plugin source = value2.Source;
			string text8 = ((source != null) ? source.Name : null) ?? "an unknown plugin";
			string text9 = ((plugin != null) ? plugin.Name : null) ?? "An unknown plugin";
			string text10 = text9 + " has replaced the '" + text3 + "' command previously registered by " + text8;
			Interface.Oxide.LogWarning(text10, Array.Empty<object>());
			RustCore.Covalence.CommandSystem.UnregisterCommand((text == "global") ? text2 : text3, value2.Source);
		}
		consoleCommand.AddCallback(plugin, callback);
		if (Server.Dict.TryGetValue(text3, out var value3))
		{
			if (value3.Variable)
			{
				string text11 = ((plugin != null) ? plugin.Name : null) ?? "An unknown plugin";
				Interface.Oxide.LogError(text11 + " tried to register the " + text2 + " console variable as a command!", Array.Empty<object>());
				return;
			}
			consoleCommand.OriginalCallback = value3.Call;
		}
		Server.Dict[text3] = consoleCommand.RustCommand;
		if (text == "global")
		{
			Server.GlobalDict[text2] = consoleCommand.RustCommand;
		}
		Index.All = Server.Dict.Values.ToArray();
		consoleCommands[text3] = consoleCommand;
	}

	[LibraryFunction("RemoveChatCommand")]
	public void RemoveChatCommand(string command, Plugin plugin)
	{
		ChatCommand chatCommand = chatCommands.Values.Where((ChatCommand x) => x.Plugin == plugin).FirstOrDefault((ChatCommand x) => x.Name == command);
		if (chatCommand != null)
		{
			RemoveChatCommand(chatCommand);
		}
	}

	[LibraryFunction("RemoveConsoleCommand")]
	public void RemoveConsoleCommand(string command, Plugin plugin)
	{
		ConsoleCommand consoleCommand = consoleCommands.Values.Where((ConsoleCommand x) => x.Callback.Plugin == plugin).FirstOrDefault((ConsoleCommand x) => x.Name == command);
		if (consoleCommand != null)
		{
			RemoveConsoleCommand(consoleCommand);
		}
	}

	private void RemoveChatCommand(ChatCommand command)
	{
		if (chatCommands.ContainsKey(command.Name))
		{
			chatCommands.Remove(command.Name);
		}
	}

	private void RemoveConsoleCommand(ConsoleCommand command)
	{
		if (!consoleCommands.ContainsKey(command.Name))
		{
			return;
		}
		consoleCommands.Remove(command.Name);
		if (command.OriginalCallback != null)
		{
			Server.Dict[command.RustCommand.FullName].Call = command.OriginalCallback;
			if (command.RustCommand.FullName.StartsWith("global."))
			{
				Server.GlobalDict[command.RustCommand.Name].Call = command.OriginalCallback;
			}
			return;
		}
		Server.Dict.Remove(command.RustCommand.FullName);
		if (command.Name.StartsWith("global."))
		{
			Server.GlobalDict.Remove(command.RustCommand.Name);
		}
		Index.All = Server.Dict.Values.ToArray();
	}

	internal bool HandleChatCommand(BasePlayer sender, string name, string[] args)
	{
		if (chatCommands.TryGetValue(name.ToLowerInvariant(), out var value))
		{
			value.HandleCommand(sender, name, args);
			return true;
		}
		return false;
	}

	private void plugin_OnRemovedFromManager(Plugin sender, PluginManager manager)
	{
		ConsoleCommand[] array = consoleCommands.Values.Where((ConsoleCommand c) => c.Callback.Plugin == sender).ToArray();
		foreach (ConsoleCommand command in array)
		{
			RemoveConsoleCommand(command);
		}
		ChatCommand[] array2 = chatCommands.Values.Where((ChatCommand c) => c.Plugin == sender).ToArray();
		foreach (ChatCommand command2 in array2)
		{
			RemoveChatCommand(command2);
		}
		if (pluginRemovedFromManager.TryGetValue(sender, out var value))
		{
			value.Remove();
			pluginRemovedFromManager.Remove(sender);
		}
	}

	private bool CanOverrideCommand(string command, string type)
	{
		string[] array = command.Split(new char[1] { '.' });
		string text = ((array.Length >= 2) ? array[0].Trim() : "global");
		string text2 = ((array.Length >= 2) ? string.Join(".", array.Skip(1).ToArray()) : array[0].Trim());
		string text3 = text + "." + text2;
		if (RustCore.Covalence.CommandSystem.registeredCommands.TryGetValue(command, out var value) && value.Source.IsCorePlugin)
		{
			return false;
		}
		ConsoleCommand value3;
		if (type == "chat")
		{
			if (chatCommands.TryGetValue(command, out var value2) && value2.Plugin.IsCorePlugin)
			{
				return false;
			}
		}
		else if (type == "console" && consoleCommands.TryGetValue((text == "global") ? text2 : text3, out value3) && value3.Callback.Plugin.IsCorePlugin)
		{
			return false;
		}
		if (!RustCore.RestrictedCommands.Contains(command))
		{
			return !RustCore.RestrictedCommands.Contains(text3);
		}
		return false;
	}
}


using Oxide.Core.Libraries;
using Oxide.Game.Rust.Libraries.Covalence;

public class Item : Library
{
	internal static readonly RustCovalenceProvider Covalence = RustCovalenceProvider.Instance;

	public static Item GetItem(int itemId)
	{
		return ItemManager.CreateByItemID(itemId, 1, 0uL);
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text.RegularExpressions;
using Facepunch;
using Network;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Libraries;
using UnityEngine;

public class Player : Library
{
	private static readonly string ipPattern = ":{1}[0-9]{1}\\d*";

	internal readonly Permission permission = Interface.Oxide.GetLibrary<Permission>((string)null);

	public ListHashSet<BasePlayer> Players => BasePlayer.activePlayerList;

	public ListHashSet<BasePlayer> Sleepers => BasePlayer.sleepingPlayerList;

	public CultureInfo Language(BasePlayer player)
	{
		try
		{
			return CultureInfo.GetCultureInfo(((BaseNetworkable)player).net.connection.info.GetString("global.language", "en"));
		}
		catch (CultureNotFoundException)
		{
			return CultureInfo.GetCultureInfo("en");
		}
	}

	public string Address(Connection connection)
	{
		return Regex.Replace(connection.ipaddress, ipPattern, "");
	}

	public string Address(BasePlayer player)
	{
		object obj;
		if (player == null)
		{
			obj = null;
		}
		else
		{
			Networkable net = ((BaseNetworkable)player).net;
			obj = ((net != null) ? net.connection : null);
		}
		if (obj == null)
		{
			return null;
		}
		return Address(((BaseNetworkable)player).net.connection);
	}

	public int Ping(Connection connection)
	{
		return Net.sv.GetAveragePing(connection);
	}

	public int Ping(BasePlayer player)
	{
		return Ping(((BaseNetworkable)player).net.connection);
	}

	public bool IsAdmin(ulong id)
	{
		if (!ServerUsers.Is(id, (UserGroup)1))
		{
			return DeveloperList.Contains(id);
		}
		return true;
	}

	public bool IsAdmin(string id)
	{
		return IsAdmin(Convert.ToUInt64(id));
	}

	public bool IsAdmin(BasePlayer player)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return IsAdmin(EncryptedValue<ulong>.op_Implicit(player.userID));
	}

	public bool IsBanned(ulong id)
	{
		return ServerUsers.Is(id, (UserGroup)3);
	}

	public bool IsBanned(string id)
	{
		return IsBanned(Convert.ToUInt64(id));
	}

	public bool IsBanned(BasePlayer player)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return IsBanned(EncryptedValue<ulong>.op_Implicit(player.userID));
	}

	public bool IsConnected(BasePlayer player)
	{
		return player.IsConnected;
	}

	public bool IsSleeping(ulong id)
	{
		return Object.op_Implicit((Object)(object)BasePlayer.FindSleeping(id));
	}

	public bool IsSleeping(string id)
	{
		return IsSleeping(Convert.ToUInt64(id));
	}

	public bool IsSleeping(BasePlayer player)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return IsSleeping(EncryptedValue<ulong>.op_Implicit(player.userID));
	}

	public void Ban(ulong id, string reason = "", long expiry = -1L)
	{
		if (!IsBanned(id))
		{
			BasePlayer val = FindById(id);
			ServerUsers.Set(id, (UserGroup)3, ((val != null) ? val.displayName : null) ?? "Unknown", reason, expiry);
			ServerUsers.Save();
			if ((Object)(object)val != (Object)null && IsConnected(val))
			{
				Kick(val, reason);
			}
		}
	}

	public void Ban(string id, string reason = "", long expiry = -1L)
	{
		Ban(Convert.ToUInt64(id), reason, expiry);
	}

	public void Ban(BasePlayer player, string reason = "", long expiry = -1L)
	{
		Ban(player.UserIDString, reason, expiry);
	}

	public void Heal(BasePlayer player, float amount)
	{
		((BaseCombatEntity)player).Heal(amount);
	}

	public void Hurt(BasePlayer player, float amount)
	{
		((BaseCombatEntity)player).Hurt(amount);
	}

	public void Kick(BasePlayer player, string reason = "")
	{
		player.Kick(reason, true);
	}

	public void Kill(BasePlayer player)
	{
		((BaseCombatEntity)player).Die((HitInfo)null);
	}

	public void Rename(BasePlayer player, string name)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		name = (string.IsNullOrEmpty(name.Trim()) ? player.displayName : name);
		SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerName(EncryptedValue<ulong>.op_Implicit(player.userID), name);
		((BaseNetworkable)player).net.connection.username = name;
		player.displayName = name;
		((BaseEntity)player)._name = name;
		((BaseNetworkable)player).SendNetworkUpdateImmediate(false);
		player.IPlayer.Name = name;
		permission.UpdateNickname(player.UserIDString, name);
		if (((BaseNetworkable)player).net.group == BaseNetworkable.LimboNetworkGroup)
		{
			return;
		}
		List<Connection> list = Pool.Get<List<Connection>>();
		for (int i = 0; i < Net.sv.connections.Count; i++)
		{
			Connection val = Net.sv.connections[i];
			if (val.connected && val.isAuthenticated && val.player is BasePlayer && (Object)(object)val.player != (Object)(object)player)
			{
				list.Add(val);
			}
		}
		((BaseNetworkable)player).OnNetworkSubscribersLeave(list);
		Pool.FreeUnmanaged<Connection>(ref list);
		if (!((BaseNetworkable)player).limitNetworking)
		{
			((BaseEntity)player).syncPosition = false;
			((BaseNetworkable)player)._limitedNetworking = true;
			Interface.Oxide.NextTick((Action)delegate
			{
				((BaseEntity)player).syncPosition = true;
				((BaseNetworkable)player)._limitedNetworking = false;
				((BaseNetworkable)player).UpdateNetworkGroup();
				((BaseNetworkable)player).SendNetworkUpdate((NetworkQueue)0);
			});
		}
	}

	public void Teleport(BasePlayer player, Vector3 destination)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseCombatEntity)player).IsAlive() && !player.IsSpectating())
		{
			try
			{
				player.EnsureDismounted();
				((BaseEntity)player).SetParent((BaseEntity)null, true, true);
				player.SetServerFall(true);
				player.MovePosition(destination);
				((BaseEntity)player).ClientRPC(RpcTarget.Player("ForcePositionTo", player), destination);
			}
			finally
			{
				player.SetServerFall(false);
			}
		}
	}

	public void Teleport(BasePlayer player, BasePlayer target)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		Teleport(player, Position(target));
	}

	public void Teleport(BasePlayer player, float x, float y, float z)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		this.Teleport(player, new Vector3(x, y, z));
	}

	public void Unban(ulong id)
	{
		if (IsBanned(id))
		{
			ServerUsers.Remove(id);
			ServerUsers.Save();
		}
	}

	public void Unban(string id)
	{
		Unban(Convert.ToUInt64(id));
	}

	public void Unban(BasePlayer player)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Unban(EncryptedValue<ulong>.op_Implicit(player.userID));
	}

	public Vector3 Position(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)player).transform.position;
	}

	public BasePlayer Find(string nameOrIdOrIp)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = Players.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (nameOrIdOrIp.Equals(current.displayName, StringComparison.OrdinalIgnoreCase) || nameOrIdOrIp.Equals(current.UserIDString) || nameOrIdOrIp.Equals(((BaseNetworkable)current).net.connection.ipaddress))
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public BasePlayer FindById(string id)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = Players.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (id.Equals(current.UserIDString))
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public BasePlayer FindById(ulong id)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = Players.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (id.Equals(EncryptedValue<ulong>.op_Implicit(current.userID)))
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public void Message(BasePlayer player, string message, string prefix, ulong userId = 0uL, params object[] args)
	{
		if (!string.IsNullOrEmpty(message))
		{
			message = ((args.Length != 0) ? string.Format(Formatter.ToUnity(message), args) : Formatter.ToUnity(message));
			string text = ((prefix != null) ? (prefix + " " + message) : message);
			if (Interface.CallHook("OnMessagePlayer", (object)text, (object)player, (object)userId) == null)
			{
				player.SendConsoleCommand("chat.add", new object[3] { 2, userId, text });
			}
		}
	}

	public void Message(BasePlayer player, string message, ulong userId = 0uL)
	{
		Message(player, message, null, userId);
	}

	public void Reply(BasePlayer player, string message, string prefix, ulong userId = 0uL, params object[] args)
	{
		Message(player, message, prefix, userId, args);
	}

	public void Reply(BasePlayer player, string message, ulong userId = 0uL)
	{
		Message(player, message, null, userId);
	}

	public void Command(BasePlayer player, string command, params object[] args)
	{
		player.SendConsoleCommand(command, args);
	}

	public void DropItem(BasePlayer player, int itemId)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)player).transform.position;
		PlayerInventory val = Inventory(player);
		for (int i = 0; i < val.containerMain.capacity; i++)
		{
			Item slot = val.containerMain.GetSlot(i);
			if (slot.info.itemid == itemId)
			{
				slot.Drop(position + new Vector3(0f, 1f, 0f) + position / 2f, (position + new Vector3(0f, 0.2f, 0f)) * 8f, default(Quaternion));
			}
		}
		for (int j = 0; j < val.containerBelt.capacity; j++)
		{
			Item slot2 = val.containerBelt.GetSlot(j);
			if (slot2.info.itemid == itemId)
			{
				slot2.Drop(position + new Vector3(0f, 1f, 0f) + position / 2f, (position + new Vector3(0f, 0.2f, 0f)) * 8f, default(Quaternion));
			}
		}
		for (int k = 0; k < val.containerWear.capacity; k++)
		{
			Item slot3 = val.containerWear.GetSlot(k);
			if (slot3.info.itemid == itemId)
			{
				slot3.Drop(position + new Vector3(0f, 1f, 0f) + position / 2f, (position + new Vector3(0f, 0.2f, 0f)) * 8f, default(Quaternion));
			}
		}
	}

	public void DropItem(BasePlayer player, Item item)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)player).transform.position;
		PlayerInventory val = Inventory(player);
		for (int i = 0; i < val.containerMain.capacity; i++)
		{
			Item slot = val.containerMain.GetSlot(i);
			if (slot == item)
			{
				slot.Drop(position + new Vector3(0f, 1f, 0f) + position / 2f, (position + new Vector3(0f, 0.2f, 0f)) * 8f, default(Quaternion));
			}
		}
		for (int j = 0; j < val.containerBelt.capacity; j++)
		{
			Item slot2 = val.containerBelt.GetSlot(j);
			if (slot2 == item)
			{
				slot2.Drop(position + new Vector3(0f, 1f, 0f) + position / 2f, (position + new Vector3(0f, 0.2f, 0f)) * 8f, default(Quaternion));
			}
		}
		for (int k = 0; k < val.containerWear.capacity; k++)
		{
			Item slot3 = val.containerWear.GetSlot(k);
			if (slot3 == item)
			{
				slot3.Drop(position + new Vector3(0f, 1f, 0f) + position / 2f, (position + new Vector3(0f, 0.2f, 0f)) * 8f, default(Quaternion));
			}
		}
	}

	public void GiveItem(BasePlayer player, int itemId, int quantity = 1)
	{
		GiveItem(player, Item.GetItem(itemId), quantity);
	}

	public void GiveItem(BasePlayer player, Item item, int quantity = 1)
	{
		player.inventory.GiveItem(ItemManager.CreateByItemID(item.info.itemid, quantity, 0uL), (ItemContainer)null);
	}

	public PlayerInventory Inventory(BasePlayer player)
	{
		return player.inventory;
	}

	public void ClearInventory(BasePlayer player)
	{
		PlayerInventory obj = Inventory(player);
		if (obj != null)
		{
			obj.Strip();
		}
	}

	public void ResetInventory(BasePlayer player)
	{
		PlayerInventory val = Inventory(player);
		if ((Object)(object)val != (Object)null)
		{
			val.DoDestroy();
			val.ServerInit(player);
		}
	}
}


using System;
using System.Linq;
using System.Reflection;
using Network;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Game.Rust.Libraries;
using ProtoBuf;

public class Rust : Library
{
	internal readonly Player Player = new Player();

	internal readonly Server Server = new Server();

	public override bool IsGlobal => false;

	[LibraryFunction("PrivateBindingFlag")]
	public BindingFlags PrivateBindingFlag()
	{
		return BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
	}

	[LibraryFunction("QuoteSafe")]
	public string QuoteSafe(string str)
	{
		return ExtensionMethods.Quote(str);
	}

	[LibraryFunction("BroadcastChat")]
	public void BroadcastChat(string name, string message = null, string userId = "0")
	{
		Server.Broadcast(message, name, Convert.ToUInt64(userId));
	}

	[LibraryFunction("SendChatMessage")]
	public void SendChatMessage(BasePlayer player, string name, string message = null, string userId = "0")
	{
		Player.Message(player, message, name, Convert.ToUInt64(userId));
	}

	[LibraryFunction("RunClientCommand")]
	public void RunClientCommand(BasePlayer player, string command, params object[] args)
	{
		Player.Command(player, command, args);
	}

	[LibraryFunction("RunServerCommand")]
	public void RunServerCommand(string command, params object[] args)
	{
		Server.Command(command, args);
	}

	[LibraryFunction("UserIDFromConnection")]
	public string UserIDFromConnection(Connection connection)
	{
		return connection.userid.ToString();
	}

	[LibraryFunction("UserIDsFromBuildingPrivilege")]
	public Array UserIDsFromBuildingPrivlidge(BuildingPrivlidge priv)
	{
		return priv.authorizedPlayers.Select((PlayerNameID eid) => eid.userid.ToString()).ToArray();
	}

	[LibraryFunction("UserIDFromPlayer")]
	public string UserIDFromPlayer(BasePlayer player)
	{
		return player.UserIDString;
	}

	[LibraryFunction("OwnerIDFromEntity")]
	public string OwnerIDFromEntity(BaseEntity entity)
	{
		return entity.OwnerID.ToString();
	}

	[LibraryFunction("FindPlayer")]
	public BasePlayer FindPlayer(string nameOrIdOrIp)
	{
		return Player.Find(nameOrIdOrIp);
	}

	[LibraryFunction("FindPlayerByName")]
	public BasePlayer FindPlayerByName(string name)
	{
		return Player.Find(name);
	}

	[LibraryFunction("FindPlayerById")]
	public BasePlayer FindPlayerById(ulong id)
	{
		return Player.FindById(id);
	}

	[LibraryFunction("FindPlayerByIdString")]
	public BasePlayer FindPlayerByIdString(string id)
	{
		return Player.FindById(id);
	}

	[LibraryFunction("ForcePlayerPosition")]
	public void ForcePlayerPosition(BasePlayer player, float x, float y, float z)
	{
		Player.Teleport(player, x, y, z);
	}
}


using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;

public class Server : Library
{
	public void Broadcast(string message, string prefix, ulong userId = 0uL, params object[] args)
	{
		if (!string.IsNullOrEmpty(message))
		{
			message = ((args.Length != 0) ? string.Format(Formatter.ToUnity(message), args) : Formatter.ToUnity(message));
			string text = ((prefix != null) ? (prefix + ": " + message) : message);
			ConsoleNetwork.BroadcastToAllClients("chat.add", new object[3] { 2, userId, text });
		}
	}

	public void Broadcast(string message, ulong userId = 0uL)
	{
		Broadcast(message, null, userId);
	}

	public void Command(string command, params object[] args)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		ConsoleSystem.Run(Option.Server, command, args);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Libraries;
using Oxide.Game.Rust.Libraries.Covalence;
using UnityEngine;

public class RustCommandSystem : ICommandSystem
{
	internal class RegisteredCommand
	{
		public readonly Plugin Source;

		public readonly string Command;

		public readonly CommandCallback Callback;

		public Command RustCommand;

		public Command OriginalRustCommand;

		public Action<Arg> OriginalCallback;

		public RegisteredCommand(Plugin source, string command, CommandCallback callback)
		{
			Source = source;
			Command = command;
			Callback = callback;
		}
	}

	private readonly Command cmdlib = Interface.Oxide.GetLibrary<Command>((string)null);

	private readonly RustConsolePlayer consolePlayer;

	private readonly CommandHandler commandHandler;

	internal IDictionary<string, RegisteredCommand> registeredCommands;

	public RustCommandSystem()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Expected O, but got Unknown
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Expected O, but got Unknown
		registeredCommands = new Dictionary<string, RegisteredCommand>();
		commandHandler = new CommandHandler(new CommandCallback(CommandCallback), (Func<string, bool>)registeredCommands.ContainsKey);
		consolePlayer = new RustConsolePlayer();
	}

	private bool CommandCallback(IPlayer caller, string cmd, string[] args)
	{
		if (registeredCommands.TryGetValue(cmd, out var value))
		{
			return value.Callback.Invoke(caller, cmd, args);
		}
		return false;
	}

	public void RegisterCommand(string command, Plugin plugin, CommandCallback callback)
	{
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0403: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0411: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0436: Expected O, but got Unknown
		command = command.ToLowerInvariant().Trim();
		string[] array = command.Split(new char[1] { '.' });
		string text = ((array.Length >= 2) ? array[0].Trim() : "global");
		string text2 = ((array.Length >= 2) ? string.Join(".", array.Skip(1).ToArray()) : array[0].Trim());
		string text3 = text + "." + text2;
		if (text == "global")
		{
			command = text2;
		}
		RegisteredCommand registeredCommand = new RegisteredCommand(plugin, command, callback);
		if (!CanOverrideCommand(command))
		{
			throw new CommandAlreadyExistsException(command);
		}
		if (registeredCommands.TryGetValue(command, out var value))
		{
			if (value.OriginalCallback != null)
			{
				registeredCommand.OriginalCallback = value.OriginalCallback;
			}
			Plugin source = value.Source;
			string text4 = ((source != null) ? source.Name : null) ?? "an unknown plugin";
			string text5 = ((plugin != null) ? plugin.Name : null) ?? "An unknown plugin";
			string text6 = text5 + " has replaced the '" + command + "' command previously registered by " + text4;
			Interface.Oxide.LogWarning(text6, Array.Empty<object>());
			Server.Dict.Remove(text3);
			if (text == "global")
			{
				Server.GlobalDict.Remove(text2);
			}
			Index.All = Server.Dict.Values.ToArray();
		}
		if (cmdlib.chatCommands.TryGetValue(command, out var value2))
		{
			Plugin plugin2 = value2.Plugin;
			string text7 = ((plugin2 != null) ? plugin2.Name : null) ?? "an unknown plugin";
			string text8 = ((plugin != null) ? plugin.Name : null) ?? "An unknown plugin";
			string text9 = text8 + " has replaced the '" + command + "' chat command previously registered by " + text7;
			Interface.Oxide.LogWarning(text9, Array.Empty<object>());
			cmdlib.chatCommands.Remove(command);
		}
		if (cmdlib.consoleCommands.TryGetValue(text3, out var value3))
		{
			if (value3.OriginalCallback != null)
			{
				registeredCommand.OriginalCallback = value3.OriginalCallback;
			}
			Plugin plugin3 = value3.Callback.Plugin;
			string text10 = ((plugin3 != null) ? plugin3.Name : null) ?? "an unknown plugin";
			string text11 = ((plugin != null) ? plugin.Name : null) ?? "An unknown plugin";
			string text12 = text11 + " has replaced the '" + text3 + "' console command previously registered by " + text10;
			Interface.Oxide.LogWarning(text12, Array.Empty<object>());
			Server.Dict.Remove(value3.RustCommand.FullName);
			if (text == "global")
			{
				Server.GlobalDict.Remove(value3.RustCommand.Name);
			}
			Index.All = Server.Dict.Values.ToArray();
			cmdlib.consoleCommands.Remove(value3.RustCommand.FullName);
		}
		if (Server.Dict.TryGetValue(text3, out var value4))
		{
			if (value4.Variable)
			{
				string text13 = ((plugin != null) ? plugin.Name : null) ?? "An unknown plugin";
				Interface.Oxide.LogError(text13 + " tried to register the " + text3 + " console variable as a command!", Array.Empty<object>());
				return;
			}
			registeredCommand.OriginalCallback = value4.Call;
			registeredCommand.OriginalRustCommand = value4;
		}
		registeredCommand.RustCommand = new Command
		{
			Name = text2,
			Parent = text,
			FullName = command,
			ServerUser = true,
			ServerAdmin = true,
			Client = true,
			ClientInfo = false,
			Variable = false,
			Call = delegate(Arg arg)
			{
				if (arg != null)
				{
					BasePlayer val = ArgEx.Player(arg);
					if (arg.Connection != null && (Object)(object)val != (Object)null)
					{
						if (val.IPlayer is RustPlayer rustPlayer)
						{
							rustPlayer.LastCommand = (CommandType)1;
							callback.Invoke((IPlayer)(object)rustPlayer, command, ExtractArgs(arg));
						}
					}
					else if (arg.Connection == null)
					{
						consolePlayer.LastCommand = (CommandType)1;
						callback.Invoke((IPlayer)(object)consolePlayer, command, ExtractArgs(arg));
					}
				}
			}
		};
		Server.Dict[text3] = registeredCommand.RustCommand;
		if (text == "global")
		{
			Server.GlobalDict[text2] = registeredCommand.RustCommand;
		}
		Index.All = Server.Dict.Values.ToArray();
		registeredCommands[command] = registeredCommand;
	}

	public void UnregisterCommand(string command, Plugin plugin)
	{
		if (!registeredCommands.TryGetValue(command, out var value) || plugin != value.Source)
		{
			return;
		}
		string[] array = command.Split(new char[1] { '.' });
		string obj = ((array.Length >= 2) ? array[0].Trim() : "global");
		string text = ((array.Length >= 2) ? string.Join(".", array.Skip(1).ToArray()) : array[0].Trim());
		string text2 = obj + "." + text;
		registeredCommands.Remove(command);
		if (value.OriginalCallback != null)
		{
			if (Server.Dict.ContainsKey(text2))
			{
				Server.Dict[text2].Call = value.OriginalCallback;
			}
			if (text2.StartsWith("global.") && Server.GlobalDict.ContainsKey(text))
			{
				Server.GlobalDict[text].Call = value.OriginalCallback;
			}
			if (value.OriginalRustCommand != null)
			{
				if (Server.Dict.ContainsKey(text2))
				{
					Server.Dict[text2] = value.OriginalRustCommand;
				}
				if (text2.StartsWith("global.") && Server.GlobalDict.ContainsKey(text))
				{
					Server.GlobalDict[text] = value.OriginalRustCommand;
				}
			}
		}
		else
		{
			Server.Dict.Remove(text2);
			if (text2.StartsWith("global."))
			{
				Server.GlobalDict.Remove(text);
			}
		}
		Index.All = Server.Dict.Values.ToArray();
	}

	public bool HandleChatMessage(IPlayer player, string message)
	{
		return commandHandler.HandleChatMessage(player, message);
	}

	private bool CanOverrideCommand(string command)
	{
		string[] array = command.Split(new char[1] { '.' });
		string obj = ((array.Length >= 2) ? array[0].Trim() : "global");
		string text = ((array.Length >= 2) ? string.Join(".", array.Skip(1).ToArray()) : array[0].Trim());
		string text2 = obj + "." + text;
		if (registeredCommands.TryGetValue(command, out var value) && value.Source.IsCorePlugin)
		{
			return false;
		}
		if (cmdlib.chatCommands.TryGetValue(command, out var value2) && value2.Plugin.IsCorePlugin)
		{
			return false;
		}
		if (cmdlib.consoleCommands.TryGetValue(text2, out var value3) && value3.Callback.Plugin.IsCorePlugin)
		{
			return false;
		}
		if (!RustCore.RestrictedCommands.Contains(command))
		{
			return !RustCore.RestrictedCommands.Contains(text2);
		}
		return false;
	}

	public static string[] ExtractArgs(Arg arg)
	{
		if (arg == null || !arg.HasArgs(1))
		{
			return new string[0];
		}
		return StringExtensions.SplitQuotesStrings(arg.FullString, int.MaxValue);
	}
}


using System;
using System.Globalization;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

public class RustConsolePlayer : IPlayer
{
	public object Object => null;

	public CommandType LastCommand
	{
		get
		{
			return (CommandType)1;
		}
		set
		{
		}
	}

	public string Name
	{
		get
		{
			return "Server Console";
		}
		set
		{
		}
	}

	public string Id => "server_console";

	public CultureInfo Language => CultureInfo.InstalledUICulture;

	public string Address => "127.0.0.1";

	public int Ping => 0;

	public bool IsAdmin => true;

	public bool IsBanned => false;

	public bool IsConnected => true;

	public bool IsSleeping => false;

	public bool IsServer => true;

	public TimeSpan BanTimeRemaining => TimeSpan.Zero;

	public float Health { get; set; }

	public float MaxHealth { get; set; }

	public void Ban(string reason, TimeSpan duration)
	{
	}

	public void Heal(float amount)
	{
	}

	public void Hurt(float amount)
	{
	}

	public void Kick(string reason)
	{
	}

	public void Kill()
	{
	}

	public void Rename(string name)
	{
	}

	public void Teleport(float x, float y, float z)
	{
	}

	public void Teleport(GenericPosition pos)
	{
		Teleport(pos.X, pos.Y, pos.Z);
	}

	public void Unban()
	{
	}

	public void Position(out float x, out float y, out float z)
	{
		x = 0f;
		y = 0f;
		z = 0f;
	}

	public GenericPosition Position()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Expected O, but got Unknown
		return new GenericPosition(0f, 0f, 0f);
	}

	public void Message(string message, string prefix, params object[] args)
	{
		message = ((args.Length != 0) ? string.Format(Formatter.ToPlaintext(message), args) : Formatter.ToPlaintext(message));
		string text = ((prefix != null) ? (prefix + " " + message) : message);
		Interface.Oxide.LogInfo(text, Array.Empty<object>());
	}

	public void Message(string message)
	{
		Message(message, null);
	}

	public void Reply(string message, string prefix, params object[] args)
	{
		Message(message, prefix, args);
	}

	public void Reply(string message)
	{
		Message(message, null);
	}

	public void Command(string command, params object[] args)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		ConsoleSystem.Run(Option.Server, command, args);
	}

	public bool HasPermission(string perm)
	{
		return true;
	}

	public void GrantPermission(string perm)
	{
	}

	public void RevokePermission(string perm)
	{
	}

	public bool BelongsToGroup(string group)
	{
		return false;
	}

	public void AddToGroup(string group)
	{
	}

	public void RemoveFromGroup(string group)
	{
	}
}


using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Libraries.Covalence;

public class RustCovalenceProvider : ICovalenceProvider
{
	public string GameName => "Rust";

	public uint ClientAppId => 252490u;

	public uint ServerAppId => 258550u;

	internal static RustCovalenceProvider Instance { get; private set; }

	public RustPlayerManager PlayerManager { get; private set; }

	public RustCommandSystem CommandSystem { get; private set; }

	public RustCovalenceProvider()
	{
		Instance = this;
	}

	public IServer CreateServer()
	{
		return (IServer)(object)new RustServer();
	}

	public IPlayerManager CreatePlayerManager()
	{
		PlayerManager = new RustPlayerManager();
		PlayerManager.Initialize();
		return (IPlayerManager)(object)PlayerManager;
	}

	public ICommandSystem CreateCommandSystemProvider()
	{
		return (ICommandSystem)(object)(CommandSystem = new RustCommandSystem());
	}

	public string FormatText(string text)
	{
		return Formatter.ToUnity(text);
	}
}


using System;
using System.Globalization;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Libraries;
using UnityEngine;

public class RustPlayer : IPlayer, IEquatable<IPlayer>
{
	private static Player libPlayer;

	private static Permission libPerms;

	private readonly BasePlayer player;

	private readonly ulong steamId;

	public object Object => player;

	public CommandType LastCommand { get; set; }

	public string Name { get; set; }

	public string Id { get; }

	public CultureInfo Language
	{
		get
		{
			if (!((Object)(object)player != (Object)null))
			{
				return CultureInfo.GetCultureInfo("en");
			}
			return libPlayer.Language(player);
		}
	}

	public string Address
	{
		get
		{
			if (!((Object)(object)player != (Object)null))
			{
				return "0.0.0.0";
			}
			return libPlayer.Address(player);
		}
	}

	public int Ping
	{
		get
		{
			if (!((Object)(object)player != (Object)null))
			{
				return 0;
			}
			return libPlayer.Ping(player);
		}
	}

	public bool IsAdmin => libPlayer.IsAdmin(steamId);

	public bool IsBanned => libPlayer.IsBanned(steamId);

	public bool IsConnected
	{
		get
		{
			if (!((Object)(object)player != (Object)null))
			{
				return (Object)(object)BasePlayer.FindByID(steamId) != (Object)null;
			}
			return libPlayer.IsConnected(player);
		}
	}

	public bool IsSleeping
	{
		get
		{
			if (!((Object)(object)player != (Object)null))
			{
				return (Object)(object)BasePlayer.FindSleeping(steamId) != (Object)null;
			}
			return libPlayer.IsSleeping(player);
		}
	}

	public bool IsServer => false;

	public TimeSpan BanTimeRemaining
	{
		get
		{
			if (!IsBanned)
			{
				return TimeSpan.Zero;
			}
			return TimeSpan.MaxValue;
		}
	}

	public float Health
	{
		get
		{
			return ((BaseCombatEntity)player).health;
		}
		set
		{
			((BaseCombatEntity)player).health = value;
		}
	}

	public float MaxHealth
	{
		get
		{
			return ((BaseEntity)player).MaxHealth();
		}
		set
		{
			((BaseCombatEntity)player)._maxHealth = value;
		}
	}

	internal RustPlayer(ulong id, string name)
	{
		if (libPerms == null)
		{
			libPerms = Interface.Oxide.GetLibrary<Permission>((string)null);
		}
		if (libPlayer == null)
		{
			libPlayer = Interface.Oxide.GetLibrary<Player>((string)null);
		}
		steamId = id;
		Name = ExtensionMethods.Sanitize(name);
		Id = id.ToString();
	}

	internal RustPlayer(BasePlayer player)
		: this(EncryptedValue<ulong>.op_Implicit(player.userID), player.displayName)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		this.player = player;
	}

	public void Ban(string reason, TimeSpan duration = default(TimeSpan))
	{
		libPlayer.Ban(steamId, reason, -1L);
	}

	public void Heal(float amount)
	{
		libPlayer.Heal(player, amount);
	}

	public void Hurt(float amount)
	{
		libPlayer.Hurt(player, amount);
	}

	public void Kick(string reason)
	{
		libPlayer.Kick(player, reason);
	}

	public void Kill()
	{
		libPlayer.Kill(player);
	}

	public void Rename(string name)
	{
		libPlayer.Rename(player, name);
	}

	public void Teleport(float x, float y, float z)
	{
		libPlayer.Teleport(player, x, y, z);
	}

	public void Teleport(GenericPosition pos)
	{
		Teleport(pos.X, pos.Y, pos.Z);
	}

	public void Unban()
	{
		libPlayer.Unban(steamId);
	}

	public void Position(out float x, out float y, out float z)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = libPlayer.Position(player);
		x = val.x;
		y = val.y;
		z = val.z;
	}

	public GenericPosition Position()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Expected O, but got Unknown
		Vector3 val = libPlayer.Position(player);
		return new GenericPosition(val.x, val.y, val.z);
	}

	public void Message(string message, string prefix, params object[] args)
	{
		libPlayer.Message(player, message, prefix, 0uL, args);
	}

	public void Message(string message)
	{
		Message(message, null);
	}

	public void Reply(string message, string prefix, params object[] args)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Invalid comparison between Unknown and I4
		CommandType lastCommand = LastCommand;
		if ((int)lastCommand != 0)
		{
			if ((int)lastCommand == 1)
			{
				player.ConsoleMessage(string.Format(Formatter.ToPlaintext(message), args));
			}
		}
		else
		{
			Message(message, prefix, args);
		}
	}

	public void Reply(string message)
	{
		Reply(message, null);
	}

	public void Command(string command, params object[] args)
	{
		player.SendConsoleCommand(command, args);
	}

	public bool HasPermission(string perm)
	{
		return libPerms.UserHasPermission(Id, perm);
	}

	public void GrantPermission(string perm)
	{
		libPerms.GrantUserPermission(Id, perm, (Plugin)null);
	}

	public void RevokePermission(string perm)
	{
		libPerms.RevokeUserPermission(Id, perm);
	}

	public bool BelongsToGroup(string group)
	{
		return libPerms.UserHasGroup(Id, group);
	}

	public void AddToGroup(string group)
	{
		libPerms.AddUserGroup(Id, group);
	}

	public void RemoveFromGroup(string group)
	{
		libPerms.RemoveUserGroup(Id, group);
	}

	public bool Equals(IPlayer other)
	{
		return Id == ((other != null) ? other.Id : null);
	}

	public override bool Equals(object obj)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (obj is IPlayer)
		{
			return Id == ((IPlayer)obj).Id;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return Id.GetHashCode();
	}

	public override string ToString()
	{
		return "Covalence.RustPlayer[" + Id + ", " + Name + "]";
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Libraries.Covalence;
using ProtoBuf;

public class RustPlayerManager : IPlayerManager
{
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	private struct PlayerRecord
	{
		public string Name;

		public ulong Id;
	}

	private IDictionary<string, PlayerRecord> playerData;

	private IDictionary<string, RustPlayer> allPlayers;

	private IDictionary<string, RustPlayer> connectedPlayers;

	public IEnumerable<IPlayer> All => allPlayers.Values.Cast<IPlayer>();

	public IEnumerable<IPlayer> Connected => connectedPlayers.Values.Cast<IPlayer>();

	public IEnumerable<IPlayer> Sleeping => ((IEnumerable<BasePlayer>)BasePlayer.sleepingPlayerList).Select((BasePlayer p) => p.IPlayer);

	internal void Initialize()
	{
		Utility.DatafileToProto<Dictionary<string, PlayerRecord>>("oxide.covalence", true);
		playerData = ProtoStorage.Load<Dictionary<string, PlayerRecord>>(new string[1] { "oxide.covalence" }) ?? new Dictionary<string, PlayerRecord>();
		allPlayers = new Dictionary<string, RustPlayer>();
		connectedPlayers = new Dictionary<string, RustPlayer>();
		foreach (KeyValuePair<string, PlayerRecord> playerDatum in playerData)
		{
			allPlayers.Add(playerDatum.Key, new RustPlayer(playerDatum.Value.Id, playerDatum.Value.Name));
		}
	}

	internal void PlayerJoin(ulong userId, string name)
	{
		string key = userId.ToString();
		if (playerData.TryGetValue(key, out var value))
		{
			value.Name = name;
			playerData[key] = value;
			allPlayers.Remove(key);
			allPlayers.Add(key, new RustPlayer(userId, name));
		}
		else
		{
			PlayerRecord playerRecord = default(PlayerRecord);
			playerRecord.Id = userId;
			playerRecord.Name = name;
			value = playerRecord;
			playerData.Add(key, value);
			allPlayers.Add(key, new RustPlayer(userId, name));
		}
	}

	internal void PlayerConnected(BasePlayer player)
	{
		allPlayers[player.UserIDString] = new RustPlayer(player);
		connectedPlayers[player.UserIDString] = new RustPlayer(player);
	}

	internal void PlayerDisconnected(BasePlayer player)
	{
		connectedPlayers.Remove(player.UserIDString);
	}

	internal void SavePlayerData()
	{
		ProtoStorage.Save<IDictionary<string, PlayerRecord>>(playerData, new string[1] { "oxide.covalence" });
	}

	public IPlayer FindPlayerById(string id)
	{
		if (!allPlayers.TryGetValue(id, out var value))
		{
			return null;
		}
		return (IPlayer)(object)value;
	}

	public IPlayer FindPlayerByObj(object obj)
	{
		return (IPlayer)(object)connectedPlayers.Values.FirstOrDefault((RustPlayer p) => p.Object == obj);
	}

	public IPlayer FindPlayer(string partialNameOrId)
	{
		IPlayer[] array = FindPlayers(partialNameOrId).ToArray();
		if (array.Length != 1)
		{
			return null;
		}
		return array[0];
	}

	public IEnumerable<IPlayer> FindPlayers(string partialNameOrId)
	{
		List<IPlayer> list = new List<IPlayer>();
		foreach (RustPlayer value in connectedPlayers.Values)
		{
			if (value.Name.Equals(partialNameOrId, StringComparison.OrdinalIgnoreCase) || value.Id == partialNameOrId)
			{
				list = new List<IPlayer> { (IPlayer)(object)value };
				break;
			}
			if (value.Name.IndexOf(partialNameOrId, StringComparison.OrdinalIgnoreCase) >= 0)
			{
				list.Add((IPlayer)(object)value);
			}
		}
		if (list.Count() > 0)
		{
			return list;
		}
		foreach (RustPlayer value2 in allPlayers.Values)
		{
			if (value2.Name.Equals(partialNameOrId, StringComparison.OrdinalIgnoreCase) || value2.Id == partialNameOrId)
			{
				list = new List<IPlayer> { (IPlayer)(object)value2 };
				break;
			}
			if (value2.Name.IndexOf(partialNameOrId, StringComparison.OrdinalIgnoreCase) >= 0)
			{
				list.Add((IPlayer)(object)value2);
			}
		}
		return list;
	}
}


using System;
using System.Globalization;
using System.IO;
using System.Net;
using ConVar;
using Facepunch;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Libraries;
using Rust;

public class RustServer : IServer
{
	internal readonly Server Server = new Server();

	private static IPAddress address;

	private static IPAddress localAddress;

	public string Name
	{
		get
		{
			return Server.hostname;
		}
		set
		{
			Server.hostname = value;
		}
	}

	public IPAddress Address
	{
		get
		{
			try
			{
				if (address == null || !Utility.ValidateIPv4(address.ToString()))
				{
					if (Utility.ValidateIPv4(Server.ip) && !Utility.IsLocalIP(Server.ip))
					{
						IPAddress.TryParse(Server.ip, out address);
						Interface.Oxide.LogInfo($"IP address from command-line: {address}", Array.Empty<object>());
					}
					else
					{
						IPAddress.TryParse(new WebClient().DownloadString("http://api.ipify.org"), out address);
						Interface.Oxide.LogInfo($"IP address from external API: {address}", Array.Empty<object>());
					}
				}
				return address;
			}
			catch (Exception ex)
			{
				RemoteLogger.Exception("Couldn't get server's public IP address", ex);
				return IPAddress.Any;
			}
		}
	}

	public IPAddress LocalAddress
	{
		get
		{
			try
			{
				return localAddress ?? (localAddress = Utility.GetLocalIP());
			}
			catch (Exception ex)
			{
				RemoteLogger.Exception("Couldn't get server's local IP address", ex);
				return IPAddress.Any;
			}
		}
	}

	public ushort Port => (ushort)Server.port;

	public string Version => BuildInfo.Current.Build.Number;

	public string Protocol => Protocol.printable;

	public CultureInfo Language => CultureInfo.InstalledUICulture;

	public int Players => BasePlayer.activePlayerList.Count;

	public int MaxPlayers
	{
		get
		{
			return Server.maxplayers;
		}
		set
		{
			Server.maxplayers = value;
		}
	}

	public DateTime Time
	{
		get
		{
			return TOD_Sky.Instance.Cycle.DateTime;
		}
		set
		{
			TOD_Sky.Instance.Cycle.DateTime = value;
		}
	}

	public SaveInfo SaveInfo { get; } = SaveInfo.Create(World.SaveFileName);

	public void Ban(string id, string reason, TimeSpan duration = default(TimeSpan))
	{
		if (!IsBanned(id))
		{
			long num = -1L;
			if (duration != TimeSpan.Zero)
			{
				num = new DateTimeOffset(DateTime.UtcNow.Add(duration)).ToUnixTimeSeconds();
			}
			ServerUsers.Set(ulong.Parse(id), (UserGroup)3, Name, reason, num);
			ServerUsers.Save();
		}
	}

	public TimeSpan BanTimeRemaining(string id)
	{
		if (!IsBanned(id))
		{
			return TimeSpan.Zero;
		}
		return TimeSpan.MaxValue;
	}

	public bool IsBanned(string id)
	{
		return ServerUsers.Is(ulong.Parse(id), (UserGroup)3);
	}

	public void Save()
	{
		Server.save((Arg)null);
		File.WriteAllText(Server.GetServerFolder("cfg") + "/serverauto.cfg", ConsoleSystem.SaveToConfigString(true));
		ServerUsers.Save();
	}

	public void Unban(string id)
	{
		if (IsBanned(id))
		{
			ServerUsers.Remove(ulong.Parse(id));
			ServerUsers.Save();
		}
	}

	public void Broadcast(string message, string prefix, params object[] args)
	{
		Server.Broadcast(message, prefix, 0uL, args);
	}

	public void Broadcast(string message)
	{
		Broadcast(message, null);
	}

	public void Command(string command, params object[] args)
	{
		Server.Command(command, args);
	}
}


using System;
using Oxide.Core.Plugins;

internal struct PluginCallback
{
	public readonly Plugin Plugin;

	public readonly string Name;

	public Func<Arg, bool> Call;

	public PluginCallback(Plugin plugin, string name)
	{
		Plugin = plugin;
		Name = name;
		Call = null;
	}

	public PluginCallback(Plugin plugin, Func<Arg, bool> callback)
	{
		Plugin = plugin;
		Call = callback;
		Name = null;
	}
}


using System;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;

internal class ConsoleCommand
{
	public readonly string Name;

	public PluginCallback Callback;

	public readonly Command RustCommand;

	public Action<Arg> OriginalCallback;

	internal readonly Permission permission = Interface.Oxide.GetLibrary<Permission>((string)null);

	public ConsoleCommand(string name)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Expected O, but got Unknown
		Name = name;
		string[] array = Name.Split(new char[1] { '.' });
		RustCommand = new Command
		{
			Name = array[1],
			Parent = array[0],
			FullName = name,
			ServerUser = true,
			ServerAdmin = true,
			Client = true,
			ClientInfo = false,
			Variable = false,
			Call = HandleCommand
		};
	}

	public void AddCallback(Plugin plugin, string name)
	{
		Callback = new PluginCallback(plugin, name);
	}

	public void AddCallback(Plugin plugin, Func<Arg, bool> callback)
	{
		Callback = new PluginCallback(plugin, callback);
	}

	public void HandleCommand(Arg arg)
	{
		Plugin plugin = Callback.Plugin;
		if (plugin != null)
		{
			plugin.TrackStart();
		}
		Callback.Call(arg);
		Plugin plugin2 = Callback.Plugin;
		if (plugin2 != null)
		{
			plugin2.TrackEnd();
		}
	}
}


using System;
using Oxide.Core.Plugins;

internal class ChatCommand
{
	public readonly string Name;

	public readonly Plugin Plugin;

	private readonly Action<BasePlayer, string, string[]> _callback;

	public ChatCommand(string name, Plugin plugin, Action<BasePlayer, string, string[]> callback)
	{
		Name = name;
		Plugin = plugin;
		_callback = callback;
	}

	public void HandleCommand(BasePlayer sender, string name, string[] args)
	{
		Plugin plugin = Plugin;
		if (plugin != null)
		{
			plugin.TrackStart();
		}
		_callback?.Invoke(sender, name, args);
		Plugin plugin2 = Plugin;
		if (plugin2 != null)
		{
			plugin2.TrackEnd();
		}
	}
}


using System;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

internal class RegisteredCommand
{
	public readonly Plugin Source;

	public readonly string Command;

	public readonly CommandCallback Callback;

	public Command RustCommand;

	public Command OriginalRustCommand;

	public Action<Arg> OriginalCallback;

	public RegisteredCommand(Plugin source, string command, CommandCallback callback)
	{
		Source = source;
		Command = command;
		Callback = callback;
	}
}


using ProtoBuf;

[ProtoContract(/*Could not decode attribute arguments.*/)]
private struct PlayerRecord
{
	public string Name;

	public ulong Id;
}


