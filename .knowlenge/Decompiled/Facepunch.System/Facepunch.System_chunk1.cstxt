using System;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;

[CompilerGenerated]
[Embedded]
internal sealed class IsUnmanagedAttribute : Attribute
{
}


using System.Runtime.CompilerServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

public static class BurstUtil
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static ref readonly T GetReadonly<T>(this in NativeArray<T> array, int index) where T : unmanaged
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		T* unsafeReadOnlyPtr = (T*)NativeArrayUnsafeUtility.GetUnsafeReadOnlyPtr<T>(array);
		return ref unsafeReadOnlyPtr[index];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static ref readonly T GetReadonly<T>(this in ReadOnly<T> array, int index) where T : unmanaged
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		T* unsafeReadOnlyPtr = (T*)NativeArrayUnsafeUtility.GetUnsafeReadOnlyPtr<T>(array);
		return ref unsafeReadOnlyPtr[index];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static ref T Get<T>(this in NativeArray<T> array, int index) where T : unmanaged
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		T* unsafePtr = (T*)NativeArrayUnsafeUtility.GetUnsafePtr<T>(array);
		return ref unsafePtr[index];
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

public class BufferList<T> : IEnumerable<T>, IEnumerable
{
	public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
	{
		private readonly BufferList<T> list;

		private int index;

		public T Current => list[index];

		object IEnumerator.Current => Current;

		public Enumerator(BufferList<T> list)
		{
			this.list = list;
			index = -1;
		}

		public bool MoveNext()
		{
			index++;
			return index < list.Count;
		}

		public void Reset()
		{
			index = -1;
		}

		public void Dispose()
		{
		}
	}

	private int count;

	private T[] buffer;

	public int Count => count;

	public int Capacity => buffer.Length;

	public T[] Buffer => buffer;

	public T this[int index]
	{
		get
		{
			return buffer[index];
		}
		set
		{
			buffer[index] = value;
		}
	}

	public BufferList()
	{
		buffer = Array.Empty<T>();
	}

	public BufferList(int capacity)
	{
		buffer = ((capacity == 0) ? Array.Empty<T>() : new T[capacity]);
	}

	public void Push(T element)
	{
		Add(element);
	}

	public T Pop()
	{
		if (count == 0)
		{
			return default(T);
		}
		T result = buffer[count - 1];
		buffer[count - 1] = default(T);
		count--;
		return result;
	}

	public void Add(T element)
	{
		if (count == buffer.Length)
		{
			Resize(Math.Max(buffer.Length * 2, 8));
		}
		buffer[count] = element;
		count++;
	}

	public void AddRange(BufferList<T> elements)
	{
		if (count + elements.count > buffer.Length)
		{
			Resize(Math.Max(count + elements.count, 8));
		}
		Array.Copy(elements.buffer, 0, buffer, count, elements.count);
		count += elements.count;
	}

	public bool Remove(T element)
	{
		int num = Array.IndexOf(buffer, element);
		if (num == -1)
		{
			return false;
		}
		RemoveAt(num);
		return true;
	}

	public void RemoveAt(int index)
	{
		for (int i = index; i < count - 1; i++)
		{
			buffer[i] = buffer[i + 1];
		}
		buffer[count - 1] = default(T);
		count--;
	}

	public void RemoveUnordered(int index)
	{
		buffer[index] = buffer[count - 1];
		buffer[count - 1] = default(T);
		count--;
	}

	public void CopyFrom(T[] array)
	{
		int num = array.Length;
		if (num > buffer.Length)
		{
			Resize(num);
		}
		Array.Copy(array, buffer, num);
		if (num < count)
		{
			Array.Clear(buffer, num, count - num);
		}
		count = num;
	}

	public void CopyFrom(List<T> list)
	{
		int num = list.Count;
		if (num > buffer.Length)
		{
			Resize(num);
		}
		list.CopyTo(buffer);
		if (num < count)
		{
			Array.Clear(buffer, num, count - num);
		}
		count = num;
	}

	public int IndexOf(T element)
	{
		return Array.IndexOf(buffer, element);
	}

	public int LastIndexOf(T element)
	{
		return Array.LastIndexOf(buffer, element);
	}

	public bool Contains(T element)
	{
		return Array.IndexOf(buffer, element) != -1;
	}

	public void Clear()
	{
		if (count != 0)
		{
			Array.Clear(buffer, 0, count);
			count = 0;
		}
	}

	public void Resize(int newSize)
	{
		Array.Resize(ref buffer, newSize);
	}

	public ReadOnlySpan<T> ContentReadOnlySpan()
	{
		return new ReadOnlySpan<T>(Buffer, 0, count);
	}

	public Span<T> ContentSpan()
	{
		return new Span<T>(Buffer, 0, count);
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(this);
	}

	IEnumerator<T> IEnumerable<T>.GetEnumerator()
	{
		return GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;

public class Deque<T>
{
	private T[] buffer;

	private int offset;

	private int count;

	public T this[int index]
	{
		get
		{
			return buffer[(offset + index) % buffer.Length];
		}
		set
		{
			buffer[(offset + index) % buffer.Length] = value;
		}
	}

	public int Count => count;

	public bool IsEmpty => Count == 0;

	public bool IsFull => Count == Capacity;

	public bool IsSplit => offset > Capacity - Count;

	public int Capacity => buffer.Length;

	public T Front
	{
		get
		{
			if (IsEmpty)
			{
				return default(T);
			}
			return buffer[offset];
		}
	}

	public T Back
	{
		get
		{
			if (IsEmpty)
			{
				return default(T);
			}
			return buffer[(count + offset - 1) % Capacity];
		}
	}

	public Deque(int capacity = 8)
	{
		buffer = new T[capacity];
	}

	public void Clear()
	{
		offset = (count = 0);
	}

	public void Resize(int capacity)
	{
		if (capacity > Capacity)
		{
			T[] destinationArray = new T[capacity];
			if (IsSplit)
			{
				int num = Capacity - offset;
				Array.Copy(buffer, offset, destinationArray, 0, num);
				Array.Copy(buffer, 0, destinationArray, num, Count - num);
			}
			else
			{
				Array.Copy(buffer, offset, destinationArray, 0, Count);
			}
			buffer = destinationArray;
			offset = 0;
		}
	}

	public T PeekBack()
	{
		if (IsEmpty)
		{
			return default(T);
		}
		return buffer[(count + offset) % Capacity];
	}

	public T PeekFront()
	{
		if (IsEmpty)
		{
			return default(T);
		}
		return buffer[offset];
	}

	public void PushBack(T value)
	{
		if (IsFull)
		{
			Resize(Capacity * 2);
		}
		buffer[(count + offset) % Capacity] = value;
		count++;
	}

	public void PushFront(T value)
	{
		if (IsFull)
		{
			Resize(Capacity * 2);
		}
		if (--offset < 0)
		{
			offset += Capacity;
		}
		buffer[offset] = value;
		count++;
	}

	public T PopBack()
	{
		if (IsEmpty)
		{
			return default(T);
		}
		T result = buffer[(count + offset - 1) % Capacity];
		count--;
		return result;
	}

	public T PopFront()
	{
		if (IsEmpty)
		{
			return default(T);
		}
		T result = buffer[offset];
		offset = (offset + 1) % Capacity;
		count--;
		return result;
	}
}


using System.Collections;
using System.Collections.Generic;

public interface IImmutableStack<T> : IEnumerable<T>, IEnumerable
{
	int Count { get; }

	IImmutableStack<T> Push(T value);

	IImmutableStack<T> Pop();

	T Peek();
}


using System;
using System.Collections;
using System.Collections.Generic;

public class ImmutableStack<T> : IImmutableStack<T>, IEnumerable<T>, IEnumerable
{
	private sealed class EmptyStack : IImmutableStack<T>, IEnumerable<T>, IEnumerable
	{
		public int Count => 0;

		public IImmutableStack<T> Push(T value)
		{
			return new ImmutableStack<T>(value, this);
		}

		public IImmutableStack<T> Pop()
		{
			throw new InvalidOperationException("The stack is empty.");
		}

		public T Peek()
		{
			throw new InvalidOperationException("The stack is empty.");
		}

		public IEnumerator<T> GetEnumerator()
		{
			yield break;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	private readonly T _head;

	private readonly IImmutableStack<T> _tail;

	public static IImmutableStack<T> Empty { get; } = new EmptyStack();

	public int Count { get; }

	private ImmutableStack(T head, IImmutableStack<T> tail)
	{
		if (tail == null)
		{
			throw new ArgumentNullException("tail");
		}
		_head = head;
		_tail = tail;
		Count = tail.Count + 1;
	}

	public T Peek()
	{
		return _head;
	}

	public IImmutableStack<T> Pop()
	{
		return _tail;
	}

	public IImmutableStack<T> Push(T value)
	{
		return new ImmutableStack<T>(value, this);
	}

	public IEnumerator<T> GetEnumerator()
	{
		IImmutableStack<T> stack = this;
		while (stack.Count > 0)
		{
			yield return stack.Peek();
			stack = stack.Pop();
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


public struct IntrusiveLinkedList<T> where T : ILinkedListNode<T>
{
	private T head;

	public bool Empty => head == null;

	public void Add(T item)
	{
		if (head == null)
		{
			head = item;
			return;
		}
		item.next = head;
		head = item;
	}

	public T Pop()
	{
		T result = head;
		head = head.next;
		result.next = default(T);
		return result;
	}
}


public interface ILinkedListNode<T>
{
	T next { get; set; }
}


public struct IntrusiveMinHeap<T> where T : IMinHeapNode<T>
{
	private T head;

	public bool Empty => head == null;

	public void Add(T item)
	{
		if (head == null)
		{
			head = item;
			return;
		}
		if (head.child == null && item.order <= head.order)
		{
			item.child = head;
			head = item;
			return;
		}
		T child = head;
		while (child.child != null && child.child.order < item.order)
		{
			child = child.child;
		}
		item.child = child.child;
		child.child = item;
	}

	public T Pop()
	{
		T result = head;
		head = head.child;
		result.child = default(T);
		return result;
	}
}


public interface IMinHeapNode<T>
{
	T child { get; set; }

	int order { get; }
}


using System.Collections.Generic;

public class LimitDictionary<TKey, TValue> : Dictionary<TKey, TValue>
{
	public int MaxCapacity = 8192;

	private Queue<TKey> entries;

	public LimitDictionary(int maxCapacity = 8192)
	{
		MaxCapacity = maxCapacity;
		entries = new Queue<TKey>(MaxCapacity);
	}

	public new void TryAdd(TKey key, TValue item)
	{
		if (!ContainsKey(key))
		{
			if (base.Count == MaxCapacity)
			{
				TKey key2 = entries.Dequeue();
				Remove(key2);
			}
			Add(key, item);
			entries.Enqueue(key);
		}
	}
}


using System.Collections.Generic;

public class LimitList<T> : List<T>
{
	public int maxCapacity;

	private Queue<T> entries;

	public LimitList(int maxCapacity = 4096)
	{
		this.maxCapacity = maxCapacity;
		entries = new Queue<T>(this.maxCapacity);
	}

	public new void Add(T item)
	{
		while (base.Count > maxCapacity)
		{
			T item2 = entries.Dequeue();
			Remove(item2);
		}
		base.Add(item);
		entries.Enqueue(item);
	}

	public new void AddRange(IEnumerable<T> items)
	{
		foreach (T item in items)
		{
			Add(item);
		}
	}
}


using System.Collections;
using System.Collections.Generic;

public class ListDictionary<TKey, TVal> : IEnumerable<KeyValuePair<TKey, TVal>>, IEnumerable
{
	private Dictionary<TKey, int> key2idx;

	private Dictionary<int, TKey> idx2key;

	private BufferList<TKey> keys;

	private BufferList<TVal> vals;

	public TVal this[TKey key]
	{
		get
		{
			return vals[key2idx[key]];
		}
		set
		{
			vals[key2idx[key]] = value;
		}
	}

	public BufferList<TKey> Keys => keys;

	public BufferList<TVal> Values => vals;

	public int Count => vals.Count;

	public ListDictionary()
		: this(8)
	{
	}

	public ListDictionary(int capacity = 8)
	{
		key2idx = new Dictionary<TKey, int>(capacity);
		idx2key = new Dictionary<int, TKey>(capacity);
		keys = new BufferList<TKey>(capacity);
		vals = new BufferList<TVal>(capacity);
	}

	public void Add(TKey key, TVal val)
	{
		int count = keys.Count;
		key2idx.Add(key, count);
		idx2key.Add(count, key);
		keys.Add(key);
		vals.Add(val);
	}

	public bool Contains(TKey key)
	{
		return key2idx.ContainsKey(key);
	}

	public bool ContainsKey(TKey key)
	{
		return key2idx.ContainsKey(key);
	}

	public bool Remove(TKey key)
	{
		if (!key2idx.TryGetValue(key, out var value))
		{
			return false;
		}
		Remove(value, key);
		return true;
	}

	public bool RemoveAt(int idx)
	{
		if (!idx2key.TryGetValue(idx, out var value))
		{
			return false;
		}
		Remove(idx, value);
		return true;
	}

	private void Remove(int idx_remove, TKey key_remove)
	{
		int key = keys.Count - 1;
		TKey val = idx2key[key];
		keys.RemoveUnordered(idx_remove);
		vals.RemoveUnordered(idx_remove);
		key2idx[val] = idx_remove;
		idx2key[idx_remove] = val;
		key2idx.Remove(key_remove);
		idx2key.Remove(key);
	}

	public bool TryGetValue(TKey key, out TVal val)
	{
		if (key2idx.TryGetValue(key, out var value))
		{
			val = vals[value];
			return true;
		}
		val = default(TVal);
		return false;
	}

	public KeyValuePair<TKey, TVal> GetByIndex(int idx)
	{
		return new KeyValuePair<TKey, TVal>(idx2key[idx], vals[idx]);
	}

	public void Clear()
	{
		if (Count != 0)
		{
			key2idx.Clear();
			idx2key.Clear();
			keys.Clear();
			vals.Clear();
		}
	}

	public IEnumerator<KeyValuePair<TKey, TVal>> GetEnumerator()
	{
		for (int i = 0; i < vals.Count; i++)
		{
			yield return GetByIndex(i);
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch;

public class ListHashSet<T> : IEnumerable<T>, IEnumerable, IList<T>, ICollection<T>
{
	public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
	{
		private readonly BufferList<T> list;

		private int index;

		public T Current => list[index];

		object IEnumerator.Current => Current;

		public Enumerator(ListHashSet<T> set)
		{
			list = set.vals;
			index = -1;
		}

		public bool MoveNext()
		{
			index++;
			return index < list.Count;
		}

		public void Reset()
		{
			index = -1;
		}

		public void Dispose()
		{
		}
	}

	private Dictionary<T, int> val2idx;

	private Dictionary<int, T> idx2val;

	private BufferList<T> vals;

	public BufferList<T> Values => vals;

	public int Count => vals.Count;

	public bool IsReadOnly => false;

	public T this[int index]
	{
		get
		{
			return vals[index];
		}
		set
		{
			vals[index] = value;
		}
	}

	public ListHashSet()
		: this(8)
	{
	}

	public ListHashSet(int capacity)
	{
		val2idx = new Dictionary<T, int>(capacity);
		idx2val = new Dictionary<int, T>(capacity);
		vals = new BufferList<T>(capacity);
	}

	public void Add(T val)
	{
		int count = vals.Count;
		val2idx.Add(val, count);
		idx2val.Add(count, val);
		vals.Add(val);
	}

	public bool TryAdd(T val)
	{
		if (Contains(val))
		{
			return false;
		}
		Add(val);
		return true;
	}

	public void AddRange(List<T> list)
	{
		for (int i = 0; i < list.Count; i++)
		{
			Add(list[i]);
		}
	}

	public void AddRange(IEnumerable<T> enumerable)
	{
		foreach (T item in enumerable)
		{
			Add(item);
		}
	}

	public bool Contains(T val)
	{
		return val2idx.ContainsKey(val);
	}

	public bool Remove(T val)
	{
		if (!val2idx.TryGetValue(val, out var value))
		{
			return false;
		}
		Remove(value, val);
		return true;
	}

	public void RemoveAt(int idx)
	{
		if (idx2val.TryGetValue(idx, out var value))
		{
			Remove(idx, value);
		}
	}

	public int IndexOf(T item)
	{
		if (!val2idx.TryGetValue(item, out var value))
		{
			return -1;
		}
		return value;
	}

	public void ReplaceAt(int index, T item)
	{
		T key = vals[index];
		val2idx.Remove(key);
		val2idx.Add(item, index);
		vals[index] = item;
		idx2val[index] = item;
	}

	public void Insert(int index, T item)
	{
		vals.Add(default(T));
		for (int num = vals.Count - 1; num > index; num--)
		{
			T val = vals[num - 1];
			vals[num] = val;
			val2idx[val] = num;
			idx2val[num] = val;
		}
		vals[index] = item;
		val2idx[item] = index;
		idx2val[index] = item;
	}

	public void Clear()
	{
		if (Count != 0)
		{
			val2idx.Clear();
			idx2val.Clear();
			vals.Clear();
		}
	}

	private void Remove(int idx_remove, T val_remove)
	{
		int key = vals.Count - 1;
		T val = idx2val[key];
		vals.RemoveUnordered(idx_remove);
		val2idx[val] = idx_remove;
		idx2val[idx_remove] = val;
		val2idx.Remove(val_remove);
		idx2val.Remove(key);
	}

	public void CopyTo(T[] array, int arrayIndex)
	{
		for (int i = 0; i < vals.Count; i++)
		{
			array[arrayIndex + i] = vals[i];
		}
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(this);
	}

	IEnumerator<T> IEnumerable<T>.GetEnumerator()
	{
		return GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public static void Compare(ListHashSet<T> a, ListHashSet<T> b, List<T> added, List<T> removed, List<T> remained)
	{
		if (a == null && b == null)
		{
			return;
		}
		if (a == null)
		{
			added?.AddRange(b);
		}
		else if (b == null)
		{
			removed?.AddRange(a);
		}
		else
		{
			if (a.Count == 0 && b.Count == 0)
			{
				return;
			}
			HashSet<T> obj = Pool.Get<HashSet<T>>();
			foreach (T item in b)
			{
				if (!obj.Contains(item))
				{
					if (a.Contains(item))
					{
						remained?.Add(item);
					}
					else
					{
						added?.Add(item);
					}
					obj.Add(item);
				}
			}
			foreach (T item2 in a)
			{
				if (!obj.Contains(item2))
				{
					if (b.Contains(item2))
					{
						remained?.Add(item2);
					}
					else
					{
						removed?.Add(item2);
					}
					obj.Add(item2);
				}
			}
			Pool.FreeUnmanaged(ref obj);
		}
	}
}


public class MinQueue
{
	private Deque<int> data;

	private Deque<int> min;

	public int Min => min.Front;

	public MinQueue(int capacity = 8)
	{
		data = new Deque<int>(capacity);
		min = new Deque<int>(capacity);
	}

	public void Push(int value)
	{
		data.PushBack(value);
		while (!min.IsEmpty && min.Back > value)
		{
			min.PopBack();
		}
		min.PushBack(value);
	}

	public int Pop()
	{
		if (min.Front == data.Front)
		{
			min.PopFront();
		}
		return data.PopFront();
	}
}


public class MaxQueue
{
	private Deque<int> data;

	private Deque<int> max;

	public int Max => max.Front;

	public MaxQueue(int capacity = 8)
	{
		data = new Deque<int>(capacity);
		max = new Deque<int>(capacity);
	}

	public void Push(int value)
	{
		data.PushBack(value);
		while (!max.IsEmpty && max.Back < value)
		{
			max.PopBack();
		}
		max.PushBack(value);
	}

	public int Pop()
	{
		if (max.Front == data.Front)
		{
			max.PopFront();
		}
		return data.PopFront();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.Assertions;

public class MruDictionary<Key, Value> : IEnumerable<KeyValuePair<Key, Value>>, IEnumerable
{
	private int capacity;

	private Queue<LinkedListNode<KeyValuePair<Key, Value>>> recycled;

	private LinkedList<KeyValuePair<Key, Value>> list;

	private Dictionary<Key, LinkedListNode<KeyValuePair<Key, Value>>> dict;

	private Action<Key, Value> valueRecycler;

	public int Capacity => capacity;

	public int Count => list.Count;

	public long EvictionCount { get; private set; }

	public MruDictionary(int capacity, Action<Key, Value> valueRecycler = null)
	{
		this.capacity = capacity;
		list = new LinkedList<KeyValuePair<Key, Value>>();
		dict = new Dictionary<Key, LinkedListNode<KeyValuePair<Key, Value>>>(capacity);
		recycled = new Queue<LinkedListNode<KeyValuePair<Key, Value>>>(capacity);
		this.valueRecycler = valueRecycler;
		for (int i = 0; i < capacity; i++)
		{
			recycled.Enqueue(new LinkedListNode<KeyValuePair<Key, Value>>(default(KeyValuePair<Key, Value>)));
		}
	}

	public void Add(Key key, Value value)
	{
		if (dict.ContainsKey(key))
		{
			throw new InvalidOperationException("An item with the same key has already been added.");
		}
		if (dict.Count >= capacity)
		{
			RemoveLast();
		}
		LinkedListNode<KeyValuePair<Key, Value>> linkedListNode = ((recycled.Count > 0) ? recycled.Dequeue() : new LinkedListNode<KeyValuePair<Key, Value>>(default(KeyValuePair<Key, Value>)));
		linkedListNode.Value = new KeyValuePair<Key, Value>(key, value);
		list.AddFirst(linkedListNode);
		dict.Add(key, linkedListNode);
	}

	public void Remove(Key key)
	{
		if (dict.TryGetValue(key, out var value))
		{
			Assert.AreEqual<Key>(key, value.Value.Key);
			Value value2 = value.Value.Value;
			list.Remove(value);
			dict.Remove(key);
			valueRecycler?.Invoke(key, value2);
			value.Value = default(KeyValuePair<Key, Value>);
			recycled.Enqueue(value);
		}
	}

	private void RemoveLast()
	{
		Assert.IsTrue(list.Count > 0);
		LinkedListNode<KeyValuePair<Key, Value>> last = list.Last;
		Assert.IsTrue(dict.Remove(last.Value.Key));
		list.RemoveLast();
		valueRecycler?.Invoke(last.Value.Key, last.Value.Value);
		last.Value = default(KeyValuePair<Key, Value>);
		recycled.Enqueue(last);
		EvictionCount++;
	}

	public bool TryGetValue(Key key, out Value value)
	{
		if (dict.TryGetValue(key, out var value2))
		{
			Assert.AreEqual<Key>(key, value2.Value.Key);
			value = value2.Value.Value;
			list.Remove(value2);
			list.AddFirst(value2);
			return true;
		}
		value = default(Value);
		return false;
	}

	public void Clear()
	{
		while (Count > 0)
		{
			RemoveLast();
		}
	}

	public void SetCapacity(int newCapacity)
	{
		int num = newCapacity - capacity;
		if (num > 0)
		{
			for (int i = 0; i < num; i++)
			{
				recycled.Enqueue(new LinkedListNode<KeyValuePair<Key, Value>>(default(KeyValuePair<Key, Value>)));
			}
		}
		else
		{
			num *= -1;
			if (Count > newCapacity)
			{
				int num2 = Count - newCapacity;
				for (int j = 0; j < num2; j++)
				{
					RemoveLast();
				}
			}
			int num3 = newCapacity - Count;
			while (recycled.Count > num3)
			{
				recycled.Dequeue().Value = default(KeyValuePair<Key, Value>);
			}
		}
		capacity = newCapacity;
	}

	public LinkedList<KeyValuePair<Key, Value>>.Enumerator GetEnumerator()
	{
		return list.GetEnumerator();
	}

	IEnumerator<KeyValuePair<Key, Value>> IEnumerable<KeyValuePair<Key, Value>>.GetEnumerator()
	{
		return GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections.Generic;

public class SpanningTree<T>
{
	private class Node
	{
		public List<Edge> edges;

		public bool connected;

		public Node()
		{
			edges = new List<Edge>();
			connected = false;
		}
	}

	private class Edge : IMinHeapNode<Edge>
	{
		public Node source;

		public Node target;

		public T value;

		public int order { get; private set; }

		public Edge child { get; set; }

		public Edge(Node source, Node target, int order, T value)
		{
			this.source = source;
			this.target = target;
			this.order = order;
			this.value = value;
		}
	}

	private List<Node> nodes = new List<Node>();

	private List<Edge> edges = new List<Edge>();

	public int AddNode()
	{
		nodes.Add(new Node());
		return nodes.Count - 1;
	}

	public void AddEdge(int a_idx, int b_idx, int cost, T value)
	{
		Node node = nodes[a_idx];
		Node target = nodes[b_idx];
		node.edges.Add(new Edge(node, target, cost, value));
	}

	public void Clear()
	{
		nodes.Clear();
		edges.Clear();
	}

	public void Reset()
	{
		foreach (Node node in nodes)
		{
			node.connected = false;
		}
		edges.Clear();
	}

	public void CalculateMin()
	{
		Reset();
		IntrusiveMinHeap<Edge> intrusiveMinHeap = default(IntrusiveMinHeap<Edge>);
		foreach (Node node in nodes)
		{
			if (node.connected)
			{
				continue;
			}
			foreach (Edge edge2 in node.edges)
			{
				if (!edge2.target.connected)
				{
					intrusiveMinHeap.Add(edge2);
				}
			}
			node.connected = true;
			while (!intrusiveMinHeap.Empty)
			{
				Edge edge = intrusiveMinHeap.Pop();
				Node target = edge.target;
				if (target.connected)
				{
					continue;
				}
				target.connected = true;
				foreach (Edge edge3 in target.edges)
				{
					if (edge3.target == edge.source)
					{
						edge = edge3;
					}
					if (!edge3.target.connected)
					{
						intrusiveMinHeap.Add(edge3);
					}
				}
				edges.Add(edge);
			}
		}
	}

	public void ForEach(Action<T> action)
	{
		foreach (Edge edge in edges)
		{
			action(edge.value);
		}
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;

public class Checksum
{
	private List<byte> values = new List<byte>();

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private float NormalizeFloat(float f)
	{
		if (f == -0f)
		{
			f = 0f;
		}
		return f;
	}

	public void Add(float f, int bytes)
	{
		f = NormalizeFloat(f);
		Union32 union = default(Union32);
		union.f = f;
		if (bytes >= 4)
		{
			values.Add(union.b1);
		}
		if (bytes >= 3)
		{
			values.Add(union.b2);
		}
		if (bytes >= 2)
		{
			values.Add(union.b3);
		}
		if (bytes >= 1)
		{
			values.Add(union.b4);
		}
	}

	public void Add(float f)
	{
		f = NormalizeFloat(f);
		Union32 union = default(Union32);
		union.f = f;
		values.Add(union.b1);
		values.Add(union.b2);
		values.Add(union.b3);
		values.Add(union.b4);
	}

	public void Add(int i)
	{
		Union32 union = default(Union32);
		union.i = i;
		values.Add(union.b1);
		values.Add(union.b2);
		values.Add(union.b3);
		values.Add(union.b4);
	}

	public void Add(uint u)
	{
		Union32 union = default(Union32);
		union.u = u;
		values.Add(union.b1);
		values.Add(union.b2);
		values.Add(union.b3);
		values.Add(union.b4);
	}

	public void Add(short i)
	{
		Union16 union = default(Union16);
		union.i = i;
		values.Add(union.b1);
		values.Add(union.b2);
	}

	public void Add(ushort u)
	{
		Union16 union = default(Union16);
		union.u = u;
		values.Add(union.b1);
		values.Add(union.b2);
	}

	public void Add(byte b)
	{
		values.Add(b);
	}

	public void Clear()
	{
		values.Clear();
	}

	public string MD5()
	{
		byte[] bytes = new MD5CryptoServiceProvider().ComputeHash(values.ToArray());
		return BytesToString(bytes);
	}

	public string SHA1()
	{
		byte[] bytes = new SHA1CryptoServiceProvider().ComputeHash(values.ToArray());
		return BytesToString(bytes);
	}

	public override string ToString()
	{
		return BytesToString(values.ToArray());
	}

	private string BytesToString(byte[] bytes)
	{
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < bytes.Length; i++)
		{
			stringBuilder.Append(bytes[i].ToString("x2"));
		}
		return stringBuilder.ToString();
	}
}


using System.Text;

public static class StringBuilderExtensions
{
	public static StringBuilder QuoteSafe(this StringBuilder builder, string value)
	{
		builder.Append('"');
		int num = 0;
		for (int i = 0; i < value.Length; i++)
		{
			if (value[i] == '"')
			{
				int num2 = i - num;
				if (num2 > 0)
				{
					builder.Append(value, num, num2);
				}
				builder.Append("\\\"");
				num = i + 1;
			}
		}
		if (num < value.Length)
		{
			builder.Append(value, num, value.Length - num);
		}
		builder.Append('"');
		return builder;
	}
}


using System;

public static class GenericsUtil
{
	private static class CastImpl<TSrc, TDst>
	{
		[ThreadStatic]
		public static TSrc Value;

		static CastImpl()
		{
			if (typeof(TSrc) != typeof(TDst))
			{
				throw new InvalidCastException();
			}
		}
	}

	public static TDst Cast<TSrc, TDst>(TSrc obj)
	{
		CastImpl<TSrc, TDst>.Value = obj;
		return CastImpl<TDst, TSrc>.Value;
	}

	public static void Swap<T>(ref T a, ref T b)
	{
		T val = a;
		a = b;
		b = val;
	}
}


using UnityEngine;

public class BitUtility
{
	private const float float2byte = 255f;

	private const float byte2float = 0.003921569f;

	private const float float2short = 32766f;

	private const float short2float = 3.051944E-05f;

	private const float float2ushort = 65534f;

	private const float ushort2float = 1.5259255E-05f;

	public static byte Float2Byte(float f)
	{
		Union32 union = default(Union32);
		union.f = f;
		union.b1 = 0;
		return (byte)(union.f * 255f + 0.5f);
	}

	public static float Byte2Float(int b)
	{
		return (float)b * 0.003921569f;
	}

	public static short Float2Short(float f)
	{
		return (short)(f * 32766f + 0.5f);
	}

	public static float Short2Float(int b)
	{
		return (float)b * 3.051944E-05f;
	}

	public static ushort Float2UShort(float f)
	{
		return (ushort)(f * 65534f + 0.5f);
	}

	public static float UShort2Float(ushort s)
	{
		return (float)(int)s * 1.5259255E-05f;
	}

	public static Color32 EncodeFloat(float f)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		Union32 union = default(Union32);
		union.f = f;
		return new Color32(union.b1, union.b2, union.b3, union.b4);
	}

	public static float DecodeFloat(Color32 c)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Union32 union = default(Union32);
		union.b1 = c.r;
		union.b2 = c.g;
		union.b3 = c.b;
		union.b4 = c.a;
		return union.f;
	}

	public static Color32 EncodeInt(int i)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		Union32 union = default(Union32);
		union.i = i;
		return new Color32(union.b1, union.b2, union.b3, union.b4);
	}

	public static int DecodeInt(Color32 c)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Union32 union = default(Union32);
		union.b1 = c.r;
		union.b2 = c.g;
		union.b3 = c.b;
		union.b4 = c.a;
		return union.i;
	}

	public static Color32 EncodeShort(short i)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Union16 union = default(Union16);
		union.i = i;
		return new Color32(union.b1, (byte)0, union.b2, (byte)1);
	}

	public static short DecodeShort(Color32 c)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Union16 union = default(Union16);
		union.b1 = c.r;
		union.b2 = c.b;
		return union.i;
	}

	public static Color32 EncodeUShort(ushort u)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Union16 union = default(Union16);
		union.u = u;
		return new Color32(union.b1, (byte)0, union.b2, (byte)1);
	}

	public static ushort DecodeUShort(Color32 c)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Union16 union = default(Union16);
		union.b1 = c.r;
		union.b2 = c.b;
		return union.u;
	}

	public static Color EncodeNormal(Vector3 n)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		n = (n + Vector3.one) * 0.5f;
		return new Color(n.z, n.z, n.z, n.x);
	}

	public static Vector3 DecodeNormal(Color c)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		float num = c.a * 2f - 1f;
		float num2 = c.g * 2f - 1f;
		float num3 = Mathf.Sqrt(1f - Mathf.Clamp01(num * num + num2 * num2));
		return new Vector3(num, num3, num2);
	}

	public static Color32 EncodeVector(Vector4 v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return new Color32(Float2Byte(v.x), Float2Byte(v.y), Float2Byte(v.z), Float2Byte(v.w));
	}

	public static Vector4 DecodeVector(Color32 c)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector4(Byte2Float(c.r), Byte2Float(c.g), Byte2Float(c.b), Byte2Float(c.a));
	}

	public static Color32 EncodeVector2i(Vector2i v)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		byte num = (byte)Mathf.Clamp(v.x, 0, 255);
		byte b = (byte)Mathf.Clamp(-v.x, 0, 255);
		byte b2 = (byte)Mathf.Clamp(v.y, 0, 255);
		byte b3 = (byte)Mathf.Clamp(-v.y, 0, 255);
		return new Color32(num, b, b2, b3);
	}

	public static Vector2i DecodeVector2i(Color32 c)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i(c.r - c.g, c.b - c.a);
	}
}


using System;

[Serializable]
public struct Vector2b : IEquatable<Vector2b>
{
	public static readonly Vector2b alltrue = new Vector2b(x: true, y: true);

	public static readonly Vector2b allfalse = new Vector2b(x: false, y: false);

	public bool x;

	public bool y;

	public Vector2b(bool x, bool y)
	{
		this.x = x;
		this.y = y;
	}

	public static bool operator ==(Vector2b a, Vector2b b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(Vector2b a, Vector2b b)
	{
		return !a.Equals(b);
	}

	public bool Equals(Vector2b o)
	{
		if (x == o.x)
		{
			return y == o.y;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return x.GetHashCode() ^ y.GetHashCode();
	}

	public override bool Equals(object o)
	{
		if (o != null && o is Vector2b)
		{
			return Equals((Vector2b)o);
		}
		return false;
	}

	public override string ToString()
	{
		return $"[{x},{y}]";
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Vector2i : IEquatable<Vector2i>
{
	public static readonly Vector2i zero = new Vector2i(0, 0);

	public static readonly Vector2i one = new Vector2i(1, 1);

	public static readonly Vector2i left = new Vector2i(-1, 0);

	public static readonly Vector2i right = new Vector2i(1, 0);

	public static readonly Vector2i forward = new Vector2i(0, 1);

	public static readonly Vector2i back = new Vector2i(0, -1);

	public int x;

	public int y;

	public Vector2i(int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public static Vector2i operator >>(Vector2i v, int shift)
	{
		return new Vector2i(v.x >> shift, v.y >> shift);
	}

	public static Vector2i operator <<(Vector2i v, int shift)
	{
		return new Vector2i(v.x << shift, v.y << shift);
	}

	public static Vector2i operator +(Vector2i v)
	{
		return new Vector2i(v.x, v.y);
	}

	public static Vector2i operator -(Vector2i v)
	{
		return new Vector2i(-v.x, -v.y);
	}

	public static Vector2i operator +(Vector2i a, Vector2i b)
	{
		return new Vector2i(a.x + b.x, a.y + b.y);
	}

	public static Vector2i operator -(Vector2i a, Vector2i b)
	{
		return new Vector2i(a.x - b.x, a.y - b.y);
	}

	public static Vector2i operator *(Vector2i v, int multiplier)
	{
		return new Vector2i(Mathf.RoundToInt((float)(v.x * multiplier)), Mathf.RoundToInt((float)(v.y * multiplier)));
	}

	public static Vector2i operator /(Vector2i v, int divisor)
	{
		return new Vector2i(Mathf.RoundToInt((float)(v.x / divisor)), Mathf.RoundToInt((float)(v.y / divisor)));
	}

	public static Vector2 operator *(Vector2i v, float multiplier)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2((float)v.x * multiplier, (float)v.y * multiplier);
	}

	public static Vector2 operator /(Vector2i v, float divisor)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2((float)v.x / divisor, (float)v.y / divisor);
	}

	public static Vector2i operator %(Vector2i v, int mod)
	{
		int num = v.x % mod;
		int num2 = v.y % mod;
		return new Vector2i(num, num2);
	}

	public static implicit operator Vector2(Vector2i other)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2((float)other.x, (float)other.y);
	}

	public static explicit operator Vector2i(Vector2 other)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i((int)other.x, (int)other.y);
	}

	public static bool operator ==(Vector2i a, Vector2i b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(Vector2i a, Vector2i b)
	{
		return !a.Equals(b);
	}

	public bool Equals(Vector2i o)
	{
		if (x == o.x)
		{
			return y == o.y;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return x.GetHashCode() ^ y.GetHashCode();
	}

	public override bool Equals(object o)
	{
		if (o != null && o is Vector2i)
		{
			return Equals((Vector2i)o);
		}
		return false;
	}

	public override string ToString()
	{
		return $"[{x},{y}]";
	}
}


using System;

[Serializable]
public struct Vector3b : IEquatable<Vector3b>
{
	public static readonly Vector3b alltrue = new Vector3b(x: true, y: true, z: true);

	public static readonly Vector3b allfalse = new Vector3b(x: false, y: false, z: false);

	public bool x;

	public bool y;

	public bool z;

	public Vector3b(bool x, bool y, bool z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public static bool operator ==(Vector3b a, Vector3b b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(Vector3b a, Vector3b b)
	{
		return !a.Equals(b);
	}

	public bool Equals(Vector3b o)
	{
		if (x == o.x && y == o.y)
		{
			return z == o.z;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode();
	}

	public override bool Equals(object o)
	{
		if (o != null && o is Vector3b)
		{
			return Equals((Vector3b)o);
		}
		return false;
	}

	public override string ToString()
	{
		return $"[{x},{y},{z}]";
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Vector3i : IEquatable<Vector3i>
{
	public static readonly Vector3i zero = new Vector3i(0, 0, 0);

	public static readonly Vector3i one = new Vector3i(1, 1, 1);

	public static readonly Vector3i forward = new Vector3i(0, 0, 1);

	public static readonly Vector3i back = new Vector3i(0, 0, -1);

	public static readonly Vector3i up = new Vector3i(0, 1, 0);

	public static readonly Vector3i down = new Vector3i(0, -1, 0);

	public static readonly Vector3i right = new Vector3i(1, 0, 0);

	public static readonly Vector3i left = new Vector3i(-1, 0, 0);

	public int x;

	public int y;

	public int z;

	public Vector3i(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public static Vector3i operator >>(Vector3i v, int shift)
	{
		return new Vector3i(v.x >> shift, v.y >> shift, v.z >> shift);
	}

	public static Vector3i operator <<(Vector3i v, int shift)
	{
		return new Vector3i(v.x << shift, v.y << shift, v.z << shift);
	}

	public static Vector3i operator +(Vector3i v)
	{
		return new Vector3i(v.x, v.y, v.z);
	}

	public static Vector3i operator -(Vector3i v)
	{
		return new Vector3i(-v.x, -v.y, -v.z);
	}

	public static Vector3i operator +(Vector3i a, Vector3i b)
	{
		return new Vector3i(a.x + b.x, a.y + b.y, a.z + b.z);
	}

	public static Vector3i operator -(Vector3i a, Vector3i b)
	{
		return new Vector3i(a.x - b.x, a.y - b.y, a.z - b.z);
	}

	public static Vector3i operator *(Vector3i v, int multiplier)
	{
		return new Vector3i(v.x * multiplier, v.y * multiplier, v.z * multiplier);
	}

	public static Vector3i operator /(Vector3i v, int divisor)
	{
		return new Vector3i(v.x / divisor, v.y / divisor, v.z / divisor);
	}

	public static Vector3 operator *(Vector3i v, float multiplier)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)v.x * multiplier, (float)v.y * multiplier, (float)v.z * multiplier);
	}

	public static Vector3 operator /(Vector3i v, float divisor)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)v.x / divisor, (float)v.y / divisor, (float)v.z / divisor);
	}

	public static Vector3i operator %(Vector3i v, int mod)
	{
		int num = v.x % mod;
		int num2 = v.y % mod;
		int num3 = v.z % mod;
		return new Vector3i(num, num2, num3);
	}

	public static implicit operator Vector3(Vector3i other)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)other.x, (float)other.y, (float)other.z);
	}

	public static explicit operator Vector3i(Vector3 other)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3i((int)other.x, (int)other.y, (int)other.z);
	}

	public static bool operator ==(Vector3i a, Vector3i b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(Vector3i a, Vector3i b)
	{
		return !a.Equals(b);
	}

	public bool Equals(Vector3i o)
	{
		if (x == o.x && y == o.y)
		{
			return z == o.z;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode();
	}

	public override bool Equals(object o)
	{
		if (o != null && o is Vector3i)
		{
			return Equals((Vector3i)o);
		}
		return false;
	}

	public override string ToString()
	{
		return $"[{x},{y},{z}]";
	}
}


using System;
using System.Collections.Generic;

public class Memoized<TResult, TArgs>
{
	private readonly Func<TArgs, TResult> _factory;

	private readonly Dictionary<TArgs, TResult> _cache;

	public Memoized(Func<TArgs, TResult> factory)
	{
		_factory = factory ?? throw new ArgumentNullException("factory");
		_cache = new Dictionary<TArgs, TResult>();
	}

	public TResult Get(TArgs args)
	{
		if (_cache.TryGetValue(args, out var value))
		{
			return value;
		}
		TResult val = _factory(args);
		_cache.Add(args, val);
		return val;
	}
}


using UnityEngine;

public static class Memoized
{
	public static readonly Memoized<string, int> IntToString = new Memoized<string, int>((int i) => i.ToString());

	public static readonly Memoized<string, KeyCode> KeyCodeToString = new Memoized<string, KeyCode>((KeyCode key) => ((object)(KeyCode)(ref key)/*cast due to .constrained prefix*/).ToString());
}


using System;
using System.Collections.Generic;
using Facepunch;

public class BasePooledList<T, SubclassT> : List<T>, IDisposable, Pool.IPooled where SubclassT : BasePooledList<T, SubclassT>, new()
{
	void IDisposable.Dispose()
	{
		SubclassT obj = (SubclassT)this;
		Pool.Free(ref obj);
	}

	void Pool.IPooled.EnterPool()
	{
		Clear();
	}

	void Pool.IPooled.LeavePool()
	{
	}
}


public sealed class PooledList<T> : BasePooledList<T, PooledList<T>>
{
}


using System;
using System.Collections.Generic;
using Facepunch;

public class PooledHashSet<T> : HashSet<T>, IDisposable, Pool.IPooled
{
	void IDisposable.Dispose()
	{
		PooledHashSet<T> obj = this;
		Pool.Free(ref obj);
	}

	void Pool.IPooled.EnterPool()
	{
		Clear();
	}

	void Pool.IPooled.LeavePool()
	{
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct Union16
{
	[FieldOffset(0)]
	public short i;

	[FieldOffset(0)]
	public ushort u;

	[FieldOffset(0)]
	public byte b1;

	[FieldOffset(1)]
	public byte b2;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct Union32
{
	[FieldOffset(0)]
	public int i;

	[FieldOffset(0)]
	public uint u;

	[FieldOffset(0)]
	public float f;

	[FieldOffset(0)]
	public byte b1;

	[FieldOffset(1)]
	public byte b2;

	[FieldOffset(2)]
	public byte b3;

	[FieldOffset(3)]
	public byte b4;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct Union64
{
	[FieldOffset(0)]
	public long i;

	[FieldOffset(0)]
	public ulong u;

	[FieldOffset(0)]
	public double f;

	[FieldOffset(0)]
	public byte b1;

	[FieldOffset(1)]
	public byte b2;

	[FieldOffset(2)]
	public byte b3;

	[FieldOffset(3)]
	public byte b4;

	[FieldOffset(4)]
	public byte b5;

	[FieldOffset(5)]
	public byte b6;

	[FieldOffset(6)]
	public byte b7;

	[FieldOffset(7)]
	public byte b8;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct Union8
{
	[FieldOffset(0)]
	public sbyte i;

	[FieldOffset(0)]
	public byte u;

	[FieldOffset(0)]
	public byte b1;
}


using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		MonoScriptData result = default(MonoScriptData);
		result.FilePathsData = new byte[2740]
		{
			0, 0, 0, 1, 0, 0, 0, 45, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 83, 121, 115, 116, 101, 109,
			92, 65, 114, 114, 97, 121, 80, 111, 111, 108,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			45, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 70, 97, 99,
			101, 112, 117, 110, 99, 104, 46, 83, 121, 115,
			116, 101, 109, 92, 66, 117, 114, 115, 116, 85,
			116, 105, 108, 46, 99, 115, 0, 0, 0, 1,
			0, 0, 0, 51, 92, 65, 115, 115, 101, 116,
			115, 92, 80, 108, 117, 103, 105, 110, 115, 92,
			70, 97, 99, 101, 112, 117, 110, 99, 104, 46,
			83, 121, 115, 116, 101, 109, 92, 66, 121, 116,
			101, 65, 114, 114, 97, 121, 83, 116, 114, 101,
			97, 109, 46, 99, 115, 0, 0, 0, 2, 0,
			0, 0, 58, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 83,
			121, 115, 116, 101, 109, 92, 67, 111, 108, 108,
			101, 99, 116, 105, 111, 110, 115, 92, 66, 117,
			102, 102, 101, 114, 76, 105, 115, 116, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 62, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 46, 83, 121, 115, 116, 101,
			109, 92, 67, 111, 108, 108, 101, 99, 116, 105,
			111, 110, 115, 92, 67, 105, 114, 99, 117, 108,
			97, 114, 66, 117, 102, 102, 101, 114, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 53, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 46, 83, 121, 115, 116, 101,
			109, 92, 67, 111, 108, 108, 101, 99, 116, 105,
			111, 110, 115, 92, 68, 101, 113, 117, 101, 46,
			99, 115, 0, 0, 0, 3, 0, 0, 0, 62,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 83, 121, 115, 116,
			101, 109, 92, 67, 111, 108, 108, 101, 99, 116,
			105, 111, 110, 115, 92, 73, 109, 109, 117, 116,
			97, 98, 108, 101, 83, 116, 97, 99, 107, 46,
			99, 115, 0, 0, 0, 2, 0, 0, 0, 67,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 83, 121, 115, 116,
			101, 109, 92, 67, 111, 108, 108, 101, 99, 116,
			105, 111, 110, 115, 92, 73, 110, 116, 114, 117,
			115, 105, 118, 101, 76, 105, 110, 107, 101, 100,
			76, 105, 115, 116, 46, 99, 115, 0, 0, 0,
			2, 0, 0, 0, 64, 92, 65, 115, 115, 101,
			116, 115, 92, 80, 108, 117, 103, 105, 110, 115,
			92, 70, 97, 99, 101, 112, 117, 110, 99, 104,
			46, 83, 121, 115, 116, 101, 109, 92, 67, 111,
			108, 108, 101, 99, 116, 105, 111, 110, 115, 92,
			73, 110, 116, 114, 117, 115, 105, 118, 101, 77,
			105, 110, 72, 101, 97, 112, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 63, 92, 65, 115,
			115, 101, 116, 115, 92, 80, 108, 117, 103, 105,
			110, 115, 92, 70, 97, 99, 101, 112, 117, 110,
			99, 104, 46, 83, 121, 115, 116, 101, 109, 92,
			67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
			115, 92, 76, 105, 109, 105, 116, 68, 105, 99,
			116, 105, 111, 110, 97, 114, 121, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 57, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 83, 121, 115, 116, 101, 109,
			92, 67, 111, 108, 108, 101, 99, 116, 105, 111,
			110, 115, 92, 76, 105, 109, 105, 116, 76, 105,
			115, 116, 46, 99, 115, 0, 0, 0, 1, 0,
			0, 0, 62, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 83,
			121, 115, 116, 101, 109, 92, 67, 111, 108, 108,
			101, 99, 116, 105, 111, 110, 115, 92, 76, 105,
			115, 116, 68, 105, 99, 116, 105, 111, 110, 97,
			114, 121, 46, 99, 115, 0, 0, 0, 2, 0,
			0, 0, 59, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 83,
			121, 115, 116, 101, 109, 92, 67, 111, 108, 108,
			101, 99, 116, 105, 111, 110, 115, 92, 76, 105,
			115, 116, 72, 97, 115, 104, 83, 101, 116, 46,
			99, 115, 0, 0, 0, 2, 0, 0, 0, 59,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 83, 121, 115, 116,
			101, 109, 92, 67, 111, 108, 108, 101, 99, 116,
			105, 111, 110, 115, 92, 77, 105, 110, 77, 97,
			120, 81, 117, 101, 117, 101, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 61, 92, 65, 115,
			115, 101, 116, 115, 92, 80, 108, 117, 103, 105,
			110, 115, 92, 70, 97, 99, 101, 112, 117, 110,
			99, 104, 46, 83, 121, 115, 116, 101, 109, 92,
			67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
			115, 92, 77, 114, 117, 68, 105, 99, 116, 105,
			111, 110, 97, 114, 121, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 66, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 83, 121, 115, 116, 101, 109, 92, 67,
			111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
			92, 78, 97, 116, 105, 118, 101, 77, 101, 109,
			111, 114, 121, 83, 116, 114, 101, 97, 109, 46,
			99, 115, 0, 0, 0, 3, 0, 0, 0, 60,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 83, 121, 115, 116,
			101, 109, 92, 67, 111, 108, 108, 101, 99, 116,
			105, 111, 110, 115, 92, 83, 112, 97, 110, 110,
			105, 110, 103, 84, 114, 101, 101, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 47, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 83, 121, 115, 116, 101, 109,
			92, 67, 111, 109, 109, 97, 110, 100, 76, 105,
			110, 101, 46, 99, 115, 0, 0, 0, 1, 0,
			0, 0, 50, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 83,
			121, 115, 116, 101, 109, 92, 67, 114, 121, 112,
			116, 92, 67, 104, 101, 99, 107, 115, 117, 109,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			45, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 70, 97, 99,
			101, 112, 117, 110, 99, 104, 46, 83, 121, 115,
			116, 101, 109, 92, 67, 114, 121, 112, 116, 92,
			77, 100, 53, 46, 99, 115, 0, 0, 0, 1,
			0, 0, 0, 59, 92, 65, 115, 115, 101, 116,
			115, 92, 80, 108, 117, 103, 105, 110, 115, 92,
			70, 97, 99, 101, 112, 117, 110, 99, 104, 46,
			83, 121, 115, 116, 101, 109, 92, 69, 120, 116,
			101, 110, 100, 92, 66, 97, 115, 101, 51, 54,
			69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			57, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 70, 97, 99,
			101, 112, 117, 110, 99, 104, 46, 83, 121, 115,
			116, 101, 109, 92, 69, 120, 116, 101, 110, 100,
			92, 66, 121, 116, 101, 69, 120, 116, 101, 110,
			115, 105, 111, 110, 115, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 63, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 83, 121, 115, 116, 101, 109, 92, 69,
			120, 116, 101, 110, 100, 92, 68, 105, 99, 116,
			105, 111, 110, 97, 114, 121, 69, 120, 116, 101,
			110, 115, 105, 111, 110, 115, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 57, 92, 65, 115,
			115, 101, 116, 115, 92, 80, 108, 117, 103, 105,
			110, 115, 92, 70, 97, 99, 101, 112, 117, 110,
			99, 104, 46, 83, 121, 115, 116, 101, 109, 92,
			69, 120, 116, 101, 110, 100, 92, 76, 105, 115,
			116, 69, 120, 116, 101, 110, 115, 105, 111, 110,
			115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 59, 92, 65, 115, 115, 101, 116, 115, 92,
			80, 108, 117, 103, 105, 110, 115, 92, 70, 97,
			99, 101, 112, 117, 110, 99, 104, 46, 83, 121,
			115, 116, 101, 109, 92, 69, 120, 116, 101, 110,
			100, 92, 78, 117, 109, 98, 101, 114, 69, 120,
			116, 101, 110, 115, 105, 111, 110, 115, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 58, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 46, 83, 121, 115, 116, 101,
			109, 92, 69, 120, 116, 101, 110, 100, 92, 81,
			117, 101, 117, 101, 69, 120, 116, 101, 110, 115,
			105, 111, 110, 115, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 63, 92, 65, 115, 115, 101,
			116, 115, 92, 80, 108, 117, 103, 105, 110, 115,
			92, 70, 97, 99, 101, 112, 117, 110, 99, 104,
			46, 83, 121, 115, 116, 101, 109, 92, 69, 120,
			116, 101, 110, 100, 92, 82, 101, 102, 108, 101,
			99, 116, 105, 111, 110, 69, 120, 116, 101, 110,
			115, 105, 111, 110, 115, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 66, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 83, 121, 115, 116, 101, 109, 92, 69,
			120, 116, 101, 110, 100, 92, 83, 116, 114, 105,
			110, 103, 66, 117, 105, 108, 100, 101, 114, 69,
			120, 116, 101, 110, 115, 105, 111, 110, 115, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 59,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 83, 121, 115, 116,
			101, 109, 92, 69, 120, 116, 101, 110, 100, 92,
			83, 116, 114, 105, 110, 103, 69, 120, 116, 101,
			110, 115, 105, 111, 110, 115, 46, 99, 115, 0,
			0, 0, 2, 0, 0, 0, 48, 92, 65, 115,
			115, 101, 116, 115, 92, 80, 108, 117, 103, 105,
			110, 115, 92, 70, 97, 99, 101, 112, 117, 110,
			99, 104, 46, 83, 121, 115, 116, 101, 109, 92,
			71, 101, 110, 101, 114, 105, 99, 115, 85, 116,
			105, 108, 46, 99, 115, 0, 0, 0, 1, 0,
			0, 0, 51, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 83,
			121, 115, 116, 101, 109, 92, 77, 97, 116, 104,
			92, 66, 105, 116, 85, 116, 105, 108, 105, 116,
			121, 46, 99, 115, 0, 0, 0, 2, 0, 0,
			0, 45, 92, 65, 115, 115, 101, 116, 115, 92,
			80, 108, 117, 103, 105, 110, 115, 92, 70, 97,
			99, 101, 112, 117, 110, 99, 104, 46, 83, 121,
			115, 116, 101, 109, 92, 77, 97, 116, 104, 92,
			71, 114, 105, 100, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 49, 92, 65, 115, 115, 101,
			116, 115, 92, 80, 108, 117, 103, 105, 110, 115,
			92, 70, 97, 99, 101, 112, 117, 110, 99, 104,
			46, 83, 121, 115, 116, 101, 109, 92, 77, 97,
			116, 104, 92, 86, 101, 99, 116, 111, 114, 50,
			98, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 49, 92, 65, 115, 115, 101, 116, 115, 92,
			80, 108, 117, 103, 105, 110, 115, 92, 70, 97,
			99, 101, 112, 117, 110, 99, 104, 46, 83, 121,
			115, 116, 101, 109, 92, 77, 97, 116, 104, 92,
			86, 101, 99, 116, 111, 114, 50, 105, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 49, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 46, 83, 121, 115, 116, 101,
			109, 92, 77, 97, 116, 104, 92, 86, 101, 99,
			116, 111, 114, 51, 98, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 49, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 83, 121, 115, 116, 101, 109, 92, 77,
			97, 116, 104, 92, 86, 101, 99, 116, 111, 114,
			51, 105, 46, 99, 115, 0, 0, 0, 2, 0,
			0, 0, 44, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 83,
			121, 115, 116, 101, 109, 92, 77, 101, 109, 111,
			105, 122, 101, 100, 46, 99, 115, 0, 0, 0,
			5, 0, 0, 0, 40, 92, 65, 115, 115, 101,
			116, 115, 92, 80, 108, 117, 103, 105, 110, 115,
			92, 70, 97, 99, 101, 112, 117, 110, 99, 104,
			46, 83, 121, 115, 116, 101, 109, 92, 80, 111,
			111, 108, 46, 99, 115, 0, 0, 0, 3, 0,
			0, 0, 46, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 83,
			121, 115, 116, 101, 109, 92, 80, 111, 111, 108,
			101, 100, 76, 105, 115, 116, 46, 99, 115, 0,
			0, 0, 2, 0, 0, 0, 46, 92, 65, 115,
			115, 101, 116, 115, 92, 80, 108, 117, 103, 105,
			110, 115, 92, 70, 97, 99, 101, 112, 117, 110,
			99, 104, 46, 83, 121, 115, 116, 101, 109, 92,
			83, 116, 114, 105, 110, 103, 86, 105, 101, 119,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			49, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 70, 97, 99,
			101, 112, 117, 110, 99, 104, 46, 83, 121, 115,
			116, 101, 109, 92, 85, 110, 105, 111, 110, 92,
			85, 110, 105, 111, 110, 49, 54, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 49, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 83, 121, 115, 116, 101, 109,
			92, 85, 110, 105, 111, 110, 92, 85, 110, 105,
			111, 110, 51, 50, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 49, 92, 65, 115, 115, 101,
			116, 115, 92, 80, 108, 117, 103, 105, 110, 115,
			92, 70, 97, 99, 101, 112, 117, 110, 99, 104,
			46, 83, 121, 115, 116, 101, 109, 92, 85, 110,
			105, 111, 110, 92, 85, 110, 105, 111, 110, 54,
			52, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 48, 92, 65, 115, 115, 101, 116, 115, 92,
			80, 108, 117, 103, 105, 110, 115, 92, 70, 97,
			99, 101, 112, 117, 110, 99, 104, 46, 83, 121,
			115, 116, 101, 109, 92, 85, 110, 105, 111, 110,
			92, 85, 110, 105, 111, 110, 56, 46, 99, 115
		};
		result.TypesData = new byte[1419]
		{
			0, 0, 0, 0, 19, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 124, 65, 114, 114, 97, 121,
			80, 111, 111, 108, 0, 0, 0, 0, 10, 124,
			66, 117, 114, 115, 116, 85, 116, 105, 108, 0,
			0, 0, 0, 25, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 124, 66, 121, 116, 101, 65, 114,
			114, 97, 121, 83, 116, 114, 101, 97, 109, 0,
			0, 0, 0, 11, 124, 66, 117, 102, 102, 101,
			114, 76, 105, 115, 116, 0, 0, 0, 0, 21,
			66, 117, 102, 102, 101, 114, 76, 105, 115, 116,
			124, 69, 110, 117, 109, 101, 114, 97, 116, 111,
			114, 0, 0, 0, 0, 29, 67, 105, 114, 99,
			117, 108, 97, 114, 66, 117, 102, 102, 101, 114,
			124, 67, 105, 114, 99, 117, 108, 97, 114, 66,
			117, 102, 102, 101, 114, 0, 0, 0, 0, 6,
			124, 68, 101, 113, 117, 101, 0, 0, 0, 0,
			16, 124, 73, 73, 109, 109, 117, 116, 97, 98,
			108, 101, 83, 116, 97, 99, 107, 0, 0, 0,
			0, 15, 124, 73, 109, 109, 117, 116, 97, 98,
			108, 101, 83, 116, 97, 99, 107, 0, 0, 0,
			0, 25, 73, 109, 109, 117, 116, 97, 98, 108,
			101, 83, 116, 97, 99, 107, 124, 69, 109, 112,
			116, 121, 83, 116, 97, 99, 107, 0, 0, 0,
			0, 20, 124, 73, 110, 116, 114, 117, 115, 105,
			118, 101, 76, 105, 110, 107, 101, 100, 76, 105,
			115, 116, 0, 0, 0, 0, 16, 124, 73, 76,
			105, 110, 107, 101, 100, 76, 105, 115, 116, 78,
			111, 100, 101, 0, 0, 0, 0, 17, 124, 73,
			110, 116, 114, 117, 115, 105, 118, 101, 77, 105,
			110, 72, 101, 97, 112, 0, 0, 0, 0, 13,
			124, 73, 77, 105, 110, 72, 101, 97, 112, 78,
			111, 100, 101, 0, 0, 0, 0, 16, 124, 76,
			105, 109, 105, 116, 68, 105, 99, 116, 105, 111,
			110, 97, 114, 121, 0, 0, 0, 0, 10, 124,
			76, 105, 109, 105, 116, 76, 105, 115, 116, 0,
			0, 0, 0, 15, 124, 76, 105, 115, 116, 68,
			105, 99, 116, 105, 111, 110, 97, 114, 121, 0,
			0, 0, 0, 12, 124, 76, 105, 115, 116, 72,
			97, 115, 104, 83, 101, 116, 0, 0, 0, 0,
			22, 76, 105, 115, 116, 72, 97, 115, 104, 83,
			101, 116, 124, 69, 110, 117, 109, 101, 114, 97,
			116, 111, 114, 0, 0, 0, 0, 9, 124, 77,
			105, 110, 81, 117, 101, 117, 101, 0, 0, 0,
			0, 9, 124, 77, 97, 120, 81, 117, 101, 117,
			101, 0, 0, 0, 0, 14, 124, 77, 114, 117,
			68, 105, 99, 116, 105, 111, 110, 97, 114, 121,
			0, 0, 0, 0, 28, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 124, 78, 97, 116, 105, 118,
			101, 77, 101, 109, 111, 114, 121, 83, 116, 114,
			101, 97, 109, 0, 0, 0, 0, 13, 124, 83,
			112, 97, 110, 110, 105, 110, 103, 84, 114, 101,
			101, 0, 0, 0, 0, 17, 83, 112, 97, 110,
			110, 105, 110, 103, 84, 114, 101, 101, 124, 78,
			111, 100, 101, 0, 0, 0, 0, 17, 83, 112,
			97, 110, 110, 105, 110, 103, 84, 114, 101, 101,
			124, 69, 100, 103, 101, 0, 0, 0, 0, 21,
			70, 97, 99, 101, 112, 117, 110, 99, 104, 124,
			67, 111, 109, 109, 97, 110, 100, 76, 105, 110,
			101, 0, 0, 0, 0, 9, 124, 67, 104, 101,
			99, 107, 115, 117, 109, 0, 0, 0, 0, 19,
			70, 97, 99, 101, 112, 117, 110, 99, 104, 46,
			67, 114, 121, 112, 116, 124, 77, 100, 53, 0,
			0, 0, 0, 33, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 69, 120, 116, 101, 110, 100,
			124, 66, 97, 115, 101, 51, 54, 69, 120, 116,
			101, 110, 115, 105, 111, 110, 115, 0, 0, 0,
			0, 31, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 69, 120, 116, 101, 110, 100, 124, 66,
			121, 116, 101, 69, 120, 116, 101, 110, 115, 105,
			111, 110, 115, 0, 0, 0, 0, 37, 70, 97,
			99, 101, 112, 117, 110, 99, 104, 46, 69, 120,
			116, 101, 110, 100, 124, 68, 105, 99, 116, 105,
			111, 110, 97, 114, 121, 69, 120, 116, 101, 110,
			115, 105, 111, 110, 115, 0, 0, 0, 0, 21,
			70, 97, 99, 101, 112, 117, 110, 99, 104, 46,
			69, 120, 116, 101, 110, 100, 124, 76, 105, 115,
			116, 0, 0, 0, 0, 33, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 69, 120, 116, 101,
			110, 100, 124, 78, 117, 109, 98, 101, 114, 69,
			120, 116, 101, 110, 115, 105, 111, 110, 115, 0,
			0, 0, 0, 24, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 69, 120, 116, 101, 110, 100,
			124, 81, 117, 101, 117, 101, 69, 120, 0, 0,
			0, 0, 37, 70, 97, 99, 101, 112, 117, 110,
			99, 104, 46, 69, 120, 116, 101, 110, 100, 124,
			82, 101, 102, 108, 101, 99, 116, 105, 111, 110,
			69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
			0, 0, 0, 0, 24, 124, 83, 116, 114, 105,
			110, 103, 66, 117, 105, 108, 100, 101, 114, 69,
			120, 116, 101, 110, 115, 105, 111, 110, 115, 0,
			0, 0, 0, 33, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 69, 120, 116, 101, 110, 100,
			124, 83, 116, 114, 105, 110, 103, 69, 120, 116,
			101, 110, 115, 105, 111, 110, 115, 0, 0, 0,
			0, 13, 124, 71, 101, 110, 101, 114, 105, 99,
			115, 85, 116, 105, 108, 0, 0, 0, 0, 21,
			71, 101, 110, 101, 114, 105, 99, 115, 85, 116,
			105, 108, 124, 67, 97, 115, 116, 73, 109, 112,
			108, 0, 0, 0, 0, 11, 124, 66, 105, 116,
			85, 116, 105, 108, 105, 116, 121, 0, 0, 0,
			0, 12, 83, 112, 97, 116, 105, 97, 108, 124,
			71, 114, 105, 100, 0, 0, 0, 0, 17, 83,
			112, 97, 116, 105, 97, 108, 46, 71, 114, 105,
			100, 124, 78, 111, 100, 101, 0, 0, 0, 0,
			9, 124, 86, 101, 99, 116, 111, 114, 50, 98,
			0, 0, 0, 0, 9, 124, 86, 101, 99, 116,
			111, 114, 50, 105, 0, 0, 0, 0, 9, 124,
			86, 101, 99, 116, 111, 114, 51, 98, 0, 0,
			0, 0, 9, 124, 86, 101, 99, 116, 111, 114,
			51, 105, 1, 0, 0, 0, 9, 124, 77, 101,
			109, 111, 105, 122, 101, 100, 1, 0, 0, 0,
			9, 124, 77, 101, 109, 111, 105, 122, 101, 100,
			1, 0, 0, 0, 14, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 124, 80, 111, 111, 108, 0,
			0, 0, 0, 22, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 80, 111, 111, 108, 124, 73,
			80, 111, 111, 108, 101, 100, 0, 0, 0, 0,
			30, 70, 97, 99, 101, 112, 117, 110, 99, 104,
			46, 80, 111, 111, 108, 124, 73, 80, 111, 111,
			108, 67, 111, 108, 108, 101, 99, 116, 105, 111,
			110, 0, 0, 0, 0, 29, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 80, 111, 111, 108,
			124, 80, 111, 111, 108, 67, 111, 108, 108, 101,
			99, 116, 105, 111, 110, 1, 0, 0, 0, 14,
			70, 97, 99, 101, 112, 117, 110, 99, 104, 124,
			80, 111, 111, 108, 0, 0, 0, 0, 15, 124,
			66, 97, 115, 101, 80, 111, 111, 108, 101, 100,
			76, 105, 115, 116, 0, 0, 0, 0, 11, 124,
			80, 111, 111, 108, 101, 100, 76, 105, 115, 116,
			0, 0, 0, 0, 14, 124, 80, 111, 111, 108,
			101, 100, 72, 97, 115, 104, 83, 101, 116, 0,
			0, 0, 0, 20, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 124, 83, 116, 114, 105, 110, 103,
			86, 105, 101, 119, 0, 0, 0, 0, 29, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 124,
			67, 111, 109, 112, 97, 114, 101, 114, 73, 103,
			110, 111, 114, 101, 67, 97, 115, 101, 0, 0,
			0, 0, 8, 124, 85, 110, 105, 111, 110, 49,
			54, 0, 0, 0, 0, 8, 124, 85, 110, 105,
			111, 110, 51, 50, 0, 0, 0, 0, 8, 124,
			85, 110, 105, 111, 110, 54, 52, 0, 0, 0,
			0, 7, 124, 85, 110, 105, 111, 110, 56
		};
		result.TotalFiles = 44;
		result.TotalTypes = 63;
		result.IsEditorOnly = false;
		return result;
	}
}


using System;
using System.Collections.Generic;
using Spatial;

public class Grid<T>
{
	internal class Node
	{
		public HashSet<T> Contents = new HashSet<T>();

		public void Add(T obj)
		{
			Contents.Add(obj);
		}

		public bool Remove(T obj)
		{
			return Contents.Remove(obj);
		}
	}

	private float CenterX;

	private float CenterY;

	private Node[,] Nodes;

	private Dictionary<T, Node> Lookup;

	public int CellCount { get; private set; }

	public int CellSize { get; private set; }

	public Grid(int CellSize, float WorldSize)
	{
		this.CellSize = CellSize;
		CellCount = (int)(WorldSize / (float)CellSize + 0.5f);
		CenterX = WorldSize * 0.5f;
		CenterY = WorldSize * 0.5f;
		Nodes = new Node[CellCount, CellCount];
		Lookup = new Dictionary<T, Node>(512);
	}

	public int Query(float x, float y, float radius, T[] result, Func<T, bool> filter = null)
	{
		int num = Clamp((x + CenterX - radius) / (float)CellSize);
		int num2 = Clamp((x + CenterX + radius) / (float)CellSize);
		int num3 = Clamp((y + CenterY - radius) / (float)CellSize);
		int num4 = Clamp((y + CenterY + radius) / (float)CellSize);
		int num5 = 0;
		for (int i = num; i <= num2; i++)
		{
			for (int j = num3; j <= num4; j++)
			{
				if (Nodes[i, j] == null)
				{
					continue;
				}
				foreach (T content in Nodes[i, j].Contents)
				{
					if (filter == null || filter(content))
					{
						result[num5] = content;
						num5++;
						if (num5 >= result.Length)
						{
							return num5;
						}
					}
				}
			}
		}
		return num5;
	}

	public void Query<U>(float x, float y, float radius, List<U> result) where U : class
	{
		if (result == null)
		{
			return;
		}
		int num = Clamp((x + CenterX - radius) / (float)CellSize);
		int num2 = Clamp((x + CenterX + radius) / (float)CellSize);
		int num3 = Clamp((y + CenterY - radius) / (float)CellSize);
		int num4 = Clamp((y + CenterY + radius) / (float)CellSize);
		for (int i = num; i <= num2; i++)
		{
			for (int j = num3; j <= num4; j++)
			{
				if (Nodes[i, j] == null)
				{
					continue;
				}
				foreach (T content in Nodes[i, j].Contents)
				{
					if (content is U item)
					{
						result.Add(item);
					}
				}
			}
		}
	}

	private int Clamp(float input)
	{
		int num = (int)input;
		if (num < 0)
		{
			return 0;
		}
		if (num > CellCount - 1)
		{
			return CellCount - 1;
		}
		return num;
	}

	private Node GetNode(float x, float y, bool create = true)
	{
		x += CenterX;
		y += CenterY;
		int num = Clamp(x / (float)CellSize);
		int num2 = Clamp(y / (float)CellSize);
		Node node = Nodes[num, num2];
		if (node == null && create)
		{
			node = new Node();
			Nodes[num, num2] = node;
		}
		return node;
	}

	public void Add(T obj, float x, float y)
	{
		Node node = GetNode(x, y);
		node.Add(obj);
		Lookup.Add(obj, node);
	}

	public bool AddUnique(T obj, float x, float y)
	{
		if (Contains(obj))
		{
			return false;
		}
		Add(obj, x, y);
		return true;
	}

	public bool Contains(T obj)
	{
		return Lookup.ContainsKey(obj);
	}

	public void Move(T obj, float x, float y)
	{
		Node node = GetNode(x, y);
		if (Lookup.TryGetValue(obj, out var value) && node != value)
		{
			value.Remove(obj);
			node.Add(obj);
			Lookup[obj] = node;
		}
	}

	public bool Remove(T obj)
	{
		Node value = null;
		if (Lookup.TryGetValue(obj, out value))
		{
			value.Remove(obj);
			Lookup.Remove(obj);
			return true;
		}
		return false;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

public class CircularBuffer<T> : IEnumerable<T>, IEnumerable
{
	private readonly T[] _buffer;

	private int _start;

	private int _end;

	private int _size;

	public int Capacity => _buffer.Length;

	public bool IsFull => Size == Capacity;

	public bool IsEmpty => Size == 0;

	public int Size => _size;

	public T this[int index]
	{
		get
		{
			if (IsEmpty)
			{
				throw new IndexOutOfRangeException($"Cannot access index {index}. Buffer is empty");
			}
			if (index >= _size)
			{
				throw new IndexOutOfRangeException($"Cannot access index {index}. Buffer size is {_size}");
			}
			int num = InternalIndex(index);
			return _buffer[num];
		}
		set
		{
			if (IsEmpty)
			{
				throw new IndexOutOfRangeException($"Cannot access index {index}. Buffer is empty");
			}
			if (index >= _size)
			{
				throw new IndexOutOfRangeException($"Cannot access index {index}. Buffer size is {_size}");
			}
			int num = InternalIndex(index);
			_buffer[num] = value;
		}
	}

	public CircularBuffer(int capacity)
		: this(capacity, new T[0])
	{
	}

	public CircularBuffer(int capacity, T[] items)
	{
		if (capacity < 1)
		{
			throw new ArgumentException("Circular buffer cannot have negative or zero capacity.", "capacity");
		}
		if (items == null)
		{
			throw new ArgumentNullException("items");
		}
		if (items.Length > capacity)
		{
			throw new ArgumentException("Too many items to fit circular buffer", "items");
		}
		_buffer = new T[capacity];
		Array.Copy(items, _buffer, items.Length);
		_size = items.Length;
		_start = 0;
		_end = ((_size != capacity) ? _size : 0);
	}

	public T Front()
	{
		ThrowIfEmpty();
		return _buffer[_start];
	}

	public T Back()
	{
		ThrowIfEmpty();
		return _buffer[((_end != 0) ? _end : Capacity) - 1];
	}

	public void PushBack(T item)
	{
		if (IsFull)
		{
			_buffer[_end] = item;
			Increment(ref _end);
			_start = _end;
		}
		else
		{
			_buffer[_end] = item;
			Increment(ref _end);
			_size++;
		}
	}

	public void PushFront(T item)
	{
		if (IsFull)
		{
			Decrement(ref _start);
			_end = _start;
			_buffer[_start] = item;
		}
		else
		{
			Decrement(ref _start);
			_buffer[_start] = item;
			_size++;
		}
	}

	public void PopBack()
	{
		ThrowIfEmpty("Cannot take elements from an empty buffer.");
		Decrement(ref _end);
		_buffer[_end] = default(T);
		_size--;
	}

	public void PopFront()
	{
		ThrowIfEmpty("Cannot take elements from an empty buffer.");
		_buffer[_start] = default(T);
		Increment(ref _start);
		_size--;
	}

	public void Clear()
	{
		_start = 0;
		_end = 0;
		_size = 0;
		Array.Clear(_buffer, 0, _buffer.Length);
	}

	public T[] ToArray()
	{
		T[] array = new T[Size];
		int num = 0;
		foreach (ArraySegment<T> item in ToArraySegments())
		{
			Array.Copy(item.Array, item.Offset, array, num, item.Count);
			num += item.Count;
		}
		return array;
	}

	public IList<ArraySegment<T>> ToArraySegments()
	{
		return new ArraySegment<T>[2]
		{
			ArrayOne(),
			ArrayTwo()
		};
	}

	public IEnumerator<T> GetEnumerator()
	{
		IList<ArraySegment<T>> list = ToArraySegments();
		foreach (ArraySegment<T> segment in list)
		{
			for (int i = 0; i < segment.Count; i++)
			{
				yield return segment.Array[segment.Offset + i];
			}
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	private void ThrowIfEmpty(string message = "Cannot access an empty buffer.")
	{
		if (IsEmpty)
		{
			throw new InvalidOperationException(message);
		}
	}

	private void Increment(ref int index)
	{
		if (++index == Capacity)
		{
			index = 0;
		}
	}

	private void Decrement(ref int index)
	{
		if (index == 0)
		{
			index = Capacity;
		}
		index--;
	}

	private int InternalIndex(int index)
	{
		return _start + ((index < Capacity - _start) ? index : (index - Capacity));
	}

	private ArraySegment<T> ArrayOne()
	{
		if (IsEmpty)
		{
			return new ArraySegment<T>(new T[0]);
		}
		if (_start < _end)
		{
			return new ArraySegment<T>(_buffer, _start, _end - _start);
		}
		return new ArraySegment<T>(_buffer, _start, _buffer.Length - _start);
	}

	private ArraySegment<T> ArrayTwo()
	{
		if (IsEmpty)
		{
			return new ArraySegment<T>(new T[0]);
		}
		if (_start < _end)
		{
			return new ArraySegment<T>(_buffer, _end, 0);
		}
		return new ArraySegment<T>(_buffer, 0, _end);
	}
}


using System.Collections.Concurrent;

public class ArrayPool<T>
{
	private int count;

	private ConcurrentQueue<T[]>[] buffer;

	public ArrayPool(int maxSize)
	{
		count = SizeToIndex(maxSize) + 1;
		buffer = new ConcurrentQueue<T[]>[count];
		for (int i = 0; i < count; i++)
		{
			buffer[i] = new ConcurrentQueue<T[]>();
		}
	}

	public ConcurrentQueue<T[]>[] GetBuffer()
	{
		return buffer;
	}

	public T[] Rent(int minSize)
	{
		int num = SizeToIndex(minSize);
		if (!buffer[num].TryDequeue(out var result))
		{
			return new T[IndexToSize(num)];
		}
		return result;
	}

	public void Return(T[] array)
	{
		int num = SizeToIndex(array.Length);
		buffer[num].Enqueue(array);
	}

	public int SizeToIndex(int size)
	{
		size = NextPowerOfTwo(size);
		int num = 0;
		while ((size >>= 1) != 0)
		{
			num++;
		}
		return num;
	}

	public int IndexToSize(int index)
	{
		return 1 << index;
	}

	private static int NextPowerOfTwo(int n)
	{
		if (n == 0)
		{
			return 1;
		}
		n--;
		n |= n >> 1;
		n |= n >> 2;
		n |= n >> 4;
		n |= n >> 8;
		n |= n >> 16;
		return n + 1;
	}
}


using System;
using System.IO;

public class ByteArrayStream : Stream
{
	private byte[] _data;

	private int _base;

	private int _length;

	private int _position;

	public override bool CanRead => true;

	public override bool CanSeek => true;

	public override bool CanWrite => false;

	public override long Length => _length;

	public override long Position
	{
		get
		{
			return _position - _base;
		}
		set
		{
			Seek(value, SeekOrigin.Begin);
		}
	}

	public ByteArrayStream()
	{
		_data = Array.Empty<byte>();
		_base = 0;
		_length = 0;
	}

	public ByteArrayStream(byte[] data, int offset, int length)
	{
		SetData(data, offset, length);
	}

	public void SetData(byte[] data, int offset, int length)
	{
		if (data == null)
		{
			throw new ArgumentNullException("data");
		}
		if (offset < 0 || offset >= data.Length)
		{
			throw new ArgumentOutOfRangeException("offset");
		}
		if (length < 0 || offset + length > data.Length)
		{
			throw new ArgumentOutOfRangeException("length");
		}
		_data = data;
		_base = offset;
		_length = length;
		_position = _base;
	}

	public override int Read(byte[] buffer, int offset, int count)
	{
		if (buffer == null)
		{
			throw new ArgumentNullException("buffer");
		}
		if (offset < 0 || offset >= buffer.Length)
		{
			throw new ArgumentOutOfRangeException("offset");
		}
		if (count < 0 || count > buffer.Length - offset)
		{
			throw new ArgumentOutOfRangeException("count");
		}
		int num = Math.Min(_position + count, _base + _length) - _position;
		if (num <= 0)
		{
			return 0;
		}
		Buffer.BlockCopy(_data, _position, buffer, offset, num);
		_position += num;
		return num;
	}

	public override int ReadByte()
	{
		if (_position < _base || _position >= _base + _length)
		{
			return -1;
		}
		return _data[_position++];
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		if (buffer == null)
		{
			throw new ArgumentNullException("buffer");
		}
		if (offset < 0 || offset >= buffer.Length)
		{
			throw new ArgumentOutOfRangeException("offset");
		}
		if (count < 0 || count > buffer.Length - offset)
		{
			throw new ArgumentOutOfRangeException("count");
		}
		if (_position + count >= _base + _length)
		{
			throw new IOException("Tried to write beyond the buffer bounds");
		}
		Buffer.BlockCopy(buffer, offset, _data, _position, count);
		_position += count;
	}

	public override void WriteByte(byte value)
	{
		if (_position < _base || _position >= _base + _length)
		{
			throw new IOException("Tried to write beyond the buffer bounds");
		}
		_data[_position++] = value;
	}

	public override long Seek(long offset, SeekOrigin origin)
	{
		int num = origin switch
		{
			SeekOrigin.Current => _position + (int)offset, 
			SeekOrigin.End => _base + _length + (int)offset, 
			_ => _base + (int)offset, 
		};
		if (num < _base || num > _base + _length)
		{
			throw new ArgumentOutOfRangeException("offset");
		}
		_position = num;
		return Position;
	}

	public override void Flush()
	{
	}

	public override void SetLength(long value)
	{
		throw new NotSupportedException();
	}
}


using System;
using System.IO;
using Unity.Collections;
using UnityEngine;

public class NativeMemoryStream : Stream
{
	private NativeArray<byte> _buffer;

	private int _capacity;

	private int _length;

	private int _position;

	private bool _disposeArray;

	private Allocator _allocator;

	public const int MaxSupportedCapacity = 2000000000;

	public NativeArray<byte> Buffer => _buffer;

	public Span<byte> Span => _buffer.AsSpan().Slice(0, _length);

	public override bool CanRead => true;

	public override bool CanSeek => true;

	public override bool CanWrite => true;

	public override long Length => _length;

	public override long Position
	{
		get
		{
			return _position;
		}
		set
		{
			_position = (int)value;
		}
	}

	public NativeMemoryStream(int capacity, Allocator allocator = 4, bool disposeArray = true)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		_allocator = allocator;
		_buffer = new NativeArray<byte>(capacity, allocator, (NativeArrayOptions)1);
		_capacity = capacity;
		_disposeArray = disposeArray;
	}

	public override void Flush()
	{
	}

	public override int Read(byte[] buffer, int offset, int count)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (buffer.Length - offset < count)
		{
			throw new ArgumentException("Buffer is too small");
		}
		int num = _length - _position;
		if (num > count)
		{
			num = count;
		}
		if (num <= 0)
		{
			return 0;
		}
		NativeArray<byte>.Copy(_buffer, _position, buffer, offset, count);
		_position += count;
		return count;
	}

	public override long Seek(long offset, SeekOrigin origin)
	{
		switch (origin)
		{
		case SeekOrigin.Current:
			_position += (int)offset;
			break;
		case SeekOrigin.Begin:
			_position = (int)offset;
			break;
		case SeekOrigin.End:
			_position = _length + (int)offset;
			break;
		}
		_position = Mathf.Clamp(_position, 0, _length);
		return _position;
	}

	public override void SetLength(long value)
	{
		_length = (int)value;
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		EnsureCapacity(_position + count);
		NativeArray<byte>.Copy(buffer, offset, _buffer, _position, count);
		_position += count;
		if (_length < _position)
		{
			_length = _position;
		}
	}

	private void EnsureCapacity(int capacity)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (capacity > _capacity)
		{
			if (capacity >= 2000000000)
			{
				throw new InvalidOperationException("Capacity is too large");
			}
			int num = (int)Math.Min(2000000000L, (long)capacity * 2L);
			NativeArray<byte> val = default(NativeArray<byte>);
			val..ctor(num, _allocator, (NativeArrayOptions)1);
			NativeArray<byte>.Copy(_buffer, val, _length);
			_buffer.Dispose();
			_buffer = val;
			_capacity = num;
		}
	}

	protected override void Dispose(bool disposing)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Dispose(disposing);
		if (_disposeArray && _buffer.IsCreated)
		{
			_buffer.Dispose();
			_buffer = default(NativeArray<byte>);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch.Extend;

public static class CommandLine
{
	private static bool initialized = false;

	private static string commandline = "";

	private static Dictionary<string, string> switches = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

	public static string Full
	{
		get
		{
			Initalize();
			return commandline;
		}
	}

	public static void Force(string val)
	{
		commandline = val;
		initialized = false;
	}

	private static void Initalize()
	{
		if (initialized)
		{
			return;
		}
		initialized = true;
		string[] commandLineArgs;
		if (commandline == "")
		{
			commandLineArgs = Environment.GetCommandLineArgs();
			foreach (string text in commandLineArgs)
			{
				commandline = commandline + "\"" + text + "\" ";
			}
		}
		if (commandline == "")
		{
			return;
		}
		string text2 = "";
		commandLineArgs = commandline.SplitQuotesStrings();
		foreach (string text3 in commandLineArgs)
		{
			if (text3.Length == 0)
			{
				continue;
			}
			if (text3[0] == '-' || text3[0] == '+')
			{
				if (text2 != "" && !switches.ContainsKey(text2))
				{
					switches.Add(text2, "");
				}
				text2 = text3;
			}
			else if (text2 != "")
			{
				if (!switches.ContainsKey(text2))
				{
					switches.Add(text2, text3);
				}
				text2 = "";
			}
		}
		if (text2 != "" && !switches.ContainsKey(text2))
		{
			switches.Add(text2, "");
		}
	}

	public static bool HasSwitch(string strName)
	{
		Initalize();
		return switches.ContainsKey(strName);
	}

	public static string GetSwitch(string strName, string strDefault)
	{
		Initalize();
		string value = "";
		if (!switches.TryGetValue(strName, out value))
		{
			return strDefault;
		}
		return value;
	}

	public static int GetSwitchInt(string strName, int iDefault)
	{
		Initalize();
		string value = "";
		if (!switches.TryGetValue(strName, out value))
		{
			return iDefault;
		}
		int result = iDefault;
		if (!int.TryParse(value, out result))
		{
			return iDefault;
		}
		return result;
	}

	public static Dictionary<string, string> GetSwitches()
	{
		Initalize();
		return switches;
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;
using Facepunch;

public static class Pool
{
	public interface IPooled
	{
		void EnterPool();

		void LeavePool();
	}

	public interface IPoolCollection
	{
		long ItemsCapacity { get; }

		long ItemsInStack { get; }

		long ItemsInUse { get; }

		long ItemsCreated { get; }

		long ItemsTaken { get; }

		long ItemsSpilled { get; }

		long MaxItemsInUse { get; }

		void Reset();

		void ResetMaxUsageCounter();

		void Add(object obj);
	}

	public class PoolCollection<T> : IPoolCollection where T : class, new()
	{
		private static readonly object collectionLock = new object();

		private BufferList<T> buffer;

		public long ItemsCapacity { get; private set; }

		public long ItemsInStack { get; private set; }

		public long ItemsInUse { get; private set; }

		public long ItemsCreated { get; private set; }

		public long ItemsTaken { get; private set; }

		public long ItemsSpilled { get; private set; }

		public long MaxItemsInUse { get; private set; }

		public PoolCollection()
		{
			Resize(512);
		}

		public void Reset()
		{
			Resize((int)ItemsCapacity);
		}

		public void ResetMaxUsageCounter()
		{
			lock (collectionLock)
			{
				MaxItemsInUse = ItemsInUse;
			}
		}

		public void Resize(int size)
		{
			lock (collectionLock)
			{
				buffer = new BufferList<T>(size);
				ItemsCapacity = size;
				ItemsInStack = 0L;
				ItemsInUse = 0L;
				ItemsCreated = 0L;
				ItemsTaken = 0L;
				ItemsSpilled = 0L;
				MaxItemsInUse = 0L;
			}
		}

		public void Add(T obj)
		{
			if (obj is IPooled pooled)
			{
				pooled.EnterPool();
			}
			lock (collectionLock)
			{
				ItemsInUse--;
				if (ItemsInStack < ItemsCapacity)
				{
					buffer.Push(obj);
					ItemsInStack++;
				}
				else
				{
					ItemsSpilled++;
				}
			}
		}

		public T Take()
		{
			T val;
			lock (collectionLock)
			{
				ItemsInUse++;
				MaxItemsInUse = Math.Max(ItemsInUse, MaxItemsInUse);
				if (ItemsInStack > 0)
				{
					val = buffer.Pop();
					ItemsInStack--;
					ItemsTaken++;
				}
				else
				{
					val = new T();
					ItemsCreated++;
				}
			}
			if (val is IPooled pooled)
			{
				pooled.LeavePool();
			}
			return val;
		}

		public void Fill()
		{
			long num = ItemsCapacity - ItemsInStack;
			for (int i = 0; i < num; i++)
			{
				T val = new T();
				if (val is IPooled pooled)
				{
					pooled.EnterPool();
				}
				lock (collectionLock)
				{
					buffer.Push(val);
					ItemsInStack++;
				}
			}
		}

		void IPoolCollection.Add(object obj)
		{
			Add((T)obj);
		}
	}

	public static ConcurrentDictionary<Type, IPoolCollection> Directory = new ConcurrentDictionary<Type, IPoolCollection>();

	[Obsolete("FreeList got superseeded by Free<T>(where T : IPooled) and FreeUnmanaged<T>, use those instead")]
	public static void FreeList<T>(ref List<T> obj)
	{
		FreeUnmanaged(ref obj);
	}

	[Obsolete("FreeListAndItems got superseeded by Free<T>(list, true), use that instead")]
	public static void FreeListAndItems<T>(ref List<T> items) where T : class, IPooled, new()
	{
		Free(ref items, freeElements: true);
	}

	[Obsolete("ClearList is deprecated and about to be removed")]
	public static void ClearList<T>(ICollection<T> items) where T : class, IPooled, new()
	{
		if (items == null)
		{
			throw new ArgumentNullException();
		}
		foreach (T item in items)
		{
			if (item != null)
			{
				T obj = item;
				Free(ref obj);
			}
		}
		items.Clear();
	}

	[Obsolete("FreeMemoryStream is superseeded by FreeUnmanaged, use that instead")]
	public static void FreeMemoryStream(ref MemoryStream obj)
	{
		FreeUnmanaged(ref obj);
	}

	public static void Free<T>(ref T obj) where T : class, IPooled, new()
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		FreeInternal(ref obj);
	}

	public static void Free<T>(ref List<T> obj, bool freeElements = false) where T : class, IPooled, new()
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		if (freeElements)
		{
			foreach (T item in obj)
			{
				if (item != null)
				{
					T obj2 = item;
					Free(ref obj2);
				}
			}
		}
		obj.Clear();
		FreeInternal(ref obj);
	}

	public static void Free<T>(ref HashSet<T> obj, bool freeElements = false) where T : class, IPooled, new()
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		if (freeElements)
		{
			foreach (T item in obj)
			{
				if (item != null)
				{
					T obj2 = item;
					Free(ref obj2);
				}
			}
		}
		obj.Clear();
		FreeInternal(ref obj);
	}

	public static void Free<TKey, TVal>(ref Dictionary<TKey, TVal> dict, bool freeElements = false) where TVal : class, IPooled, new()
	{
		if (dict == null)
		{
			throw new ArgumentNullException();
		}
		if (freeElements)
		{
			foreach (KeyValuePair<TKey, TVal> item in dict)
			{
				if (item.Value != null)
				{
					TVal obj = item.Value;
					Free(ref obj);
				}
			}
		}
		dict.Clear();
		FreeInternal(ref dict);
	}

	public static void Free<T>(ref BufferList<T> obj, bool freeElements = false) where T : class, IPooled, new()
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		if (freeElements)
		{
			foreach (T item in obj)
			{
				if (item != null)
				{
					T obj2 = item;
					Free(ref obj2);
				}
			}
		}
		obj.Clear();
		FreeInternal(ref obj);
	}

	public static void Free<TKey, TVal>(ref ListDictionary<TKey, TVal> dict, bool freeElements = false) where TVal : class, IPooled, new()
	{
		if (dict == null)
		{
			throw new ArgumentNullException();
		}
		if (freeElements)
		{
			for (int i = 0; i < dict.Values.Count; i++)
			{
				TVal obj = dict.Values[i];
				if (obj != null)
				{
					Free(ref obj);
				}
			}
		}
		dict.Clear();
		FreeInternal(ref dict);
	}

	public static void Free<T>(ref Queue<T> obj, bool freeElements = false) where T : class, IPooled, new()
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		if (freeElements)
		{
			foreach (T item in obj)
			{
				if (item != null)
				{
					T obj2 = item;
					Free(ref obj2);
				}
			}
		}
		obj.Clear();
		FreeInternal(ref obj);
	}

	public static void Free<T>(ref ListHashSet<T> obj, bool freeElements = false) where T : class, IPooled, new()
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		if (freeElements)
		{
			foreach (T item in obj)
			{
				if (item != null)
				{
					T obj2 = item;
					Free(ref obj2);
				}
			}
		}
		obj.Clear();
		FreeInternal(ref obj);
	}

	public static void FreeUnsafe<T>(ref T obj) where T : class, new()
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		FreeInternal(ref obj);
	}

	public static void FreeUnmanaged(ref MemoryStream obj)
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		obj.SetLength(0L);
		FreeInternal(ref obj);
	}

	public static void FreeUnmanaged(ref StringBuilder obj)
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		obj.Clear();
		FreeInternal(ref obj);
	}

	public static void FreeUnmanaged(ref Stopwatch obj)
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		obj.Reset();
		FreeInternal(ref obj);
	}

	public static void FreeUnmanaged<T>(ref List<T> obj)
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		obj.Clear();
		FreeInternal(ref obj);
	}

	public static void FreeUnmanaged<T>(ref HashSet<T> obj)
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		obj.Clear();
		FreeInternal(ref obj);
	}

	public static void FreeUnmanaged<TKey, TVal>(ref Dictionary<TKey, TVal> dict)
	{
		if (dict == null)
		{
			throw new ArgumentNullException();
		}
		dict.Clear();
		FreeInternal(ref dict);
	}

	public static void FreeUnmanaged<T>(ref BufferList<T> obj)
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		obj.Clear();
		FreeInternal(ref obj);
	}

	public static void FreeUnmanaged<TKey, TVal>(ref ListDictionary<TKey, TVal> dict)
	{
		if (dict == null)
		{
			throw new ArgumentNullException();
		}
		dict.Clear();
		FreeInternal(ref dict);
	}

	public static void FreeUnmanaged<T>(ref Queue<T> obj)
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		obj.Clear();
		FreeInternal(ref obj);
	}

	public static void FreeUnmanaged<T>(ref ListHashSet<T> obj)
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		obj.Clear();
		FreeInternal(ref obj);
	}

	private static void FreeInternal<T>(ref T obj) where T : class, new()
	{
		FindCollection<T>().Add(obj);
		obj = null;
	}

	public static T Get<T>() where T : class, new()
	{
		return FindCollection<T>().Take();
	}

	[Obsolete("GetList<T> is superseeded by Get<List<T>> and will be removed soon.")]
	public static List<T> GetList<T>()
	{
		List<T> list = Get<List<T>>();
		list.Clear();
		return list;
	}

	public static void ResizeBuffer<T>(int size) where T : class, new()
	{
		FindCollection<T>().Resize(size);
	}

	public static void FillBuffer<T>() where T : class, new()
	{
		FindCollection<T>().Fill();
	}

	public static PoolCollection<T> FindCollection<T>() where T : class, new()
	{
		return Pool<T>.Collection;
	}

	public static void Clear(string filter = null)
	{
		if (string.IsNullOrEmpty(filter))
		{
			foreach (KeyValuePair<Type, IPoolCollection> item in Directory)
			{
				item.Value.Reset();
			}
			return;
		}
		foreach (KeyValuePair<Type, IPoolCollection> item2 in Directory)
		{
			if (item2.Key.FullName.Contains(filter, CompareOptions.IgnoreCase))
			{
				item2.Value.Reset();
			}
		}
	}

	private static bool Contains(this string haystack, string needle, CompareOptions options)
	{
		return CultureInfo.InvariantCulture.CompareInfo.IndexOf(haystack, needle, options) >= 0;
	}
}


using Facepunch;

internal static class Pool<T> where T : class, new()
{
	public static Pool.PoolCollection<T> Collection;

	static Pool()
	{
		Collection = new Pool.PoolCollection<T>();
		Pool.Directory[typeof(T)] = Collection;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;

public readonly struct StringView
{
	public class ComparerIgnoreCase : EqualityComparer<StringView>
	{
		public static ComparerIgnoreCase Instance = new ComparerIgnoreCase();

		public override bool Equals(StringView x, StringView y)
		{
			if (x.Length != y.Length)
			{
				return false;
			}
			for (int i = 0; i != x.Length; i++)
			{
				char c = x._source[x._start + i];
				char c2 = y._source[y._start + i];
				if (c != c2 && ((c | 0x20) != (c2 | 0x20) || (uint)((c | 0x20) - 97) > 25u))
				{
					return false;
				}
			}
			return true;
		}

		public override int GetHashCode(StringView obj)
		{
			int num = 5381;
			int num2 = num;
			int start = obj._start;
			while (start != obj._end)
			{
				int num3 = obj._source[start++];
				if ((uint)((num3 | 0x20) - 97) <= 25u)
				{
					num3 |= 0x20;
				}
				num = ((num << 5) + num) ^ num3;
				if (start == obj._end)
				{
					break;
				}
				num3 = obj._source[start++];
				if ((uint)((num3 | 0x20) - 97) <= 25u)
				{
					num3 |= 0x20;
				}
				num2 = ((num2 << 5) + num2) ^ num3;
			}
			return num + num2 * 1566083941;
		}
	}

	private readonly string _source;

	private readonly int _start;

	private readonly int _end;

	public int Length => _end - _start;

	public char this[int index]
	{
		get
		{
			if (index >= Length || index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			return _source[_start + index];
		}
	}

	public StringView(string source)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		_source = source;
		_start = 0;
		_end = _source.Length;
	}

	public StringView(string source, int start)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		_source = source;
		_start = start;
		_end = _source.Length;
		if (_start > _end)
		{
			throw new ArgumentOutOfRangeException($"Invalid view arguments: start({_start}) is after end({_end})!");
		}
		if (_start < 0)
		{
			throw new ArgumentOutOfRangeException($"Start({_start}) was past the start of string!");
		}
	}

	public StringView(string source, int start, int length)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		_source = source;
		_start = start;
		_end = _start + length;
		if (_start > _end)
		{
			throw new ArgumentOutOfRangeException($"Invalid view arguments: start({_start}) is after end({_end})!");
		}
		if (_end > _source.Length)
		{
			throw new ArgumentOutOfRangeException($"End({_end}) was past the length of string!");
		}
		if (_start < 0)
		{
			throw new ArgumentOutOfRangeException($"Start({_start}) was past the start of string!");
		}
	}

	public static implicit operator StringView(string source)
	{
		return new StringView(source);
	}

	public static implicit operator ReadOnlySpan<char>(StringView view)
	{
		return view._source.AsSpan(view._start, view.Length);
	}

	public static explicit operator string(StringView view)
	{
		return view.ToString();
	}

	public override string ToString()
	{
		return _source.Substring(_start, Length);
	}

	public override int GetHashCode()
	{
		int num = 5381;
		int num2 = num;
		int start = _start;
		while (start != _end)
		{
			int num3 = _source[start++];
			num = ((num << 5) + num) ^ num3;
			if (start == _end)
			{
				break;
			}
			num3 = _source[start++];
			num2 = ((num2 << 5) + num2) ^ num3;
		}
		return num + num2 * 1566083941;
	}

	public override bool Equals(object obj)
	{
		return Equals(obj, StringComparison.CurrentCulture);
	}

	public bool Equals(object obj, StringComparison comparisonOptions)
	{
		if (obj is StringView otherSv)
		{
			return Equals(otherSv);
		}
		if (obj is string text)
		{
			if (text.Length == Length)
			{
				return string.Compare(_source, _start, text, 0, Length, comparisonOptions) == 0;
			}
			return false;
		}
		throw new ArgumentException($"Unsupported type for equality check! Other object was {obj.GetType()}");
	}

	public bool Equals(string other)
	{
		if (other == null || other.Length != Length)
		{
			return false;
		}
		for (int i = 0; i < Length; i++)
		{
			if (_source[_start + i] != other[i])
			{
				return false;
			}
		}
		return true;
	}

	public bool Equals(char other)
	{
		if (Length == 1)
		{
			return _source[_start] == other;
		}
		return false;
	}

	public bool Equals(StringView otherSv)
	{
		if (Length != otherSv.Length)
		{
			return false;
		}
		for (int i = 0; i != Length; i++)
		{
			if (_source[_start + i] != otherSv._source[otherSv._start + i])
			{
				return false;
			}
		}
		return true;
	}

	public static bool operator ==(StringView left, StringView right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(StringView left, StringView right)
	{
		return !left.Equals(right);
	}

	public void Split(char delim, ICollection<StringView> collection)
	{
		int num = _start;
		for (int i = _start; i != _end; i++)
		{
			if (_source[i] == delim)
			{
				if (num != i)
				{
					collection.Add(new StringView(_source, num, i - num));
				}
				num = i + 1;
			}
		}
		if (num != _end)
		{
			collection.Add(new StringView(_source, num, _end - num));
		}
	}

	public bool StartsWith(StringView other)
	{
		if (other.Length > Length)
		{
			return false;
		}
		for (int i = 0; i < other.Length; i++)
		{
			if (_source[_start + i] != other._source[other._start + i])
			{
				return false;
			}
		}
		return true;
	}

	public StringView Substring(int offset)
	{
		if (offset > Length || offset < 0)
		{
			throw new ArgumentOutOfRangeException("offset");
		}
		return new StringView(_source, _start + offset, Length - offset);
	}

	public StringView Substring(int offset, int length)
	{
		if (offset > Length || offset < 0)
		{
			throw new ArgumentOutOfRangeException("offset");
		}
		if (_start + offset + length > _end)
		{
			throw new ArgumentOutOfRangeException("length");
		}
		return new StringView(_source, _start + offset, length);
	}

	public StringView Slice(int offset, int length)
	{
		return Substring(offset, length);
	}

	public bool Contains(StringView other)
	{
		if (other.Length > Length)
		{
			return false;
		}
		int num = 0;
		for (int i = 0; i < Length; i++)
		{
			if (_source[_start + i] == other._source[other._start + num])
			{
				num++;
				if (num == other._end - other._start)
				{
					return true;
				}
			}
			else
			{
				num = 0;
			}
		}
		return false;
	}

	public int IndexOf(StringView other)
	{
		if (other.Length > Length)
		{
			return -1;
		}
		int num = 0;
		for (int i = 0; i < Length; i++)
		{
			if (_source[_start + i] == other._source[other._start + num])
			{
				num++;
				if (num == other._end - other._start)
				{
					return i - num + 1;
				}
			}
			else
			{
				num = 0;
			}
		}
		return -1;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;

public static class Base36Extensions
{
	private const string CharList = "0123456789abcdefghijklmnopqrstuvwxyz";

	private static char[] CharArray = "0123456789abcdefghijklmnopqrstuvwxyz".ToCharArray();

	public static string ToBase36<T>(this T i) where T : struct, IComparable, IComparable<T>, IConvertible, IEquatable<T>, IFormattable
	{
		long num = (long)Convert.ToDecimal(i);
		if (num < 0)
		{
			throw new ArgumentOutOfRangeException("input", num, "input cannot be negative");
		}
		Stack<char> stack = new Stack<char>();
		while (num != 0L)
		{
			stack.Push(CharArray[num % 36]);
			num /= 36;
		}
		return new string(stack.ToArray());
	}

	public static long FromBase36(this string input)
	{
		IEnumerable<char> enumerable = input.ToLower().Reverse();
		long num = 0L;
		int num2 = 0;
		foreach (char item in enumerable)
		{
			num += "0123456789abcdefghijklmnopqrstuvwxyz".IndexOf(item) * (long)Math.Pow(36.0, num2);
			num2++;
		}
		return num;
	}
}


using System.Runtime.CompilerServices;

public static class ByteExtensions
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static T ReadUnsafe<T>(this byte[] buffer, int iOffset = 0) where T : unmanaged
	{
		fixed (byte* ptr = buffer)
		{
			return *(T*)(ptr + iOffset);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static void WriteUnsafe<T>(this byte[] buffer, in T value, int iOffset = 0) where T : unmanaged
	{
		fixed (byte* ptr = buffer)
		{
			*(T*)(ptr + iOffset) = value;
		}
	}
}


using System.Collections.Generic;
using Facepunch;

public static class DictionaryExtensions
{
	public static TValue GetOrCreate<TKey, TValue>(this Dictionary<TKey, TValue> dict, TKey key) where TValue : new()
	{
		if (dict.TryGetValue(key, out var value))
		{
			return value;
		}
		value = new TValue();
		dict.Add(key, value);
		return value;
	}

	public static TValue GetOrCreatePooled<TKey, TValue>(this Dictionary<TKey, TValue> dict, TKey key) where TValue : class, new()
	{
		if (dict.TryGetValue(key, out var value))
		{
			return value;
		}
		value = Pool.Get<TValue>();
		dict.Add(key, value);
		return value;
	}

	public static Dictionary<TKey, TValue> Clone<TKey, TValue>(this Dictionary<TKey, TValue> dict)
	{
		Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>(dict.Count, dict.Comparer);
		foreach (KeyValuePair<TKey, TValue> item in dict)
		{
			dictionary.Add(item.Key, item.Value);
		}
		return dictionary;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;

public static class List
{
	public static void Compare<T>(this List<T> a, List<T> b, List<T> added, List<T> removed, List<T> remained) where T : class
	{
		if (a == null && b == null)
		{
			return;
		}
		if (a == null)
		{
			added?.AddRange(b);
		}
		else if (b == null)
		{
			removed?.AddRange(a);
		}
		else
		{
			if (a.Count == 0 && b.Count == 0)
			{
				return;
			}
			HashSet<T> obj = Pool.Get<HashSet<T>>();
			foreach (T item in a)
			{
				obj.Add(item);
			}
			HashSet<T> obj2 = Pool.Get<HashSet<T>>();
			foreach (T item2 in b)
			{
				if (!obj2.Contains(item2))
				{
					if (obj.Contains(item2))
					{
						remained?.Add(item2);
					}
					else
					{
						added?.Add(item2);
					}
					obj2.Add(item2);
				}
			}
			obj.Clear();
			foreach (T item3 in b)
			{
				obj.Add(item3);
			}
			foreach (T item4 in a)
			{
				if (!obj2.Contains(item4))
				{
					if (obj.Contains(item4))
					{
						remained?.Add(item4);
					}
					else
					{
						removed?.Add(item4);
					}
					obj2.Add(item4);
				}
			}
			Pool.FreeUnmanaged(ref obj2);
			Pool.FreeUnmanaged(ref obj);
		}
	}

	public static void Compare<TListA, TListB, TItemA, TItemB, TKey>(this TListA a, TListB b, HashSet<TKey> added, HashSet<TKey> removed, HashSet<TKey> remained, Func<TItemA, TKey> selectorA, Func<TItemB, TKey> selectorB) where TListA : IEnumerable<TItemA> where TListB : IEnumerable<TItemB> where TKey : IEquatable<TKey>
	{
		if (a == null)
		{
			throw new ArgumentNullException("a");
		}
		if (b == null)
		{
			throw new ArgumentNullException("b");
		}
		if (added == null)
		{
			throw new ArgumentNullException("added");
		}
		if (removed == null)
		{
			throw new ArgumentNullException("removed");
		}
		if (remained == null)
		{
			throw new ArgumentNullException("remained");
		}
		added.Clear();
		foreach (TItemB item in b)
		{
			added.Add(selectorB(item));
		}
		removed.Clear();
		foreach (TItemA item2 in a)
		{
			removed.Add(selectorA(item2));
		}
		remained.Clear();
		foreach (TKey item3 in removed)
		{
			if (added.Contains(item3))
			{
				remained.Add(item3);
			}
		}
		added.ExceptWith(remained);
		removed.ExceptWith(remained);
	}

	public static TItem FindWith<TItem, TKey>(this IReadOnlyCollection<TItem> items, Func<TItem, TKey> selector, TKey search, IEqualityComparer<TKey> comparer = null)
	{
		comparer = comparer ?? EqualityComparer<TKey>.Default;
		foreach (TItem item in items)
		{
			if (comparer.Equals(selector(item), search))
			{
				return item;
			}
		}
		return default(TItem);
	}

	public static TItem? TryFindWith<TItem, TKey>(this IReadOnlyCollection<TItem> items, Func<TItem, TKey> selector, TKey search, IEqualityComparer<TKey> comparer = null) where TItem : struct
	{
		comparer = comparer ?? EqualityComparer<TKey>.Default;
		foreach (TItem item in items)
		{
			if (comparer.Equals(selector(item), search))
			{
				return item;
			}
		}
		return null;
	}

	public static int FindIndexWith<TItem, TKey>(this IReadOnlyList<TItem> items, Func<TItem, TKey> selector, TKey search, IEqualityComparer<TKey> comparer = null) where TKey : IEquatable<TKey>
	{
		comparer = comparer ?? EqualityComparer<TKey>.Default;
		for (int i = 0; i < items.Count; i++)
		{
			TItem arg = items[i];
			if (comparer.Equals(search, selector(arg)))
			{
				return i;
			}
		}
		return -1;
	}

	public static int FindIndex<TItem>(this IReadOnlyList<TItem> items, TItem search, IEqualityComparer<TItem> comparer = null)
	{
		comparer = comparer ?? EqualityComparer<TItem>.Default;
		for (int i = 0; i < items.Count; i++)
		{
			TItem y = items[i];
			if (comparer.Equals(search, y))
			{
				return i;
			}
		}
		return -1;
	}

	public static List<T> ShallowClonePooled<T>(this List<T> items)
	{
		if (items == null)
		{
			return null;
		}
		List<T> list = Pool.Get<List<T>>();
		foreach (T item in items)
		{
			list.Add(item);
		}
		return list;
	}

	public static bool Resize<T>(this List<T> list, int newCount)
	{
		if (list == null)
		{
			throw new ArgumentNullException("list");
		}
		if (newCount < 0)
		{
			throw new ArgumentOutOfRangeException("newCount");
		}
		if (list.Count == newCount)
		{
			return false;
		}
		if (list.Count > newCount)
		{
			while (list.Count > newCount)
			{
				list.RemoveAt(list.Count - 1);
			}
		}
		else
		{
			while (list.Count < newCount)
			{
				list.Add(default(T));
			}
		}
		return true;
	}
}


using System;

public static class NumberExtensions
{
	public static string FormatBytes<T>(this T input, bool shortFormat = false) where T : struct, IComparable, IComparable<T>, IConvertible, IEquatable<T>, IFormattable
	{
		ulong num = (ulong)Convert.ChangeType(input, typeof(ulong));
		double num2 = num;
		string text;
		if (num >= 1152921504606846976L)
		{
			text = "eb";
			num2 = num >> 50;
		}
		else if (num >= 1125899906842624L)
		{
			text = "pb";
			num2 = num >> 40;
		}
		else if (num >= 1099511627776L)
		{
			text = "tb";
			num2 = num >> 30;
		}
		else if (num >= 1073741824)
		{
			text = "gb";
			num2 = num >> 20;
		}
		else if (num >= 1048576)
		{
			text = "mb";
			num2 = num >> 10;
		}
		else
		{
			if (num < 1024)
			{
				return num.ToString("0b");
			}
			text = "kb";
			num2 = num;
		}
		return (num2 / 1024.0).ToString(shortFormat ? "0" : "0.00") + text;
	}

	public static T Clamp<T>(this T input, T min, T max) where T : struct, IComparable, IComparable<T>, IConvertible, IEquatable<T>, IFormattable
	{
		if (input.CompareTo(min) < 0)
		{
			return min;
		}
		if (input.CompareTo(max) > 0)
		{
			return max;
		}
		return input;
	}

	public static string FormatSeconds(this ulong i)
	{
		return FormatSeconds((long)i);
	}

	public static string FormatSeconds(this long s)
	{
		double num = Math.Floor((float)s / 60f);
		double num2 = Math.Floor((float)num / 60f);
		double num3 = Math.Floor((float)num2 / 24f);
		double num4 = Math.Floor((float)num3 / 7f);
		if (s < 60)
		{
			return $"{s}s";
		}
		if (num < 60.0)
		{
			return string.Format("{1}m{0}s", s % 60, num, num2, num3, num4);
		}
		if (num2 < 48.0)
		{
			return string.Format("{2}h{1}m{0}s", s % 60, num % 60.0, num2, num3, num4);
		}
		if (num3 < 7.0)
		{
			return string.Format("{3}d{2}h{1}m{0}s", s % 60, num % 60.0, num2 % 24.0, num3 % 7.0, num4);
		}
		return string.Format("{4}w{3}d{2}h{1}m{0}s", s % 60, num % 60.0, num2 % 24.0, num3 % 7.0, num4);
	}

	public static string FormatSecondsLong(this ulong i)
	{
		return FormatSecondsLong((long)i);
	}

	public static string FormatSecondsLong(this long s)
	{
		double num = Math.Floor((float)s / 60f);
		double num2 = Math.Floor((float)num / 60f);
		double num3 = Math.Floor((float)num2 / 24f);
		double num4 = Math.Floor((float)num3 / 7f);
		if (s < 60)
		{
			return $"{s} seconds";
		}
		if (num < 60.0)
		{
			return string.Format("{1} minutes", s % 60, num, num2, num3, num4);
		}
		if (num2 < 48.0)
		{
			return string.Format("{2} hours", s % 60, num % 60.0, num2, num3, num4);
		}
		if (num3 < 2.0)
		{
			return string.Format("{3} days, {2} hours", s % 60, num % 60.0, num2 % 24.0, num3 % 7.0, num4);
		}
		return string.Format("{3} days", s % 60, num % 60.0, num2 % 24.0, num3, num4);
	}

	public static string FormatNumberShort(this ulong i)
	{
		return FormatNumberShort((long)i);
	}

	public static string FormatNumberShort(this long num)
	{
		if (num >= 1000000000)
		{
			return ((double)num / 1000000000.0).ToString("0.#") + "B";
		}
		if (num >= 1000000)
		{
			return ((double)num / 1000000.0).ToString("0.#") + "M";
		}
		if (num >= 1000)
		{
			return ((double)num / 1000.0).ToString("0.#") + "K";
		}
		return num.ToString("#,0");
	}

	public static string FormatDistance(this float num)
	{
		return $"{num:F1}m";
	}
}


using System.Collections.Generic;

public static class QueueEx
{
	public static void EnqueueRange<T>(this Queue<T> queue, IEnumerable<T> items)
	{
		foreach (T item in items)
		{
			queue.Enqueue(item);
		}
	}
}


using System;
using System.Reflection;

public static class ReflectionExtensions
{
	public static bool HasAttribute(this MemberInfo method, Type attribute)
	{
		return method.GetCustomAttributes(attribute, inherit: true).Length != 0;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Facepunch.Extend;

public static class StringExtensions
{
	private static readonly Regex regexSplitQuotes = new Regex("\"([^\"]+)\"|'([^']+)'|\\S+");

	private static char[] spaceOrQuote = new char[2] { ' ', '"' };

	private static StringBuilder _quoteSafeBuilder = new StringBuilder();

	private static char[] FilenameDelim = new char[2] { '/', '\\' };

	private static readonly char[] _badCharacters = new char[73]
	{
		'\0', '\u0001', '\u0002', '\u0003', '\u0004', '\u0005', '\u0006', '\a', '\b', '\t',
		'\v', '\f', '\r', '\u000e', '\u000f', '\u0010', '\u0012', '\u0013', '\u0014', '\u0016',
		'\u0017', '\u0018', '\u0019', '\u001a', '\u001b', '\u001c', '\u001d', '\u001e', '\u001f', '\u00a0',
		'\u00ad', '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006', '\u2007', '\u2008',
		'\u2009', '\u200a', '\u200b', '\u200c', '\u200d', '\u200e', '\u200f', '‐', '‑', '‒',
		'–', '—', '―', '‖', '‗', '‘', '’', '‚', '‛', '“',
		'”', '„', '‟', '\u2028', '\u2029', '\u202f', '\u205f', '\u2060', '␠', '␢',
		'␣', '\u3000', '\ufeff'
	};

	public static string QuoteSafe(this string str)
	{
		lock (_quoteSafeBuilder)
		{
			_quoteSafeBuilder.Clear();
			_quoteSafeBuilder.QuoteSafe(str);
			return _quoteSafeBuilder.ToString();
		}
	}

	public static string[] SplitQuotesStrings(this string input, int maxCount = int.MaxValue)
	{
		input = input.Replace("\\\"", "&qute;");
		List<string> list = new List<string>();
		Match match = regexSplitQuotes.Match(input);
		for (int i = 0; i < maxCount; i++)
		{
			if (!match.Success)
			{
				break;
			}
			string value = match.Value;
			value = value.Trim(spaceOrQuote);
			value = value.Replace("&qute;", "\"");
			list.Add(value);
			match = match.NextMatch();
		}
		return list.ToArray();
	}

	public static decimal ToDecimal(this string str, decimal Default = 0m)
	{
		decimal result = Default;
		decimal.TryParse(str, out result);
		return result;
	}

	public static float ToFloat(this string str, float Default = 0f)
	{
		return (float)str.ToDecimal((decimal)Default);
	}

	public static int ToInt(this string str, int Default = 0)
	{
		decimal num = str.ToDecimal(Default);
		if (!(num <= -2147483648m))
		{
			if (!(num >= 2147483647m))
			{
				return (int)num;
			}
			return int.MaxValue;
		}
		return int.MinValue;
	}

	public static long ToLong(this string str, long Default = 0L)
	{
		decimal num = str.ToDecimal(Default);
		if (!(num <= -9223372036854775808m))
		{
			if (!(num >= 9223372036854775807m))
			{
				return (long)num;
			}
			return long.MaxValue;
		}
		return long.MinValue;
	}

	public static bool ToBool(this string str)
	{
		if (string.IsNullOrWhiteSpace(str))
		{
			return false;
		}
		switch (str)
		{
		case "0":
			return false;
		case "1":
			return true;
		case "False":
			return false;
		case "True":
			return true;
		default:
			str = str.Trim();
			str = str.ToLower();
			return str switch
			{
				"true" => true, 
				"t" => true, 
				"yes" => true, 
				"y" => true, 
				_ => false, 
			};
		}
	}

	public static string Truncate(this string str, int maxLength, string appendage = null)
	{
		if (string.IsNullOrEmpty(str))
		{
			return str;
		}
		if (str.Length <= maxLength)
		{
			return str;
		}
		if (appendage != null)
		{
			maxLength -= appendage.Length;
		}
		str = str.Substring(0, maxLength);
		if (appendage == null)
		{
			return str;
		}
		return str + appendage;
	}

	public static string TruncateFilename(this string str, int maxLength, string appendage = null)
	{
		if (string.IsNullOrEmpty(str))
		{
			return str;
		}
		if (str.Length <= maxLength)
		{
			return str;
		}
		maxLength -= 3;
		string text = str;
		int num = 0;
		while (num++ < 100)
		{
			List<string> list = str.Split(FilenameDelim).ToList();
			list.RemoveRange(list.Count - 1 - num, num);
			if (list.Count == 1)
			{
				return list.Last();
			}
			list.Insert(list.Count - 1, "...");
			text = string.Join("/", list.ToArray());
			if (text.Length < maxLength)
			{
				return text;
			}
		}
		return str.Split(FilenameDelim).ToList().Last();
	}

	public static bool Contains(this string source, string toCheck, StringComparison comp)
	{
		return source.IndexOf(toCheck, comp) >= 0;
	}

	public static string Snippet(this string source, string find, int padding)
	{
		if (string.IsNullOrEmpty(find))
		{
			return string.Empty;
		}
		StringBuilder stringBuilder = new StringBuilder();
		int num;
		for (num = 0; num < source.Length; num += find.Length)
		{
			num = source.IndexOf(find, num, StringComparison.InvariantCultureIgnoreCase);
			if (num == -1)
			{
				break;
			}
			int num2 = (num - padding).Clamp(0, source.Length);
			int num3 = (num2 + find.Length + padding * 2).Clamp(0, source.Length);
			num = num3;
			if (stringBuilder.Length > 0)
			{
				stringBuilder.Append(" ... ");
			}
			stringBuilder.Append(source.Substring(num2, num3 - num2));
		}
		return stringBuilder.ToString();
	}

	public static string RemoveBadCharacters(this string str)
	{
		str = new string(str.Where((char x) => !_badCharacters.Contains(x)).ToArray());
		return str;
	}

	public static string Base64Encode(this string plainText)
	{
		return Convert.ToBase64String(Encoding.UTF8.GetBytes(plainText));
	}

	public static string Base64Decode(this string base64EncodedData)
	{
		byte[] bytes = Convert.FromBase64String(base64EncodedData);
		return Encoding.UTF8.GetString(bytes);
	}
}


using System.Security.Cryptography;
using System.Text;

public class Md5
{
	public static string Calculate(string input)
	{
		return Calculate(Encoding.ASCII.GetBytes(input));
	}

	public static string Calculate(byte[] input)
	{
		byte[] array = MD5.Create().ComputeHash(input);
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < array.Length; i++)
		{
			stringBuilder.Append(array[i].ToString("x2"));
		}
		return stringBuilder.ToString();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
{
	private readonly BufferList<T> list;

	private int index;

	public T Current => list[index];

	object IEnumerator.Current => Current;

	public Enumerator(BufferList<T> list)
	{
		this.list = list;
		index = -1;
	}

	public bool MoveNext()
	{
		index++;
		return index < list.Count;
	}

	public void Reset()
	{
		index = -1;
	}

	public void Dispose()
	{
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

private sealed class EmptyStack : IImmutableStack<T>, IEnumerable<T>, IEnumerable
{
	public int Count => 0;

	public IImmutableStack<T> Push(T value)
	{
		return new ImmutableStack<T>(value, this);
	}

	public IImmutableStack<T> Pop()
	{
		throw new InvalidOperationException("The stack is empty.");
	}

	public T Peek()
	{
		throw new InvalidOperationException("The stack is empty.");
	}

	public IEnumerator<T> GetEnumerator()
	{
		yield break;
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
{
	private readonly BufferList<T> list;

	private int index;

	public T Current => list[index];

	object IEnumerator.Current => Current;

	public Enumerator(ListHashSet<T> set)
	{
		list = set.vals;
		index = -1;
	}

	public bool MoveNext()
	{
		index++;
		return index < list.Count;
	}

	public void Reset()
	{
		index = -1;
	}

	public void Dispose()
	{
	}
}


using System.Collections.Generic;

private class Node
{
	public List<Edge> edges;

	public bool connected;

	public Node()
	{
		edges = new List<Edge>();
		connected = false;
	}
}


private class Edge : IMinHeapNode<Edge>
{
	public Node source;

	public Node target;

	public T value;

	public int order { get; private set; }

	public Edge child { get; set; }

	public Edge(Node source, Node target, int order, T value)
	{
		this.source = source;
		this.target = target;
		this.order = order;
		this.value = value;
	}
}


using System;

private static class CastImpl<TSrc, TDst>
{
	[ThreadStatic]
	public static TSrc Value;

	static CastImpl()
	{
		if (typeof(TSrc) != typeof(TDst))
		{
			throw new InvalidCastException();
		}
	}
}


private struct MonoScriptData
{
	public byte[] FilePathsData;

	public byte[] TypesData;

	public int TotalTypes;

	public int TotalFiles;

	public bool IsEditorOnly;
}


using System.Collections.Generic;

internal class Node
{
	public HashSet<T> Contents = new HashSet<T>();

	public void Add(T obj)
	{
		Contents.Add(obj);
	}

	public bool Remove(T obj)
	{
		return Contents.Remove(obj);
	}
}


public interface IPooled
{
	void EnterPool();

	void LeavePool();
}


public interface IPoolCollection
{
	long ItemsCapacity { get; }

	long ItemsInStack { get; }

	long ItemsInUse { get; }

	long ItemsCreated { get; }

	long ItemsTaken { get; }

	long ItemsSpilled { get; }

	long MaxItemsInUse { get; }

	void Reset();

	void ResetMaxUsageCounter();

	void Add(object obj);
}


using System;

public class PoolCollection<T> : IPoolCollection where T : class, new()
{
	private static readonly object collectionLock = new object();

	private BufferList<T> buffer;

	public long ItemsCapacity { get; private set; }

	public long ItemsInStack { get; private set; }

	public long ItemsInUse { get; private set; }

	public long ItemsCreated { get; private set; }

	public long ItemsTaken { get; private set; }

	public long ItemsSpilled { get; private set; }

	public long MaxItemsInUse { get; private set; }

	public PoolCollection()
	{
		Resize(512);
	}

	public void Reset()
	{
		Resize((int)ItemsCapacity);
	}

	public void ResetMaxUsageCounter()
	{
		lock (collectionLock)
		{
			MaxItemsInUse = ItemsInUse;
		}
	}

	public void Resize(int size)
	{
		lock (collectionLock)
		{
			buffer = new BufferList<T>(size);
			ItemsCapacity = size;
			ItemsInStack = 0L;
			ItemsInUse = 0L;
			ItemsCreated = 0L;
			ItemsTaken = 0L;
			ItemsSpilled = 0L;
			MaxItemsInUse = 0L;
		}
	}

	public void Add(T obj)
	{
		if (obj is IPooled pooled)
		{
			pooled.EnterPool();
		}
		lock (collectionLock)
		{
			ItemsInUse--;
			if (ItemsInStack < ItemsCapacity)
			{
				buffer.Push(obj);
				ItemsInStack++;
			}
			else
			{
				ItemsSpilled++;
			}
		}
	}

	public T Take()
	{
		T val;
		lock (collectionLock)
		{
			ItemsInUse++;
			MaxItemsInUse = Math.Max(ItemsInUse, MaxItemsInUse);
			if (ItemsInStack > 0)
			{
				val = buffer.Pop();
				ItemsInStack--;
				ItemsTaken++;
			}
			else
			{
				val = new T();
				ItemsCreated++;
			}
		}
		if (val is IPooled pooled)
		{
			pooled.LeavePool();
		}
		return val;
	}

	public void Fill()
	{
		long num = ItemsCapacity - ItemsInStack;
		for (int i = 0; i < num; i++)
		{
			T val = new T();
			if (val is IPooled pooled)
			{
				pooled.EnterPool();
			}
			lock (collectionLock)
			{
				buffer.Push(val);
				ItemsInStack++;
			}
		}
	}

	void IPoolCollection.Add(object obj)
	{
		Add((T)obj);
	}
}


using System.Collections.Generic;

public class ComparerIgnoreCase : EqualityComparer<StringView>
{
	public static ComparerIgnoreCase Instance = new ComparerIgnoreCase();

	public override bool Equals(StringView x, StringView y)
	{
		if (x.Length != y.Length)
		{
			return false;
		}
		for (int i = 0; i != x.Length; i++)
		{
			char c = x._source[x._start + i];
			char c2 = y._source[y._start + i];
			if (c != c2 && ((c | 0x20) != (c2 | 0x20) || (uint)((c | 0x20) - 97) > 25u))
			{
				return false;
			}
		}
		return true;
	}

	public override int GetHashCode(StringView obj)
	{
		int num = 5381;
		int num2 = num;
		int start = obj._start;
		while (start != obj._end)
		{
			int num3 = obj._source[start++];
			if ((uint)((num3 | 0x20) - 97) <= 25u)
			{
				num3 |= 0x20;
			}
			num = ((num << 5) + num) ^ num3;
			if (start == obj._end)
			{
				break;
			}
			num3 = obj._source[start++];
			if ((uint)((num3 | 0x20) - 97) <= 25u)
			{
				num3 |= 0x20;
			}
			num2 = ((num2 << 5) + num2) ^ num3;
		}
		return num + num2 * 1566083941;
	}
}


