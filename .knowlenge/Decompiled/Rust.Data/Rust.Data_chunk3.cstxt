using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Minicopter : IDisposable, IPooled, IProto<Minicopter>, IProto
{
	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelFraction;

	[NonSerialized]
	public float pitch;

	[NonSerialized]
	public float roll;

	[NonSerialized]
	public float yaw;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Minicopter instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelFraction = 0f;
			instance.pitch = 0f;
			instance.roll = 0f;
			instance.yaw = 0f;
			Pool.Free<Minicopter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Minicopter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Minicopter instance)
	{
		instance.fuelStorageID = fuelStorageID;
		instance.fuelFraction = fuelFraction;
		instance.pitch = pitch;
		instance.roll = roll;
		instance.yaw = yaw;
	}

	public Minicopter Copy()
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		CopyTo(minicopter);
		return minicopter;
	}

	public static Minicopter Deserialize(BufferStream stream)
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		Deserialize(stream, minicopter, isDelta: false);
		return minicopter;
	}

	public static Minicopter DeserializeLengthDelimited(BufferStream stream)
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		DeserializeLengthDelimited(stream, minicopter, isDelta: false);
		return minicopter;
	}

	public static Minicopter DeserializeLength(BufferStream stream, int length)
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		DeserializeLength(stream, length, minicopter, isDelta: false);
		return minicopter;
	}

	public static Minicopter Deserialize(byte[] buffer)
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, minicopter, isDelta: false);
		return minicopter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Minicopter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Minicopter Deserialize(BufferStream stream, Minicopter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.roll = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Minicopter DeserializeLengthDelimited(BufferStream stream, Minicopter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.roll = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Minicopter DeserializeLength(BufferStream stream, int length, Minicopter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.roll = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Minicopter instance, Minicopter previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.pitch != previous.pitch)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
		if (instance.roll != previous.roll)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.roll);
		}
		if (instance.yaw != previous.yaw)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
	}

	public static void Serialize(BufferStream stream, Minicopter instance)
	{
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.pitch != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
		if (instance.roll != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.roll);
		}
		if (instance.yaw != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ModularVehicle : IDisposable, IPooled, IProto<ModularVehicle>, IProto
{
	[NonSerialized]
	public bool editable;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ModularVehicle instance)
	{
		if (instance.ShouldPool)
		{
			instance.editable = false;
			Pool.Free<ModularVehicle>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ModularVehicle with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ModularVehicle instance)
	{
		instance.editable = editable;
	}

	public ModularVehicle Copy()
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		CopyTo(modularVehicle);
		return modularVehicle;
	}

	public static ModularVehicle Deserialize(BufferStream stream)
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		Deserialize(stream, modularVehicle, isDelta: false);
		return modularVehicle;
	}

	public static ModularVehicle DeserializeLengthDelimited(BufferStream stream)
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		DeserializeLengthDelimited(stream, modularVehicle, isDelta: false);
		return modularVehicle;
	}

	public static ModularVehicle DeserializeLength(BufferStream stream, int length)
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		DeserializeLength(stream, length, modularVehicle, isDelta: false);
		return modularVehicle;
	}

	public static ModularVehicle Deserialize(byte[] buffer)
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, modularVehicle, isDelta: false);
		return modularVehicle;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ModularVehicle previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ModularVehicle Deserialize(BufferStream stream, ModularVehicle instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.editable = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ModularVehicle DeserializeLengthDelimited(BufferStream stream, ModularVehicle instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.editable = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ModularVehicle DeserializeLength(BufferStream stream, int length, ModularVehicle instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.editable = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ModularVehicle instance, ModularVehicle previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.editable);
	}

	public static void Serialize(BufferStream stream, ModularVehicle instance)
	{
		if (instance.editable)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.editable);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ModularCar : IDisposable, IPooled, IProto<ModularCar>, IProto
{
	[NonSerialized]
	public float steerAngle;

	[NonSerialized]
	public float driveWheelVel;

	[NonSerialized]
	public float throttleInput;

	[NonSerialized]
	public float brakeInput;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelFraction;

	[NonSerialized]
	public bool hasLock;

	[NonSerialized]
	public string lockCode;

	[NonSerialized]
	public List<ulong> whitelistUsers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ModularCar instance)
	{
		if (instance.ShouldPool)
		{
			instance.steerAngle = 0f;
			instance.driveWheelVel = 0f;
			instance.throttleInput = 0f;
			instance.brakeInput = 0f;
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelFraction = 0f;
			instance.hasLock = false;
			instance.lockCode = string.Empty;
			if (instance.whitelistUsers != null)
			{
				List<ulong> list = instance.whitelistUsers;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.whitelistUsers = list;
			}
			Pool.Free<ModularCar>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ModularCar with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ModularCar instance)
	{
		instance.steerAngle = steerAngle;
		instance.driveWheelVel = driveWheelVel;
		instance.throttleInput = throttleInput;
		instance.brakeInput = brakeInput;
		instance.fuelStorageID = fuelStorageID;
		instance.fuelFraction = fuelFraction;
		instance.hasLock = hasLock;
		instance.lockCode = lockCode;
		if (whitelistUsers != null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
			for (int i = 0; i < whitelistUsers.Count; i++)
			{
				ulong item = whitelistUsers[i];
				instance.whitelistUsers.Add(item);
			}
		}
		else
		{
			instance.whitelistUsers = null;
		}
	}

	public ModularCar Copy()
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		CopyTo(modularCar);
		return modularCar;
	}

	public static ModularCar Deserialize(BufferStream stream)
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		Deserialize(stream, modularCar, isDelta: false);
		return modularCar;
	}

	public static ModularCar DeserializeLengthDelimited(BufferStream stream)
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		DeserializeLengthDelimited(stream, modularCar, isDelta: false);
		return modularCar;
	}

	public static ModularCar DeserializeLength(BufferStream stream, int length)
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		DeserializeLength(stream, length, modularCar, isDelta: false);
		return modularCar;
	}

	public static ModularCar Deserialize(byte[] buffer)
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, modularCar, isDelta: false);
		return modularCar;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ModularCar previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ModularCar Deserialize(BufferStream stream, ModularCar instance, bool isDelta)
	{
		if (!isDelta && instance.whitelistUsers == null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.steerAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 53:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.whitelistUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ModularCar DeserializeLengthDelimited(BufferStream stream, ModularCar instance, bool isDelta)
	{
		if (!isDelta && instance.whitelistUsers == null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 53:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.whitelistUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ModularCar DeserializeLength(BufferStream stream, int length, ModularCar instance, bool isDelta)
	{
		if (!isDelta && instance.whitelistUsers == null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 53:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.whitelistUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ModularCar instance, ModularCar previous)
	{
		if (instance.steerAngle != previous.steerAngle)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerAngle);
		}
		if (instance.driveWheelVel != previous.driveWheelVel)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != previous.throttleInput)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != previous.brakeInput)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.hasLock);
		if (instance.lockCode != null && instance.lockCode != previous.lockCode)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.lockCode);
		}
		if (instance.whitelistUsers != null)
		{
			for (int i = 0; i < instance.whitelistUsers.Count; i++)
			{
				ulong val = instance.whitelistUsers[i];
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, ModularCar instance)
	{
		if (instance.steerAngle != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerAngle);
		}
		if (instance.driveWheelVel != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.hasLock)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.hasLock);
		}
		if (instance.lockCode != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.lockCode);
		}
		if (instance.whitelistUsers != null)
		{
			for (int i = 0; i < instance.whitelistUsers.Count; i++)
			{
				ulong val = instance.whitelistUsers[i];
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SimpleUID : IDisposable, IPooled, IProto<SimpleUID>, IProto
{
	[NonSerialized]
	public NetworkableId uid;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SimpleUID instance)
	{
		if (instance.ShouldPool)
		{
			instance.uid = default(NetworkableId);
			Pool.Free<SimpleUID>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SimpleUID with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SimpleUID instance)
	{
		instance.uid = uid;
	}

	public SimpleUID Copy()
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		CopyTo(simpleUID);
		return simpleUID;
	}

	public static SimpleUID Deserialize(BufferStream stream)
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		Deserialize(stream, simpleUID, isDelta: false);
		return simpleUID;
	}

	public static SimpleUID DeserializeLengthDelimited(BufferStream stream)
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		DeserializeLengthDelimited(stream, simpleUID, isDelta: false);
		return simpleUID;
	}

	public static SimpleUID DeserializeLength(BufferStream stream, int length)
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		DeserializeLength(stream, length, simpleUID, isDelta: false);
		return simpleUID;
	}

	public static SimpleUID Deserialize(byte[] buffer)
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, simpleUID, isDelta: false);
		return simpleUID;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SimpleUID previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SimpleUID Deserialize(BufferStream stream, SimpleUID instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SimpleUID DeserializeLengthDelimited(BufferStream stream, SimpleUID instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SimpleUID DeserializeLength(BufferStream stream, int length, SimpleUID instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SimpleUID instance, SimpleUID previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.uid.Value);
	}

	public static void Serialize(BufferStream stream, SimpleUID instance)
	{
		if (instance.uid != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref uid.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SimpleUInt : IDisposable, IPooled, IProto<SimpleUInt>, IProto
{
	[NonSerialized]
	public uint value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SimpleUInt instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0u;
			Pool.Free<SimpleUInt>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SimpleUInt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SimpleUInt instance)
	{
		instance.value = value;
	}

	public SimpleUInt Copy()
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		CopyTo(simpleUInt);
		return simpleUInt;
	}

	public static SimpleUInt Deserialize(BufferStream stream)
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		Deserialize(stream, simpleUInt, isDelta: false);
		return simpleUInt;
	}

	public static SimpleUInt DeserializeLengthDelimited(BufferStream stream)
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		DeserializeLengthDelimited(stream, simpleUInt, isDelta: false);
		return simpleUInt;
	}

	public static SimpleUInt DeserializeLength(BufferStream stream, int length)
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		DeserializeLength(stream, length, simpleUInt, isDelta: false);
		return simpleUInt;
	}

	public static SimpleUInt Deserialize(byte[] buffer)
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, simpleUInt, isDelta: false);
		return simpleUInt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SimpleUInt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SimpleUInt Deserialize(BufferStream stream, SimpleUInt instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SimpleUInt DeserializeLengthDelimited(BufferStream stream, SimpleUInt instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SimpleUInt DeserializeLength(BufferStream stream, int length, SimpleUInt instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SimpleUInt instance, SimpleUInt previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, SimpleUInt instance)
	{
		if (instance.value != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SimpleInt : IDisposable, IPooled, IProto<SimpleInt>, IProto
{
	[NonSerialized]
	public int value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SimpleInt instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0;
			Pool.Free<SimpleInt>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SimpleInt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SimpleInt instance)
	{
		instance.value = value;
	}

	public SimpleInt Copy()
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		CopyTo(simpleInt);
		return simpleInt;
	}

	public static SimpleInt Deserialize(BufferStream stream)
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		Deserialize(stream, simpleInt, isDelta: false);
		return simpleInt;
	}

	public static SimpleInt DeserializeLengthDelimited(BufferStream stream)
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		DeserializeLengthDelimited(stream, simpleInt, isDelta: false);
		return simpleInt;
	}

	public static SimpleInt DeserializeLength(BufferStream stream, int length)
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		DeserializeLength(stream, length, simpleInt, isDelta: false);
		return simpleInt;
	}

	public static SimpleInt Deserialize(byte[] buffer)
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, simpleInt, isDelta: false);
		return simpleInt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SimpleInt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SimpleInt Deserialize(BufferStream stream, SimpleInt instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SimpleInt DeserializeLengthDelimited(BufferStream stream, SimpleInt instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SimpleInt DeserializeLength(BufferStream stream, int length, SimpleInt instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SimpleInt instance, SimpleInt previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
		}
	}

	public static void Serialize(BufferStream stream, SimpleInt instance)
	{
		if (instance.value != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VehicleLift : IDisposable, IPooled, IProto<VehicleLift>, IProto
{
	[NonSerialized]
	public bool platformIsOccupied;

	[NonSerialized]
	public bool editableOccupant;

	[NonSerialized]
	public bool driveableOccupant;

	[NonSerialized]
	public int occupantLockState;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VehicleLift instance)
	{
		if (instance.ShouldPool)
		{
			instance.platformIsOccupied = false;
			instance.editableOccupant = false;
			instance.driveableOccupant = false;
			instance.occupantLockState = 0;
			Pool.Free<VehicleLift>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VehicleLift with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VehicleLift instance)
	{
		instance.platformIsOccupied = platformIsOccupied;
		instance.editableOccupant = editableOccupant;
		instance.driveableOccupant = driveableOccupant;
		instance.occupantLockState = occupantLockState;
	}

	public VehicleLift Copy()
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		CopyTo(vehicleLift);
		return vehicleLift;
	}

	public static VehicleLift Deserialize(BufferStream stream)
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		Deserialize(stream, vehicleLift, isDelta: false);
		return vehicleLift;
	}

	public static VehicleLift DeserializeLengthDelimited(BufferStream stream)
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		DeserializeLengthDelimited(stream, vehicleLift, isDelta: false);
		return vehicleLift;
	}

	public static VehicleLift DeserializeLength(BufferStream stream, int length)
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		DeserializeLength(stream, length, vehicleLift, isDelta: false);
		return vehicleLift;
	}

	public static VehicleLift Deserialize(byte[] buffer)
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vehicleLift, isDelta: false);
		return vehicleLift;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VehicleLift previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VehicleLift Deserialize(BufferStream stream, VehicleLift instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.platformIsOccupied = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.editableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.driveableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.occupantLockState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VehicleLift DeserializeLengthDelimited(BufferStream stream, VehicleLift instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.platformIsOccupied = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.editableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.driveableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.occupantLockState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VehicleLift DeserializeLength(BufferStream stream, int length, VehicleLift instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.platformIsOccupied = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.editableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.driveableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.occupantLockState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VehicleLift instance, VehicleLift previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.platformIsOccupied);
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.editableOccupant);
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.driveableOccupant);
		if (instance.occupantLockState != previous.occupantLockState)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.occupantLockState);
		}
	}

	public static void Serialize(BufferStream stream, VehicleLift instance)
	{
		if (instance.platformIsOccupied)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.platformIsOccupied);
		}
		if (instance.editableOccupant)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.editableOccupant);
		}
		if (instance.driveableOccupant)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.driveableOccupant);
		}
		if (instance.occupantLockState != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.occupantLockState);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class EngineStorage : IDisposable, IPooled, IProto<EngineStorage>, IProto
{
	[NonSerialized]
	public bool isUsable;

	[NonSerialized]
	public float accelerationBoost;

	[NonSerialized]
	public float topSpeedBoost;

	[NonSerialized]
	public float fuelEconomyBoost;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EngineStorage instance)
	{
		if (instance.ShouldPool)
		{
			instance.isUsable = false;
			instance.accelerationBoost = 0f;
			instance.topSpeedBoost = 0f;
			instance.fuelEconomyBoost = 0f;
			Pool.Free<EngineStorage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EngineStorage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EngineStorage instance)
	{
		instance.isUsable = isUsable;
		instance.accelerationBoost = accelerationBoost;
		instance.topSpeedBoost = topSpeedBoost;
		instance.fuelEconomyBoost = fuelEconomyBoost;
	}

	public EngineStorage Copy()
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		CopyTo(engineStorage);
		return engineStorage;
	}

	public static EngineStorage Deserialize(BufferStream stream)
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		Deserialize(stream, engineStorage, isDelta: false);
		return engineStorage;
	}

	public static EngineStorage DeserializeLengthDelimited(BufferStream stream)
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		DeserializeLengthDelimited(stream, engineStorage, isDelta: false);
		return engineStorage;
	}

	public static EngineStorage DeserializeLength(BufferStream stream, int length)
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		DeserializeLength(stream, length, engineStorage, isDelta: false);
		return engineStorage;
	}

	public static EngineStorage Deserialize(byte[] buffer)
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, engineStorage, isDelta: false);
		return engineStorage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EngineStorage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EngineStorage Deserialize(BufferStream stream, EngineStorage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.isUsable = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.accelerationBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.topSpeedBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.fuelEconomyBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EngineStorage DeserializeLengthDelimited(BufferStream stream, EngineStorage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.isUsable = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.accelerationBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.topSpeedBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.fuelEconomyBoost = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EngineStorage DeserializeLength(BufferStream stream, int length, EngineStorage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.isUsable = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.accelerationBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.topSpeedBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.fuelEconomyBoost = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EngineStorage instance, EngineStorage previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.isUsable);
		if (instance.accelerationBoost != previous.accelerationBoost)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.accelerationBoost);
		}
		if (instance.topSpeedBoost != previous.topSpeedBoost)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.topSpeedBoost);
		}
		if (instance.fuelEconomyBoost != previous.fuelEconomyBoost)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.fuelEconomyBoost);
		}
	}

	public static void Serialize(BufferStream stream, EngineStorage instance)
	{
		if (instance.isUsable)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.isUsable);
		}
		if (instance.accelerationBoost != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.accelerationBoost);
		}
		if (instance.topSpeedBoost != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.topSpeedBoost);
		}
		if (instance.fuelEconomyBoost != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.fuelEconomyBoost);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class IOEntity : IDisposable, IPooled, IProto<IOEntity>, IProto
{
	public class IOConnection : IDisposable, IPooled, IProto<IOConnection>, IProto
	{
		public class LineVec : IDisposable, IPooled, IProto<LineVec>, IProto
		{
			[NonSerialized]
			public Vector4 vec;

			public bool ShouldPool = true;

			private bool _disposed;

			public static void ResetToPool(LineVec instance)
			{
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				if (instance.ShouldPool)
				{
					instance.vec = default(Vector4);
					Pool.Free<LineVec>(ref instance);
				}
			}

			public void ResetToPool()
			{
				ResetToPool(this);
			}

			public virtual void Dispose()
			{
				if (!ShouldPool)
				{
					throw new Exception("Trying to dispose LineVec with ShouldPool set to false!");
				}
				if (!_disposed)
				{
					ResetToPool();
					_disposed = true;
				}
			}

			public virtual void EnterPool()
			{
				_disposed = true;
			}

			public virtual void LeavePool()
			{
				_disposed = false;
			}

			public void CopyTo(LineVec instance)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				instance.vec = vec;
			}

			public LineVec Copy()
			{
				LineVec lineVec = Pool.Get<LineVec>();
				CopyTo(lineVec);
				return lineVec;
			}

			public static LineVec Deserialize(BufferStream stream)
			{
				LineVec lineVec = Pool.Get<LineVec>();
				Deserialize(stream, lineVec, isDelta: false);
				return lineVec;
			}

			public static LineVec DeserializeLengthDelimited(BufferStream stream)
			{
				LineVec lineVec = Pool.Get<LineVec>();
				DeserializeLengthDelimited(stream, lineVec, isDelta: false);
				return lineVec;
			}

			public static LineVec DeserializeLength(BufferStream stream, int length)
			{
				LineVec lineVec = Pool.Get<LineVec>();
				DeserializeLength(stream, length, lineVec, isDelta: false);
				return lineVec;
			}

			public static LineVec Deserialize(byte[] buffer)
			{
				LineVec lineVec = Pool.Get<LineVec>();
				using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
				Deserialize(stream, lineVec, isDelta: false);
				return lineVec;
			}

			public void FromProto(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void WriteToStream(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public virtual void WriteToStreamDelta(BufferStream stream, LineVec previous)
			{
				if (previous == null)
				{
					Serialize(stream, this);
				}
				else
				{
					SerializeDelta(stream, this, previous);
				}
			}

			public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
			{
				DeserializeLength(stream, size, this, isDelta);
			}

			public static LineVec Deserialize(BufferStream stream, LineVec instance, bool isDelta)
			{
				//IL_001d: Unknown result type (might be due to invalid IL or missing references)
				while (true)
				{
					int num = stream.ReadByte();
					switch (num)
					{
					case 10:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
						continue;
					case -1:
					case 0:
						return instance;
					}
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
			}

			public static LineVec DeserializeLengthDelimited(BufferStream stream, LineVec instance, bool isDelta)
			{
				//IL_0051: Unknown result type (might be due to invalid IL or missing references)
				long num = ProtocolParser.ReadUInt32(stream);
				num += stream.Position;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static LineVec DeserializeLength(BufferStream stream, int length, LineVec instance, bool isDelta)
			{
				//IL_0049: Unknown result type (might be due to invalid IL or missing references)
				long num = stream.Position + length;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static void SerializeDelta(BufferStream stream, LineVec instance, LineVec previous)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_002c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0032: Unknown result type (might be due to invalid IL or missing references)
				if (instance.vec != previous.vec)
				{
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.vec, previous.vec);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}

			public static void Serialize(BufferStream stream, LineVec instance)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0008: Unknown result type (might be due to invalid IL or missing references)
				//IL_000e: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				if (instance.vec != default(Vector4))
				{
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Vector4Serialized.Serialize(stream, instance.vec);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}

			public void ToProto(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public void InspectUids(UidInspector<ulong> action)
			{
			}
		}

		public class LinePointList : IDisposable, IPooled, IProto<LinePointList>, IProto
		{
			[NonSerialized]
			public Vector4 a;

			[NonSerialized]
			public Vector4 b;

			[NonSerialized]
			public Vector4 c;

			[NonSerialized]
			public Vector4 d;

			[NonSerialized]
			public Vector4 e;

			[NonSerialized]
			public Vector4 f;

			[NonSerialized]
			public Vector4 g;

			[NonSerialized]
			public Vector4 h;

			public bool ShouldPool = true;

			private bool _disposed;

			public static void ResetToPool(LinePointList instance)
			{
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0027: Unknown result type (might be due to invalid IL or missing references)
				//IL_0033: Unknown result type (might be due to invalid IL or missing references)
				//IL_003f: Unknown result type (might be due to invalid IL or missing references)
				//IL_004b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0057: Unknown result type (might be due to invalid IL or missing references)
				//IL_0063: Unknown result type (might be due to invalid IL or missing references)
				if (instance.ShouldPool)
				{
					instance.a = default(Vector4);
					instance.b = default(Vector4);
					instance.c = default(Vector4);
					instance.d = default(Vector4);
					instance.e = default(Vector4);
					instance.f = default(Vector4);
					instance.g = default(Vector4);
					instance.h = default(Vector4);
					Pool.Free<LinePointList>(ref instance);
				}
			}

			public void ResetToPool()
			{
				ResetToPool(this);
			}

			public virtual void Dispose()
			{
				if (!ShouldPool)
				{
					throw new Exception("Trying to dispose LinePointList with ShouldPool set to false!");
				}
				if (!_disposed)
				{
					ResetToPool();
					_disposed = true;
				}
			}

			public virtual void EnterPool()
			{
				_disposed = true;
			}

			public virtual void LeavePool()
			{
				_disposed = false;
			}

			public void CopyTo(LinePointList instance)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_000e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_001a: Unknown result type (might be due to invalid IL or missing references)
				//IL_001f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_002b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0032: Unknown result type (might be due to invalid IL or missing references)
				//IL_0037: Unknown result type (might be due to invalid IL or missing references)
				//IL_003e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_004a: Unknown result type (might be due to invalid IL or missing references)
				//IL_004f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0056: Unknown result type (might be due to invalid IL or missing references)
				//IL_005b: Unknown result type (might be due to invalid IL or missing references)
				instance.a = a;
				instance.b = b;
				instance.c = c;
				instance.d = d;
				instance.e = e;
				instance.f = f;
				instance.g = g;
				instance.h = h;
			}

			public LinePointList Copy()
			{
				LinePointList linePointList = Pool.Get<LinePointList>();
				CopyTo(linePointList);
				return linePointList;
			}

			public static LinePointList Deserialize(BufferStream stream)
			{
				LinePointList linePointList = Pool.Get<LinePointList>();
				Deserialize(stream, linePointList, isDelta: false);
				return linePointList;
			}

			public static LinePointList DeserializeLengthDelimited(BufferStream stream)
			{
				LinePointList linePointList = Pool.Get<LinePointList>();
				DeserializeLengthDelimited(stream, linePointList, isDelta: false);
				return linePointList;
			}

			public static LinePointList DeserializeLength(BufferStream stream, int length)
			{
				LinePointList linePointList = Pool.Get<LinePointList>();
				DeserializeLength(stream, length, linePointList, isDelta: false);
				return linePointList;
			}

			public static LinePointList Deserialize(byte[] buffer)
			{
				LinePointList linePointList = Pool.Get<LinePointList>();
				using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
				Deserialize(stream, linePointList, isDelta: false);
				return linePointList;
			}

			public void FromProto(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void WriteToStream(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public virtual void WriteToStreamDelta(BufferStream stream, LinePointList previous)
			{
				if (previous == null)
				{
					Serialize(stream, this);
				}
				else
				{
					SerializeDelta(stream, this, previous);
				}
			}

			public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
			{
				DeserializeLength(stream, size, this, isDelta);
			}

			public static LinePointList Deserialize(BufferStream stream, LinePointList instance, bool isDelta)
			{
				//IL_00db: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
				//IL_008f: Unknown result type (might be due to invalid IL or missing references)
				//IL_006c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
				//IL_007c: Unknown result type (might be due to invalid IL or missing references)
				while (true)
				{
					int num = stream.ReadByte();
					switch (num)
					{
					case 10:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
						continue;
					case 18:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
						continue;
					case 26:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
						continue;
					case 34:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
						continue;
					case 42:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
						continue;
					case 50:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
						continue;
					case 58:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
						continue;
					case 66:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
						continue;
					case -1:
					case 0:
						return instance;
					}
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
			}

			public static LinePointList DeserializeLengthDelimited(BufferStream stream, LinePointList instance, bool isDelta)
			{
				//IL_010f: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
				//IL_009d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0122: Unknown result type (might be due to invalid IL or missing references)
				//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
				long num = ProtocolParser.ReadUInt32(stream);
				num += stream.Position;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
						continue;
					case 18:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
						continue;
					case 26:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
						continue;
					case 34:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
						continue;
					case 42:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
						continue;
					case 50:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
						continue;
					case 58:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
						continue;
					case 66:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static LinePointList DeserializeLength(BufferStream stream, int length, LinePointList instance, bool isDelta)
			{
				//IL_0107: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
				//IL_0095: Unknown result type (might be due to invalid IL or missing references)
				//IL_011a: Unknown result type (might be due to invalid IL or missing references)
				//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
				//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
				long num = stream.Position + length;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
						continue;
					case 18:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
						continue;
					case 26:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
						continue;
					case 34:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
						continue;
					case 42:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
						continue;
					case 50:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
						continue;
					case 58:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
						continue;
					case 66:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static void SerializeDelta(BufferStream stream, LinePointList instance, LinePointList previous)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_0065: Unknown result type (might be due to invalid IL or missing references)
				//IL_006b: Unknown result type (might be due to invalid IL or missing references)
				//IL_002c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0032: Unknown result type (might be due to invalid IL or missing references)
				//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
				//IL_0091: Unknown result type (might be due to invalid IL or missing references)
				//IL_0097: Unknown result type (might be due to invalid IL or missing references)
				//IL_0136: Unknown result type (might be due to invalid IL or missing references)
				//IL_013c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
				//IL_0100: Unknown result type (might be due to invalid IL or missing references)
				//IL_019f: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
				//IL_0163: Unknown result type (might be due to invalid IL or missing references)
				//IL_0169: Unknown result type (might be due to invalid IL or missing references)
				//IL_0208: Unknown result type (might be due to invalid IL or missing references)
				//IL_020e: Unknown result type (might be due to invalid IL or missing references)
				//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
				//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
				//IL_0271: Unknown result type (might be due to invalid IL or missing references)
				//IL_0277: Unknown result type (might be due to invalid IL or missing references)
				//IL_0235: Unknown result type (might be due to invalid IL or missing references)
				//IL_023b: Unknown result type (might be due to invalid IL or missing references)
				//IL_02da: Unknown result type (might be due to invalid IL or missing references)
				//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
				//IL_029e: Unknown result type (might be due to invalid IL or missing references)
				//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
				//IL_0307: Unknown result type (might be due to invalid IL or missing references)
				//IL_030d: Unknown result type (might be due to invalid IL or missing references)
				if (instance.a != previous.a)
				{
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.a, previous.a);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
				if (instance.b != previous.b)
				{
					stream.WriteByte(18);
					BufferStream.RangeHandle range2 = stream.GetRange(1);
					int position2 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.b, previous.b);
					int num2 = stream.Position - position2;
					if (num2 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
					}
					Span<byte> span2 = range2.GetSpan();
					ProtocolParser.WriteUInt32((uint)num2, span2, 0);
				}
				if (instance.c != previous.c)
				{
					stream.WriteByte(26);
					BufferStream.RangeHandle range3 = stream.GetRange(1);
					int position3 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.c, previous.c);
					int num3 = stream.Position - position3;
					if (num3 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
					}
					Span<byte> span3 = range3.GetSpan();
					ProtocolParser.WriteUInt32((uint)num3, span3, 0);
				}
				if (instance.d != previous.d)
				{
					stream.WriteByte(34);
					BufferStream.RangeHandle range4 = stream.GetRange(1);
					int position4 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.d, previous.d);
					int num4 = stream.Position - position4;
					if (num4 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
					}
					Span<byte> span4 = range4.GetSpan();
					ProtocolParser.WriteUInt32((uint)num4, span4, 0);
				}
				if (instance.e != previous.e)
				{
					stream.WriteByte(42);
					BufferStream.RangeHandle range5 = stream.GetRange(1);
					int position5 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.e, previous.e);
					int num5 = stream.Position - position5;
					if (num5 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
					}
					Span<byte> span5 = range5.GetSpan();
					ProtocolParser.WriteUInt32((uint)num5, span5, 0);
				}
				if (instance.f != previous.f)
				{
					stream.WriteByte(50);
					BufferStream.RangeHandle range6 = stream.GetRange(1);
					int position6 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.f, previous.f);
					int num6 = stream.Position - position6;
					if (num6 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
					}
					Span<byte> span6 = range6.GetSpan();
					ProtocolParser.WriteUInt32((uint)num6, span6, 0);
				}
				if (instance.g != previous.g)
				{
					stream.WriteByte(58);
					BufferStream.RangeHandle range7 = stream.GetRange(1);
					int position7 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.g, previous.g);
					int num7 = stream.Position - position7;
					if (num7 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
					}
					Span<byte> span7 = range7.GetSpan();
					ProtocolParser.WriteUInt32((uint)num7, span7, 0);
				}
				if (instance.h != previous.h)
				{
					stream.WriteByte(66);
					BufferStream.RangeHandle range8 = stream.GetRange(1);
					int position8 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.h, previous.h);
					int num8 = stream.Position - position8;
					if (num8 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
					}
					Span<byte> span8 = range8.GetSpan();
					ProtocolParser.WriteUInt32((uint)num8, span8, 0);
				}
			}

			public static void Serialize(BufferStream stream, LinePointList instance)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0008: Unknown result type (might be due to invalid IL or missing references)
				//IL_000e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0069: Unknown result type (might be due to invalid IL or missing references)
				//IL_006f: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
				//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
				//IL_0092: Unknown result type (might be due to invalid IL or missing references)
				//IL_012e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0135: Unknown result type (might be due to invalid IL or missing references)
				//IL_013b: Unknown result type (might be due to invalid IL or missing references)
				//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
				//IL_0194: Unknown result type (might be due to invalid IL or missing references)
				//IL_019b: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
				//IL_015e: Unknown result type (might be due to invalid IL or missing references)
				//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
				//IL_0201: Unknown result type (might be due to invalid IL or missing references)
				//IL_0207: Unknown result type (might be due to invalid IL or missing references)
				//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
				//IL_0260: Unknown result type (might be due to invalid IL or missing references)
				//IL_0267: Unknown result type (might be due to invalid IL or missing references)
				//IL_026d: Unknown result type (might be due to invalid IL or missing references)
				//IL_022a: Unknown result type (might be due to invalid IL or missing references)
				//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
				//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
				//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
				//IL_0290: Unknown result type (might be due to invalid IL or missing references)
				//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
				if (instance.a != default(Vector4))
				{
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Vector4Serialized.Serialize(stream, instance.a);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
				if (instance.b != default(Vector4))
				{
					stream.WriteByte(18);
					BufferStream.RangeHandle range2 = stream.GetRange(1);
					int position2 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.b);
					int num2 = stream.Position - position2;
					if (num2 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
					}
					Span<byte> span2 = range2.GetSpan();
					ProtocolParser.WriteUInt32((uint)num2, span2, 0);
				}
				if (instance.c != default(Vector4))
				{
					stream.WriteByte(26);
					BufferStream.RangeHandle range3 = stream.GetRange(1);
					int position3 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.c);
					int num3 = stream.Position - position3;
					if (num3 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
					}
					Span<byte> span3 = range3.GetSpan();
					ProtocolParser.WriteUInt32((uint)num3, span3, 0);
				}
				if (instance.d != default(Vector4))
				{
					stream.WriteByte(34);
					BufferStream.RangeHandle range4 = stream.GetRange(1);
					int position4 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.d);
					int num4 = stream.Position - position4;
					if (num4 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
					}
					Span<byte> span4 = range4.GetSpan();
					ProtocolParser.WriteUInt32((uint)num4, span4, 0);
				}
				if (instance.e != default(Vector4))
				{
					stream.WriteByte(42);
					BufferStream.RangeHandle range5 = stream.GetRange(1);
					int position5 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.e);
					int num5 = stream.Position - position5;
					if (num5 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
					}
					Span<byte> span5 = range5.GetSpan();
					ProtocolParser.WriteUInt32((uint)num5, span5, 0);
				}
				if (instance.f != default(Vector4))
				{
					stream.WriteByte(50);
					BufferStream.RangeHandle range6 = stream.GetRange(1);
					int position6 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.f);
					int num6 = stream.Position - position6;
					if (num6 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
					}
					Span<byte> span6 = range6.GetSpan();
					ProtocolParser.WriteUInt32((uint)num6, span6, 0);
				}
				if (instance.g != default(Vector4))
				{
					stream.WriteByte(58);
					BufferStream.RangeHandle range7 = stream.GetRange(1);
					int position7 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.g);
					int num7 = stream.Position - position7;
					if (num7 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
					}
					Span<byte> span7 = range7.GetSpan();
					ProtocolParser.WriteUInt32((uint)num7, span7, 0);
				}
				if (instance.h != default(Vector4))
				{
					stream.WriteByte(66);
					BufferStream.RangeHandle range8 = stream.GetRange(1);
					int position8 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.h);
					int num8 = stream.Position - position8;
					if (num8 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
					}
					Span<byte> span8 = range8.GetSpan();
					ProtocolParser.WriteUInt32((uint)num8, span8, 0);
				}
			}

			public void ToProto(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public void InspectUids(UidInspector<ulong> action)
			{
			}
		}

		[NonSerialized]
		public string niceName;

		[NonSerialized]
		public int type;

		[NonSerialized]
		public NetworkableId connectedID;

		[NonSerialized]
		public int connectedToSlot;

		[NonSerialized]
		public bool inUse;

		[NonSerialized]
		public List<LineVec> linePointList;

		[NonSerialized]
		public int colour;

		[NonSerialized]
		public Vector3 worldSpaceRotation;

		[NonSerialized]
		public float lineThickness;

		[NonSerialized]
		public List<WireLineAnchorInfo> lineAnchorList;

		[NonSerialized]
		public Vector3 originPosition;

		[NonSerialized]
		public Vector3 originRotation;

		[NonSerialized]
		public List<float> slackLevels;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(IOConnection instance)
		{
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0119: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Unknown result type (might be due to invalid IL or missing references)
			if (!instance.ShouldPool)
			{
				return;
			}
			instance.niceName = string.Empty;
			instance.type = 0;
			instance.connectedID = default(NetworkableId);
			instance.connectedToSlot = 0;
			instance.inUse = false;
			if (instance.linePointList != null)
			{
				for (int i = 0; i < instance.linePointList.Count; i++)
				{
					if (instance.linePointList[i] != null)
					{
						instance.linePointList[i].ResetToPool();
						instance.linePointList[i] = null;
					}
				}
				List<LineVec> list = instance.linePointList;
				Pool.Free<LineVec>(ref list, false);
				instance.linePointList = list;
			}
			instance.colour = 0;
			instance.worldSpaceRotation = default(Vector3);
			instance.lineThickness = 0f;
			if (instance.lineAnchorList != null)
			{
				for (int j = 0; j < instance.lineAnchorList.Count; j++)
				{
					if (instance.lineAnchorList[j] != null)
					{
						instance.lineAnchorList[j].ResetToPool();
						instance.lineAnchorList[j] = null;
					}
				}
				List<WireLineAnchorInfo> list2 = instance.lineAnchorList;
				Pool.Free<WireLineAnchorInfo>(ref list2, false);
				instance.lineAnchorList = list2;
			}
			instance.originPosition = default(Vector3);
			instance.originRotation = default(Vector3);
			if (instance.slackLevels != null)
			{
				List<float> list3 = instance.slackLevels;
				Pool.FreeUnmanaged<float>(ref list3);
				instance.slackLevels = list3;
			}
			Pool.Free<IOConnection>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose IOConnection with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(IOConnection instance)
		{
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0102: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			instance.niceName = niceName;
			instance.type = type;
			instance.connectedID = connectedID;
			instance.connectedToSlot = connectedToSlot;
			instance.inUse = inUse;
			if (linePointList != null)
			{
				instance.linePointList = Pool.Get<List<LineVec>>();
				for (int i = 0; i < linePointList.Count; i++)
				{
					LineVec item = linePointList[i].Copy();
					instance.linePointList.Add(item);
				}
			}
			else
			{
				instance.linePointList = null;
			}
			instance.colour = colour;
			instance.worldSpaceRotation = worldSpaceRotation;
			instance.lineThickness = lineThickness;
			if (lineAnchorList != null)
			{
				instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
				for (int j = 0; j < lineAnchorList.Count; j++)
				{
					WireLineAnchorInfo item2 = lineAnchorList[j].Copy();
					instance.lineAnchorList.Add(item2);
				}
			}
			else
			{
				instance.lineAnchorList = null;
			}
			instance.originPosition = originPosition;
			instance.originRotation = originRotation;
			if (slackLevels != null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
				for (int k = 0; k < slackLevels.Count; k++)
				{
					float item3 = slackLevels[k];
					instance.slackLevels.Add(item3);
				}
			}
			else
			{
				instance.slackLevels = null;
			}
		}

		public IOConnection Copy()
		{
			IOConnection iOConnection = Pool.Get<IOConnection>();
			CopyTo(iOConnection);
			return iOConnection;
		}

		public static IOConnection Deserialize(BufferStream stream)
		{
			IOConnection iOConnection = Pool.Get<IOConnection>();
			Deserialize(stream, iOConnection, isDelta: false);
			return iOConnection;
		}

		public static IOConnection DeserializeLengthDelimited(BufferStream stream)
		{
			IOConnection iOConnection = Pool.Get<IOConnection>();
			DeserializeLengthDelimited(stream, iOConnection, isDelta: false);
			return iOConnection;
		}

		public static IOConnection DeserializeLength(BufferStream stream, int length)
		{
			IOConnection iOConnection = Pool.Get<IOConnection>();
			DeserializeLength(stream, length, iOConnection, isDelta: false);
			return iOConnection;
		}

		public static IOConnection Deserialize(byte[] buffer)
		{
			IOConnection iOConnection = Pool.Get<IOConnection>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, iOConnection, isDelta: false);
			return iOConnection;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, IOConnection previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static IOConnection Deserialize(BufferStream stream, IOConnection instance, bool isDelta)
		{
			//IL_01be: Unknown result type (might be due to invalid IL or missing references)
			//IL_0171: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				if (instance.linePointList == null)
				{
					instance.linePointList = Pool.Get<List<LineVec>>();
				}
				if (instance.lineAnchorList == null)
				{
					instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
				}
				if (instance.slackLevels == null)
				{
					instance.slackLevels = Pool.Get<List<float>>();
				}
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.niceName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.connectedID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 32:
					instance.connectedToSlot = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.inUse = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					instance.linePointList.Add(LineVec.DeserializeLengthDelimited(stream));
					continue;
				case 56:
					instance.colour = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldSpaceRotation, isDelta);
					continue;
				case 77:
					instance.lineThickness = ProtocolParser.ReadSingle(stream);
					continue;
				case 82:
					instance.lineAnchorList.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
					continue;
				case 90:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originPosition, isDelta);
					continue;
				case 98:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originRotation, isDelta);
					continue;
				case 109:
					instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static IOConnection DeserializeLengthDelimited(BufferStream stream, IOConnection instance, bool isDelta)
		{
			//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				if (instance.linePointList == null)
				{
					instance.linePointList = Pool.Get<List<LineVec>>();
				}
				if (instance.lineAnchorList == null)
				{
					instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
				}
				if (instance.slackLevels == null)
				{
					instance.slackLevels = Pool.Get<List<float>>();
				}
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.niceName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.connectedID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 32:
					instance.connectedToSlot = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.inUse = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					instance.linePointList.Add(LineVec.DeserializeLengthDelimited(stream));
					continue;
				case 56:
					instance.colour = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldSpaceRotation, isDelta);
					continue;
				case 77:
					instance.lineThickness = ProtocolParser.ReadSingle(stream);
					continue;
				case 82:
					instance.lineAnchorList.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
					continue;
				case 90:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originPosition, isDelta);
					continue;
				case 98:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originRotation, isDelta);
					continue;
				case 109:
					instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static IOConnection DeserializeLength(BufferStream stream, int length, IOConnection instance, bool isDelta)
		{
			//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_019a: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				if (instance.linePointList == null)
				{
					instance.linePointList = Pool.Get<List<LineVec>>();
				}
				if (instance.lineAnchorList == null)
				{
					instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
				}
				if (instance.slackLevels == null)
				{
					instance.slackLevels = Pool.Get<List<float>>();
				}
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.niceName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.connectedID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 32:
					instance.connectedToSlot = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.inUse = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					instance.linePointList.Add(LineVec.DeserializeLengthDelimited(stream));
					continue;
				case 56:
					instance.colour = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldSpaceRotation, isDelta);
					continue;
				case 77:
					instance.lineThickness = ProtocolParser.ReadSingle(stream);
					continue;
				case 82:
					instance.lineAnchorList.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
					continue;
				case 90:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originPosition, isDelta);
					continue;
				case 98:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originRotation, isDelta);
					continue;
				case 109:
					instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, IOConnection instance, IOConnection previous)
		{
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0140: Unknown result type (might be due to invalid IL or missing references)
			//IL_0167: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_027d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0283: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0313: Unknown result type (might be due to invalid IL or missing references)
			//IL_0319: Unknown result type (might be due to invalid IL or missing references)
			if (instance.niceName != null && instance.niceName != previous.niceName)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.niceName);
			}
			if (instance.type != previous.type)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.connectedID.Value);
			if (instance.connectedToSlot != previous.connectedToSlot)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.connectedToSlot);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.inUse);
			if (instance.linePointList != null)
			{
				for (int i = 0; i < instance.linePointList.Count; i++)
				{
					LineVec lineVec = instance.linePointList[i];
					stream.WriteByte(50);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					LineVec.SerializeDelta(stream, lineVec, lineVec);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePointList (ProtoBuf.IOEntity.IOConnection.LineVec)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.colour != previous.colour)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.colour);
			}
			if (instance.worldSpaceRotation != previous.worldSpaceRotation)
			{
				stream.WriteByte(66);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.worldSpaceRotation, previous.worldSpaceRotation);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldSpaceRotation (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.lineThickness != previous.lineThickness)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.lineThickness);
			}
			if (instance.lineAnchorList != null)
			{
				for (int j = 0; j < instance.lineAnchorList.Count; j++)
				{
					WireLineAnchorInfo wireLineAnchorInfo = instance.lineAnchorList[j];
					stream.WriteByte(82);
					BufferStream.RangeHandle range3 = stream.GetRange(5);
					int position3 = stream.Position;
					WireLineAnchorInfo.SerializeDelta(stream, wireLineAnchorInfo, wireLineAnchorInfo);
					int val = stream.Position - position3;
					Span<byte> span3 = range3.GetSpan();
					int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
					if (num3 < 5)
					{
						span3[num3 - 1] |= 128;
						while (num3 < 4)
						{
							span3[num3++] = 128;
						}
						span3[4] = 0;
					}
				}
			}
			if (instance.originPosition != previous.originPosition)
			{
				stream.WriteByte(90);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.originPosition, previous.originPosition);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPosition (UnityEngine.Vector3)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
			if (instance.originRotation != previous.originRotation)
			{
				stream.WriteByte(98);
				BufferStream.RangeHandle range5 = stream.GetRange(1);
				int position5 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.originRotation, previous.originRotation);
				int num5 = stream.Position - position5;
				if (num5 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originRotation (UnityEngine.Vector3)");
				}
				Span<byte> span5 = range5.GetSpan();
				ProtocolParser.WriteUInt32((uint)num5, span5, 0);
			}
			if (instance.slackLevels != null)
			{
				for (int k = 0; k < instance.slackLevels.Count; k++)
				{
					float f = instance.slackLevels[k];
					stream.WriteByte(109);
					ProtocolParser.WriteSingle(stream, f);
				}
			}
		}

		public static void Serialize(BufferStream stream, IOConnection instance)
		{
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_0272: Unknown result type (might be due to invalid IL or missing references)
			//IL_0279: Unknown result type (might be due to invalid IL or missing references)
			//IL_027f: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_030a: Unknown result type (might be due to invalid IL or missing references)
			if (instance.niceName != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.niceName);
			}
			if (instance.type != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.connectedID != default(NetworkableId))
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.connectedID.Value);
			}
			if (instance.connectedToSlot != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.connectedToSlot);
			}
			if (instance.inUse)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.inUse);
			}
			if (instance.linePointList != null)
			{
				for (int i = 0; i < instance.linePointList.Count; i++)
				{
					LineVec instance2 = instance.linePointList[i];
					stream.WriteByte(50);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					LineVec.Serialize(stream, instance2);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePointList (ProtoBuf.IOEntity.IOConnection.LineVec)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.colour != 0)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.colour);
			}
			if (instance.worldSpaceRotation != default(Vector3))
			{
				stream.WriteByte(66);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.worldSpaceRotation);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldSpaceRotation (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.lineThickness != 0f)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.lineThickness);
			}
			if (instance.lineAnchorList != null)
			{
				for (int j = 0; j < instance.lineAnchorList.Count; j++)
				{
					WireLineAnchorInfo instance3 = instance.lineAnchorList[j];
					stream.WriteByte(82);
					BufferStream.RangeHandle range3 = stream.GetRange(5);
					int position3 = stream.Position;
					WireLineAnchorInfo.Serialize(stream, instance3);
					int val = stream.Position - position3;
					Span<byte> span3 = range3.GetSpan();
					int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
					if (num3 < 5)
					{
						span3[num3 - 1] |= 128;
						while (num3 < 4)
						{
							span3[num3++] = 128;
						}
						span3[4] = 0;
					}
				}
			}
			if (instance.originPosition != default(Vector3))
			{
				stream.WriteByte(90);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.originPosition);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPosition (UnityEngine.Vector3)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
			if (instance.originRotation != default(Vector3))
			{
				stream.WriteByte(98);
				BufferStream.RangeHandle range5 = stream.GetRange(1);
				int position5 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.originRotation);
				int num5 = stream.Position - position5;
				if (num5 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originRotation (UnityEngine.Vector3)");
				}
				Span<byte> span5 = range5.GetSpan();
				ProtocolParser.WriteUInt32((uint)num5, span5, 0);
			}
			if (instance.slackLevels != null)
			{
				for (int k = 0; k < instance.slackLevels.Count; k++)
				{
					float f = instance.slackLevels[k];
					stream.WriteByte(109);
					ProtocolParser.WriteSingle(stream, f);
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref connectedID.Value);
			if (linePointList != null)
			{
				for (int i = 0; i < linePointList.Count; i++)
				{
					linePointList[i]?.InspectUids(action);
				}
			}
			if (lineAnchorList != null)
			{
				for (int j = 0; j < lineAnchorList.Count; j++)
				{
					lineAnchorList[j]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public List<IOConnection> inputs;

	[NonSerialized]
	public List<IOConnection> outputs;

	[NonSerialized]
	public NetworkableId genericEntRef1;

	[NonSerialized]
	public NetworkableId genericEntRef2;

	[NonSerialized]
	public NetworkableId genericEntRef3;

	[NonSerialized]
	public int genericInt1;

	[NonSerialized]
	public int genericInt2;

	[NonSerialized]
	public float genericFloat1;

	[NonSerialized]
	public float genericFloat2;

	[NonSerialized]
	public int genericInt3;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(IOEntity instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.inputs != null)
		{
			for (int i = 0; i < instance.inputs.Count; i++)
			{
				if (instance.inputs[i] != null)
				{
					instance.inputs[i].ResetToPool();
					instance.inputs[i] = null;
				}
			}
			List<IOConnection> list = instance.inputs;
			Pool.Free<IOConnection>(ref list, false);
			instance.inputs = list;
		}
		if (instance.outputs != null)
		{
			for (int j = 0; j < instance.outputs.Count; j++)
			{
				if (instance.outputs[j] != null)
				{
					instance.outputs[j].ResetToPool();
					instance.outputs[j] = null;
				}
			}
			List<IOConnection> list2 = instance.outputs;
			Pool.Free<IOConnection>(ref list2, false);
			instance.outputs = list2;
		}
		instance.genericEntRef1 = default(NetworkableId);
		instance.genericEntRef2 = default(NetworkableId);
		instance.genericEntRef3 = default(NetworkableId);
		instance.genericInt1 = 0;
		instance.genericInt2 = 0;
		instance.genericFloat1 = 0f;
		instance.genericFloat2 = 0f;
		instance.genericInt3 = 0;
		Pool.Free<IOEntity>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose IOEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(IOEntity instance)
	{
		if (inputs != null)
		{
			instance.inputs = Pool.Get<List<IOConnection>>();
			for (int i = 0; i < inputs.Count; i++)
			{
				IOConnection item = inputs[i].Copy();
				instance.inputs.Add(item);
			}
		}
		else
		{
			instance.inputs = null;
		}
		if (outputs != null)
		{
			instance.outputs = Pool.Get<List<IOConnection>>();
			for (int j = 0; j < outputs.Count; j++)
			{
				IOConnection item2 = outputs[j].Copy();
				instance.outputs.Add(item2);
			}
		}
		else
		{
			instance.outputs = null;
		}
		instance.genericEntRef1 = genericEntRef1;
		instance.genericEntRef2 = genericEntRef2;
		instance.genericEntRef3 = genericEntRef3;
		instance.genericInt1 = genericInt1;
		instance.genericInt2 = genericInt2;
		instance.genericFloat1 = genericFloat1;
		instance.genericFloat2 = genericFloat2;
		instance.genericInt3 = genericInt3;
	}

	public IOEntity Copy()
	{
		IOEntity iOEntity = Pool.Get<IOEntity>();
		CopyTo(iOEntity);
		return iOEntity;
	}

	public static IOEntity Deserialize(BufferStream stream)
	{
		IOEntity iOEntity = Pool.Get<IOEntity>();
		Deserialize(stream, iOEntity, isDelta: false);
		return iOEntity;
	}

	public static IOEntity DeserializeLengthDelimited(BufferStream stream)
	{
		IOEntity iOEntity = Pool.Get<IOEntity>();
		DeserializeLengthDelimited(stream, iOEntity, isDelta: false);
		return iOEntity;
	}

	public static IOEntity DeserializeLength(BufferStream stream, int length)
	{
		IOEntity iOEntity = Pool.Get<IOEntity>();
		DeserializeLength(stream, length, iOEntity, isDelta: false);
		return iOEntity;
	}

	public static IOEntity Deserialize(byte[] buffer)
	{
		IOEntity iOEntity = Pool.Get<IOEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, iOEntity, isDelta: false);
		return iOEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, IOEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static IOEntity Deserialize(BufferStream stream, IOEntity instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.inputs == null)
			{
				instance.inputs = Pool.Get<List<IOConnection>>();
			}
			if (instance.outputs == null)
			{
				instance.outputs = Pool.Get<List<IOConnection>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.inputs.Add(IOConnection.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.outputs.Add(IOConnection.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.genericEntRef1 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.genericEntRef2 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.genericEntRef3 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 69:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static IOEntity DeserializeLengthDelimited(BufferStream stream, IOEntity instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.inputs == null)
			{
				instance.inputs = Pool.Get<List<IOConnection>>();
			}
			if (instance.outputs == null)
			{
				instance.outputs = Pool.Get<List<IOConnection>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.inputs.Add(IOConnection.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.outputs.Add(IOConnection.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.genericEntRef1 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.genericEntRef2 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.genericEntRef3 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 69:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static IOEntity DeserializeLength(BufferStream stream, int length, IOEntity instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.inputs == null)
			{
				instance.inputs = Pool.Get<List<IOConnection>>();
			}
			if (instance.outputs == null)
			{
				instance.outputs = Pool.Get<List<IOConnection>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.inputs.Add(IOConnection.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.outputs.Add(IOConnection.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.genericEntRef1 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.genericEntRef2 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.genericEntRef3 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 69:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, IOEntity instance, IOEntity previous)
	{
		if (instance.inputs != null)
		{
			for (int i = 0; i < instance.inputs.Count; i++)
			{
				IOConnection iOConnection = instance.inputs[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				IOConnection.SerializeDelta(stream, iOConnection, iOConnection);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.outputs != null)
		{
			for (int j = 0; j < instance.outputs.Count; j++)
			{
				IOConnection iOConnection2 = instance.outputs[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				IOConnection.SerializeDelta(stream, iOConnection2, iOConnection2);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.genericEntRef1.Value);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.genericEntRef2.Value);
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.genericEntRef3.Value);
		if (instance.genericInt1 != previous.genericInt1)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt1);
		}
		if (instance.genericInt2 != previous.genericInt2)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt2);
		}
		if (instance.genericFloat1 != previous.genericFloat1)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.genericFloat1);
		}
		if (instance.genericFloat2 != previous.genericFloat2)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.genericFloat2);
		}
		if (instance.genericInt3 != previous.genericInt3)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt3);
		}
	}

	public static void Serialize(BufferStream stream, IOEntity instance)
	{
		if (instance.inputs != null)
		{
			for (int i = 0; i < instance.inputs.Count; i++)
			{
				IOConnection instance2 = instance.inputs[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				IOConnection.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.outputs != null)
		{
			for (int j = 0; j < instance.outputs.Count; j++)
			{
				IOConnection instance3 = instance.outputs[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				IOConnection.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.genericEntRef1 != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.genericEntRef1.Value);
		}
		if (instance.genericEntRef2 != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.genericEntRef2.Value);
		}
		if (instance.genericEntRef3 != default(NetworkableId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.genericEntRef3.Value);
		}
		if (instance.genericInt1 != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt1);
		}
		if (instance.genericInt2 != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt2);
		}
		if (instance.genericFloat1 != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.genericFloat1);
		}
		if (instance.genericFloat2 != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.genericFloat2);
		}
		if (instance.genericInt3 != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt3);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (inputs != null)
		{
			for (int i = 0; i < inputs.Count; i++)
			{
				inputs[i]?.InspectUids(action);
			}
		}
		if (outputs != null)
		{
			for (int j = 0; j < outputs.Count; j++)
			{
				outputs[j]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref genericEntRef1.Value);
		action(UidType.NetworkableId, ref genericEntRef2.Value);
		action(UidType.NetworkableId, ref genericEntRef3.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PuzzleReset : IDisposable, IPooled, IProto<PuzzleReset>, IProto
{
	[NonSerialized]
	public bool playerBlocksReset;

	[NonSerialized]
	public float playerDetectionRadius;

	[NonSerialized]
	public Vector3 playerDetectionOrigin;

	[NonSerialized]
	public float timeBetweenResets;

	[NonSerialized]
	public bool scaleWithServerPopulation;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PuzzleReset instance)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.playerBlocksReset = false;
			instance.playerDetectionRadius = 0f;
			instance.playerDetectionOrigin = default(Vector3);
			instance.timeBetweenResets = 0f;
			instance.scaleWithServerPopulation = false;
			Pool.Free<PuzzleReset>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PuzzleReset with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PuzzleReset instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.playerBlocksReset = playerBlocksReset;
		instance.playerDetectionRadius = playerDetectionRadius;
		instance.playerDetectionOrigin = playerDetectionOrigin;
		instance.timeBetweenResets = timeBetweenResets;
		instance.scaleWithServerPopulation = scaleWithServerPopulation;
	}

	public PuzzleReset Copy()
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		CopyTo(puzzleReset);
		return puzzleReset;
	}

	public static PuzzleReset Deserialize(BufferStream stream)
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		Deserialize(stream, puzzleReset, isDelta: false);
		return puzzleReset;
	}

	public static PuzzleReset DeserializeLengthDelimited(BufferStream stream)
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		DeserializeLengthDelimited(stream, puzzleReset, isDelta: false);
		return puzzleReset;
	}

	public static PuzzleReset DeserializeLength(BufferStream stream, int length)
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		DeserializeLength(stream, length, puzzleReset, isDelta: false);
		return puzzleReset;
	}

	public static PuzzleReset Deserialize(byte[] buffer)
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, puzzleReset, isDelta: false);
		return puzzleReset;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PuzzleReset previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PuzzleReset Deserialize(BufferStream stream, PuzzleReset instance, bool isDelta)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.playerBlocksReset = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.playerDetectionRadius = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerDetectionOrigin, isDelta);
				continue;
			case 37:
				instance.timeBetweenResets = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.scaleWithServerPopulation = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PuzzleReset DeserializeLengthDelimited(BufferStream stream, PuzzleReset instance, bool isDelta)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerBlocksReset = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.playerDetectionRadius = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerDetectionOrigin, isDelta);
				continue;
			case 37:
				instance.timeBetweenResets = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.scaleWithServerPopulation = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PuzzleReset DeserializeLength(BufferStream stream, int length, PuzzleReset instance, bool isDelta)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerBlocksReset = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.playerDetectionRadius = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerDetectionOrigin, isDelta);
				continue;
			case 37:
				instance.timeBetweenResets = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.scaleWithServerPopulation = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PuzzleReset instance, PuzzleReset previous)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.playerBlocksReset);
		if (instance.playerDetectionRadius != previous.playerDetectionRadius)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.playerDetectionRadius);
		}
		if (instance.playerDetectionOrigin != previous.playerDetectionOrigin)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.playerDetectionOrigin, previous.playerDetectionOrigin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerDetectionOrigin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.timeBetweenResets != previous.timeBetweenResets)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.timeBetweenResets);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.scaleWithServerPopulation);
	}

	public static void Serialize(BufferStream stream, PuzzleReset instance)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.playerBlocksReset)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.playerBlocksReset);
		}
		if (instance.playerDetectionRadius != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.playerDetectionRadius);
		}
		if (instance.playerDetectionOrigin != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.playerDetectionOrigin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerDetectionOrigin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.timeBetweenResets != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.timeBetweenResets);
		}
		if (instance.scaleWithServerPopulation)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.scaleWithServerPopulation);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class RelationshipManager : IDisposable, IPooled, IProto<RelationshipManager>, IProto
{
	public class PlayerRelationshipInfo : IDisposable, IPooled, IProto<PlayerRelationshipInfo>, IProto
	{
		[NonSerialized]
		public ulong playerID;

		[NonSerialized]
		public int type;

		[NonSerialized]
		public int weight;

		[NonSerialized]
		public uint mugshotCrc;

		[NonSerialized]
		public string displayName;

		[NonSerialized]
		public string notes;

		[NonSerialized]
		public float timeSinceSeen;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerRelationshipInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.playerID = 0uL;
				instance.type = 0;
				instance.weight = 0;
				instance.mugshotCrc = 0u;
				instance.displayName = string.Empty;
				instance.notes = string.Empty;
				instance.timeSinceSeen = 0f;
				Pool.Free<PlayerRelationshipInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerRelationshipInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerRelationshipInfo instance)
		{
			instance.playerID = playerID;
			instance.type = type;
			instance.weight = weight;
			instance.mugshotCrc = mugshotCrc;
			instance.displayName = displayName;
			instance.notes = notes;
			instance.timeSinceSeen = timeSinceSeen;
		}

		public PlayerRelationshipInfo Copy()
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			CopyTo(playerRelationshipInfo);
			return playerRelationshipInfo;
		}

		public static PlayerRelationshipInfo Deserialize(BufferStream stream)
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			Deserialize(stream, playerRelationshipInfo, isDelta: false);
			return playerRelationshipInfo;
		}

		public static PlayerRelationshipInfo DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			DeserializeLengthDelimited(stream, playerRelationshipInfo, isDelta: false);
			return playerRelationshipInfo;
		}

		public static PlayerRelationshipInfo DeserializeLength(BufferStream stream, int length)
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			DeserializeLength(stream, length, playerRelationshipInfo, isDelta: false);
			return playerRelationshipInfo;
		}

		public static PlayerRelationshipInfo Deserialize(byte[] buffer)
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerRelationshipInfo, isDelta: false);
			return playerRelationshipInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerRelationshipInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerRelationshipInfo Deserialize(BufferStream stream, PlayerRelationshipInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.weight = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 42:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 61:
					instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerRelationshipInfo DeserializeLengthDelimited(BufferStream stream, PlayerRelationshipInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.weight = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 42:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 61:
					instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerRelationshipInfo DeserializeLength(BufferStream stream, int length, PlayerRelationshipInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.weight = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 42:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 61:
					instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerRelationshipInfo instance, PlayerRelationshipInfo previous)
		{
			if (instance.playerID != previous.playerID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.type != previous.type)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.weight != previous.weight)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.weight);
			}
			if (instance.mugshotCrc != previous.mugshotCrc)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, instance.mugshotCrc);
			}
			if (instance.displayName != null && instance.displayName != previous.displayName)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.notes != null && instance.notes != previous.notes)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.notes);
			}
			if (instance.timeSinceSeen != previous.timeSinceSeen)
			{
				stream.WriteByte(61);
				ProtocolParser.WriteSingle(stream, instance.timeSinceSeen);
			}
		}

		public static void Serialize(BufferStream stream, PlayerRelationshipInfo instance)
		{
			if (instance.playerID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.type != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.weight != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.weight);
			}
			if (instance.mugshotCrc != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, instance.mugshotCrc);
			}
			if (instance.displayName != null)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.notes != null)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.notes);
			}
			if (instance.timeSinceSeen != 0f)
			{
				stream.WriteByte(61);
				ProtocolParser.WriteSingle(stream, instance.timeSinceSeen);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class PlayerRelationships : IDisposable, IPooled, IProto<PlayerRelationships>, IProto
	{
		[NonSerialized]
		public ulong playerID;

		[NonSerialized]
		public List<PlayerRelationshipInfo> relations;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerRelationships instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			instance.playerID = 0uL;
			if (instance.relations != null)
			{
				for (int i = 0; i < instance.relations.Count; i++)
				{
					if (instance.relations[i] != null)
					{
						instance.relations[i].ResetToPool();
						instance.relations[i] = null;
					}
				}
				List<PlayerRelationshipInfo> list = instance.relations;
				Pool.Free<PlayerRelationshipInfo>(ref list, false);
				instance.relations = list;
			}
			Pool.Free<PlayerRelationships>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerRelationships with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerRelationships instance)
		{
			instance.playerID = playerID;
			if (relations != null)
			{
				instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
				for (int i = 0; i < relations.Count; i++)
				{
					PlayerRelationshipInfo item = relations[i].Copy();
					instance.relations.Add(item);
				}
			}
			else
			{
				instance.relations = null;
			}
		}

		public PlayerRelationships Copy()
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			CopyTo(playerRelationships);
			return playerRelationships;
		}

		public static PlayerRelationships Deserialize(BufferStream stream)
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			Deserialize(stream, playerRelationships, isDelta: false);
			return playerRelationships;
		}

		public static PlayerRelationships DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			DeserializeLengthDelimited(stream, playerRelationships, isDelta: false);
			return playerRelationships;
		}

		public static PlayerRelationships DeserializeLength(BufferStream stream, int length)
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			DeserializeLength(stream, length, playerRelationships, isDelta: false);
			return playerRelationships;
		}

		public static PlayerRelationships Deserialize(byte[] buffer)
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerRelationships, isDelta: false);
			return playerRelationships;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerRelationships previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerRelationships Deserialize(BufferStream stream, PlayerRelationships instance, bool isDelta)
		{
			if (!isDelta && instance.relations == null)
			{
				instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerRelationships DeserializeLengthDelimited(BufferStream stream, PlayerRelationships instance, bool isDelta)
		{
			if (!isDelta && instance.relations == null)
			{
				instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerRelationships DeserializeLength(BufferStream stream, int length, PlayerRelationships instance, bool isDelta)
		{
			if (!isDelta && instance.relations == null)
			{
				instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerRelationships instance, PlayerRelationships previous)
		{
			if (instance.playerID != previous.playerID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.relations == null)
			{
				return;
			}
			for (int i = 0; i < instance.relations.Count; i++)
			{
				PlayerRelationshipInfo playerRelationshipInfo = instance.relations[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerRelationshipInfo.SerializeDelta(stream, playerRelationshipInfo, playerRelationshipInfo);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public static void Serialize(BufferStream stream, PlayerRelationships instance)
		{
			if (instance.playerID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.relations == null)
			{
				return;
			}
			for (int i = 0; i < instance.relations.Count; i++)
			{
				PlayerRelationshipInfo instance2 = instance.relations[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerRelationshipInfo.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (relations != null)
			{
				for (int i = 0; i < relations.Count; i++)
				{
					relations[i]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public ulong lastTeamIndex;

	[NonSerialized]
	public List<PlayerTeam> teamList;

	[NonSerialized]
	public int maxTeamSize;

	[NonSerialized]
	public List<PlayerRelationships> relationships;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RelationshipManager instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.lastTeamIndex = 0uL;
		if (instance.teamList != null)
		{
			for (int i = 0; i < instance.teamList.Count; i++)
			{
				if (instance.teamList[i] != null)
				{
					instance.teamList[i].ResetToPool();
					instance.teamList[i] = null;
				}
			}
			List<PlayerTeam> list = instance.teamList;
			Pool.Free<PlayerTeam>(ref list, false);
			instance.teamList = list;
		}
		instance.maxTeamSize = 0;
		if (instance.relationships != null)
		{
			for (int j = 0; j < instance.relationships.Count; j++)
			{
				if (instance.relationships[j] != null)
				{
					instance.relationships[j].ResetToPool();
					instance.relationships[j] = null;
				}
			}
			List<PlayerRelationships> list2 = instance.relationships;
			Pool.Free<PlayerRelationships>(ref list2, false);
			instance.relationships = list2;
		}
		Pool.Free<RelationshipManager>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RelationshipManager with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RelationshipManager instance)
	{
		instance.lastTeamIndex = lastTeamIndex;
		if (teamList != null)
		{
			instance.teamList = Pool.Get<List<PlayerTeam>>();
			for (int i = 0; i < teamList.Count; i++)
			{
				PlayerTeam item = teamList[i].Copy();
				instance.teamList.Add(item);
			}
		}
		else
		{
			instance.teamList = null;
		}
		instance.maxTeamSize = maxTeamSize;
		if (relationships != null)
		{
			instance.relationships = Pool.Get<List<PlayerRelationships>>();
			for (int j = 0; j < relationships.Count; j++)
			{
				PlayerRelationships item2 = relationships[j].Copy();
				instance.relationships.Add(item2);
			}
		}
		else
		{
			instance.relationships = null;
		}
	}

	public RelationshipManager Copy()
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		CopyTo(relationshipManager);
		return relationshipManager;
	}

	public static RelationshipManager Deserialize(BufferStream stream)
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		Deserialize(stream, relationshipManager, isDelta: false);
		return relationshipManager;
	}

	public static RelationshipManager DeserializeLengthDelimited(BufferStream stream)
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		DeserializeLengthDelimited(stream, relationshipManager, isDelta: false);
		return relationshipManager;
	}

	public static RelationshipManager DeserializeLength(BufferStream stream, int length)
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		DeserializeLength(stream, length, relationshipManager, isDelta: false);
		return relationshipManager;
	}

	public static RelationshipManager Deserialize(byte[] buffer)
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, relationshipManager, isDelta: false);
		return relationshipManager;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RelationshipManager previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RelationshipManager Deserialize(BufferStream stream, RelationshipManager instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teamList == null)
			{
				instance.teamList = Pool.Get<List<PlayerTeam>>();
			}
			if (instance.relationships == null)
			{
				instance.relationships = Pool.Get<List<PlayerRelationships>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lastTeamIndex = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamList.Add(PlayerTeam.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.maxTeamSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.relationships.Add(PlayerRelationships.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RelationshipManager DeserializeLengthDelimited(BufferStream stream, RelationshipManager instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teamList == null)
			{
				instance.teamList = Pool.Get<List<PlayerTeam>>();
			}
			if (instance.relationships == null)
			{
				instance.relationships = Pool.Get<List<PlayerRelationships>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lastTeamIndex = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamList.Add(PlayerTeam.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.maxTeamSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.relationships.Add(PlayerRelationships.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RelationshipManager DeserializeLength(BufferStream stream, int length, RelationshipManager instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teamList == null)
			{
				instance.teamList = Pool.Get<List<PlayerTeam>>();
			}
			if (instance.relationships == null)
			{
				instance.relationships = Pool.Get<List<PlayerRelationships>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lastTeamIndex = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamList.Add(PlayerTeam.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.maxTeamSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.relationships.Add(PlayerRelationships.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RelationshipManager instance, RelationshipManager previous)
	{
		if (instance.lastTeamIndex != previous.lastTeamIndex)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lastTeamIndex);
		}
		if (instance.teamList != null)
		{
			for (int i = 0; i < instance.teamList.Count; i++)
			{
				PlayerTeam playerTeam = instance.teamList[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerTeam.SerializeDelta(stream, playerTeam, playerTeam);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.maxTeamSize != previous.maxTeamSize)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxTeamSize);
		}
		if (instance.relationships == null)
		{
			return;
		}
		for (int j = 0; j < instance.relationships.Count; j++)
		{
			PlayerRelationships playerRelationships = instance.relationships[j];
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerRelationships.SerializeDelta(stream, playerRelationships, playerRelationships);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, RelationshipManager instance)
	{
		if (instance.lastTeamIndex != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lastTeamIndex);
		}
		if (instance.teamList != null)
		{
			for (int i = 0; i < instance.teamList.Count; i++)
			{
				PlayerTeam instance2 = instance.teamList[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerTeam.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.maxTeamSize != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxTeamSize);
		}
		if (instance.relationships == null)
		{
			return;
		}
		for (int j = 0; j < instance.relationships.Count; j++)
		{
			PlayerRelationships instance3 = instance.relationships[j];
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerRelationships.Serialize(stream, instance3);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (teamList != null)
		{
			for (int i = 0; i < teamList.Count; i++)
			{
				teamList[i]?.InspectUids(action);
			}
		}
		if (relationships != null)
		{
			for (int j = 0; j < relationships.Count; j++)
			{
				relationships[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class EggHunt : IDisposable, IPooled, IProto<EggHunt>, IProto
{
	public class EggHunter : IDisposable, IPooled, IProto<EggHunter>, IProto
	{
		[NonSerialized]
		public string displayName;

		[NonSerialized]
		public int numEggs;

		[NonSerialized]
		public ulong playerID;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(EggHunter instance)
		{
			if (instance.ShouldPool)
			{
				instance.displayName = string.Empty;
				instance.numEggs = 0;
				instance.playerID = 0uL;
				Pool.Free<EggHunter>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose EggHunter with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(EggHunter instance)
		{
			instance.displayName = displayName;
			instance.numEggs = numEggs;
			instance.playerID = playerID;
		}

		public EggHunter Copy()
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			CopyTo(eggHunter);
			return eggHunter;
		}

		public static EggHunter Deserialize(BufferStream stream)
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			Deserialize(stream, eggHunter, isDelta: false);
			return eggHunter;
		}

		public static EggHunter DeserializeLengthDelimited(BufferStream stream)
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			DeserializeLengthDelimited(stream, eggHunter, isDelta: false);
			return eggHunter;
		}

		public static EggHunter DeserializeLength(BufferStream stream, int length)
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			DeserializeLength(stream, length, eggHunter, isDelta: false);
			return eggHunter;
		}

		public static EggHunter Deserialize(byte[] buffer)
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, eggHunter, isDelta: false);
			return eggHunter;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, EggHunter previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static EggHunter Deserialize(BufferStream stream, EggHunter instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static EggHunter DeserializeLengthDelimited(BufferStream stream, EggHunter instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static EggHunter DeserializeLength(BufferStream stream, int length, EggHunter instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, EggHunter instance, EggHunter previous)
		{
			if (instance.displayName != null && instance.displayName != previous.displayName)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.numEggs != previous.numEggs)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.numEggs);
			}
			if (instance.playerID != previous.playerID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
		}

		public static void Serialize(BufferStream stream, EggHunter instance)
		{
			if (instance.displayName != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.numEggs != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.numEggs);
			}
			if (instance.playerID != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<EggHunter> hunters;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EggHunt instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.hunters != null)
		{
			for (int i = 0; i < instance.hunters.Count; i++)
			{
				if (instance.hunters[i] != null)
				{
					instance.hunters[i].ResetToPool();
					instance.hunters[i] = null;
				}
			}
			List<EggHunter> list = instance.hunters;
			Pool.Free<EggHunter>(ref list, false);
			instance.hunters = list;
		}
		Pool.Free<EggHunt>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EggHunt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EggHunt instance)
	{
		if (hunters != null)
		{
			instance.hunters = Pool.Get<List<EggHunter>>();
			for (int i = 0; i < hunters.Count; i++)
			{
				EggHunter item = hunters[i].Copy();
				instance.hunters.Add(item);
			}
		}
		else
		{
			instance.hunters = null;
		}
	}

	public EggHunt Copy()
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		CopyTo(eggHunt);
		return eggHunt;
	}

	public static EggHunt Deserialize(BufferStream stream)
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		Deserialize(stream, eggHunt, isDelta: false);
		return eggHunt;
	}

	public static EggHunt DeserializeLengthDelimited(BufferStream stream)
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		DeserializeLengthDelimited(stream, eggHunt, isDelta: false);
		return eggHunt;
	}

	public static EggHunt DeserializeLength(BufferStream stream, int length)
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		DeserializeLength(stream, length, eggHunt, isDelta: false);
		return eggHunt;
	}

	public static EggHunt Deserialize(byte[] buffer)
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, eggHunt, isDelta: false);
		return eggHunt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EggHunt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EggHunt Deserialize(BufferStream stream, EggHunt instance, bool isDelta)
	{
		if (!isDelta && instance.hunters == null)
		{
			instance.hunters = Pool.Get<List<EggHunter>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.hunters.Add(EggHunter.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EggHunt DeserializeLengthDelimited(BufferStream stream, EggHunt instance, bool isDelta)
	{
		if (!isDelta && instance.hunters == null)
		{
			instance.hunters = Pool.Get<List<EggHunter>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.hunters.Add(EggHunter.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EggHunt DeserializeLength(BufferStream stream, int length, EggHunt instance, bool isDelta)
	{
		if (!isDelta && instance.hunters == null)
		{
			instance.hunters = Pool.Get<List<EggHunter>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.hunters.Add(EggHunter.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EggHunt instance, EggHunt previous)
	{
		if (instance.hunters == null)
		{
			return;
		}
		for (int i = 0; i < instance.hunters.Count; i++)
		{
			EggHunter eggHunter = instance.hunters[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			EggHunter.SerializeDelta(stream, eggHunter, eggHunter);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, EggHunt instance)
	{
		if (instance.hunters == null)
		{
			return;
		}
		for (int i = 0; i < instance.hunters.Count; i++)
		{
			EggHunter instance2 = instance.hunters[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			EggHunter.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (hunters != null)
		{
			for (int i = 0; i < hunters.Count; i++)
			{
				hunters[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ArcadeMachine : IDisposable, IPooled, IProto<ArcadeMachine>, IProto
{
	public class ScoreEntry : IDisposable, IPooled, IProto<ScoreEntry>, IProto
	{
		[NonSerialized]
		public ulong playerID;

		[NonSerialized]
		public string displayName;

		[NonSerialized]
		public int score;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ScoreEntry instance)
		{
			if (instance.ShouldPool)
			{
				instance.playerID = 0uL;
				instance.displayName = string.Empty;
				instance.score = 0;
				Pool.Free<ScoreEntry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ScoreEntry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ScoreEntry instance)
		{
			instance.playerID = playerID;
			instance.displayName = displayName;
			instance.score = score;
		}

		public ScoreEntry Copy()
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			CopyTo(scoreEntry);
			return scoreEntry;
		}

		public static ScoreEntry Deserialize(BufferStream stream)
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			Deserialize(stream, scoreEntry, isDelta: false);
			return scoreEntry;
		}

		public static ScoreEntry DeserializeLengthDelimited(BufferStream stream)
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			DeserializeLengthDelimited(stream, scoreEntry, isDelta: false);
			return scoreEntry;
		}

		public static ScoreEntry DeserializeLength(BufferStream stream, int length)
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			DeserializeLength(stream, length, scoreEntry, isDelta: false);
			return scoreEntry;
		}

		public static ScoreEntry Deserialize(byte[] buffer)
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, scoreEntry, isDelta: false);
			return scoreEntry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ScoreEntry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ScoreEntry Deserialize(BufferStream stream, ScoreEntry instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ScoreEntry DeserializeLengthDelimited(BufferStream stream, ScoreEntry instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ScoreEntry DeserializeLength(BufferStream stream, int length, ScoreEntry instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ScoreEntry instance, ScoreEntry previous)
		{
			if (instance.playerID != previous.playerID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.displayName != null && instance.displayName != previous.displayName)
			{
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.score != previous.score)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public static void Serialize(BufferStream stream, ScoreEntry instance)
		{
			if (instance.playerID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.displayName != null)
			{
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.score != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<ScoreEntry> scores;

	[NonSerialized]
	public int genericInt1;

	[NonSerialized]
	public int genericInt2;

	[NonSerialized]
	public int genericInt3;

	[NonSerialized]
	public int genericInt4;

	[NonSerialized]
	public float genericFloat1;

	[NonSerialized]
	public float genericFloat2;

	[NonSerialized]
	public float genericFloat3;

	[NonSerialized]
	public float genericFloat4;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ArcadeMachine instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				if (instance.scores[i] != null)
				{
					instance.scores[i].ResetToPool();
					instance.scores[i] = null;
				}
			}
			List<ScoreEntry> list = instance.scores;
			Pool.Free<ScoreEntry>(ref list, false);
			instance.scores = list;
		}
		instance.genericInt1 = 0;
		instance.genericInt2 = 0;
		instance.genericInt3 = 0;
		instance.genericInt4 = 0;
		instance.genericFloat1 = 0f;
		instance.genericFloat2 = 0f;
		instance.genericFloat3 = 0f;
		instance.genericFloat4 = 0f;
		Pool.Free<ArcadeMachine>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ArcadeMachine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ArcadeMachine instance)
	{
		if (scores != null)
		{
			instance.scores = Pool.Get<List<ScoreEntry>>();
			for (int i = 0; i < scores.Count; i++)
			{
				ScoreEntry item = scores[i].Copy();
				instance.scores.Add(item);
			}
		}
		else
		{
			instance.scores = null;
		}
		instance.genericInt1 = genericInt1;
		instance.genericInt2 = genericInt2;
		instance.genericInt3 = genericInt3;
		instance.genericInt4 = genericInt4;
		instance.genericFloat1 = genericFloat1;
		instance.genericFloat2 = genericFloat2;
		instance.genericFloat3 = genericFloat3;
		instance.genericFloat4 = genericFloat4;
	}

	public ArcadeMachine Copy()
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		CopyTo(arcadeMachine);
		return arcadeMachine;
	}

	public static ArcadeMachine Deserialize(BufferStream stream)
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		Deserialize(stream, arcadeMachine, isDelta: false);
		return arcadeMachine;
	}

	public static ArcadeMachine DeserializeLengthDelimited(BufferStream stream)
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		DeserializeLengthDelimited(stream, arcadeMachine, isDelta: false);
		return arcadeMachine;
	}

	public static ArcadeMachine DeserializeLength(BufferStream stream, int length)
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		DeserializeLength(stream, length, arcadeMachine, isDelta: false);
		return arcadeMachine;
	}

	public static ArcadeMachine Deserialize(byte[] buffer)
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, arcadeMachine, isDelta: false);
		return arcadeMachine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ArcadeMachine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ArcadeMachine Deserialize(BufferStream stream, ArcadeMachine instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<ScoreEntry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.scores.Add(ScoreEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.genericInt4 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.genericFloat3 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat4 = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ArcadeMachine DeserializeLengthDelimited(BufferStream stream, ArcadeMachine instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<ScoreEntry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.scores.Add(ScoreEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.genericInt4 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.genericFloat3 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat4 = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ArcadeMachine DeserializeLength(BufferStream stream, int length, ArcadeMachine instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<ScoreEntry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.scores.Add(ScoreEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.genericInt4 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.genericFloat3 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat4 = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ArcadeMachine instance, ArcadeMachine previous)
	{
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				ScoreEntry scoreEntry = instance.scores[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ScoreEntry.SerializeDelta(stream, scoreEntry, scoreEntry);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.genericInt1 != previous.genericInt1)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt1);
		}
		if (instance.genericInt2 != previous.genericInt2)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt2);
		}
		if (instance.genericInt3 != previous.genericInt3)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt3);
		}
		if (instance.genericInt4 != previous.genericInt4)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt4);
		}
		if (instance.genericFloat1 != previous.genericFloat1)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.genericFloat1);
		}
		if (instance.genericFloat2 != previous.genericFloat2)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.genericFloat2);
		}
		if (instance.genericFloat3 != previous.genericFloat3)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.genericFloat3);
		}
		if (instance.genericFloat4 != previous.genericFloat4)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.genericFloat4);
		}
	}

	public static void Serialize(BufferStream stream, ArcadeMachine instance)
	{
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				ScoreEntry instance2 = instance.scores[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ScoreEntry.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.genericInt1 != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt1);
		}
		if (instance.genericInt2 != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt2);
		}
		if (instance.genericInt3 != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt3);
		}
		if (instance.genericInt4 != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt4);
		}
		if (instance.genericFloat1 != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.genericFloat1);
		}
		if (instance.genericFloat2 != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.genericFloat2);
		}
		if (instance.genericFloat3 != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.genericFloat3);
		}
		if (instance.genericFloat4 != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.genericFloat4);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (scores != null)
		{
			for (int i = 0; i < scores.Count; i++)
			{
				scores[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Horse : IDisposable, IPooled, IProto<Horse>, IProto
{
	[NonSerialized]
	public float stamina;

	[NonSerialized]
	public float maxStamina;

	[NonSerialized]
	public int gait;

	[NonSerialized]
	public float equipmentSpeedMod;

	[NonSerialized]
	public int breedIndex;

	[NonSerialized]
	public NetworkableId towEntityId;

	[NonSerialized]
	public ItemContainer equipmentContainer;

	[NonSerialized]
	public ItemContainer storageContainer;

	[NonSerialized]
	public int numStorageSlots;

	[NonSerialized]
	public NetworkableId playerLeadingId;

	[NonSerialized]
	public HorseModifiers modifiers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Horse instance)
	{
		if (instance.ShouldPool)
		{
			instance.stamina = 0f;
			instance.maxStamina = 0f;
			instance.gait = 0;
			instance.equipmentSpeedMod = 0f;
			instance.breedIndex = 0;
			instance.towEntityId = default(NetworkableId);
			if (instance.equipmentContainer != null)
			{
				instance.equipmentContainer.ResetToPool();
				instance.equipmentContainer = null;
			}
			if (instance.storageContainer != null)
			{
				instance.storageContainer.ResetToPool();
				instance.storageContainer = null;
			}
			instance.numStorageSlots = 0;
			instance.playerLeadingId = default(NetworkableId);
			if (instance.modifiers != null)
			{
				instance.modifiers.ResetToPool();
				instance.modifiers = null;
			}
			Pool.Free<Horse>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Horse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Horse instance)
	{
		instance.stamina = stamina;
		instance.maxStamina = maxStamina;
		instance.gait = gait;
		instance.equipmentSpeedMod = equipmentSpeedMod;
		instance.breedIndex = breedIndex;
		instance.towEntityId = towEntityId;
		if (equipmentContainer != null)
		{
			if (instance.equipmentContainer == null)
			{
				instance.equipmentContainer = equipmentContainer.Copy();
			}
			else
			{
				equipmentContainer.CopyTo(instance.equipmentContainer);
			}
		}
		else
		{
			instance.equipmentContainer = null;
		}
		if (storageContainer != null)
		{
			if (instance.storageContainer == null)
			{
				instance.storageContainer = storageContainer.Copy();
			}
			else
			{
				storageContainer.CopyTo(instance.storageContainer);
			}
		}
		else
		{
			instance.storageContainer = null;
		}
		instance.numStorageSlots = numStorageSlots;
		instance.playerLeadingId = playerLeadingId;
		if (modifiers != null)
		{
			if (instance.modifiers == null)
			{
				instance.modifiers = modifiers.Copy();
			}
			else
			{
				modifiers.CopyTo(instance.modifiers);
			}
		}
		else
		{
			instance.modifiers = null;
		}
	}

	public Horse Copy()
	{
		Horse horse = Pool.Get<Horse>();
		CopyTo(horse);
		return horse;
	}

	public static Horse Deserialize(BufferStream stream)
	{
		Horse horse = Pool.Get<Horse>();
		Deserialize(stream, horse, isDelta: false);
		return horse;
	}

	public static Horse DeserializeLengthDelimited(BufferStream stream)
	{
		Horse horse = Pool.Get<Horse>();
		DeserializeLengthDelimited(stream, horse, isDelta: false);
		return horse;
	}

	public static Horse DeserializeLength(BufferStream stream, int length)
	{
		Horse horse = Pool.Get<Horse>();
		DeserializeLength(stream, length, horse, isDelta: false);
		return horse;
	}

	public static Horse Deserialize(byte[] buffer)
	{
		Horse horse = Pool.Get<Horse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, horse, isDelta: false);
		return horse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Horse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Horse Deserialize(BufferStream stream, Horse instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.stamina = ProtocolParser.ReadSingle(stream);
				break;
			case 21:
				instance.maxStamina = ProtocolParser.ReadSingle(stream);
				break;
			case 24:
				instance.gait = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 37:
				instance.equipmentSpeedMod = ProtocolParser.ReadSingle(stream);
				break;
			case 40:
				instance.breedIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.towEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 58:
				if (instance.equipmentContainer == null)
				{
					instance.equipmentContainer = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.equipmentContainer, isDelta);
				}
				break;
			case 66:
				if (instance.storageContainer == null)
				{
					instance.storageContainer = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.storageContainer, isDelta);
				}
				break;
			case 72:
				instance.numStorageSlots = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 80:
				instance.playerLeadingId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 90:
				if (instance.modifiers == null)
				{
					instance.modifiers = HorseModifiers.DeserializeLengthDelimited(stream);
				}
				else
				{
					HorseModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Horse DeserializeLengthDelimited(BufferStream stream, Horse instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.stamina = ProtocolParser.ReadSingle(stream);
				break;
			case 21:
				instance.maxStamina = ProtocolParser.ReadSingle(stream);
				break;
			case 24:
				instance.gait = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 37:
				instance.equipmentSpeedMod = ProtocolParser.ReadSingle(stream);
				break;
			case 40:
				instance.breedIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.towEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 58:
				if (instance.equipmentContainer == null)
				{
					instance.equipmentContainer = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.equipmentContainer, isDelta);
				}
				break;
			case 66:
				if (instance.storageContainer == null)
				{
					instance.storageContainer = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.storageContainer, isDelta);
				}
				break;
			case 72:
				instance.numStorageSlots = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 80:
				instance.playerLeadingId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 90:
				if (instance.modifiers == null)
				{
					instance.modifiers = HorseModifiers.DeserializeLengthDelimited(stream);
				}
				else
				{
					HorseModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Horse DeserializeLength(BufferStream stream, int length, Horse instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.stamina = ProtocolParser.ReadSingle(stream);
				break;
			case 21:
				instance.maxStamina = ProtocolParser.ReadSingle(stream);
				break;
			case 24:
				instance.gait = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 37:
				instance.equipmentSpeedMod = ProtocolParser.ReadSingle(stream);
				break;
			case 40:
				instance.breedIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.towEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 58:
				if (instance.equipmentContainer == null)
				{
					instance.equipmentContainer = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.equipmentContainer, isDelta);
				}
				break;
			case 66:
				if (instance.storageContainer == null)
				{
					instance.storageContainer = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.storageContainer, isDelta);
				}
				break;
			case 72:
				instance.numStorageSlots = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 80:
				instance.playerLeadingId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 90:
				if (instance.modifiers == null)
				{
					instance.modifiers = HorseModifiers.DeserializeLengthDelimited(stream);
				}
				else
				{
					HorseModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Horse instance, Horse previous)
	{
		if (instance.stamina != previous.stamina)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.stamina);
		}
		if (instance.maxStamina != previous.maxStamina)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.maxStamina);
		}
		if (instance.gait != previous.gait)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gait);
		}
		if (instance.equipmentSpeedMod != previous.equipmentSpeedMod)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.equipmentSpeedMod);
		}
		if (instance.breedIndex != previous.breedIndex)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.breedIndex);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, instance.towEntityId.Value);
		if (instance.equipmentContainer != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.equipmentContainer, previous.equipmentContainer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.storageContainer != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.storageContainer, previous.storageContainer);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.numStorageSlots != previous.numStorageSlots)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numStorageSlots);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteUInt64(stream, instance.playerLeadingId.Value);
		if (instance.modifiers == null)
		{
			return;
		}
		stream.WriteByte(90);
		BufferStream.RangeHandle range3 = stream.GetRange(3);
		int position3 = stream.Position;
		HorseModifiers.SerializeDelta(stream, instance.modifiers, previous.modifiers);
		int num3 = stream.Position - position3;
		if (num3 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.HorseModifiers)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		if (num4 < 3)
		{
			span3[num4 - 1] |= 128;
			while (num4 < 2)
			{
				span3[num4++] = 128;
			}
			span3[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Horse instance)
	{
		if (instance.stamina != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.stamina);
		}
		if (instance.maxStamina != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.maxStamina);
		}
		if (instance.gait != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gait);
		}
		if (instance.equipmentSpeedMod != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.equipmentSpeedMod);
		}
		if (instance.breedIndex != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.breedIndex);
		}
		if (instance.towEntityId != default(NetworkableId))
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.towEntityId.Value);
		}
		if (instance.equipmentContainer != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance.equipmentContainer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.storageContainer != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.Serialize(stream, instance.storageContainer);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.numStorageSlots != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numStorageSlots);
		}
		if (instance.playerLeadingId != default(NetworkableId))
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, instance.playerLeadingId.Value);
		}
		if (instance.modifiers == null)
		{
			return;
		}
		stream.WriteByte(90);
		BufferStream.RangeHandle range3 = stream.GetRange(3);
		int position3 = stream.Position;
		HorseModifiers.Serialize(stream, instance.modifiers);
		int num3 = stream.Position - position3;
		if (num3 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.HorseModifiers)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		if (num4 < 3)
		{
			span3[num4 - 1] |= 128;
			while (num4 < 2)
			{
				span3[num4++] = 128;
			}
			span3[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref towEntityId.Value);
		equipmentContainer?.InspectUids(action);
		storageContainer?.InspectUids(action);
		action(UidType.NetworkableId, ref playerLeadingId.Value);
		modifiers?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class HorseModifiers : IDisposable, IPooled, IProto<HorseModifiers>, IProto
{
	[NonSerialized]
	public List<Modifier> modifiers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(HorseModifiers instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.modifiers != null)
		{
			for (int i = 0; i < instance.modifiers.Count; i++)
			{
				if (instance.modifiers[i] != null)
				{
					instance.modifiers[i].ResetToPool();
					instance.modifiers[i] = null;
				}
			}
			List<Modifier> list = instance.modifiers;
			Pool.Free<Modifier>(ref list, false);
			instance.modifiers = list;
		}
		Pool.Free<HorseModifiers>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose HorseModifiers with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(HorseModifiers instance)
	{
		if (modifiers != null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
			for (int i = 0; i < modifiers.Count; i++)
			{
				Modifier item = modifiers[i].Copy();
				instance.modifiers.Add(item);
			}
		}
		else
		{
			instance.modifiers = null;
		}
	}

	public HorseModifiers Copy()
	{
		HorseModifiers horseModifiers = Pool.Get<HorseModifiers>();
		CopyTo(horseModifiers);
		return horseModifiers;
	}

	public static HorseModifiers Deserialize(BufferStream stream)
	{
		HorseModifiers horseModifiers = Pool.Get<HorseModifiers>();
		Deserialize(stream, horseModifiers, isDelta: false);
		return horseModifiers;
	}

	public static HorseModifiers DeserializeLengthDelimited(BufferStream stream)
	{
		HorseModifiers horseModifiers = Pool.Get<HorseModifiers>();
		DeserializeLengthDelimited(stream, horseModifiers, isDelta: false);
		return horseModifiers;
	}

	public static HorseModifiers DeserializeLength(BufferStream stream, int length)
	{
		HorseModifiers horseModifiers = Pool.Get<HorseModifiers>();
		DeserializeLength(stream, length, horseModifiers, isDelta: false);
		return horseModifiers;
	}

	public static HorseModifiers Deserialize(byte[] buffer)
	{
		HorseModifiers horseModifiers = Pool.Get<HorseModifiers>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, horseModifiers, isDelta: false);
		return horseModifiers;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, HorseModifiers previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static HorseModifiers Deserialize(BufferStream stream, HorseModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static HorseModifiers DeserializeLengthDelimited(BufferStream stream, HorseModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static HorseModifiers DeserializeLength(BufferStream stream, int length, HorseModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, HorseModifiers instance, HorseModifiers previous)
	{
		if (instance.modifiers == null)
		{
			return;
		}
		for (int i = 0; i < instance.modifiers.Count; i++)
		{
			Modifier modifier = instance.modifiers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Modifier.SerializeDelta(stream, modifier, modifier);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.Modifier)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, HorseModifiers instance)
	{
		if (instance.modifiers == null)
		{
			return;
		}
		for (int i = 0; i < instance.modifiers.Count; i++)
		{
			Modifier instance2 = instance.modifiers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Modifier.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.Modifier)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (modifiers != null)
		{
			for (int i = 0; i < modifiers.Count; i++)
			{
				modifiers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SmartAlarm : IDisposable, IPooled, IProto<SmartAlarm>, IProto
{
	[NonSerialized]
	public List<ulong> subscriptions;

	[NonSerialized]
	public string notificationTitle;

	[NonSerialized]
	public string notificationBody;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SmartAlarm instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.subscriptions != null)
			{
				List<ulong> list = instance.subscriptions;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.subscriptions = list;
			}
			instance.notificationTitle = string.Empty;
			instance.notificationBody = string.Empty;
			Pool.Free<SmartAlarm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SmartAlarm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SmartAlarm instance)
	{
		if (subscriptions != null)
		{
			instance.subscriptions = Pool.Get<List<ulong>>();
			for (int i = 0; i < subscriptions.Count; i++)
			{
				ulong item = subscriptions[i];
				instance.subscriptions.Add(item);
			}
		}
		else
		{
			instance.subscriptions = null;
		}
		instance.notificationTitle = notificationTitle;
		instance.notificationBody = notificationBody;
	}

	public SmartAlarm Copy()
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		CopyTo(smartAlarm);
		return smartAlarm;
	}

	public static SmartAlarm Deserialize(BufferStream stream)
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		Deserialize(stream, smartAlarm, isDelta: false);
		return smartAlarm;
	}

	public static SmartAlarm DeserializeLengthDelimited(BufferStream stream)
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		DeserializeLengthDelimited(stream, smartAlarm, isDelta: false);
		return smartAlarm;
	}

	public static SmartAlarm DeserializeLength(BufferStream stream, int length)
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		DeserializeLength(stream, length, smartAlarm, isDelta: false);
		return smartAlarm;
	}

	public static SmartAlarm Deserialize(byte[] buffer)
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, smartAlarm, isDelta: false);
		return smartAlarm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SmartAlarm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SmartAlarm Deserialize(BufferStream stream, SmartAlarm instance, bool isDelta)
	{
		if (!isDelta && instance.subscriptions == null)
		{
			instance.subscriptions = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.subscriptions.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.notificationTitle = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.notificationBody = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SmartAlarm DeserializeLengthDelimited(BufferStream stream, SmartAlarm instance, bool isDelta)
	{
		if (!isDelta && instance.subscriptions == null)
		{
			instance.subscriptions = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.subscriptions.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.notificationTitle = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.notificationBody = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SmartAlarm DeserializeLength(BufferStream stream, int length, SmartAlarm instance, bool isDelta)
	{
		if (!isDelta && instance.subscriptions == null)
		{
			instance.subscriptions = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.subscriptions.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.notificationTitle = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.notificationBody = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SmartAlarm instance, SmartAlarm previous)
	{
		if (instance.subscriptions != null)
		{
			for (int i = 0; i < instance.subscriptions.Count; i++)
			{
				ulong val = instance.subscriptions[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.notificationTitle != null && instance.notificationTitle != previous.notificationTitle)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.notificationTitle);
		}
		if (instance.notificationBody != null && instance.notificationBody != previous.notificationBody)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.notificationBody);
		}
	}

	public static void Serialize(BufferStream stream, SmartAlarm instance)
	{
		if (instance.subscriptions != null)
		{
			for (int i = 0; i < instance.subscriptions.Count; i++)
			{
				ulong val = instance.subscriptions[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.notificationTitle != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.notificationTitle);
		}
		if (instance.notificationBody != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.notificationBody);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class InstrumentRecording : IDisposable, IPooled, IProto<InstrumentRecording>, IProto
{
	[NonSerialized]
	public List<InstrumentRecordingNote> notes;

	[NonSerialized]
	public int forInstrument;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InstrumentRecording instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.notes != null)
		{
			for (int i = 0; i < instance.notes.Count; i++)
			{
				if (instance.notes[i] != null)
				{
					instance.notes[i].ResetToPool();
					instance.notes[i] = null;
				}
			}
			List<InstrumentRecordingNote> list = instance.notes;
			Pool.Free<InstrumentRecordingNote>(ref list, false);
			instance.notes = list;
		}
		instance.forInstrument = 0;
		Pool.Free<InstrumentRecording>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InstrumentRecording with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InstrumentRecording instance)
	{
		if (notes != null)
		{
			instance.notes = Pool.Get<List<InstrumentRecordingNote>>();
			for (int i = 0; i < notes.Count; i++)
			{
				InstrumentRecordingNote item = notes[i].Copy();
				instance.notes.Add(item);
			}
		}
		else
		{
			instance.notes = null;
		}
		instance.forInstrument = forInstrument;
	}

	public InstrumentRecording Copy()
	{
		InstrumentRecording instrumentRecording = Pool.Get<InstrumentRecording>();
		CopyTo(instrumentRecording);
		return instrumentRecording;
	}

	public static InstrumentRecording Deserialize(BufferStream stream)
	{
		InstrumentRecording instrumentRecording = Pool.Get<InstrumentRecording>();
		Deserialize(stream, instrumentRecording, isDelta: false);
		return instrumentRecording;
	}

	public static InstrumentRecording DeserializeLengthDelimited(BufferStream stream)
	{
		InstrumentRecording instrumentRecording = Pool.Get<InstrumentRecording>();
		DeserializeLengthDelimited(stream, instrumentRecording, isDelta: false);
		return instrumentRecording;
	}

	public static InstrumentRecording DeserializeLength(BufferStream stream, int length)
	{
		InstrumentRecording instrumentRecording = Pool.Get<InstrumentRecording>();
		DeserializeLength(stream, length, instrumentRecording, isDelta: false);
		return instrumentRecording;
	}

	public static InstrumentRecording Deserialize(byte[] buffer)
	{
		InstrumentRecording instrumentRecording = Pool.Get<InstrumentRecording>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instrumentRecording, isDelta: false);
		return instrumentRecording;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InstrumentRecording previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InstrumentRecording Deserialize(BufferStream stream, InstrumentRecording instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<InstrumentRecordingNote>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.notes.Add(InstrumentRecordingNote.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.forInstrument = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InstrumentRecording DeserializeLengthDelimited(BufferStream stream, InstrumentRecording instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<InstrumentRecordingNote>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.notes.Add(InstrumentRecordingNote.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.forInstrument = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InstrumentRecording DeserializeLength(BufferStream stream, int length, InstrumentRecording instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<InstrumentRecordingNote>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.notes.Add(InstrumentRecordingNote.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.forInstrument = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InstrumentRecording instance, InstrumentRecording previous)
	{
		if (instance.notes != null)
		{
			for (int i = 0; i < instance.notes.Count; i++)
			{
				InstrumentRecordingNote instrumentRecordingNote = instance.notes[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				InstrumentRecordingNote.SerializeDelta(stream, instrumentRecordingNote, instrumentRecordingNote);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field notes (ProtoBuf.InstrumentRecordingNote)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.forInstrument != previous.forInstrument)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.forInstrument);
		}
	}

	public static void Serialize(BufferStream stream, InstrumentRecording instance)
	{
		if (instance.notes != null)
		{
			for (int i = 0; i < instance.notes.Count; i++)
			{
				InstrumentRecordingNote instance2 = instance.notes[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				InstrumentRecordingNote.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field notes (ProtoBuf.InstrumentRecordingNote)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.forInstrument != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.forInstrument);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (notes != null)
		{
			for (int i = 0; i < notes.Count; i++)
			{
				notes[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class InstrumentRecordingNote : IDisposable, IPooled, IProto<InstrumentRecordingNote>, IProto
{
	[NonSerialized]
	public float startTime;

	[NonSerialized]
	public float duration;

	[NonSerialized]
	public int note;

	[NonSerialized]
	public int octave;

	[NonSerialized]
	public float velocity;

	[NonSerialized]
	public int noteType;

	[NonSerialized]
	public bool shouldPlay;

	[NonSerialized]
	public bool hasPlayed;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InstrumentRecordingNote instance)
	{
		if (instance.ShouldPool)
		{
			instance.startTime = 0f;
			instance.duration = 0f;
			instance.note = 0;
			instance.octave = 0;
			instance.velocity = 0f;
			instance.noteType = 0;
			instance.shouldPlay = false;
			instance.hasPlayed = false;
			Pool.Free<InstrumentRecordingNote>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InstrumentRecordingNote with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InstrumentRecordingNote instance)
	{
		instance.startTime = startTime;
		instance.duration = duration;
		instance.note = note;
		instance.octave = octave;
		instance.velocity = velocity;
		instance.noteType = noteType;
		instance.shouldPlay = shouldPlay;
		instance.hasPlayed = hasPlayed;
	}

	public InstrumentRecordingNote Copy()
	{
		InstrumentRecordingNote instrumentRecordingNote = Pool.Get<InstrumentRecordingNote>();
		CopyTo(instrumentRecordingNote);
		return instrumentRecordingNote;
	}

	public static InstrumentRecordingNote Deserialize(BufferStream stream)
	{
		InstrumentRecordingNote instrumentRecordingNote = Pool.Get<InstrumentRecordingNote>();
		Deserialize(stream, instrumentRecordingNote, isDelta: false);
		return instrumentRecordingNote;
	}

	public static InstrumentRecordingNote DeserializeLengthDelimited(BufferStream stream)
	{
		InstrumentRecordingNote instrumentRecordingNote = Pool.Get<InstrumentRecordingNote>();
		DeserializeLengthDelimited(stream, instrumentRecordingNote, isDelta: false);
		return instrumentRecordingNote;
	}

	public static InstrumentRecordingNote DeserializeLength(BufferStream stream, int length)
	{
		InstrumentRecordingNote instrumentRecordingNote = Pool.Get<InstrumentRecordingNote>();
		DeserializeLength(stream, length, instrumentRecordingNote, isDelta: false);
		return instrumentRecordingNote;
	}

	public static InstrumentRecordingNote Deserialize(byte[] buffer)
	{
		InstrumentRecordingNote instrumentRecordingNote = Pool.Get<InstrumentRecordingNote>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instrumentRecordingNote, isDelta: false);
		return instrumentRecordingNote;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InstrumentRecordingNote previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InstrumentRecordingNote Deserialize(BufferStream stream, InstrumentRecordingNote instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.startTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.note = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.octave = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 45:
				instance.velocity = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.shouldPlay = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.hasPlayed = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InstrumentRecordingNote DeserializeLengthDelimited(BufferStream stream, InstrumentRecordingNote instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.startTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.note = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.octave = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 45:
				instance.velocity = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.shouldPlay = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.hasPlayed = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InstrumentRecordingNote DeserializeLength(BufferStream stream, int length, InstrumentRecordingNote instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.startTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.note = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.octave = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 45:
				instance.velocity = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.shouldPlay = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.hasPlayed = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InstrumentRecordingNote instance, InstrumentRecordingNote previous)
	{
		if (instance.startTime != previous.startTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.startTime);
		}
		if (instance.duration != previous.duration)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
		if (instance.note != previous.note)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.note);
		}
		if (instance.octave != previous.octave)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.octave);
		}
		if (instance.velocity != previous.velocity)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.velocity);
		}
		if (instance.noteType != previous.noteType)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.shouldPlay);
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.hasPlayed);
	}

	public static void Serialize(BufferStream stream, InstrumentRecordingNote instance)
	{
		if (instance.startTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.startTime);
		}
		if (instance.duration != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
		if (instance.note != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.note);
		}
		if (instance.octave != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.octave);
		}
		if (instance.velocity != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.velocity);
		}
		if (instance.noteType != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
		if (instance.shouldPlay)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.shouldPlay);
		}
		if (instance.hasPlayed)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.hasPlayed);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class InstrumentMidiBindings : IDisposable, IPooled, IProto<InstrumentMidiBindings>, IProto
{
	[NonSerialized]
	public List<InstrumentMidiBinding> bindings;

	[NonSerialized]
	public uint forInstrument;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InstrumentMidiBindings instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.bindings != null)
		{
			for (int i = 0; i < instance.bindings.Count; i++)
			{
				if (instance.bindings[i] != null)
				{
					instance.bindings[i].ResetToPool();
					instance.bindings[i] = null;
				}
			}
			List<InstrumentMidiBinding> list = instance.bindings;
			Pool.Free<InstrumentMidiBinding>(ref list, false);
			instance.bindings = list;
		}
		instance.forInstrument = 0u;
		Pool.Free<InstrumentMidiBindings>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InstrumentMidiBindings with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InstrumentMidiBindings instance)
	{
		if (bindings != null)
		{
			instance.bindings = Pool.Get<List<InstrumentMidiBinding>>();
			for (int i = 0; i < bindings.Count; i++)
			{
				InstrumentMidiBinding item = bindings[i].Copy();
				instance.bindings.Add(item);
			}
		}
		else
		{
			instance.bindings = null;
		}
		instance.forInstrument = forInstrument;
	}

	public InstrumentMidiBindings Copy()
	{
		InstrumentMidiBindings instrumentMidiBindings = Pool.Get<InstrumentMidiBindings>();
		CopyTo(instrumentMidiBindings);
		return instrumentMidiBindings;
	}

	public static InstrumentMidiBindings Deserialize(BufferStream stream)
	{
		InstrumentMidiBindings instrumentMidiBindings = Pool.Get<InstrumentMidiBindings>();
		Deserialize(stream, instrumentMidiBindings, isDelta: false);
		return instrumentMidiBindings;
	}

	public static InstrumentMidiBindings DeserializeLengthDelimited(BufferStream stream)
	{
		InstrumentMidiBindings instrumentMidiBindings = Pool.Get<InstrumentMidiBindings>();
		DeserializeLengthDelimited(stream, instrumentMidiBindings, isDelta: false);
		return instrumentMidiBindings;
	}

	public static InstrumentMidiBindings DeserializeLength(BufferStream stream, int length)
	{
		InstrumentMidiBindings instrumentMidiBindings = Pool.Get<InstrumentMidiBindings>();
		DeserializeLength(stream, length, instrumentMidiBindings, isDelta: false);
		return instrumentMidiBindings;
	}

	public static InstrumentMidiBindings Deserialize(byte[] buffer)
	{
		InstrumentMidiBindings instrumentMidiBindings = Pool.Get<InstrumentMidiBindings>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instrumentMidiBindings, isDelta: false);
		return instrumentMidiBindings;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InstrumentMidiBindings previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InstrumentMidiBindings Deserialize(BufferStream stream, InstrumentMidiBindings instance, bool isDelta)
	{
		if (!isDelta && instance.bindings == null)
		{
			instance.bindings = Pool.Get<List<InstrumentMidiBinding>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.bindings.Add(InstrumentMidiBinding.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.forInstrument = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InstrumentMidiBindings DeserializeLengthDelimited(BufferStream stream, InstrumentMidiBindings instance, bool isDelta)
	{
		if (!isDelta && instance.bindings == null)
		{
			instance.bindings = Pool.Get<List<InstrumentMidiBinding>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.bindings.Add(InstrumentMidiBinding.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.forInstrument = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InstrumentMidiBindings DeserializeLength(BufferStream stream, int length, InstrumentMidiBindings instance, bool isDelta)
	{
		if (!isDelta && instance.bindings == null)
		{
			instance.bindings = Pool.Get<List<InstrumentMidiBinding>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.bindings.Add(InstrumentMidiBinding.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.forInstrument = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InstrumentMidiBindings instance, InstrumentMidiBindings previous)
	{
		if (instance.bindings != null)
		{
			for (int i = 0; i < instance.bindings.Count; i++)
			{
				InstrumentMidiBinding instrumentMidiBinding = instance.bindings[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				InstrumentMidiBinding.SerializeDelta(stream, instrumentMidiBinding, instrumentMidiBinding);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bindings (ProtoBuf.InstrumentMidiBinding)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.forInstrument != previous.forInstrument)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.forInstrument);
		}
	}

	public static void Serialize(BufferStream stream, InstrumentMidiBindings instance)
	{
		if (instance.bindings != null)
		{
			for (int i = 0; i < instance.bindings.Count; i++)
			{
				InstrumentMidiBinding instance2 = instance.bindings[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				InstrumentMidiBinding.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bindings (ProtoBuf.InstrumentMidiBinding)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.forInstrument != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.forInstrument);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (bindings != null)
		{
			for (int i = 0; i < bindings.Count; i++)
			{
				bindings[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class InstrumentMidiBinding : IDisposable, IPooled, IProto<InstrumentMidiBinding>, IProto
{
	[NonSerialized]
	public int noteFrom;

	[NonSerialized]
	public int note;

	[NonSerialized]
	public int noteOctave;

	[NonSerialized]
	public int noteType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InstrumentMidiBinding instance)
	{
		if (instance.ShouldPool)
		{
			instance.noteFrom = 0;
			instance.note = 0;
			instance.noteOctave = 0;
			instance.noteType = 0;
			Pool.Free<InstrumentMidiBinding>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InstrumentMidiBinding with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InstrumentMidiBinding instance)
	{
		instance.noteFrom = noteFrom;
		instance.note = note;
		instance.noteOctave = noteOctave;
		instance.noteType = noteType;
	}

	public InstrumentMidiBinding Copy()
	{
		InstrumentMidiBinding instrumentMidiBinding = Pool.Get<InstrumentMidiBinding>();
		CopyTo(instrumentMidiBinding);
		return instrumentMidiBinding;
	}

	public static InstrumentMidiBinding Deserialize(BufferStream stream)
	{
		InstrumentMidiBinding instrumentMidiBinding = Pool.Get<InstrumentMidiBinding>();
		Deserialize(stream, instrumentMidiBinding, isDelta: false);
		return instrumentMidiBinding;
	}

	public static InstrumentMidiBinding DeserializeLengthDelimited(BufferStream stream)
	{
		InstrumentMidiBinding instrumentMidiBinding = Pool.Get<InstrumentMidiBinding>();
		DeserializeLengthDelimited(stream, instrumentMidiBinding, isDelta: false);
		return instrumentMidiBinding;
	}

	public static InstrumentMidiBinding DeserializeLength(BufferStream stream, int length)
	{
		InstrumentMidiBinding instrumentMidiBinding = Pool.Get<InstrumentMidiBinding>();
		DeserializeLength(stream, length, instrumentMidiBinding, isDelta: false);
		return instrumentMidiBinding;
	}

	public static InstrumentMidiBinding Deserialize(byte[] buffer)
	{
		InstrumentMidiBinding instrumentMidiBinding = Pool.Get<InstrumentMidiBinding>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instrumentMidiBinding, isDelta: false);
		return instrumentMidiBinding;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InstrumentMidiBinding previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InstrumentMidiBinding Deserialize(BufferStream stream, InstrumentMidiBinding instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.noteFrom = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.note = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.noteOctave = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InstrumentMidiBinding DeserializeLengthDelimited(BufferStream stream, InstrumentMidiBinding instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.noteFrom = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.note = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.noteOctave = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InstrumentMidiBinding DeserializeLength(BufferStream stream, int length, InstrumentMidiBinding instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.noteFrom = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.note = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.noteOctave = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InstrumentMidiBinding instance, InstrumentMidiBinding previous)
	{
		if (instance.noteFrom != previous.noteFrom)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteFrom);
		}
		if (instance.note != previous.note)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.note);
		}
		if (instance.noteOctave != previous.noteOctave)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteOctave);
		}
		if (instance.noteType != previous.noteType)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
	}

	public static void Serialize(BufferStream stream, InstrumentMidiBinding instance)
	{
		if (instance.noteFrom != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteFrom);
		}
		if (instance.note != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.note);
		}
		if (instance.noteOctave != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteOctave);
		}
		if (instance.noteType != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LightString : IDisposable, IPooled, IProto<LightString>, IProto
{
	public class StringPoint : IDisposable, IPooled, IProto<StringPoint>, IProto
	{
		[NonSerialized]
		public Vector3 point;

		[NonSerialized]
		public Vector3 normal;

		[NonSerialized]
		public float slack;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(StringPoint instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.point = default(Vector3);
				instance.normal = default(Vector3);
				instance.slack = 0f;
				Pool.Free<StringPoint>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose StringPoint with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(StringPoint instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			instance.point = point;
			instance.normal = normal;
			instance.slack = slack;
		}

		public StringPoint Copy()
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			CopyTo(stringPoint);
			return stringPoint;
		}

		public static StringPoint Deserialize(BufferStream stream)
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			Deserialize(stream, stringPoint, isDelta: false);
			return stringPoint;
		}

		public static StringPoint DeserializeLengthDelimited(BufferStream stream)
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			DeserializeLengthDelimited(stream, stringPoint, isDelta: false);
			return stringPoint;
		}

		public static StringPoint DeserializeLength(BufferStream stream, int length)
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			DeserializeLength(stream, length, stringPoint, isDelta: false);
			return stringPoint;
		}

		public static StringPoint Deserialize(byte[] buffer)
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, stringPoint, isDelta: false);
			return stringPoint;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, StringPoint previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static StringPoint Deserialize(BufferStream stream, StringPoint instance, bool isDelta)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
					continue;
				case 29:
					instance.slack = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static StringPoint DeserializeLengthDelimited(BufferStream stream, StringPoint instance, bool isDelta)
		{
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
					continue;
				case 29:
					instance.slack = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static StringPoint DeserializeLength(BufferStream stream, int length, StringPoint instance, bool isDelta)
		{
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
					continue;
				case 29:
					instance.slack = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, StringPoint instance, StringPoint previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			if (instance.point != previous.point)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.point, previous.point);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field point (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.normal != previous.normal)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.slack != previous.slack)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.slack);
			}
		}

		public static void Serialize(BufferStream stream, StringPoint instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			if (instance.point != default(Vector3))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance.point);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field point (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.normal != default(Vector3))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.normal);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.slack != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.slack);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<StringPoint> points;

	[NonSerialized]
	public int lengthUsed;

	[NonSerialized]
	public int animationStyle;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LightString instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.points != null)
		{
			for (int i = 0; i < instance.points.Count; i++)
			{
				if (instance.points[i] != null)
				{
					instance.points[i].ResetToPool();
					instance.points[i] = null;
				}
			}
			List<StringPoint> list = instance.points;
			Pool.Free<StringPoint>(ref list, false);
			instance.points = list;
		}
		instance.lengthUsed = 0;
		instance.animationStyle = 0;
		Pool.Free<LightString>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LightString with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LightString instance)
	{
		if (points != null)
		{
			instance.points = Pool.Get<List<StringPoint>>();
			for (int i = 0; i < points.Count; i++)
			{
				StringPoint item = points[i].Copy();
				instance.points.Add(item);
			}
		}
		else
		{
			instance.points = null;
		}
		instance.lengthUsed = lengthUsed;
		instance.animationStyle = animationStyle;
	}

	public LightString Copy()
	{
		LightString lightString = Pool.Get<LightString>();
		CopyTo(lightString);
		return lightString;
	}

	public static LightString Deserialize(BufferStream stream)
	{
		LightString lightString = Pool.Get<LightString>();
		Deserialize(stream, lightString, isDelta: false);
		return lightString;
	}

	public static LightString DeserializeLengthDelimited(BufferStream stream)
	{
		LightString lightString = Pool.Get<LightString>();
		DeserializeLengthDelimited(stream, lightString, isDelta: false);
		return lightString;
	}

	public static LightString DeserializeLength(BufferStream stream, int length)
	{
		LightString lightString = Pool.Get<LightString>();
		DeserializeLength(stream, length, lightString, isDelta: false);
		return lightString;
	}

	public static LightString Deserialize(byte[] buffer)
	{
		LightString lightString = Pool.Get<LightString>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lightString, isDelta: false);
		return lightString;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LightString previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LightString Deserialize(BufferStream stream, LightString instance, bool isDelta)
	{
		if (!isDelta && instance.points == null)
		{
			instance.points = Pool.Get<List<StringPoint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.points.Add(StringPoint.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lengthUsed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.animationStyle = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LightString DeserializeLengthDelimited(BufferStream stream, LightString instance, bool isDelta)
	{
		if (!isDelta && instance.points == null)
		{
			instance.points = Pool.Get<List<StringPoint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.points.Add(StringPoint.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lengthUsed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.animationStyle = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LightString DeserializeLength(BufferStream stream, int length, LightString instance, bool isDelta)
	{
		if (!isDelta && instance.points == null)
		{
			instance.points = Pool.Get<List<StringPoint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.points.Add(StringPoint.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lengthUsed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.animationStyle = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LightString instance, LightString previous)
	{
		if (instance.points != null)
		{
			for (int i = 0; i < instance.points.Count; i++)
			{
				StringPoint stringPoint = instance.points[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				StringPoint.SerializeDelta(stream, stringPoint, stringPoint);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field points (ProtoBuf.LightString.StringPoint)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.lengthUsed != previous.lengthUsed)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lengthUsed);
		}
		if (instance.animationStyle != previous.animationStyle)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.animationStyle);
		}
	}

	public static void Serialize(BufferStream stream, LightString instance)
	{
		if (instance.points != null)
		{
			for (int i = 0; i < instance.points.Count; i++)
			{
				StringPoint instance2 = instance.points[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				StringPoint.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field points (ProtoBuf.LightString.StringPoint)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.lengthUsed != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lengthUsed);
		}
		if (instance.animationStyle != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.animationStyle);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (points != null)
		{
			for (int i = 0; i < points.Count; i++)
			{
				points[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class LightDeployer : IDisposable, IPooled, IProto<LightDeployer>, IProto
{
	[NonSerialized]
	public NetworkableId active;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LightDeployer instance)
	{
		if (instance.ShouldPool)
		{
			instance.active = default(NetworkableId);
			Pool.Free<LightDeployer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LightDeployer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LightDeployer instance)
	{
		instance.active = active;
	}

	public LightDeployer Copy()
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		CopyTo(lightDeployer);
		return lightDeployer;
	}

	public static LightDeployer Deserialize(BufferStream stream)
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		Deserialize(stream, lightDeployer, isDelta: false);
		return lightDeployer;
	}

	public static LightDeployer DeserializeLengthDelimited(BufferStream stream)
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		DeserializeLengthDelimited(stream, lightDeployer, isDelta: false);
		return lightDeployer;
	}

	public static LightDeployer DeserializeLength(BufferStream stream, int length)
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		DeserializeLength(stream, length, lightDeployer, isDelta: false);
		return lightDeployer;
	}

	public static LightDeployer Deserialize(byte[] buffer)
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lightDeployer, isDelta: false);
		return lightDeployer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LightDeployer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LightDeployer Deserialize(BufferStream stream, LightDeployer instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.active = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LightDeployer DeserializeLengthDelimited(BufferStream stream, LightDeployer instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.active = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LightDeployer DeserializeLength(BufferStream stream, int length, LightDeployer instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.active = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LightDeployer instance, LightDeployer previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.active.Value);
	}

	public static void Serialize(BufferStream stream, LightDeployer instance)
	{
		if (instance.active != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.active.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref active.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class RCEntity : IDisposable, IPooled, IProto<RCEntity>, IProto
{
	[NonSerialized]
	public Vector3 aim;

	[NonSerialized]
	public float zoom;

	[NonSerialized]
	public string identifier;

	[NonSerialized]
	public string password;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RCEntity instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.aim = default(Vector3);
			instance.zoom = 0f;
			instance.identifier = string.Empty;
			instance.password = string.Empty;
			Pool.Free<RCEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RCEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RCEntity instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.aim = aim;
		instance.zoom = zoom;
		instance.identifier = identifier;
		instance.password = password;
	}

	public RCEntity Copy()
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		CopyTo(rCEntity);
		return rCEntity;
	}

	public static RCEntity Deserialize(BufferStream stream)
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		Deserialize(stream, rCEntity, isDelta: false);
		return rCEntity;
	}

	public static RCEntity DeserializeLengthDelimited(BufferStream stream)
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		DeserializeLengthDelimited(stream, rCEntity, isDelta: false);
		return rCEntity;
	}

	public static RCEntity DeserializeLength(BufferStream stream, int length)
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		DeserializeLength(stream, length, rCEntity, isDelta: false);
		return rCEntity;
	}

	public static RCEntity Deserialize(byte[] buffer)
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, rCEntity, isDelta: false);
		return rCEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RCEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RCEntity Deserialize(BufferStream stream, RCEntity instance, bool isDelta)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aim, isDelta);
				continue;
			case 21:
				instance.zoom = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.password = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RCEntity DeserializeLengthDelimited(BufferStream stream, RCEntity instance, bool isDelta)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aim, isDelta);
				continue;
			case 21:
				instance.zoom = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.password = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RCEntity DeserializeLength(BufferStream stream, int length, RCEntity instance, bool isDelta)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aim, isDelta);
				continue;
			case 21:
				instance.zoom = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.password = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RCEntity instance, RCEntity previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aim != previous.aim)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aim, previous.aim);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aim (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.zoom != previous.zoom)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.zoom);
		}
		if (instance.identifier != null && instance.identifier != previous.identifier)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.identifier);
		}
		if (instance.password != null && instance.password != previous.password)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.password);
		}
	}

	public static void Serialize(BufferStream stream, RCEntity instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aim != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aim);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aim (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.zoom != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.zoom);
		}
		if (instance.identifier != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.identifier);
		}
		if (instance.password != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.password);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ComputerStation : IDisposable, IPooled, IProto<ComputerStation>, IProto
{
	[NonSerialized]
	public string bookmarks;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ComputerStation instance)
	{
		if (instance.ShouldPool)
		{
			instance.bookmarks = string.Empty;
			Pool.Free<ComputerStation>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ComputerStation with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ComputerStation instance)
	{
		instance.bookmarks = bookmarks;
	}

	public ComputerStation Copy()
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		CopyTo(computerStation);
		return computerStation;
	}

	public static ComputerStation Deserialize(BufferStream stream)
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		Deserialize(stream, computerStation, isDelta: false);
		return computerStation;
	}

	public static ComputerStation DeserializeLengthDelimited(BufferStream stream)
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		DeserializeLengthDelimited(stream, computerStation, isDelta: false);
		return computerStation;
	}

	public static ComputerStation DeserializeLength(BufferStream stream, int length)
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		DeserializeLength(stream, length, computerStation, isDelta: false);
		return computerStation;
	}

	public static ComputerStation Deserialize(byte[] buffer)
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, computerStation, isDelta: false);
		return computerStation;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ComputerStation previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ComputerStation Deserialize(BufferStream stream, ComputerStation instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.bookmarks = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ComputerStation DeserializeLengthDelimited(BufferStream stream, ComputerStation instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.bookmarks = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ComputerStation DeserializeLength(BufferStream stream, int length, ComputerStation instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.bookmarks = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ComputerStation instance, ComputerStation previous)
	{
		if (instance.bookmarks != null && instance.bookmarks != previous.bookmarks)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.bookmarks);
		}
	}

	public static void Serialize(BufferStream stream, ComputerStation instance)
	{
		if (instance.bookmarks != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.bookmarks);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Composter : IDisposable, IPooled, IProto<Composter>, IProto
{
	[NonSerialized]
	public float fertilizerProductionProgress;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Composter instance)
	{
		if (instance.ShouldPool)
		{
			instance.fertilizerProductionProgress = 0f;
			Pool.Free<Composter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Composter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Composter instance)
	{
		instance.fertilizerProductionProgress = fertilizerProductionProgress;
	}

	public Composter Copy()
	{
		Composter composter = Pool.Get<Composter>();
		CopyTo(composter);
		return composter;
	}

	public static Composter Deserialize(BufferStream stream)
	{
		Composter composter = Pool.Get<Composter>();
		Deserialize(stream, composter, isDelta: false);
		return composter;
	}

	public static Composter DeserializeLengthDelimited(BufferStream stream)
	{
		Composter composter = Pool.Get<Composter>();
		DeserializeLengthDelimited(stream, composter, isDelta: false);
		return composter;
	}

	public static Composter DeserializeLength(BufferStream stream, int length)
	{
		Composter composter = Pool.Get<Composter>();
		DeserializeLength(stream, length, composter, isDelta: false);
		return composter;
	}

	public static Composter Deserialize(byte[] buffer)
	{
		Composter composter = Pool.Get<Composter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, composter, isDelta: false);
		return composter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Composter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Composter Deserialize(BufferStream stream, Composter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.fertilizerProductionProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Composter DeserializeLengthDelimited(BufferStream stream, Composter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fertilizerProductionProgress = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Composter DeserializeLength(BufferStream stream, int length, Composter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fertilizerProductionProgress = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Composter instance, Composter previous)
	{
		if (instance.fertilizerProductionProgress != previous.fertilizerProductionProgress)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fertilizerProductionProgress);
		}
	}

	public static void Serialize(BufferStream stream, Composter instance)
	{
		if (instance.fertilizerProductionProgress != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fertilizerProductionProgress);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VehicleVendor : IDisposable, IPooled, IProto<VehicleVendor>, IProto
{
	public class PlayerStorage : IDisposable, IPooled, IProto<PlayerStorage>, IProto
	{
		public class PlayerStoredVehicle : IDisposable, IPooled, IProto<PlayerStoredVehicle>, IProto
		{
			[NonSerialized]
			public string shortname;

			[NonSerialized]
			public string resourcePath;

			[NonSerialized]
			public float health;

			public bool ShouldPool = true;

			private bool _disposed;

			public static void ResetToPool(PlayerStoredVehicle instance)
			{
				if (instance.ShouldPool)
				{
					instance.shortname = string.Empty;
					instance.resourcePath = string.Empty;
					instance.health = 0f;
					Pool.Free<PlayerStoredVehicle>(ref instance);
				}
			}

			public void ResetToPool()
			{
				ResetToPool(this);
			}

			public virtual void Dispose()
			{
				if (!ShouldPool)
				{
					throw new Exception("Trying to dispose PlayerStoredVehicle with ShouldPool set to false!");
				}
				if (!_disposed)
				{
					ResetToPool();
					_disposed = true;
				}
			}

			public virtual void EnterPool()
			{
				_disposed = true;
			}

			public virtual void LeavePool()
			{
				_disposed = false;
			}

			public void CopyTo(PlayerStoredVehicle instance)
			{
				instance.shortname = shortname;
				instance.resourcePath = resourcePath;
				instance.health = health;
			}

			public PlayerStoredVehicle Copy()
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				CopyTo(playerStoredVehicle);
				return playerStoredVehicle;
			}

			public static PlayerStoredVehicle Deserialize(BufferStream stream)
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				Deserialize(stream, playerStoredVehicle, isDelta: false);
				return playerStoredVehicle;
			}

			public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream)
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				DeserializeLengthDelimited(stream, playerStoredVehicle, isDelta: false);
				return playerStoredVehicle;
			}

			public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length)
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				DeserializeLength(stream, length, playerStoredVehicle, isDelta: false);
				return playerStoredVehicle;
			}

			public static PlayerStoredVehicle Deserialize(byte[] buffer)
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
				Deserialize(stream, playerStoredVehicle, isDelta: false);
				return playerStoredVehicle;
			}

			public void FromProto(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void WriteToStream(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public virtual void WriteToStreamDelta(BufferStream stream, PlayerStoredVehicle previous)
			{
				if (previous == null)
				{
					Serialize(stream, this);
				}
				else
				{
					SerializeDelta(stream, this, previous);
				}
			}

			public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
			{
				DeserializeLength(stream, size, this, isDelta);
			}

			public static PlayerStoredVehicle Deserialize(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
			{
				while (true)
				{
					int num = stream.ReadByte();
					switch (num)
					{
					case 10:
						instance.shortname = ProtocolParser.ReadString(stream);
						continue;
					case 18:
						instance.resourcePath = ProtocolParser.ReadString(stream);
						continue;
					case 29:
						instance.health = ProtocolParser.ReadSingle(stream);
						continue;
					case -1:
					case 0:
						return instance;
					}
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
			}

			public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
			{
				long num = ProtocolParser.ReadUInt32(stream);
				num += stream.Position;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						instance.shortname = ProtocolParser.ReadString(stream);
						continue;
					case 18:
						instance.resourcePath = ProtocolParser.ReadString(stream);
						continue;
					case 29:
						instance.health = ProtocolParser.ReadSingle(stream);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length, PlayerStoredVehicle instance, bool isDelta)
			{
				long num = stream.Position + length;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						instance.shortname = ProtocolParser.ReadString(stream);
						continue;
					case 18:
						instance.resourcePath = ProtocolParser.ReadString(stream);
						continue;
					case 29:
						instance.health = ProtocolParser.ReadSingle(stream);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static void SerializeDelta(BufferStream stream, PlayerStoredVehicle instance, PlayerStoredVehicle previous)
			{
				if (instance.shortname != null && instance.shortname != previous.shortname)
				{
					stream.WriteByte(10);
					ProtocolParser.WriteString(stream, instance.shortname);
				}
				if (instance.resourcePath != null && instance.resourcePath != previous.resourcePath)
				{
					stream.WriteByte(18);
					ProtocolParser.WriteString(stream, instance.resourcePath);
				}
				if (instance.health != previous.health)
				{
					stream.WriteByte(29);
					ProtocolParser.WriteSingle(stream, instance.health);
				}
			}

			public static void Serialize(BufferStream stream, PlayerStoredVehicle instance)
			{
				if (instance.shortname != null)
				{
					stream.WriteByte(10);
					ProtocolParser.WriteString(stream, instance.shortname);
				}
				if (instance.resourcePath != null)
				{
					stream.WriteByte(18);
					ProtocolParser.WriteString(stream, instance.resourcePath);
				}
				if (instance.health != 0f)
				{
					stream.WriteByte(29);
					ProtocolParser.WriteSingle(stream, instance.health);
				}
			}

			public void ToProto(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public void InspectUids(UidInspector<ulong> action)
			{
			}
		}

		[NonSerialized]
		public ulong userid;

		[NonSerialized]
		public List<PlayerStoredVehicle> storedVehicles;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerStorage instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			instance.userid = 0uL;
			if (instance.storedVehicles != null)
			{
				for (int i = 0; i < instance.storedVehicles.Count; i++)
				{
					if (instance.storedVehicles[i] != null)
					{
						instance.storedVehicles[i].ResetToPool();
						instance.storedVehicles[i] = null;
					}
				}
				List<PlayerStoredVehicle> list = instance.storedVehicles;
				Pool.Free<PlayerStoredVehicle>(ref list, false);
				instance.storedVehicles = list;
			}
			Pool.Free<PlayerStorage>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerStorage with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerStorage instance)
		{
			instance.userid = userid;
			if (storedVehicles != null)
			{
				instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
				for (int i = 0; i < storedVehicles.Count; i++)
				{
					PlayerStoredVehicle item = storedVehicles[i].Copy();
					instance.storedVehicles.Add(item);
				}
			}
			else
			{
				instance.storedVehicles = null;
			}
		}

		public PlayerStorage Copy()
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			CopyTo(playerStorage);
			return playerStorage;
		}

		public static PlayerStorage Deserialize(BufferStream stream)
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			Deserialize(stream, playerStorage, isDelta: false);
			return playerStorage;
		}

		public static PlayerStorage DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			DeserializeLengthDelimited(stream, playerStorage, isDelta: false);
			return playerStorage;
		}

		public static PlayerStorage DeserializeLength(BufferStream stream, int length)
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			DeserializeLength(stream, length, playerStorage, isDelta: false);
			return playerStorage;
		}

		public static PlayerStorage Deserialize(byte[] buffer)
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerStorage, isDelta: false);
			return playerStorage;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerStorage previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerStorage Deserialize(BufferStream stream, PlayerStorage instance, bool isDelta)
		{
			if (!isDelta && instance.storedVehicles == null)
			{
				instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerStorage DeserializeLengthDelimited(BufferStream stream, PlayerStorage instance, bool isDelta)
		{
			if (!isDelta && instance.storedVehicles == null)
			{
				instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerStorage DeserializeLength(BufferStream stream, int length, PlayerStorage instance, bool isDelta)
		{
			if (!isDelta && instance.storedVehicles == null)
			{
				instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerStorage instance, PlayerStorage previous)
		{
			if (instance.userid != previous.userid)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.storedVehicles == null)
			{
				return;
			}
			for (int i = 0; i < instance.storedVehicles.Count; i++)
			{
				PlayerStoredVehicle playerStoredVehicle = instance.storedVehicles[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerStoredVehicle.SerializeDelta(stream, playerStoredVehicle, playerStoredVehicle);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public static void Serialize(BufferStream stream, PlayerStorage instance)
		{
			if (instance.userid != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.storedVehicles == null)
			{
				return;
			}
			for (int i = 0; i < instance.storedVehicles.Count; i++)
			{
				PlayerStoredVehicle instance2 = instance.storedVehicles[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerStoredVehicle.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (storedVehicles != null)
			{
				for (int i = 0; i < storedVehicles.Count; i++)
				{
					storedVehicles[i]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public List<PlayerStorage> playerStorage;

	[NonSerialized]
	public NetworkableId spawnerRef;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VehicleVendor instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.playerStorage != null)
		{
			for (int i = 0; i < instance.playerStorage.Count; i++)
			{
				if (instance.playerStorage[i] != null)
				{
					instance.playerStorage[i].ResetToPool();
					instance.playerStorage[i] = null;
				}
			}
			List<PlayerStorage> list = instance.playerStorage;
			Pool.Free<PlayerStorage>(ref list, false);
			instance.playerStorage = list;
		}
		instance.spawnerRef = default(NetworkableId);
		Pool.Free<VehicleVendor>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VehicleVendor with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VehicleVendor instance)
	{
		if (playerStorage != null)
		{
			instance.playerStorage = Pool.Get<List<PlayerStorage>>();
			for (int i = 0; i < playerStorage.Count; i++)
			{
				PlayerStorage item = playerStorage[i].Copy();
				instance.playerStorage.Add(item);
			}
		}
		else
		{
			instance.playerStorage = null;
		}
		instance.spawnerRef = spawnerRef;
	}

	public VehicleVendor Copy()
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		CopyTo(vehicleVendor);
		return vehicleVendor;
	}

	public static VehicleVendor Deserialize(BufferStream stream)
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		Deserialize(stream, vehicleVendor, isDelta: false);
		return vehicleVendor;
	}

	public static VehicleVendor DeserializeLengthDelimited(BufferStream stream)
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		DeserializeLengthDelimited(stream, vehicleVendor, isDelta: false);
		return vehicleVendor;
	}

	public static VehicleVendor DeserializeLength(BufferStream stream, int length)
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		DeserializeLength(stream, length, vehicleVendor, isDelta: false);
		return vehicleVendor;
	}

	public static VehicleVendor Deserialize(byte[] buffer)
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vehicleVendor, isDelta: false);
		return vehicleVendor;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VehicleVendor previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VehicleVendor Deserialize(BufferStream stream, VehicleVendor instance, bool isDelta)
	{
		if (!isDelta && instance.playerStorage == null)
		{
			instance.playerStorage = Pool.Get<List<PlayerStorage>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.playerStorage.Add(PlayerStorage.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.spawnerRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VehicleVendor DeserializeLengthDelimited(BufferStream stream, VehicleVendor instance, bool isDelta)
	{
		if (!isDelta && instance.playerStorage == null)
		{
			instance.playerStorage = Pool.Get<List<PlayerStorage>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerStorage.Add(PlayerStorage.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.spawnerRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VehicleVendor DeserializeLength(BufferStream stream, int length, VehicleVendor instance, bool isDelta)
	{
		if (!isDelta && instance.playerStorage == null)
		{
			instance.playerStorage = Pool.Get<List<PlayerStorage>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerStorage.Add(PlayerStorage.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.spawnerRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VehicleVendor instance, VehicleVendor previous)
	{
		if (instance.playerStorage != null)
		{
			for (int i = 0; i < instance.playerStorage.Count; i++)
			{
				PlayerStorage playerStorage = instance.playerStorage[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerStorage.SerializeDelta(stream, playerStorage, playerStorage);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.spawnerRef.Value);
	}

	public static void Serialize(BufferStream stream, VehicleVendor instance)
	{
		if (instance.playerStorage != null)
		{
			for (int i = 0; i < instance.playerStorage.Count; i++)
			{
				PlayerStorage instance2 = instance.playerStorage[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerStorage.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.spawnerRef != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.spawnerRef.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (playerStorage != null)
		{
			for (int i = 0; i < playerStorage.Count; i++)
			{
				playerStorage[i]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref spawnerRef.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ShopKeeper : IDisposable, IPooled, IProto<ShopKeeper>, IProto
{
	[NonSerialized]
	public NetworkableId vendingRef;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ShopKeeper instance)
	{
		if (instance.ShouldPool)
		{
			instance.vendingRef = default(NetworkableId);
			Pool.Free<ShopKeeper>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ShopKeeper with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ShopKeeper instance)
	{
		instance.vendingRef = vendingRef;
	}

	public ShopKeeper Copy()
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		CopyTo(shopKeeper);
		return shopKeeper;
	}

	public static ShopKeeper Deserialize(BufferStream stream)
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		Deserialize(stream, shopKeeper, isDelta: false);
		return shopKeeper;
	}

	public static ShopKeeper DeserializeLengthDelimited(BufferStream stream)
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		DeserializeLengthDelimited(stream, shopKeeper, isDelta: false);
		return shopKeeper;
	}

	public static ShopKeeper DeserializeLength(BufferStream stream, int length)
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		DeserializeLength(stream, length, shopKeeper, isDelta: false);
		return shopKeeper;
	}

	public static ShopKeeper Deserialize(byte[] buffer)
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, shopKeeper, isDelta: false);
		return shopKeeper;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ShopKeeper previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ShopKeeper Deserialize(BufferStream stream, ShopKeeper instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.vendingRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ShopKeeper DeserializeLengthDelimited(BufferStream stream, ShopKeeper instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.vendingRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ShopKeeper DeserializeLength(BufferStream stream, int length, ShopKeeper instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.vendingRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ShopKeeper instance, ShopKeeper previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.vendingRef.Value);
	}

	public static void Serialize(BufferStream stream, ShopKeeper instance)
	{
		if (instance.vendingRef != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.vendingRef.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref vendingRef.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WaterPool : IDisposable, IPooled, IProto<WaterPool>, IProto
{
	[NonSerialized]
	public float fillAmount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WaterPool instance)
	{
		if (instance.ShouldPool)
		{
			instance.fillAmount = 0f;
			Pool.Free<WaterPool>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WaterPool with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WaterPool instance)
	{
		instance.fillAmount = fillAmount;
	}

	public WaterPool Copy()
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		CopyTo(waterPool);
		return waterPool;
	}

	public static WaterPool Deserialize(BufferStream stream)
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		Deserialize(stream, waterPool, isDelta: false);
		return waterPool;
	}

	public static WaterPool DeserializeLengthDelimited(BufferStream stream)
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		DeserializeLengthDelimited(stream, waterPool, isDelta: false);
		return waterPool;
	}

	public static WaterPool DeserializeLength(BufferStream stream, int length)
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		DeserializeLength(stream, length, waterPool, isDelta: false);
		return waterPool;
	}

	public static WaterPool Deserialize(byte[] buffer)
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, waterPool, isDelta: false);
		return waterPool;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WaterPool previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WaterPool Deserialize(BufferStream stream, WaterPool instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.fillAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WaterPool DeserializeLengthDelimited(BufferStream stream, WaterPool instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fillAmount = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WaterPool DeserializeLength(BufferStream stream, int length, WaterPool instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fillAmount = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WaterPool instance, WaterPool previous)
	{
		if (instance.fillAmount != previous.fillAmount)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fillAmount);
		}
	}

	public static void Serialize(BufferStream stream, WaterPool instance)
	{
		if (instance.fillAmount != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fillAmount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Photo : IDisposable, IPooled, IProto<Photo>, IProto
{
	[NonSerialized]
	public ulong photographerSteamId;

	[NonSerialized]
	public uint imageCrc;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Photo instance)
	{
		if (instance.ShouldPool)
		{
			instance.photographerSteamId = 0uL;
			instance.imageCrc = 0u;
			Pool.Free<Photo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Photo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Photo instance)
	{
		instance.photographerSteamId = photographerSteamId;
		instance.imageCrc = imageCrc;
	}

	public Photo Copy()
	{
		Photo photo = Pool.Get<Photo>();
		CopyTo(photo);
		return photo;
	}

	public static Photo Deserialize(BufferStream stream)
	{
		Photo photo = Pool.Get<Photo>();
		Deserialize(stream, photo, isDelta: false);
		return photo;
	}

	public static Photo DeserializeLengthDelimited(BufferStream stream)
	{
		Photo photo = Pool.Get<Photo>();
		DeserializeLengthDelimited(stream, photo, isDelta: false);
		return photo;
	}

	public static Photo DeserializeLength(BufferStream stream, int length)
	{
		Photo photo = Pool.Get<Photo>();
		DeserializeLength(stream, length, photo, isDelta: false);
		return photo;
	}

	public static Photo Deserialize(byte[] buffer)
	{
		Photo photo = Pool.Get<Photo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, photo, isDelta: false);
		return photo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Photo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Photo Deserialize(BufferStream stream, Photo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.photographerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Photo DeserializeLengthDelimited(BufferStream stream, Photo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.photographerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Photo DeserializeLength(BufferStream stream, int length, Photo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.photographerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Photo instance, Photo previous)
	{
		if (instance.photographerSteamId != previous.photographerSteamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.photographerSteamId);
		}
		if (instance.imageCrc != previous.imageCrc)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
	}

	public static void Serialize(BufferStream stream, Photo instance)
	{
		if (instance.photographerSteamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.photographerSteamId);
		}
		if (instance.imageCrc != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PhotoFrame : IDisposable, IPooled, IProto<PhotoFrame>, IProto
{
	[NonSerialized]
	public NetworkableId photoEntityId;

	[NonSerialized]
	public uint overlayImageCrc;

	[NonSerialized]
	public List<ulong> editHistory;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PhotoFrame instance)
	{
		if (instance.ShouldPool)
		{
			instance.photoEntityId = default(NetworkableId);
			instance.overlayImageCrc = 0u;
			if (instance.editHistory != null)
			{
				List<ulong> list = instance.editHistory;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.editHistory = list;
			}
			Pool.Free<PhotoFrame>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PhotoFrame with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PhotoFrame instance)
	{
		instance.photoEntityId = photoEntityId;
		instance.overlayImageCrc = overlayImageCrc;
		if (editHistory != null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
			for (int i = 0; i < editHistory.Count; i++)
			{
				ulong item = editHistory[i];
				instance.editHistory.Add(item);
			}
		}
		else
		{
			instance.editHistory = null;
		}
	}

	public PhotoFrame Copy()
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		CopyTo(photoFrame);
		return photoFrame;
	}

	public static PhotoFrame Deserialize(BufferStream stream)
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		Deserialize(stream, photoFrame, isDelta: false);
		return photoFrame;
	}

	public static PhotoFrame DeserializeLengthDelimited(BufferStream stream)
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		DeserializeLengthDelimited(stream, photoFrame, isDelta: false);
		return photoFrame;
	}

	public static PhotoFrame DeserializeLength(BufferStream stream, int length)
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		DeserializeLength(stream, length, photoFrame, isDelta: false);
		return photoFrame;
	}

	public static PhotoFrame Deserialize(byte[] buffer)
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, photoFrame, isDelta: false);
		return photoFrame;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PhotoFrame previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PhotoFrame Deserialize(BufferStream stream, PhotoFrame instance, bool isDelta)
	{
		if (!isDelta && instance.editHistory == null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.photoEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.overlayImageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PhotoFrame DeserializeLengthDelimited(BufferStream stream, PhotoFrame instance, bool isDelta)
	{
		if (!isDelta && instance.editHistory == null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.photoEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.overlayImageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PhotoFrame DeserializeLength(BufferStream stream, int length, PhotoFrame instance, bool isDelta)
	{
		if (!isDelta && instance.editHistory == null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.photoEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.overlayImageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PhotoFrame instance, PhotoFrame previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.photoEntityId.Value);
		if (instance.overlayImageCrc != previous.overlayImageCrc)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.overlayImageCrc);
		}
		if (instance.editHistory != null)
		{
			for (int i = 0; i < instance.editHistory.Count; i++)
			{
				ulong val = instance.editHistory[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, PhotoFrame instance)
	{
		if (instance.photoEntityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.photoEntityId.Value);
		}
		if (instance.overlayImageCrc != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.overlayImageCrc);
		}
		if (instance.editHistory != null)
		{
			for (int i = 0; i < instance.editHistory.Count; i++)
			{
				ulong val = instance.editHistory[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref photoEntityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VehicleModule : IDisposable, IPooled, IProto<VehicleModule>, IProto
{
	[NonSerialized]
	public int socketIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VehicleModule instance)
	{
		if (instance.ShouldPool)
		{
			instance.socketIndex = 0;
			Pool.Free<VehicleModule>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VehicleModule with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VehicleModule instance)
	{
		instance.socketIndex = socketIndex;
	}

	public VehicleModule Copy()
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		CopyTo(vehicleModule);
		return vehicleModule;
	}

	public static VehicleModule Deserialize(BufferStream stream)
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		Deserialize(stream, vehicleModule, isDelta: false);
		return vehicleModule;
	}

	public static VehicleModule DeserializeLengthDelimited(BufferStream stream)
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		DeserializeLengthDelimited(stream, vehicleModule, isDelta: false);
		return vehicleModule;
	}

	public static VehicleModule DeserializeLength(BufferStream stream, int length)
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		DeserializeLength(stream, length, vehicleModule, isDelta: false);
		return vehicleModule;
	}

	public static VehicleModule Deserialize(byte[] buffer)
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vehicleModule, isDelta: false);
		return vehicleModule;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VehicleModule previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VehicleModule Deserialize(BufferStream stream, VehicleModule instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.socketIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VehicleModule DeserializeLengthDelimited(BufferStream stream, VehicleModule instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.socketIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VehicleModule DeserializeLength(BufferStream stream, int length, VehicleModule instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.socketIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VehicleModule instance, VehicleModule previous)
	{
		if (instance.socketIndex != previous.socketIndex)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.socketIndex);
		}
	}

	public static void Serialize(BufferStream stream, VehicleModule instance)
	{
		if (instance.socketIndex != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.socketIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MixingTable : IDisposable, IPooled, IProto<MixingTable>, IProto
{
	[NonSerialized]
	public float totalMixTime;

	[NonSerialized]
	public float remainingMixTime;

	[NonSerialized]
	public int currentRecipe;

	[NonSerialized]
	public int pendingItem;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MixingTable instance)
	{
		if (instance.ShouldPool)
		{
			instance.totalMixTime = 0f;
			instance.remainingMixTime = 0f;
			instance.currentRecipe = 0;
			instance.pendingItem = 0;
			Pool.Free<MixingTable>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MixingTable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MixingTable instance)
	{
		instance.totalMixTime = totalMixTime;
		instance.remainingMixTime = remainingMixTime;
		instance.currentRecipe = currentRecipe;
		instance.pendingItem = pendingItem;
	}

	public MixingTable Copy()
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		CopyTo(mixingTable);
		return mixingTable;
	}

	public static MixingTable Deserialize(BufferStream stream)
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		Deserialize(stream, mixingTable, isDelta: false);
		return mixingTable;
	}

	public static MixingTable DeserializeLengthDelimited(BufferStream stream)
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		DeserializeLengthDelimited(stream, mixingTable, isDelta: false);
		return mixingTable;
	}

	public static MixingTable DeserializeLength(BufferStream stream, int length)
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		DeserializeLength(stream, length, mixingTable, isDelta: false);
		return mixingTable;
	}

	public static MixingTable Deserialize(byte[] buffer)
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mixingTable, isDelta: false);
		return mixingTable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MixingTable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MixingTable Deserialize(BufferStream stream, MixingTable instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.totalMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.remainingMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.currentRecipe = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.pendingItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MixingTable DeserializeLengthDelimited(BufferStream stream, MixingTable instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.totalMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.remainingMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.currentRecipe = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.pendingItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MixingTable DeserializeLength(BufferStream stream, int length, MixingTable instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.totalMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.remainingMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.currentRecipe = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.pendingItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MixingTable instance, MixingTable previous)
	{
		if (instance.totalMixTime != previous.totalMixTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.totalMixTime);
		}
		if (instance.remainingMixTime != previous.remainingMixTime)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.remainingMixTime);
		}
		if (instance.currentRecipe != previous.currentRecipe)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentRecipe);
		}
		if (instance.pendingItem != previous.pendingItem)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.pendingItem);
		}
	}

	public static void Serialize(BufferStream stream, MixingTable instance)
	{
		if (instance.totalMixTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.totalMixTime);
		}
		if (instance.remainingMixTime != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.remainingMixTime);
		}
		if (instance.currentRecipe != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentRecipe);
		}
		if (instance.pendingItem != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.pendingItem);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Elevator : IDisposable, IPooled, IProto<Elevator>, IProto
{
	[NonSerialized]
	public int floor;

	[NonSerialized]
	public NetworkableId spawnedLift;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Elevator instance)
	{
		if (instance.ShouldPool)
		{
			instance.floor = 0;
			instance.spawnedLift = default(NetworkableId);
			Pool.Free<Elevator>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Elevator with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Elevator instance)
	{
		instance.floor = floor;
		instance.spawnedLift = spawnedLift;
	}

	public Elevator Copy()
	{
		Elevator elevator = Pool.Get<Elevator>();
		CopyTo(elevator);
		return elevator;
	}

	public static Elevator Deserialize(BufferStream stream)
	{
		Elevator elevator = Pool.Get<Elevator>();
		Deserialize(stream, elevator, isDelta: false);
		return elevator;
	}

	public static Elevator DeserializeLengthDelimited(BufferStream stream)
	{
		Elevator elevator = Pool.Get<Elevator>();
		DeserializeLengthDelimited(stream, elevator, isDelta: false);
		return elevator;
	}

	public static Elevator DeserializeLength(BufferStream stream, int length)
	{
		Elevator elevator = Pool.Get<Elevator>();
		DeserializeLength(stream, length, elevator, isDelta: false);
		return elevator;
	}

	public static Elevator Deserialize(byte[] buffer)
	{
		Elevator elevator = Pool.Get<Elevator>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, elevator, isDelta: false);
		return elevator;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Elevator previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Elevator Deserialize(BufferStream stream, Elevator instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.spawnedLift = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Elevator DeserializeLengthDelimited(BufferStream stream, Elevator instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.spawnedLift = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Elevator DeserializeLength(BufferStream stream, int length, Elevator instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.spawnedLift = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Elevator instance, Elevator previous)
	{
		if (instance.floor != previous.floor)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.floor);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.spawnedLift.Value);
	}

	public static void Serialize(BufferStream stream, Elevator instance)
	{
		if (instance.floor != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.floor);
		}
		if (instance.spawnedLift != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.spawnedLift.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref spawnedLift.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SkullTrophy : IDisposable, IPooled, IProto<SkullTrophy>, IProto
{
	[NonSerialized]
	public string playerName;

	[NonSerialized]
	public string streamerName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SkullTrophy instance)
	{
		if (instance.ShouldPool)
		{
			instance.playerName = string.Empty;
			instance.streamerName = string.Empty;
			Pool.Free<SkullTrophy>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SkullTrophy with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SkullTrophy instance)
	{
		instance.playerName = playerName;
		instance.streamerName = streamerName;
	}

	public SkullTrophy Copy()
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		CopyTo(skullTrophy);
		return skullTrophy;
	}

	public static SkullTrophy Deserialize(BufferStream stream)
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		Deserialize(stream, skullTrophy, isDelta: false);
		return skullTrophy;
	}

	public static SkullTrophy DeserializeLengthDelimited(BufferStream stream)
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		DeserializeLengthDelimited(stream, skullTrophy, isDelta: false);
		return skullTrophy;
	}

	public static SkullTrophy DeserializeLength(BufferStream stream, int length)
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		DeserializeLength(stream, length, skullTrophy, isDelta: false);
		return skullTrophy;
	}

	public static SkullTrophy Deserialize(byte[] buffer)
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, skullTrophy, isDelta: false);
		return skullTrophy;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SkullTrophy previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SkullTrophy Deserialize(BufferStream stream, SkullTrophy instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.streamerName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SkullTrophy DeserializeLengthDelimited(BufferStream stream, SkullTrophy instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.streamerName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SkullTrophy DeserializeLength(BufferStream stream, int length, SkullTrophy instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.streamerName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SkullTrophy instance, SkullTrophy previous)
	{
		if (instance.playerName != null && instance.playerName != previous.playerName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.streamerName != null && instance.streamerName != previous.streamerName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
	}

	public static void Serialize(BufferStream stream, SkullTrophy instance)
	{
		if (instance.playerName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.streamerName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Cassette : IDisposable, IPooled, IProto<Cassette>, IProto
{
	[NonSerialized]
	public uint audioId;

	[NonSerialized]
	public NetworkableId holder;

	[NonSerialized]
	public ulong creatorSteamId;

	[NonSerialized]
	public int preloadAudioId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Cassette instance)
	{
		if (instance.ShouldPool)
		{
			instance.audioId = 0u;
			instance.holder = default(NetworkableId);
			instance.creatorSteamId = 0uL;
			instance.preloadAudioId = 0;
			Pool.Free<Cassette>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Cassette with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Cassette instance)
	{
		instance.audioId = audioId;
		instance.holder = holder;
		instance.creatorSteamId = creatorSteamId;
		instance.preloadAudioId = preloadAudioId;
	}

	public Cassette Copy()
	{
		Cassette cassette = Pool.Get<Cassette>();
		CopyTo(cassette);
		return cassette;
	}

	public static Cassette Deserialize(BufferStream stream)
	{
		Cassette cassette = Pool.Get<Cassette>();
		Deserialize(stream, cassette, isDelta: false);
		return cassette;
	}

	public static Cassette DeserializeLengthDelimited(BufferStream stream)
	{
		Cassette cassette = Pool.Get<Cassette>();
		DeserializeLengthDelimited(stream, cassette, isDelta: false);
		return cassette;
	}

	public static Cassette DeserializeLength(BufferStream stream, int length)
	{
		Cassette cassette = Pool.Get<Cassette>();
		DeserializeLength(stream, length, cassette, isDelta: false);
		return cassette;
	}

	public static Cassette Deserialize(byte[] buffer)
	{
		Cassette cassette = Pool.Get<Cassette>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cassette, isDelta: false);
		return cassette;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Cassette previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Cassette Deserialize(BufferStream stream, Cassette instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 24:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.holder = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.creatorSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.preloadAudioId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Cassette DeserializeLengthDelimited(BufferStream stream, Cassette instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.holder = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.creatorSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.preloadAudioId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Cassette DeserializeLength(BufferStream stream, int length, Cassette instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.holder = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.creatorSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.preloadAudioId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Cassette instance, Cassette previous)
	{
		if (instance.audioId != previous.audioId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.audioId);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.holder.Value);
		if (instance.creatorSteamId != previous.creatorSteamId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.creatorSteamId);
		}
		if (instance.preloadAudioId != previous.preloadAudioId)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.preloadAudioId);
		}
	}

	public static void Serialize(BufferStream stream, Cassette instance)
	{
		if (instance.audioId != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.audioId);
		}
		if (instance.holder != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.holder.Value);
		}
		if (instance.creatorSteamId != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.creatorSteamId);
		}
		if (instance.preloadAudioId != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.preloadAudioId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref holder.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Telephone : IDisposable, IPooled, IProto<Telephone>, IProto
{
	[NonSerialized]
	public int lastNumber;

	[NonSerialized]
	public int phoneNumber;

	[NonSerialized]
	public NetworkableId usingPlayer;

	[NonSerialized]
	public string phoneName;

	[NonSerialized]
	public PhoneDirectory savedNumbers;

	[NonSerialized]
	public List<VoicemailEntry> voicemail;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Telephone instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.lastNumber = 0;
		instance.phoneNumber = 0;
		instance.usingPlayer = default(NetworkableId);
		instance.phoneName = string.Empty;
		if (instance.savedNumbers != null)
		{
			instance.savedNumbers.ResetToPool();
			instance.savedNumbers = null;
		}
		if (instance.voicemail != null)
		{
			for (int i = 0; i < instance.voicemail.Count; i++)
			{
				if (instance.voicemail[i] != null)
				{
					instance.voicemail[i].ResetToPool();
					instance.voicemail[i] = null;
				}
			}
			List<VoicemailEntry> list = instance.voicemail;
			Pool.Free<VoicemailEntry>(ref list, false);
			instance.voicemail = list;
		}
		Pool.Free<Telephone>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Telephone with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Telephone instance)
	{
		instance.lastNumber = lastNumber;
		instance.phoneNumber = phoneNumber;
		instance.usingPlayer = usingPlayer;
		instance.phoneName = phoneName;
		if (savedNumbers != null)
		{
			if (instance.savedNumbers == null)
			{
				instance.savedNumbers = savedNumbers.Copy();
			}
			else
			{
				savedNumbers.CopyTo(instance.savedNumbers);
			}
		}
		else
		{
			instance.savedNumbers = null;
		}
		if (voicemail != null)
		{
			instance.voicemail = Pool.Get<List<VoicemailEntry>>();
			for (int i = 0; i < voicemail.Count; i++)
			{
				VoicemailEntry item = voicemail[i].Copy();
				instance.voicemail.Add(item);
			}
		}
		else
		{
			instance.voicemail = null;
		}
	}

	public Telephone Copy()
	{
		Telephone telephone = Pool.Get<Telephone>();
		CopyTo(telephone);
		return telephone;
	}

	public static Telephone Deserialize(BufferStream stream)
	{
		Telephone telephone = Pool.Get<Telephone>();
		Deserialize(stream, telephone, isDelta: false);
		return telephone;
	}

	public static Telephone DeserializeLengthDelimited(BufferStream stream)
	{
		Telephone telephone = Pool.Get<Telephone>();
		DeserializeLengthDelimited(stream, telephone, isDelta: false);
		return telephone;
	}

	public static Telephone DeserializeLength(BufferStream stream, int length)
	{
		Telephone telephone = Pool.Get<Telephone>();
		DeserializeLength(stream, length, telephone, isDelta: false);
		return telephone;
	}

	public static Telephone Deserialize(byte[] buffer)
	{
		Telephone telephone = Pool.Get<Telephone>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, telephone, isDelta: false);
		return telephone;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Telephone previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Telephone Deserialize(BufferStream stream, Telephone instance, bool isDelta)
	{
		if (!isDelta && instance.voicemail == null)
		{
			instance.voicemail = Pool.Get<List<VoicemailEntry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lastNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.usingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.phoneName = ProtocolParser.ReadString(stream);
				break;
			case 50:
				if (instance.savedNumbers == null)
				{
					instance.savedNumbers = PhoneDirectory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PhoneDirectory.DeserializeLengthDelimited(stream, instance.savedNumbers, isDelta);
				}
				break;
			case 58:
				instance.voicemail.Add(VoicemailEntry.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Telephone DeserializeLengthDelimited(BufferStream stream, Telephone instance, bool isDelta)
	{
		if (!isDelta && instance.voicemail == null)
		{
			instance.voicemail = Pool.Get<List<VoicemailEntry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lastNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.usingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.phoneName = ProtocolParser.ReadString(stream);
				break;
			case 50:
				if (instance.savedNumbers == null)
				{
					instance.savedNumbers = PhoneDirectory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PhoneDirectory.DeserializeLengthDelimited(stream, instance.savedNumbers, isDelta);
				}
				break;
			case 58:
				instance.voicemail.Add(VoicemailEntry.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Telephone DeserializeLength(BufferStream stream, int length, Telephone instance, bool isDelta)
	{
		if (!isDelta && instance.voicemail == null)
		{
			instance.voicemail = Pool.Get<List<VoicemailEntry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lastNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.usingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.phoneName = ProtocolParser.ReadString(stream);
				break;
			case 50:
				if (instance.savedNumbers == null)
				{
					instance.savedNumbers = PhoneDirectory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PhoneDirectory.DeserializeLengthDelimited(stream, instance.savedNumbers, isDelta);
				}
				break;
			case 58:
				instance.voicemail.Add(VoicemailEntry.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Telephone instance, Telephone previous)
	{
		if (instance.lastNumber != previous.lastNumber)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastNumber);
		}
		if (instance.phoneNumber != previous.phoneNumber)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.usingPlayer.Value);
		if (instance.phoneName != null && instance.phoneName != previous.phoneName)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}
		if (instance.savedNumbers != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PhoneDirectory.SerializeDelta(stream, instance.savedNumbers, previous.savedNumbers);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.voicemail == null)
		{
			return;
		}
		for (int i = 0; i < instance.voicemail.Count; i++)
		{
			VoicemailEntry voicemailEntry = instance.voicemail[i];
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			VoicemailEntry.SerializeDelta(stream, voicemailEntry, voicemailEntry);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, Telephone instance)
	{
		if (instance.lastNumber != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastNumber);
		}
		if (instance.phoneNumber != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		if (instance.usingPlayer != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.usingPlayer.Value);
		}
		if (instance.phoneName != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}
		if (instance.savedNumbers != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PhoneDirectory.Serialize(stream, instance.savedNumbers);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.voicemail == null)
		{
			return;
		}
		for (int i = 0; i < instance.voicemail.Count; i++)
		{
			VoicemailEntry instance2 = instance.voicemail[i];
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			VoicemailEntry.Serialize(stream, instance2);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref usingPlayer.Value);
		savedNumbers?.InspectUids(action);
		if (voicemail != null)
		{
			for (int i = 0; i < voicemail.Count; i++)
			{
				voicemail[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BoomBox : IDisposable, IPooled, IProto<BoomBox>, IProto
{
	[NonSerialized]
	public string radioIp;

	[NonSerialized]
	public ulong assignedRadioBy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BoomBox instance)
	{
		if (instance.ShouldPool)
		{
			instance.radioIp = string.Empty;
			instance.assignedRadioBy = 0uL;
			Pool.Free<BoomBox>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BoomBox with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BoomBox instance)
	{
		instance.radioIp = radioIp;
		instance.assignedRadioBy = assignedRadioBy;
	}

	public BoomBox Copy()
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		CopyTo(boomBox);
		return boomBox;
	}

	public static BoomBox Deserialize(BufferStream stream)
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		Deserialize(stream, boomBox, isDelta: false);
		return boomBox;
	}

	public static BoomBox DeserializeLengthDelimited(BufferStream stream)
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		DeserializeLengthDelimited(stream, boomBox, isDelta: false);
		return boomBox;
	}

	public static BoomBox DeserializeLength(BufferStream stream, int length)
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		DeserializeLength(stream, length, boomBox, isDelta: false);
		return boomBox;
	}

	public static BoomBox Deserialize(byte[] buffer)
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, boomBox, isDelta: false);
		return boomBox;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BoomBox previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BoomBox Deserialize(BufferStream stream, BoomBox instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.radioIp = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.assignedRadioBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BoomBox DeserializeLengthDelimited(BufferStream stream, BoomBox instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.radioIp = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.assignedRadioBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BoomBox DeserializeLength(BufferStream stream, int length, BoomBox instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.radioIp = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.assignedRadioBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BoomBox instance, BoomBox previous)
	{
		if (instance.radioIp != null && instance.radioIp != previous.radioIp)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.radioIp);
		}
		if (instance.assignedRadioBy != previous.assignedRadioBy)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.assignedRadioBy);
		}
	}

	public static void Serialize(BufferStream stream, BoomBox instance)
	{
		if (instance.radioIp != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.radioIp);
		}
		if (instance.assignedRadioBy != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.assignedRadioBy);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class NeonSign : IDisposable, IPooled, IProto<NeonSign>, IProto
{
	public class Lights : IDisposable, IPooled, IProto<Lights>, IProto
	{
		[NonSerialized]
		public Color topLeft;

		[NonSerialized]
		public Color topRight;

		[NonSerialized]
		public Color bottomLeft;

		[NonSerialized]
		public Color bottomRight;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Lights instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.topLeft = default(Color);
				instance.topRight = default(Color);
				instance.bottomLeft = default(Color);
				instance.bottomRight = default(Color);
				Pool.Free<Lights>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Lights with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Lights instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			instance.topLeft = topLeft;
			instance.topRight = topRight;
			instance.bottomLeft = bottomLeft;
			instance.bottomRight = bottomRight;
		}

		public Lights Copy()
		{
			Lights lights = Pool.Get<Lights>();
			CopyTo(lights);
			return lights;
		}

		public static Lights Deserialize(BufferStream stream)
		{
			Lights lights = Pool.Get<Lights>();
			Deserialize(stream, lights, isDelta: false);
			return lights;
		}

		public static Lights DeserializeLengthDelimited(BufferStream stream)
		{
			Lights lights = Pool.Get<Lights>();
			DeserializeLengthDelimited(stream, lights, isDelta: false);
			return lights;
		}

		public static Lights DeserializeLength(BufferStream stream, int length)
		{
			Lights lights = Pool.Get<Lights>();
			DeserializeLength(stream, length, lights, isDelta: false);
			return lights;
		}

		public static Lights Deserialize(byte[] buffer)
		{
			Lights lights = Pool.Get<Lights>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, lights, isDelta: false);
			return lights;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Lights previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Lights Deserialize(BufferStream stream, Lights instance, bool isDelta)
		{
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
					continue;
				case 26:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
					continue;
				case 34:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Lights DeserializeLengthDelimited(BufferStream stream, Lights instance, bool isDelta)
		{
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
					continue;
				case 26:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
					continue;
				case 34:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Lights DeserializeLength(BufferStream stream, int length, Lights instance, bool isDelta)
		{
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
					continue;
				case 26:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
					continue;
				case 34:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Lights instance, Lights previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_013c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0169: Unknown result type (might be due to invalid IL or missing references)
			if (instance.topLeft != previous.topLeft)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.topLeft, previous.topLeft);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topLeft (UnityEngine.Color)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.topRight != previous.topRight)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.topRight, previous.topRight);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topRight (UnityEngine.Color)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.bottomLeft != previous.bottomLeft)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.bottomLeft, previous.bottomLeft);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomLeft (UnityEngine.Color)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
			if (instance.bottomRight != previous.bottomRight)
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.bottomRight, previous.bottomRight);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomRight (UnityEngine.Color)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
		}

		public static void Serialize(BufferStream stream, Lights instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_012e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_015e: Unknown result type (might be due to invalid IL or missing references)
			if (instance.topLeft != default(Color))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ColorSerialized.Serialize(stream, instance.topLeft);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topLeft (UnityEngine.Color)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.topRight != default(Color))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				ColorSerialized.Serialize(stream, instance.topRight);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topRight (UnityEngine.Color)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.bottomLeft != default(Color))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				ColorSerialized.Serialize(stream, instance.bottomLeft);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomLeft (UnityEngine.Color)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
			if (instance.bottomRight != default(Color))
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				ColorSerialized.Serialize(stream, instance.bottomRight);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomRight (UnityEngine.Color)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Lights> frameLighting;

	[NonSerialized]
	public int currentFrame;

	[NonSerialized]
	public float animationSpeed;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NeonSign instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.frameLighting != null)
		{
			for (int i = 0; i < instance.frameLighting.Count; i++)
			{
				if (instance.frameLighting[i] != null)
				{
					instance.frameLighting[i].ResetToPool();
					instance.frameLighting[i] = null;
				}
			}
			List<Lights> list = instance.frameLighting;
			Pool.Free<Lights>(ref list, false);
			instance.frameLighting = list;
		}
		instance.currentFrame = 0;
		instance.animationSpeed = 0f;
		Pool.Free<NeonSign>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NeonSign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NeonSign instance)
	{
		if (frameLighting != null)
		{
			instance.frameLighting = Pool.Get<List<Lights>>();
			for (int i = 0; i < frameLighting.Count; i++)
			{
				Lights item = frameLighting[i].Copy();
				instance.frameLighting.Add(item);
			}
		}
		else
		{
			instance.frameLighting = null;
		}
		instance.currentFrame = currentFrame;
		instance.animationSpeed = animationSpeed;
	}

	public NeonSign Copy()
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		CopyTo(neonSign);
		return neonSign;
	}

	public static NeonSign Deserialize(BufferStream stream)
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		Deserialize(stream, neonSign, isDelta: false);
		return neonSign;
	}

	public static NeonSign DeserializeLengthDelimited(BufferStream stream)
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		DeserializeLengthDelimited(stream, neonSign, isDelta: false);
		return neonSign;
	}

	public static NeonSign DeserializeLength(BufferStream stream, int length)
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		DeserializeLength(stream, length, neonSign, isDelta: false);
		return neonSign;
	}

	public static NeonSign Deserialize(byte[] buffer)
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, neonSign, isDelta: false);
		return neonSign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NeonSign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NeonSign Deserialize(BufferStream stream, NeonSign instance, bool isDelta)
	{
		if (!isDelta && instance.frameLighting == null)
		{
			instance.frameLighting = Pool.Get<List<Lights>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 42:
				instance.frameLighting.Add(Lights.DeserializeLengthDelimited(stream));
				continue;
			case 48:
				instance.currentFrame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.animationSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NeonSign DeserializeLengthDelimited(BufferStream stream, NeonSign instance, bool isDelta)
	{
		if (!isDelta && instance.frameLighting == null)
		{
			instance.frameLighting = Pool.Get<List<Lights>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 42:
				instance.frameLighting.Add(Lights.DeserializeLengthDelimited(stream));
				continue;
			case 48:
				instance.currentFrame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.animationSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NeonSign DeserializeLength(BufferStream stream, int length, NeonSign instance, bool isDelta)
	{
		if (!isDelta && instance.frameLighting == null)
		{
			instance.frameLighting = Pool.Get<List<Lights>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 42:
				instance.frameLighting.Add(Lights.DeserializeLengthDelimited(stream));
				continue;
			case 48:
				instance.currentFrame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.animationSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NeonSign instance, NeonSign previous)
	{
		if (instance.frameLighting != null)
		{
			for (int i = 0; i < instance.frameLighting.Count; i++)
			{
				Lights lights = instance.frameLighting[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Lights.SerializeDelta(stream, lights, lights);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field frameLighting (ProtoBuf.NeonSign.Lights)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.currentFrame != previous.currentFrame)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentFrame);
		}
		if (instance.animationSpeed != previous.animationSpeed)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.animationSpeed);
		}
	}

	public static void Serialize(BufferStream stream, NeonSign instance)
	{
		if (instance.frameLighting != null)
		{
			for (int i = 0; i < instance.frameLighting.Count; i++)
			{
				Lights instance2 = instance.frameLighting[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Lights.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field frameLighting (ProtoBuf.NeonSign.Lights)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.currentFrame != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentFrame);
		}
		if (instance.animationSpeed != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.animationSpeed);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (frameLighting != null)
		{
			for (int i = 0; i < frameLighting.Count; i++)
			{
				frameLighting[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TrainEngine : IDisposable, IPooled, IProto<TrainEngine>, IProto
{
	[NonSerialized]
	public int throttleSetting;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TrainEngine instance)
	{
		if (instance.ShouldPool)
		{
			instance.throttleSetting = 0;
			instance.fuelStorageID = default(NetworkableId);
			Pool.Free<TrainEngine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TrainEngine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TrainEngine instance)
	{
		instance.throttleSetting = throttleSetting;
		instance.fuelStorageID = fuelStorageID;
	}

	public TrainEngine Copy()
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		CopyTo(trainEngine);
		return trainEngine;
	}

	public static TrainEngine Deserialize(BufferStream stream)
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		Deserialize(stream, trainEngine, isDelta: false);
		return trainEngine;
	}

	public static TrainEngine DeserializeLengthDelimited(BufferStream stream)
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		DeserializeLengthDelimited(stream, trainEngine, isDelta: false);
		return trainEngine;
	}

	public static TrainEngine DeserializeLength(BufferStream stream, int length)
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		DeserializeLength(stream, length, trainEngine, isDelta: false);
		return trainEngine;
	}

	public static TrainEngine Deserialize(byte[] buffer)
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, trainEngine, isDelta: false);
		return trainEngine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TrainEngine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TrainEngine Deserialize(BufferStream stream, TrainEngine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.throttleSetting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TrainEngine DeserializeLengthDelimited(BufferStream stream, TrainEngine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.throttleSetting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TrainEngine DeserializeLength(BufferStream stream, int length, TrainEngine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.throttleSetting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TrainEngine instance, TrainEngine previous)
	{
		if (instance.throttleSetting != previous.throttleSetting)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.throttleSetting);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
	}

	public static void Serialize(BufferStream stream, TrainEngine instance)
	{
		if (instance.throttleSetting != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.throttleSetting);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SubEntityList : IDisposable, IPooled, IProto<SubEntityList>, IProto
{
	[NonSerialized]
	public List<NetworkableId> subEntityIds;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SubEntityList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.subEntityIds != null)
			{
				List<NetworkableId> list = instance.subEntityIds;
				Pool.FreeUnmanaged<NetworkableId>(ref list);
				instance.subEntityIds = list;
			}
			Pool.Free<SubEntityList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SubEntityList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SubEntityList instance)
	{
		if (subEntityIds != null)
		{
			instance.subEntityIds = Pool.Get<List<NetworkableId>>();
			for (int i = 0; i < subEntityIds.Count; i++)
			{
				NetworkableId item = subEntityIds[i];
				instance.subEntityIds.Add(item);
			}
		}
		else
		{
			instance.subEntityIds = null;
		}
	}

	public SubEntityList Copy()
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		CopyTo(subEntityList);
		return subEntityList;
	}

	public static SubEntityList Deserialize(BufferStream stream)
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		Deserialize(stream, subEntityList, isDelta: false);
		return subEntityList;
	}

	public static SubEntityList DeserializeLengthDelimited(BufferStream stream)
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		DeserializeLengthDelimited(stream, subEntityList, isDelta: false);
		return subEntityList;
	}

	public static SubEntityList DeserializeLength(BufferStream stream, int length)
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		DeserializeLength(stream, length, subEntityList, isDelta: false);
		return subEntityList;
	}

	public static SubEntityList Deserialize(byte[] buffer)
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, subEntityList, isDelta: false);
		return subEntityList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SubEntityList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SubEntityList Deserialize(BufferStream stream, SubEntityList instance, bool isDelta)
	{
		if (!isDelta && instance.subEntityIds == null)
		{
			instance.subEntityIds = Pool.Get<List<NetworkableId>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.subEntityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SubEntityList DeserializeLengthDelimited(BufferStream stream, SubEntityList instance, bool isDelta)
	{
		if (!isDelta && instance.subEntityIds == null)
		{
			instance.subEntityIds = Pool.Get<List<NetworkableId>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.subEntityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SubEntityList DeserializeLength(BufferStream stream, int length, SubEntityList instance, bool isDelta)
	{
		if (!isDelta && instance.subEntityIds == null)
		{
			instance.subEntityIds = Pool.Get<List<NetworkableId>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.subEntityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SubEntityList instance, SubEntityList previous)
	{
		if (instance.subEntityIds != null)
		{
			for (int i = 0; i < instance.subEntityIds.Count; i++)
			{
				NetworkableId networkableId = instance.subEntityIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public static void Serialize(BufferStream stream, SubEntityList instance)
	{
		if (instance.subEntityIds != null)
		{
			for (int i = 0; i < instance.subEntityIds.Count; i++)
			{
				NetworkableId networkableId = instance.subEntityIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < subEntityIds.Count; i++)
		{
			NetworkableId value = subEntityIds[i];
			action(UidType.NetworkableId, ref value.Value);
			subEntityIds[i] = value;
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MarketTerminal : IDisposable, IPooled, IProto<MarketTerminal>, IProto
{
	public class PendingOrder : IDisposable, IPooled, IProto<PendingOrder>, IProto
	{
		[NonSerialized]
		public NetworkableId vendingMachineId;

		[NonSerialized]
		public NetworkableId droneId;

		[NonSerialized]
		public TimeUntil timeUntilExpiry;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PendingOrder instance)
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.vendingMachineId = default(NetworkableId);
				instance.droneId = default(NetworkableId);
				instance.timeUntilExpiry = TimeUntil.op_Implicit(0f);
				Pool.Free<PendingOrder>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PendingOrder with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PendingOrder instance)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			instance.vendingMachineId = vendingMachineId;
			instance.droneId = droneId;
			instance.timeUntilExpiry = timeUntilExpiry;
		}

		public PendingOrder Copy()
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			CopyTo(pendingOrder);
			return pendingOrder;
		}

		public static PendingOrder Deserialize(BufferStream stream)
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			Deserialize(stream, pendingOrder, isDelta: false);
			return pendingOrder;
		}

		public static PendingOrder DeserializeLengthDelimited(BufferStream stream)
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			DeserializeLengthDelimited(stream, pendingOrder, isDelta: false);
			return pendingOrder;
		}

		public static PendingOrder DeserializeLength(BufferStream stream, int length)
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			DeserializeLength(stream, length, pendingOrder, isDelta: false);
			return pendingOrder;
		}

		public static PendingOrder Deserialize(byte[] buffer)
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, pendingOrder, isDelta: false);
			return pendingOrder;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PendingOrder previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PendingOrder Deserialize(BufferStream stream, PendingOrder instance, bool isDelta)
		{
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 37:
					instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PendingOrder DeserializeLengthDelimited(BufferStream stream, PendingOrder instance, bool isDelta)
		{
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 37:
					instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PendingOrder DeserializeLength(BufferStream stream, int length, PendingOrder instance, bool isDelta)
		{
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 37:
					instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PendingOrder instance, PendingOrder previous)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.droneId.Value);
			if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != TimeUntil.op_Implicit(previous.timeUntilExpiry))
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
			}
		}

		public static void Serialize(BufferStream stream, PendingOrder instance)
		{
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			if (instance.vendingMachineId != default(NetworkableId))
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
			}
			if (instance.droneId != default(NetworkableId))
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.droneId.Value);
			}
			if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref vendingMachineId.Value);
			action(UidType.NetworkableId, ref droneId.Value);
		}
	}

	[NonSerialized]
	public ulong customerSteamId;

	[NonSerialized]
	public NetworkableId marketplaceId;

	[NonSerialized]
	public List<PendingOrder> orders;

	[NonSerialized]
	public string customerName;

	[NonSerialized]
	public TimeUntil timeUntilExpiry;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MarketTerminal instance)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.customerSteamId = 0uL;
		instance.marketplaceId = default(NetworkableId);
		if (instance.orders != null)
		{
			for (int i = 0; i < instance.orders.Count; i++)
			{
				if (instance.orders[i] != null)
				{
					instance.orders[i].ResetToPool();
					instance.orders[i] = null;
				}
			}
			List<PendingOrder> list = instance.orders;
			Pool.Free<PendingOrder>(ref list, false);
			instance.orders = list;
		}
		instance.customerName = string.Empty;
		instance.timeUntilExpiry = TimeUntil.op_Implicit(0f);
		Pool.Free<MarketTerminal>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MarketTerminal with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MarketTerminal instance)
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		instance.customerSteamId = customerSteamId;
		instance.marketplaceId = marketplaceId;
		if (orders != null)
		{
			instance.orders = Pool.Get<List<PendingOrder>>();
			for (int i = 0; i < orders.Count; i++)
			{
				PendingOrder item = orders[i].Copy();
				instance.orders.Add(item);
			}
		}
		else
		{
			instance.orders = null;
		}
		instance.customerName = customerName;
		instance.timeUntilExpiry = timeUntilExpiry;
	}

	public MarketTerminal Copy()
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		CopyTo(marketTerminal);
		return marketTerminal;
	}

	public static MarketTerminal Deserialize(BufferStream stream)
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		Deserialize(stream, marketTerminal, isDelta: false);
		return marketTerminal;
	}

	public static MarketTerminal DeserializeLengthDelimited(BufferStream stream)
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		DeserializeLengthDelimited(stream, marketTerminal, isDelta: false);
		return marketTerminal;
	}

	public static MarketTerminal DeserializeLength(BufferStream stream, int length)
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		DeserializeLength(stream, length, marketTerminal, isDelta: false);
		return marketTerminal;
	}

	public static MarketTerminal Deserialize(byte[] buffer)
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, marketTerminal, isDelta: false);
		return marketTerminal;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MarketTerminal previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MarketTerminal Deserialize(BufferStream stream, MarketTerminal instance, bool isDelta)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.orders == null)
		{
			instance.orders = Pool.Get<List<PendingOrder>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.customerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.orders.Add(PendingOrder.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.customerName = ProtocolParser.ReadString(stream);
				continue;
			case 53:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MarketTerminal DeserializeLengthDelimited(BufferStream stream, MarketTerminal instance, bool isDelta)
	{
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.orders == null)
		{
			instance.orders = Pool.Get<List<PendingOrder>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.customerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.orders.Add(PendingOrder.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.customerName = ProtocolParser.ReadString(stream);
				continue;
			case 53:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MarketTerminal DeserializeLength(BufferStream stream, int length, MarketTerminal instance, bool isDelta)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.orders == null)
		{
			instance.orders = Pool.Get<List<PendingOrder>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.customerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.orders.Add(PendingOrder.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.customerName = ProtocolParser.ReadString(stream);
				continue;
			case 53:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MarketTerminal instance, MarketTerminal previous)
	{
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		if (instance.customerSteamId != previous.customerSteamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.customerSteamId);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.marketplaceId.Value);
		if (instance.orders != null)
		{
			for (int i = 0; i < instance.orders.Count; i++)
			{
				PendingOrder pendingOrder = instance.orders[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				PendingOrder.SerializeDelta(stream, pendingOrder, pendingOrder);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field orders (ProtoBuf.MarketTerminal.PendingOrder)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.customerName != null && instance.customerName != previous.customerName)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.customerName);
		}
		if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != TimeUntil.op_Implicit(previous.timeUntilExpiry))
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
		}
	}

	public static void Serialize(BufferStream stream, MarketTerminal instance)
	{
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		if (instance.customerSteamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.customerSteamId);
		}
		if (instance.marketplaceId != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.marketplaceId.Value);
		}
		if (instance.orders != null)
		{
			for (int i = 0; i < instance.orders.Count; i++)
			{
				PendingOrder instance2 = instance.orders[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				PendingOrder.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field orders (ProtoBuf.MarketTerminal.PendingOrder)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.customerName != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.customerName);
		}
		if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref marketplaceId.Value);
		if (orders != null)
		{
			for (int i = 0; i < orders.Count; i++)
			{
				orders[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DeliveryDrone : IDisposable, IPooled, IProto<DeliveryDrone>, IProto
{
	[NonSerialized]
	public NetworkableId marketplaceId;

	[NonSerialized]
	public NetworkableId terminalId;

	[NonSerialized]
	public NetworkableId vendingMachineId;

	[NonSerialized]
	public int state;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DeliveryDrone instance)
	{
		if (instance.ShouldPool)
		{
			instance.marketplaceId = default(NetworkableId);
			instance.terminalId = default(NetworkableId);
			instance.vendingMachineId = default(NetworkableId);
			instance.state = 0;
			Pool.Free<DeliveryDrone>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DeliveryDrone with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DeliveryDrone instance)
	{
		instance.marketplaceId = marketplaceId;
		instance.terminalId = terminalId;
		instance.vendingMachineId = vendingMachineId;
		instance.state = state;
	}

	public DeliveryDrone Copy()
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		CopyTo(deliveryDrone);
		return deliveryDrone;
	}

	public static DeliveryDrone Deserialize(BufferStream stream)
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		Deserialize(stream, deliveryDrone, isDelta: false);
		return deliveryDrone;
	}

	public static DeliveryDrone DeserializeLengthDelimited(BufferStream stream)
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		DeserializeLengthDelimited(stream, deliveryDrone, isDelta: false);
		return deliveryDrone;
	}

	public static DeliveryDrone DeserializeLength(BufferStream stream, int length)
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		DeserializeLength(stream, length, deliveryDrone, isDelta: false);
		return deliveryDrone;
	}

	public static DeliveryDrone Deserialize(byte[] buffer)
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, deliveryDrone, isDelta: false);
		return deliveryDrone;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DeliveryDrone previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DeliveryDrone Deserialize(BufferStream stream, DeliveryDrone instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.terminalId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DeliveryDrone DeserializeLengthDelimited(BufferStream stream, DeliveryDrone instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.terminalId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DeliveryDrone DeserializeLength(BufferStream stream, int length, DeliveryDrone instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.terminalId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DeliveryDrone instance, DeliveryDrone previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.marketplaceId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.terminalId.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
		if (instance.state != previous.state)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
	}

	public static void Serialize(BufferStream stream, DeliveryDrone instance)
	{
		if (instance.marketplaceId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.marketplaceId.Value);
		}
		if (instance.terminalId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.terminalId.Value);
		}
		if (instance.vendingMachineId != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref marketplaceId.Value);
		action(UidType.NetworkableId, ref terminalId.Value);
		action(UidType.NetworkableId, ref vendingMachineId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class GameMode : IDisposable, IPooled, IProto<GameMode>, IProto
{
	public class TeamInfo : IDisposable, IPooled, IProto<TeamInfo>, IProto
	{
		[NonSerialized]
		public int score;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(TeamInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.score = 0;
				Pool.Free<TeamInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose TeamInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(TeamInfo instance)
		{
			instance.score = score;
		}

		public TeamInfo Copy()
		{
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			CopyTo(teamInfo);
			return teamInfo;
		}

		public static TeamInfo Deserialize(BufferStream stream)
		{
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			Deserialize(stream, teamInfo, isDelta: false);
			return teamInfo;
		}

		public static TeamInfo DeserializeLengthDelimited(BufferStream stream)
		{
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			DeserializeLengthDelimited(stream, teamInfo, isDelta: false);
			return teamInfo;
		}

		public static TeamInfo DeserializeLength(BufferStream stream, int length)
		{
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			DeserializeLength(stream, length, teamInfo, isDelta: false);
			return teamInfo;
		}

		public static TeamInfo Deserialize(byte[] buffer)
		{
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, teamInfo, isDelta: false);
			return teamInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, TeamInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static TeamInfo Deserialize(BufferStream stream, TeamInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static TeamInfo DeserializeLengthDelimited(BufferStream stream, TeamInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static TeamInfo DeserializeLength(BufferStream stream, int length, TeamInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, TeamInfo instance, TeamInfo previous)
		{
			if (instance.score != previous.score)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public static void Serialize(BufferStream stream, TeamInfo instance)
		{
			if (instance.score != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class ScoreColumn : IDisposable, IPooled, IProto<ScoreColumn>, IProto
	{
		[NonSerialized]
		public string name;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ScoreColumn instance)
		{
			if (instance.ShouldPool)
			{
				instance.name = string.Empty;
				Pool.Free<ScoreColumn>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ScoreColumn with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ScoreColumn instance)
		{
			instance.name = name;
		}

		public ScoreColumn Copy()
		{
			ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
			CopyTo(scoreColumn);
			return scoreColumn;
		}

		public static ScoreColumn Deserialize(BufferStream stream)
		{
			ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
			Deserialize(stream, scoreColumn, isDelta: false);
			return scoreColumn;
		}

		public static ScoreColumn DeserializeLengthDelimited(BufferStream stream)
		{
			ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
			DeserializeLengthDelimited(stream, scoreColumn, isDelta: false);
			return scoreColumn;
		}

		public static ScoreColumn DeserializeLength(BufferStream stream, int length)
		{
			ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
			DeserializeLength(stream, length, scoreColumn, isDelta: false);
			return scoreColumn;
		}

		public static ScoreColumn Deserialize(byte[] buffer)
		{
			ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, scoreColumn, isDelta: false);
			return scoreColumn;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ScoreColumn previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ScoreColumn Deserialize(BufferStream stream, ScoreColumn instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ScoreColumn DeserializeLengthDelimited(BufferStream stream, ScoreColumn instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ScoreColumn DeserializeLength(BufferStream stream, int length, ScoreColumn instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ScoreColumn instance, ScoreColumn previous)
		{
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.name);
			}
		}

		public static void Serialize(BufferStream stream, ScoreColumn instance)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class PlayerScore : IDisposable, IPooled, IProto<PlayerScore>, IProto
	{
		[NonSerialized]
		public string playerName;

		[NonSerialized]
		public ulong userid;

		[NonSerialized]
		public List<int> scores;

		[NonSerialized]
		public int team;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerScore instance)
		{
			if (instance.ShouldPool)
			{
				instance.playerName = string.Empty;
				instance.userid = 0uL;
				if (instance.scores != null)
				{
					List<int> list = instance.scores;
					Pool.FreeUnmanaged<int>(ref list);
					instance.scores = list;
				}
				instance.team = 0;
				Pool.Free<PlayerScore>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerScore with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerScore instance)
		{
			instance.playerName = playerName;
			instance.userid = userid;
			if (scores != null)
			{
				instance.scores = Pool.Get<List<int>>();
				for (int i = 0; i < scores.Count; i++)
				{
					int item = scores[i];
					instance.scores.Add(item);
				}
			}
			else
			{
				instance.scores = null;
			}
			instance.team = team;
		}

		public PlayerScore Copy()
		{
			PlayerScore playerScore = Pool.Get<PlayerScore>();
			CopyTo(playerScore);
			return playerScore;
		}

		public static PlayerScore Deserialize(BufferStream stream)
		{
			PlayerScore playerScore = Pool.Get<PlayerScore>();
			Deserialize(stream, playerScore, isDelta: false);
			return playerScore;
		}

		public static PlayerScore DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerScore playerScore = Pool.Get<PlayerScore>();
			DeserializeLengthDelimited(stream, playerScore, isDelta: false);
			return playerScore;
		}

		public static PlayerScore DeserializeLength(BufferStream stream, int length)
		{
			PlayerScore playerScore = Pool.Get<PlayerScore>();
			DeserializeLength(stream, length, playerScore, isDelta: false);
			return playerScore;
		}

		public static PlayerScore Deserialize(byte[] buffer)
		{
			PlayerScore playerScore = Pool.Get<PlayerScore>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerScore, isDelta: false);
			return playerScore;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerScore previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerScore Deserialize(BufferStream stream, PlayerScore instance, bool isDelta)
		{
			if (!isDelta && instance.scores == null)
			{
				instance.scores = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.playerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.scores.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 32:
					instance.team = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerScore DeserializeLengthDelimited(BufferStream stream, PlayerScore instance, bool isDelta)
		{
			if (!isDelta && instance.scores == null)
			{
				instance.scores = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.playerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.scores.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 32:
					instance.team = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerScore DeserializeLength(BufferStream stream, int length, PlayerScore instance, bool isDelta)
		{
			if (!isDelta && instance.scores == null)
			{
				instance.scores = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.playerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.scores.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 32:
					instance.team = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerScore instance, PlayerScore previous)
		{
			if (instance.playerName != previous.playerName)
			{
				if (instance.playerName == null)
				{
					throw new ArgumentNullException("playerName", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.playerName);
			}
			if (instance.userid != previous.userid)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.scores != null)
			{
				for (int i = 0; i < instance.scores.Count; i++)
				{
					int num = instance.scores[i];
					stream.WriteByte(24);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.team != previous.team)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.team);
			}
		}

		public static void Serialize(BufferStream stream, PlayerScore instance)
		{
			if (instance.playerName == null)
			{
				throw new ArgumentNullException("playerName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.playerName);
			if (instance.userid != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.scores != null)
			{
				for (int i = 0; i < instance.scores.Count; i++)
				{
					int num = instance.scores[i];
					stream.WriteByte(24);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.team != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.team);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<TeamInfo> teams;

	[NonSerialized]
	public List<ScoreColumn> scoreColumns;

	[NonSerialized]
	public List<PlayerScore> playerScores;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(GameMode instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.teams != null)
		{
			for (int i = 0; i < instance.teams.Count; i++)
			{
				if (instance.teams[i] != null)
				{
					instance.teams[i].ResetToPool();
					instance.teams[i] = null;
				}
			}
			List<TeamInfo> list = instance.teams;
			Pool.Free<TeamInfo>(ref list, false);
			instance.teams = list;
		}
		if (instance.scoreColumns != null)
		{
			for (int j = 0; j < instance.scoreColumns.Count; j++)
			{
				if (instance.scoreColumns[j] != null)
				{
					instance.scoreColumns[j].ResetToPool();
					instance.scoreColumns[j] = null;
				}
			}
			List<ScoreColumn> list2 = instance.scoreColumns;
			Pool.Free<ScoreColumn>(ref list2, false);
			instance.scoreColumns = list2;
		}
		if (instance.playerScores != null)
		{
			for (int k = 0; k < instance.playerScores.Count; k++)
			{
				if (instance.playerScores[k] != null)
				{
					instance.playerScores[k].ResetToPool();
					instance.playerScores[k] = null;
				}
			}
			List<PlayerScore> list3 = instance.playerScores;
			Pool.Free<PlayerScore>(ref list3, false);
			instance.playerScores = list3;
		}
		Pool.Free<GameMode>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose GameMode with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(GameMode instance)
	{
		if (teams != null)
		{
			instance.teams = Pool.Get<List<TeamInfo>>();
			for (int i = 0; i < teams.Count; i++)
			{
				TeamInfo item = teams[i].Copy();
				instance.teams.Add(item);
			}
		}
		else
		{
			instance.teams = null;
		}
		if (scoreColumns != null)
		{
			instance.scoreColumns = Pool.Get<List<ScoreColumn>>();
			for (int j = 0; j < scoreColumns.Count; j++)
			{
				ScoreColumn item2 = scoreColumns[j].Copy();
				instance.scoreColumns.Add(item2);
			}
		}
		else
		{
			instance.scoreColumns = null;
		}
		if (playerScores != null)
		{
			instance.playerScores = Pool.Get<List<PlayerScore>>();
			for (int k = 0; k < playerScores.Count; k++)
			{
				PlayerScore item3 = playerScores[k].Copy();
				instance.playerScores.Add(item3);
			}
		}
		else
		{
			instance.playerScores = null;
		}
	}

	public GameMode Copy()
	{
		GameMode gameMode = Pool.Get<GameMode>();
		CopyTo(gameMode);
		return gameMode;
	}

	public static GameMode Deserialize(BufferStream stream)
	{
		GameMode gameMode = Pool.Get<GameMode>();
		Deserialize(stream, gameMode, isDelta: false);
		return gameMode;
	}

	public static GameMode DeserializeLengthDelimited(BufferStream stream)
	{
		GameMode gameMode = Pool.Get<GameMode>();
		DeserializeLengthDelimited(stream, gameMode, isDelta: false);
		return gameMode;
	}

	public static GameMode DeserializeLength(BufferStream stream, int length)
	{
		GameMode gameMode = Pool.Get<GameMode>();
		DeserializeLength(stream, length, gameMode, isDelta: false);
		return gameMode;
	}

	public static GameMode Deserialize(byte[] buffer)
	{
		GameMode gameMode = Pool.Get<GameMode>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, gameMode, isDelta: false);
		return gameMode;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, GameMode previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static GameMode Deserialize(BufferStream stream, GameMode instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teams == null)
			{
				instance.teams = Pool.Get<List<TeamInfo>>();
			}
			if (instance.scoreColumns == null)
			{
				instance.scoreColumns = Pool.Get<List<ScoreColumn>>();
			}
			if (instance.playerScores == null)
			{
				instance.playerScores = Pool.Get<List<PlayerScore>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.teams.Add(TeamInfo.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.scoreColumns.Add(ScoreColumn.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.playerScores.Add(PlayerScore.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static GameMode DeserializeLengthDelimited(BufferStream stream, GameMode instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teams == null)
			{
				instance.teams = Pool.Get<List<TeamInfo>>();
			}
			if (instance.scoreColumns == null)
			{
				instance.scoreColumns = Pool.Get<List<ScoreColumn>>();
			}
			if (instance.playerScores == null)
			{
				instance.playerScores = Pool.Get<List<PlayerScore>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.teams.Add(TeamInfo.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.scoreColumns.Add(ScoreColumn.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.playerScores.Add(PlayerScore.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static GameMode DeserializeLength(BufferStream stream, int length, GameMode instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teams == null)
			{
				instance.teams = Pool.Get<List<TeamInfo>>();
			}
			if (instance.scoreColumns == null)
			{
				instance.scoreColumns = Pool.Get<List<ScoreColumn>>();
			}
			if (instance.playerScores == null)
			{
				instance.playerScores = Pool.Get<List<PlayerScore>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.teams.Add(TeamInfo.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.scoreColumns.Add(ScoreColumn.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.playerScores.Add(PlayerScore.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, GameMode instance, GameMode previous)
	{
		if (instance.teams != null)
		{
			for (int i = 0; i < instance.teams.Count; i++)
			{
				TeamInfo teamInfo = instance.teams[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				TeamInfo.SerializeDelta(stream, teamInfo, teamInfo);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field teams (ProtoBuf.GameMode.TeamInfo)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.scoreColumns != null)
		{
			for (int j = 0; j < instance.scoreColumns.Count; j++)
			{
				ScoreColumn scoreColumn = instance.scoreColumns[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				ScoreColumn.SerializeDelta(stream, scoreColumn, scoreColumn);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.playerScores == null)
		{
			return;
		}
		for (int k = 0; k < instance.playerScores.Count; k++)
		{
			PlayerScore playerScore = instance.playerScores[k];
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			PlayerScore.SerializeDelta(stream, playerScore, playerScore);
			int val2 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val2, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, GameMode instance)
	{
		if (instance.teams != null)
		{
			for (int i = 0; i < instance.teams.Count; i++)
			{
				TeamInfo instance2 = instance.teams[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				TeamInfo.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field teams (ProtoBuf.GameMode.TeamInfo)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.scoreColumns != null)
		{
			for (int j = 0; j < instance.scoreColumns.Count; j++)
			{
				ScoreColumn instance3 = instance.scoreColumns[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				ScoreColumn.Serialize(stream, instance3);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.playerScores == null)
		{
			return;
		}
		for (int k = 0; k < instance.playerScores.Count; k++)
		{
			PlayerScore instance4 = instance.playerScores[k];
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			PlayerScore.Serialize(stream, instance4);
			int val2 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val2, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (teams != null)
		{
			for (int i = 0; i < teams.Count; i++)
			{
				teams[i]?.InspectUids(action);
			}
		}
		if (scoreColumns != null)
		{
			for (int j = 0; j < scoreColumns.Count; j++)
			{
				scoreColumns[j]?.InspectUids(action);
			}
		}
		if (playerScores != null)
		{
			for (int k = 0; k < playerScores.Count; k++)
			{
				playerScores[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ReclaimManager : IDisposable, IPooled, IProto<ReclaimManager>, IProto
{
	public class ReclaimInfo : IDisposable, IPooled, IProto<ReclaimInfo>, IProto
	{
		[NonSerialized]
		public ulong victimID;

		[NonSerialized]
		public ItemContainer mainInventory;

		[NonSerialized]
		public ItemContainer wearInventory;

		[NonSerialized]
		public ItemContainer beltInventory;

		[NonSerialized]
		public ItemContainer backpackInventory;

		[NonSerialized]
		public int reclaimId;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ReclaimInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.victimID = 0uL;
				if (instance.mainInventory != null)
				{
					instance.mainInventory.ResetToPool();
					instance.mainInventory = null;
				}
				if (instance.wearInventory != null)
				{
					instance.wearInventory.ResetToPool();
					instance.wearInventory = null;
				}
				if (instance.beltInventory != null)
				{
					instance.beltInventory.ResetToPool();
					instance.beltInventory = null;
				}
				if (instance.backpackInventory != null)
				{
					instance.backpackInventory.ResetToPool();
					instance.backpackInventory = null;
				}
				instance.reclaimId = 0;
				Pool.Free<ReclaimInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ReclaimInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ReclaimInfo instance)
		{
			instance.victimID = victimID;
			if (mainInventory != null)
			{
				if (instance.mainInventory == null)
				{
					instance.mainInventory = mainInventory.Copy();
				}
				else
				{
					mainInventory.CopyTo(instance.mainInventory);
				}
			}
			else
			{
				instance.mainInventory = null;
			}
			if (wearInventory != null)
			{
				if (instance.wearInventory == null)
				{
					instance.wearInventory = wearInventory.Copy();
				}
				else
				{
					wearInventory.CopyTo(instance.wearInventory);
				}
			}
			else
			{
				instance.wearInventory = null;
			}
			if (beltInventory != null)
			{
				if (instance.beltInventory == null)
				{
					instance.beltInventory = beltInventory.Copy();
				}
				else
				{
					beltInventory.CopyTo(instance.beltInventory);
				}
			}
			else
			{
				instance.beltInventory = null;
			}
			if (backpackInventory != null)
			{
				if (instance.backpackInventory == null)
				{
					instance.backpackInventory = backpackInventory.Copy();
				}
				else
				{
					backpackInventory.CopyTo(instance.backpackInventory);
				}
			}
			else
			{
				instance.backpackInventory = null;
			}
			instance.reclaimId = reclaimId;
		}

		public ReclaimInfo Copy()
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			CopyTo(reclaimInfo);
			return reclaimInfo;
		}

		public static ReclaimInfo Deserialize(BufferStream stream)
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			Deserialize(stream, reclaimInfo, isDelta: false);
			return reclaimInfo;
		}

		public static ReclaimInfo DeserializeLengthDelimited(BufferStream stream)
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			DeserializeLengthDelimited(stream, reclaimInfo, isDelta: false);
			return reclaimInfo;
		}

		public static ReclaimInfo DeserializeLength(BufferStream stream, int length)
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			DeserializeLength(stream, length, reclaimInfo, isDelta: false);
			return reclaimInfo;
		}

		public static ReclaimInfo Deserialize(byte[] buffer)
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, reclaimInfo, isDelta: false);
			return reclaimInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ReclaimInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ReclaimInfo Deserialize(BufferStream stream, ReclaimInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.victimID = ProtocolParser.ReadUInt64(stream);
					break;
				case 34:
					if (instance.mainInventory == null)
					{
						instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
					}
					break;
				case 42:
					if (instance.wearInventory == null)
					{
						instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
					}
					break;
				case 50:
					if (instance.beltInventory == null)
					{
						instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
					}
					break;
				case 58:
					if (instance.backpackInventory == null)
					{
						instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
					}
					break;
				case 64:
					instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
				case 0:
					return instance;
				}
			}
		}

		public static ReclaimInfo DeserializeLengthDelimited(BufferStream stream, ReclaimInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.victimID = ProtocolParser.ReadUInt64(stream);
					break;
				case 34:
					if (instance.mainInventory == null)
					{
						instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
					}
					break;
				case 42:
					if (instance.wearInventory == null)
					{
						instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
					}
					break;
				case 50:
					if (instance.beltInventory == null)
					{
						instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
					}
					break;
				case 58:
					if (instance.backpackInventory == null)
					{
						instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
					}
					break;
				case 64:
					instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ReclaimInfo DeserializeLength(BufferStream stream, int length, ReclaimInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.victimID = ProtocolParser.ReadUInt64(stream);
					break;
				case 34:
					if (instance.mainInventory == null)
					{
						instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
					}
					break;
				case 42:
					if (instance.wearInventory == null)
					{
						instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
					}
					break;
				case 50:
					if (instance.beltInventory == null)
					{
						instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
					}
					break;
				case 58:
					if (instance.backpackInventory == null)
					{
						instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
					}
					break;
				case 64:
					instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ReclaimInfo instance, ReclaimInfo previous)
		{
			if (instance.victimID != previous.victimID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.victimID);
			}
			if (instance.mainInventory == null)
			{
				throw new ArgumentNullException("mainInventory", "Required by proto specification.");
			}
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.mainInventory, previous.mainInventory);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
			if (instance.wearInventory == null)
			{
				throw new ArgumentNullException("wearInventory", "Required by proto specification.");
			}
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.wearInventory, previous.wearInventory);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
			if (instance.beltInventory == null)
			{
				throw new ArgumentNullException("beltInventory", "Required by proto specification.");
			}
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.beltInventory, previous.beltInventory);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
			if (instance.backpackInventory == null)
			{
				throw new ArgumentNullException("backpackInventory", "Required by proto specification.");
			}
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.backpackInventory, previous.backpackInventory);
			int val4 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
			if (instance.reclaimId != previous.reclaimId)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.reclaimId);
			}
		}

		public static void Serialize(BufferStream stream, ReclaimInfo instance)
		{
			if (instance.victimID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.victimID);
			}
			if (instance.mainInventory == null)
			{
				throw new ArgumentNullException("mainInventory", "Required by proto specification.");
			}
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance.mainInventory);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
			if (instance.wearInventory == null)
			{
				throw new ArgumentNullException("wearInventory", "Required by proto specification.");
			}
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.Serialize(stream, instance.wearInventory);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
			if (instance.beltInventory == null)
			{
				throw new ArgumentNullException("beltInventory", "Required by proto specification.");
			}
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			ItemContainer.Serialize(stream, instance.beltInventory);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
			if (instance.backpackInventory == null)
			{
				throw new ArgumentNullException("backpackInventory", "Required by proto specification.");
			}
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			ItemContainer.Serialize(stream, instance.backpackInventory);
			int val4 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
			if (instance.reclaimId != 0)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.reclaimId);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			mainInventory?.InspectUids(action);
			wearInventory?.InspectUids(action);
			beltInventory?.InspectUids(action);
			backpackInventory?.InspectUids(action);
		}
	}

	[NonSerialized]
	public List<ReclaimInfo> reclaimEntries;

	[NonSerialized]
	public int lastReclaimID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ReclaimManager instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.reclaimEntries != null)
		{
			for (int i = 0; i < instance.reclaimEntries.Count; i++)
			{
				if (instance.reclaimEntries[i] != null)
				{
					instance.reclaimEntries[i].ResetToPool();
					instance.reclaimEntries[i] = null;
				}
			}
			List<ReclaimInfo> list = instance.reclaimEntries;
			Pool.Free<ReclaimInfo>(ref list, false);
			instance.reclaimEntries = list;
		}
		instance.lastReclaimID = 0;
		Pool.Free<ReclaimManager>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ReclaimManager with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ReclaimManager instance)
	{
		if (reclaimEntries != null)
		{
			instance.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
			for (int i = 0; i < reclaimEntries.Count; i++)
			{
				ReclaimInfo item = reclaimEntries[i].Copy();
				instance.reclaimEntries.Add(item);
			}
		}
		else
		{
			instance.reclaimEntries = null;
		}
		instance.lastReclaimID = lastReclaimID;
	}

	public ReclaimManager Copy()
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		CopyTo(reclaimManager);
		return reclaimManager;
	}

	public static ReclaimManager Deserialize(BufferStream stream)
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		Deserialize(stream, reclaimManager, isDelta: false);
		return reclaimManager;
	}

	public static ReclaimManager DeserializeLengthDelimited(BufferStream stream)
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		DeserializeLengthDelimited(stream, reclaimManager, isDelta: false);
		return reclaimManager;
	}

	public static ReclaimManager DeserializeLength(BufferStream stream, int length)
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		DeserializeLength(stream, length, reclaimManager, isDelta: false);
		return reclaimManager;
	}

	public static ReclaimManager Deserialize(byte[] buffer)
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, reclaimManager, isDelta: false);
		return reclaimManager;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ReclaimManager previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ReclaimManager Deserialize(BufferStream stream, ReclaimManager instance, bool isDelta)
	{
		if (!isDelta && instance.reclaimEntries == null)
		{
			instance.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.reclaimEntries.Add(ReclaimInfo.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lastReclaimID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ReclaimManager DeserializeLengthDelimited(BufferStream stream, ReclaimManager instance, bool isDelta)
	{
		if (!isDelta && instance.reclaimEntries == null)
		{
			instance.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.reclaimEntries.Add(ReclaimInfo.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lastReclaimID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ReclaimManager DeserializeLength(BufferStream stream, int length, ReclaimManager instance, bool isDelta)
	{
		if (!isDelta && instance.reclaimEntries == null)
		{
			instance.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.reclaimEntries.Add(ReclaimInfo.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lastReclaimID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ReclaimManager instance, ReclaimManager previous)
	{
		if (instance.reclaimEntries != null)
		{
			for (int i = 0; i < instance.reclaimEntries.Count; i++)
			{
				ReclaimInfo reclaimInfo = instance.reclaimEntries[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ReclaimInfo.SerializeDelta(stream, reclaimInfo, reclaimInfo);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.lastReclaimID != previous.lastReclaimID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastReclaimID);
		}
	}

	public static void Serialize(BufferStream stream, ReclaimManager instance)
	{
		if (instance.reclaimEntries != null)
		{
			for (int i = 0; i < instance.reclaimEntries.Count; i++)
			{
				ReclaimInfo instance2 = instance.reclaimEntries[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ReclaimInfo.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.lastReclaimID != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastReclaimID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (reclaimEntries != null)
		{
			for (int i = 0; i < reclaimEntries.Count; i++)
			{
				reclaimEntries[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ReclaimTerminal : IDisposable, IPooled, IProto<ReclaimTerminal>, IProto
{
	[NonSerialized]
	public int itemCount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ReclaimTerminal instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemCount = 0;
			Pool.Free<ReclaimTerminal>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ReclaimTerminal with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ReclaimTerminal instance)
	{
		instance.itemCount = itemCount;
	}

	public ReclaimTerminal Copy()
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		CopyTo(reclaimTerminal);
		return reclaimTerminal;
	}

	public static ReclaimTerminal Deserialize(BufferStream stream)
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		Deserialize(stream, reclaimTerminal, isDelta: false);
		return reclaimTerminal;
	}

	public static ReclaimTerminal DeserializeLengthDelimited(BufferStream stream)
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		DeserializeLengthDelimited(stream, reclaimTerminal, isDelta: false);
		return reclaimTerminal;
	}

	public static ReclaimTerminal DeserializeLength(BufferStream stream, int length)
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		DeserializeLength(stream, length, reclaimTerminal, isDelta: false);
		return reclaimTerminal;
	}

	public static ReclaimTerminal Deserialize(byte[] buffer)
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, reclaimTerminal, isDelta: false);
		return reclaimTerminal;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ReclaimTerminal previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ReclaimTerminal Deserialize(BufferStream stream, ReclaimTerminal instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ReclaimTerminal DeserializeLengthDelimited(BufferStream stream, ReclaimTerminal instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ReclaimTerminal DeserializeLength(BufferStream stream, int length, ReclaimTerminal instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ReclaimTerminal instance, ReclaimTerminal previous)
	{
		if (instance.itemCount != previous.itemCount)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCount);
		}
	}

	public static void Serialize(BufferStream stream, ReclaimTerminal instance)
	{
		if (instance.itemCount != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SlotMachine : IDisposable, IPooled, IProto<SlotMachine>, IProto
{
	[NonSerialized]
	public int oldResult1;

	[NonSerialized]
	public int oldResult2;

	[NonSerialized]
	public int oldResult3;

	[NonSerialized]
	public int newResult1;

	[NonSerialized]
	public int newResult2;

	[NonSerialized]
	public int newResult3;

	[NonSerialized]
	public bool isSpinning;

	[NonSerialized]
	public float spinTime;

	[NonSerialized]
	public NetworkableId storageID;

	[NonSerialized]
	public int multiplier;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SlotMachine instance)
	{
		if (instance.ShouldPool)
		{
			instance.oldResult1 = 0;
			instance.oldResult2 = 0;
			instance.oldResult3 = 0;
			instance.newResult1 = 0;
			instance.newResult2 = 0;
			instance.newResult3 = 0;
			instance.isSpinning = false;
			instance.spinTime = 0f;
			instance.storageID = default(NetworkableId);
			instance.multiplier = 0;
			Pool.Free<SlotMachine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SlotMachine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SlotMachine instance)
	{
		instance.oldResult1 = oldResult1;
		instance.oldResult2 = oldResult2;
		instance.oldResult3 = oldResult3;
		instance.newResult1 = newResult1;
		instance.newResult2 = newResult2;
		instance.newResult3 = newResult3;
		instance.isSpinning = isSpinning;
		instance.spinTime = spinTime;
		instance.storageID = storageID;
		instance.multiplier = multiplier;
	}

	public SlotMachine Copy()
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		CopyTo(slotMachine);
		return slotMachine;
	}

	public static SlotMachine Deserialize(BufferStream stream)
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		Deserialize(stream, slotMachine, isDelta: false);
		return slotMachine;
	}

	public static SlotMachine DeserializeLengthDelimited(BufferStream stream)
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		DeserializeLengthDelimited(stream, slotMachine, isDelta: false);
		return slotMachine;
	}

	public static SlotMachine DeserializeLength(BufferStream stream, int length)
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		DeserializeLength(stream, length, slotMachine, isDelta: false);
		return slotMachine;
	}

	public static SlotMachine Deserialize(byte[] buffer)
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, slotMachine, isDelta: false);
		return slotMachine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SlotMachine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SlotMachine Deserialize(BufferStream stream, SlotMachine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.oldResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oldResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.oldResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.newResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.newResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.newResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isSpinning = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.spinTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 80:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SlotMachine DeserializeLengthDelimited(BufferStream stream, SlotMachine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.oldResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oldResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.oldResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.newResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.newResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.newResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isSpinning = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.spinTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 80:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SlotMachine DeserializeLength(BufferStream stream, int length, SlotMachine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.oldResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oldResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.oldResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.newResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.newResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.newResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isSpinning = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.spinTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 80:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SlotMachine instance, SlotMachine previous)
	{
		if (instance.oldResult1 != previous.oldResult1)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult1);
		}
		if (instance.oldResult2 != previous.oldResult2)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult2);
		}
		if (instance.oldResult3 != previous.oldResult3)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult3);
		}
		if (instance.newResult1 != previous.newResult1)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult1);
		}
		if (instance.newResult2 != previous.newResult2)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult2);
		}
		if (instance.newResult3 != previous.newResult3)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult3);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.isSpinning);
		if (instance.spinTime != previous.spinTime)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.spinTime);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		if (instance.multiplier != previous.multiplier)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
	}

	public static void Serialize(BufferStream stream, SlotMachine instance)
	{
		if (instance.oldResult1 != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult1);
		}
		if (instance.oldResult2 != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult2);
		}
		if (instance.oldResult3 != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult3);
		}
		if (instance.newResult1 != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult1);
		}
		if (instance.newResult2 != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult2);
		}
		if (instance.newResult3 != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult3);
		}
		if (instance.isSpinning)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isSpinning);
		}
		if (instance.spinTime != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.spinTime);
		}
		if (instance.storageID != default(NetworkableId))
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		}
		if (instance.multiplier != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref storageID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CardGame : IDisposable, IPooled, IProto<CardGame>, IProto
{
	public class CardPlayer : IDisposable, IPooled, IProto<CardPlayer>, IProto
	{
		[NonSerialized]
		public ulong userid;

		[NonSerialized]
		public List<int> cards;

		[NonSerialized]
		public int scrap;

		[NonSerialized]
		public int state;

		[NonSerialized]
		public int availableInputs;

		[NonSerialized]
		public int betThisRound;

		[NonSerialized]
		public int betThisTurn;

		[NonSerialized]
		public bool leftRoundEarly;

		[NonSerialized]
		public bool sendCardDetails;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(CardPlayer instance)
		{
			if (instance.ShouldPool)
			{
				instance.userid = 0uL;
				if (instance.cards != null)
				{
					List<int> list = instance.cards;
					Pool.FreeUnmanaged<int>(ref list);
					instance.cards = list;
				}
				instance.scrap = 0;
				instance.state = 0;
				instance.availableInputs = 0;
				instance.betThisRound = 0;
				instance.betThisTurn = 0;
				instance.leftRoundEarly = false;
				instance.sendCardDetails = false;
				Pool.Free<CardPlayer>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose CardPlayer with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(CardPlayer instance)
		{
			instance.userid = userid;
			if (cards != null)
			{
				instance.cards = Pool.Get<List<int>>();
				for (int i = 0; i < cards.Count; i++)
				{
					int item = cards[i];
					instance.cards.Add(item);
				}
			}
			else
			{
				instance.cards = null;
			}
			instance.scrap = scrap;
			instance.state = state;
			instance.availableInputs = availableInputs;
			instance.betThisRound = betThisRound;
			instance.betThisTurn = betThisTurn;
			instance.leftRoundEarly = leftRoundEarly;
			instance.sendCardDetails = sendCardDetails;
		}

		public CardPlayer Copy()
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			CopyTo(cardPlayer);
			return cardPlayer;
		}

		public static CardPlayer Deserialize(BufferStream stream)
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			Deserialize(stream, cardPlayer, isDelta: false);
			return cardPlayer;
		}

		public static CardPlayer DeserializeLengthDelimited(BufferStream stream)
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			DeserializeLengthDelimited(stream, cardPlayer, isDelta: false);
			return cardPlayer;
		}

		public static CardPlayer DeserializeLength(BufferStream stream, int length)
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			DeserializeLength(stream, length, cardPlayer, isDelta: false);
			return cardPlayer;
		}

		public static CardPlayer Deserialize(byte[] buffer)
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, cardPlayer, isDelta: false);
			return cardPlayer;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, CardPlayer previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static CardPlayer Deserialize(BufferStream stream, CardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.state = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 64:
					instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.sendCardDetails = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static CardPlayer DeserializeLengthDelimited(BufferStream stream, CardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.state = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 64:
					instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.sendCardDetails = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static CardPlayer DeserializeLength(BufferStream stream, int length, CardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.state = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 64:
					instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.sendCardDetails = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, CardPlayer instance, CardPlayer previous)
		{
			if (instance.userid != previous.userid)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.cards != null)
			{
				for (int i = 0; i < instance.cards.Count; i++)
				{
					int num = instance.cards[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.scrap != previous.scrap)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.scrap);
			}
			if (instance.state != previous.state)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
			}
			if (instance.availableInputs != previous.availableInputs)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.availableInputs);
			}
			if (instance.betThisRound != previous.betThisRound)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisRound);
			}
			if (instance.betThisTurn != previous.betThisTurn)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisTurn);
			}
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.leftRoundEarly);
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.sendCardDetails);
		}

		public static void Serialize(BufferStream stream, CardPlayer instance)
		{
			if (instance.userid != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.cards != null)
			{
				for (int i = 0; i < instance.cards.Count; i++)
				{
					int num = instance.cards[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.scrap != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.scrap);
			}
			if (instance.state != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
			}
			if (instance.availableInputs != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.availableInputs);
			}
			if (instance.betThisRound != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisRound);
			}
			if (instance.betThisTurn != 0)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisTurn);
			}
			if (instance.leftRoundEarly)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteBool(stream, instance.leftRoundEarly);
			}
			if (instance.sendCardDetails)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteBool(stream, instance.sendCardDetails);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class TexasHoldEm : IDisposable, IPooled, IProto<TexasHoldEm>, IProto
	{
		[NonSerialized]
		public int dealerIndex;

		[NonSerialized]
		public List<int> communityCards;

		[NonSerialized]
		public int biggestRaiseThisTurn;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(TexasHoldEm instance)
		{
			if (instance.ShouldPool)
			{
				instance.dealerIndex = 0;
				if (instance.communityCards != null)
				{
					List<int> list = instance.communityCards;
					Pool.FreeUnmanaged<int>(ref list);
					instance.communityCards = list;
				}
				instance.biggestRaiseThisTurn = 0;
				Pool.Free<TexasHoldEm>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose TexasHoldEm with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(TexasHoldEm instance)
		{
			instance.dealerIndex = dealerIndex;
			if (communityCards != null)
			{
				instance.communityCards = Pool.Get<List<int>>();
				for (int i = 0; i < communityCards.Count; i++)
				{
					int item = communityCards[i];
					instance.communityCards.Add(item);
				}
			}
			else
			{
				instance.communityCards = null;
			}
			instance.biggestRaiseThisTurn = biggestRaiseThisTurn;
		}

		public TexasHoldEm Copy()
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			CopyTo(texasHoldEm);
			return texasHoldEm;
		}

		public static TexasHoldEm Deserialize(BufferStream stream)
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			Deserialize(stream, texasHoldEm, isDelta: false);
			return texasHoldEm;
		}

		public static TexasHoldEm DeserializeLengthDelimited(BufferStream stream)
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			DeserializeLengthDelimited(stream, texasHoldEm, isDelta: false);
			return texasHoldEm;
		}

		public static TexasHoldEm DeserializeLength(BufferStream stream, int length)
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			DeserializeLength(stream, length, texasHoldEm, isDelta: false);
			return texasHoldEm;
		}

		public static TexasHoldEm Deserialize(byte[] buffer)
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, texasHoldEm, isDelta: false);
			return texasHoldEm;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, TexasHoldEm previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static TexasHoldEm Deserialize(BufferStream stream, TexasHoldEm instance, bool isDelta)
		{
			if (!isDelta && instance.communityCards == null)
			{
				instance.communityCards = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static TexasHoldEm DeserializeLengthDelimited(BufferStream stream, TexasHoldEm instance, bool isDelta)
		{
			if (!isDelta && instance.communityCards == null)
			{
				instance.communityCards = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static TexasHoldEm DeserializeLength(BufferStream stream, int length, TexasHoldEm instance, bool isDelta)
		{
			if (!isDelta && instance.communityCards == null)
			{
				instance.communityCards = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, TexasHoldEm instance, TexasHoldEm previous)
		{
			if (instance.dealerIndex != previous.dealerIndex)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.dealerIndex);
			}
			if (instance.communityCards != null)
			{
				for (int i = 0; i < instance.communityCards.Count; i++)
				{
					int num = instance.communityCards[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.biggestRaiseThisTurn != previous.biggestRaiseThisTurn)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.biggestRaiseThisTurn);
			}
		}

		public static void Serialize(BufferStream stream, TexasHoldEm instance)
		{
			if (instance.dealerIndex != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.dealerIndex);
			}
			if (instance.communityCards != null)
			{
				for (int i = 0; i < instance.communityCards.Count; i++)
				{
					int num = instance.communityCards[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.biggestRaiseThisTurn != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.biggestRaiseThisTurn);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class RoundResults : IDisposable, IPooled, IProto<RoundResults>, IProto
	{
		public class Result : IDisposable, IPooled, IProto<Result>, IProto
		{
			[NonSerialized]
			public ulong ID;

			[NonSerialized]
			public int winnings;

			[NonSerialized]
			public int resultCode;

			public bool ShouldPool = true;

			private bool _disposed;

			public static void ResetToPool(Result instance)
			{
				if (instance.ShouldPool)
				{
					instance.ID = 0uL;
					instance.winnings = 0;
					instance.resultCode = 0;
					Pool.Free<Result>(ref instance);
				}
			}

			public void ResetToPool()
			{
				ResetToPool(this);
			}

			public virtual void Dispose()
			{
				if (!ShouldPool)
				{
					throw new Exception("Trying to dispose Result with ShouldPool set to false!");
				}
				if (!_disposed)
				{
					ResetToPool();
					_disposed = true;
				}
			}

			public virtual void EnterPool()
			{
				_disposed = true;
			}

			public virtual void LeavePool()
			{
				_disposed = false;
			}

			public void CopyTo(Result instance)
			{
				instance.ID = ID;
				instance.winnings = winnings;
				instance.resultCode = resultCode;
			}

			public Result Copy()
			{
				Result result = Pool.Get<Result>();
				CopyTo(result);
				return result;
			}

			public static Result Deserialize(BufferStream stream)
			{
				Result result = Pool.Get<Result>();
				Deserialize(stream, result, isDelta: false);
				return result;
			}

			public static Result DeserializeLengthDelimited(BufferStream stream)
			{
				Result result = Pool.Get<Result>();
				DeserializeLengthDelimited(stream, result, isDelta: false);
				return result;
			}

			public static Result DeserializeLength(BufferStream stream, int length)
			{
				Result result = Pool.Get<Result>();
				DeserializeLength(stream, length, result, isDelta: false);
				return result;
			}

			public static Result Deserialize(byte[] buffer)
			{
				Result result = Pool.Get<Result>();
				using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
				Deserialize(stream, result, isDelta: false);
				return result;
			}

			public void FromProto(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void WriteToStream(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public virtual void WriteToStreamDelta(BufferStream stream, Result previous)
			{
				if (previous == null)
				{
					Serialize(stream, this);
				}
				else
				{
					SerializeDelta(stream, this, previous);
				}
			}

			public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
			{
				DeserializeLength(stream, size, this, isDelta);
			}

			public static Result Deserialize(BufferStream stream, Result instance, bool isDelta)
			{
				while (true)
				{
					int num = stream.ReadByte();
					switch (num)
					{
					case 8:
						instance.ID = ProtocolParser.ReadUInt64(stream);
						continue;
					case 16:
						instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					case 24:
						instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					case -1:
					case 0:
						return instance;
					}
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
			}

			public static Result DeserializeLengthDelimited(BufferStream stream, Result instance, bool isDelta)
			{
				long num = ProtocolParser.ReadUInt32(stream);
				num += stream.Position;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 8:
						instance.ID = ProtocolParser.ReadUInt64(stream);
						continue;
					case 16:
						instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					case 24:
						instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static Result DeserializeLength(BufferStream stream, int length, Result instance, bool isDelta)
			{
				long num = stream.Position + length;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 8:
						instance.ID = ProtocolParser.ReadUInt64(stream);
						continue;
					case 16:
						instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					case 24:
						instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static void SerializeDelta(BufferStream stream, Result instance, Result previous)
			{
				if (instance.ID != previous.ID)
				{
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, instance.ID);
				}
				if (instance.winnings != previous.winnings)
				{
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
				}
				if (instance.resultCode != previous.resultCode)
				{
					stream.WriteByte(24);
					ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
				}
			}

			public static void Serialize(BufferStream stream, Result instance)
			{
				if (instance.ID != 0L)
				{
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, instance.ID);
				}
				if (instance.winnings != 0)
				{
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
				}
				if (instance.resultCode != 0)
				{
					stream.WriteByte(24);
					ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
				}
			}

			public void ToProto(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public void InspectUids(UidInspector<ulong> action)
			{
			}
		}

		[NonSerialized]
		public List<Result> results;

		[NonSerialized]
		public int winningScore;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(RoundResults instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.results != null)
			{
				for (int i = 0; i < instance.results.Count; i++)
				{
					if (instance.results[i] != null)
					{
						instance.results[i].ResetToPool();
						instance.results[i] = null;
					}
				}
				List<Result> list = instance.results;
				Pool.Free<Result>(ref list, false);
				instance.results = list;
			}
			instance.winningScore = 0;
			Pool.Free<RoundResults>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose RoundResults with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(RoundResults instance)
		{
			if (results != null)
			{
				instance.results = Pool.Get<List<Result>>();
				for (int i = 0; i < results.Count; i++)
				{
					Result item = results[i].Copy();
					instance.results.Add(item);
				}
			}
			else
			{
				instance.results = null;
			}
			instance.winningScore = winningScore;
		}

		public RoundResults Copy()
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			CopyTo(roundResults);
			return roundResults;
		}

		public static RoundResults Deserialize(BufferStream stream)
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			Deserialize(stream, roundResults, isDelta: false);
			return roundResults;
		}

		public static RoundResults DeserializeLengthDelimited(BufferStream stream)
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			DeserializeLengthDelimited(stream, roundResults, isDelta: false);
			return roundResults;
		}

		public static RoundResults DeserializeLength(BufferStream stream, int length)
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			DeserializeLength(stream, length, roundResults, isDelta: false);
			return roundResults;
		}

		public static RoundResults Deserialize(byte[] buffer)
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, roundResults, isDelta: false);
			return roundResults;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, RoundResults previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static RoundResults Deserialize(BufferStream stream, RoundResults instance, bool isDelta)
		{
			if (!isDelta && instance.results == null)
			{
				instance.results = Pool.Get<List<Result>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.results.Add(Result.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static RoundResults DeserializeLengthDelimited(BufferStream stream, RoundResults instance, bool isDelta)
		{
			if (!isDelta && instance.results == null)
			{
				instance.results = Pool.Get<List<Result>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.results.Add(Result.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static RoundResults DeserializeLength(BufferStream stream, int length, RoundResults instance, bool isDelta)
		{
			if (!isDelta && instance.results == null)
			{
				instance.results = Pool.Get<List<Result>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.results.Add(Result.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, RoundResults instance, RoundResults previous)
		{
			if (instance.results != null)
			{
				for (int i = 0; i < instance.results.Count; i++)
				{
					Result result = instance.results[i];
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Result.SerializeDelta(stream, result, result);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field results (ProtoBuf.CardGame.RoundResults.Result)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.winningScore != previous.winningScore)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.winningScore);
			}
		}

		public static void Serialize(BufferStream stream, RoundResults instance)
		{
			if (instance.results != null)
			{
				for (int i = 0; i < instance.results.Count; i++)
				{
					Result instance2 = instance.results[i];
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Result.Serialize(stream, instance2);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field results (ProtoBuf.CardGame.RoundResults.Result)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.winningScore != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.winningScore);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (results != null)
			{
				for (int i = 0; i < results.Count; i++)
				{
					results[i]?.InspectUids(action);
				}
			}
		}
	}

	public class Blackjack : IDisposable, IPooled, IProto<Blackjack>, IProto
	{
		[NonSerialized]
		public List<int> dealerCards;

		[NonSerialized]
		public List<BlackjackCardPlayer> players;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Blackjack instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.dealerCards != null)
			{
				List<int> list = instance.dealerCards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.dealerCards = list;
			}
			if (instance.players != null)
			{
				for (int i = 0; i < instance.players.Count; i++)
				{
					if (instance.players[i] != null)
					{
						instance.players[i].ResetToPool();
						instance.players[i] = null;
					}
				}
				List<BlackjackCardPlayer> list2 = instance.players;
				Pool.Free<BlackjackCardPlayer>(ref list2, false);
				instance.players = list2;
			}
			Pool.Free<Blackjack>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Blackjack with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Blackjack instance)
		{
			if (dealerCards != null)
			{
				instance.dealerCards = Pool.Get<List<int>>();
				for (int i = 0; i < dealerCards.Count; i++)
				{
					int item = dealerCards[i];
					instance.dealerCards.Add(item);
				}
			}
			else
			{
				instance.dealerCards = null;
			}
			if (players != null)
			{
				instance.players = Pool.Get<List<BlackjackCardPlayer>>();
				for (int j = 0; j < players.Count; j++)
				{
					BlackjackCardPlayer item2 = players[j].Copy();
					instance.players.Add(item2);
				}
			}
			else
			{
				instance.players = null;
			}
		}

		public Blackjack Copy()
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			CopyTo(blackjack);
			return blackjack;
		}

		public static Blackjack Deserialize(BufferStream stream)
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			Deserialize(stream, blackjack, isDelta: false);
			return blackjack;
		}

		public static Blackjack DeserializeLengthDelimited(BufferStream stream)
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			DeserializeLengthDelimited(stream, blackjack, isDelta: false);
			return blackjack;
		}

		public static Blackjack DeserializeLength(BufferStream stream, int length)
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			DeserializeLength(stream, length, blackjack, isDelta: false);
			return blackjack;
		}

		public static Blackjack Deserialize(byte[] buffer)
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, blackjack, isDelta: false);
			return blackjack;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Blackjack previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Blackjack Deserialize(BufferStream stream, Blackjack instance, bool isDelta)
		{
			if (!isDelta)
			{
				if (instance.dealerCards == null)
				{
					instance.dealerCards = Pool.Get<List<int>>();
				}
				if (instance.players == null)
				{
					instance.players = Pool.Get<List<BlackjackCardPlayer>>();
				}
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Blackjack DeserializeLengthDelimited(BufferStream stream, Blackjack instance, bool isDelta)
		{
			if (!isDelta)
			{
				if (instance.dealerCards == null)
				{
					instance.dealerCards = Pool.Get<List<int>>();
				}
				if (instance.players == null)
				{
					instance.players = Pool.Get<List<BlackjackCardPlayer>>();
				}
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Blackjack DeserializeLength(BufferStream stream, int length, Blackjack instance, bool isDelta)
		{
			if (!isDelta)
			{
				if (instance.dealerCards == null)
				{
					instance.dealerCards = Pool.Get<List<int>>();
				}
				if (instance.players == null)
				{
					instance.players = Pool.Get<List<BlackjackCardPlayer>>();
				}
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Blackjack instance, Blackjack previous)
		{
			if (instance.dealerCards != null)
			{
				for (int i = 0; i < instance.dealerCards.Count; i++)
				{
					int num = instance.dealerCards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.players == null)
			{
				return;
			}
			for (int j = 0; j < instance.players.Count; j++)
			{
				BlackjackCardPlayer blackjackCardPlayer = instance.players[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				BlackjackCardPlayer.SerializeDelta(stream, blackjackCardPlayer, blackjackCardPlayer);
				int num2 = stream.Position - position;
				if (num2 > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.BlackjackCardPlayer)");
				}
				Span<byte> span = range.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
				if (num3 < 3)
				{
					span[num3 - 1] |= 128;
					while (num3 < 2)
					{
						span[num3++] = 128;
					}
					span[2] = 0;
				}
			}
		}

		public static void Serialize(BufferStream stream, Blackjack instance)
		{
			if (instance.dealerCards != null)
			{
				for (int i = 0; i < instance.dealerCards.Count; i++)
				{
					int num = instance.dealerCards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.players == null)
			{
				return;
			}
			for (int j = 0; j < instance.players.Count; j++)
			{
				BlackjackCardPlayer instance2 = instance.players[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				BlackjackCardPlayer.Serialize(stream, instance2);
				int num2 = stream.Position - position;
				if (num2 > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.BlackjackCardPlayer)");
				}
				Span<byte> span = range.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
				if (num3 < 3)
				{
					span[num3 - 1] |= 128;
					while (num3 < 2)
					{
						span[num3++] = 128;
					}
					span[2] = 0;
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (players != null)
			{
				for (int i = 0; i < players.Count; i++)
				{
					players[i]?.InspectUids(action);
				}
			}
		}
	}

	public class BlackjackCardPlayer : IDisposable, IPooled, IProto<BlackjackCardPlayer>, IProto
	{
		[NonSerialized]
		public List<int> splitCards;

		[NonSerialized]
		public int splitBetThisRound;

		[NonSerialized]
		public int insuranceBetThisRound;

		[NonSerialized]
		public bool playingSplitCards;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(BlackjackCardPlayer instance)
		{
			if (instance.ShouldPool)
			{
				if (instance.splitCards != null)
				{
					List<int> list = instance.splitCards;
					Pool.FreeUnmanaged<int>(ref list);
					instance.splitCards = list;
				}
				instance.splitBetThisRound = 0;
				instance.insuranceBetThisRound = 0;
				instance.playingSplitCards = false;
				Pool.Free<BlackjackCardPlayer>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose BlackjackCardPlayer with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(BlackjackCardPlayer instance)
		{
			if (splitCards != null)
			{
				instance.splitCards = Pool.Get<List<int>>();
				for (int i = 0; i < splitCards.Count; i++)
				{
					int item = splitCards[i];
					instance.splitCards.Add(item);
				}
			}
			else
			{
				instance.splitCards = null;
			}
			instance.splitBetThisRound = splitBetThisRound;
			instance.insuranceBetThisRound = insuranceBetThisRound;
			instance.playingSplitCards = playingSplitCards;
		}

		public BlackjackCardPlayer Copy()
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			CopyTo(blackjackCardPlayer);
			return blackjackCardPlayer;
		}

		public static BlackjackCardPlayer Deserialize(BufferStream stream)
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			Deserialize(stream, blackjackCardPlayer, isDelta: false);
			return blackjackCardPlayer;
		}

		public static BlackjackCardPlayer DeserializeLengthDelimited(BufferStream stream)
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			DeserializeLengthDelimited(stream, blackjackCardPlayer, isDelta: false);
			return blackjackCardPlayer;
		}

		public static BlackjackCardPlayer DeserializeLength(BufferStream stream, int length)
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			DeserializeLength(stream, length, blackjackCardPlayer, isDelta: false);
			return blackjackCardPlayer;
		}

		public static BlackjackCardPlayer Deserialize(byte[] buffer)
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, blackjackCardPlayer, isDelta: false);
			return blackjackCardPlayer;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, BlackjackCardPlayer previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static BlackjackCardPlayer Deserialize(BufferStream stream, BlackjackCardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.splitCards == null)
			{
				instance.splitCards = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.playingSplitCards = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static BlackjackCardPlayer DeserializeLengthDelimited(BufferStream stream, BlackjackCardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.splitCards == null)
			{
				instance.splitCards = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.playingSplitCards = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static BlackjackCardPlayer DeserializeLength(BufferStream stream, int length, BlackjackCardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.splitCards == null)
			{
				instance.splitCards = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.playingSplitCards = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, BlackjackCardPlayer instance, BlackjackCardPlayer previous)
		{
			if (instance.splitCards != null)
			{
				for (int i = 0; i < instance.splitCards.Count; i++)
				{
					int num = instance.splitCards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.splitBetThisRound != previous.splitBetThisRound)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.splitBetThisRound);
			}
			if (instance.insuranceBetThisRound != previous.insuranceBetThisRound)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.insuranceBetThisRound);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.playingSplitCards);
		}

		public static void Serialize(BufferStream stream, BlackjackCardPlayer instance)
		{
			if (instance.splitCards != null)
			{
				for (int i = 0; i < instance.splitCards.Count; i++)
				{
					int num = instance.splitCards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.splitBetThisRound != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.splitBetThisRound);
			}
			if (instance.insuranceBetThisRound != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.insuranceBetThisRound);
			}
			if (instance.playingSplitCards)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteBool(stream, instance.playingSplitCards);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class CardList : IDisposable, IPooled, IProto<CardList>, IProto
	{
		[NonSerialized]
		public List<int> cards;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(CardList instance)
		{
			if (instance.ShouldPool)
			{
				if (instance.cards != null)
				{
					List<int> list = instance.cards;
					Pool.FreeUnmanaged<int>(ref list);
					instance.cards = list;
				}
				Pool.Free<CardList>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose CardList with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(CardList instance)
		{
			if (cards != null)
			{
				instance.cards = Pool.Get<List<int>>();
				for (int i = 0; i < cards.Count; i++)
				{
					int item = cards[i];
					instance.cards.Add(item);
				}
			}
			else
			{
				instance.cards = null;
			}
		}

		public CardList Copy()
		{
			CardList cardList = Pool.Get<CardList>();
			CopyTo(cardList);
			return cardList;
		}

		public static CardList Deserialize(BufferStream stream)
		{
			CardList cardList = Pool.Get<CardList>();
			Deserialize(stream, cardList, isDelta: false);
			return cardList;
		}

		public static CardList DeserializeLengthDelimited(BufferStream stream)
		{
			CardList cardList = Pool.Get<CardList>();
			DeserializeLengthDelimited(stream, cardList, isDelta: false);
			return cardList;
		}

		public static CardList DeserializeLength(BufferStream stream, int length)
		{
			CardList cardList = Pool.Get<CardList>();
			DeserializeLength(stream, length, cardList, isDelta: false);
			return cardList;
		}

		public static CardList Deserialize(byte[] buffer)
		{
			CardList cardList = Pool.Get<CardList>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, cardList, isDelta: false);
			return cardList;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, CardList previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static CardList Deserialize(BufferStream stream, CardList instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static CardList DeserializeLengthDelimited(BufferStream stream, CardList instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static CardList DeserializeLength(BufferStream stream, int length, CardList instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, CardList instance, CardList previous)
		{
			if (instance.cards != null)
			{
				for (int i = 0; i < instance.cards.Count; i++)
				{
					int num = instance.cards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
		}

		public static void Serialize(BufferStream stream, CardList instance)
		{
			if (instance.cards != null)
			{
				for (int i = 0; i < instance.cards.Count; i++)
				{
					int num = instance.cards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<CardPlayer> players;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public int activePlayerIndex;

	[NonSerialized]
	public int pot;

	[NonSerialized]
	public int lastActionId;

	[NonSerialized]
	public ulong lastActionTarget;

	[NonSerialized]
	public int lastActionValue;

	[NonSerialized]
	public NetworkableId potRef;

	[NonSerialized]
	public TexasHoldEm texasHoldEm;

	[NonSerialized]
	public Blackjack blackjack;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CardGame instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.players != null)
		{
			for (int i = 0; i < instance.players.Count; i++)
			{
				if (instance.players[i] != null)
				{
					instance.players[i].ResetToPool();
					instance.players[i] = null;
				}
			}
			List<CardPlayer> list = instance.players;
			Pool.Free<CardPlayer>(ref list, false);
			instance.players = list;
		}
		instance.state = 0;
		instance.activePlayerIndex = 0;
		instance.pot = 0;
		instance.lastActionId = 0;
		instance.lastActionTarget = 0uL;
		instance.lastActionValue = 0;
		instance.potRef = default(NetworkableId);
		if (instance.texasHoldEm != null)
		{
			instance.texasHoldEm.ResetToPool();
			instance.texasHoldEm = null;
		}
		if (instance.blackjack != null)
		{
			instance.blackjack.ResetToPool();
			instance.blackjack = null;
		}
		Pool.Free<CardGame>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CardGame with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CardGame instance)
	{
		if (players != null)
		{
			instance.players = Pool.Get<List<CardPlayer>>();
			for (int i = 0; i < players.Count; i++)
			{
				CardPlayer item = players[i].Copy();
				instance.players.Add(item);
			}
		}
		else
		{
			instance.players = null;
		}
		instance.state = state;
		instance.activePlayerIndex = activePlayerIndex;
		instance.pot = pot;
		instance.lastActionId = lastActionId;
		instance.lastActionTarget = lastActionTarget;
		instance.lastActionValue = lastActionValue;
		instance.potRef = potRef;
		if (texasHoldEm != null)
		{
			if (instance.texasHoldEm == null)
			{
				instance.texasHoldEm = texasHoldEm.Copy();
			}
			else
			{
				texasHoldEm.CopyTo(instance.texasHoldEm);
			}
		}
		else
		{
			instance.texasHoldEm = null;
		}
		if (blackjack != null)
		{
			if (instance.blackjack == null)
			{
				instance.blackjack = blackjack.Copy();
			}
			else
			{
				blackjack.CopyTo(instance.blackjack);
			}
		}
		else
		{
			instance.blackjack = null;
		}
	}

	public CardGame Copy()
	{
		CardGame cardGame = Pool.Get<CardGame>();
		CopyTo(cardGame);
		return cardGame;
	}

	public static CardGame Deserialize(BufferStream stream)
	{
		CardGame cardGame = Pool.Get<CardGame>();
		Deserialize(stream, cardGame, isDelta: false);
		return cardGame;
	}

	public static CardGame DeserializeLengthDelimited(BufferStream stream)
	{
		CardGame cardGame = Pool.Get<CardGame>();
		DeserializeLengthDelimited(stream, cardGame, isDelta: false);
		return cardGame;
	}

	public static CardGame DeserializeLength(BufferStream stream, int length)
	{
		CardGame cardGame = Pool.Get<CardGame>();
		DeserializeLength(stream, length, cardGame, isDelta: false);
		return cardGame;
	}

	public static CardGame Deserialize(byte[] buffer)
	{
		CardGame cardGame = Pool.Get<CardGame>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cardGame, isDelta: false);
		return cardGame;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CardGame previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CardGame Deserialize(BufferStream stream, CardGame instance, bool isDelta)
	{
		if (!isDelta && instance.players == null)
		{
			instance.players = Pool.Get<List<CardPlayer>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.players.Add(CardPlayer.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.activePlayerIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.pot = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.lastActionId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.lastActionTarget = ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.lastActionValue = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 64:
				instance.potRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 74:
				if (instance.texasHoldEm == null)
				{
					instance.texasHoldEm = TexasHoldEm.DeserializeLengthDelimited(stream);
				}
				else
				{
					TexasHoldEm.DeserializeLengthDelimited(stream, instance.texasHoldEm, isDelta);
				}
				break;
			case 82:
				if (instance.blackjack == null)
				{
					instance.blackjack = Blackjack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Blackjack.DeserializeLengthDelimited(stream, instance.blackjack, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static CardGame DeserializeLengthDelimited(BufferStream stream, CardGame instance, bool isDelta)
	{
		if (!isDelta && instance.players == null)
		{
			instance.players = Pool.Get<List<CardPlayer>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.players.Add(CardPlayer.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.activePlayerIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.pot = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.lastActionId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.lastActionTarget = ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.lastActionValue = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 64:
				instance.potRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 74:
				if (instance.texasHoldEm == null)
				{
					instance.texasHoldEm = TexasHoldEm.DeserializeLengthDelimited(stream);
				}
				else
				{
					TexasHoldEm.DeserializeLengthDelimited(stream, instance.texasHoldEm, isDelta);
				}
				break;
			case 82:
				if (instance.blackjack == null)
				{
					instance.blackjack = Blackjack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Blackjack.DeserializeLengthDelimited(stream, instance.blackjack, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CardGame DeserializeLength(BufferStream stream, int length, CardGame instance, bool isDelta)
	{
		if (!isDelta && instance.players == null)
		{
			instance.players = Pool.Get<List<CardPlayer>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.players.Add(CardPlayer.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.activePlayerIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.pot = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.lastActionId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.lastActionTarget = ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.lastActionValue = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 64:
				instance.potRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 74:
				if (instance.texasHoldEm == null)
				{
					instance.texasHoldEm = TexasHoldEm.DeserializeLengthDelimited(stream);
				}
				else
				{
					TexasHoldEm.DeserializeLengthDelimited(stream, instance.texasHoldEm, isDelta);
				}
				break;
			case 82:
				if (instance.blackjack == null)
				{
					instance.blackjack = Blackjack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Blackjack.DeserializeLengthDelimited(stream, instance.blackjack, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CardGame instance, CardGame previous)
	{
		if (instance.players != null)
		{
			for (int i = 0; i < instance.players.Count; i++)
			{
				CardPlayer cardPlayer = instance.players[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				CardPlayer.SerializeDelta(stream, cardPlayer, cardPlayer);
				int num = stream.Position - position;
				if (num > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.CardPlayer)");
				}
				Span<byte> span = range.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
				if (num2 < 3)
				{
					span[num2 - 1] |= 128;
					while (num2 < 2)
					{
						span[num2++] = 128;
					}
					span[2] = 0;
				}
			}
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.activePlayerIndex != previous.activePlayerIndex)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.activePlayerIndex);
		}
		if (instance.pot != previous.pot)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.pot);
		}
		if (instance.lastActionId != previous.lastActionId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastActionId);
		}
		if (instance.lastActionTarget != previous.lastActionTarget)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.lastActionTarget);
		}
		if (instance.lastActionValue != previous.lastActionValue)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastActionValue);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.potRef.Value);
		if (instance.texasHoldEm != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(3);
			int position2 = stream.Position;
			TexasHoldEm.SerializeDelta(stream, instance.texasHoldEm, previous.texasHoldEm);
			int num3 = stream.Position - position2;
			if (num3 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field texasHoldEm (ProtoBuf.CardGame.TexasHoldEm)");
			}
			Span<byte> span2 = range2.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)num3, span2, 0);
			if (num4 < 3)
			{
				span2[num4 - 1] |= 128;
				while (num4 < 2)
				{
					span2[num4++] = 128;
				}
				span2[2] = 0;
			}
		}
		if (instance.blackjack == null)
		{
			return;
		}
		stream.WriteByte(82);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		Blackjack.SerializeDelta(stream, instance.blackjack, previous.blackjack);
		int num5 = stream.Position - position3;
		if (num5 > int.MaxValue)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field blackjack (ProtoBuf.CardGame.Blackjack)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num6 = ProtocolParser.WriteUInt32((uint)num5, span3, 0);
		if (num6 < 5)
		{
			span3[num6 - 1] |= 128;
			while (num6 < 4)
			{
				span3[num6++] = 128;
			}
			span3[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, CardGame instance)
	{
		if (instance.players != null)
		{
			for (int i = 0; i < instance.players.Count; i++)
			{
				CardPlayer instance2 = instance.players[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				CardPlayer.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.CardPlayer)");
				}
				Span<byte> span = range.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
				if (num2 < 3)
				{
					span[num2 - 1] |= 128;
					while (num2 < 2)
					{
						span[num2++] = 128;
					}
					span[2] = 0;
				}
			}
		}
		if (instance.state != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.activePlayerIndex != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.activePlayerIndex);
		}
		if (instance.pot != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.pot);
		}
		if (instance.lastActionId != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastActionId);
		}
		if (instance.lastActionTarget != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.lastActionTarget);
		}
		if (instance.lastActionValue != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastActionValue);
		}
		if (instance.potRef != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.potRef.Value);
		}
		if (instance.texasHoldEm != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(3);
			int position2 = stream.Position;
			TexasHoldEm.Serialize(stream, instance.texasHoldEm);
			int num3 = stream.Position - position2;
			if (num3 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field texasHoldEm (ProtoBuf.CardGame.TexasHoldEm)");
			}
			Span<byte> span2 = range2.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)num3, span2, 0);
			if (num4 < 3)
			{
				span2[num4 - 1] |= 128;
				while (num4 < 2)
				{
					span2[num4++] = 128;
				}
				span2[2] = 0;
			}
		}
		if (instance.blackjack == null)
		{
			return;
		}
		stream.WriteByte(82);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		Blackjack.Serialize(stream, instance.blackjack);
		int num5 = stream.Position - position3;
		if (num5 > int.MaxValue)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field blackjack (ProtoBuf.CardGame.Blackjack)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num6 = ProtocolParser.WriteUInt32((uint)num5, span3, 0);
		if (num6 < 5)
		{
			span3[num6 - 1] |= 128;
			while (num6 < 4)
			{
				span3[num6++] = 128;
			}
			span3[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (players != null)
		{
			for (int i = 0; i < players.Count; i++)
			{
				players[i]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref potRef.Value);
		texasHoldEm?.InspectUids(action);
		blackjack?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Crane : IDisposable, IPooled, IProto<Crane>, IProto
{
	[NonSerialized]
	public float yaw;

	[NonSerialized]
	public float arm1;

	[NonSerialized]
	public float arm2;

	[NonSerialized]
	public float magnet;

	[NonSerialized]
	public float time;

	[NonSerialized]
	public int treadInput;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Crane instance)
	{
		if (instance.ShouldPool)
		{
			instance.yaw = 0f;
			instance.arm1 = 0f;
			instance.arm2 = 0f;
			instance.magnet = 0f;
			instance.time = 0f;
			instance.treadInput = 0;
			Pool.Free<Crane>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Crane with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Crane instance)
	{
		instance.yaw = yaw;
		instance.arm1 = arm1;
		instance.arm2 = arm2;
		instance.magnet = magnet;
		instance.time = time;
		instance.treadInput = treadInput;
	}

	public Crane Copy()
	{
		Crane crane = Pool.Get<Crane>();
		CopyTo(crane);
		return crane;
	}

	public static Crane Deserialize(BufferStream stream)
	{
		Crane crane = Pool.Get<Crane>();
		Deserialize(stream, crane, isDelta: false);
		return crane;
	}

	public static Crane DeserializeLengthDelimited(BufferStream stream)
	{
		Crane crane = Pool.Get<Crane>();
		DeserializeLengthDelimited(stream, crane, isDelta: false);
		return crane;
	}

	public static Crane DeserializeLength(BufferStream stream, int length)
	{
		Crane crane = Pool.Get<Crane>();
		DeserializeLength(stream, length, crane, isDelta: false);
		return crane;
	}

	public static Crane Deserialize(byte[] buffer)
	{
		Crane crane = Pool.Get<Crane>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, crane, isDelta: false);
		return crane;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Crane previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Crane Deserialize(BufferStream stream, Crane instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.arm1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.arm2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.magnet = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.treadInput = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Crane DeserializeLengthDelimited(BufferStream stream, Crane instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.arm1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.arm2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.magnet = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.treadInput = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Crane DeserializeLength(BufferStream stream, int length, Crane instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.arm1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.arm2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.magnet = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.treadInput = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Crane instance, Crane previous)
	{
		if (instance.yaw != previous.yaw)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
		if (instance.arm1 != previous.arm1)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.arm1);
		}
		if (instance.arm2 != previous.arm2)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.arm2);
		}
		if (instance.magnet != previous.magnet)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.magnet);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.treadInput != previous.treadInput)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.treadInput);
		}
	}

	public static void Serialize(BufferStream stream, Crane instance)
	{
		if (instance.yaw != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
		if (instance.arm1 != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.arm1);
		}
		if (instance.arm2 != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.arm2);
		}
		if (instance.magnet != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.magnet);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.treadInput != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.treadInput);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ConnectedSpeaker : IDisposable, IPooled, IProto<ConnectedSpeaker>, IProto
{
	[NonSerialized]
	public NetworkableId connectedTo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ConnectedSpeaker instance)
	{
		if (instance.ShouldPool)
		{
			instance.connectedTo = default(NetworkableId);
			Pool.Free<ConnectedSpeaker>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ConnectedSpeaker with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ConnectedSpeaker instance)
	{
		instance.connectedTo = connectedTo;
	}

	public ConnectedSpeaker Copy()
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		CopyTo(connectedSpeaker);
		return connectedSpeaker;
	}

	public static ConnectedSpeaker Deserialize(BufferStream stream)
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		Deserialize(stream, connectedSpeaker, isDelta: false);
		return connectedSpeaker;
	}

	public static ConnectedSpeaker DeserializeLengthDelimited(BufferStream stream)
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		DeserializeLengthDelimited(stream, connectedSpeaker, isDelta: false);
		return connectedSpeaker;
	}

	public static ConnectedSpeaker DeserializeLength(BufferStream stream, int length)
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		DeserializeLength(stream, length, connectedSpeaker, isDelta: false);
		return connectedSpeaker;
	}

	public static ConnectedSpeaker Deserialize(byte[] buffer)
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, connectedSpeaker, isDelta: false);
		return connectedSpeaker;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ConnectedSpeaker previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ConnectedSpeaker Deserialize(BufferStream stream, ConnectedSpeaker instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.connectedTo = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ConnectedSpeaker DeserializeLengthDelimited(BufferStream stream, ConnectedSpeaker instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.connectedTo = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ConnectedSpeaker DeserializeLength(BufferStream stream, int length, ConnectedSpeaker instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.connectedTo = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ConnectedSpeaker instance, ConnectedSpeaker previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.connectedTo.Value);
	}

	public static void Serialize(BufferStream stream, ConnectedSpeaker instance)
	{
		if (instance.connectedTo != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.connectedTo.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref connectedTo.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VoicemailEntry : IDisposable, IPooled, IProto<VoicemailEntry>, IProto
{
	[NonSerialized]
	public uint audioId;

	[NonSerialized]
	public string userName;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VoicemailEntry instance)
	{
		if (instance.ShouldPool)
		{
			instance.audioId = 0u;
			instance.userName = string.Empty;
			instance.timestamp = 0L;
			Pool.Free<VoicemailEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VoicemailEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VoicemailEntry instance)
	{
		instance.audioId = audioId;
		instance.userName = userName;
		instance.timestamp = timestamp;
	}

	public VoicemailEntry Copy()
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		CopyTo(voicemailEntry);
		return voicemailEntry;
	}

	public static VoicemailEntry Deserialize(BufferStream stream)
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		Deserialize(stream, voicemailEntry, isDelta: false);
		return voicemailEntry;
	}

	public static VoicemailEntry DeserializeLengthDelimited(BufferStream stream)
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		DeserializeLengthDelimited(stream, voicemailEntry, isDelta: false);
		return voicemailEntry;
	}

	public static VoicemailEntry DeserializeLength(BufferStream stream, int length)
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		DeserializeLength(stream, length, voicemailEntry, isDelta: false);
		return voicemailEntry;
	}

	public static VoicemailEntry Deserialize(byte[] buffer)
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, voicemailEntry, isDelta: false);
		return voicemailEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VoicemailEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VoicemailEntry Deserialize(BufferStream stream, VoicemailEntry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.userName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VoicemailEntry DeserializeLengthDelimited(BufferStream stream, VoicemailEntry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.userName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VoicemailEntry DeserializeLength(BufferStream stream, int length, VoicemailEntry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.userName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VoicemailEntry instance, VoicemailEntry previous)
	{
		if (instance.audioId != previous.audioId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.audioId);
		}
		if (instance.userName != previous.userName)
		{
			if (instance.userName == null)
			{
				throw new ArgumentNullException("userName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.userName);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, VoicemailEntry instance)
	{
		if (instance.audioId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.audioId);
		}
		if (instance.userName == null)
		{
			throw new ArgumentNullException("userName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.userName);
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AudioEntity : IDisposable, IPooled, IProto<AudioEntity>, IProto
{
	[NonSerialized]
	public int colourMode;

	[NonSerialized]
	public int volumeRange;

	[NonSerialized]
	public int speed;

	[NonSerialized]
	public int gradient;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AudioEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.colourMode = 0;
			instance.volumeRange = 0;
			instance.speed = 0;
			instance.gradient = 0;
			Pool.Free<AudioEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AudioEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AudioEntity instance)
	{
		instance.colourMode = colourMode;
		instance.volumeRange = volumeRange;
		instance.speed = speed;
		instance.gradient = gradient;
	}

	public AudioEntity Copy()
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		CopyTo(audioEntity);
		return audioEntity;
	}

	public static AudioEntity Deserialize(BufferStream stream)
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		Deserialize(stream, audioEntity, isDelta: false);
		return audioEntity;
	}

	public static AudioEntity DeserializeLengthDelimited(BufferStream stream)
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		DeserializeLengthDelimited(stream, audioEntity, isDelta: false);
		return audioEntity;
	}

	public static AudioEntity DeserializeLength(BufferStream stream, int length)
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		DeserializeLength(stream, length, audioEntity, isDelta: false);
		return audioEntity;
	}

	public static AudioEntity Deserialize(byte[] buffer)
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, audioEntity, isDelta: false);
		return audioEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AudioEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AudioEntity Deserialize(BufferStream stream, AudioEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.colourMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.volumeRange = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.speed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.gradient = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AudioEntity DeserializeLengthDelimited(BufferStream stream, AudioEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.colourMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.volumeRange = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.speed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.gradient = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AudioEntity DeserializeLength(BufferStream stream, int length, AudioEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.colourMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.volumeRange = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.speed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.gradient = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AudioEntity instance, AudioEntity previous)
	{
		if (instance.colourMode != previous.colourMode)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourMode);
		}
		if (instance.volumeRange != previous.volumeRange)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.volumeRange);
		}
		if (instance.speed != previous.speed)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.speed);
		}
		if (instance.gradient != previous.gradient)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gradient);
		}
	}

	public static void Serialize(BufferStream stream, AudioEntity instance)
	{
		if (instance.colourMode != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourMode);
		}
		if (instance.volumeRange != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.volumeRange);
		}
		if (instance.speed != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.speed);
		}
		if (instance.gradient != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gradient);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MicrophoneStand : IDisposable, IPooled, IProto<MicrophoneStand>, IProto
{
	[NonSerialized]
	public int microphoneMode;

	[NonSerialized]
	public NetworkableId IORef;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MicrophoneStand instance)
	{
		if (instance.ShouldPool)
		{
			instance.microphoneMode = 0;
			instance.IORef = default(NetworkableId);
			Pool.Free<MicrophoneStand>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MicrophoneStand with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MicrophoneStand instance)
	{
		instance.microphoneMode = microphoneMode;
		instance.IORef = IORef;
	}

	public MicrophoneStand Copy()
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		CopyTo(microphoneStand);
		return microphoneStand;
	}

	public static MicrophoneStand Deserialize(BufferStream stream)
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		Deserialize(stream, microphoneStand, isDelta: false);
		return microphoneStand;
	}

	public static MicrophoneStand DeserializeLengthDelimited(BufferStream stream)
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		DeserializeLengthDelimited(stream, microphoneStand, isDelta: false);
		return microphoneStand;
	}

	public static MicrophoneStand DeserializeLength(BufferStream stream, int length)
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		DeserializeLength(stream, length, microphoneStand, isDelta: false);
		return microphoneStand;
	}

	public static MicrophoneStand Deserialize(byte[] buffer)
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, microphoneStand, isDelta: false);
		return microphoneStand;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MicrophoneStand previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MicrophoneStand Deserialize(BufferStream stream, MicrophoneStand instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.microphoneMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.IORef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MicrophoneStand DeserializeLengthDelimited(BufferStream stream, MicrophoneStand instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.microphoneMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.IORef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MicrophoneStand DeserializeLength(BufferStream stream, int length, MicrophoneStand instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.microphoneMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.IORef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MicrophoneStand instance, MicrophoneStand previous)
	{
		if (instance.microphoneMode != previous.microphoneMode)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.microphoneMode);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.IORef.Value);
	}

	public static void Serialize(BufferStream stream, MicrophoneStand instance)
	{
		if (instance.microphoneMode != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.microphoneMode);
		}
		if (instance.IORef != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.IORef.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref IORef.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CommandBlock : IDisposable, IPooled, IProto<CommandBlock>, IProto
{
	[NonSerialized]
	public string currentCommand;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CommandBlock instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentCommand = string.Empty;
			Pool.Free<CommandBlock>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CommandBlock with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CommandBlock instance)
	{
		instance.currentCommand = currentCommand;
	}

	public CommandBlock Copy()
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		CopyTo(commandBlock);
		return commandBlock;
	}

	public static CommandBlock Deserialize(BufferStream stream)
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		Deserialize(stream, commandBlock, isDelta: false);
		return commandBlock;
	}

	public static CommandBlock DeserializeLengthDelimited(BufferStream stream)
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		DeserializeLengthDelimited(stream, commandBlock, isDelta: false);
		return commandBlock;
	}

	public static CommandBlock DeserializeLength(BufferStream stream, int length)
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		DeserializeLength(stream, length, commandBlock, isDelta: false);
		return commandBlock;
	}

	public static CommandBlock Deserialize(byte[] buffer)
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, commandBlock, isDelta: false);
		return commandBlock;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CommandBlock previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CommandBlock Deserialize(BufferStream stream, CommandBlock instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.currentCommand = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CommandBlock DeserializeLengthDelimited(BufferStream stream, CommandBlock instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.currentCommand = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CommandBlock DeserializeLength(BufferStream stream, int length, CommandBlock instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.currentCommand = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CommandBlock instance, CommandBlock previous)
	{
		if (instance.currentCommand != previous.currentCommand)
		{
			if (instance.currentCommand == null)
			{
				throw new ArgumentNullException("currentCommand", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.currentCommand);
		}
	}

	public static void Serialize(BufferStream stream, CommandBlock instance)
	{
		if (instance.currentCommand == null)
		{
			throw new ArgumentNullException("currentCommand", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.currentCommand);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Submarine : IDisposable, IPooled, IProto<Submarine>, IProto
{
	[NonSerialized]
	public float throttle;

	[NonSerialized]
	public float upDown;

	[NonSerialized]
	public float rudder;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelAmount;

	[NonSerialized]
	public NetworkableId torpedoStorageID;

	[NonSerialized]
	public float oxygen;

	[NonSerialized]
	public NetworkableId itemStorageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Submarine instance)
	{
		if (instance.ShouldPool)
		{
			instance.throttle = 0f;
			instance.upDown = 0f;
			instance.rudder = 0f;
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelAmount = 0f;
			instance.torpedoStorageID = default(NetworkableId);
			instance.oxygen = 0f;
			instance.itemStorageID = default(NetworkableId);
			Pool.Free<Submarine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Submarine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Submarine instance)
	{
		instance.throttle = throttle;
		instance.upDown = upDown;
		instance.rudder = rudder;
		instance.fuelStorageID = fuelStorageID;
		instance.fuelAmount = fuelAmount;
		instance.torpedoStorageID = torpedoStorageID;
		instance.oxygen = oxygen;
		instance.itemStorageID = itemStorageID;
	}

	public Submarine Copy()
	{
		Submarine submarine = Pool.Get<Submarine>();
		CopyTo(submarine);
		return submarine;
	}

	public static Submarine Deserialize(BufferStream stream)
	{
		Submarine submarine = Pool.Get<Submarine>();
		Deserialize(stream, submarine, isDelta: false);
		return submarine;
	}

	public static Submarine DeserializeLengthDelimited(BufferStream stream)
	{
		Submarine submarine = Pool.Get<Submarine>();
		DeserializeLengthDelimited(stream, submarine, isDelta: false);
		return submarine;
	}

	public static Submarine DeserializeLength(BufferStream stream, int length)
	{
		Submarine submarine = Pool.Get<Submarine>();
		DeserializeLength(stream, length, submarine, isDelta: false);
		return submarine;
	}

	public static Submarine Deserialize(byte[] buffer)
	{
		Submarine submarine = Pool.Get<Submarine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, submarine, isDelta: false);
		return submarine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Submarine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Submarine Deserialize(BufferStream stream, Submarine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.throttle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.upDown = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rudder = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.fuelAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.torpedoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 61:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Submarine DeserializeLengthDelimited(BufferStream stream, Submarine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.throttle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.upDown = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rudder = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.fuelAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.torpedoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 61:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Submarine DeserializeLength(BufferStream stream, int length, Submarine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.throttle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.upDown = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rudder = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.fuelAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.torpedoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 61:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Submarine instance, Submarine previous)
	{
		if (instance.throttle != previous.throttle)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.throttle);
		}
		if (instance.upDown != previous.upDown)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.upDown);
		}
		if (instance.rudder != previous.rudder)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.rudder);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelAmount != previous.fuelAmount)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.fuelAmount);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, instance.torpedoStorageID.Value);
		if (instance.oxygen != previous.oxygen)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.oxygen);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.itemStorageID.Value);
	}

	public static void Serialize(BufferStream stream, Submarine instance)
	{
		if (instance.throttle != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.throttle);
		}
		if (instance.upDown != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.upDown);
		}
		if (instance.rudder != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.rudder);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelAmount != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.fuelAmount);
		}
		if (instance.torpedoStorageID != default(NetworkableId))
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.torpedoStorageID.Value);
		}
		if (instance.oxygen != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.oxygen);
		}
		if (instance.itemStorageID != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.itemStorageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
		action(UidType.NetworkableId, ref torpedoStorageID.Value);
		action(UidType.NetworkableId, ref itemStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SleepingBagCamper : IDisposable, IPooled, IProto<SleepingBagCamper>, IProto
{
	[NonSerialized]
	public NetworkableId seatID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SleepingBagCamper instance)
	{
		if (instance.ShouldPool)
		{
			instance.seatID = default(NetworkableId);
			Pool.Free<SleepingBagCamper>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SleepingBagCamper with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SleepingBagCamper instance)
	{
		instance.seatID = seatID;
	}

	public SleepingBagCamper Copy()
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		CopyTo(sleepingBagCamper);
		return sleepingBagCamper;
	}

	public static SleepingBagCamper Deserialize(BufferStream stream)
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		Deserialize(stream, sleepingBagCamper, isDelta: false);
		return sleepingBagCamper;
	}

	public static SleepingBagCamper DeserializeLengthDelimited(BufferStream stream)
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		DeserializeLengthDelimited(stream, sleepingBagCamper, isDelta: false);
		return sleepingBagCamper;
	}

	public static SleepingBagCamper DeserializeLength(BufferStream stream, int length)
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		DeserializeLength(stream, length, sleepingBagCamper, isDelta: false);
		return sleepingBagCamper;
	}

	public static SleepingBagCamper Deserialize(byte[] buffer)
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sleepingBagCamper, isDelta: false);
		return sleepingBagCamper;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SleepingBagCamper previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SleepingBagCamper Deserialize(BufferStream stream, SleepingBagCamper instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.seatID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SleepingBagCamper DeserializeLengthDelimited(BufferStream stream, SleepingBagCamper instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seatID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SleepingBagCamper DeserializeLength(BufferStream stream, int length, SleepingBagCamper instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seatID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SleepingBagCamper instance, SleepingBagCamper previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.seatID.Value);
	}

	public static void Serialize(BufferStream stream, SleepingBagCamper instance)
	{
		if (instance.seatID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.seatID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref seatID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CamperModule : IDisposable, IPooled, IProto<CamperModule>, IProto
{
	[NonSerialized]
	public NetworkableId bbqId;

	[NonSerialized]
	public NetworkableId lockerId;

	[NonSerialized]
	public NetworkableId storageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CamperModule instance)
	{
		if (instance.ShouldPool)
		{
			instance.bbqId = default(NetworkableId);
			instance.lockerId = default(NetworkableId);
			instance.storageID = default(NetworkableId);
			Pool.Free<CamperModule>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CamperModule with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CamperModule instance)
	{
		instance.bbqId = bbqId;
		instance.lockerId = lockerId;
		instance.storageID = storageID;
	}

	public CamperModule Copy()
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		CopyTo(camperModule);
		return camperModule;
	}

	public static CamperModule Deserialize(BufferStream stream)
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		Deserialize(stream, camperModule, isDelta: false);
		return camperModule;
	}

	public static CamperModule DeserializeLengthDelimited(BufferStream stream)
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		DeserializeLengthDelimited(stream, camperModule, isDelta: false);
		return camperModule;
	}

	public static CamperModule DeserializeLength(BufferStream stream, int length)
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		DeserializeLength(stream, length, camperModule, isDelta: false);
		return camperModule;
	}

	public static CamperModule Deserialize(byte[] buffer)
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, camperModule, isDelta: false);
		return camperModule;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CamperModule previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CamperModule Deserialize(BufferStream stream, CamperModule instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.bbqId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.lockerId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CamperModule DeserializeLengthDelimited(BufferStream stream, CamperModule instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.bbqId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.lockerId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CamperModule DeserializeLength(BufferStream stream, int length, CamperModule instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.bbqId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.lockerId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CamperModule instance, CamperModule previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.bbqId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.lockerId.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
	}

	public static void Serialize(BufferStream stream, CamperModule instance)
	{
		if (instance.bbqId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.bbqId.Value);
		}
		if (instance.lockerId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.lockerId.Value);
		}
		if (instance.storageID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref bbqId.Value);
		action(UidType.NetworkableId, ref lockerId.Value);
		action(UidType.NetworkableId, ref storageID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PaintableSign : IDisposable, IPooled, IProto<PaintableSign>, IProto
{
	[NonSerialized]
	public List<uint> crcs;

	[NonSerialized]
	public List<ulong> editHistory;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PaintableSign instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.crcs != null)
			{
				List<uint> list = instance.crcs;
				Pool.FreeUnmanaged<uint>(ref list);
				instance.crcs = list;
			}
			if (instance.editHistory != null)
			{
				List<ulong> list2 = instance.editHistory;
				Pool.FreeUnmanaged<ulong>(ref list2);
				instance.editHistory = list2;
			}
			Pool.Free<PaintableSign>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PaintableSign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PaintableSign instance)
	{
		if (crcs != null)
		{
			instance.crcs = Pool.Get<List<uint>>();
			for (int i = 0; i < crcs.Count; i++)
			{
				uint item = crcs[i];
				instance.crcs.Add(item);
			}
		}
		else
		{
			instance.crcs = null;
		}
		if (editHistory != null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
			for (int j = 0; j < editHistory.Count; j++)
			{
				ulong item2 = editHistory[j];
				instance.editHistory.Add(item2);
			}
		}
		else
		{
			instance.editHistory = null;
		}
	}

	public PaintableSign Copy()
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		CopyTo(paintableSign);
		return paintableSign;
	}

	public static PaintableSign Deserialize(BufferStream stream)
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		Deserialize(stream, paintableSign, isDelta: false);
		return paintableSign;
	}

	public static PaintableSign DeserializeLengthDelimited(BufferStream stream)
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		DeserializeLengthDelimited(stream, paintableSign, isDelta: false);
		return paintableSign;
	}

	public static PaintableSign DeserializeLength(BufferStream stream, int length)
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		DeserializeLength(stream, length, paintableSign, isDelta: false);
		return paintableSign;
	}

	public static PaintableSign Deserialize(byte[] buffer)
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, paintableSign, isDelta: false);
		return paintableSign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PaintableSign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PaintableSign Deserialize(BufferStream stream, PaintableSign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.crcs == null)
			{
				instance.crcs = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.crcs.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PaintableSign DeserializeLengthDelimited(BufferStream stream, PaintableSign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.crcs == null)
			{
				instance.crcs = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.crcs.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PaintableSign DeserializeLength(BufferStream stream, int length, PaintableSign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.crcs == null)
			{
				instance.crcs = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.crcs.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PaintableSign instance, PaintableSign previous)
	{
		if (instance.crcs != null)
		{
			for (int i = 0; i < instance.crcs.Count; i++)
			{
				uint val = instance.crcs[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.editHistory != null)
		{
			for (int j = 0; j < instance.editHistory.Count; j++)
			{
				ulong val2 = instance.editHistory[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public static void Serialize(BufferStream stream, PaintableSign instance)
	{
		if (instance.crcs != null)
		{
			for (int i = 0; i < instance.crcs.Count; i++)
			{
				uint val = instance.crcs[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.editHistory != null)
		{
			for (int j = 0; j < instance.editHistory.Count; j++)
			{
				ulong val2 = instance.editHistory[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MLRS : IDisposable, IPooled, IProto<MLRS>, IProto
{
	[NonSerialized]
	public Vector3 targetPos;

	[NonSerialized]
	public Vector3 curHitPos;

	[NonSerialized]
	public NetworkableId rocketStorageID;

	[NonSerialized]
	public NetworkableId dashboardStorageID;

	[NonSerialized]
	public uint ammoCount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MLRS instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.targetPos = default(Vector3);
			instance.curHitPos = default(Vector3);
			instance.rocketStorageID = default(NetworkableId);
			instance.dashboardStorageID = default(NetworkableId);
			instance.ammoCount = 0u;
			Pool.Free<MLRS>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MLRS with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MLRS instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.targetPos = targetPos;
		instance.curHitPos = curHitPos;
		instance.rocketStorageID = rocketStorageID;
		instance.dashboardStorageID = dashboardStorageID;
		instance.ammoCount = ammoCount;
	}

	public MLRS Copy()
	{
		MLRS mLRS = Pool.Get<MLRS>();
		CopyTo(mLRS);
		return mLRS;
	}

	public static MLRS Deserialize(BufferStream stream)
	{
		MLRS mLRS = Pool.Get<MLRS>();
		Deserialize(stream, mLRS, isDelta: false);
		return mLRS;
	}

	public static MLRS DeserializeLengthDelimited(BufferStream stream)
	{
		MLRS mLRS = Pool.Get<MLRS>();
		DeserializeLengthDelimited(stream, mLRS, isDelta: false);
		return mLRS;
	}

	public static MLRS DeserializeLength(BufferStream stream, int length)
	{
		MLRS mLRS = Pool.Get<MLRS>();
		DeserializeLength(stream, length, mLRS, isDelta: false);
		return mLRS;
	}

	public static MLRS Deserialize(byte[] buffer)
	{
		MLRS mLRS = Pool.Get<MLRS>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mLRS, isDelta: false);
		return mLRS;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MLRS previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MLRS Deserialize(BufferStream stream, MLRS instance, bool isDelta)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curHitPos, isDelta);
				continue;
			case 32:
				instance.rocketStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.dashboardStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.ammoCount = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MLRS DeserializeLengthDelimited(BufferStream stream, MLRS instance, bool isDelta)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curHitPos, isDelta);
				continue;
			case 32:
				instance.rocketStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.dashboardStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.ammoCount = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MLRS DeserializeLength(BufferStream stream, int length, MLRS instance, bool isDelta)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curHitPos, isDelta);
				continue;
			case 32:
				instance.rocketStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.dashboardStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.ammoCount = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MLRS instance, MLRS previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (instance.targetPos != previous.targetPos)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.targetPos, previous.targetPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.curHitPos != previous.curHitPos)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.curHitPos, previous.curHitPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curHitPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.rocketStorageID.Value);
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.dashboardStorageID.Value);
		if (instance.ammoCount != previous.ammoCount)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.ammoCount);
		}
	}

	public static void Serialize(BufferStream stream, MLRS instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (instance.targetPos != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.targetPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.curHitPos != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.curHitPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curHitPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rocketStorageID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.rocketStorageID.Value);
		}
		if (instance.dashboardStorageID != default(NetworkableId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.dashboardStorageID.Value);
		}
		if (instance.ammoCount != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.ammoCount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref rocketStorageID.Value);
		action(UidType.NetworkableId, ref dashboardStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Snowmobile : IDisposable, IPooled, IProto<Snowmobile>, IProto
{
	[NonSerialized]
	public float steerInput;

	[NonSerialized]
	public float driveWheelVel;

	[NonSerialized]
	public float throttleInput;

	[NonSerialized]
	public float brakeInput;

	[NonSerialized]
	public NetworkableId storageID;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelFraction;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Snowmobile instance)
	{
		if (instance.ShouldPool)
		{
			instance.steerInput = 0f;
			instance.driveWheelVel = 0f;
			instance.throttleInput = 0f;
			instance.brakeInput = 0f;
			instance.storageID = default(NetworkableId);
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelFraction = 0f;
			Pool.Free<Snowmobile>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Snowmobile with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Snowmobile instance)
	{
		instance.steerInput = steerInput;
		instance.driveWheelVel = driveWheelVel;
		instance.throttleInput = throttleInput;
		instance.brakeInput = brakeInput;
		instance.storageID = storageID;
		instance.fuelStorageID = fuelStorageID;
		instance.fuelFraction = fuelFraction;
	}

	public Snowmobile Copy()
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		CopyTo(snowmobile);
		return snowmobile;
	}

	public static Snowmobile Deserialize(BufferStream stream)
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		Deserialize(stream, snowmobile, isDelta: false);
		return snowmobile;
	}

	public static Snowmobile DeserializeLengthDelimited(BufferStream stream)
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		DeserializeLengthDelimited(stream, snowmobile, isDelta: false);
		return snowmobile;
	}

	public static Snowmobile DeserializeLength(BufferStream stream, int length)
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		DeserializeLength(stream, length, snowmobile, isDelta: false);
		return snowmobile;
	}

	public static Snowmobile Deserialize(byte[] buffer)
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, snowmobile, isDelta: false);
		return snowmobile;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Snowmobile previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Snowmobile Deserialize(BufferStream stream, Snowmobile instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Snowmobile DeserializeLengthDelimited(BufferStream stream, Snowmobile instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Snowmobile DeserializeLength(BufferStream stream, int length, Snowmobile instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Snowmobile instance, Snowmobile previous)
	{
		if (instance.steerInput != previous.steerInput)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != previous.driveWheelVel)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != previous.throttleInput)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != previous.brakeInput)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
	}

	public static void Serialize(BufferStream stream, Snowmobile instance)
	{
		if (instance.steerInput != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.storageID != default(NetworkableId))
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref storageID.Value);
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PatternFirework : IDisposable, IPooled, IProto<PatternFirework>, IProto
{
	public class Design : IDisposable, IPooled, IProto<Design>, IProto
	{
		[NonSerialized]
		public List<Star> stars;

		[NonSerialized]
		public ulong editedBy;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Design instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.stars != null)
			{
				for (int i = 0; i < instance.stars.Count; i++)
				{
					if (instance.stars[i] != null)
					{
						instance.stars[i].ResetToPool();
						instance.stars[i] = null;
					}
				}
				List<Star> list = instance.stars;
				Pool.Free<Star>(ref list, false);
				instance.stars = list;
			}
			instance.editedBy = 0uL;
			Pool.Free<Design>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Design with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Design instance)
		{
			if (stars != null)
			{
				instance.stars = Pool.Get<List<Star>>();
				for (int i = 0; i < stars.Count; i++)
				{
					Star item = stars[i].Copy();
					instance.stars.Add(item);
				}
			}
			else
			{
				instance.stars = null;
			}
			instance.editedBy = editedBy;
		}

		public Design Copy()
		{
			Design design = Pool.Get<Design>();
			CopyTo(design);
			return design;
		}

		public static Design Deserialize(BufferStream stream)
		{
			Design design = Pool.Get<Design>();
			Deserialize(stream, design, isDelta: false);
			return design;
		}

		public static Design DeserializeLengthDelimited(BufferStream stream)
		{
			Design design = Pool.Get<Design>();
			DeserializeLengthDelimited(stream, design, isDelta: false);
			return design;
		}

		public static Design DeserializeLength(BufferStream stream, int length)
		{
			Design design = Pool.Get<Design>();
			DeserializeLength(stream, length, design, isDelta: false);
			return design;
		}

		public static Design Deserialize(byte[] buffer)
		{
			Design design = Pool.Get<Design>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, design, isDelta: false);
			return design;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Design previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Design Deserialize(BufferStream stream, Design instance, bool isDelta)
		{
			if (!isDelta && instance.stars == null)
			{
				instance.stars = Pool.Get<List<Star>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.stars.Add(Star.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.editedBy = ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Design DeserializeLengthDelimited(BufferStream stream, Design instance, bool isDelta)
		{
			if (!isDelta && instance.stars == null)
			{
				instance.stars = Pool.Get<List<Star>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.stars.Add(Star.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.editedBy = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Design DeserializeLength(BufferStream stream, int length, Design instance, bool isDelta)
		{
			if (!isDelta && instance.stars == null)
			{
				instance.stars = Pool.Get<List<Star>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.stars.Add(Star.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.editedBy = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Design instance, Design previous)
		{
			if (instance.stars != null)
			{
				for (int i = 0; i < instance.stars.Count; i++)
				{
					Star star = instance.stars[i];
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Star.SerializeDelta(stream, star, star);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stars (ProtoBuf.PatternFirework.Star)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.editedBy != previous.editedBy)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.editedBy);
			}
		}

		public static void Serialize(BufferStream stream, Design instance)
		{
			if (instance.stars != null)
			{
				for (int i = 0; i < instance.stars.Count; i++)
				{
					Star instance2 = instance.stars[i];
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Star.Serialize(stream, instance2);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stars (ProtoBuf.PatternFirework.Star)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.editedBy != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.editedBy);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (stars != null)
			{
				for (int i = 0; i < stars.Count; i++)
				{
					stars[i]?.InspectUids(action);
				}
			}
		}
	}

	public class Star : IDisposable, IPooled, IProto<Star>, IProto
	{
		[NonSerialized]
		public Vector2 position;

		[NonSerialized]
		public Color color;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Star instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.position = default(Vector2);
				instance.color = default(Color);
				Pool.Free<Star>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Star with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Star instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			instance.position = position;
			instance.color = color;
		}

		public Star Copy()
		{
			Star star = Pool.Get<Star>();
			CopyTo(star);
			return star;
		}

		public static Star Deserialize(BufferStream stream)
		{
			Star star = Pool.Get<Star>();
			Deserialize(stream, star, isDelta: false);
			return star;
		}

		public static Star DeserializeLengthDelimited(BufferStream stream)
		{
			Star star = Pool.Get<Star>();
			DeserializeLengthDelimited(stream, star, isDelta: false);
			return star;
		}

		public static Star DeserializeLength(BufferStream stream, int length)
		{
			Star star = Pool.Get<Star>();
			DeserializeLength(stream, length, star, isDelta: false);
			return star;
		}

		public static Star Deserialize(byte[] buffer)
		{
			Star star = Pool.Get<Star>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, star, isDelta: false);
			return star;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Star previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Star Deserialize(BufferStream stream, Star instance, bool isDelta)
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Star DeserializeLengthDelimited(BufferStream stream, Star instance, bool isDelta)
		{
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Star DeserializeLength(BufferStream stream, int length, Star instance, bool isDelta)
		{
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Star instance, Star previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			if (instance.position != previous.position)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector2Serialized.SerializeDelta(stream, instance.position, previous.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector2)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.color != previous.color)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.color, previous.color);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
		}

		public static void Serialize(BufferStream stream, Star instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			if (instance.position != default(Vector2))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector2Serialized.Serialize(stream, instance.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector2)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.color != default(Color))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				ColorSerialized.Serialize(stream, instance.color);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class SavedDesign : IDisposable, IPooled, IProto<SavedDesign>, IProto
	{
		[NonSerialized]
		public int version;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public Design design;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SavedDesign instance)
		{
			if (instance.ShouldPool)
			{
				instance.version = 0;
				instance.name = string.Empty;
				if (instance.design != null)
				{
					instance.design.ResetToPool();
					instance.design = null;
				}
				Pool.Free<SavedDesign>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SavedDesign with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SavedDesign instance)
		{
			instance.version = version;
			instance.name = name;
			if (design != null)
			{
				if (instance.design == null)
				{
					instance.design = design.Copy();
				}
				else
				{
					design.CopyTo(instance.design);
				}
			}
			else
			{
				instance.design = null;
			}
		}

		public SavedDesign Copy()
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			CopyTo(savedDesign);
			return savedDesign;
		}

		public static SavedDesign Deserialize(BufferStream stream)
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			Deserialize(stream, savedDesign, isDelta: false);
			return savedDesign;
		}

		public static SavedDesign DeserializeLengthDelimited(BufferStream stream)
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			DeserializeLengthDelimited(stream, savedDesign, isDelta: false);
			return savedDesign;
		}

		public static SavedDesign DeserializeLength(BufferStream stream, int length)
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			DeserializeLength(stream, length, savedDesign, isDelta: false);
			return savedDesign;
		}

		public static SavedDesign Deserialize(byte[] buffer)
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, savedDesign, isDelta: false);
			return savedDesign;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SavedDesign previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SavedDesign Deserialize(BufferStream stream, SavedDesign instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.version = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					break;
				case 26:
					if (instance.design == null)
					{
						instance.design = Design.DeserializeLengthDelimited(stream);
					}
					else
					{
						Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
					}
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
				case 0:
					return instance;
				}
			}
		}

		public static SavedDesign DeserializeLengthDelimited(BufferStream stream, SavedDesign instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.version = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					break;
				case 26:
					if (instance.design == null)
					{
						instance.design = Design.DeserializeLengthDelimited(stream);
					}
					else
					{
						Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
					}
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SavedDesign DeserializeLength(BufferStream stream, int length, SavedDesign instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.version = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					break;
				case 26:
					if (instance.design == null)
					{
						instance.design = Design.DeserializeLengthDelimited(stream);
					}
					else
					{
						Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
					}
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SavedDesign instance, SavedDesign previous)
		{
			if (instance.version != previous.version)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.version);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.design == null)
			{
				throw new ArgumentNullException("design", "Required by proto specification.");
			}
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			Design.SerializeDelta(stream, instance.design, previous.design);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}

		public static void Serialize(BufferStream stream, SavedDesign instance)
		{
			if (instance.version != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.version);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.design == null)
			{
				throw new ArgumentNullException("design", "Required by proto specification.");
			}
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			Design.Serialize(stream, instance.design);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			design?.InspectUids(action);
		}
	}

	[NonSerialized]
	public Design design;

	[NonSerialized]
	public int shellFuseLength;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PatternFirework instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.design != null)
			{
				instance.design.ResetToPool();
				instance.design = null;
			}
			instance.shellFuseLength = 0;
			Pool.Free<PatternFirework>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PatternFirework with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PatternFirework instance)
	{
		if (design != null)
		{
			if (instance.design == null)
			{
				instance.design = design.Copy();
			}
			else
			{
				design.CopyTo(instance.design);
			}
		}
		else
		{
			instance.design = null;
		}
		instance.shellFuseLength = shellFuseLength;
	}

	public PatternFirework Copy()
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		CopyTo(patternFirework);
		return patternFirework;
	}

	public static PatternFirework Deserialize(BufferStream stream)
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		Deserialize(stream, patternFirework, isDelta: false);
		return patternFirework;
	}

	public static PatternFirework DeserializeLengthDelimited(BufferStream stream)
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		DeserializeLengthDelimited(stream, patternFirework, isDelta: false);
		return patternFirework;
	}

	public static PatternFirework DeserializeLength(BufferStream stream, int length)
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		DeserializeLength(stream, length, patternFirework, isDelta: false);
		return patternFirework;
	}

	public static PatternFirework Deserialize(byte[] buffer)
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, patternFirework, isDelta: false);
		return patternFirework;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PatternFirework previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PatternFirework Deserialize(BufferStream stream, PatternFirework instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			case 16:
				instance.shellFuseLength = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static PatternFirework DeserializeLengthDelimited(BufferStream stream, PatternFirework instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			case 16:
				instance.shellFuseLength = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PatternFirework DeserializeLength(BufferStream stream, int length, PatternFirework instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			case 16:
				instance.shellFuseLength = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PatternFirework instance, PatternFirework previous)
	{
		if (instance.design != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			Design.SerializeDelta(stream, instance.design, previous.design);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}
		if (instance.shellFuseLength != previous.shellFuseLength)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.shellFuseLength);
		}
	}

	public static void Serialize(BufferStream stream, PatternFirework instance)
	{
		if (instance.design != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			Design.Serialize(stream, instance.design);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}
		if (instance.shellFuseLength != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.shellFuseLength);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		design?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class CargoPlane : IDisposable, IPooled, IProto<CargoPlane>, IProto
{
	[NonSerialized]
	public Vector3 startPos;

	[NonSerialized]
	public Vector3 endPos;

	[NonSerialized]
	public float secondsToTake;

	[NonSerialized]
	public float secondsTaken;

	[NonSerialized]
	public bool dropped;

	[NonSerialized]
	public Vector3 dropPosition;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CargoPlane instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.startPos = default(Vector3);
			instance.endPos = default(Vector3);
			instance.secondsToTake = 0f;
			instance.secondsTaken = 0f;
			instance.dropped = false;
			instance.dropPosition = default(Vector3);
			Pool.Free<CargoPlane>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CargoPlane with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CargoPlane instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		instance.startPos = startPos;
		instance.endPos = endPos;
		instance.secondsToTake = secondsToTake;
		instance.secondsTaken = secondsTaken;
		instance.dropped = dropped;
		instance.dropPosition = dropPosition;
	}

	public CargoPlane Copy()
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		CopyTo(cargoPlane);
		return cargoPlane;
	}

	public static CargoPlane Deserialize(BufferStream stream)
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		Deserialize(stream, cargoPlane, isDelta: false);
		return cargoPlane;
	}

	public static CargoPlane DeserializeLengthDelimited(BufferStream stream)
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		DeserializeLengthDelimited(stream, cargoPlane, isDelta: false);
		return cargoPlane;
	}

	public static CargoPlane DeserializeLength(BufferStream stream, int length)
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		DeserializeLength(stream, length, cargoPlane, isDelta: false);
		return cargoPlane;
	}

	public static CargoPlane Deserialize(byte[] buffer)
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cargoPlane, isDelta: false);
		return cargoPlane;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CargoPlane previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CargoPlane Deserialize(BufferStream stream, CargoPlane instance, bool isDelta)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPos, isDelta);
				continue;
			case 29:
				instance.secondsToTake = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.secondsTaken = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.dropped = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.dropPosition, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CargoPlane DeserializeLengthDelimited(BufferStream stream, CargoPlane instance, bool isDelta)
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPos, isDelta);
				continue;
			case 29:
				instance.secondsToTake = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.secondsTaken = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.dropped = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.dropPosition, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CargoPlane DeserializeLength(BufferStream stream, int length, CargoPlane instance, bool isDelta)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPos, isDelta);
				continue;
			case 29:
				instance.secondsToTake = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.secondsTaken = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.dropped = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.dropPosition, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CargoPlane instance, CargoPlane previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		if (instance.startPos != previous.startPos)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.startPos, previous.startPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.endPos != previous.endPos)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.endPos, previous.endPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field endPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.secondsToTake != previous.secondsToTake)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.secondsToTake);
		}
		if (instance.secondsTaken != previous.secondsTaken)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.secondsTaken);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.dropped);
		if (instance.dropPosition != previous.dropPosition)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.dropPosition, previous.dropPosition);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field dropPosition (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public static void Serialize(BufferStream stream, CargoPlane instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		if (instance.startPos != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.startPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.endPos != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.endPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field endPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.secondsToTake != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.secondsToTake);
		}
		if (instance.secondsTaken != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.secondsTaken);
		}
		if (instance.dropped)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.dropped);
		}
		if (instance.dropPosition != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.dropPosition);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field dropPosition (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PaintedItem : IDisposable, IPooled, IProto<PaintedItem>, IProto
{
	[NonSerialized]
	public uint imageCrc;

	[NonSerialized]
	public ulong editedBy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PaintedItem instance)
	{
		if (instance.ShouldPool)
		{
			instance.imageCrc = 0u;
			instance.editedBy = 0uL;
			Pool.Free<PaintedItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PaintedItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PaintedItem instance)
	{
		instance.imageCrc = imageCrc;
		instance.editedBy = editedBy;
	}

	public PaintedItem Copy()
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		CopyTo(paintedItem);
		return paintedItem;
	}

	public static PaintedItem Deserialize(BufferStream stream)
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		Deserialize(stream, paintedItem, isDelta: false);
		return paintedItem;
	}

	public static PaintedItem DeserializeLengthDelimited(BufferStream stream)
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		DeserializeLengthDelimited(stream, paintedItem, isDelta: false);
		return paintedItem;
	}

	public static PaintedItem DeserializeLength(BufferStream stream, int length)
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		DeserializeLength(stream, length, paintedItem, isDelta: false);
		return paintedItem;
	}

	public static PaintedItem Deserialize(byte[] buffer)
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, paintedItem, isDelta: false);
		return paintedItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PaintedItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PaintedItem Deserialize(BufferStream stream, PaintedItem instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PaintedItem DeserializeLengthDelimited(BufferStream stream, PaintedItem instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PaintedItem DeserializeLength(BufferStream stream, int length, PaintedItem instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PaintedItem instance, PaintedItem previous)
	{
		if (instance.imageCrc != previous.imageCrc)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
		if (instance.editedBy != previous.editedBy)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.editedBy);
		}
	}

	public static void Serialize(BufferStream stream, PaintedItem instance)
	{
		if (instance.imageCrc != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
		if (instance.editedBy != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.editedBy);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Spray : IDisposable, IPooled, IProto<Spray>, IProto
{
	[NonSerialized]
	public ulong sprayedBy;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Spray instance)
	{
		if (instance.ShouldPool)
		{
			instance.sprayedBy = 0uL;
			instance.timestamp = 0L;
			Pool.Free<Spray>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Spray with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Spray instance)
	{
		instance.sprayedBy = sprayedBy;
		instance.timestamp = timestamp;
	}

	public Spray Copy()
	{
		Spray spray = Pool.Get<Spray>();
		CopyTo(spray);
		return spray;
	}

	public static Spray Deserialize(BufferStream stream)
	{
		Spray spray = Pool.Get<Spray>();
		Deserialize(stream, spray, isDelta: false);
		return spray;
	}

	public static Spray DeserializeLengthDelimited(BufferStream stream)
	{
		Spray spray = Pool.Get<Spray>();
		DeserializeLengthDelimited(stream, spray, isDelta: false);
		return spray;
	}

	public static Spray DeserializeLength(BufferStream stream, int length)
	{
		Spray spray = Pool.Get<Spray>();
		DeserializeLength(stream, length, spray, isDelta: false);
		return spray;
	}

	public static Spray Deserialize(byte[] buffer)
	{
		Spray spray = Pool.Get<Spray>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spray, isDelta: false);
		return spray;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Spray previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Spray Deserialize(BufferStream stream, Spray instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.sprayedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Spray DeserializeLengthDelimited(BufferStream stream, Spray instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.sprayedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Spray DeserializeLength(BufferStream stream, int length, Spray instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.sprayedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Spray instance, Spray previous)
	{
		if (instance.sprayedBy != previous.sprayedBy)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.sprayedBy);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, Spray instance)
	{
		if (instance.sprayedBy != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.sprayedBy);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class SprayLine : IDisposable, IPooled, IProto<SprayLine>, IProto
{
	[NonSerialized]
	public List<LinePoint> linePoints;

	[NonSerialized]
	public Vector3 colour;

	[NonSerialized]
	public float width;

	[NonSerialized]
	public NetworkableId editingPlayer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SprayLine instance)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				if (instance.linePoints[i] != null)
				{
					instance.linePoints[i].ResetToPool();
					instance.linePoints[i] = null;
				}
			}
			List<LinePoint> list = instance.linePoints;
			Pool.Free<LinePoint>(ref list, false);
			instance.linePoints = list;
		}
		instance.colour = default(Vector3);
		instance.width = 0f;
		instance.editingPlayer = default(NetworkableId);
		Pool.Free<SprayLine>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SprayLine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SprayLine instance)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				LinePoint item = linePoints[i].Copy();
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
		instance.colour = colour;
		instance.width = width;
		instance.editingPlayer = editingPlayer;
	}

	public SprayLine Copy()
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		CopyTo(sprayLine);
		return sprayLine;
	}

	public static SprayLine Deserialize(BufferStream stream)
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		Deserialize(stream, sprayLine, isDelta: false);
		return sprayLine;
	}

	public static SprayLine DeserializeLengthDelimited(BufferStream stream)
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		DeserializeLengthDelimited(stream, sprayLine, isDelta: false);
		return sprayLine;
	}

	public static SprayLine DeserializeLength(BufferStream stream, int length)
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		DeserializeLength(stream, length, sprayLine, isDelta: false);
		return sprayLine;
	}

	public static SprayLine Deserialize(byte[] buffer)
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sprayLine, isDelta: false);
		return sprayLine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SprayLine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SprayLine Deserialize(BufferStream stream, SprayLine instance, bool isDelta)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colour, isDelta);
				continue;
			case 29:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.editingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SprayLine DeserializeLengthDelimited(BufferStream stream, SprayLine instance, bool isDelta)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colour, isDelta);
				continue;
			case 29:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.editingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SprayLine DeserializeLength(BufferStream stream, int length, SprayLine instance, bool isDelta)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colour, isDelta);
				continue;
			case 29:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.editingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SprayLine instance, SprayLine previous)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				LinePoint linePoint = instance.linePoints[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				LinePoint.SerializeDelta(stream, linePoint, linePoint);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.LinePoint)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.colour != previous.colour)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.colour, previous.colour);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colour (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.width != previous.width)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.width);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.editingPlayer.Value);
	}

	public static void Serialize(BufferStream stream, SprayLine instance)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				LinePoint instance2 = instance.linePoints[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				LinePoint.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.LinePoint)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.colour != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.colour);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colour (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.width != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.width);
		}
		if (instance.editingPlayer != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.editingPlayer.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (linePoints != null)
		{
			for (int i = 0; i < linePoints.Count; i++)
			{
				linePoints[i]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref editingPlayer.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SprayList : IDisposable, IPooled, IProto<SprayList>, IProto
{
	[NonSerialized]
	public List<LinePoint> linePoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SprayList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				if (instance.linePoints[i] != null)
				{
					instance.linePoints[i].ResetToPool();
					instance.linePoints[i] = null;
				}
			}
			List<LinePoint> list = instance.linePoints;
			Pool.Free<LinePoint>(ref list, false);
			instance.linePoints = list;
		}
		Pool.Free<SprayList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SprayList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SprayList instance)
	{
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				LinePoint item = linePoints[i].Copy();
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
	}

	public SprayList Copy()
	{
		SprayList sprayList = Pool.Get<SprayList>();
		CopyTo(sprayList);
		return sprayList;
	}

	public static SprayList Deserialize(BufferStream stream)
	{
		SprayList sprayList = Pool.Get<SprayList>();
		Deserialize(stream, sprayList, isDelta: false);
		return sprayList;
	}

	public static SprayList DeserializeLengthDelimited(BufferStream stream)
	{
		SprayList sprayList = Pool.Get<SprayList>();
		DeserializeLengthDelimited(stream, sprayList, isDelta: false);
		return sprayList;
	}

	public static SprayList DeserializeLength(BufferStream stream, int length)
	{
		SprayList sprayList = Pool.Get<SprayList>();
		DeserializeLength(stream, length, sprayList, isDelta: false);
		return sprayList;
	}

	public static SprayList Deserialize(byte[] buffer)
	{
		SprayList sprayList = Pool.Get<SprayList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sprayList, isDelta: false);
		return sprayList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SprayList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SprayList Deserialize(BufferStream stream, SprayList instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SprayList DeserializeLengthDelimited(BufferStream stream, SprayList instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SprayList DeserializeLength(BufferStream stream, int length, SprayList instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SprayList instance, SprayList previous)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			LinePoint linePoint = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			LinePoint.SerializeDelta(stream, linePoint, linePoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.LinePoint)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, SprayList instance)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			LinePoint instance2 = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			LinePoint.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.LinePoint)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (linePoints != null)
		{
			for (int i = 0; i < linePoints.Count; i++)
			{
				linePoints[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LinePoint : IDisposable, IPooled, IProto<LinePoint>, IProto
{
	[NonSerialized]
	public Vector3 localPosition;

	[NonSerialized]
	public Vector3 worldNormal;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LinePoint instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.localPosition = default(Vector3);
			instance.worldNormal = default(Vector3);
			Pool.Free<LinePoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LinePoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LinePoint instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.localPosition = localPosition;
		instance.worldNormal = worldNormal;
	}

	public LinePoint Copy()
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		CopyTo(linePoint);
		return linePoint;
	}

	public static LinePoint Deserialize(BufferStream stream)
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		Deserialize(stream, linePoint, isDelta: false);
		return linePoint;
	}

	public static LinePoint DeserializeLengthDelimited(BufferStream stream)
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		DeserializeLengthDelimited(stream, linePoint, isDelta: false);
		return linePoint;
	}

	public static LinePoint DeserializeLength(BufferStream stream, int length)
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		DeserializeLength(stream, length, linePoint, isDelta: false);
		return linePoint;
	}

	public static LinePoint Deserialize(byte[] buffer)
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, linePoint, isDelta: false);
		return linePoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LinePoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LinePoint Deserialize(BufferStream stream, LinePoint instance, bool isDelta)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localPosition, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldNormal, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LinePoint DeserializeLengthDelimited(BufferStream stream, LinePoint instance, bool isDelta)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localPosition, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldNormal, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LinePoint DeserializeLength(BufferStream stream, int length, LinePoint instance, bool isDelta)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localPosition, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldNormal, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LinePoint instance, LinePoint previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (instance.localPosition != previous.localPosition)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.localPosition, previous.localPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.worldNormal != previous.worldNormal)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.worldNormal, previous.worldNormal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldNormal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, LinePoint instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (instance.localPosition != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.localPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.worldNormal != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.worldNormal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldNormal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Zipline : IDisposable, IPooled, IProto<Zipline>, IProto
{
	[NonSerialized]
	public List<VectorData> destinationPoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Zipline instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.destinationPoints != null)
			{
				List<VectorData> list = instance.destinationPoints;
				Pool.FreeUnmanaged<VectorData>(ref list);
				instance.destinationPoints = list;
			}
			Pool.Free<Zipline>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Zipline with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Zipline instance)
	{
		if (destinationPoints != null)
		{
			instance.destinationPoints = Pool.Get<List<VectorData>>();
			for (int i = 0; i < destinationPoints.Count; i++)
			{
				VectorData item = destinationPoints[i];
				instance.destinationPoints.Add(item);
			}
		}
		else
		{
			instance.destinationPoints = null;
		}
	}

	public Zipline Copy()
	{
		Zipline zipline = Pool.Get<Zipline>();
		CopyTo(zipline);
		return zipline;
	}

	public static Zipline Deserialize(BufferStream stream)
	{
		Zipline zipline = Pool.Get<Zipline>();
		Deserialize(stream, zipline, isDelta: false);
		return zipline;
	}

	public static Zipline DeserializeLengthDelimited(BufferStream stream)
	{
		Zipline zipline = Pool.Get<Zipline>();
		DeserializeLengthDelimited(stream, zipline, isDelta: false);
		return zipline;
	}

	public static Zipline DeserializeLength(BufferStream stream, int length)
	{
		Zipline zipline = Pool.Get<Zipline>();
		DeserializeLength(stream, length, zipline, isDelta: false);
		return zipline;
	}

	public static Zipline Deserialize(byte[] buffer)
	{
		Zipline zipline = Pool.Get<Zipline>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, zipline, isDelta: false);
		return zipline;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Zipline previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Zipline Deserialize(BufferStream stream, Zipline instance, bool isDelta)
	{
		if (!isDelta && instance.destinationPoints == null)
		{
			instance.destinationPoints = Pool.Get<List<VectorData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.destinationPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Zipline DeserializeLengthDelimited(BufferStream stream, Zipline instance, bool isDelta)
	{
		if (!isDelta && instance.destinationPoints == null)
		{
			instance.destinationPoints = Pool.Get<List<VectorData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.destinationPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Zipline DeserializeLength(BufferStream stream, int length, Zipline instance, bool isDelta)
	{
		if (!isDelta && instance.destinationPoints == null)
		{
			instance.destinationPoints = Pool.Get<List<VectorData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.destinationPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Zipline instance, Zipline previous)
	{
		if (instance.destinationPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.destinationPoints.Count; i++)
		{
			VectorData vectorData = instance.destinationPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.SerializeDelta(stream, vectorData, vectorData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destinationPoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, Zipline instance)
	{
		if (instance.destinationPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.destinationPoints.Count; i++)
		{
			VectorData instance2 = instance.destinationPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destinationPoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (destinationPoints != null)
		{
			for (int i = 0; i < destinationPoints.Count; i++)
			{
				destinationPoints[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ZiplineMountable : IDisposable, IPooled, IProto<ZiplineMountable>, IProto
{
	[NonSerialized]
	public List<VectorData> linePoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ZiplineMountable instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.linePoints != null)
			{
				List<VectorData> list = instance.linePoints;
				Pool.FreeUnmanaged<VectorData>(ref list);
				instance.linePoints = list;
			}
			Pool.Free<ZiplineMountable>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ZiplineMountable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ZiplineMountable instance)
	{
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				VectorData item = linePoints[i];
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
	}

	public ZiplineMountable Copy()
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		CopyTo(ziplineMountable);
		return ziplineMountable;
	}

	public static ZiplineMountable Deserialize(BufferStream stream)
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		Deserialize(stream, ziplineMountable, isDelta: false);
		return ziplineMountable;
	}

	public static ZiplineMountable DeserializeLengthDelimited(BufferStream stream)
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		DeserializeLengthDelimited(stream, ziplineMountable, isDelta: false);
		return ziplineMountable;
	}

	public static ZiplineMountable DeserializeLength(BufferStream stream, int length)
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		DeserializeLength(stream, length, ziplineMountable, isDelta: false);
		return ziplineMountable;
	}

	public static ZiplineMountable Deserialize(byte[] buffer)
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ziplineMountable, isDelta: false);
		return ziplineMountable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ZiplineMountable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ZiplineMountable Deserialize(BufferStream stream, ZiplineMountable instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static ZiplineMountable DeserializeLengthDelimited(BufferStream stream, ZiplineMountable instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ZiplineMountable DeserializeLength(BufferStream stream, int length, ZiplineMountable instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ZiplineMountable instance, ZiplineMountable previous)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			VectorData vectorData = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.SerializeDelta(stream, vectorData, vectorData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ZiplineMountable instance)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			VectorData instance2 = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (linePoints != null)
		{
			for (int i = 0; i < linePoints.Count; i++)
			{
				linePoints[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ZiplineArrivalPoint : IDisposable, IPooled, IProto<ZiplineArrivalPoint>, IProto
{
	[NonSerialized]
	public List<VectorData> linePoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ZiplineArrivalPoint instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.linePoints != null)
			{
				List<VectorData> list = instance.linePoints;
				Pool.FreeUnmanaged<VectorData>(ref list);
				instance.linePoints = list;
			}
			Pool.Free<ZiplineArrivalPoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ZiplineArrivalPoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ZiplineArrivalPoint instance)
	{
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				VectorData item = linePoints[i];
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
	}

	public ZiplineArrivalPoint Copy()
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		CopyTo(ziplineArrivalPoint);
		return ziplineArrivalPoint;
	}

	public static ZiplineArrivalPoint Deserialize(BufferStream stream)
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		Deserialize(stream, ziplineArrivalPoint, isDelta: false);
		return ziplineArrivalPoint;
	}

	public static ZiplineArrivalPoint DeserializeLengthDelimited(BufferStream stream)
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		DeserializeLengthDelimited(stream, ziplineArrivalPoint, isDelta: false);
		return ziplineArrivalPoint;
	}

	public static ZiplineArrivalPoint DeserializeLength(BufferStream stream, int length)
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		DeserializeLength(stream, length, ziplineArrivalPoint, isDelta: false);
		return ziplineArrivalPoint;
	}

	public static ZiplineArrivalPoint Deserialize(byte[] buffer)
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ziplineArrivalPoint, isDelta: false);
		return ziplineArrivalPoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ZiplineArrivalPoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ZiplineArrivalPoint Deserialize(BufferStream stream, ZiplineArrivalPoint instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static ZiplineArrivalPoint DeserializeLengthDelimited(BufferStream stream, ZiplineArrivalPoint instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ZiplineArrivalPoint DeserializeLength(BufferStream stream, int length, ZiplineArrivalPoint instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ZiplineArrivalPoint instance, ZiplineArrivalPoint previous)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			VectorData vectorData = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.SerializeDelta(stream, vectorData, vectorData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ZiplineArrivalPoint instance)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			VectorData instance2 = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (linePoints != null)
		{
			for (int i = 0; i < linePoints.Count; i++)
			{
				linePoints[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseTrain : IDisposable, IPooled, IProto<BaseTrain>, IProto
{
	[NonSerialized]
	public float time;

	[NonSerialized]
	public float frontBogieYRot;

	[NonSerialized]
	public float rearBogieYRot;

	[NonSerialized]
	public NetworkableId frontCouplingID;

	[NonSerialized]
	public bool frontCouplingToFront;

	[NonSerialized]
	public NetworkableId rearCouplingID;

	[NonSerialized]
	public bool rearCouplingToFront;

	[NonSerialized]
	public int lootTypeIndex;

	[NonSerialized]
	public float lootPercent;

	[NonSerialized]
	public NetworkableId itemStorageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseTrain instance)
	{
		if (instance.ShouldPool)
		{
			instance.time = 0f;
			instance.frontBogieYRot = 0f;
			instance.rearBogieYRot = 0f;
			instance.frontCouplingID = default(NetworkableId);
			instance.frontCouplingToFront = false;
			instance.rearCouplingID = default(NetworkableId);
			instance.rearCouplingToFront = false;
			instance.lootTypeIndex = 0;
			instance.lootPercent = 0f;
			instance.itemStorageID = default(NetworkableId);
			Pool.Free<BaseTrain>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseTrain with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseTrain instance)
	{
		instance.time = time;
		instance.frontBogieYRot = frontBogieYRot;
		instance.rearBogieYRot = rearBogieYRot;
		instance.frontCouplingID = frontCouplingID;
		instance.frontCouplingToFront = frontCouplingToFront;
		instance.rearCouplingID = rearCouplingID;
		instance.rearCouplingToFront = rearCouplingToFront;
		instance.lootTypeIndex = lootTypeIndex;
		instance.lootPercent = lootPercent;
		instance.itemStorageID = itemStorageID;
	}

	public BaseTrain Copy()
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		CopyTo(baseTrain);
		return baseTrain;
	}

	public static BaseTrain Deserialize(BufferStream stream)
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		Deserialize(stream, baseTrain, isDelta: false);
		return baseTrain;
	}

	public static BaseTrain DeserializeLengthDelimited(BufferStream stream)
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		DeserializeLengthDelimited(stream, baseTrain, isDelta: false);
		return baseTrain;
	}

	public static BaseTrain DeserializeLength(BufferStream stream, int length)
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		DeserializeLength(stream, length, baseTrain, isDelta: false);
		return baseTrain;
	}

	public static BaseTrain Deserialize(byte[] buffer)
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseTrain, isDelta: false);
		return baseTrain;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseTrain previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseTrain Deserialize(BufferStream stream, BaseTrain instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.frontBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rearBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.frontCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.frontCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.rearCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 56:
				instance.rearCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lootPercent = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseTrain DeserializeLengthDelimited(BufferStream stream, BaseTrain instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.frontBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rearBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.frontCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.frontCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.rearCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 56:
				instance.rearCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lootPercent = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseTrain DeserializeLength(BufferStream stream, int length, BaseTrain instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.frontBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rearBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.frontCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.frontCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.rearCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 56:
				instance.rearCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lootPercent = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseTrain instance, BaseTrain previous)
	{
		if (instance.time != previous.time)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.frontBogieYRot != previous.frontBogieYRot)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.frontBogieYRot);
		}
		if (instance.rearBogieYRot != previous.rearBogieYRot)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.rearBogieYRot);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.frontCouplingID.Value);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.frontCouplingToFront);
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, instance.rearCouplingID.Value);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.rearCouplingToFront);
		if (instance.lootTypeIndex != previous.lootTypeIndex)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lootTypeIndex);
		}
		if (instance.lootPercent != previous.lootPercent)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lootPercent);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteUInt64(stream, instance.itemStorageID.Value);
	}

	public static void Serialize(BufferStream stream, BaseTrain instance)
	{
		if (instance.time != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.frontBogieYRot != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.frontBogieYRot);
		}
		if (instance.rearBogieYRot != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.rearBogieYRot);
		}
		if (instance.frontCouplingID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.frontCouplingID.Value);
		}
		if (instance.frontCouplingToFront)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.frontCouplingToFront);
		}
		if (instance.rearCouplingID != default(NetworkableId))
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.rearCouplingID.Value);
		}
		if (instance.rearCouplingToFront)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.rearCouplingToFront);
		}
		if (instance.lootTypeIndex != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lootTypeIndex);
		}
		if (instance.lootPercent != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lootPercent);
		}
		if (instance.itemStorageID != default(NetworkableId))
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, instance.itemStorageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref frontCouplingID.Value);
		action(UidType.NetworkableId, ref rearCouplingID.Value);
		action(UidType.NetworkableId, ref itemStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CoalingTower : IDisposable, IPooled, IProto<CoalingTower>, IProto
{
	[NonSerialized]
	public int lootTypeIndex;

	[NonSerialized]
	public NetworkableId oreStorageID;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public NetworkableId activeUnloadableID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CoalingTower instance)
	{
		if (instance.ShouldPool)
		{
			instance.lootTypeIndex = 0;
			instance.oreStorageID = default(NetworkableId);
			instance.fuelStorageID = default(NetworkableId);
			instance.activeUnloadableID = default(NetworkableId);
			Pool.Free<CoalingTower>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CoalingTower with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CoalingTower instance)
	{
		instance.lootTypeIndex = lootTypeIndex;
		instance.oreStorageID = oreStorageID;
		instance.fuelStorageID = fuelStorageID;
		instance.activeUnloadableID = activeUnloadableID;
	}

	public CoalingTower Copy()
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		CopyTo(coalingTower);
		return coalingTower;
	}

	public static CoalingTower Deserialize(BufferStream stream)
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		Deserialize(stream, coalingTower, isDelta: false);
		return coalingTower;
	}

	public static CoalingTower DeserializeLengthDelimited(BufferStream stream)
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		DeserializeLengthDelimited(stream, coalingTower, isDelta: false);
		return coalingTower;
	}

	public static CoalingTower DeserializeLength(BufferStream stream, int length)
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		DeserializeLength(stream, length, coalingTower, isDelta: false);
		return coalingTower;
	}

	public static CoalingTower Deserialize(byte[] buffer)
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, coalingTower, isDelta: false);
		return coalingTower;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CoalingTower previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CoalingTower Deserialize(BufferStream stream, CoalingTower instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oreStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.activeUnloadableID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CoalingTower DeserializeLengthDelimited(BufferStream stream, CoalingTower instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oreStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.activeUnloadableID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CoalingTower DeserializeLength(BufferStream stream, int length, CoalingTower instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oreStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.activeUnloadableID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CoalingTower instance, CoalingTower previous)
	{
		if (instance.lootTypeIndex != previous.lootTypeIndex)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lootTypeIndex);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.oreStorageID.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.activeUnloadableID.Value);
	}

	public static void Serialize(BufferStream stream, CoalingTower instance)
	{
		if (instance.lootTypeIndex != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lootTypeIndex);
		}
		if (instance.oreStorageID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.oreStorageID.Value);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.activeUnloadableID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.activeUnloadableID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref oreStorageID.Value);
		action(UidType.NetworkableId, ref fuelStorageID.Value);
		action(UidType.NetworkableId, ref activeUnloadableID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseOven : IDisposable, IPooled, IProto<BaseOven>, IProto
{
	public class CookingItem : IDisposable, IPooled, IProto<CookingItem>, IProto
	{
		[NonSerialized]
		public int itemID;

		[NonSerialized]
		public int slotIndex;

		[NonSerialized]
		public int initialStackSize;

		[NonSerialized]
		public float cookingProgress;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(CookingItem instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemID = 0;
				instance.slotIndex = 0;
				instance.initialStackSize = 0;
				instance.cookingProgress = 0f;
				Pool.Free<CookingItem>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose CookingItem with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(CookingItem instance)
		{
			instance.itemID = itemID;
			instance.slotIndex = slotIndex;
			instance.initialStackSize = initialStackSize;
			instance.cookingProgress = cookingProgress;
		}

		public CookingItem Copy()
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			CopyTo(cookingItem);
			return cookingItem;
		}

		public static CookingItem Deserialize(BufferStream stream)
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			Deserialize(stream, cookingItem, isDelta: false);
			return cookingItem;
		}

		public static CookingItem DeserializeLengthDelimited(BufferStream stream)
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			DeserializeLengthDelimited(stream, cookingItem, isDelta: false);
			return cookingItem;
		}

		public static CookingItem DeserializeLength(BufferStream stream, int length)
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			DeserializeLength(stream, length, cookingItem, isDelta: false);
			return cookingItem;
		}

		public static CookingItem Deserialize(byte[] buffer)
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, cookingItem, isDelta: false);
			return cookingItem;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, CookingItem previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static CookingItem Deserialize(BufferStream stream, CookingItem instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 37:
					instance.cookingProgress = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static CookingItem DeserializeLengthDelimited(BufferStream stream, CookingItem instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 37:
					instance.cookingProgress = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static CookingItem DeserializeLength(BufferStream stream, int length, CookingItem instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 37:
					instance.cookingProgress = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, CookingItem instance, CookingItem previous)
		{
			if (instance.itemID != previous.itemID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
			}
			if (instance.slotIndex != previous.slotIndex)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
			}
			if (instance.initialStackSize != previous.initialStackSize)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.initialStackSize);
			}
			if (instance.cookingProgress != previous.cookingProgress)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.cookingProgress);
			}
		}

		public static void Serialize(BufferStream stream, CookingItem instance)
		{
			if (instance.itemID != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
			}
			if (instance.slotIndex != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
			}
			if (instance.initialStackSize != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.initialStackSize);
			}
			if (instance.cookingProgress != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.cookingProgress);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public float cookSpeed;

	[NonSerialized]
	public List<CookingItem> cookingItems;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseOven instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.cookSpeed = 0f;
		if (instance.cookingItems != null)
		{
			for (int i = 0; i < instance.cookingItems.Count; i++)
			{
				if (instance.cookingItems[i] != null)
				{
					instance.cookingItems[i].ResetToPool();
					instance.cookingItems[i] = null;
				}
			}
			List<CookingItem> list = instance.cookingItems;
			Pool.Free<CookingItem>(ref list, false);
			instance.cookingItems = list;
		}
		Pool.Free<BaseOven>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseOven with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseOven instance)
	{
		instance.cookSpeed = cookSpeed;
		if (cookingItems != null)
		{
			instance.cookingItems = Pool.Get<List<CookingItem>>();
			for (int i = 0; i < cookingItems.Count; i++)
			{
				CookingItem item = cookingItems[i].Copy();
				instance.cookingItems.Add(item);
			}
		}
		else
		{
			instance.cookingItems = null;
		}
	}

	public BaseOven Copy()
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		CopyTo(baseOven);
		return baseOven;
	}

	public static BaseOven Deserialize(BufferStream stream)
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		Deserialize(stream, baseOven, isDelta: false);
		return baseOven;
	}

	public static BaseOven DeserializeLengthDelimited(BufferStream stream)
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		DeserializeLengthDelimited(stream, baseOven, isDelta: false);
		return baseOven;
	}

	public static BaseOven DeserializeLength(BufferStream stream, int length)
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		DeserializeLength(stream, length, baseOven, isDelta: false);
		return baseOven;
	}

	public static BaseOven Deserialize(byte[] buffer)
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseOven, isDelta: false);
		return baseOven;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseOven previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseOven Deserialize(BufferStream stream, BaseOven instance, bool isDelta)
	{
		if (!isDelta && instance.cookingItems == null)
		{
			instance.cookingItems = Pool.Get<List<CookingItem>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.cookSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				instance.cookingItems.Add(CookingItem.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseOven DeserializeLengthDelimited(BufferStream stream, BaseOven instance, bool isDelta)
	{
		if (!isDelta && instance.cookingItems == null)
		{
			instance.cookingItems = Pool.Get<List<CookingItem>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.cookSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				instance.cookingItems.Add(CookingItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseOven DeserializeLength(BufferStream stream, int length, BaseOven instance, bool isDelta)
	{
		if (!isDelta && instance.cookingItems == null)
		{
			instance.cookingItems = Pool.Get<List<CookingItem>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.cookSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				instance.cookingItems.Add(CookingItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseOven instance, BaseOven previous)
	{
		if (instance.cookSpeed != previous.cookSpeed)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.cookSpeed);
		}
		if (instance.cookingItems == null)
		{
			return;
		}
		for (int i = 0; i < instance.cookingItems.Count; i++)
		{
			CookingItem cookingItem = instance.cookingItems[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			CookingItem.SerializeDelta(stream, cookingItem, cookingItem);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cookingItems (ProtoBuf.BaseOven.CookingItem)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, BaseOven instance)
	{
		if (instance.cookSpeed != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.cookSpeed);
		}
		if (instance.cookingItems == null)
		{
			return;
		}
		for (int i = 0; i < instance.cookingItems.Count; i++)
		{
			CookingItem instance2 = instance.cookingItems[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			CookingItem.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cookingItems (ProtoBuf.BaseOven.CookingItem)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (cookingItems != null)
		{
			for (int i = 0; i < cookingItems.Count; i++)
			{
				cookingItems[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BrainComponent : IDisposable, IPooled, IProto<BrainComponent>, IProto
{
	[NonSerialized]
	public int currentState;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BrainComponent instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentState = 0;
			Pool.Free<BrainComponent>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BrainComponent with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BrainComponent instance)
	{
		instance.currentState = currentState;
	}

	public BrainComponent Copy()
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		CopyTo(brainComponent);
		return brainComponent;
	}

	public static BrainComponent Deserialize(BufferStream stream)
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		Deserialize(stream, brainComponent, isDelta: false);
		return brainComponent;
	}

	public static BrainComponent DeserializeLengthDelimited(BufferStream stream)
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		DeserializeLengthDelimited(stream, brainComponent, isDelta: false);
		return brainComponent;
	}

	public static BrainComponent DeserializeLength(BufferStream stream, int length)
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		DeserializeLength(stream, length, brainComponent, isDelta: false);
		return brainComponent;
	}

	public static BrainComponent Deserialize(byte[] buffer)
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, brainComponent, isDelta: false);
		return brainComponent;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BrainComponent previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BrainComponent Deserialize(BufferStream stream, BrainComponent instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.currentState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BrainComponent DeserializeLengthDelimited(BufferStream stream, BrainComponent instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BrainComponent DeserializeLength(BufferStream stream, int length, BrainComponent instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BrainComponent instance, BrainComponent previous)
	{
		if (instance.currentState != previous.currentState)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentState);
		}
	}

	public static void Serialize(BufferStream stream, BrainComponent instance)
	{
		if (instance.currentState != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentState);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ProceduralDungeon : IDisposable, IPooled, IProto<ProceduralDungeon>, IProto
{
	[NonSerialized]
	public uint seed;

	[NonSerialized]
	public NetworkableId exitPortalID;

	[NonSerialized]
	public Vector3 mapOffset;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ProceduralDungeon instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.seed = 0u;
			instance.exitPortalID = default(NetworkableId);
			instance.mapOffset = default(Vector3);
			Pool.Free<ProceduralDungeon>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ProceduralDungeon with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ProceduralDungeon instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.seed = seed;
		instance.exitPortalID = exitPortalID;
		instance.mapOffset = mapOffset;
	}

	public ProceduralDungeon Copy()
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		CopyTo(proceduralDungeon);
		return proceduralDungeon;
	}

	public static ProceduralDungeon Deserialize(BufferStream stream)
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		Deserialize(stream, proceduralDungeon, isDelta: false);
		return proceduralDungeon;
	}

	public static ProceduralDungeon DeserializeLengthDelimited(BufferStream stream)
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		DeserializeLengthDelimited(stream, proceduralDungeon, isDelta: false);
		return proceduralDungeon;
	}

	public static ProceduralDungeon DeserializeLength(BufferStream stream, int length)
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		DeserializeLength(stream, length, proceduralDungeon, isDelta: false);
		return proceduralDungeon;
	}

	public static ProceduralDungeon Deserialize(byte[] buffer)
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, proceduralDungeon, isDelta: false);
		return proceduralDungeon;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ProceduralDungeon previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ProceduralDungeon Deserialize(BufferStream stream, ProceduralDungeon instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.exitPortalID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mapOffset, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ProceduralDungeon DeserializeLengthDelimited(BufferStream stream, ProceduralDungeon instance, bool isDelta)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.exitPortalID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mapOffset, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ProceduralDungeon DeserializeLength(BufferStream stream, int length, ProceduralDungeon instance, bool isDelta)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.exitPortalID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mapOffset, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ProceduralDungeon instance, ProceduralDungeon previous)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (instance.seed != previous.seed)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.exitPortalID.Value);
		if (instance.mapOffset != previous.mapOffset)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.mapOffset, previous.mapOffset);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mapOffset (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ProceduralDungeon instance)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (instance.seed != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.exitPortalID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.exitPortalID.Value);
		}
		if (instance.mapOffset != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.mapOffset);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mapOffset (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref exitPortalID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class IndustrialConveyor : IDisposable, IPooled, IProto<IndustrialConveyor>, IProto
{
	public class ItemFilter : IDisposable, IPooled, IProto<ItemFilter>, IProto
	{
		[NonSerialized]
		public int itemDef;

		[NonSerialized]
		public int itemCategory;

		[NonSerialized]
		public int maxAmountInDestination;

		[NonSerialized]
		public int isBlueprint;

		[NonSerialized]
		public int bufferAmount;

		[NonSerialized]
		public int retainMinimum;

		[NonSerialized]
		public int bufferTransferRemaining;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ItemFilter instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemDef = 0;
				instance.itemCategory = 0;
				instance.maxAmountInDestination = 0;
				instance.isBlueprint = 0;
				instance.bufferAmount = 0;
				instance.retainMinimum = 0;
				instance.bufferTransferRemaining = 0;
				Pool.Free<ItemFilter>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ItemFilter with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ItemFilter instance)
		{
			instance.itemDef = itemDef;
			instance.itemCategory = itemCategory;
			instance.maxAmountInDestination = maxAmountInDestination;
			instance.isBlueprint = isBlueprint;
			instance.bufferAmount = bufferAmount;
			instance.retainMinimum = retainMinimum;
			instance.bufferTransferRemaining = bufferTransferRemaining;
		}

		public ItemFilter Copy()
		{
			ItemFilter itemFilter = Pool.Get<ItemFilter>();
			CopyTo(itemFilter);
			return itemFilter;
		}

		public static ItemFilter Deserialize(BufferStream stream)
		{
			ItemFilter itemFilter = Pool.Get<ItemFilter>();
			Deserialize(stream, itemFilter, isDelta: false);
			return itemFilter;
		}

		public static ItemFilter DeserializeLengthDelimited(BufferStream stream)
		{
			ItemFilter itemFilter = Pool.Get<ItemFilter>();
			DeserializeLengthDelimited(stream, itemFilter, isDelta: false);
			return itemFilter;
		}

		public static ItemFilter DeserializeLength(BufferStream stream, int length)
		{
			ItemFilter itemFilter = Pool.Get<ItemFilter>();
			DeserializeLength(stream, length, itemFilter, isDelta: false);
			return itemFilter;
		}

		public static ItemFilter Deserialize(byte[] buffer)
		{
			ItemFilter itemFilter = Pool.Get<ItemFilter>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, itemFilter, isDelta: false);
			return itemFilter;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ItemFilter previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ItemFilter Deserialize(BufferStream stream, ItemFilter instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ItemFilter DeserializeLengthDelimited(BufferStream stream, ItemFilter instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ItemFilter DeserializeLength(BufferStream stream, int length, ItemFilter instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ItemFilter instance, ItemFilter previous)
		{
			if (instance.itemDef != previous.itemDef)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemDef);
			}
			if (instance.itemCategory != previous.itemCategory)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCategory);
			}
			if (instance.maxAmountInDestination != previous.maxAmountInDestination)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.maxAmountInDestination);
			}
			if (instance.isBlueprint != previous.isBlueprint)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.isBlueprint);
			}
			if (instance.bufferAmount != previous.bufferAmount)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferAmount);
			}
			if (instance.retainMinimum != previous.retainMinimum)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.retainMinimum);
			}
			if (instance.bufferTransferRemaining != previous.bufferTransferRemaining)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferTransferRemaining);
			}
		}

		public static void Serialize(BufferStream stream, ItemFilter instance)
		{
			if (instance.itemDef != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemDef);
			}
			if (instance.itemCategory != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCategory);
			}
			if (instance.maxAmountInDestination != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.maxAmountInDestination);
			}
			if (instance.isBlueprint != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.isBlueprint);
			}
			if (instance.bufferAmount != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferAmount);
			}
			if (instance.retainMinimum != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.retainMinimum);
			}
			if (instance.bufferTransferRemaining != 0)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferTransferRemaining);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class ItemFilterList : IDisposable, IPooled, IProto<ItemFilterList>, IProto
	{
		[NonSerialized]
		public List<ItemFilter> filters;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ItemFilterList instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.filters != null)
			{
				for (int i = 0; i < instance.filters.Count; i++)
				{
					if (instance.filters[i] != null)
					{
						instance.filters[i].ResetToPool();
						instance.filters[i] = null;
					}
				}
				List<ItemFilter> list = instance.filters;
				Pool.Free<ItemFilter>(ref list, false);
				instance.filters = list;
			}
			Pool.Free<ItemFilterList>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ItemFilterList with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ItemFilterList instance)
		{
			if (filters != null)
			{
				instance.filters = Pool.Get<List<ItemFilter>>();
				for (int i = 0; i < filters.Count; i++)
				{
					ItemFilter item = filters[i].Copy();
					instance.filters.Add(item);
				}
			}
			else
			{
				instance.filters = null;
			}
		}

		public ItemFilterList Copy()
		{
			ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
			CopyTo(itemFilterList);
			return itemFilterList;
		}

		public static ItemFilterList Deserialize(BufferStream stream)
		{
			ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
			Deserialize(stream, itemFilterList, isDelta: false);
			return itemFilterList;
		}

		public static ItemFilterList DeserializeLengthDelimited(BufferStream stream)
		{
			ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
			DeserializeLengthDelimited(stream, itemFilterList, isDelta: false);
			return itemFilterList;
		}

		public static ItemFilterList DeserializeLength(BufferStream stream, int length)
		{
			ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
			DeserializeLength(stream, length, itemFilterList, isDelta: false);
			return itemFilterList;
		}

		public static ItemFilterList Deserialize(byte[] buffer)
		{
			ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, itemFilterList, isDelta: false);
			return itemFilterList;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ItemFilterList previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ItemFilterList Deserialize(BufferStream stream, ItemFilterList instance, bool isDelta)
		{
			if (!isDelta && instance.filters == null)
			{
				instance.filters = Pool.Get<List<ItemFilter>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ItemFilterList DeserializeLengthDelimited(BufferStream stream, ItemFilterList instance, bool isDelta)
		{
			if (!isDelta && instance.filters == null)
			{
				instance.filters = Pool.Get<List<ItemFilter>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ItemFilterList DeserializeLength(BufferStream stream, int length, ItemFilterList instance, bool isDelta)
		{
			if (!isDelta && instance.filters == null)
			{
				instance.filters = Pool.Get<List<ItemFilter>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ItemFilterList instance, ItemFilterList previous)
		{
			if (instance.filters == null)
			{
				return;
			}
			for (int i = 0; i < instance.filters.Count; i++)
			{
				ItemFilter itemFilter = instance.filters[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ItemFilter.SerializeDelta(stream, itemFilter, itemFilter);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field filters (ProtoBuf.IndustrialConveyor.ItemFilter)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}

		public static void Serialize(BufferStream stream, ItemFilterList instance)
		{
			if (instance.filters == null)
			{
				return;
			}
			for (int i = 0; i < instance.filters.Count; i++)
			{
				ItemFilter instance2 = instance.filters[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ItemFilter.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field filters (ProtoBuf.IndustrialConveyor.ItemFilter)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (filters != null)
			{
				for (int i = 0; i < filters.Count; i++)
				{
					filters[i]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public List<ItemFilter> filters;

	[NonSerialized]
	public int conveyorMode;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(IndustrialConveyor instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.filters != null)
		{
			for (int i = 0; i < instance.filters.Count; i++)
			{
				if (instance.filters[i] != null)
				{
					instance.filters[i].ResetToPool();
					instance.filters[i] = null;
				}
			}
			List<ItemFilter> list = instance.filters;
			Pool.Free<ItemFilter>(ref list, false);
			instance.filters = list;
		}
		instance.conveyorMode = 0;
		Pool.Free<IndustrialConveyor>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose IndustrialConveyor with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(IndustrialConveyor instance)
	{
		if (filters != null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
			for (int i = 0; i < filters.Count; i++)
			{
				ItemFilter item = filters[i].Copy();
				instance.filters.Add(item);
			}
		}
		else
		{
			instance.filters = null;
		}
		instance.conveyorMode = conveyorMode;
	}

	public IndustrialConveyor Copy()
	{
		IndustrialConveyor industrialConveyor = Pool.Get<IndustrialConveyor>();
		CopyTo(industrialConveyor);
		return industrialConveyor;
	}

	public static IndustrialConveyor Deserialize(BufferStream stream)
	{
		IndustrialConveyor industrialConveyor = Pool.Get<IndustrialConveyor>();
		Deserialize(stream, industrialConveyor, isDelta: false);
		return industrialConveyor;
	}

	public static IndustrialConveyor DeserializeLengthDelimited(BufferStream stream)
	{
		IndustrialConveyor industrialConveyor = Pool.Get<IndustrialConveyor>();
		DeserializeLengthDelimited(stream, industrialConveyor, isDelta: false);
		return industrialConveyor;
	}

	public static IndustrialConveyor DeserializeLength(BufferStream stream, int length)
	{
		IndustrialConveyor industrialConveyor = Pool.Get<IndustrialConveyor>();
		DeserializeLength(stream, length, industrialConveyor, isDelta: false);
		return industrialConveyor;
	}

	public static IndustrialConveyor Deserialize(byte[] buffer)
	{
		IndustrialConveyor industrialConveyor = Pool.Get<IndustrialConveyor>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, industrialConveyor, isDelta: false);
		return industrialConveyor;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, IndustrialConveyor previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static IndustrialConveyor Deserialize(BufferStream stream, IndustrialConveyor instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.conveyorMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static IndustrialConveyor DeserializeLengthDelimited(BufferStream stream, IndustrialConveyor instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.conveyorMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static IndustrialConveyor DeserializeLength(BufferStream stream, int length, IndustrialConveyor instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.conveyorMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, IndustrialConveyor instance, IndustrialConveyor previous)
	{
		if (instance.filters != null)
		{
			for (int i = 0; i < instance.filters.Count; i++)
			{
				ItemFilter itemFilter = instance.filters[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ItemFilter.SerializeDelta(stream, itemFilter, itemFilter);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field filters (ProtoBuf.IndustrialConveyor.ItemFilter)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.conveyorMode != previous.conveyorMode)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.conveyorMode);
		}
	}

	public static void Serialize(BufferStream stream, IndustrialConveyor instance)
	{
		if (instance.filters != null)
		{
			for (int i = 0; i < instance.filters.Count; i++)
			{
				ItemFilter instance2 = instance.filters[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ItemFilter.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field filters (ProtoBuf.IndustrialConveyor.ItemFilter)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.conveyorMode != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.conveyorMode);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (filters != null)
		{
			for (int i = 0; i < filters.Count; i++)
			{
				filters[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class IndustrialCrafter : IDisposable, IPooled, IProto<IndustrialCrafter>, IProto
{
	[NonSerialized]
	public int currentlyCrafting;

	[NonSerialized]
	public int currentlyCraftingAmount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(IndustrialCrafter instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentlyCrafting = 0;
			instance.currentlyCraftingAmount = 0;
			Pool.Free<IndustrialCrafter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose IndustrialCrafter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(IndustrialCrafter instance)
	{
		instance.currentlyCrafting = currentlyCrafting;
		instance.currentlyCraftingAmount = currentlyCraftingAmount;
	}

	public IndustrialCrafter Copy()
	{
		IndustrialCrafter industrialCrafter = Pool.Get<IndustrialCrafter>();
		CopyTo(industrialCrafter);
		return industrialCrafter;
	}

	public static IndustrialCrafter Deserialize(BufferStream stream)
	{
		IndustrialCrafter industrialCrafter = Pool.Get<IndustrialCrafter>();
		Deserialize(stream, industrialCrafter, isDelta: false);
		return industrialCrafter;
	}

	public static IndustrialCrafter DeserializeLengthDelimited(BufferStream stream)
	{
		IndustrialCrafter industrialCrafter = Pool.Get<IndustrialCrafter>();
		DeserializeLengthDelimited(stream, industrialCrafter, isDelta: false);
		return industrialCrafter;
	}

	public static IndustrialCrafter DeserializeLength(BufferStream stream, int length)
	{
		IndustrialCrafter industrialCrafter = Pool.Get<IndustrialCrafter>();
		DeserializeLength(stream, length, industrialCrafter, isDelta: false);
		return industrialCrafter;
	}

	public static IndustrialCrafter Deserialize(byte[] buffer)
	{
		IndustrialCrafter industrialCrafter = Pool.Get<IndustrialCrafter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, industrialCrafter, isDelta: false);
		return industrialCrafter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, IndustrialCrafter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static IndustrialCrafter Deserialize(BufferStream stream, IndustrialCrafter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.currentlyCrafting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.currentlyCraftingAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static IndustrialCrafter DeserializeLengthDelimited(BufferStream stream, IndustrialCrafter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentlyCrafting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.currentlyCraftingAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static IndustrialCrafter DeserializeLength(BufferStream stream, int length, IndustrialCrafter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentlyCrafting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.currentlyCraftingAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, IndustrialCrafter instance, IndustrialCrafter previous)
	{
		if (instance.currentlyCrafting != previous.currentlyCrafting)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentlyCrafting);
		}
		if (instance.currentlyCraftingAmount != previous.currentlyCraftingAmount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentlyCraftingAmount);
		}
	}

	public static void Serialize(BufferStream stream, IndustrialCrafter instance)
	{
		if (instance.currentlyCrafting != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentlyCrafting);
		}
		if (instance.currentlyCraftingAmount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentlyCraftingAmount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class IndustrialConveyorTransfer : IDisposable, IPooled, IProto<IndustrialConveyorTransfer>, IProto
{
	public struct ItemTransfer : IProto<ItemTransfer>, IProto
	{
		[NonSerialized]
		public int itemId;

		[NonSerialized]
		public int amount;

		public static void ResetToPool(ItemTransfer instance)
		{
			instance.itemId = 0;
			instance.amount = 0;
		}

		public void CopyTo(ItemTransfer instance)
		{
			instance.itemId = itemId;
			instance.amount = amount;
		}

		public ItemTransfer Copy()
		{
			ItemTransfer itemTransfer = default(ItemTransfer);
			CopyTo(itemTransfer);
			return itemTransfer;
		}

		public static ItemTransfer Deserialize(BufferStream stream)
		{
			ItemTransfer instance = default(ItemTransfer);
			Deserialize(stream, ref instance, isDelta: false);
			return instance;
		}

		public static ItemTransfer DeserializeLengthDelimited(BufferStream stream)
		{
			ItemTransfer instance = default(ItemTransfer);
			DeserializeLengthDelimited(stream, ref instance, isDelta: false);
			return instance;
		}

		public static ItemTransfer DeserializeLength(BufferStream stream, int length)
		{
			ItemTransfer instance = default(ItemTransfer);
			DeserializeLength(stream, length, ref instance, isDelta: false);
			return instance;
		}

		public static ItemTransfer Deserialize(byte[] buffer)
		{
			ItemTransfer instance = default(ItemTransfer);
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, ref instance, isDelta: false);
			return instance;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, ref this, isDelta);
		}

		public void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void WriteToStreamDelta(BufferStream stream, ItemTransfer previous)
		{
			SerializeDelta(stream, this, previous);
		}

		public void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, ref this, isDelta);
		}

		public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, ref this, isDelta);
		}

		public static ItemTransfer Deserialize(BufferStream stream, ref ItemTransfer instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ItemTransfer DeserializeLengthDelimited(BufferStream stream, ref ItemTransfer instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ItemTransfer DeserializeLength(BufferStream stream, int length, ref ItemTransfer instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ItemTransfer instance, ItemTransfer previous)
		{
			if (instance.itemId != previous.itemId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.amount != previous.amount)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
			}
		}

		public static void Serialize(BufferStream stream, ItemTransfer instance)
		{
			if (instance.itemId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.amount != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<ItemTransfer> ItemTransfers;

	[NonSerialized]
	public List<NetworkableId> inputEntities;

	[NonSerialized]
	public List<NetworkableId> outputEntities;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(IndustrialConveyorTransfer instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.ItemTransfers != null)
			{
				List<ItemTransfer> itemTransfers = instance.ItemTransfers;
				Pool.FreeUnmanaged<ItemTransfer>(ref itemTransfers);
				instance.ItemTransfers = itemTransfers;
			}
			if (instance.inputEntities != null)
			{
				List<NetworkableId> list = instance.inputEntities;
				Pool.FreeUnmanaged<NetworkableId>(ref list);
				instance.inputEntities = list;
			}
			if (instance.outputEntities != null)
			{
				List<NetworkableId> list2 = instance.outputEntities;
				Pool.FreeUnmanaged<NetworkableId>(ref list2);
				instance.outputEntities = list2;
			}
			Pool.Free<IndustrialConveyorTransfer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose IndustrialConveyorTransfer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(IndustrialConveyorTransfer instance)
	{
		if (ItemTransfers != null)
		{
			instance.ItemTransfers = Pool.Get<List<ItemTransfer>>();
			for (int i = 0; i < ItemTransfers.Count; i++)
			{
				ItemTransfer item = ItemTransfers[i];
				instance.ItemTransfers.Add(item);
			}
		}
		else
		{
			instance.ItemTransfers = null;
		}
		if (inputEntities != null)
		{
			instance.inputEntities = Pool.Get<List<NetworkableId>>();
			for (int j = 0; j < inputEntities.Count; j++)
			{
				NetworkableId item2 = inputEntities[j];
				instance.inputEntities.Add(item2);
			}
		}
		else
		{
			instance.inputEntities = null;
		}
		if (outputEntities != null)
		{
			instance.outputEntities = Pool.Get<List<NetworkableId>>();
			for (int k = 0; k < outputEntities.Count; k++)
			{
				NetworkableId item3 = outputEntities[k];
				instance.outputEntities.Add(item3);
			}
		}
		else
		{
			instance.outputEntities = null;
		}
	}

	public IndustrialConveyorTransfer Copy()
	{
		IndustrialConveyorTransfer industrialConveyorTransfer = Pool.Get<IndustrialConveyorTransfer>();
		CopyTo(industrialConveyorTransfer);
		return industrialConveyorTransfer;
	}

	public static IndustrialConveyorTransfer Deserialize(BufferStream stream)
	{
		IndustrialConveyorTransfer industrialConveyorTransfer = Pool.Get<IndustrialConveyorTransfer>();
		Deserialize(stream, industrialConveyorTransfer, isDelta: false);
		return industrialConveyorTransfer;
	}

	public static IndustrialConveyorTransfer DeserializeLengthDelimited(BufferStream stream)
	{
		IndustrialConveyorTransfer industrialConveyorTransfer = Pool.Get<IndustrialConveyorTransfer>();
		DeserializeLengthDelimited(stream, industrialConveyorTransfer, isDelta: false);
		return industrialConveyorTransfer;
	}

	public static IndustrialConveyorTransfer DeserializeLength(BufferStream stream, int length)
	{
		IndustrialConveyorTransfer industrialConveyorTransfer = Pool.Get<IndustrialConveyorTransfer>();
		DeserializeLength(stream, length, industrialConveyorTransfer, isDelta: false);
		return industrialConveyorTransfer;
	}

	public static IndustrialConveyorTransfer Deserialize(byte[] buffer)
	{
		IndustrialConveyorTransfer industrialConveyorTransfer = Pool.Get<IndustrialConveyorTransfer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, industrialConveyorTransfer, isDelta: false);
		return industrialConveyorTransfer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, IndustrialConveyorTransfer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static IndustrialConveyorTransfer Deserialize(BufferStream stream, IndustrialConveyorTransfer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.ItemTransfers == null)
			{
				instance.ItemTransfers = Pool.Get<List<ItemTransfer>>();
			}
			if (instance.inputEntities == null)
			{
				instance.inputEntities = Pool.Get<List<NetworkableId>>();
			}
			if (instance.outputEntities == null)
			{
				instance.outputEntities = Pool.Get<List<NetworkableId>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				ItemTransfer instance2 = default(ItemTransfer);
				ItemTransfer.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.ItemTransfers.Add(instance2);
				break;
			}
			case 16:
				instance.inputEntities.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				break;
			case 24:
				instance.outputEntities.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static IndustrialConveyorTransfer DeserializeLengthDelimited(BufferStream stream, IndustrialConveyorTransfer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.ItemTransfers == null)
			{
				instance.ItemTransfers = Pool.Get<List<ItemTransfer>>();
			}
			if (instance.inputEntities == null)
			{
				instance.inputEntities = Pool.Get<List<NetworkableId>>();
			}
			if (instance.outputEntities == null)
			{
				instance.outputEntities = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				ItemTransfer instance2 = default(ItemTransfer);
				ItemTransfer.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.ItemTransfers.Add(instance2);
				break;
			}
			case 16:
				instance.inputEntities.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				break;
			case 24:
				instance.outputEntities.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static IndustrialConveyorTransfer DeserializeLength(BufferStream stream, int length, IndustrialConveyorTransfer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.ItemTransfers == null)
			{
				instance.ItemTransfers = Pool.Get<List<ItemTransfer>>();
			}
			if (instance.inputEntities == null)
			{
				instance.inputEntities = Pool.Get<List<NetworkableId>>();
			}
			if (instance.outputEntities == null)
			{
				instance.outputEntities = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				ItemTransfer instance2 = default(ItemTransfer);
				ItemTransfer.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.ItemTransfers.Add(instance2);
				break;
			}
			case 16:
				instance.inputEntities.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				break;
			case 24:
				instance.outputEntities.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, IndustrialConveyorTransfer instance, IndustrialConveyorTransfer previous)
	{
		if (instance.ItemTransfers != null)
		{
			for (int i = 0; i < instance.ItemTransfers.Count; i++)
			{
				ItemTransfer itemTransfer = instance.ItemTransfers[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ItemTransfer.SerializeDelta(stream, itemTransfer, itemTransfer);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ItemTransfers (ProtoBuf.IndustrialConveyorTransfer.ItemTransfer)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.inputEntities != null)
		{
			for (int j = 0; j < instance.inputEntities.Count; j++)
			{
				NetworkableId networkableId = instance.inputEntities[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
		if (instance.outputEntities != null)
		{
			for (int k = 0; k < instance.outputEntities.Count; k++)
			{
				NetworkableId networkableId2 = instance.outputEntities[k];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, networkableId2.Value);
			}
		}
	}

	public static void Serialize(BufferStream stream, IndustrialConveyorTransfer instance)
	{
		if (instance.ItemTransfers != null)
		{
			for (int i = 0; i < instance.ItemTransfers.Count; i++)
			{
				ItemTransfer instance2 = instance.ItemTransfers[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ItemTransfer.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ItemTransfers (ProtoBuf.IndustrialConveyorTransfer.ItemTransfer)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.inputEntities != null)
		{
			for (int j = 0; j < instance.inputEntities.Count; j++)
			{
				NetworkableId networkableId = instance.inputEntities[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
		if (instance.outputEntities != null)
		{
			for (int k = 0; k < instance.outputEntities.Count; k++)
			{
				NetworkableId networkableId2 = instance.outputEntities[k];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, networkableId2.Value);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (ItemTransfers != null)
		{
			for (int i = 0; i < ItemTransfers.Count; i++)
			{
				ItemTransfers[i].InspectUids(action);
			}
		}
		for (int j = 0; j < inputEntities.Count; j++)
		{
			NetworkableId value = inputEntities[j];
			action(UidType.NetworkableId, ref value.Value);
			inputEntities[j] = value;
		}
		for (int k = 0; k < outputEntities.Count; k++)
		{
			NetworkableId value2 = outputEntities[k];
			action(UidType.NetworkableId, ref value2.Value);
			outputEntities[k] = value2;
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Drone : IDisposable, IPooled, IProto<Drone>, IProto
{
	[NonSerialized]
	public float pitch;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Drone instance)
	{
		if (instance.ShouldPool)
		{
			instance.pitch = 0f;
			Pool.Free<Drone>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Drone with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Drone instance)
	{
		instance.pitch = pitch;
	}

	public Drone Copy()
	{
		Drone drone = Pool.Get<Drone>();
		CopyTo(drone);
		return drone;
	}

	public static Drone Deserialize(BufferStream stream)
	{
		Drone drone = Pool.Get<Drone>();
		Deserialize(stream, drone, isDelta: false);
		return drone;
	}

	public static Drone DeserializeLengthDelimited(BufferStream stream)
	{
		Drone drone = Pool.Get<Drone>();
		DeserializeLengthDelimited(stream, drone, isDelta: false);
		return drone;
	}

	public static Drone DeserializeLength(BufferStream stream, int length)
	{
		Drone drone = Pool.Get<Drone>();
		DeserializeLength(stream, length, drone, isDelta: false);
		return drone;
	}

	public static Drone Deserialize(byte[] buffer)
	{
		Drone drone = Pool.Get<Drone>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, drone, isDelta: false);
		return drone;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Drone previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Drone Deserialize(BufferStream stream, Drone instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Drone DeserializeLengthDelimited(BufferStream stream, Drone instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Drone DeserializeLength(BufferStream stream, int length, Drone instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Drone instance, Drone previous)
	{
		if (instance.pitch != previous.pitch)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
	}

	public static void Serialize(BufferStream stream, Drone instance)
	{
		if (instance.pitch != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TimedExplosive : IDisposable, IPooled, IProto<TimedExplosive>, IProto
{
	[NonSerialized]
	public NetworkableId parentid;

	[NonSerialized]
	public Vector3 pos;

	[NonSerialized]
	public Vector3 normal;

	[NonSerialized]
	public bool rfOn;

	[NonSerialized]
	public int freq;

	[NonSerialized]
	public ulong creatorID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TimedExplosive instance)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.parentid = default(NetworkableId);
			instance.pos = default(Vector3);
			instance.normal = default(Vector3);
			instance.rfOn = false;
			instance.freq = 0;
			instance.creatorID = 0uL;
			Pool.Free<TimedExplosive>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TimedExplosive with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TimedExplosive instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.parentid = parentid;
		instance.pos = pos;
		instance.normal = normal;
		instance.rfOn = rfOn;
		instance.freq = freq;
		instance.creatorID = creatorID;
	}

	public TimedExplosive Copy()
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		CopyTo(timedExplosive);
		return timedExplosive;
	}

	public static TimedExplosive Deserialize(BufferStream stream)
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		Deserialize(stream, timedExplosive, isDelta: false);
		return timedExplosive;
	}

	public static TimedExplosive DeserializeLengthDelimited(BufferStream stream)
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		DeserializeLengthDelimited(stream, timedExplosive, isDelta: false);
		return timedExplosive;
	}

	public static TimedExplosive DeserializeLength(BufferStream stream, int length)
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		DeserializeLength(stream, length, timedExplosive, isDelta: false);
		return timedExplosive;
	}

	public static TimedExplosive Deserialize(byte[] buffer)
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, timedExplosive, isDelta: false);
		return timedExplosive;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TimedExplosive previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TimedExplosive Deserialize(BufferStream stream, TimedExplosive instance, bool isDelta)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 32:
				instance.rfOn = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.freq = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.creatorID = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TimedExplosive DeserializeLengthDelimited(BufferStream stream, TimedExplosive instance, bool isDelta)
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 32:
				instance.rfOn = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.freq = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.creatorID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TimedExplosive DeserializeLength(BufferStream stream, int length, TimedExplosive instance, bool isDelta)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 32:
				instance.rfOn = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.freq = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.creatorID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TimedExplosive instance, TimedExplosive previous)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.parentid.Value);
		if (instance.pos != previous.pos)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.pos, previous.pos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != previous.normal)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.rfOn);
		if (instance.freq != previous.freq)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.freq);
		}
		if (instance.creatorID != previous.creatorID)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.creatorID);
		}
	}

	public static void Serialize(BufferStream stream, TimedExplosive instance)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (instance.parentid != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentid.Value);
		}
		if (instance.pos != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.pos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rfOn)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.rfOn);
		}
		if (instance.freq != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.freq);
		}
		if (instance.creatorID != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.creatorID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref parentid.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AttackHeli : IDisposable, IPooled, IProto<AttackHeli>, IProto
{
	[NonSerialized]
	public NetworkableId turretID;

	[NonSerialized]
	public NetworkableId rocketsID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AttackHeli instance)
	{
		if (instance.ShouldPool)
		{
			instance.turretID = default(NetworkableId);
			instance.rocketsID = default(NetworkableId);
			Pool.Free<AttackHeli>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AttackHeli with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AttackHeli instance)
	{
		instance.turretID = turretID;
		instance.rocketsID = rocketsID;
	}

	public AttackHeli Copy()
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		CopyTo(attackHeli);
		return attackHeli;
	}

	public static AttackHeli Deserialize(BufferStream stream)
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		Deserialize(stream, attackHeli, isDelta: false);
		return attackHeli;
	}

	public static AttackHeli DeserializeLengthDelimited(BufferStream stream)
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		DeserializeLengthDelimited(stream, attackHeli, isDelta: false);
		return attackHeli;
	}

	public static AttackHeli DeserializeLength(BufferStream stream, int length)
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		DeserializeLength(stream, length, attackHeli, isDelta: false);
		return attackHeli;
	}

	public static AttackHeli Deserialize(byte[] buffer)
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, attackHeli, isDelta: false);
		return attackHeli;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AttackHeli previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AttackHeli Deserialize(BufferStream stream, AttackHeli instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.turretID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.rocketsID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AttackHeli DeserializeLengthDelimited(BufferStream stream, AttackHeli instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.turretID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.rocketsID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AttackHeli DeserializeLength(BufferStream stream, int length, AttackHeli instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.turretID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.rocketsID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AttackHeli instance, AttackHeli previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.turretID.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.rocketsID.Value);
	}

	public static void Serialize(BufferStream stream, AttackHeli instance)
	{
		if (instance.turretID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.turretID.Value);
		}
		if (instance.rocketsID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.rocketsID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref turretID.Value);
		action(UidType.NetworkableId, ref rocketsID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AttackHeliTurret : IDisposable, IPooled, IProto<AttackHeliTurret>, IProto
{
	[NonSerialized]
	public int clipAmmo;

	[NonSerialized]
	public int totalAmmo;

	[NonSerialized]
	public int gunState;

	[NonSerialized]
	public float xRot;

	[NonSerialized]
	public float yRot;

	[NonSerialized]
	public NetworkableId heldEntityID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AttackHeliTurret instance)
	{
		if (instance.ShouldPool)
		{
			instance.clipAmmo = 0;
			instance.totalAmmo = 0;
			instance.gunState = 0;
			instance.xRot = 0f;
			instance.yRot = 0f;
			instance.heldEntityID = default(NetworkableId);
			Pool.Free<AttackHeliTurret>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AttackHeliTurret with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AttackHeliTurret instance)
	{
		instance.clipAmmo = clipAmmo;
		instance.totalAmmo = totalAmmo;
		instance.gunState = gunState;
		instance.xRot = xRot;
		instance.yRot = yRot;
		instance.heldEntityID = heldEntityID;
	}

	public AttackHeliTurret Copy()
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		CopyTo(attackHeliTurret);
		return attackHeliTurret;
	}

	public static AttackHeliTurret Deserialize(BufferStream stream)
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		Deserialize(stream, attackHeliTurret, isDelta: false);
		return attackHeliTurret;
	}

	public static AttackHeliTurret DeserializeLengthDelimited(BufferStream stream)
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		DeserializeLengthDelimited(stream, attackHeliTurret, isDelta: false);
		return attackHeliTurret;
	}

	public static AttackHeliTurret DeserializeLength(BufferStream stream, int length)
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		DeserializeLength(stream, length, attackHeliTurret, isDelta: false);
		return attackHeliTurret;
	}

	public static AttackHeliTurret Deserialize(byte[] buffer)
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, attackHeliTurret, isDelta: false);
		return attackHeliTurret;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AttackHeliTurret previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AttackHeliTurret Deserialize(BufferStream stream, AttackHeliTurret instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clipAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.gunState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.xRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.heldEntityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AttackHeliTurret DeserializeLengthDelimited(BufferStream stream, AttackHeliTurret instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clipAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.gunState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.xRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.heldEntityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AttackHeliTurret DeserializeLength(BufferStream stream, int length, AttackHeliTurret instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clipAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.gunState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.xRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.heldEntityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AttackHeliTurret instance, AttackHeliTurret previous)
	{
		if (instance.clipAmmo != previous.clipAmmo)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clipAmmo);
		}
		if (instance.totalAmmo != previous.totalAmmo)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAmmo);
		}
		if (instance.gunState != previous.gunState)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gunState);
		}
		if (instance.xRot != previous.xRot)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.xRot);
		}
		if (instance.yRot != previous.yRot)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.yRot);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, instance.heldEntityID.Value);
	}

	public static void Serialize(BufferStream stream, AttackHeliTurret instance)
	{
		if (instance.clipAmmo != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clipAmmo);
		}
		if (instance.totalAmmo != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAmmo);
		}
		if (instance.gunState != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gunState);
		}
		if (instance.xRot != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.xRot);
		}
		if (instance.yRot != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.yRot);
		}
		if (instance.heldEntityID != default(NetworkableId))
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.heldEntityID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref heldEntityID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AttackHeliRockets : IDisposable, IPooled, IProto<AttackHeliRockets>, IProto
{
	[NonSerialized]
	public int totalAmmo;

	[NonSerialized]
	public int rocketsSinceReload;

	[NonSerialized]
	public bool hasFlares;

	[NonSerialized]
	public int ammoItemID;

	[NonSerialized]
	public int preferredAmmoType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AttackHeliRockets instance)
	{
		if (instance.ShouldPool)
		{
			instance.totalAmmo = 0;
			instance.rocketsSinceReload = 0;
			instance.hasFlares = false;
			instance.ammoItemID = 0;
			instance.preferredAmmoType = 0;
			Pool.Free<AttackHeliRockets>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AttackHeliRockets with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AttackHeliRockets instance)
	{
		instance.totalAmmo = totalAmmo;
		instance.rocketsSinceReload = rocketsSinceReload;
		instance.hasFlares = hasFlares;
		instance.ammoItemID = ammoItemID;
		instance.preferredAmmoType = preferredAmmoType;
	}

	public AttackHeliRockets Copy()
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		CopyTo(attackHeliRockets);
		return attackHeliRockets;
	}

	public static AttackHeliRockets Deserialize(BufferStream stream)
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		Deserialize(stream, attackHeliRockets, isDelta: false);
		return attackHeliRockets;
	}

	public static AttackHeliRockets DeserializeLengthDelimited(BufferStream stream)
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		DeserializeLengthDelimited(stream, attackHeliRockets, isDelta: false);
		return attackHeliRockets;
	}

	public static AttackHeliRockets DeserializeLength(BufferStream stream, int length)
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		DeserializeLength(stream, length, attackHeliRockets, isDelta: false);
		return attackHeliRockets;
	}

	public static AttackHeliRockets Deserialize(byte[] buffer)
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, attackHeliRockets, isDelta: false);
		return attackHeliRockets;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AttackHeliRockets previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AttackHeliRockets Deserialize(BufferStream stream, AttackHeliRockets instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rocketsSinceReload = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.hasFlares = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.ammoItemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.preferredAmmoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AttackHeliRockets DeserializeLengthDelimited(BufferStream stream, AttackHeliRockets instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rocketsSinceReload = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.hasFlares = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.ammoItemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.preferredAmmoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AttackHeliRockets DeserializeLength(BufferStream stream, int length, AttackHeliRockets instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rocketsSinceReload = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.hasFlares = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.ammoItemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.preferredAmmoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AttackHeliRockets instance, AttackHeliRockets previous)
	{
		if (instance.totalAmmo != previous.totalAmmo)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAmmo);
		}
		if (instance.rocketsSinceReload != previous.rocketsSinceReload)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rocketsSinceReload);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.hasFlares);
		if (instance.ammoItemID != previous.ammoItemID)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoItemID);
		}
		if (instance.preferredAmmoType != previous.preferredAmmoType)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.preferredAmmoType);
		}
	}

	public static void Serialize(BufferStream stream, AttackHeliRockets instance)
	{
		if (instance.totalAmmo != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAmmo);
		}
		if (instance.rocketsSinceReload != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rocketsSinceReload);
		}
		if (instance.hasFlares)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.hasFlares);
		}
		if (instance.ammoItemID != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoItemID);
		}
		if (instance.preferredAmmoType != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.preferredAmmoType);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanManager : IDisposable, IPooled, IProto<ClanManager>, IProto
{
	[NonSerialized]
	public string backendType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanManager instance)
	{
		if (instance.ShouldPool)
		{
			instance.backendType = string.Empty;
			Pool.Free<ClanManager>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanManager with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanManager instance)
	{
		instance.backendType = backendType;
	}

	public ClanManager Copy()
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		CopyTo(clanManager);
		return clanManager;
	}

	public static ClanManager Deserialize(BufferStream stream)
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		Deserialize(stream, clanManager, isDelta: false);
		return clanManager;
	}

	public static ClanManager DeserializeLengthDelimited(BufferStream stream)
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		DeserializeLengthDelimited(stream, clanManager, isDelta: false);
		return clanManager;
	}

	public static ClanManager DeserializeLength(BufferStream stream, int length)
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		DeserializeLength(stream, length, clanManager, isDelta: false);
		return clanManager;
	}

	public static ClanManager Deserialize(byte[] buffer)
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanManager, isDelta: false);
		return clanManager;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanManager previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanManager Deserialize(BufferStream stream, ClanManager instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.backendType = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanManager DeserializeLengthDelimited(BufferStream stream, ClanManager instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.backendType = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanManager DeserializeLength(BufferStream stream, int length, ClanManager instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.backendType = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanManager instance, ClanManager previous)
	{
		if (instance.backendType != previous.backendType)
		{
			if (instance.backendType == null)
			{
				throw new ArgumentNullException("backendType", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.backendType);
		}
	}

	public static void Serialize(BufferStream stream, ClanManager instance)
	{
		if (instance.backendType == null)
		{
			throw new ArgumentNullException("backendType", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.backendType);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AssociatedFiles : IDisposable, IPooled, IProto<AssociatedFiles>, IProto
{
	public class AssociatedFile : IDisposable, IPooled, IProto<AssociatedFile>, IProto
	{
		[NonSerialized]
		public int type;

		[NonSerialized]
		public uint crc;

		[NonSerialized]
		public uint numID;

		[NonSerialized]
		public byte[] data;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(AssociatedFile instance)
		{
			if (instance.ShouldPool)
			{
				instance.type = 0;
				instance.crc = 0u;
				instance.numID = 0u;
				instance.data = null;
				Pool.Free<AssociatedFile>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose AssociatedFile with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(AssociatedFile instance)
		{
			instance.type = type;
			instance.crc = crc;
			instance.numID = numID;
			if (data == null)
			{
				instance.data = null;
				return;
			}
			instance.data = new byte[data.Length];
			Array.Copy(data, instance.data, instance.data.Length);
		}

		public AssociatedFile Copy()
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			CopyTo(associatedFile);
			return associatedFile;
		}

		public static AssociatedFile Deserialize(BufferStream stream)
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			Deserialize(stream, associatedFile, isDelta: false);
			return associatedFile;
		}

		public static AssociatedFile DeserializeLengthDelimited(BufferStream stream)
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			DeserializeLengthDelimited(stream, associatedFile, isDelta: false);
			return associatedFile;
		}

		public static AssociatedFile DeserializeLength(BufferStream stream, int length)
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			DeserializeLength(stream, length, associatedFile, isDelta: false);
			return associatedFile;
		}

		public static AssociatedFile Deserialize(byte[] buffer)
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, associatedFile, isDelta: false);
			return associatedFile;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, AssociatedFile previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static AssociatedFile Deserialize(BufferStream stream, AssociatedFile instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.crc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 24:
					instance.numID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 34:
					instance.data = ProtocolParser.ReadBytes(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static AssociatedFile DeserializeLengthDelimited(BufferStream stream, AssociatedFile instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.crc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 24:
					instance.numID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 34:
					instance.data = ProtocolParser.ReadBytes(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static AssociatedFile DeserializeLength(BufferStream stream, int length, AssociatedFile instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.crc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 24:
					instance.numID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 34:
					instance.data = ProtocolParser.ReadBytes(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, AssociatedFile instance, AssociatedFile previous)
		{
			if (instance.type != previous.type)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.crc != previous.crc)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt32(stream, instance.crc);
			}
			if (instance.numID != previous.numID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt32(stream, instance.numID);
			}
			if (instance.data == null)
			{
				throw new ArgumentNullException("data", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteBytes(stream, instance.data);
		}

		public static void Serialize(BufferStream stream, AssociatedFile instance)
		{
			if (instance.type != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.crc != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt32(stream, instance.crc);
			}
			if (instance.numID != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt32(stream, instance.numID);
			}
			if (instance.data == null)
			{
				throw new ArgumentNullException("data", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteBytes(stream, instance.data);
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<AssociatedFile> files;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AssociatedFiles instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.files != null)
		{
			for (int i = 0; i < instance.files.Count; i++)
			{
				if (instance.files[i] != null)
				{
					instance.files[i].ResetToPool();
					instance.files[i] = null;
				}
			}
			List<AssociatedFile> list = instance.files;
			Pool.Free<AssociatedFile>(ref list, false);
			instance.files = list;
		}
		Pool.Free<AssociatedFiles>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AssociatedFiles with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AssociatedFiles instance)
	{
		if (files != null)
		{
			instance.files = Pool.Get<List<AssociatedFile>>();
			for (int i = 0; i < files.Count; i++)
			{
				AssociatedFile item = files[i].Copy();
				instance.files.Add(item);
			}
		}
		else
		{
			instance.files = null;
		}
	}

	public AssociatedFiles Copy()
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		CopyTo(associatedFiles);
		return associatedFiles;
	}

	public static AssociatedFiles Deserialize(BufferStream stream)
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		Deserialize(stream, associatedFiles, isDelta: false);
		return associatedFiles;
	}

	public static AssociatedFiles DeserializeLengthDelimited(BufferStream stream)
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		DeserializeLengthDelimited(stream, associatedFiles, isDelta: false);
		return associatedFiles;
	}

	public static AssociatedFiles DeserializeLength(BufferStream stream, int length)
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		DeserializeLength(stream, length, associatedFiles, isDelta: false);
		return associatedFiles;
	}

	public static AssociatedFiles Deserialize(byte[] buffer)
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, associatedFiles, isDelta: false);
		return associatedFiles;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AssociatedFiles previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AssociatedFiles Deserialize(BufferStream stream, AssociatedFiles instance, bool isDelta)
	{
		if (!isDelta && instance.files == null)
		{
			instance.files = Pool.Get<List<AssociatedFile>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.files.Add(AssociatedFile.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AssociatedFiles DeserializeLengthDelimited(BufferStream stream, AssociatedFiles instance, bool isDelta)
	{
		if (!isDelta && instance.files == null)
		{
			instance.files = Pool.Get<List<AssociatedFile>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.files.Add(AssociatedFile.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AssociatedFiles DeserializeLength(BufferStream stream, int length, AssociatedFiles instance, bool isDelta)
	{
		if (!isDelta && instance.files == null)
		{
			instance.files = Pool.Get<List<AssociatedFile>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.files.Add(AssociatedFile.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AssociatedFiles instance, AssociatedFiles previous)
	{
		if (instance.files == null)
		{
			return;
		}
		for (int i = 0; i < instance.files.Count; i++)
		{
			AssociatedFile associatedFile = instance.files[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AssociatedFile.SerializeDelta(stream, associatedFile, associatedFile);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AssociatedFiles instance)
	{
		if (instance.files == null)
		{
			return;
		}
		for (int i = 0; i < instance.files.Count; i++)
		{
			AssociatedFile instance2 = instance.files[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AssociatedFile.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (files != null)
		{
			for (int i = 0; i < files.Count; i++)
			{
				files[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NexusFerry : IDisposable, IPooled, IProto<NexusFerry>, IProto
{
	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public string ownerZone;

	[NonSerialized]
	public List<string> schedule;

	[NonSerialized]
	public int scheduleIndex;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public bool isRetiring;

	[NonSerialized]
	public List<NetworkableId> transferredIds;

	[NonSerialized]
	public int nextScheduleIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NexusFerry instance)
	{
		if (instance.ShouldPool)
		{
			instance.timestamp = 0L;
			instance.ownerZone = string.Empty;
			if (instance.schedule != null)
			{
				List<string> list = instance.schedule;
				Pool.FreeUnmanaged<string>(ref list);
				instance.schedule = list;
			}
			instance.scheduleIndex = 0;
			instance.state = 0;
			instance.isRetiring = false;
			if (instance.transferredIds != null)
			{
				List<NetworkableId> list2 = instance.transferredIds;
				Pool.FreeUnmanaged<NetworkableId>(ref list2);
				instance.transferredIds = list2;
			}
			instance.nextScheduleIndex = 0;
			Pool.Free<NexusFerry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NexusFerry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NexusFerry instance)
	{
		instance.timestamp = timestamp;
		instance.ownerZone = ownerZone;
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<string>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				string item = schedule[i];
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
		instance.scheduleIndex = scheduleIndex;
		instance.state = state;
		instance.isRetiring = isRetiring;
		if (transferredIds != null)
		{
			instance.transferredIds = Pool.Get<List<NetworkableId>>();
			for (int j = 0; j < transferredIds.Count; j++)
			{
				NetworkableId item2 = transferredIds[j];
				instance.transferredIds.Add(item2);
			}
		}
		else
		{
			instance.transferredIds = null;
		}
		instance.nextScheduleIndex = nextScheduleIndex;
	}

	public NexusFerry Copy()
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		CopyTo(nexusFerry);
		return nexusFerry;
	}

	public static NexusFerry Deserialize(BufferStream stream)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		Deserialize(stream, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public static NexusFerry DeserializeLengthDelimited(BufferStream stream)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		DeserializeLengthDelimited(stream, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public static NexusFerry DeserializeLength(BufferStream stream, int length)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		DeserializeLength(stream, length, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public static NexusFerry Deserialize(byte[] buffer)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NexusFerry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NexusFerry Deserialize(BufferStream stream, NexusFerry instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.schedule == null)
			{
				instance.schedule = Pool.Get<List<string>>();
			}
			if (instance.transferredIds == null)
			{
				instance.transferredIds = Pool.Get<List<NetworkableId>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 32:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.transferredIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case 64:
				instance.nextScheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NexusFerry DeserializeLengthDelimited(BufferStream stream, NexusFerry instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.schedule == null)
			{
				instance.schedule = Pool.Get<List<string>>();
			}
			if (instance.transferredIds == null)
			{
				instance.transferredIds = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 32:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.transferredIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case 64:
				instance.nextScheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NexusFerry DeserializeLength(BufferStream stream, int length, NexusFerry instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.schedule == null)
			{
				instance.schedule = Pool.Get<List<string>>();
			}
			if (instance.transferredIds == null)
			{
				instance.transferredIds = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 32:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.transferredIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case 64:
				instance.nextScheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NexusFerry instance, NexusFerry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.ownerZone != null && instance.ownerZone != previous.ownerZone)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.ownerZone);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != previous.scheduleIndex)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.isRetiring);
		if (instance.transferredIds != null)
		{
			for (int j = 0; j < instance.transferredIds.Count; j++)
			{
				NetworkableId networkableId = instance.transferredIds[j];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
		if (instance.nextScheduleIndex != previous.nextScheduleIndex)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextScheduleIndex);
		}
	}

	public static void Serialize(BufferStream stream, NexusFerry instance)
	{
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.ownerZone != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.ownerZone);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.isRetiring)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.isRetiring);
		}
		if (instance.transferredIds != null)
		{
			for (int j = 0; j < instance.transferredIds.Count; j++)
			{
				NetworkableId networkableId = instance.transferredIds[j];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
		if (instance.nextScheduleIndex != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextScheduleIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < transferredIds.Count; i++)
		{
			NetworkableId value = transferredIds[i];
			action(UidType.NetworkableId, ref value.Value);
			transferredIds[i] = value;
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NexusIsland : IDisposable, IPooled, IProto<NexusIsland>, IProto
{
	[NonSerialized]
	public string zoneKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NexusIsland instance)
	{
		if (instance.ShouldPool)
		{
			instance.zoneKey = string.Empty;
			Pool.Free<NexusIsland>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NexusIsland with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NexusIsland instance)
	{
		instance.zoneKey = zoneKey;
	}

	public NexusIsland Copy()
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		CopyTo(nexusIsland);
		return nexusIsland;
	}

	public static NexusIsland Deserialize(BufferStream stream)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		Deserialize(stream, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public static NexusIsland DeserializeLengthDelimited(BufferStream stream)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		DeserializeLengthDelimited(stream, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public static NexusIsland DeserializeLength(BufferStream stream, int length)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		DeserializeLength(stream, length, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public static NexusIsland Deserialize(byte[] buffer)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NexusIsland previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NexusIsland Deserialize(BufferStream stream, NexusIsland instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.zoneKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NexusIsland DeserializeLengthDelimited(BufferStream stream, NexusIsland instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.zoneKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NexusIsland DeserializeLength(BufferStream stream, int length, NexusIsland instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.zoneKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NexusIsland instance, NexusIsland previous)
	{
		if (instance.zoneKey != null && instance.zoneKey != previous.zoneKey)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.zoneKey);
		}
	}

	public static void Serialize(BufferStream stream, NexusIsland instance)
	{
		if (instance.zoneKey != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.zoneKey);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


