using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PatternFirework : IDisposable, IPooled, IProto<PatternFirework>, IProto
{
	public class Design : IDisposable, IPooled, IProto<Design>, IProto
	{
		[NonSerialized]
		public List<Star> stars;

		[NonSerialized]
		public ulong editedBy;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Design instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.stars != null)
			{
				for (int i = 0; i < instance.stars.Count; i++)
				{
					if (instance.stars[i] != null)
					{
						instance.stars[i].ResetToPool();
						instance.stars[i] = null;
					}
				}
				List<Star> list = instance.stars;
				Pool.Free<Star>(ref list, false);
				instance.stars = list;
			}
			instance.editedBy = 0uL;
			Pool.Free<Design>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Design with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Design instance)
		{
			if (stars != null)
			{
				instance.stars = Pool.Get<List<Star>>();
				for (int i = 0; i < stars.Count; i++)
				{
					Star item = stars[i].Copy();
					instance.stars.Add(item);
				}
			}
			else
			{
				instance.stars = null;
			}
			instance.editedBy = editedBy;
		}

		public Design Copy()
		{
			Design design = Pool.Get<Design>();
			CopyTo(design);
			return design;
		}

		public static Design Deserialize(BufferStream stream)
		{
			Design design = Pool.Get<Design>();
			Deserialize(stream, design, isDelta: false);
			return design;
		}

		public static Design DeserializeLengthDelimited(BufferStream stream)
		{
			Design design = Pool.Get<Design>();
			DeserializeLengthDelimited(stream, design, isDelta: false);
			return design;
		}

		public static Design DeserializeLength(BufferStream stream, int length)
		{
			Design design = Pool.Get<Design>();
			DeserializeLength(stream, length, design, isDelta: false);
			return design;
		}

		public static Design Deserialize(byte[] buffer)
		{
			Design design = Pool.Get<Design>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, design, isDelta: false);
			return design;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Design previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Design Deserialize(BufferStream stream, Design instance, bool isDelta)
		{
			if (!isDelta && instance.stars == null)
			{
				instance.stars = Pool.Get<List<Star>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.stars.Add(Star.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.editedBy = ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Design DeserializeLengthDelimited(BufferStream stream, Design instance, bool isDelta)
		{
			if (!isDelta && instance.stars == null)
			{
				instance.stars = Pool.Get<List<Star>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.stars.Add(Star.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.editedBy = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Design DeserializeLength(BufferStream stream, int length, Design instance, bool isDelta)
		{
			if (!isDelta && instance.stars == null)
			{
				instance.stars = Pool.Get<List<Star>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.stars.Add(Star.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.editedBy = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Design instance, Design previous)
		{
			if (instance.stars != null)
			{
				for (int i = 0; i < instance.stars.Count; i++)
				{
					Star star = instance.stars[i];
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Star.SerializeDelta(stream, star, star);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stars (ProtoBuf.PatternFirework.Star)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.editedBy != previous.editedBy)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.editedBy);
			}
		}

		public static void Serialize(BufferStream stream, Design instance)
		{
			if (instance.stars != null)
			{
				for (int i = 0; i < instance.stars.Count; i++)
				{
					Star instance2 = instance.stars[i];
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Star.Serialize(stream, instance2);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stars (ProtoBuf.PatternFirework.Star)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.editedBy != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.editedBy);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (stars != null)
			{
				for (int i = 0; i < stars.Count; i++)
				{
					stars[i]?.InspectUids(action);
				}
			}
		}
	}

	public class Star : IDisposable, IPooled, IProto<Star>, IProto
	{
		[NonSerialized]
		public Vector2 position;

		[NonSerialized]
		public Color color;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Star instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.position = default(Vector2);
				instance.color = default(Color);
				Pool.Free<Star>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Star with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Star instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			instance.position = position;
			instance.color = color;
		}

		public Star Copy()
		{
			Star star = Pool.Get<Star>();
			CopyTo(star);
			return star;
		}

		public static Star Deserialize(BufferStream stream)
		{
			Star star = Pool.Get<Star>();
			Deserialize(stream, star, isDelta: false);
			return star;
		}

		public static Star DeserializeLengthDelimited(BufferStream stream)
		{
			Star star = Pool.Get<Star>();
			DeserializeLengthDelimited(stream, star, isDelta: false);
			return star;
		}

		public static Star DeserializeLength(BufferStream stream, int length)
		{
			Star star = Pool.Get<Star>();
			DeserializeLength(stream, length, star, isDelta: false);
			return star;
		}

		public static Star Deserialize(byte[] buffer)
		{
			Star star = Pool.Get<Star>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, star, isDelta: false);
			return star;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Star previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Star Deserialize(BufferStream stream, Star instance, bool isDelta)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Star DeserializeLengthDelimited(BufferStream stream, Star instance, bool isDelta)
		{
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Star DeserializeLength(BufferStream stream, int length, Star instance, bool isDelta)
		{
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Star instance, Star previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			if (instance.position != previous.position)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector2Serialized.SerializeDelta(stream, instance.position, previous.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector2)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.color != previous.color)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.color, previous.color);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
		}

		public static void Serialize(BufferStream stream, Star instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			if (instance.position != default(Vector2))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector2Serialized.Serialize(stream, instance.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector2)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.color != default(Color))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				ColorSerialized.Serialize(stream, instance.color);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class SavedDesign : IDisposable, IPooled, IProto<SavedDesign>, IProto
	{
		[NonSerialized]
		public int version;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public Design design;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SavedDesign instance)
		{
			if (instance.ShouldPool)
			{
				instance.version = 0;
				instance.name = string.Empty;
				if (instance.design != null)
				{
					instance.design.ResetToPool();
					instance.design = null;
				}
				Pool.Free<SavedDesign>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SavedDesign with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SavedDesign instance)
		{
			instance.version = version;
			instance.name = name;
			if (design != null)
			{
				if (instance.design == null)
				{
					instance.design = design.Copy();
				}
				else
				{
					design.CopyTo(instance.design);
				}
			}
			else
			{
				instance.design = null;
			}
		}

		public SavedDesign Copy()
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			CopyTo(savedDesign);
			return savedDesign;
		}

		public static SavedDesign Deserialize(BufferStream stream)
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			Deserialize(stream, savedDesign, isDelta: false);
			return savedDesign;
		}

		public static SavedDesign DeserializeLengthDelimited(BufferStream stream)
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			DeserializeLengthDelimited(stream, savedDesign, isDelta: false);
			return savedDesign;
		}

		public static SavedDesign DeserializeLength(BufferStream stream, int length)
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			DeserializeLength(stream, length, savedDesign, isDelta: false);
			return savedDesign;
		}

		public static SavedDesign Deserialize(byte[] buffer)
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, savedDesign, isDelta: false);
			return savedDesign;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SavedDesign previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SavedDesign Deserialize(BufferStream stream, SavedDesign instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.version = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					break;
				case 26:
					if (instance.design == null)
					{
						instance.design = Design.DeserializeLengthDelimited(stream);
					}
					else
					{
						Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
					}
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
					return instance;
				}
			}
		}

		public static SavedDesign DeserializeLengthDelimited(BufferStream stream, SavedDesign instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.version = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					break;
				case 26:
					if (instance.design == null)
					{
						instance.design = Design.DeserializeLengthDelimited(stream);
					}
					else
					{
						Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
					}
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SavedDesign DeserializeLength(BufferStream stream, int length, SavedDesign instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.version = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					break;
				case 26:
					if (instance.design == null)
					{
						instance.design = Design.DeserializeLengthDelimited(stream);
					}
					else
					{
						Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
					}
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SavedDesign instance, SavedDesign previous)
		{
			if (instance.version != previous.version)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.version);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.design == null)
			{
				throw new ArgumentNullException("design", "Required by proto specification.");
			}
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			Design.SerializeDelta(stream, instance.design, previous.design);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}

		public static void Serialize(BufferStream stream, SavedDesign instance)
		{
			if (instance.version != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.version);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.design == null)
			{
				throw new ArgumentNullException("design", "Required by proto specification.");
			}
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			Design.Serialize(stream, instance.design);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			design?.InspectUids(action);
		}
	}

	[NonSerialized]
	public Design design;

	[NonSerialized]
	public int shellFuseLength;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PatternFirework instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.design != null)
			{
				instance.design.ResetToPool();
				instance.design = null;
			}
			instance.shellFuseLength = 0;
			Pool.Free<PatternFirework>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PatternFirework with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PatternFirework instance)
	{
		if (design != null)
		{
			if (instance.design == null)
			{
				instance.design = design.Copy();
			}
			else
			{
				design.CopyTo(instance.design);
			}
		}
		else
		{
			instance.design = null;
		}
		instance.shellFuseLength = shellFuseLength;
	}

	public PatternFirework Copy()
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		CopyTo(patternFirework);
		return patternFirework;
	}

	public static PatternFirework Deserialize(BufferStream stream)
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		Deserialize(stream, patternFirework, isDelta: false);
		return patternFirework;
	}

	public static PatternFirework DeserializeLengthDelimited(BufferStream stream)
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		DeserializeLengthDelimited(stream, patternFirework, isDelta: false);
		return patternFirework;
	}

	public static PatternFirework DeserializeLength(BufferStream stream, int length)
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		DeserializeLength(stream, length, patternFirework, isDelta: false);
		return patternFirework;
	}

	public static PatternFirework Deserialize(byte[] buffer)
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, patternFirework, isDelta: false);
		return patternFirework;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PatternFirework previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PatternFirework Deserialize(BufferStream stream, PatternFirework instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			case 16:
				instance.shellFuseLength = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static PatternFirework DeserializeLengthDelimited(BufferStream stream, PatternFirework instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			case 16:
				instance.shellFuseLength = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PatternFirework DeserializeLength(BufferStream stream, int length, PatternFirework instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			case 16:
				instance.shellFuseLength = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PatternFirework instance, PatternFirework previous)
	{
		if (instance.design != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			Design.SerializeDelta(stream, instance.design, previous.design);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}
		if (instance.shellFuseLength != previous.shellFuseLength)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.shellFuseLength);
		}
	}

	public static void Serialize(BufferStream stream, PatternFirework instance)
	{
		if (instance.design != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			Design.Serialize(stream, instance.design);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}
		if (instance.shellFuseLength != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.shellFuseLength);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		design?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class CargoPlane : IDisposable, IPooled, IProto<CargoPlane>, IProto
{
	[NonSerialized]
	public Vector3 startPos;

	[NonSerialized]
	public Vector3 endPos;

	[NonSerialized]
	public float secondsToTake;

	[NonSerialized]
	public float secondsTaken;

	[NonSerialized]
	public bool dropped;

	[NonSerialized]
	public Vector3 dropPosition;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CargoPlane instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.startPos = default(Vector3);
			instance.endPos = default(Vector3);
			instance.secondsToTake = 0f;
			instance.secondsTaken = 0f;
			instance.dropped = false;
			instance.dropPosition = default(Vector3);
			Pool.Free<CargoPlane>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CargoPlane with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CargoPlane instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		instance.startPos = startPos;
		instance.endPos = endPos;
		instance.secondsToTake = secondsToTake;
		instance.secondsTaken = secondsTaken;
		instance.dropped = dropped;
		instance.dropPosition = dropPosition;
	}

	public CargoPlane Copy()
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		CopyTo(cargoPlane);
		return cargoPlane;
	}

	public static CargoPlane Deserialize(BufferStream stream)
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		Deserialize(stream, cargoPlane, isDelta: false);
		return cargoPlane;
	}

	public static CargoPlane DeserializeLengthDelimited(BufferStream stream)
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		DeserializeLengthDelimited(stream, cargoPlane, isDelta: false);
		return cargoPlane;
	}

	public static CargoPlane DeserializeLength(BufferStream stream, int length)
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		DeserializeLength(stream, length, cargoPlane, isDelta: false);
		return cargoPlane;
	}

	public static CargoPlane Deserialize(byte[] buffer)
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cargoPlane, isDelta: false);
		return cargoPlane;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CargoPlane previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CargoPlane Deserialize(BufferStream stream, CargoPlane instance, bool isDelta)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPos, isDelta);
				continue;
			case 29:
				instance.secondsToTake = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.secondsTaken = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.dropped = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.dropPosition, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CargoPlane DeserializeLengthDelimited(BufferStream stream, CargoPlane instance, bool isDelta)
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPos, isDelta);
				continue;
			case 29:
				instance.secondsToTake = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.secondsTaken = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.dropped = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.dropPosition, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CargoPlane DeserializeLength(BufferStream stream, int length, CargoPlane instance, bool isDelta)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPos, isDelta);
				continue;
			case 29:
				instance.secondsToTake = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.secondsTaken = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.dropped = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.dropPosition, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CargoPlane instance, CargoPlane previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		if (instance.startPos != previous.startPos)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.startPos, previous.startPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.endPos != previous.endPos)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.endPos, previous.endPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field endPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.secondsToTake != previous.secondsToTake)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.secondsToTake);
		}
		if (instance.secondsTaken != previous.secondsTaken)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.secondsTaken);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.dropped);
		if (instance.dropPosition != previous.dropPosition)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.dropPosition, previous.dropPosition);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field dropPosition (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public static void Serialize(BufferStream stream, CargoPlane instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		if (instance.startPos != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.startPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.endPos != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.endPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field endPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.secondsToTake != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.secondsToTake);
		}
		if (instance.secondsTaken != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.secondsTaken);
		}
		if (instance.dropped)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.dropped);
		}
		if (instance.dropPosition != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.dropPosition);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field dropPosition (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PaintedItem : IDisposable, IPooled, IProto<PaintedItem>, IProto
{
	[NonSerialized]
	public uint imageCrc;

	[NonSerialized]
	public ulong editedBy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PaintedItem instance)
	{
		if (instance.ShouldPool)
		{
			instance.imageCrc = 0u;
			instance.editedBy = 0uL;
			Pool.Free<PaintedItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PaintedItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PaintedItem instance)
	{
		instance.imageCrc = imageCrc;
		instance.editedBy = editedBy;
	}

	public PaintedItem Copy()
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		CopyTo(paintedItem);
		return paintedItem;
	}

	public static PaintedItem Deserialize(BufferStream stream)
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		Deserialize(stream, paintedItem, isDelta: false);
		return paintedItem;
	}

	public static PaintedItem DeserializeLengthDelimited(BufferStream stream)
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		DeserializeLengthDelimited(stream, paintedItem, isDelta: false);
		return paintedItem;
	}

	public static PaintedItem DeserializeLength(BufferStream stream, int length)
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		DeserializeLength(stream, length, paintedItem, isDelta: false);
		return paintedItem;
	}

	public static PaintedItem Deserialize(byte[] buffer)
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, paintedItem, isDelta: false);
		return paintedItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PaintedItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PaintedItem Deserialize(BufferStream stream, PaintedItem instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PaintedItem DeserializeLengthDelimited(BufferStream stream, PaintedItem instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PaintedItem DeserializeLength(BufferStream stream, int length, PaintedItem instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PaintedItem instance, PaintedItem previous)
	{
		if (instance.imageCrc != previous.imageCrc)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
		if (instance.editedBy != previous.editedBy)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.editedBy);
		}
	}

	public static void Serialize(BufferStream stream, PaintedItem instance)
	{
		if (instance.imageCrc != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
		if (instance.editedBy != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.editedBy);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Spray : IDisposable, IPooled, IProto<Spray>, IProto
{
	[NonSerialized]
	public ulong sprayedBy;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Spray instance)
	{
		if (instance.ShouldPool)
		{
			instance.sprayedBy = 0uL;
			instance.timestamp = 0L;
			Pool.Free<Spray>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Spray with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Spray instance)
	{
		instance.sprayedBy = sprayedBy;
		instance.timestamp = timestamp;
	}

	public Spray Copy()
	{
		Spray spray = Pool.Get<Spray>();
		CopyTo(spray);
		return spray;
	}

	public static Spray Deserialize(BufferStream stream)
	{
		Spray spray = Pool.Get<Spray>();
		Deserialize(stream, spray, isDelta: false);
		return spray;
	}

	public static Spray DeserializeLengthDelimited(BufferStream stream)
	{
		Spray spray = Pool.Get<Spray>();
		DeserializeLengthDelimited(stream, spray, isDelta: false);
		return spray;
	}

	public static Spray DeserializeLength(BufferStream stream, int length)
	{
		Spray spray = Pool.Get<Spray>();
		DeserializeLength(stream, length, spray, isDelta: false);
		return spray;
	}

	public static Spray Deserialize(byte[] buffer)
	{
		Spray spray = Pool.Get<Spray>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spray, isDelta: false);
		return spray;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Spray previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Spray Deserialize(BufferStream stream, Spray instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.sprayedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Spray DeserializeLengthDelimited(BufferStream stream, Spray instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.sprayedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Spray DeserializeLength(BufferStream stream, int length, Spray instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.sprayedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Spray instance, Spray previous)
	{
		if (instance.sprayedBy != previous.sprayedBy)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.sprayedBy);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, Spray instance)
	{
		if (instance.sprayedBy != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.sprayedBy);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class SprayLine : IDisposable, IPooled, IProto<SprayLine>, IProto
{
	[NonSerialized]
	public List<LinePoint> linePoints;

	[NonSerialized]
	public Vector3 colour;

	[NonSerialized]
	public float width;

	[NonSerialized]
	public NetworkableId editingPlayer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SprayLine instance)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				if (instance.linePoints[i] != null)
				{
					instance.linePoints[i].ResetToPool();
					instance.linePoints[i] = null;
				}
			}
			List<LinePoint> list = instance.linePoints;
			Pool.Free<LinePoint>(ref list, false);
			instance.linePoints = list;
		}
		instance.colour = default(Vector3);
		instance.width = 0f;
		instance.editingPlayer = default(NetworkableId);
		Pool.Free<SprayLine>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SprayLine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SprayLine instance)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				LinePoint item = linePoints[i].Copy();
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
		instance.colour = colour;
		instance.width = width;
		instance.editingPlayer = editingPlayer;
	}

	public SprayLine Copy()
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		CopyTo(sprayLine);
		return sprayLine;
	}

	public static SprayLine Deserialize(BufferStream stream)
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		Deserialize(stream, sprayLine, isDelta: false);
		return sprayLine;
	}

	public static SprayLine DeserializeLengthDelimited(BufferStream stream)
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		DeserializeLengthDelimited(stream, sprayLine, isDelta: false);
		return sprayLine;
	}

	public static SprayLine DeserializeLength(BufferStream stream, int length)
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		DeserializeLength(stream, length, sprayLine, isDelta: false);
		return sprayLine;
	}

	public static SprayLine Deserialize(byte[] buffer)
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sprayLine, isDelta: false);
		return sprayLine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SprayLine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SprayLine Deserialize(BufferStream stream, SprayLine instance, bool isDelta)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colour, isDelta);
				continue;
			case 29:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.editingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SprayLine DeserializeLengthDelimited(BufferStream stream, SprayLine instance, bool isDelta)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colour, isDelta);
				continue;
			case 29:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.editingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SprayLine DeserializeLength(BufferStream stream, int length, SprayLine instance, bool isDelta)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colour, isDelta);
				continue;
			case 29:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.editingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SprayLine instance, SprayLine previous)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				LinePoint linePoint = instance.linePoints[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				LinePoint.SerializeDelta(stream, linePoint, linePoint);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.LinePoint)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.colour != previous.colour)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.colour, previous.colour);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colour (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.width != previous.width)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.width);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.editingPlayer.Value);
	}

	public static void Serialize(BufferStream stream, SprayLine instance)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				LinePoint instance2 = instance.linePoints[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				LinePoint.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.LinePoint)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.colour != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.colour);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colour (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.width != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.width);
		}
		if (instance.editingPlayer != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.editingPlayer.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (linePoints != null)
		{
			for (int i = 0; i < linePoints.Count; i++)
			{
				linePoints[i]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref editingPlayer.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SprayList : IDisposable, IPooled, IProto<SprayList>, IProto
{
	[NonSerialized]
	public List<LinePoint> linePoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SprayList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				if (instance.linePoints[i] != null)
				{
					instance.linePoints[i].ResetToPool();
					instance.linePoints[i] = null;
				}
			}
			List<LinePoint> list = instance.linePoints;
			Pool.Free<LinePoint>(ref list, false);
			instance.linePoints = list;
		}
		Pool.Free<SprayList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SprayList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SprayList instance)
	{
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				LinePoint item = linePoints[i].Copy();
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
	}

	public SprayList Copy()
	{
		SprayList sprayList = Pool.Get<SprayList>();
		CopyTo(sprayList);
		return sprayList;
	}

	public static SprayList Deserialize(BufferStream stream)
	{
		SprayList sprayList = Pool.Get<SprayList>();
		Deserialize(stream, sprayList, isDelta: false);
		return sprayList;
	}

	public static SprayList DeserializeLengthDelimited(BufferStream stream)
	{
		SprayList sprayList = Pool.Get<SprayList>();
		DeserializeLengthDelimited(stream, sprayList, isDelta: false);
		return sprayList;
	}

	public static SprayList DeserializeLength(BufferStream stream, int length)
	{
		SprayList sprayList = Pool.Get<SprayList>();
		DeserializeLength(stream, length, sprayList, isDelta: false);
		return sprayList;
	}

	public static SprayList Deserialize(byte[] buffer)
	{
		SprayList sprayList = Pool.Get<SprayList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sprayList, isDelta: false);
		return sprayList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SprayList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SprayList Deserialize(BufferStream stream, SprayList instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SprayList DeserializeLengthDelimited(BufferStream stream, SprayList instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SprayList DeserializeLength(BufferStream stream, int length, SprayList instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SprayList instance, SprayList previous)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			LinePoint linePoint = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			LinePoint.SerializeDelta(stream, linePoint, linePoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.LinePoint)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, SprayList instance)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			LinePoint instance2 = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			LinePoint.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.LinePoint)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (linePoints != null)
		{
			for (int i = 0; i < linePoints.Count; i++)
			{
				linePoints[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LinePoint : IDisposable, IPooled, IProto<LinePoint>, IProto
{
	[NonSerialized]
	public Vector3 localPosition;

	[NonSerialized]
	public Vector3 worldNormal;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LinePoint instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.localPosition = default(Vector3);
			instance.worldNormal = default(Vector3);
			Pool.Free<LinePoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LinePoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LinePoint instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.localPosition = localPosition;
		instance.worldNormal = worldNormal;
	}

	public LinePoint Copy()
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		CopyTo(linePoint);
		return linePoint;
	}

	public static LinePoint Deserialize(BufferStream stream)
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		Deserialize(stream, linePoint, isDelta: false);
		return linePoint;
	}

	public static LinePoint DeserializeLengthDelimited(BufferStream stream)
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		DeserializeLengthDelimited(stream, linePoint, isDelta: false);
		return linePoint;
	}

	public static LinePoint DeserializeLength(BufferStream stream, int length)
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		DeserializeLength(stream, length, linePoint, isDelta: false);
		return linePoint;
	}

	public static LinePoint Deserialize(byte[] buffer)
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, linePoint, isDelta: false);
		return linePoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LinePoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LinePoint Deserialize(BufferStream stream, LinePoint instance, bool isDelta)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localPosition, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldNormal, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LinePoint DeserializeLengthDelimited(BufferStream stream, LinePoint instance, bool isDelta)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localPosition, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldNormal, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LinePoint DeserializeLength(BufferStream stream, int length, LinePoint instance, bool isDelta)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localPosition, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldNormal, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LinePoint instance, LinePoint previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (instance.localPosition != previous.localPosition)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.localPosition, previous.localPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.worldNormal != previous.worldNormal)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.worldNormal, previous.worldNormal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldNormal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, LinePoint instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (instance.localPosition != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.localPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.worldNormal != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.worldNormal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldNormal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Zipline : IDisposable, IPooled, IProto<Zipline>, IProto
{
	[NonSerialized]
	public List<VectorData> destinationPoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Zipline instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.destinationPoints != null)
			{
				List<VectorData> list = instance.destinationPoints;
				Pool.FreeUnmanaged<VectorData>(ref list);
				instance.destinationPoints = list;
			}
			Pool.Free<Zipline>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Zipline with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Zipline instance)
	{
		if (destinationPoints != null)
		{
			instance.destinationPoints = Pool.Get<List<VectorData>>();
			for (int i = 0; i < destinationPoints.Count; i++)
			{
				VectorData item = destinationPoints[i];
				instance.destinationPoints.Add(item);
			}
		}
		else
		{
			instance.destinationPoints = null;
		}
	}

	public Zipline Copy()
	{
		Zipline zipline = Pool.Get<Zipline>();
		CopyTo(zipline);
		return zipline;
	}

	public static Zipline Deserialize(BufferStream stream)
	{
		Zipline zipline = Pool.Get<Zipline>();
		Deserialize(stream, zipline, isDelta: false);
		return zipline;
	}

	public static Zipline DeserializeLengthDelimited(BufferStream stream)
	{
		Zipline zipline = Pool.Get<Zipline>();
		DeserializeLengthDelimited(stream, zipline, isDelta: false);
		return zipline;
	}

	public static Zipline DeserializeLength(BufferStream stream, int length)
	{
		Zipline zipline = Pool.Get<Zipline>();
		DeserializeLength(stream, length, zipline, isDelta: false);
		return zipline;
	}

	public static Zipline Deserialize(byte[] buffer)
	{
		Zipline zipline = Pool.Get<Zipline>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, zipline, isDelta: false);
		return zipline;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Zipline previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Zipline Deserialize(BufferStream stream, Zipline instance, bool isDelta)
	{
		if (!isDelta && instance.destinationPoints == null)
		{
			instance.destinationPoints = Pool.Get<List<VectorData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.destinationPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static Zipline DeserializeLengthDelimited(BufferStream stream, Zipline instance, bool isDelta)
	{
		if (!isDelta && instance.destinationPoints == null)
		{
			instance.destinationPoints = Pool.Get<List<VectorData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.destinationPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Zipline DeserializeLength(BufferStream stream, int length, Zipline instance, bool isDelta)
	{
		if (!isDelta && instance.destinationPoints == null)
		{
			instance.destinationPoints = Pool.Get<List<VectorData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.destinationPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Zipline instance, Zipline previous)
	{
		if (instance.destinationPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.destinationPoints.Count; i++)
		{
			VectorData vectorData = instance.destinationPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.SerializeDelta(stream, vectorData, vectorData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destinationPoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, Zipline instance)
	{
		if (instance.destinationPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.destinationPoints.Count; i++)
		{
			VectorData instance2 = instance.destinationPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destinationPoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (destinationPoints != null)
		{
			for (int i = 0; i < destinationPoints.Count; i++)
			{
				destinationPoints[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ZiplineMountable : IDisposable, IPooled, IProto<ZiplineMountable>, IProto
{
	[NonSerialized]
	public List<VectorData> linePoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ZiplineMountable instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.linePoints != null)
			{
				List<VectorData> list = instance.linePoints;
				Pool.FreeUnmanaged<VectorData>(ref list);
				instance.linePoints = list;
			}
			Pool.Free<ZiplineMountable>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ZiplineMountable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ZiplineMountable instance)
	{
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				VectorData item = linePoints[i];
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
	}

	public ZiplineMountable Copy()
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		CopyTo(ziplineMountable);
		return ziplineMountable;
	}

	public static ZiplineMountable Deserialize(BufferStream stream)
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		Deserialize(stream, ziplineMountable, isDelta: false);
		return ziplineMountable;
	}

	public static ZiplineMountable DeserializeLengthDelimited(BufferStream stream)
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		DeserializeLengthDelimited(stream, ziplineMountable, isDelta: false);
		return ziplineMountable;
	}

	public static ZiplineMountable DeserializeLength(BufferStream stream, int length)
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		DeserializeLength(stream, length, ziplineMountable, isDelta: false);
		return ziplineMountable;
	}

	public static ZiplineMountable Deserialize(byte[] buffer)
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ziplineMountable, isDelta: false);
		return ziplineMountable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ZiplineMountable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ZiplineMountable Deserialize(BufferStream stream, ZiplineMountable instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static ZiplineMountable DeserializeLengthDelimited(BufferStream stream, ZiplineMountable instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ZiplineMountable DeserializeLength(BufferStream stream, int length, ZiplineMountable instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ZiplineMountable instance, ZiplineMountable previous)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			VectorData vectorData = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.SerializeDelta(stream, vectorData, vectorData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ZiplineMountable instance)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			VectorData instance2 = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (linePoints != null)
		{
			for (int i = 0; i < linePoints.Count; i++)
			{
				linePoints[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ZiplineArrivalPoint : IDisposable, IPooled, IProto<ZiplineArrivalPoint>, IProto
{
	[NonSerialized]
	public List<VectorData> linePoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ZiplineArrivalPoint instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.linePoints != null)
			{
				List<VectorData> list = instance.linePoints;
				Pool.FreeUnmanaged<VectorData>(ref list);
				instance.linePoints = list;
			}
			Pool.Free<ZiplineArrivalPoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ZiplineArrivalPoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ZiplineArrivalPoint instance)
	{
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				VectorData item = linePoints[i];
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
	}

	public ZiplineArrivalPoint Copy()
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		CopyTo(ziplineArrivalPoint);
		return ziplineArrivalPoint;
	}

	public static ZiplineArrivalPoint Deserialize(BufferStream stream)
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		Deserialize(stream, ziplineArrivalPoint, isDelta: false);
		return ziplineArrivalPoint;
	}

	public static ZiplineArrivalPoint DeserializeLengthDelimited(BufferStream stream)
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		DeserializeLengthDelimited(stream, ziplineArrivalPoint, isDelta: false);
		return ziplineArrivalPoint;
	}

	public static ZiplineArrivalPoint DeserializeLength(BufferStream stream, int length)
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		DeserializeLength(stream, length, ziplineArrivalPoint, isDelta: false);
		return ziplineArrivalPoint;
	}

	public static ZiplineArrivalPoint Deserialize(byte[] buffer)
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ziplineArrivalPoint, isDelta: false);
		return ziplineArrivalPoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ZiplineArrivalPoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ZiplineArrivalPoint Deserialize(BufferStream stream, ZiplineArrivalPoint instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static ZiplineArrivalPoint DeserializeLengthDelimited(BufferStream stream, ZiplineArrivalPoint instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ZiplineArrivalPoint DeserializeLength(BufferStream stream, int length, ZiplineArrivalPoint instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ZiplineArrivalPoint instance, ZiplineArrivalPoint previous)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			VectorData vectorData = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.SerializeDelta(stream, vectorData, vectorData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ZiplineArrivalPoint instance)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			VectorData instance2 = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (linePoints != null)
		{
			for (int i = 0; i < linePoints.Count; i++)
			{
				linePoints[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseTrain : IDisposable, IPooled, IProto<BaseTrain>, IProto
{
	[NonSerialized]
	public float time;

	[NonSerialized]
	public float frontBogieYRot;

	[NonSerialized]
	public float rearBogieYRot;

	[NonSerialized]
	public NetworkableId frontCouplingID;

	[NonSerialized]
	public bool frontCouplingToFront;

	[NonSerialized]
	public NetworkableId rearCouplingID;

	[NonSerialized]
	public bool rearCouplingToFront;

	[NonSerialized]
	public int lootTypeIndex;

	[NonSerialized]
	public float lootPercent;

	[NonSerialized]
	public NetworkableId itemStorageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseTrain instance)
	{
		if (instance.ShouldPool)
		{
			instance.time = 0f;
			instance.frontBogieYRot = 0f;
			instance.rearBogieYRot = 0f;
			instance.frontCouplingID = default(NetworkableId);
			instance.frontCouplingToFront = false;
			instance.rearCouplingID = default(NetworkableId);
			instance.rearCouplingToFront = false;
			instance.lootTypeIndex = 0;
			instance.lootPercent = 0f;
			instance.itemStorageID = default(NetworkableId);
			Pool.Free<BaseTrain>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseTrain with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseTrain instance)
	{
		instance.time = time;
		instance.frontBogieYRot = frontBogieYRot;
		instance.rearBogieYRot = rearBogieYRot;
		instance.frontCouplingID = frontCouplingID;
		instance.frontCouplingToFront = frontCouplingToFront;
		instance.rearCouplingID = rearCouplingID;
		instance.rearCouplingToFront = rearCouplingToFront;
		instance.lootTypeIndex = lootTypeIndex;
		instance.lootPercent = lootPercent;
		instance.itemStorageID = itemStorageID;
	}

	public BaseTrain Copy()
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		CopyTo(baseTrain);
		return baseTrain;
	}

	public static BaseTrain Deserialize(BufferStream stream)
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		Deserialize(stream, baseTrain, isDelta: false);
		return baseTrain;
	}

	public static BaseTrain DeserializeLengthDelimited(BufferStream stream)
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		DeserializeLengthDelimited(stream, baseTrain, isDelta: false);
		return baseTrain;
	}

	public static BaseTrain DeserializeLength(BufferStream stream, int length)
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		DeserializeLength(stream, length, baseTrain, isDelta: false);
		return baseTrain;
	}

	public static BaseTrain Deserialize(byte[] buffer)
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseTrain, isDelta: false);
		return baseTrain;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseTrain previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseTrain Deserialize(BufferStream stream, BaseTrain instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.frontBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rearBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.frontCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.frontCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.rearCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 56:
				instance.rearCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lootPercent = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseTrain DeserializeLengthDelimited(BufferStream stream, BaseTrain instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.frontBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rearBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.frontCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.frontCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.rearCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 56:
				instance.rearCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lootPercent = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseTrain DeserializeLength(BufferStream stream, int length, BaseTrain instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.frontBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rearBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.frontCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.frontCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.rearCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 56:
				instance.rearCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lootPercent = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseTrain instance, BaseTrain previous)
	{
		if (instance.time != previous.time)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.frontBogieYRot != previous.frontBogieYRot)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.frontBogieYRot);
		}
		if (instance.rearBogieYRot != previous.rearBogieYRot)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.rearBogieYRot);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.frontCouplingID.Value);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.frontCouplingToFront);
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, instance.rearCouplingID.Value);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.rearCouplingToFront);
		if (instance.lootTypeIndex != previous.lootTypeIndex)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lootTypeIndex);
		}
		if (instance.lootPercent != previous.lootPercent)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lootPercent);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteUInt64(stream, instance.itemStorageID.Value);
	}

	public static void Serialize(BufferStream stream, BaseTrain instance)
	{
		if (instance.time != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.frontBogieYRot != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.frontBogieYRot);
		}
		if (instance.rearBogieYRot != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.rearBogieYRot);
		}
		if (instance.frontCouplingID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.frontCouplingID.Value);
		}
		if (instance.frontCouplingToFront)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.frontCouplingToFront);
		}
		if (instance.rearCouplingID != default(NetworkableId))
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.rearCouplingID.Value);
		}
		if (instance.rearCouplingToFront)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.rearCouplingToFront);
		}
		if (instance.lootTypeIndex != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lootTypeIndex);
		}
		if (instance.lootPercent != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lootPercent);
		}
		if (instance.itemStorageID != default(NetworkableId))
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, instance.itemStorageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref frontCouplingID.Value);
		action(UidType.NetworkableId, ref rearCouplingID.Value);
		action(UidType.NetworkableId, ref itemStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CoalingTower : IDisposable, IPooled, IProto<CoalingTower>, IProto
{
	[NonSerialized]
	public int lootTypeIndex;

	[NonSerialized]
	public NetworkableId oreStorageID;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public NetworkableId activeUnloadableID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CoalingTower instance)
	{
		if (instance.ShouldPool)
		{
			instance.lootTypeIndex = 0;
			instance.oreStorageID = default(NetworkableId);
			instance.fuelStorageID = default(NetworkableId);
			instance.activeUnloadableID = default(NetworkableId);
			Pool.Free<CoalingTower>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CoalingTower with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CoalingTower instance)
	{
		instance.lootTypeIndex = lootTypeIndex;
		instance.oreStorageID = oreStorageID;
		instance.fuelStorageID = fuelStorageID;
		instance.activeUnloadableID = activeUnloadableID;
	}

	public CoalingTower Copy()
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		CopyTo(coalingTower);
		return coalingTower;
	}

	public static CoalingTower Deserialize(BufferStream stream)
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		Deserialize(stream, coalingTower, isDelta: false);
		return coalingTower;
	}

	public static CoalingTower DeserializeLengthDelimited(BufferStream stream)
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		DeserializeLengthDelimited(stream, coalingTower, isDelta: false);
		return coalingTower;
	}

	public static CoalingTower DeserializeLength(BufferStream stream, int length)
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		DeserializeLength(stream, length, coalingTower, isDelta: false);
		return coalingTower;
	}

	public static CoalingTower Deserialize(byte[] buffer)
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, coalingTower, isDelta: false);
		return coalingTower;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CoalingTower previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CoalingTower Deserialize(BufferStream stream, CoalingTower instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oreStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.activeUnloadableID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CoalingTower DeserializeLengthDelimited(BufferStream stream, CoalingTower instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oreStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.activeUnloadableID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CoalingTower DeserializeLength(BufferStream stream, int length, CoalingTower instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oreStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.activeUnloadableID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CoalingTower instance, CoalingTower previous)
	{
		if (instance.lootTypeIndex != previous.lootTypeIndex)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lootTypeIndex);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.oreStorageID.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.activeUnloadableID.Value);
	}

	public static void Serialize(BufferStream stream, CoalingTower instance)
	{
		if (instance.lootTypeIndex != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lootTypeIndex);
		}
		if (instance.oreStorageID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.oreStorageID.Value);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.activeUnloadableID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.activeUnloadableID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref oreStorageID.Value);
		action(UidType.NetworkableId, ref fuelStorageID.Value);
		action(UidType.NetworkableId, ref activeUnloadableID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseOven : IDisposable, IPooled, IProto<BaseOven>, IProto
{
	public class CookingItem : IDisposable, IPooled, IProto<CookingItem>, IProto
	{
		[NonSerialized]
		public int itemID;

		[NonSerialized]
		public int slotIndex;

		[NonSerialized]
		public int initialStackSize;

		[NonSerialized]
		public float cookingProgress;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(CookingItem instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemID = 0;
				instance.slotIndex = 0;
				instance.initialStackSize = 0;
				instance.cookingProgress = 0f;
				Pool.Free<CookingItem>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose CookingItem with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(CookingItem instance)
		{
			instance.itemID = itemID;
			instance.slotIndex = slotIndex;
			instance.initialStackSize = initialStackSize;
			instance.cookingProgress = cookingProgress;
		}

		public CookingItem Copy()
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			CopyTo(cookingItem);
			return cookingItem;
		}

		public static CookingItem Deserialize(BufferStream stream)
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			Deserialize(stream, cookingItem, isDelta: false);
			return cookingItem;
		}

		public static CookingItem DeserializeLengthDelimited(BufferStream stream)
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			DeserializeLengthDelimited(stream, cookingItem, isDelta: false);
			return cookingItem;
		}

		public static CookingItem DeserializeLength(BufferStream stream, int length)
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			DeserializeLength(stream, length, cookingItem, isDelta: false);
			return cookingItem;
		}

		public static CookingItem Deserialize(byte[] buffer)
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, cookingItem, isDelta: false);
			return cookingItem;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, CookingItem previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static CookingItem Deserialize(BufferStream stream, CookingItem instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 37:
					instance.cookingProgress = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static CookingItem DeserializeLengthDelimited(BufferStream stream, CookingItem instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 37:
					instance.cookingProgress = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static CookingItem DeserializeLength(BufferStream stream, int length, CookingItem instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 37:
					instance.cookingProgress = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, CookingItem instance, CookingItem previous)
		{
			if (instance.itemID != previous.itemID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
			}
			if (instance.slotIndex != previous.slotIndex)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
			}
			if (instance.initialStackSize != previous.initialStackSize)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.initialStackSize);
			}
			if (instance.cookingProgress != previous.cookingProgress)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.cookingProgress);
			}
		}

		public static void Serialize(BufferStream stream, CookingItem instance)
		{
			if (instance.itemID != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
			}
			if (instance.slotIndex != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
			}
			if (instance.initialStackSize != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.initialStackSize);
			}
			if (instance.cookingProgress != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.cookingProgress);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public float cookSpeed;

	[NonSerialized]
	public List<CookingItem> cookingItems;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseOven instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.cookSpeed = 0f;
		if (instance.cookingItems != null)
		{
			for (int i = 0; i < instance.cookingItems.Count; i++)
			{
				if (instance.cookingItems[i] != null)
				{
					instance.cookingItems[i].ResetToPool();
					instance.cookingItems[i] = null;
				}
			}
			List<CookingItem> list = instance.cookingItems;
			Pool.Free<CookingItem>(ref list, false);
			instance.cookingItems = list;
		}
		Pool.Free<BaseOven>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseOven with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseOven instance)
	{
		instance.cookSpeed = cookSpeed;
		if (cookingItems != null)
		{
			instance.cookingItems = Pool.Get<List<CookingItem>>();
			for (int i = 0; i < cookingItems.Count; i++)
			{
				CookingItem item = cookingItems[i].Copy();
				instance.cookingItems.Add(item);
			}
		}
		else
		{
			instance.cookingItems = null;
		}
	}

	public BaseOven Copy()
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		CopyTo(baseOven);
		return baseOven;
	}

	public static BaseOven Deserialize(BufferStream stream)
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		Deserialize(stream, baseOven, isDelta: false);
		return baseOven;
	}

	public static BaseOven DeserializeLengthDelimited(BufferStream stream)
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		DeserializeLengthDelimited(stream, baseOven, isDelta: false);
		return baseOven;
	}

	public static BaseOven DeserializeLength(BufferStream stream, int length)
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		DeserializeLength(stream, length, baseOven, isDelta: false);
		return baseOven;
	}

	public static BaseOven Deserialize(byte[] buffer)
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseOven, isDelta: false);
		return baseOven;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseOven previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseOven Deserialize(BufferStream stream, BaseOven instance, bool isDelta)
	{
		if (!isDelta && instance.cookingItems == null)
		{
			instance.cookingItems = Pool.Get<List<CookingItem>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.cookSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				instance.cookingItems.Add(CookingItem.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseOven DeserializeLengthDelimited(BufferStream stream, BaseOven instance, bool isDelta)
	{
		if (!isDelta && instance.cookingItems == null)
		{
			instance.cookingItems = Pool.Get<List<CookingItem>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.cookSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				instance.cookingItems.Add(CookingItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseOven DeserializeLength(BufferStream stream, int length, BaseOven instance, bool isDelta)
	{
		if (!isDelta && instance.cookingItems == null)
		{
			instance.cookingItems = Pool.Get<List<CookingItem>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.cookSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				instance.cookingItems.Add(CookingItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseOven instance, BaseOven previous)
	{
		if (instance.cookSpeed != previous.cookSpeed)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.cookSpeed);
		}
		if (instance.cookingItems == null)
		{
			return;
		}
		for (int i = 0; i < instance.cookingItems.Count; i++)
		{
			CookingItem cookingItem = instance.cookingItems[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			CookingItem.SerializeDelta(stream, cookingItem, cookingItem);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cookingItems (ProtoBuf.BaseOven.CookingItem)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, BaseOven instance)
	{
		if (instance.cookSpeed != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.cookSpeed);
		}
		if (instance.cookingItems == null)
		{
			return;
		}
		for (int i = 0; i < instance.cookingItems.Count; i++)
		{
			CookingItem instance2 = instance.cookingItems[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			CookingItem.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cookingItems (ProtoBuf.BaseOven.CookingItem)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (cookingItems != null)
		{
			for (int i = 0; i < cookingItems.Count; i++)
			{
				cookingItems[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BrainComponent : IDisposable, IPooled, IProto<BrainComponent>, IProto
{
	[NonSerialized]
	public int currentState;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BrainComponent instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentState = 0;
			Pool.Free<BrainComponent>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BrainComponent with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BrainComponent instance)
	{
		instance.currentState = currentState;
	}

	public BrainComponent Copy()
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		CopyTo(brainComponent);
		return brainComponent;
	}

	public static BrainComponent Deserialize(BufferStream stream)
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		Deserialize(stream, brainComponent, isDelta: false);
		return brainComponent;
	}

	public static BrainComponent DeserializeLengthDelimited(BufferStream stream)
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		DeserializeLengthDelimited(stream, brainComponent, isDelta: false);
		return brainComponent;
	}

	public static BrainComponent DeserializeLength(BufferStream stream, int length)
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		DeserializeLength(stream, length, brainComponent, isDelta: false);
		return brainComponent;
	}

	public static BrainComponent Deserialize(byte[] buffer)
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, brainComponent, isDelta: false);
		return brainComponent;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BrainComponent previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BrainComponent Deserialize(BufferStream stream, BrainComponent instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.currentState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BrainComponent DeserializeLengthDelimited(BufferStream stream, BrainComponent instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BrainComponent DeserializeLength(BufferStream stream, int length, BrainComponent instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BrainComponent instance, BrainComponent previous)
	{
		if (instance.currentState != previous.currentState)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentState);
		}
	}

	public static void Serialize(BufferStream stream, BrainComponent instance)
	{
		if (instance.currentState != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentState);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ProceduralDungeon : IDisposable, IPooled, IProto<ProceduralDungeon>, IProto
{
	[NonSerialized]
	public uint seed;

	[NonSerialized]
	public NetworkableId exitPortalID;

	[NonSerialized]
	public Vector3 mapOffset;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ProceduralDungeon instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.seed = 0u;
			instance.exitPortalID = default(NetworkableId);
			instance.mapOffset = default(Vector3);
			Pool.Free<ProceduralDungeon>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ProceduralDungeon with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ProceduralDungeon instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.seed = seed;
		instance.exitPortalID = exitPortalID;
		instance.mapOffset = mapOffset;
	}

	public ProceduralDungeon Copy()
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		CopyTo(proceduralDungeon);
		return proceduralDungeon;
	}

	public static ProceduralDungeon Deserialize(BufferStream stream)
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		Deserialize(stream, proceduralDungeon, isDelta: false);
		return proceduralDungeon;
	}

	public static ProceduralDungeon DeserializeLengthDelimited(BufferStream stream)
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		DeserializeLengthDelimited(stream, proceduralDungeon, isDelta: false);
		return proceduralDungeon;
	}

	public static ProceduralDungeon DeserializeLength(BufferStream stream, int length)
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		DeserializeLength(stream, length, proceduralDungeon, isDelta: false);
		return proceduralDungeon;
	}

	public static ProceduralDungeon Deserialize(byte[] buffer)
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, proceduralDungeon, isDelta: false);
		return proceduralDungeon;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ProceduralDungeon previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ProceduralDungeon Deserialize(BufferStream stream, ProceduralDungeon instance, bool isDelta)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.exitPortalID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mapOffset, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ProceduralDungeon DeserializeLengthDelimited(BufferStream stream, ProceduralDungeon instance, bool isDelta)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.exitPortalID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mapOffset, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ProceduralDungeon DeserializeLength(BufferStream stream, int length, ProceduralDungeon instance, bool isDelta)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.exitPortalID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mapOffset, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ProceduralDungeon instance, ProceduralDungeon previous)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (instance.seed != previous.seed)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.exitPortalID.Value);
		if (instance.mapOffset != previous.mapOffset)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.mapOffset, previous.mapOffset);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mapOffset (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ProceduralDungeon instance)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (instance.seed != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.exitPortalID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.exitPortalID.Value);
		}
		if (instance.mapOffset != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.mapOffset);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mapOffset (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref exitPortalID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class IndustrialConveyor : IDisposable, IPooled, IProto<IndustrialConveyor>, IProto
{
	public class ItemFilter : IDisposable, IPooled, IProto<ItemFilter>, IProto
	{
		[NonSerialized]
		public int itemDef;

		[NonSerialized]
		public int itemCategory;

		[NonSerialized]
		public int maxAmountInDestination;

		[NonSerialized]
		public int isBlueprint;

		[NonSerialized]
		public int bufferAmount;

		[NonSerialized]
		public int retainMinimum;

		[NonSerialized]
		public int bufferTransferRemaining;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ItemFilter instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemDef = 0;
				instance.itemCategory = 0;
				instance.maxAmountInDestination = 0;
				instance.isBlueprint = 0;
				instance.bufferAmount = 0;
				instance.retainMinimum = 0;
				instance.bufferTransferRemaining = 0;
				Pool.Free<ItemFilter>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ItemFilter with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ItemFilter instance)
		{
			instance.itemDef = itemDef;
			instance.itemCategory = itemCategory;
			instance.maxAmountInDestination = maxAmountInDestination;
			instance.isBlueprint = isBlueprint;
			instance.bufferAmount = bufferAmount;
			instance.retainMinimum = retainMinimum;
			instance.bufferTransferRemaining = bufferTransferRemaining;
		}

		public ItemFilter Copy()
		{
			ItemFilter itemFilter = Pool.Get<ItemFilter>();
			CopyTo(itemFilter);
			return itemFilter;
		}

		public static ItemFilter Deserialize(BufferStream stream)
		{
			ItemFilter itemFilter = Pool.Get<ItemFilter>();
			Deserialize(stream, itemFilter, isDelta: false);
			return itemFilter;
		}

		public static ItemFilter DeserializeLengthDelimited(BufferStream stream)
		{
			ItemFilter itemFilter = Pool.Get<ItemFilter>();
			DeserializeLengthDelimited(stream, itemFilter, isDelta: false);
			return itemFilter;
		}

		public static ItemFilter DeserializeLength(BufferStream stream, int length)
		{
			ItemFilter itemFilter = Pool.Get<ItemFilter>();
			DeserializeLength(stream, length, itemFilter, isDelta: false);
			return itemFilter;
		}

		public static ItemFilter Deserialize(byte[] buffer)
		{
			ItemFilter itemFilter = Pool.Get<ItemFilter>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, itemFilter, isDelta: false);
			return itemFilter;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ItemFilter previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ItemFilter Deserialize(BufferStream stream, ItemFilter instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ItemFilter DeserializeLengthDelimited(BufferStream stream, ItemFilter instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ItemFilter DeserializeLength(BufferStream stream, int length, ItemFilter instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ItemFilter instance, ItemFilter previous)
		{
			if (instance.itemDef != previous.itemDef)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemDef);
			}
			if (instance.itemCategory != previous.itemCategory)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCategory);
			}
			if (instance.maxAmountInDestination != previous.maxAmountInDestination)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.maxAmountInDestination);
			}
			if (instance.isBlueprint != previous.isBlueprint)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.isBlueprint);
			}
			if (instance.bufferAmount != previous.bufferAmount)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferAmount);
			}
			if (instance.retainMinimum != previous.retainMinimum)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.retainMinimum);
			}
			if (instance.bufferTransferRemaining != previous.bufferTransferRemaining)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferTransferRemaining);
			}
		}

		public static void Serialize(BufferStream stream, ItemFilter instance)
		{
			if (instance.itemDef != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemDef);
			}
			if (instance.itemCategory != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCategory);
			}
			if (instance.maxAmountInDestination != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.maxAmountInDestination);
			}
			if (instance.isBlueprint != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.isBlueprint);
			}
			if (instance.bufferAmount != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferAmount);
			}
			if (instance.retainMinimum != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.retainMinimum);
			}
			if (instance.bufferTransferRemaining != 0)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferTransferRemaining);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class ItemFilterList : IDisposable, IPooled, IProto<ItemFilterList>, IProto
	{
		[NonSerialized]
		public List<ItemFilter> filters;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ItemFilterList instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.filters != null)
			{
				for (int i = 0; i < instance.filters.Count; i++)
				{
					if (instance.filters[i] != null)
					{
						instance.filters[i].ResetToPool();
						instance.filters[i] = null;
					}
				}
				List<ItemFilter> list = instance.filters;
				Pool.Free<ItemFilter>(ref list, false);
				instance.filters = list;
			}
			Pool.Free<ItemFilterList>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ItemFilterList with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ItemFilterList instance)
		{
			if (filters != null)
			{
				instance.filters = Pool.Get<List<ItemFilter>>();
				for (int i = 0; i < filters.Count; i++)
				{
					ItemFilter item = filters[i].Copy();
					instance.filters.Add(item);
				}
			}
			else
			{
				instance.filters = null;
			}
		}

		public ItemFilterList Copy()
		{
			ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
			CopyTo(itemFilterList);
			return itemFilterList;
		}

		public static ItemFilterList Deserialize(BufferStream stream)
		{
			ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
			Deserialize(stream, itemFilterList, isDelta: false);
			return itemFilterList;
		}

		public static ItemFilterList DeserializeLengthDelimited(BufferStream stream)
		{
			ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
			DeserializeLengthDelimited(stream, itemFilterList, isDelta: false);
			return itemFilterList;
		}

		public static ItemFilterList DeserializeLength(BufferStream stream, int length)
		{
			ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
			DeserializeLength(stream, length, itemFilterList, isDelta: false);
			return itemFilterList;
		}

		public static ItemFilterList Deserialize(byte[] buffer)
		{
			ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, itemFilterList, isDelta: false);
			return itemFilterList;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ItemFilterList previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ItemFilterList Deserialize(BufferStream stream, ItemFilterList instance, bool isDelta)
		{
			if (!isDelta && instance.filters == null)
			{
				instance.filters = Pool.Get<List<ItemFilter>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ItemFilterList DeserializeLengthDelimited(BufferStream stream, ItemFilterList instance, bool isDelta)
		{
			if (!isDelta && instance.filters == null)
			{
				instance.filters = Pool.Get<List<ItemFilter>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ItemFilterList DeserializeLength(BufferStream stream, int length, ItemFilterList instance, bool isDelta)
		{
			if (!isDelta && instance.filters == null)
			{
				instance.filters = Pool.Get<List<ItemFilter>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ItemFilterList instance, ItemFilterList previous)
		{
			if (instance.filters == null)
			{
				return;
			}
			for (int i = 0; i < instance.filters.Count; i++)
			{
				ItemFilter itemFilter = instance.filters[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ItemFilter.SerializeDelta(stream, itemFilter, itemFilter);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field filters (ProtoBuf.IndustrialConveyor.ItemFilter)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}

		public static void Serialize(BufferStream stream, ItemFilterList instance)
		{
			if (instance.filters == null)
			{
				return;
			}
			for (int i = 0; i < instance.filters.Count; i++)
			{
				ItemFilter instance2 = instance.filters[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ItemFilter.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field filters (ProtoBuf.IndustrialConveyor.ItemFilter)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (filters != null)
			{
				for (int i = 0; i < filters.Count; i++)
				{
					filters[i]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public List<ItemFilter> filters;

	[NonSerialized]
	public int conveyorMode;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(IndustrialConveyor instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.filters != null)
		{
			for (int i = 0; i < instance.filters.Count; i++)
			{
				if (instance.filters[i] != null)
				{
					instance.filters[i].ResetToPool();
					instance.filters[i] = null;
				}
			}
			List<ItemFilter> list = instance.filters;
			Pool.Free<ItemFilter>(ref list, false);
			instance.filters = list;
		}
		instance.conveyorMode = 0;
		Pool.Free<IndustrialConveyor>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose IndustrialConveyor with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(IndustrialConveyor instance)
	{
		if (filters != null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
			for (int i = 0; i < filters.Count; i++)
			{
				ItemFilter item = filters[i].Copy();
				instance.filters.Add(item);
			}
		}
		else
		{
			instance.filters = null;
		}
		instance.conveyorMode = conveyorMode;
	}

	public IndustrialConveyor Copy()
	{
		IndustrialConveyor industrialConveyor = Pool.Get<IndustrialConveyor>();
		CopyTo(industrialConveyor);
		return industrialConveyor;
	}

	public static IndustrialConveyor Deserialize(BufferStream stream)
	{
		IndustrialConveyor industrialConveyor = Pool.Get<IndustrialConveyor>();
		Deserialize(stream, industrialConveyor, isDelta: false);
		return industrialConveyor;
	}

	public static IndustrialConveyor DeserializeLengthDelimited(BufferStream stream)
	{
		IndustrialConveyor industrialConveyor = Pool.Get<IndustrialConveyor>();
		DeserializeLengthDelimited(stream, industrialConveyor, isDelta: false);
		return industrialConveyor;
	}

	public static IndustrialConveyor DeserializeLength(BufferStream stream, int length)
	{
		IndustrialConveyor industrialConveyor = Pool.Get<IndustrialConveyor>();
		DeserializeLength(stream, length, industrialConveyor, isDelta: false);
		return industrialConveyor;
	}

	public static IndustrialConveyor Deserialize(byte[] buffer)
	{
		IndustrialConveyor industrialConveyor = Pool.Get<IndustrialConveyor>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, industrialConveyor, isDelta: false);
		return industrialConveyor;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, IndustrialConveyor previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static IndustrialConveyor Deserialize(BufferStream stream, IndustrialConveyor instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.conveyorMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static IndustrialConveyor DeserializeLengthDelimited(BufferStream stream, IndustrialConveyor instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.conveyorMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static IndustrialConveyor DeserializeLength(BufferStream stream, int length, IndustrialConveyor instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.conveyorMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, IndustrialConveyor instance, IndustrialConveyor previous)
	{
		if (instance.filters != null)
		{
			for (int i = 0; i < instance.filters.Count; i++)
			{
				ItemFilter itemFilter = instance.filters[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ItemFilter.SerializeDelta(stream, itemFilter, itemFilter);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field filters (ProtoBuf.IndustrialConveyor.ItemFilter)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.conveyorMode != previous.conveyorMode)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.conveyorMode);
		}
	}

	public static void Serialize(BufferStream stream, IndustrialConveyor instance)
	{
		if (instance.filters != null)
		{
			for (int i = 0; i < instance.filters.Count; i++)
			{
				ItemFilter instance2 = instance.filters[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ItemFilter.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field filters (ProtoBuf.IndustrialConveyor.ItemFilter)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.conveyorMode != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.conveyorMode);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (filters != null)
		{
			for (int i = 0; i < filters.Count; i++)
			{
				filters[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class IndustrialCrafter : IDisposable, IPooled, IProto<IndustrialCrafter>, IProto
{
	[NonSerialized]
	public int currentlyCrafting;

	[NonSerialized]
	public int currentlyCraftingAmount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(IndustrialCrafter instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentlyCrafting = 0;
			instance.currentlyCraftingAmount = 0;
			Pool.Free<IndustrialCrafter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose IndustrialCrafter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(IndustrialCrafter instance)
	{
		instance.currentlyCrafting = currentlyCrafting;
		instance.currentlyCraftingAmount = currentlyCraftingAmount;
	}

	public IndustrialCrafter Copy()
	{
		IndustrialCrafter industrialCrafter = Pool.Get<IndustrialCrafter>();
		CopyTo(industrialCrafter);
		return industrialCrafter;
	}

	public static IndustrialCrafter Deserialize(BufferStream stream)
	{
		IndustrialCrafter industrialCrafter = Pool.Get<IndustrialCrafter>();
		Deserialize(stream, industrialCrafter, isDelta: false);
		return industrialCrafter;
	}

	public static IndustrialCrafter DeserializeLengthDelimited(BufferStream stream)
	{
		IndustrialCrafter industrialCrafter = Pool.Get<IndustrialCrafter>();
		DeserializeLengthDelimited(stream, industrialCrafter, isDelta: false);
		return industrialCrafter;
	}

	public static IndustrialCrafter DeserializeLength(BufferStream stream, int length)
	{
		IndustrialCrafter industrialCrafter = Pool.Get<IndustrialCrafter>();
		DeserializeLength(stream, length, industrialCrafter, isDelta: false);
		return industrialCrafter;
	}

	public static IndustrialCrafter Deserialize(byte[] buffer)
	{
		IndustrialCrafter industrialCrafter = Pool.Get<IndustrialCrafter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, industrialCrafter, isDelta: false);
		return industrialCrafter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, IndustrialCrafter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static IndustrialCrafter Deserialize(BufferStream stream, IndustrialCrafter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.currentlyCrafting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.currentlyCraftingAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static IndustrialCrafter DeserializeLengthDelimited(BufferStream stream, IndustrialCrafter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentlyCrafting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.currentlyCraftingAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static IndustrialCrafter DeserializeLength(BufferStream stream, int length, IndustrialCrafter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentlyCrafting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.currentlyCraftingAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, IndustrialCrafter instance, IndustrialCrafter previous)
	{
		if (instance.currentlyCrafting != previous.currentlyCrafting)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentlyCrafting);
		}
		if (instance.currentlyCraftingAmount != previous.currentlyCraftingAmount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentlyCraftingAmount);
		}
	}

	public static void Serialize(BufferStream stream, IndustrialCrafter instance)
	{
		if (instance.currentlyCrafting != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentlyCrafting);
		}
		if (instance.currentlyCraftingAmount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentlyCraftingAmount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class IndustrialConveyorTransfer : IDisposable, IPooled, IProto<IndustrialConveyorTransfer>, IProto
{
	public struct ItemTransfer : IProto<ItemTransfer>, IProto
	{
		[NonSerialized]
		public int itemId;

		[NonSerialized]
		public int amount;

		public static void ResetToPool(ItemTransfer instance)
		{
			instance.itemId = 0;
			instance.amount = 0;
		}

		public void CopyTo(ItemTransfer instance)
		{
			instance.itemId = itemId;
			instance.amount = amount;
		}

		public ItemTransfer Copy()
		{
			ItemTransfer itemTransfer = default(ItemTransfer);
			CopyTo(itemTransfer);
			return itemTransfer;
		}

		public static ItemTransfer Deserialize(BufferStream stream)
		{
			ItemTransfer instance = default(ItemTransfer);
			Deserialize(stream, ref instance, isDelta: false);
			return instance;
		}

		public static ItemTransfer DeserializeLengthDelimited(BufferStream stream)
		{
			ItemTransfer instance = default(ItemTransfer);
			DeserializeLengthDelimited(stream, ref instance, isDelta: false);
			return instance;
		}

		public static ItemTransfer DeserializeLength(BufferStream stream, int length)
		{
			ItemTransfer instance = default(ItemTransfer);
			DeserializeLength(stream, length, ref instance, isDelta: false);
			return instance;
		}

		public static ItemTransfer Deserialize(byte[] buffer)
		{
			ItemTransfer instance = default(ItemTransfer);
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, ref instance, isDelta: false);
			return instance;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, ref this, isDelta);
		}

		public void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void WriteToStreamDelta(BufferStream stream, ItemTransfer previous)
		{
			SerializeDelta(stream, this, previous);
		}

		public void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, ref this, isDelta);
		}

		public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, ref this, isDelta);
		}

		public static ItemTransfer Deserialize(BufferStream stream, ref ItemTransfer instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ItemTransfer DeserializeLengthDelimited(BufferStream stream, ref ItemTransfer instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ItemTransfer DeserializeLength(BufferStream stream, int length, ref ItemTransfer instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ItemTransfer instance, ItemTransfer previous)
		{
			if (instance.itemId != previous.itemId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.amount != previous.amount)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
			}
		}

		public static void Serialize(BufferStream stream, ItemTransfer instance)
		{
			if (instance.itemId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.amount != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<ItemTransfer> ItemTransfers;

	[NonSerialized]
	public List<NetworkableId> inputEntities;

	[NonSerialized]
	public List<NetworkableId> outputEntities;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(IndustrialConveyorTransfer instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.ItemTransfers != null)
			{
				List<ItemTransfer> itemTransfers = instance.ItemTransfers;
				Pool.FreeUnmanaged<ItemTransfer>(ref itemTransfers);
				instance.ItemTransfers = itemTransfers;
			}
			if (instance.inputEntities != null)
			{
				List<NetworkableId> list = instance.inputEntities;
				Pool.FreeUnmanaged<NetworkableId>(ref list);
				instance.inputEntities = list;
			}
			if (instance.outputEntities != null)
			{
				List<NetworkableId> list2 = instance.outputEntities;
				Pool.FreeUnmanaged<NetworkableId>(ref list2);
				instance.outputEntities = list2;
			}
			Pool.Free<IndustrialConveyorTransfer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose IndustrialConveyorTransfer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(IndustrialConveyorTransfer instance)
	{
		if (ItemTransfers != null)
		{
			instance.ItemTransfers = Pool.Get<List<ItemTransfer>>();
			for (int i = 0; i < ItemTransfers.Count; i++)
			{
				ItemTransfer item = ItemTransfers[i];
				instance.ItemTransfers.Add(item);
			}
		}
		else
		{
			instance.ItemTransfers = null;
		}
		if (inputEntities != null)
		{
			instance.inputEntities = Pool.Get<List<NetworkableId>>();
			for (int j = 0; j < inputEntities.Count; j++)
			{
				NetworkableId item2 = inputEntities[j];
				instance.inputEntities.Add(item2);
			}
		}
		else
		{
			instance.inputEntities = null;
		}
		if (outputEntities != null)
		{
			instance.outputEntities = Pool.Get<List<NetworkableId>>();
			for (int k = 0; k < outputEntities.Count; k++)
			{
				NetworkableId item3 = outputEntities[k];
				instance.outputEntities.Add(item3);
			}
		}
		else
		{
			instance.outputEntities = null;
		}
	}

	public IndustrialConveyorTransfer Copy()
	{
		IndustrialConveyorTransfer industrialConveyorTransfer = Pool.Get<IndustrialConveyorTransfer>();
		CopyTo(industrialConveyorTransfer);
		return industrialConveyorTransfer;
	}

	public static IndustrialConveyorTransfer Deserialize(BufferStream stream)
	{
		IndustrialConveyorTransfer industrialConveyorTransfer = Pool.Get<IndustrialConveyorTransfer>();
		Deserialize(stream, industrialConveyorTransfer, isDelta: false);
		return industrialConveyorTransfer;
	}

	public static IndustrialConveyorTransfer DeserializeLengthDelimited(BufferStream stream)
	{
		IndustrialConveyorTransfer industrialConveyorTransfer = Pool.Get<IndustrialConveyorTransfer>();
		DeserializeLengthDelimited(stream, industrialConveyorTransfer, isDelta: false);
		return industrialConveyorTransfer;
	}

	public static IndustrialConveyorTransfer DeserializeLength(BufferStream stream, int length)
	{
		IndustrialConveyorTransfer industrialConveyorTransfer = Pool.Get<IndustrialConveyorTransfer>();
		DeserializeLength(stream, length, industrialConveyorTransfer, isDelta: false);
		return industrialConveyorTransfer;
	}

	public static IndustrialConveyorTransfer Deserialize(byte[] buffer)
	{
		IndustrialConveyorTransfer industrialConveyorTransfer = Pool.Get<IndustrialConveyorTransfer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, industrialConveyorTransfer, isDelta: false);
		return industrialConveyorTransfer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, IndustrialConveyorTransfer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static IndustrialConveyorTransfer Deserialize(BufferStream stream, IndustrialConveyorTransfer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.ItemTransfers == null)
			{
				instance.ItemTransfers = Pool.Get<List<ItemTransfer>>();
			}
			if (instance.inputEntities == null)
			{
				instance.inputEntities = Pool.Get<List<NetworkableId>>();
			}
			if (instance.outputEntities == null)
			{
				instance.outputEntities = Pool.Get<List<NetworkableId>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				ItemTransfer instance2 = default(ItemTransfer);
				ItemTransfer.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.ItemTransfers.Add(instance2);
				break;
			}
			case 16:
				instance.inputEntities.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				break;
			case 24:
				instance.outputEntities.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static IndustrialConveyorTransfer DeserializeLengthDelimited(BufferStream stream, IndustrialConveyorTransfer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.ItemTransfers == null)
			{
				instance.ItemTransfers = Pool.Get<List<ItemTransfer>>();
			}
			if (instance.inputEntities == null)
			{
				instance.inputEntities = Pool.Get<List<NetworkableId>>();
			}
			if (instance.outputEntities == null)
			{
				instance.outputEntities = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				ItemTransfer instance2 = default(ItemTransfer);
				ItemTransfer.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.ItemTransfers.Add(instance2);
				break;
			}
			case 16:
				instance.inputEntities.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				break;
			case 24:
				instance.outputEntities.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static IndustrialConveyorTransfer DeserializeLength(BufferStream stream, int length, IndustrialConveyorTransfer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.ItemTransfers == null)
			{
				instance.ItemTransfers = Pool.Get<List<ItemTransfer>>();
			}
			if (instance.inputEntities == null)
			{
				instance.inputEntities = Pool.Get<List<NetworkableId>>();
			}
			if (instance.outputEntities == null)
			{
				instance.outputEntities = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				ItemTransfer instance2 = default(ItemTransfer);
				ItemTransfer.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.ItemTransfers.Add(instance2);
				break;
			}
			case 16:
				instance.inputEntities.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				break;
			case 24:
				instance.outputEntities.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, IndustrialConveyorTransfer instance, IndustrialConveyorTransfer previous)
	{
		if (instance.ItemTransfers != null)
		{
			for (int i = 0; i < instance.ItemTransfers.Count; i++)
			{
				ItemTransfer itemTransfer = instance.ItemTransfers[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ItemTransfer.SerializeDelta(stream, itemTransfer, itemTransfer);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ItemTransfers (ProtoBuf.IndustrialConveyorTransfer.ItemTransfer)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.inputEntities != null)
		{
			for (int j = 0; j < instance.inputEntities.Count; j++)
			{
				NetworkableId networkableId = instance.inputEntities[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
		if (instance.outputEntities != null)
		{
			for (int k = 0; k < instance.outputEntities.Count; k++)
			{
				NetworkableId networkableId2 = instance.outputEntities[k];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, networkableId2.Value);
			}
		}
	}

	public static void Serialize(BufferStream stream, IndustrialConveyorTransfer instance)
	{
		if (instance.ItemTransfers != null)
		{
			for (int i = 0; i < instance.ItemTransfers.Count; i++)
			{
				ItemTransfer instance2 = instance.ItemTransfers[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ItemTransfer.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ItemTransfers (ProtoBuf.IndustrialConveyorTransfer.ItemTransfer)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.inputEntities != null)
		{
			for (int j = 0; j < instance.inputEntities.Count; j++)
			{
				NetworkableId networkableId = instance.inputEntities[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
		if (instance.outputEntities != null)
		{
			for (int k = 0; k < instance.outputEntities.Count; k++)
			{
				NetworkableId networkableId2 = instance.outputEntities[k];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, networkableId2.Value);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (ItemTransfers != null)
		{
			for (int i = 0; i < ItemTransfers.Count; i++)
			{
				ItemTransfers[i].InspectUids(action);
			}
		}
		for (int j = 0; j < inputEntities.Count; j++)
		{
			NetworkableId value = inputEntities[j];
			action(UidType.NetworkableId, ref value.Value);
			inputEntities[j] = value;
		}
		for (int k = 0; k < outputEntities.Count; k++)
		{
			NetworkableId value2 = outputEntities[k];
			action(UidType.NetworkableId, ref value2.Value);
			outputEntities[k] = value2;
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Drone : IDisposable, IPooled, IProto<Drone>, IProto
{
	[NonSerialized]
	public float pitch;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Drone instance)
	{
		if (instance.ShouldPool)
		{
			instance.pitch = 0f;
			Pool.Free<Drone>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Drone with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Drone instance)
	{
		instance.pitch = pitch;
	}

	public Drone Copy()
	{
		Drone drone = Pool.Get<Drone>();
		CopyTo(drone);
		return drone;
	}

	public static Drone Deserialize(BufferStream stream)
	{
		Drone drone = Pool.Get<Drone>();
		Deserialize(stream, drone, isDelta: false);
		return drone;
	}

	public static Drone DeserializeLengthDelimited(BufferStream stream)
	{
		Drone drone = Pool.Get<Drone>();
		DeserializeLengthDelimited(stream, drone, isDelta: false);
		return drone;
	}

	public static Drone DeserializeLength(BufferStream stream, int length)
	{
		Drone drone = Pool.Get<Drone>();
		DeserializeLength(stream, length, drone, isDelta: false);
		return drone;
	}

	public static Drone Deserialize(byte[] buffer)
	{
		Drone drone = Pool.Get<Drone>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, drone, isDelta: false);
		return drone;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Drone previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Drone Deserialize(BufferStream stream, Drone instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Drone DeserializeLengthDelimited(BufferStream stream, Drone instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Drone DeserializeLength(BufferStream stream, int length, Drone instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Drone instance, Drone previous)
	{
		if (instance.pitch != previous.pitch)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
	}

	public static void Serialize(BufferStream stream, Drone instance)
	{
		if (instance.pitch != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TimedExplosive : IDisposable, IPooled, IProto<TimedExplosive>, IProto
{
	[NonSerialized]
	public NetworkableId parentid;

	[NonSerialized]
	public Vector3 pos;

	[NonSerialized]
	public Vector3 normal;

	[NonSerialized]
	public bool rfOn;

	[NonSerialized]
	public int freq;

	[NonSerialized]
	public ulong creatorID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TimedExplosive instance)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.parentid = default(NetworkableId);
			instance.pos = default(Vector3);
			instance.normal = default(Vector3);
			instance.rfOn = false;
			instance.freq = 0;
			instance.creatorID = 0uL;
			Pool.Free<TimedExplosive>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TimedExplosive with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TimedExplosive instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.parentid = parentid;
		instance.pos = pos;
		instance.normal = normal;
		instance.rfOn = rfOn;
		instance.freq = freq;
		instance.creatorID = creatorID;
	}

	public TimedExplosive Copy()
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		CopyTo(timedExplosive);
		return timedExplosive;
	}

	public static TimedExplosive Deserialize(BufferStream stream)
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		Deserialize(stream, timedExplosive, isDelta: false);
		return timedExplosive;
	}

	public static TimedExplosive DeserializeLengthDelimited(BufferStream stream)
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		DeserializeLengthDelimited(stream, timedExplosive, isDelta: false);
		return timedExplosive;
	}

	public static TimedExplosive DeserializeLength(BufferStream stream, int length)
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		DeserializeLength(stream, length, timedExplosive, isDelta: false);
		return timedExplosive;
	}

	public static TimedExplosive Deserialize(byte[] buffer)
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, timedExplosive, isDelta: false);
		return timedExplosive;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TimedExplosive previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TimedExplosive Deserialize(BufferStream stream, TimedExplosive instance, bool isDelta)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 32:
				instance.rfOn = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.freq = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.creatorID = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TimedExplosive DeserializeLengthDelimited(BufferStream stream, TimedExplosive instance, bool isDelta)
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 32:
				instance.rfOn = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.freq = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.creatorID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TimedExplosive DeserializeLength(BufferStream stream, int length, TimedExplosive instance, bool isDelta)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 32:
				instance.rfOn = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.freq = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.creatorID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TimedExplosive instance, TimedExplosive previous)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.parentid.Value);
		if (instance.pos != previous.pos)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.pos, previous.pos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != previous.normal)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.rfOn);
		if (instance.freq != previous.freq)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.freq);
		}
		if (instance.creatorID != previous.creatorID)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.creatorID);
		}
	}

	public static void Serialize(BufferStream stream, TimedExplosive instance)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (instance.parentid != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentid.Value);
		}
		if (instance.pos != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.pos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rfOn)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.rfOn);
		}
		if (instance.freq != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.freq);
		}
		if (instance.creatorID != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.creatorID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref parentid.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AttackHeli : IDisposable, IPooled, IProto<AttackHeli>, IProto
{
	[NonSerialized]
	public NetworkableId turretID;

	[NonSerialized]
	public NetworkableId rocketsID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AttackHeli instance)
	{
		if (instance.ShouldPool)
		{
			instance.turretID = default(NetworkableId);
			instance.rocketsID = default(NetworkableId);
			Pool.Free<AttackHeli>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AttackHeli with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AttackHeli instance)
	{
		instance.turretID = turretID;
		instance.rocketsID = rocketsID;
	}

	public AttackHeli Copy()
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		CopyTo(attackHeli);
		return attackHeli;
	}

	public static AttackHeli Deserialize(BufferStream stream)
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		Deserialize(stream, attackHeli, isDelta: false);
		return attackHeli;
	}

	public static AttackHeli DeserializeLengthDelimited(BufferStream stream)
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		DeserializeLengthDelimited(stream, attackHeli, isDelta: false);
		return attackHeli;
	}

	public static AttackHeli DeserializeLength(BufferStream stream, int length)
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		DeserializeLength(stream, length, attackHeli, isDelta: false);
		return attackHeli;
	}

	public static AttackHeli Deserialize(byte[] buffer)
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, attackHeli, isDelta: false);
		return attackHeli;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AttackHeli previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AttackHeli Deserialize(BufferStream stream, AttackHeli instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.turretID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.rocketsID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AttackHeli DeserializeLengthDelimited(BufferStream stream, AttackHeli instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.turretID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.rocketsID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AttackHeli DeserializeLength(BufferStream stream, int length, AttackHeli instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.turretID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.rocketsID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AttackHeli instance, AttackHeli previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.turretID.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.rocketsID.Value);
	}

	public static void Serialize(BufferStream stream, AttackHeli instance)
	{
		if (instance.turretID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.turretID.Value);
		}
		if (instance.rocketsID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.rocketsID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref turretID.Value);
		action(UidType.NetworkableId, ref rocketsID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AttackHeliTurret : IDisposable, IPooled, IProto<AttackHeliTurret>, IProto
{
	[NonSerialized]
	public int clipAmmo;

	[NonSerialized]
	public int totalAmmo;

	[NonSerialized]
	public int gunState;

	[NonSerialized]
	public float xRot;

	[NonSerialized]
	public float yRot;

	[NonSerialized]
	public NetworkableId heldEntityID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AttackHeliTurret instance)
	{
		if (instance.ShouldPool)
		{
			instance.clipAmmo = 0;
			instance.totalAmmo = 0;
			instance.gunState = 0;
			instance.xRot = 0f;
			instance.yRot = 0f;
			instance.heldEntityID = default(NetworkableId);
			Pool.Free<AttackHeliTurret>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AttackHeliTurret with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AttackHeliTurret instance)
	{
		instance.clipAmmo = clipAmmo;
		instance.totalAmmo = totalAmmo;
		instance.gunState = gunState;
		instance.xRot = xRot;
		instance.yRot = yRot;
		instance.heldEntityID = heldEntityID;
	}

	public AttackHeliTurret Copy()
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		CopyTo(attackHeliTurret);
		return attackHeliTurret;
	}

	public static AttackHeliTurret Deserialize(BufferStream stream)
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		Deserialize(stream, attackHeliTurret, isDelta: false);
		return attackHeliTurret;
	}

	public static AttackHeliTurret DeserializeLengthDelimited(BufferStream stream)
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		DeserializeLengthDelimited(stream, attackHeliTurret, isDelta: false);
		return attackHeliTurret;
	}

	public static AttackHeliTurret DeserializeLength(BufferStream stream, int length)
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		DeserializeLength(stream, length, attackHeliTurret, isDelta: false);
		return attackHeliTurret;
	}

	public static AttackHeliTurret Deserialize(byte[] buffer)
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, attackHeliTurret, isDelta: false);
		return attackHeliTurret;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AttackHeliTurret previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AttackHeliTurret Deserialize(BufferStream stream, AttackHeliTurret instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clipAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.gunState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.xRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.heldEntityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AttackHeliTurret DeserializeLengthDelimited(BufferStream stream, AttackHeliTurret instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clipAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.gunState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.xRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.heldEntityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AttackHeliTurret DeserializeLength(BufferStream stream, int length, AttackHeliTurret instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clipAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.gunState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.xRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.heldEntityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AttackHeliTurret instance, AttackHeliTurret previous)
	{
		if (instance.clipAmmo != previous.clipAmmo)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clipAmmo);
		}
		if (instance.totalAmmo != previous.totalAmmo)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAmmo);
		}
		if (instance.gunState != previous.gunState)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gunState);
		}
		if (instance.xRot != previous.xRot)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.xRot);
		}
		if (instance.yRot != previous.yRot)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.yRot);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, instance.heldEntityID.Value);
	}

	public static void Serialize(BufferStream stream, AttackHeliTurret instance)
	{
		if (instance.clipAmmo != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clipAmmo);
		}
		if (instance.totalAmmo != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAmmo);
		}
		if (instance.gunState != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gunState);
		}
		if (instance.xRot != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.xRot);
		}
		if (instance.yRot != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.yRot);
		}
		if (instance.heldEntityID != default(NetworkableId))
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.heldEntityID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref heldEntityID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AttackHeliRockets : IDisposable, IPooled, IProto<AttackHeliRockets>, IProto
{
	[NonSerialized]
	public int totalAmmo;

	[NonSerialized]
	public int rocketsSinceReload;

	[NonSerialized]
	public bool hasFlares;

	[NonSerialized]
	public int ammoItemID;

	[NonSerialized]
	public int preferredAmmoType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AttackHeliRockets instance)
	{
		if (instance.ShouldPool)
		{
			instance.totalAmmo = 0;
			instance.rocketsSinceReload = 0;
			instance.hasFlares = false;
			instance.ammoItemID = 0;
			instance.preferredAmmoType = 0;
			Pool.Free<AttackHeliRockets>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AttackHeliRockets with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AttackHeliRockets instance)
	{
		instance.totalAmmo = totalAmmo;
		instance.rocketsSinceReload = rocketsSinceReload;
		instance.hasFlares = hasFlares;
		instance.ammoItemID = ammoItemID;
		instance.preferredAmmoType = preferredAmmoType;
	}

	public AttackHeliRockets Copy()
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		CopyTo(attackHeliRockets);
		return attackHeliRockets;
	}

	public static AttackHeliRockets Deserialize(BufferStream stream)
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		Deserialize(stream, attackHeliRockets, isDelta: false);
		return attackHeliRockets;
	}

	public static AttackHeliRockets DeserializeLengthDelimited(BufferStream stream)
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		DeserializeLengthDelimited(stream, attackHeliRockets, isDelta: false);
		return attackHeliRockets;
	}

	public static AttackHeliRockets DeserializeLength(BufferStream stream, int length)
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		DeserializeLength(stream, length, attackHeliRockets, isDelta: false);
		return attackHeliRockets;
	}

	public static AttackHeliRockets Deserialize(byte[] buffer)
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, attackHeliRockets, isDelta: false);
		return attackHeliRockets;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AttackHeliRockets previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AttackHeliRockets Deserialize(BufferStream stream, AttackHeliRockets instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rocketsSinceReload = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.hasFlares = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.ammoItemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.preferredAmmoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AttackHeliRockets DeserializeLengthDelimited(BufferStream stream, AttackHeliRockets instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rocketsSinceReload = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.hasFlares = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.ammoItemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.preferredAmmoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AttackHeliRockets DeserializeLength(BufferStream stream, int length, AttackHeliRockets instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rocketsSinceReload = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.hasFlares = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.ammoItemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.preferredAmmoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AttackHeliRockets instance, AttackHeliRockets previous)
	{
		if (instance.totalAmmo != previous.totalAmmo)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAmmo);
		}
		if (instance.rocketsSinceReload != previous.rocketsSinceReload)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rocketsSinceReload);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.hasFlares);
		if (instance.ammoItemID != previous.ammoItemID)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoItemID);
		}
		if (instance.preferredAmmoType != previous.preferredAmmoType)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.preferredAmmoType);
		}
	}

	public static void Serialize(BufferStream stream, AttackHeliRockets instance)
	{
		if (instance.totalAmmo != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAmmo);
		}
		if (instance.rocketsSinceReload != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rocketsSinceReload);
		}
		if (instance.hasFlares)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.hasFlares);
		}
		if (instance.ammoItemID != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoItemID);
		}
		if (instance.preferredAmmoType != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.preferredAmmoType);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanManager : IDisposable, IPooled, IProto<ClanManager>, IProto
{
	[NonSerialized]
	public string backendType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanManager instance)
	{
		if (instance.ShouldPool)
		{
			instance.backendType = string.Empty;
			Pool.Free<ClanManager>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanManager with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanManager instance)
	{
		instance.backendType = backendType;
	}

	public ClanManager Copy()
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		CopyTo(clanManager);
		return clanManager;
	}

	public static ClanManager Deserialize(BufferStream stream)
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		Deserialize(stream, clanManager, isDelta: false);
		return clanManager;
	}

	public static ClanManager DeserializeLengthDelimited(BufferStream stream)
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		DeserializeLengthDelimited(stream, clanManager, isDelta: false);
		return clanManager;
	}

	public static ClanManager DeserializeLength(BufferStream stream, int length)
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		DeserializeLength(stream, length, clanManager, isDelta: false);
		return clanManager;
	}

	public static ClanManager Deserialize(byte[] buffer)
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanManager, isDelta: false);
		return clanManager;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanManager previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanManager Deserialize(BufferStream stream, ClanManager instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.backendType = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanManager DeserializeLengthDelimited(BufferStream stream, ClanManager instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.backendType = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanManager DeserializeLength(BufferStream stream, int length, ClanManager instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.backendType = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanManager instance, ClanManager previous)
	{
		if (instance.backendType != previous.backendType)
		{
			if (instance.backendType == null)
			{
				throw new ArgumentNullException("backendType", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.backendType);
		}
	}

	public static void Serialize(BufferStream stream, ClanManager instance)
	{
		if (instance.backendType == null)
		{
			throw new ArgumentNullException("backendType", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.backendType);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AssociatedFiles : IDisposable, IPooled, IProto<AssociatedFiles>, IProto
{
	public class AssociatedFile : IDisposable, IPooled, IProto<AssociatedFile>, IProto
	{
		[NonSerialized]
		public int type;

		[NonSerialized]
		public uint crc;

		[NonSerialized]
		public uint numID;

		[NonSerialized]
		public byte[] data;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(AssociatedFile instance)
		{
			if (instance.ShouldPool)
			{
				instance.type = 0;
				instance.crc = 0u;
				instance.numID = 0u;
				instance.data = null;
				Pool.Free<AssociatedFile>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose AssociatedFile with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(AssociatedFile instance)
		{
			instance.type = type;
			instance.crc = crc;
			instance.numID = numID;
			if (data == null)
			{
				instance.data = null;
				return;
			}
			instance.data = new byte[data.Length];
			Array.Copy(data, instance.data, instance.data.Length);
		}

		public AssociatedFile Copy()
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			CopyTo(associatedFile);
			return associatedFile;
		}

		public static AssociatedFile Deserialize(BufferStream stream)
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			Deserialize(stream, associatedFile, isDelta: false);
			return associatedFile;
		}

		public static AssociatedFile DeserializeLengthDelimited(BufferStream stream)
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			DeserializeLengthDelimited(stream, associatedFile, isDelta: false);
			return associatedFile;
		}

		public static AssociatedFile DeserializeLength(BufferStream stream, int length)
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			DeserializeLength(stream, length, associatedFile, isDelta: false);
			return associatedFile;
		}

		public static AssociatedFile Deserialize(byte[] buffer)
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, associatedFile, isDelta: false);
			return associatedFile;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, AssociatedFile previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static AssociatedFile Deserialize(BufferStream stream, AssociatedFile instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.crc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 24:
					instance.numID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 34:
					instance.data = ProtocolParser.ReadBytes(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static AssociatedFile DeserializeLengthDelimited(BufferStream stream, AssociatedFile instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.crc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 24:
					instance.numID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 34:
					instance.data = ProtocolParser.ReadBytes(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static AssociatedFile DeserializeLength(BufferStream stream, int length, AssociatedFile instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.crc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 24:
					instance.numID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 34:
					instance.data = ProtocolParser.ReadBytes(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, AssociatedFile instance, AssociatedFile previous)
		{
			if (instance.type != previous.type)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.crc != previous.crc)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt32(stream, instance.crc);
			}
			if (instance.numID != previous.numID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt32(stream, instance.numID);
			}
			if (instance.data == null)
			{
				throw new ArgumentNullException("data", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteBytes(stream, instance.data);
		}

		public static void Serialize(BufferStream stream, AssociatedFile instance)
		{
			if (instance.type != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.crc != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt32(stream, instance.crc);
			}
			if (instance.numID != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt32(stream, instance.numID);
			}
			if (instance.data == null)
			{
				throw new ArgumentNullException("data", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteBytes(stream, instance.data);
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<AssociatedFile> files;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AssociatedFiles instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.files != null)
		{
			for (int i = 0; i < instance.files.Count; i++)
			{
				if (instance.files[i] != null)
				{
					instance.files[i].ResetToPool();
					instance.files[i] = null;
				}
			}
			List<AssociatedFile> list = instance.files;
			Pool.Free<AssociatedFile>(ref list, false);
			instance.files = list;
		}
		Pool.Free<AssociatedFiles>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AssociatedFiles with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AssociatedFiles instance)
	{
		if (files != null)
		{
			instance.files = Pool.Get<List<AssociatedFile>>();
			for (int i = 0; i < files.Count; i++)
			{
				AssociatedFile item = files[i].Copy();
				instance.files.Add(item);
			}
		}
		else
		{
			instance.files = null;
		}
	}

	public AssociatedFiles Copy()
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		CopyTo(associatedFiles);
		return associatedFiles;
	}

	public static AssociatedFiles Deserialize(BufferStream stream)
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		Deserialize(stream, associatedFiles, isDelta: false);
		return associatedFiles;
	}

	public static AssociatedFiles DeserializeLengthDelimited(BufferStream stream)
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		DeserializeLengthDelimited(stream, associatedFiles, isDelta: false);
		return associatedFiles;
	}

	public static AssociatedFiles DeserializeLength(BufferStream stream, int length)
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		DeserializeLength(stream, length, associatedFiles, isDelta: false);
		return associatedFiles;
	}

	public static AssociatedFiles Deserialize(byte[] buffer)
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, associatedFiles, isDelta: false);
		return associatedFiles;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AssociatedFiles previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AssociatedFiles Deserialize(BufferStream stream, AssociatedFiles instance, bool isDelta)
	{
		if (!isDelta && instance.files == null)
		{
			instance.files = Pool.Get<List<AssociatedFile>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.files.Add(AssociatedFile.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AssociatedFiles DeserializeLengthDelimited(BufferStream stream, AssociatedFiles instance, bool isDelta)
	{
		if (!isDelta && instance.files == null)
		{
			instance.files = Pool.Get<List<AssociatedFile>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.files.Add(AssociatedFile.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AssociatedFiles DeserializeLength(BufferStream stream, int length, AssociatedFiles instance, bool isDelta)
	{
		if (!isDelta && instance.files == null)
		{
			instance.files = Pool.Get<List<AssociatedFile>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.files.Add(AssociatedFile.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AssociatedFiles instance, AssociatedFiles previous)
	{
		if (instance.files == null)
		{
			return;
		}
		for (int i = 0; i < instance.files.Count; i++)
		{
			AssociatedFile associatedFile = instance.files[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AssociatedFile.SerializeDelta(stream, associatedFile, associatedFile);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AssociatedFiles instance)
	{
		if (instance.files == null)
		{
			return;
		}
		for (int i = 0; i < instance.files.Count; i++)
		{
			AssociatedFile instance2 = instance.files[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AssociatedFile.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (files != null)
		{
			for (int i = 0; i < files.Count; i++)
			{
				files[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NexusFerry : IDisposable, IPooled, IProto<NexusFerry>, IProto
{
	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public string ownerZone;

	[NonSerialized]
	public List<string> schedule;

	[NonSerialized]
	public int scheduleIndex;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public bool isRetiring;

	[NonSerialized]
	public List<NetworkableId> transferredIds;

	[NonSerialized]
	public int nextScheduleIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NexusFerry instance)
	{
		if (instance.ShouldPool)
		{
			instance.timestamp = 0L;
			instance.ownerZone = string.Empty;
			if (instance.schedule != null)
			{
				List<string> list = instance.schedule;
				Pool.FreeUnmanaged<string>(ref list);
				instance.schedule = list;
			}
			instance.scheduleIndex = 0;
			instance.state = 0;
			instance.isRetiring = false;
			if (instance.transferredIds != null)
			{
				List<NetworkableId> list2 = instance.transferredIds;
				Pool.FreeUnmanaged<NetworkableId>(ref list2);
				instance.transferredIds = list2;
			}
			instance.nextScheduleIndex = 0;
			Pool.Free<NexusFerry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NexusFerry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NexusFerry instance)
	{
		instance.timestamp = timestamp;
		instance.ownerZone = ownerZone;
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<string>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				string item = schedule[i];
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
		instance.scheduleIndex = scheduleIndex;
		instance.state = state;
		instance.isRetiring = isRetiring;
		if (transferredIds != null)
		{
			instance.transferredIds = Pool.Get<List<NetworkableId>>();
			for (int j = 0; j < transferredIds.Count; j++)
			{
				NetworkableId item2 = transferredIds[j];
				instance.transferredIds.Add(item2);
			}
		}
		else
		{
			instance.transferredIds = null;
		}
		instance.nextScheduleIndex = nextScheduleIndex;
	}

	public NexusFerry Copy()
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		CopyTo(nexusFerry);
		return nexusFerry;
	}

	public static NexusFerry Deserialize(BufferStream stream)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		Deserialize(stream, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public static NexusFerry DeserializeLengthDelimited(BufferStream stream)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		DeserializeLengthDelimited(stream, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public static NexusFerry DeserializeLength(BufferStream stream, int length)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		DeserializeLength(stream, length, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public static NexusFerry Deserialize(byte[] buffer)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NexusFerry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NexusFerry Deserialize(BufferStream stream, NexusFerry instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.schedule == null)
			{
				instance.schedule = Pool.Get<List<string>>();
			}
			if (instance.transferredIds == null)
			{
				instance.transferredIds = Pool.Get<List<NetworkableId>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 32:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.transferredIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case 64:
				instance.nextScheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NexusFerry DeserializeLengthDelimited(BufferStream stream, NexusFerry instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.schedule == null)
			{
				instance.schedule = Pool.Get<List<string>>();
			}
			if (instance.transferredIds == null)
			{
				instance.transferredIds = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 32:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.transferredIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case 64:
				instance.nextScheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NexusFerry DeserializeLength(BufferStream stream, int length, NexusFerry instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.schedule == null)
			{
				instance.schedule = Pool.Get<List<string>>();
			}
			if (instance.transferredIds == null)
			{
				instance.transferredIds = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 32:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.transferredIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case 64:
				instance.nextScheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NexusFerry instance, NexusFerry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.ownerZone != null && instance.ownerZone != previous.ownerZone)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.ownerZone);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != previous.scheduleIndex)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.isRetiring);
		if (instance.transferredIds != null)
		{
			for (int j = 0; j < instance.transferredIds.Count; j++)
			{
				NetworkableId networkableId = instance.transferredIds[j];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
		if (instance.nextScheduleIndex != previous.nextScheduleIndex)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextScheduleIndex);
		}
	}

	public static void Serialize(BufferStream stream, NexusFerry instance)
	{
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.ownerZone != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.ownerZone);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.isRetiring)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.isRetiring);
		}
		if (instance.transferredIds != null)
		{
			for (int j = 0; j < instance.transferredIds.Count; j++)
			{
				NetworkableId networkableId = instance.transferredIds[j];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
		if (instance.nextScheduleIndex != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextScheduleIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < transferredIds.Count; i++)
		{
			NetworkableId value = transferredIds[i];
			action(UidType.NetworkableId, ref value.Value);
			transferredIds[i] = value;
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NexusIsland : IDisposable, IPooled, IProto<NexusIsland>, IProto
{
	[NonSerialized]
	public string zoneKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NexusIsland instance)
	{
		if (instance.ShouldPool)
		{
			instance.zoneKey = string.Empty;
			Pool.Free<NexusIsland>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NexusIsland with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NexusIsland instance)
	{
		instance.zoneKey = zoneKey;
	}

	public NexusIsland Copy()
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		CopyTo(nexusIsland);
		return nexusIsland;
	}

	public static NexusIsland Deserialize(BufferStream stream)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		Deserialize(stream, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public static NexusIsland DeserializeLengthDelimited(BufferStream stream)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		DeserializeLengthDelimited(stream, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public static NexusIsland DeserializeLength(BufferStream stream, int length)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		DeserializeLength(stream, length, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public static NexusIsland Deserialize(byte[] buffer)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NexusIsland previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NexusIsland Deserialize(BufferStream stream, NexusIsland instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.zoneKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NexusIsland DeserializeLengthDelimited(BufferStream stream, NexusIsland instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.zoneKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NexusIsland DeserializeLength(BufferStream stream, int length, NexusIsland instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.zoneKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NexusIsland instance, NexusIsland previous)
	{
		if (instance.zoneKey != null && instance.zoneKey != previous.zoneKey)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.zoneKey);
		}
	}

	public static void Serialize(BufferStream stream, NexusIsland instance)
	{
		if (instance.zoneKey != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.zoneKey);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NexusDockTerminal : IDisposable, IPooled, IProto<NexusDockTerminal>, IProto
{
	public class ScheduleEntry : IDisposable, IPooled, IProto<ScheduleEntry>, IProto
	{
		[NonSerialized]
		public int nextZoneId;

		[NonSerialized]
		public int estimate;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ScheduleEntry instance)
		{
			if (instance.ShouldPool)
			{
				instance.nextZoneId = 0;
				instance.estimate = 0;
				Pool.Free<ScheduleEntry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ScheduleEntry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ScheduleEntry instance)
		{
			instance.nextZoneId = nextZoneId;
			instance.estimate = estimate;
		}

		public ScheduleEntry Copy()
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			CopyTo(scheduleEntry);
			return scheduleEntry;
		}

		public static ScheduleEntry Deserialize(BufferStream stream)
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			Deserialize(stream, scheduleEntry, isDelta: false);
			return scheduleEntry;
		}

		public static ScheduleEntry DeserializeLengthDelimited(BufferStream stream)
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			DeserializeLengthDelimited(stream, scheduleEntry, isDelta: false);
			return scheduleEntry;
		}

		public static ScheduleEntry DeserializeLength(BufferStream stream, int length)
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			DeserializeLength(stream, length, scheduleEntry, isDelta: false);
			return scheduleEntry;
		}

		public static ScheduleEntry Deserialize(byte[] buffer)
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, scheduleEntry, isDelta: false);
			return scheduleEntry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ScheduleEntry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ScheduleEntry Deserialize(BufferStream stream, ScheduleEntry instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ScheduleEntry DeserializeLengthDelimited(BufferStream stream, ScheduleEntry instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ScheduleEntry DeserializeLength(BufferStream stream, int length, ScheduleEntry instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ScheduleEntry instance, ScheduleEntry previous)
		{
			if (instance.nextZoneId != previous.nextZoneId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.nextZoneId);
			}
			if (instance.estimate != previous.estimate)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.estimate);
			}
		}

		public static void Serialize(BufferStream stream, ScheduleEntry instance)
		{
			if (instance.nextZoneId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.nextZoneId);
			}
			if (instance.estimate != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.estimate);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<ScheduleEntry> schedule;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NexusDockTerminal instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				if (instance.schedule[i] != null)
				{
					instance.schedule[i].ResetToPool();
					instance.schedule[i] = null;
				}
			}
			List<ScheduleEntry> list = instance.schedule;
			Pool.Free<ScheduleEntry>(ref list, false);
			instance.schedule = list;
		}
		Pool.Free<NexusDockTerminal>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NexusDockTerminal with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NexusDockTerminal instance)
	{
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<ScheduleEntry>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				ScheduleEntry item = schedule[i].Copy();
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
	}

	public NexusDockTerminal Copy()
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		CopyTo(nexusDockTerminal);
		return nexusDockTerminal;
	}

	public static NexusDockTerminal Deserialize(BufferStream stream)
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		Deserialize(stream, nexusDockTerminal, isDelta: false);
		return nexusDockTerminal;
	}

	public static NexusDockTerminal DeserializeLengthDelimited(BufferStream stream)
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		DeserializeLengthDelimited(stream, nexusDockTerminal, isDelta: false);
		return nexusDockTerminal;
	}

	public static NexusDockTerminal DeserializeLength(BufferStream stream, int length)
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		DeserializeLength(stream, length, nexusDockTerminal, isDelta: false);
		return nexusDockTerminal;
	}

	public static NexusDockTerminal Deserialize(byte[] buffer)
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nexusDockTerminal, isDelta: false);
		return nexusDockTerminal;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NexusDockTerminal previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NexusDockTerminal Deserialize(BufferStream stream, NexusDockTerminal instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<ScheduleEntry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.schedule.Add(ScheduleEntry.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NexusDockTerminal DeserializeLengthDelimited(BufferStream stream, NexusDockTerminal instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<ScheduleEntry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.schedule.Add(ScheduleEntry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NexusDockTerminal DeserializeLength(BufferStream stream, int length, NexusDockTerminal instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<ScheduleEntry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.schedule.Add(ScheduleEntry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NexusDockTerminal instance, NexusDockTerminal previous)
	{
		if (instance.schedule == null)
		{
			return;
		}
		for (int i = 0; i < instance.schedule.Count; i++)
		{
			ScheduleEntry scheduleEntry = instance.schedule[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ScheduleEntry.SerializeDelta(stream, scheduleEntry, scheduleEntry);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field schedule (ProtoBuf.NexusDockTerminal.ScheduleEntry)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, NexusDockTerminal instance)
	{
		if (instance.schedule == null)
		{
			return;
		}
		for (int i = 0; i < instance.schedule.Count; i++)
		{
			ScheduleEntry instance2 = instance.schedule[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ScheduleEntry.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field schedule (ProtoBuf.NexusDockTerminal.ScheduleEntry)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (schedule != null)
		{
			for (int i = 0; i < schedule.Count; i++)
			{
				schedule[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseBoat : IDisposable, IPooled, IProto<BaseBoat>, IProto
{
	[NonSerialized]
	public float shoreDriftTimerValue;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseBoat instance)
	{
		if (instance.ShouldPool)
		{
			instance.shoreDriftTimerValue = 0f;
			Pool.Free<BaseBoat>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseBoat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseBoat instance)
	{
		instance.shoreDriftTimerValue = shoreDriftTimerValue;
	}

	public BaseBoat Copy()
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		CopyTo(baseBoat);
		return baseBoat;
	}

	public static BaseBoat Deserialize(BufferStream stream)
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		Deserialize(stream, baseBoat, isDelta: false);
		return baseBoat;
	}

	public static BaseBoat DeserializeLengthDelimited(BufferStream stream)
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		DeserializeLengthDelimited(stream, baseBoat, isDelta: false);
		return baseBoat;
	}

	public static BaseBoat DeserializeLength(BufferStream stream, int length)
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		DeserializeLength(stream, length, baseBoat, isDelta: false);
		return baseBoat;
	}

	public static BaseBoat Deserialize(byte[] buffer)
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseBoat, isDelta: false);
		return baseBoat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseBoat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseBoat Deserialize(BufferStream stream, BaseBoat instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.shoreDriftTimerValue = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseBoat DeserializeLengthDelimited(BufferStream stream, BaseBoat instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.shoreDriftTimerValue = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseBoat DeserializeLength(BufferStream stream, int length, BaseBoat instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.shoreDriftTimerValue = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseBoat instance, BaseBoat previous)
	{
		if (instance.shoreDriftTimerValue != previous.shoreDriftTimerValue)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.shoreDriftTimerValue);
		}
	}

	public static void Serialize(BufferStream stream, BaseBoat instance)
	{
		if (instance.shoreDriftTimerValue != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.shoreDriftTimerValue);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DieselEngine : IDisposable, IPooled, IProto<DieselEngine>, IProto
{
	[NonSerialized]
	public float fuelTime;

	[NonSerialized]
	public ulong startedByPlayer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DieselEngine instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelTime = 0f;
			instance.startedByPlayer = 0uL;
			Pool.Free<DieselEngine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DieselEngine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DieselEngine instance)
	{
		instance.fuelTime = fuelTime;
		instance.startedByPlayer = startedByPlayer;
	}

	public DieselEngine Copy()
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		CopyTo(dieselEngine);
		return dieselEngine;
	}

	public static DieselEngine Deserialize(BufferStream stream)
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		Deserialize(stream, dieselEngine, isDelta: false);
		return dieselEngine;
	}

	public static DieselEngine DeserializeLengthDelimited(BufferStream stream)
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		DeserializeLengthDelimited(stream, dieselEngine, isDelta: false);
		return dieselEngine;
	}

	public static DieselEngine DeserializeLength(BufferStream stream, int length)
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		DeserializeLength(stream, length, dieselEngine, isDelta: false);
		return dieselEngine;
	}

	public static DieselEngine Deserialize(byte[] buffer)
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, dieselEngine, isDelta: false);
		return dieselEngine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DieselEngine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DieselEngine Deserialize(BufferStream stream, DieselEngine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.fuelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.startedByPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DieselEngine DeserializeLengthDelimited(BufferStream stream, DieselEngine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fuelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.startedByPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DieselEngine DeserializeLength(BufferStream stream, int length, DieselEngine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fuelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.startedByPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DieselEngine instance, DieselEngine previous)
	{
		if (instance.fuelTime != previous.fuelTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fuelTime);
		}
		if (instance.startedByPlayer != previous.startedByPlayer)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.startedByPlayer);
		}
	}

	public static void Serialize(BufferStream stream, DieselEngine instance)
	{
		if (instance.fuelTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fuelTime);
		}
		if (instance.startedByPlayer != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.startedByPlayer);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class RockingChair : IDisposable, IPooled, IProto<RockingChair>, IProto
{
	[NonSerialized]
	public Vector3 initEuler;

	[NonSerialized]
	public float initY;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RockingChair instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.initEuler = default(Vector3);
			instance.initY = 0f;
			Pool.Free<RockingChair>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RockingChair with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RockingChair instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.initEuler = initEuler;
		instance.initY = initY;
	}

	public RockingChair Copy()
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		CopyTo(rockingChair);
		return rockingChair;
	}

	public static RockingChair Deserialize(BufferStream stream)
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		Deserialize(stream, rockingChair, isDelta: false);
		return rockingChair;
	}

	public static RockingChair DeserializeLengthDelimited(BufferStream stream)
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		DeserializeLengthDelimited(stream, rockingChair, isDelta: false);
		return rockingChair;
	}

	public static RockingChair DeserializeLength(BufferStream stream, int length)
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		DeserializeLength(stream, length, rockingChair, isDelta: false);
		return rockingChair;
	}

	public static RockingChair Deserialize(byte[] buffer)
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, rockingChair, isDelta: false);
		return rockingChair;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RockingChair previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RockingChair Deserialize(BufferStream stream, RockingChair instance, bool isDelta)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.initEuler, isDelta);
				continue;
			case 21:
				instance.initY = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RockingChair DeserializeLengthDelimited(BufferStream stream, RockingChair instance, bool isDelta)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.initEuler, isDelta);
				continue;
			case 21:
				instance.initY = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RockingChair DeserializeLength(BufferStream stream, int length, RockingChair instance, bool isDelta)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.initEuler, isDelta);
				continue;
			case 21:
				instance.initY = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RockingChair instance, RockingChair previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.initEuler != previous.initEuler)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.initEuler, previous.initEuler);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field initEuler (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.initY != previous.initY)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.initY);
		}
	}

	public static void Serialize(BufferStream stream, RockingChair instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.initEuler != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.initEuler);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field initEuler (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.initY != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.initY);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class HeadData : IDisposable, IPooled, IProto<HeadData>, IProto
{
	[NonSerialized]
	public uint entitySource;

	[NonSerialized]
	public string playerName;

	[NonSerialized]
	public ulong playerId;

	[NonSerialized]
	public List<int> clothing;

	[NonSerialized]
	public uint count;

	[NonSerialized]
	public int horseBreed;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(HeadData instance)
	{
		if (instance.ShouldPool)
		{
			instance.entitySource = 0u;
			instance.playerName = string.Empty;
			instance.playerId = 0uL;
			if (instance.clothing != null)
			{
				List<int> list = instance.clothing;
				Pool.FreeUnmanaged<int>(ref list);
				instance.clothing = list;
			}
			instance.count = 0u;
			instance.horseBreed = 0;
			Pool.Free<HeadData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose HeadData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(HeadData instance)
	{
		instance.entitySource = entitySource;
		instance.playerName = playerName;
		instance.playerId = playerId;
		if (clothing != null)
		{
			instance.clothing = Pool.Get<List<int>>();
			for (int i = 0; i < clothing.Count; i++)
			{
				int item = clothing[i];
				instance.clothing.Add(item);
			}
		}
		else
		{
			instance.clothing = null;
		}
		instance.count = count;
		instance.horseBreed = horseBreed;
	}

	public HeadData Copy()
	{
		HeadData headData = Pool.Get<HeadData>();
		CopyTo(headData);
		return headData;
	}

	public static HeadData Deserialize(BufferStream stream)
	{
		HeadData headData = Pool.Get<HeadData>();
		Deserialize(stream, headData, isDelta: false);
		return headData;
	}

	public static HeadData DeserializeLengthDelimited(BufferStream stream)
	{
		HeadData headData = Pool.Get<HeadData>();
		DeserializeLengthDelimited(stream, headData, isDelta: false);
		return headData;
	}

	public static HeadData DeserializeLength(BufferStream stream, int length)
	{
		HeadData headData = Pool.Get<HeadData>();
		DeserializeLength(stream, length, headData, isDelta: false);
		return headData;
	}

	public static HeadData Deserialize(byte[] buffer)
	{
		HeadData headData = Pool.Get<HeadData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, headData, isDelta: false);
		return headData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, HeadData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static HeadData Deserialize(BufferStream stream, HeadData instance, bool isDelta)
	{
		if (!isDelta && instance.clothing == null)
		{
			instance.clothing = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entitySource = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.clothing.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.count = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.horseBreed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static HeadData DeserializeLengthDelimited(BufferStream stream, HeadData instance, bool isDelta)
	{
		if (!isDelta && instance.clothing == null)
		{
			instance.clothing = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entitySource = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.clothing.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.count = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.horseBreed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static HeadData DeserializeLength(BufferStream stream, int length, HeadData instance, bool isDelta)
	{
		if (!isDelta && instance.clothing == null)
		{
			instance.clothing = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entitySource = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.clothing.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.count = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.horseBreed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, HeadData instance, HeadData previous)
	{
		if (instance.entitySource != previous.entitySource)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.entitySource);
		}
		if (instance.playerName != null && instance.playerName != previous.playerName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.playerId != previous.playerId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.clothing != null)
		{
			for (int i = 0; i < instance.clothing.Count; i++)
			{
				int num = instance.clothing[i];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.count != previous.count)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.count);
		}
		if (instance.horseBreed != previous.horseBreed)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.horseBreed);
		}
	}

	public static void Serialize(BufferStream stream, HeadData instance)
	{
		if (instance.entitySource != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.entitySource);
		}
		if (instance.playerName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.playerId != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.clothing != null)
		{
			for (int i = 0; i < instance.clothing.Count; i++)
			{
				int num = instance.clothing[i];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.count != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.count);
		}
		if (instance.horseBreed != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.horseBreed);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WantedPoster : IDisposable, IPooled, IProto<WantedPoster>, IProto
{
	[NonSerialized]
	public uint imageCrc;

	[NonSerialized]
	public string playerName;

	[NonSerialized]
	public ulong playerId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WantedPoster instance)
	{
		if (instance.ShouldPool)
		{
			instance.imageCrc = 0u;
			instance.playerName = string.Empty;
			instance.playerId = 0uL;
			Pool.Free<WantedPoster>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WantedPoster with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WantedPoster instance)
	{
		instance.imageCrc = imageCrc;
		instance.playerName = playerName;
		instance.playerId = playerId;
	}

	public WantedPoster Copy()
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		CopyTo(wantedPoster);
		return wantedPoster;
	}

	public static WantedPoster Deserialize(BufferStream stream)
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		Deserialize(stream, wantedPoster, isDelta: false);
		return wantedPoster;
	}

	public static WantedPoster DeserializeLengthDelimited(BufferStream stream)
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		DeserializeLengthDelimited(stream, wantedPoster, isDelta: false);
		return wantedPoster;
	}

	public static WantedPoster DeserializeLength(BufferStream stream, int length)
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		DeserializeLength(stream, length, wantedPoster, isDelta: false);
		return wantedPoster;
	}

	public static WantedPoster Deserialize(byte[] buffer)
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wantedPoster, isDelta: false);
		return wantedPoster;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WantedPoster previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WantedPoster Deserialize(BufferStream stream, WantedPoster instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WantedPoster DeserializeLengthDelimited(BufferStream stream, WantedPoster instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WantedPoster DeserializeLength(BufferStream stream, int length, WantedPoster instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WantedPoster instance, WantedPoster previous)
	{
		if (instance.imageCrc != previous.imageCrc)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
		if (instance.playerName != null && instance.playerName != previous.playerName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.playerId != previous.playerId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
	}

	public static void Serialize(BufferStream stream, WantedPoster instance)
	{
		if (instance.imageCrc != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
		if (instance.playerName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.playerId != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class WaypointRace : IDisposable, IPooled, IProto<WaypointRace>, IProto
{
	[NonSerialized]
	public List<Vector3> positions;

	[NonSerialized]
	public NetworkableId racingVehicle;

	[NonSerialized]
	public int currentWaypoint;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WaypointRace instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.positions != null)
			{
				List<Vector3> list = instance.positions;
				Pool.FreeUnmanaged<Vector3>(ref list);
				instance.positions = list;
			}
			instance.racingVehicle = default(NetworkableId);
			instance.currentWaypoint = 0;
			Pool.Free<WaypointRace>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WaypointRace with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WaypointRace instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (positions != null)
		{
			instance.positions = Pool.Get<List<Vector3>>();
			for (int i = 0; i < positions.Count; i++)
			{
				Vector3 item = positions[i];
				instance.positions.Add(item);
			}
		}
		else
		{
			instance.positions = null;
		}
		instance.racingVehicle = racingVehicle;
		instance.currentWaypoint = currentWaypoint;
	}

	public WaypointRace Copy()
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		CopyTo(waypointRace);
		return waypointRace;
	}

	public static WaypointRace Deserialize(BufferStream stream)
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		Deserialize(stream, waypointRace, isDelta: false);
		return waypointRace;
	}

	public static WaypointRace DeserializeLengthDelimited(BufferStream stream)
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		DeserializeLengthDelimited(stream, waypointRace, isDelta: false);
		return waypointRace;
	}

	public static WaypointRace DeserializeLength(BufferStream stream, int length)
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		DeserializeLength(stream, length, waypointRace, isDelta: false);
		return waypointRace;
	}

	public static WaypointRace Deserialize(byte[] buffer)
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, waypointRace, isDelta: false);
		return waypointRace;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WaypointRace previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WaypointRace Deserialize(BufferStream stream, WaypointRace instance, bool isDelta)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.positions == null)
		{
			instance.positions = Pool.Get<List<Vector3>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.positions.Add(instance2);
				break;
			}
			case 16:
				instance.racingVehicle = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 24:
				instance.currentWaypoint = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static WaypointRace DeserializeLengthDelimited(BufferStream stream, WaypointRace instance, bool isDelta)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.positions == null)
		{
			instance.positions = Pool.Get<List<Vector3>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.positions.Add(instance2);
				break;
			}
			case 16:
				instance.racingVehicle = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 24:
				instance.currentWaypoint = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WaypointRace DeserializeLength(BufferStream stream, int length, WaypointRace instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.positions == null)
		{
			instance.positions = Pool.Get<List<Vector3>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.positions.Add(instance2);
				break;
			}
			case 16:
				instance.racingVehicle = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 24:
				instance.currentWaypoint = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WaypointRace instance, WaypointRace previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.positions != null)
		{
			for (int i = 0; i < instance.positions.Count; i++)
			{
				Vector3 val = instance.positions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field positions (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.racingVehicle.Value);
		if (instance.currentWaypoint != previous.currentWaypoint)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentWaypoint);
		}
	}

	public static void Serialize(BufferStream stream, WaypointRace instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.positions != null)
		{
			for (int i = 0; i < instance.positions.Count; i++)
			{
				Vector3 instance2 = instance.positions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field positions (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.racingVehicle != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.racingVehicle.Value);
		}
		if (instance.currentWaypoint != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentWaypoint);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref racingVehicle.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Ragdoll : IDisposable, IPooled, IProto<Ragdoll>, IProto
{
	[NonSerialized]
	public float time;

	[NonSerialized]
	public List<int> positions;

	[NonSerialized]
	public List<int> rotations;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Ragdoll instance)
	{
		if (instance.ShouldPool)
		{
			instance.time = 0f;
			if (instance.positions != null)
			{
				List<int> list = instance.positions;
				Pool.FreeUnmanaged<int>(ref list);
				instance.positions = list;
			}
			if (instance.rotations != null)
			{
				List<int> list2 = instance.rotations;
				Pool.FreeUnmanaged<int>(ref list2);
				instance.rotations = list2;
			}
			Pool.Free<Ragdoll>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Ragdoll with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Ragdoll instance)
	{
		instance.time = time;
		if (positions != null)
		{
			instance.positions = Pool.Get<List<int>>();
			for (int i = 0; i < positions.Count; i++)
			{
				int item = positions[i];
				instance.positions.Add(item);
			}
		}
		else
		{
			instance.positions = null;
		}
		if (rotations != null)
		{
			instance.rotations = Pool.Get<List<int>>();
			for (int j = 0; j < rotations.Count; j++)
			{
				int item2 = rotations[j];
				instance.rotations.Add(item2);
			}
		}
		else
		{
			instance.rotations = null;
		}
	}

	public Ragdoll Copy()
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		CopyTo(ragdoll);
		return ragdoll;
	}

	public static Ragdoll Deserialize(BufferStream stream)
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		Deserialize(stream, ragdoll, isDelta: false);
		return ragdoll;
	}

	public static Ragdoll DeserializeLengthDelimited(BufferStream stream)
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		DeserializeLengthDelimited(stream, ragdoll, isDelta: false);
		return ragdoll;
	}

	public static Ragdoll DeserializeLength(BufferStream stream, int length)
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		DeserializeLength(stream, length, ragdoll, isDelta: false);
		return ragdoll;
	}

	public static Ragdoll Deserialize(byte[] buffer)
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ragdoll, isDelta: false);
		return ragdoll;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Ragdoll previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Ragdoll Deserialize(BufferStream stream, Ragdoll instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.positions == null)
			{
				instance.positions = Pool.Get<List<int>>();
			}
			if (instance.rotations == null)
			{
				instance.rotations = Pool.Get<List<int>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.positions.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.rotations.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Ragdoll DeserializeLengthDelimited(BufferStream stream, Ragdoll instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.positions == null)
			{
				instance.positions = Pool.Get<List<int>>();
			}
			if (instance.rotations == null)
			{
				instance.rotations = Pool.Get<List<int>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.positions.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.rotations.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Ragdoll DeserializeLength(BufferStream stream, int length, Ragdoll instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.positions == null)
			{
				instance.positions = Pool.Get<List<int>>();
			}
			if (instance.rotations == null)
			{
				instance.rotations = Pool.Get<List<int>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.positions.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.rotations.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Ragdoll instance, Ragdoll previous)
	{
		if (instance.time != previous.time)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.positions != null)
		{
			for (int i = 0; i < instance.positions.Count; i++)
			{
				int num = instance.positions[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.rotations != null)
		{
			for (int j = 0; j < instance.rotations.Count; j++)
			{
				int num2 = instance.rotations[j];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
	}

	public static void Serialize(BufferStream stream, Ragdoll instance)
	{
		if (instance.time != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.positions != null)
		{
			for (int i = 0; i < instance.positions.Count; i++)
			{
				int num = instance.positions[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.rotations != null)
		{
			for (int j = 0; j < instance.rotations.Count; j++)
			{
				int num2 = instance.rotations[j];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class LegacyShelter : IDisposable, IPooled, IProto<LegacyShelter>, IProto
{
	[NonSerialized]
	public NetworkableId doorID;

	[NonSerialized]
	public float timeSinceInteracted;

	[NonSerialized]
	public ulong ownerId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LegacyShelter instance)
	{
		if (instance.ShouldPool)
		{
			instance.doorID = default(NetworkableId);
			instance.timeSinceInteracted = 0f;
			instance.ownerId = 0uL;
			Pool.Free<LegacyShelter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LegacyShelter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LegacyShelter instance)
	{
		instance.doorID = doorID;
		instance.timeSinceInteracted = timeSinceInteracted;
		instance.ownerId = ownerId;
	}

	public LegacyShelter Copy()
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		CopyTo(legacyShelter);
		return legacyShelter;
	}

	public static LegacyShelter Deserialize(BufferStream stream)
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		Deserialize(stream, legacyShelter, isDelta: false);
		return legacyShelter;
	}

	public static LegacyShelter DeserializeLengthDelimited(BufferStream stream)
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		DeserializeLengthDelimited(stream, legacyShelter, isDelta: false);
		return legacyShelter;
	}

	public static LegacyShelter DeserializeLength(BufferStream stream, int length)
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		DeserializeLength(stream, length, legacyShelter, isDelta: false);
		return legacyShelter;
	}

	public static LegacyShelter Deserialize(byte[] buffer)
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, legacyShelter, isDelta: false);
		return legacyShelter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LegacyShelter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LegacyShelter Deserialize(BufferStream stream, LegacyShelter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeSinceInteracted = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ownerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LegacyShelter DeserializeLengthDelimited(BufferStream stream, LegacyShelter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeSinceInteracted = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ownerId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LegacyShelter DeserializeLength(BufferStream stream, int length, LegacyShelter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeSinceInteracted = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ownerId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LegacyShelter instance, LegacyShelter previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.doorID.Value);
		if (instance.timeSinceInteracted != previous.timeSinceInteracted)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeSinceInteracted);
		}
		if (instance.ownerId != previous.ownerId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.ownerId);
		}
	}

	public static void Serialize(BufferStream stream, LegacyShelter instance)
	{
		if (instance.doorID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.doorID.Value);
		}
		if (instance.timeSinceInteracted != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeSinceInteracted);
		}
		if (instance.ownerId != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.ownerId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref doorID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MetalDetectorSource : IDisposable, IPooled, IProto<MetalDetectorSource>, IProto
{
	[NonSerialized]
	public List<Vector3> spawnLocations;

	[NonSerialized]
	public float spawnRadius;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MetalDetectorSource instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.spawnLocations != null)
			{
				List<Vector3> list = instance.spawnLocations;
				Pool.FreeUnmanaged<Vector3>(ref list);
				instance.spawnLocations = list;
			}
			instance.spawnRadius = 0f;
			Pool.Free<MetalDetectorSource>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MetalDetectorSource with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MetalDetectorSource instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (spawnLocations != null)
		{
			instance.spawnLocations = Pool.Get<List<Vector3>>();
			for (int i = 0; i < spawnLocations.Count; i++)
			{
				Vector3 item = spawnLocations[i];
				instance.spawnLocations.Add(item);
			}
		}
		else
		{
			instance.spawnLocations = null;
		}
		instance.spawnRadius = spawnRadius;
	}

	public MetalDetectorSource Copy()
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		CopyTo(metalDetectorSource);
		return metalDetectorSource;
	}

	public static MetalDetectorSource Deserialize(BufferStream stream)
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		Deserialize(stream, metalDetectorSource, isDelta: false);
		return metalDetectorSource;
	}

	public static MetalDetectorSource DeserializeLengthDelimited(BufferStream stream)
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		DeserializeLengthDelimited(stream, metalDetectorSource, isDelta: false);
		return metalDetectorSource;
	}

	public static MetalDetectorSource DeserializeLength(BufferStream stream, int length)
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		DeserializeLength(stream, length, metalDetectorSource, isDelta: false);
		return metalDetectorSource;
	}

	public static MetalDetectorSource Deserialize(byte[] buffer)
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, metalDetectorSource, isDelta: false);
		return metalDetectorSource;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MetalDetectorSource previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MetalDetectorSource Deserialize(BufferStream stream, MetalDetectorSource instance, bool isDelta)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.spawnLocations == null)
		{
			instance.spawnLocations = Pool.Get<List<Vector3>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.spawnLocations.Add(instance2);
				break;
			}
			case 21:
				instance.spawnRadius = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static MetalDetectorSource DeserializeLengthDelimited(BufferStream stream, MetalDetectorSource instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.spawnLocations == null)
		{
			instance.spawnLocations = Pool.Get<List<Vector3>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.spawnLocations.Add(instance2);
				break;
			}
			case 21:
				instance.spawnRadius = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MetalDetectorSource DeserializeLength(BufferStream stream, int length, MetalDetectorSource instance, bool isDelta)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.spawnLocations == null)
		{
			instance.spawnLocations = Pool.Get<List<Vector3>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.spawnLocations.Add(instance2);
				break;
			}
			case 21:
				instance.spawnRadius = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MetalDetectorSource instance, MetalDetectorSource previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spawnLocations != null)
		{
			for (int i = 0; i < instance.spawnLocations.Count; i++)
			{
				Vector3 val = instance.spawnLocations[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spawnLocations (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.spawnRadius != previous.spawnRadius)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.spawnRadius);
		}
	}

	public static void Serialize(BufferStream stream, MetalDetectorSource instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spawnLocations != null)
		{
			for (int i = 0; i < instance.spawnLocations.Count; i++)
			{
				Vector3 instance2 = instance.spawnLocations[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spawnLocations (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.spawnRadius != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.spawnRadius);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TutorialIsland : IDisposable, IPooled, IProto<TutorialIsland>, IProto
{
	[NonSerialized]
	public NetworkableId targetPlayer;

	[NonSerialized]
	public float disconnectDuration;

	[NonSerialized]
	public int spawnLocationIndex;

	[NonSerialized]
	public float tutorialDuration;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TutorialIsland instance)
	{
		if (instance.ShouldPool)
		{
			instance.targetPlayer = default(NetworkableId);
			instance.disconnectDuration = 0f;
			instance.spawnLocationIndex = 0;
			instance.tutorialDuration = 0f;
			Pool.Free<TutorialIsland>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TutorialIsland with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TutorialIsland instance)
	{
		instance.targetPlayer = targetPlayer;
		instance.disconnectDuration = disconnectDuration;
		instance.spawnLocationIndex = spawnLocationIndex;
		instance.tutorialDuration = tutorialDuration;
	}

	public TutorialIsland Copy()
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		CopyTo(tutorialIsland);
		return tutorialIsland;
	}

	public static TutorialIsland Deserialize(BufferStream stream)
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		Deserialize(stream, tutorialIsland, isDelta: false);
		return tutorialIsland;
	}

	public static TutorialIsland DeserializeLengthDelimited(BufferStream stream)
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		DeserializeLengthDelimited(stream, tutorialIsland, isDelta: false);
		return tutorialIsland;
	}

	public static TutorialIsland DeserializeLength(BufferStream stream, int length)
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		DeserializeLength(stream, length, tutorialIsland, isDelta: false);
		return tutorialIsland;
	}

	public static TutorialIsland Deserialize(byte[] buffer)
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, tutorialIsland, isDelta: false);
		return tutorialIsland;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TutorialIsland previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TutorialIsland Deserialize(BufferStream stream, TutorialIsland instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.disconnectDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.spawnLocationIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.tutorialDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TutorialIsland DeserializeLengthDelimited(BufferStream stream, TutorialIsland instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.disconnectDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.spawnLocationIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.tutorialDuration = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TutorialIsland DeserializeLength(BufferStream stream, int length, TutorialIsland instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.disconnectDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.spawnLocationIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.tutorialDuration = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TutorialIsland instance, TutorialIsland previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetPlayer.Value);
		if (instance.disconnectDuration != previous.disconnectDuration)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.disconnectDuration);
		}
		if (instance.spawnLocationIndex != previous.spawnLocationIndex)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.spawnLocationIndex);
		}
		if (instance.tutorialDuration != previous.tutorialDuration)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.tutorialDuration);
		}
	}

	public static void Serialize(BufferStream stream, TutorialIsland instance)
	{
		if (instance.targetPlayer != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetPlayer.Value);
		}
		if (instance.disconnectDuration != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.disconnectDuration);
		}
		if (instance.spawnLocationIndex != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.spawnLocationIndex);
		}
		if (instance.tutorialDuration != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.tutorialDuration);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetPlayer.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CinematicEntity : IDisposable, IPooled, IProto<CinematicEntity>, IProto
{
	[NonSerialized]
	public NetworkableId targetPlayer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CinematicEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.targetPlayer = default(NetworkableId);
			Pool.Free<CinematicEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CinematicEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CinematicEntity instance)
	{
		instance.targetPlayer = targetPlayer;
	}

	public CinematicEntity Copy()
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		CopyTo(cinematicEntity);
		return cinematicEntity;
	}

	public static CinematicEntity Deserialize(BufferStream stream)
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		Deserialize(stream, cinematicEntity, isDelta: false);
		return cinematicEntity;
	}

	public static CinematicEntity DeserializeLengthDelimited(BufferStream stream)
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		DeserializeLengthDelimited(stream, cinematicEntity, isDelta: false);
		return cinematicEntity;
	}

	public static CinematicEntity DeserializeLength(BufferStream stream, int length)
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		DeserializeLength(stream, length, cinematicEntity, isDelta: false);
		return cinematicEntity;
	}

	public static CinematicEntity Deserialize(byte[] buffer)
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cinematicEntity, isDelta: false);
		return cinematicEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CinematicEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CinematicEntity Deserialize(BufferStream stream, CinematicEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CinematicEntity DeserializeLengthDelimited(BufferStream stream, CinematicEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CinematicEntity DeserializeLength(BufferStream stream, int length, CinematicEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CinematicEntity instance, CinematicEntity previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetPlayer.Value);
	}

	public static void Serialize(BufferStream stream, CinematicEntity instance)
	{
		if (instance.targetPlayer != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetPlayer.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetPlayer.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class HarborCrane : IDisposable, IPooled, IProto<HarborCrane>, IProto
{
	public class QueuedMove : IDisposable, IPooled, IProto<QueuedMove>, IProto
	{
		[NonSerialized]
		public NetworkableId targetEntity;

		[NonSerialized]
		public Vector3 targetWorldPosition;

		[NonSerialized]
		public Vector4 targetWorldRotation;

		[NonSerialized]
		public bool hasTarget;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(QueuedMove instance)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.targetEntity = default(NetworkableId);
				instance.targetWorldPosition = default(Vector3);
				instance.targetWorldRotation = default(Vector4);
				instance.hasTarget = false;
				Pool.Free<QueuedMove>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose QueuedMove with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(QueuedMove instance)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			instance.targetEntity = targetEntity;
			instance.targetWorldPosition = targetWorldPosition;
			instance.targetWorldRotation = targetWorldRotation;
			instance.hasTarget = hasTarget;
		}

		public QueuedMove Copy()
		{
			QueuedMove queuedMove = Pool.Get<QueuedMove>();
			CopyTo(queuedMove);
			return queuedMove;
		}

		public static QueuedMove Deserialize(BufferStream stream)
		{
			QueuedMove queuedMove = Pool.Get<QueuedMove>();
			Deserialize(stream, queuedMove, isDelta: false);
			return queuedMove;
		}

		public static QueuedMove DeserializeLengthDelimited(BufferStream stream)
		{
			QueuedMove queuedMove = Pool.Get<QueuedMove>();
			DeserializeLengthDelimited(stream, queuedMove, isDelta: false);
			return queuedMove;
		}

		public static QueuedMove DeserializeLength(BufferStream stream, int length)
		{
			QueuedMove queuedMove = Pool.Get<QueuedMove>();
			DeserializeLength(stream, length, queuedMove, isDelta: false);
			return queuedMove;
		}

		public static QueuedMove Deserialize(byte[] buffer)
		{
			QueuedMove queuedMove = Pool.Get<QueuedMove>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, queuedMove, isDelta: false);
			return queuedMove;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, QueuedMove previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static QueuedMove Deserialize(BufferStream stream, QueuedMove instance, bool isDelta)
		{
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
					continue;
				case 26:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
					continue;
				case 32:
					instance.hasTarget = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static QueuedMove DeserializeLengthDelimited(BufferStream stream, QueuedMove instance, bool isDelta)
		{
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
					continue;
				case 26:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
					continue;
				case 32:
					instance.hasTarget = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static QueuedMove DeserializeLength(BufferStream stream, int length, QueuedMove instance, bool isDelta)
		{
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
					continue;
				case 26:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
					continue;
				case 32:
					instance.hasTarget = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, QueuedMove instance, QueuedMove previous)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetEntity.Value);
			if (instance.targetWorldPosition != previous.targetWorldPosition)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.targetWorldPosition, previous.targetWorldPosition);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldPosition (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.targetWorldRotation != previous.targetWorldRotation)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.targetWorldRotation, previous.targetWorldRotation);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldRotation (UnityEngine.Vector4)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.hasTarget);
		}

		public static void Serialize(BufferStream stream, QueuedMove instance)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			if (instance.targetEntity != default(NetworkableId))
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.targetEntity.Value);
			}
			if (instance.targetWorldPosition != default(Vector3))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance.targetWorldPosition);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldPosition (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.targetWorldRotation != default(Vector4))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.targetWorldRotation);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldRotation (UnityEngine.Vector4)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.hasTarget)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteBool(stream, instance.hasTarget);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref targetEntity.Value);
		}
	}

	[NonSerialized]
	public float time;

	[NonSerialized]
	public float yaw;

	[NonSerialized]
	public float depth;

	[NonSerialized]
	public float height;

	[NonSerialized]
	public QueuedMove currentMove;

	[NonSerialized]
	public int currentPickupState;

	[NonSerialized]
	public Vector3 startForward;

	[NonSerialized]
	public float maxMoveHeight;

	[NonSerialized]
	public NetworkableId toParent;

	[NonSerialized]
	public List<QueuedMove> queuedMoves;

	[NonSerialized]
	public float moveDelay;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(HarborCrane instance)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.time = 0f;
		instance.yaw = 0f;
		instance.depth = 0f;
		instance.height = 0f;
		if (instance.currentMove != null)
		{
			instance.currentMove.ResetToPool();
			instance.currentMove = null;
		}
		instance.currentPickupState = 0;
		instance.startForward = default(Vector3);
		instance.maxMoveHeight = 0f;
		instance.toParent = default(NetworkableId);
		if (instance.queuedMoves != null)
		{
			for (int i = 0; i < instance.queuedMoves.Count; i++)
			{
				if (instance.queuedMoves[i] != null)
				{
					instance.queuedMoves[i].ResetToPool();
					instance.queuedMoves[i] = null;
				}
			}
			List<QueuedMove> list = instance.queuedMoves;
			Pool.Free<QueuedMove>(ref list, false);
			instance.queuedMoves = list;
		}
		instance.moveDelay = 0f;
		Pool.Free<HarborCrane>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose HarborCrane with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(HarborCrane instance)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		instance.time = time;
		instance.yaw = yaw;
		instance.depth = depth;
		instance.height = height;
		if (currentMove != null)
		{
			if (instance.currentMove == null)
			{
				instance.currentMove = currentMove.Copy();
			}
			else
			{
				currentMove.CopyTo(instance.currentMove);
			}
		}
		else
		{
			instance.currentMove = null;
		}
		instance.currentPickupState = currentPickupState;
		instance.startForward = startForward;
		instance.maxMoveHeight = maxMoveHeight;
		instance.toParent = toParent;
		if (queuedMoves != null)
		{
			instance.queuedMoves = Pool.Get<List<QueuedMove>>();
			for (int i = 0; i < queuedMoves.Count; i++)
			{
				QueuedMove item = queuedMoves[i].Copy();
				instance.queuedMoves.Add(item);
			}
		}
		else
		{
			instance.queuedMoves = null;
		}
		instance.moveDelay = moveDelay;
	}

	public HarborCrane Copy()
	{
		HarborCrane harborCrane = Pool.Get<HarborCrane>();
		CopyTo(harborCrane);
		return harborCrane;
	}

	public static HarborCrane Deserialize(BufferStream stream)
	{
		HarborCrane harborCrane = Pool.Get<HarborCrane>();
		Deserialize(stream, harborCrane, isDelta: false);
		return harborCrane;
	}

	public static HarborCrane DeserializeLengthDelimited(BufferStream stream)
	{
		HarborCrane harborCrane = Pool.Get<HarborCrane>();
		DeserializeLengthDelimited(stream, harborCrane, isDelta: false);
		return harborCrane;
	}

	public static HarborCrane DeserializeLength(BufferStream stream, int length)
	{
		HarborCrane harborCrane = Pool.Get<HarborCrane>();
		DeserializeLength(stream, length, harborCrane, isDelta: false);
		return harborCrane;
	}

	public static HarborCrane Deserialize(byte[] buffer)
	{
		HarborCrane harborCrane = Pool.Get<HarborCrane>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, harborCrane, isDelta: false);
		return harborCrane;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, HarborCrane previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static HarborCrane Deserialize(BufferStream stream, HarborCrane instance, bool isDelta)
	{
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.queuedMoves == null)
		{
			instance.queuedMoves = Pool.Get<List<QueuedMove>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				break;
			case 21:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				break;
			case 29:
				instance.depth = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.height = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.currentMove == null)
				{
					instance.currentMove = QueuedMove.DeserializeLengthDelimited(stream);
				}
				else
				{
					QueuedMove.DeserializeLengthDelimited(stream, instance.currentMove, isDelta);
				}
				break;
			case 48:
				instance.currentPickupState = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startForward, isDelta);
				break;
			case 69:
				instance.maxMoveHeight = ProtocolParser.ReadSingle(stream);
				break;
			case 72:
				instance.toParent = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 90:
				instance.queuedMoves.Add(QueuedMove.DeserializeLengthDelimited(stream));
				break;
			case 101:
				instance.moveDelay = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static HarborCrane DeserializeLengthDelimited(BufferStream stream, HarborCrane instance, bool isDelta)
	{
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.queuedMoves == null)
		{
			instance.queuedMoves = Pool.Get<List<QueuedMove>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				break;
			case 21:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				break;
			case 29:
				instance.depth = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.height = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.currentMove == null)
				{
					instance.currentMove = QueuedMove.DeserializeLengthDelimited(stream);
				}
				else
				{
					QueuedMove.DeserializeLengthDelimited(stream, instance.currentMove, isDelta);
				}
				break;
			case 48:
				instance.currentPickupState = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startForward, isDelta);
				break;
			case 69:
				instance.maxMoveHeight = ProtocolParser.ReadSingle(stream);
				break;
			case 72:
				instance.toParent = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 90:
				instance.queuedMoves.Add(QueuedMove.DeserializeLengthDelimited(stream));
				break;
			case 101:
				instance.moveDelay = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static HarborCrane DeserializeLength(BufferStream stream, int length, HarborCrane instance, bool isDelta)
	{
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.queuedMoves == null)
		{
			instance.queuedMoves = Pool.Get<List<QueuedMove>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				break;
			case 21:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				break;
			case 29:
				instance.depth = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.height = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.currentMove == null)
				{
					instance.currentMove = QueuedMove.DeserializeLengthDelimited(stream);
				}
				else
				{
					QueuedMove.DeserializeLengthDelimited(stream, instance.currentMove, isDelta);
				}
				break;
			case 48:
				instance.currentPickupState = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startForward, isDelta);
				break;
			case 69:
				instance.maxMoveHeight = ProtocolParser.ReadSingle(stream);
				break;
			case 72:
				instance.toParent = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 90:
				instance.queuedMoves.Add(QueuedMove.DeserializeLengthDelimited(stream));
				break;
			case 101:
				instance.moveDelay = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, HarborCrane instance, HarborCrane previous)
	{
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		if (instance.time != previous.time)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.yaw != previous.yaw)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
		if (instance.depth != previous.depth)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.depth);
		}
		if (instance.height != previous.height)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.height);
		}
		if (instance.currentMove != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			QueuedMove.SerializeDelta(stream, instance.currentMove, previous.currentMove);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field currentMove (ProtoBuf.HarborCrane.QueuedMove)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.currentPickupState != previous.currentPickupState)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentPickupState);
		}
		if (instance.startForward != previous.startForward)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.startForward, previous.startForward);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startForward (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.maxMoveHeight != previous.maxMoveHeight)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.maxMoveHeight);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteUInt64(stream, instance.toParent.Value);
		if (instance.queuedMoves != null)
		{
			for (int i = 0; i < instance.queuedMoves.Count; i++)
			{
				QueuedMove queuedMove = instance.queuedMoves[i];
				stream.WriteByte(90);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				QueuedMove.SerializeDelta(stream, queuedMove, queuedMove);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field queuedMoves (ProtoBuf.HarborCrane.QueuedMove)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.moveDelay != previous.moveDelay)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.moveDelay);
		}
	}

	public static void Serialize(BufferStream stream, HarborCrane instance)
	{
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		if (instance.time != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.yaw != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
		if (instance.depth != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.depth);
		}
		if (instance.height != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.height);
		}
		if (instance.currentMove != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			QueuedMove.Serialize(stream, instance.currentMove);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field currentMove (ProtoBuf.HarborCrane.QueuedMove)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.currentPickupState != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentPickupState);
		}
		if (instance.startForward != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.startForward);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startForward (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.maxMoveHeight != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.maxMoveHeight);
		}
		if (instance.toParent != default(NetworkableId))
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, instance.toParent.Value);
		}
		if (instance.queuedMoves != null)
		{
			for (int i = 0; i < instance.queuedMoves.Count; i++)
			{
				QueuedMove instance2 = instance.queuedMoves[i];
				stream.WriteByte(90);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				QueuedMove.Serialize(stream, instance2);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field queuedMoves (ProtoBuf.HarborCrane.QueuedMove)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.moveDelay != 0f)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.moveDelay);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		currentMove?.InspectUids(action);
		action(UidType.NetworkableId, ref toParent.Value);
		if (queuedMoves != null)
		{
			for (int i = 0; i < queuedMoves.Count; i++)
			{
				queuedMoves[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CargoShip : IDisposable, IPooled, IProto<CargoShip>, IProto
{
	[NonSerialized]
	public int currentHarborApproachNode;

	[NonSerialized]
	public bool isDoingHarborApproach;

	[NonSerialized]
	public bool shouldLookAhead;

	[NonSerialized]
	public bool isEgressing;

	[NonSerialized]
	public uint layout;

	[NonSerialized]
	public List<ulong> playerIds;

	[NonSerialized]
	public int dockCount;

	[NonSerialized]
	public float lifetime;

	[NonSerialized]
	public int harborIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CargoShip instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentHarborApproachNode = 0;
			instance.isDoingHarborApproach = false;
			instance.shouldLookAhead = false;
			instance.isEgressing = false;
			instance.layout = 0u;
			if (instance.playerIds != null)
			{
				List<ulong> list = instance.playerIds;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.playerIds = list;
			}
			instance.dockCount = 0;
			instance.lifetime = 0f;
			instance.harborIndex = 0;
			Pool.Free<CargoShip>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CargoShip with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CargoShip instance)
	{
		instance.currentHarborApproachNode = currentHarborApproachNode;
		instance.isDoingHarborApproach = isDoingHarborApproach;
		instance.shouldLookAhead = shouldLookAhead;
		instance.isEgressing = isEgressing;
		instance.layout = layout;
		if (playerIds != null)
		{
			instance.playerIds = Pool.Get<List<ulong>>();
			for (int i = 0; i < playerIds.Count; i++)
			{
				ulong item = playerIds[i];
				instance.playerIds.Add(item);
			}
		}
		else
		{
			instance.playerIds = null;
		}
		instance.dockCount = dockCount;
		instance.lifetime = lifetime;
		instance.harborIndex = harborIndex;
	}

	public CargoShip Copy()
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		CopyTo(cargoShip);
		return cargoShip;
	}

	public static CargoShip Deserialize(BufferStream stream)
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		Deserialize(stream, cargoShip, isDelta: false);
		return cargoShip;
	}

	public static CargoShip DeserializeLengthDelimited(BufferStream stream)
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		DeserializeLengthDelimited(stream, cargoShip, isDelta: false);
		return cargoShip;
	}

	public static CargoShip DeserializeLength(BufferStream stream, int length)
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		DeserializeLength(stream, length, cargoShip, isDelta: false);
		return cargoShip;
	}

	public static CargoShip Deserialize(byte[] buffer)
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cargoShip, isDelta: false);
		return cargoShip;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CargoShip previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CargoShip Deserialize(BufferStream stream, CargoShip instance, bool isDelta)
	{
		if (!isDelta && instance.playerIds == null)
		{
			instance.playerIds = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.currentHarborApproachNode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isDoingHarborApproach = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.shouldLookAhead = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.isEgressing = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.layout = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.playerIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.dockCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.harborIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CargoShip DeserializeLengthDelimited(BufferStream stream, CargoShip instance, bool isDelta)
	{
		if (!isDelta && instance.playerIds == null)
		{
			instance.playerIds = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentHarborApproachNode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isDoingHarborApproach = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.shouldLookAhead = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.isEgressing = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.layout = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.playerIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.dockCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.harborIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CargoShip DeserializeLength(BufferStream stream, int length, CargoShip instance, bool isDelta)
	{
		if (!isDelta && instance.playerIds == null)
		{
			instance.playerIds = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentHarborApproachNode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isDoingHarborApproach = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.shouldLookAhead = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.isEgressing = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.layout = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.playerIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.dockCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.harborIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CargoShip instance, CargoShip previous)
	{
		if (instance.currentHarborApproachNode != previous.currentHarborApproachNode)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentHarborApproachNode);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.isDoingHarborApproach);
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.shouldLookAhead);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.isEgressing);
		if (instance.layout != previous.layout)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.layout);
		}
		if (instance.playerIds != null)
		{
			for (int i = 0; i < instance.playerIds.Count; i++)
			{
				ulong val = instance.playerIds[i];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.dockCount != previous.dockCount)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dockCount);
		}
		if (instance.lifetime != previous.lifetime)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lifetime);
		}
		if (instance.harborIndex != previous.harborIndex)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.harborIndex);
		}
	}

	public static void Serialize(BufferStream stream, CargoShip instance)
	{
		if (instance.currentHarborApproachNode != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentHarborApproachNode);
		}
		if (instance.isDoingHarborApproach)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.isDoingHarborApproach);
		}
		if (instance.shouldLookAhead)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.shouldLookAhead);
		}
		if (instance.isEgressing)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isEgressing);
		}
		if (instance.layout != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.layout);
		}
		if (instance.playerIds != null)
		{
			for (int i = 0; i < instance.playerIds.Count; i++)
			{
				ulong val = instance.playerIds[i];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.dockCount != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dockCount);
		}
		if (instance.lifetime != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lifetime);
		}
		if (instance.harborIndex != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.harborIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CargoShipContainer : IDisposable, IPooled, IProto<CargoShipContainer>, IProto
{
	[NonSerialized]
	public int dressingVariant;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CargoShipContainer instance)
	{
		if (instance.ShouldPool)
		{
			instance.dressingVariant = 0;
			Pool.Free<CargoShipContainer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CargoShipContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CargoShipContainer instance)
	{
		instance.dressingVariant = dressingVariant;
	}

	public CargoShipContainer Copy()
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		CopyTo(cargoShipContainer);
		return cargoShipContainer;
	}

	public static CargoShipContainer Deserialize(BufferStream stream)
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		Deserialize(stream, cargoShipContainer, isDelta: false);
		return cargoShipContainer;
	}

	public static CargoShipContainer DeserializeLengthDelimited(BufferStream stream)
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		DeserializeLengthDelimited(stream, cargoShipContainer, isDelta: false);
		return cargoShipContainer;
	}

	public static CargoShipContainer DeserializeLength(BufferStream stream, int length)
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		DeserializeLength(stream, length, cargoShipContainer, isDelta: false);
		return cargoShipContainer;
	}

	public static CargoShipContainer Deserialize(byte[] buffer)
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cargoShipContainer, isDelta: false);
		return cargoShipContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CargoShipContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CargoShipContainer Deserialize(BufferStream stream, CargoShipContainer instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.dressingVariant = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CargoShipContainer DeserializeLengthDelimited(BufferStream stream, CargoShipContainer instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dressingVariant = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CargoShipContainer DeserializeLength(BufferStream stream, int length, CargoShipContainer instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dressingVariant = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CargoShipContainer instance, CargoShipContainer previous)
	{
		if (instance.dressingVariant != previous.dressingVariant)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dressingVariant);
		}
	}

	public static void Serialize(BufferStream stream, CargoShipContainer instance)
	{
		if (instance.dressingVariant != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dressingVariant);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionMapMarker : IDisposable, IPooled, IProto<MissionMapMarker>, IProto
{
	[NonSerialized]
	public List<uint> missionIds;

	[NonSerialized]
	public string providerToken;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionMapMarker instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.missionIds != null)
			{
				List<uint> list = instance.missionIds;
				Pool.FreeUnmanaged<uint>(ref list);
				instance.missionIds = list;
			}
			instance.providerToken = string.Empty;
			Pool.Free<MissionMapMarker>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionMapMarker with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionMapMarker instance)
	{
		if (missionIds != null)
		{
			instance.missionIds = Pool.Get<List<uint>>();
			for (int i = 0; i < missionIds.Count; i++)
			{
				uint item = missionIds[i];
				instance.missionIds.Add(item);
			}
		}
		else
		{
			instance.missionIds = null;
		}
		instance.providerToken = providerToken;
	}

	public MissionMapMarker Copy()
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		CopyTo(missionMapMarker);
		return missionMapMarker;
	}

	public static MissionMapMarker Deserialize(BufferStream stream)
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		Deserialize(stream, missionMapMarker, isDelta: false);
		return missionMapMarker;
	}

	public static MissionMapMarker DeserializeLengthDelimited(BufferStream stream)
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		DeserializeLengthDelimited(stream, missionMapMarker, isDelta: false);
		return missionMapMarker;
	}

	public static MissionMapMarker DeserializeLength(BufferStream stream, int length)
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		DeserializeLength(stream, length, missionMapMarker, isDelta: false);
		return missionMapMarker;
	}

	public static MissionMapMarker Deserialize(byte[] buffer)
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionMapMarker, isDelta: false);
		return missionMapMarker;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionMapMarker previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionMapMarker Deserialize(BufferStream stream, MissionMapMarker instance, bool isDelta)
	{
		if (!isDelta && instance.missionIds == null)
		{
			instance.missionIds = Pool.Get<List<uint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.missionIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 18:
				instance.providerToken = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionMapMarker DeserializeLengthDelimited(BufferStream stream, MissionMapMarker instance, bool isDelta)
	{
		if (!isDelta && instance.missionIds == null)
		{
			instance.missionIds = Pool.Get<List<uint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.missionIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 18:
				instance.providerToken = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionMapMarker DeserializeLength(BufferStream stream, int length, MissionMapMarker instance, bool isDelta)
	{
		if (!isDelta && instance.missionIds == null)
		{
			instance.missionIds = Pool.Get<List<uint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.missionIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 18:
				instance.providerToken = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionMapMarker instance, MissionMapMarker previous)
	{
		if (instance.missionIds != null)
		{
			for (int i = 0; i < instance.missionIds.Count; i++)
			{
				uint val = instance.missionIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.providerToken != null && instance.providerToken != previous.providerToken)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.providerToken);
		}
	}

	public static void Serialize(BufferStream stream, MissionMapMarker instance)
	{
		if (instance.missionIds != null)
		{
			for (int i = 0; i < instance.missionIds.Count; i++)
			{
				uint val = instance.missionIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.providerToken != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.providerToken);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Bike : IDisposable, IPooled, IProto<Bike>, IProto
{
	[NonSerialized]
	public float steerInput;

	[NonSerialized]
	public float driveWheelVel;

	[NonSerialized]
	public float throttleInput;

	[NonSerialized]
	public float brakeInput;

	[NonSerialized]
	public NetworkableId storageID;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelFraction;

	[NonSerialized]
	public float sidecarAngle;

	[NonSerialized]
	public float time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Bike instance)
	{
		if (instance.ShouldPool)
		{
			instance.steerInput = 0f;
			instance.driveWheelVel = 0f;
			instance.throttleInput = 0f;
			instance.brakeInput = 0f;
			instance.storageID = default(NetworkableId);
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelFraction = 0f;
			instance.sidecarAngle = 0f;
			instance.time = 0f;
			Pool.Free<Bike>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Bike with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Bike instance)
	{
		instance.steerInput = steerInput;
		instance.driveWheelVel = driveWheelVel;
		instance.throttleInput = throttleInput;
		instance.brakeInput = brakeInput;
		instance.storageID = storageID;
		instance.fuelStorageID = fuelStorageID;
		instance.fuelFraction = fuelFraction;
		instance.sidecarAngle = sidecarAngle;
		instance.time = time;
	}

	public Bike Copy()
	{
		Bike bike = Pool.Get<Bike>();
		CopyTo(bike);
		return bike;
	}

	public static Bike Deserialize(BufferStream stream)
	{
		Bike bike = Pool.Get<Bike>();
		Deserialize(stream, bike, isDelta: false);
		return bike;
	}

	public static Bike DeserializeLengthDelimited(BufferStream stream)
	{
		Bike bike = Pool.Get<Bike>();
		DeserializeLengthDelimited(stream, bike, isDelta: false);
		return bike;
	}

	public static Bike DeserializeLength(BufferStream stream, int length)
	{
		Bike bike = Pool.Get<Bike>();
		DeserializeLength(stream, length, bike, isDelta: false);
		return bike;
	}

	public static Bike Deserialize(byte[] buffer)
	{
		Bike bike = Pool.Get<Bike>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, bike, isDelta: false);
		return bike;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Bike previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Bike Deserialize(BufferStream stream, Bike instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sidecarAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Bike DeserializeLengthDelimited(BufferStream stream, Bike instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sidecarAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Bike DeserializeLength(BufferStream stream, int length, Bike instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sidecarAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Bike instance, Bike previous)
	{
		if (instance.steerInput != previous.steerInput)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != previous.driveWheelVel)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != previous.throttleInput)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != previous.brakeInput)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.sidecarAngle != previous.sidecarAngle)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.sidecarAngle);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public static void Serialize(BufferStream stream, Bike instance)
	{
		if (instance.steerInput != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.storageID != default(NetworkableId))
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.sidecarAngle != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.sidecarAngle);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref storageID.Value);
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TravellingVendor : IDisposable, IPooled, IProto<TravellingVendor>, IProto
{
	[NonSerialized]
	public float steeringAngle;

	[NonSerialized]
	public Vector3 velocity;

	[NonSerialized]
	public int wheelFlags;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TravellingVendor instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.steeringAngle = 0f;
			instance.velocity = default(Vector3);
			instance.wheelFlags = 0;
			Pool.Free<TravellingVendor>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TravellingVendor with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TravellingVendor instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.steeringAngle = steeringAngle;
		instance.velocity = velocity;
		instance.wheelFlags = wheelFlags;
	}

	public TravellingVendor Copy()
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		CopyTo(travellingVendor);
		return travellingVendor;
	}

	public static TravellingVendor Deserialize(BufferStream stream)
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		Deserialize(stream, travellingVendor, isDelta: false);
		return travellingVendor;
	}

	public static TravellingVendor DeserializeLengthDelimited(BufferStream stream)
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		DeserializeLengthDelimited(stream, travellingVendor, isDelta: false);
		return travellingVendor;
	}

	public static TravellingVendor DeserializeLength(BufferStream stream, int length)
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		DeserializeLength(stream, length, travellingVendor, isDelta: false);
		return travellingVendor;
	}

	public static TravellingVendor Deserialize(byte[] buffer)
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, travellingVendor, isDelta: false);
		return travellingVendor;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TravellingVendor previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TravellingVendor Deserialize(BufferStream stream, TravellingVendor instance, bool isDelta)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.steeringAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.velocity, isDelta);
				continue;
			case 24:
				instance.wheelFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TravellingVendor DeserializeLengthDelimited(BufferStream stream, TravellingVendor instance, bool isDelta)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steeringAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.velocity, isDelta);
				continue;
			case 24:
				instance.wheelFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TravellingVendor DeserializeLength(BufferStream stream, int length, TravellingVendor instance, bool isDelta)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steeringAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.velocity, isDelta);
				continue;
			case 24:
				instance.wheelFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TravellingVendor instance, TravellingVendor previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.steeringAngle != previous.steeringAngle)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steeringAngle);
		}
		if (instance.velocity != previous.velocity)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.velocity, previous.velocity);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field velocity (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.wheelFlags != previous.wheelFlags)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wheelFlags);
		}
	}

	public static void Serialize(BufferStream stream, TravellingVendor instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (instance.steeringAngle != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steeringAngle);
		}
		if (instance.velocity != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.velocity);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field velocity (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.wheelFlags != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wheelFlags);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingDynamicPricing : IDisposable, IPooled, IProto<VendingDynamicPricing>, IProto
{
	[NonSerialized]
	public List<SalesData> allSalesData;

	[NonSerialized]
	public float timeToNextSalesUpdate;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingDynamicPricing instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.allSalesData != null)
		{
			for (int i = 0; i < instance.allSalesData.Count; i++)
			{
				if (instance.allSalesData[i] != null)
				{
					instance.allSalesData[i].ResetToPool();
					instance.allSalesData[i] = null;
				}
			}
			List<SalesData> list = instance.allSalesData;
			Pool.Free<SalesData>(ref list, false);
			instance.allSalesData = list;
		}
		instance.timeToNextSalesUpdate = 0f;
		Pool.Free<VendingDynamicPricing>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingDynamicPricing with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingDynamicPricing instance)
	{
		if (allSalesData != null)
		{
			instance.allSalesData = Pool.Get<List<SalesData>>();
			for (int i = 0; i < allSalesData.Count; i++)
			{
				SalesData item = allSalesData[i].Copy();
				instance.allSalesData.Add(item);
			}
		}
		else
		{
			instance.allSalesData = null;
		}
		instance.timeToNextSalesUpdate = timeToNextSalesUpdate;
	}

	public VendingDynamicPricing Copy()
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		CopyTo(vendingDynamicPricing);
		return vendingDynamicPricing;
	}

	public static VendingDynamicPricing Deserialize(BufferStream stream)
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		Deserialize(stream, vendingDynamicPricing, isDelta: false);
		return vendingDynamicPricing;
	}

	public static VendingDynamicPricing DeserializeLengthDelimited(BufferStream stream)
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		DeserializeLengthDelimited(stream, vendingDynamicPricing, isDelta: false);
		return vendingDynamicPricing;
	}

	public static VendingDynamicPricing DeserializeLength(BufferStream stream, int length)
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		DeserializeLength(stream, length, vendingDynamicPricing, isDelta: false);
		return vendingDynamicPricing;
	}

	public static VendingDynamicPricing Deserialize(byte[] buffer)
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingDynamicPricing, isDelta: false);
		return vendingDynamicPricing;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingDynamicPricing previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingDynamicPricing Deserialize(BufferStream stream, VendingDynamicPricing instance, bool isDelta)
	{
		if (!isDelta && instance.allSalesData == null)
		{
			instance.allSalesData = Pool.Get<List<SalesData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.allSalesData.Add(SalesData.DeserializeLengthDelimited(stream));
				continue;
			case 29:
				instance.timeToNextSalesUpdate = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingDynamicPricing DeserializeLengthDelimited(BufferStream stream, VendingDynamicPricing instance, bool isDelta)
	{
		if (!isDelta && instance.allSalesData == null)
		{
			instance.allSalesData = Pool.Get<List<SalesData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.allSalesData.Add(SalesData.DeserializeLengthDelimited(stream));
				continue;
			case 29:
				instance.timeToNextSalesUpdate = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingDynamicPricing DeserializeLength(BufferStream stream, int length, VendingDynamicPricing instance, bool isDelta)
	{
		if (!isDelta && instance.allSalesData == null)
		{
			instance.allSalesData = Pool.Get<List<SalesData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.allSalesData.Add(SalesData.DeserializeLengthDelimited(stream));
				continue;
			case 29:
				instance.timeToNextSalesUpdate = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingDynamicPricing instance, VendingDynamicPricing previous)
	{
		if (instance.allSalesData != null)
		{
			for (int i = 0; i < instance.allSalesData.Count; i++)
			{
				SalesData salesData = instance.allSalesData[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				SalesData.SerializeDelta(stream, salesData, salesData);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field allSalesData (ProtoBuf.SalesData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.timeToNextSalesUpdate != previous.timeToNextSalesUpdate)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.timeToNextSalesUpdate);
		}
	}

	public static void Serialize(BufferStream stream, VendingDynamicPricing instance)
	{
		if (instance.allSalesData != null)
		{
			for (int i = 0; i < instance.allSalesData.Count; i++)
			{
				SalesData instance2 = instance.allSalesData[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				SalesData.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field allSalesData (ProtoBuf.SalesData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.timeToNextSalesUpdate != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.timeToNextSalesUpdate);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (allSalesData != null)
		{
			for (int i = 0; i < allSalesData.Count; i++)
			{
				allSalesData[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SalesData : IDisposable, IPooled, IProto<SalesData>, IProto
{
	[NonSerialized]
	public ulong totalSales;

	[NonSerialized]
	public ulong totalIntervals;

	[NonSerialized]
	public ulong soldThisInterval;

	[NonSerialized]
	public float currentMultiplier;

	[NonSerialized]
	public bool isForReceivedQuantity;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SalesData instance)
	{
		if (instance.ShouldPool)
		{
			instance.totalSales = 0uL;
			instance.totalIntervals = 0uL;
			instance.soldThisInterval = 0uL;
			instance.currentMultiplier = 0f;
			instance.isForReceivedQuantity = false;
			Pool.Free<SalesData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SalesData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SalesData instance)
	{
		instance.totalSales = totalSales;
		instance.totalIntervals = totalIntervals;
		instance.soldThisInterval = soldThisInterval;
		instance.currentMultiplier = currentMultiplier;
		instance.isForReceivedQuantity = isForReceivedQuantity;
	}

	public SalesData Copy()
	{
		SalesData salesData = Pool.Get<SalesData>();
		CopyTo(salesData);
		return salesData;
	}

	public static SalesData Deserialize(BufferStream stream)
	{
		SalesData salesData = Pool.Get<SalesData>();
		Deserialize(stream, salesData, isDelta: false);
		return salesData;
	}

	public static SalesData DeserializeLengthDelimited(BufferStream stream)
	{
		SalesData salesData = Pool.Get<SalesData>();
		DeserializeLengthDelimited(stream, salesData, isDelta: false);
		return salesData;
	}

	public static SalesData DeserializeLength(BufferStream stream, int length)
	{
		SalesData salesData = Pool.Get<SalesData>();
		DeserializeLength(stream, length, salesData, isDelta: false);
		return salesData;
	}

	public static SalesData Deserialize(byte[] buffer)
	{
		SalesData salesData = Pool.Get<SalesData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, salesData, isDelta: false);
		return salesData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SalesData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SalesData Deserialize(BufferStream stream, SalesData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 24:
				instance.totalSales = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.totalIntervals = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.soldThisInterval = ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.currentMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.isForReceivedQuantity = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SalesData DeserializeLengthDelimited(BufferStream stream, SalesData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.totalSales = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.totalIntervals = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.soldThisInterval = ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.currentMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.isForReceivedQuantity = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SalesData DeserializeLength(BufferStream stream, int length, SalesData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.totalSales = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.totalIntervals = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.soldThisInterval = ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.currentMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.isForReceivedQuantity = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SalesData instance, SalesData previous)
	{
		if (instance.totalSales != previous.totalSales)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.totalSales);
		}
		if (instance.totalIntervals != previous.totalIntervals)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.totalIntervals);
		}
		if (instance.soldThisInterval != previous.soldThisInterval)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.soldThisInterval);
		}
		if (instance.currentMultiplier != previous.currentMultiplier)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.currentMultiplier);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.isForReceivedQuantity);
	}

	public static void Serialize(BufferStream stream, SalesData instance)
	{
		if (instance.totalSales != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.totalSales);
		}
		if (instance.totalIntervals != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.totalIntervals);
		}
		if (instance.soldThisInterval != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.soldThisInterval);
		}
		if (instance.currentMultiplier != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.currentMultiplier);
		}
		if (instance.isForReceivedQuantity)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.isForReceivedQuantity);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TinCanAlarm : IDisposable, IPooled, IProto<TinCanAlarm>, IProto
{
	[NonSerialized]
	public Vector3 endPoint;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TinCanAlarm instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.endPoint = default(Vector3);
			Pool.Free<TinCanAlarm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TinCanAlarm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TinCanAlarm instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.endPoint = endPoint;
	}

	public TinCanAlarm Copy()
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		CopyTo(tinCanAlarm);
		return tinCanAlarm;
	}

	public static TinCanAlarm Deserialize(BufferStream stream)
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		Deserialize(stream, tinCanAlarm, isDelta: false);
		return tinCanAlarm;
	}

	public static TinCanAlarm DeserializeLengthDelimited(BufferStream stream)
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		DeserializeLengthDelimited(stream, tinCanAlarm, isDelta: false);
		return tinCanAlarm;
	}

	public static TinCanAlarm DeserializeLength(BufferStream stream, int length)
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		DeserializeLength(stream, length, tinCanAlarm, isDelta: false);
		return tinCanAlarm;
	}

	public static TinCanAlarm Deserialize(byte[] buffer)
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, tinCanAlarm, isDelta: false);
		return tinCanAlarm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TinCanAlarm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TinCanAlarm Deserialize(BufferStream stream, TinCanAlarm instance, bool isDelta)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPoint, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TinCanAlarm DeserializeLengthDelimited(BufferStream stream, TinCanAlarm instance, bool isDelta)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPoint, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TinCanAlarm DeserializeLength(BufferStream stream, int length, TinCanAlarm instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPoint, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TinCanAlarm instance, TinCanAlarm previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.endPoint != previous.endPoint)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.endPoint, previous.endPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field endPoint (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, TinCanAlarm instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.endPoint != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.endPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field endPoint (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DigitalClock : IDisposable, IPooled, IProto<DigitalClock>, IProto
{
	[NonSerialized]
	public List<DigitalClockAlarm> alarms;

	[NonSerialized]
	public bool muted;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DigitalClock instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				if (instance.alarms[i] != null)
				{
					instance.alarms[i].ResetToPool();
					instance.alarms[i] = null;
				}
			}
			List<DigitalClockAlarm> list = instance.alarms;
			Pool.Free<DigitalClockAlarm>(ref list, false);
			instance.alarms = list;
		}
		instance.muted = false;
		Pool.Free<DigitalClock>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DigitalClock with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DigitalClock instance)
	{
		if (alarms != null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
			for (int i = 0; i < alarms.Count; i++)
			{
				DigitalClockAlarm item = alarms[i].Copy();
				instance.alarms.Add(item);
			}
		}
		else
		{
			instance.alarms = null;
		}
		instance.muted = muted;
	}

	public DigitalClock Copy()
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		CopyTo(digitalClock);
		return digitalClock;
	}

	public static DigitalClock Deserialize(BufferStream stream)
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		Deserialize(stream, digitalClock, isDelta: false);
		return digitalClock;
	}

	public static DigitalClock DeserializeLengthDelimited(BufferStream stream)
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		DeserializeLengthDelimited(stream, digitalClock, isDelta: false);
		return digitalClock;
	}

	public static DigitalClock DeserializeLength(BufferStream stream, int length)
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		DeserializeLength(stream, length, digitalClock, isDelta: false);
		return digitalClock;
	}

	public static DigitalClock Deserialize(byte[] buffer)
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, digitalClock, isDelta: false);
		return digitalClock;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DigitalClock previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DigitalClock Deserialize(BufferStream stream, DigitalClock instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DigitalClock DeserializeLengthDelimited(BufferStream stream, DigitalClock instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DigitalClock DeserializeLength(BufferStream stream, int length, DigitalClock instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DigitalClock instance, DigitalClock previous)
	{
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				DigitalClockAlarm digitalClockAlarm = instance.alarms[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				DigitalClockAlarm.SerializeDelta(stream, digitalClockAlarm, digitalClockAlarm);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field alarms (ProtoBuf.DigitalClockAlarm)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.muted);
	}

	public static void Serialize(BufferStream stream, DigitalClock instance)
	{
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				DigitalClockAlarm instance2 = instance.alarms[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				DigitalClockAlarm.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field alarms (ProtoBuf.DigitalClockAlarm)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.muted)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.muted);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (alarms != null)
		{
			for (int i = 0; i < alarms.Count; i++)
			{
				alarms[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ElevatorLift : IDisposable, IPooled, IProto<ElevatorLift>, IProto
{
	[NonSerialized]
	public NetworkableId owner;

	[NonSerialized]
	public float topElevatorHeight;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ElevatorLift instance)
	{
		if (instance.ShouldPool)
		{
			instance.owner = default(NetworkableId);
			instance.topElevatorHeight = 0f;
			Pool.Free<ElevatorLift>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ElevatorLift with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ElevatorLift instance)
	{
		instance.owner = owner;
		instance.topElevatorHeight = topElevatorHeight;
	}

	public ElevatorLift Copy()
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		CopyTo(elevatorLift);
		return elevatorLift;
	}

	public static ElevatorLift Deserialize(BufferStream stream)
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		Deserialize(stream, elevatorLift, isDelta: false);
		return elevatorLift;
	}

	public static ElevatorLift DeserializeLengthDelimited(BufferStream stream)
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		DeserializeLengthDelimited(stream, elevatorLift, isDelta: false);
		return elevatorLift;
	}

	public static ElevatorLift DeserializeLength(BufferStream stream, int length)
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		DeserializeLength(stream, length, elevatorLift, isDelta: false);
		return elevatorLift;
	}

	public static ElevatorLift Deserialize(byte[] buffer)
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, elevatorLift, isDelta: false);
		return elevatorLift;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ElevatorLift previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ElevatorLift Deserialize(BufferStream stream, ElevatorLift instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.owner = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.topElevatorHeight = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ElevatorLift DeserializeLengthDelimited(BufferStream stream, ElevatorLift instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.owner = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.topElevatorHeight = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ElevatorLift DeserializeLength(BufferStream stream, int length, ElevatorLift instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.owner = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.topElevatorHeight = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ElevatorLift instance, ElevatorLift previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.owner.Value);
		if (instance.topElevatorHeight != previous.topElevatorHeight)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.topElevatorHeight);
		}
	}

	public static void Serialize(BufferStream stream, ElevatorLift instance)
	{
		if (instance.owner != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.owner.Value);
		}
		if (instance.topElevatorHeight != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.topElevatorHeight);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref owner.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DiverPropulsionVehicle : IDisposable, IPooled, IProto<DiverPropulsionVehicle>, IProto
{
	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public int fuelAmount;

	[NonSerialized]
	public int fuelTicks;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DiverPropulsionVehicle instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelAmount = 0;
			instance.fuelTicks = 0;
			Pool.Free<DiverPropulsionVehicle>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DiverPropulsionVehicle with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DiverPropulsionVehicle instance)
	{
		instance.fuelStorageID = fuelStorageID;
		instance.fuelAmount = fuelAmount;
		instance.fuelTicks = fuelTicks;
	}

	public DiverPropulsionVehicle Copy()
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		CopyTo(diverPropulsionVehicle);
		return diverPropulsionVehicle;
	}

	public static DiverPropulsionVehicle Deserialize(BufferStream stream)
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		Deserialize(stream, diverPropulsionVehicle, isDelta: false);
		return diverPropulsionVehicle;
	}

	public static DiverPropulsionVehicle DeserializeLengthDelimited(BufferStream stream)
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		DeserializeLengthDelimited(stream, diverPropulsionVehicle, isDelta: false);
		return diverPropulsionVehicle;
	}

	public static DiverPropulsionVehicle DeserializeLength(BufferStream stream, int length)
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		DeserializeLength(stream, length, diverPropulsionVehicle, isDelta: false);
		return diverPropulsionVehicle;
	}

	public static DiverPropulsionVehicle Deserialize(byte[] buffer)
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, diverPropulsionVehicle, isDelta: false);
		return diverPropulsionVehicle;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DiverPropulsionVehicle previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DiverPropulsionVehicle Deserialize(BufferStream stream, DiverPropulsionVehicle instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.fuelTicks = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DiverPropulsionVehicle DeserializeLengthDelimited(BufferStream stream, DiverPropulsionVehicle instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.fuelTicks = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DiverPropulsionVehicle DeserializeLength(BufferStream stream, int length, DiverPropulsionVehicle instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.fuelTicks = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DiverPropulsionVehicle instance, DiverPropulsionVehicle previous)
	{
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelAmount != previous.fuelAmount)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.fuelAmount);
		}
		if (instance.fuelTicks != previous.fuelTicks)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.fuelTicks);
		}
	}

	public static void Serialize(BufferStream stream, DiverPropulsionVehicle instance)
	{
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelAmount != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.fuelAmount);
		}
		if (instance.fuelTicks != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.fuelTicks);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NPCVendingMachine : IDisposable, IPooled, IProto<NPCVendingMachine>, IProto
{
	[NonSerialized]
	public NetworkableId attachedNpc;

	[NonSerialized]
	public float nextRefresh;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NPCVendingMachine instance)
	{
		if (instance.ShouldPool)
		{
			instance.attachedNpc = default(NetworkableId);
			instance.nextRefresh = 0f;
			Pool.Free<NPCVendingMachine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NPCVendingMachine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NPCVendingMachine instance)
	{
		instance.attachedNpc = attachedNpc;
		instance.nextRefresh = nextRefresh;
	}

	public NPCVendingMachine Copy()
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		CopyTo(nPCVendingMachine);
		return nPCVendingMachine;
	}

	public static NPCVendingMachine Deserialize(BufferStream stream)
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		Deserialize(stream, nPCVendingMachine, isDelta: false);
		return nPCVendingMachine;
	}

	public static NPCVendingMachine DeserializeLengthDelimited(BufferStream stream)
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		DeserializeLengthDelimited(stream, nPCVendingMachine, isDelta: false);
		return nPCVendingMachine;
	}

	public static NPCVendingMachine DeserializeLength(BufferStream stream, int length)
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		DeserializeLength(stream, length, nPCVendingMachine, isDelta: false);
		return nPCVendingMachine;
	}

	public static NPCVendingMachine Deserialize(byte[] buffer)
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nPCVendingMachine, isDelta: false);
		return nPCVendingMachine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NPCVendingMachine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NPCVendingMachine Deserialize(BufferStream stream, NPCVendingMachine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.attachedNpc = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.nextRefresh = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NPCVendingMachine DeserializeLengthDelimited(BufferStream stream, NPCVendingMachine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.attachedNpc = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.nextRefresh = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NPCVendingMachine DeserializeLength(BufferStream stream, int length, NPCVendingMachine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.attachedNpc = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.nextRefresh = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NPCVendingMachine instance, NPCVendingMachine previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.attachedNpc.Value);
		if (instance.nextRefresh != previous.nextRefresh)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.nextRefresh);
		}
	}

	public static void Serialize(BufferStream stream, NPCVendingMachine instance)
	{
		if (instance.attachedNpc != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.attachedNpc.Value);
		}
		if (instance.nextRefresh != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.nextRefresh);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref attachedNpc.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Mailbox : IDisposable, IPooled, IProto<Mailbox>, IProto
{
	[NonSerialized]
	public ItemContainer inventory;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Mailbox instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.inventory != null)
			{
				instance.inventory.ResetToPool();
				instance.inventory = null;
			}
			Pool.Free<Mailbox>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Mailbox with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Mailbox instance)
	{
		if (inventory != null)
		{
			if (instance.inventory == null)
			{
				instance.inventory = inventory.Copy();
			}
			else
			{
				inventory.CopyTo(instance.inventory);
			}
		}
		else
		{
			instance.inventory = null;
		}
	}

	public Mailbox Copy()
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		CopyTo(mailbox);
		return mailbox;
	}

	public static Mailbox Deserialize(BufferStream stream)
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		Deserialize(stream, mailbox, isDelta: false);
		return mailbox;
	}

	public static Mailbox DeserializeLengthDelimited(BufferStream stream)
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		DeserializeLengthDelimited(stream, mailbox, isDelta: false);
		return mailbox;
	}

	public static Mailbox DeserializeLength(BufferStream stream, int length)
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		DeserializeLength(stream, length, mailbox, isDelta: false);
		return mailbox;
	}

	public static Mailbox Deserialize(byte[] buffer)
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mailbox, isDelta: false);
		return mailbox;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Mailbox previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Mailbox Deserialize(BufferStream stream, Mailbox instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.inventory == null)
				{
					instance.inventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static Mailbox DeserializeLengthDelimited(BufferStream stream, Mailbox instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.inventory == null)
				{
					instance.inventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Mailbox DeserializeLength(BufferStream stream, int length, Mailbox instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.inventory == null)
				{
					instance.inventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Mailbox instance, Mailbox previous)
	{
		if (instance.inventory == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.inventory, previous.inventory);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Mailbox instance)
	{
		if (instance.inventory == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.Serialize(stream, instance.inventory);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		inventory?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class GunWeaponMod : IDisposable, IPooled, IProto<GunWeaponMod>, IProto
{
	[NonSerialized]
	public int zoomLevel;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(GunWeaponMod instance)
	{
		if (instance.ShouldPool)
		{
			instance.zoomLevel = 0;
			Pool.Free<GunWeaponMod>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose GunWeaponMod with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(GunWeaponMod instance)
	{
		instance.zoomLevel = zoomLevel;
	}

	public GunWeaponMod Copy()
	{
		GunWeaponMod gunWeaponMod = Pool.Get<GunWeaponMod>();
		CopyTo(gunWeaponMod);
		return gunWeaponMod;
	}

	public static GunWeaponMod Deserialize(BufferStream stream)
	{
		GunWeaponMod gunWeaponMod = Pool.Get<GunWeaponMod>();
		Deserialize(stream, gunWeaponMod, isDelta: false);
		return gunWeaponMod;
	}

	public static GunWeaponMod DeserializeLengthDelimited(BufferStream stream)
	{
		GunWeaponMod gunWeaponMod = Pool.Get<GunWeaponMod>();
		DeserializeLengthDelimited(stream, gunWeaponMod, isDelta: false);
		return gunWeaponMod;
	}

	public static GunWeaponMod DeserializeLength(BufferStream stream, int length)
	{
		GunWeaponMod gunWeaponMod = Pool.Get<GunWeaponMod>();
		DeserializeLength(stream, length, gunWeaponMod, isDelta: false);
		return gunWeaponMod;
	}

	public static GunWeaponMod Deserialize(byte[] buffer)
	{
		GunWeaponMod gunWeaponMod = Pool.Get<GunWeaponMod>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, gunWeaponMod, isDelta: false);
		return gunWeaponMod;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, GunWeaponMod previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static GunWeaponMod Deserialize(BufferStream stream, GunWeaponMod instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.zoomLevel = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static GunWeaponMod DeserializeLengthDelimited(BufferStream stream, GunWeaponMod instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.zoomLevel = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static GunWeaponMod DeserializeLength(BufferStream stream, int length, GunWeaponMod instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.zoomLevel = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, GunWeaponMod instance, GunWeaponMod previous)
	{
		if (instance.zoomLevel != previous.zoomLevel)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.zoomLevel);
		}
	}

	public static void Serialize(BufferStream stream, GunWeaponMod instance)
	{
		if (instance.zoomLevel != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.zoomLevel);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseSculpture : IDisposable, IPooled, IProto<BaseSculpture>, IProto
{
	[NonSerialized]
	public uint crc;

	[NonSerialized]
	public int colourSelection;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseSculpture instance)
	{
		if (instance.ShouldPool)
		{
			instance.crc = 0u;
			instance.colourSelection = 0;
			Pool.Free<BaseSculpture>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseSculpture with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseSculpture instance)
	{
		instance.crc = crc;
		instance.colourSelection = colourSelection;
	}

	public BaseSculpture Copy()
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		CopyTo(baseSculpture);
		return baseSculpture;
	}

	public static BaseSculpture Deserialize(BufferStream stream)
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		Deserialize(stream, baseSculpture, isDelta: false);
		return baseSculpture;
	}

	public static BaseSculpture DeserializeLengthDelimited(BufferStream stream)
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		DeserializeLengthDelimited(stream, baseSculpture, isDelta: false);
		return baseSculpture;
	}

	public static BaseSculpture DeserializeLength(BufferStream stream, int length)
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		DeserializeLength(stream, length, baseSculpture, isDelta: false);
		return baseSculpture;
	}

	public static BaseSculpture Deserialize(byte[] buffer)
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseSculpture, isDelta: false);
		return baseSculpture;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseSculpture previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseSculpture Deserialize(BufferStream stream, BaseSculpture instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.colourSelection = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseSculpture DeserializeLengthDelimited(BufferStream stream, BaseSculpture instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.colourSelection = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseSculpture DeserializeLength(BufferStream stream, int length, BaseSculpture instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.colourSelection = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseSculpture instance, BaseSculpture previous)
	{
		if (instance.crc != previous.crc)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
		if (instance.colourSelection != previous.colourSelection)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourSelection);
		}
	}

	public static void Serialize(BufferStream stream, BaseSculpture instance)
	{
		if (instance.crc != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
		if (instance.colourSelection != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourSelection);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Catapult : IDisposable, IPooled, IProto<Catapult>, IProto
{
	[NonSerialized]
	public NetworkableId ammoStorageID;

	[NonSerialized]
	public float reloadProgress;

	[NonSerialized]
	public int ammoType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Catapult instance)
	{
		if (instance.ShouldPool)
		{
			instance.ammoStorageID = default(NetworkableId);
			instance.reloadProgress = 0f;
			instance.ammoType = 0;
			Pool.Free<Catapult>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Catapult with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Catapult instance)
	{
		instance.ammoStorageID = ammoStorageID;
		instance.reloadProgress = reloadProgress;
		instance.ammoType = ammoType;
	}

	public Catapult Copy()
	{
		Catapult catapult = Pool.Get<Catapult>();
		CopyTo(catapult);
		return catapult;
	}

	public static Catapult Deserialize(BufferStream stream)
	{
		Catapult catapult = Pool.Get<Catapult>();
		Deserialize(stream, catapult, isDelta: false);
		return catapult;
	}

	public static Catapult DeserializeLengthDelimited(BufferStream stream)
	{
		Catapult catapult = Pool.Get<Catapult>();
		DeserializeLengthDelimited(stream, catapult, isDelta: false);
		return catapult;
	}

	public static Catapult DeserializeLength(BufferStream stream, int length)
	{
		Catapult catapult = Pool.Get<Catapult>();
		DeserializeLength(stream, length, catapult, isDelta: false);
		return catapult;
	}

	public static Catapult Deserialize(byte[] buffer)
	{
		Catapult catapult = Pool.Get<Catapult>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, catapult, isDelta: false);
		return catapult;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Catapult previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Catapult Deserialize(BufferStream stream, Catapult instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.ammoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Catapult DeserializeLengthDelimited(BufferStream stream, Catapult instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Catapult DeserializeLength(BufferStream stream, int length, Catapult instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Catapult instance, Catapult previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.ammoStorageID.Value);
		if (instance.reloadProgress != previous.reloadProgress)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.reloadProgress);
		}
		if (instance.ammoType != previous.ammoType)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
	}

	public static void Serialize(BufferStream stream, Catapult instance)
	{
		if (instance.ammoStorageID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.ammoStorageID.Value);
		}
		if (instance.reloadProgress != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.reloadProgress);
		}
		if (instance.ammoType != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref ammoStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SiegeTower : IDisposable, IPooled, IProto<SiegeTower>, IProto
{
	[NonSerialized]
	public NetworkableId doorID;

	[NonSerialized]
	public NetworkableId drawBridgeID;

	[NonSerialized]
	public NetworkableId drawBridge2ID;

	[NonSerialized]
	public NetworkableId drawBridge3ID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SiegeTower instance)
	{
		if (instance.ShouldPool)
		{
			instance.doorID = default(NetworkableId);
			instance.drawBridgeID = default(NetworkableId);
			instance.drawBridge2ID = default(NetworkableId);
			instance.drawBridge3ID = default(NetworkableId);
			Pool.Free<SiegeTower>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SiegeTower with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SiegeTower instance)
	{
		instance.doorID = doorID;
		instance.drawBridgeID = drawBridgeID;
		instance.drawBridge2ID = drawBridge2ID;
		instance.drawBridge3ID = drawBridge3ID;
	}

	public SiegeTower Copy()
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		CopyTo(siegeTower);
		return siegeTower;
	}

	public static SiegeTower Deserialize(BufferStream stream)
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		Deserialize(stream, siegeTower, isDelta: false);
		return siegeTower;
	}

	public static SiegeTower DeserializeLengthDelimited(BufferStream stream)
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		DeserializeLengthDelimited(stream, siegeTower, isDelta: false);
		return siegeTower;
	}

	public static SiegeTower DeserializeLength(BufferStream stream, int length)
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		DeserializeLength(stream, length, siegeTower, isDelta: false);
		return siegeTower;
	}

	public static SiegeTower Deserialize(byte[] buffer)
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, siegeTower, isDelta: false);
		return siegeTower;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SiegeTower previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SiegeTower Deserialize(BufferStream stream, SiegeTower instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.drawBridgeID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.drawBridge2ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.drawBridge3ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SiegeTower DeserializeLengthDelimited(BufferStream stream, SiegeTower instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.drawBridgeID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.drawBridge2ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.drawBridge3ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SiegeTower DeserializeLength(BufferStream stream, int length, SiegeTower instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.drawBridgeID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.drawBridge2ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.drawBridge3ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SiegeTower instance, SiegeTower previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.doorID.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.drawBridgeID.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.drawBridge2ID.Value);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.drawBridge3ID.Value);
	}

	public static void Serialize(BufferStream stream, SiegeTower instance)
	{
		if (instance.doorID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.doorID.Value);
		}
		if (instance.drawBridgeID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.drawBridgeID.Value);
		}
		if (instance.drawBridge2ID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.drawBridge2ID.Value);
		}
		if (instance.drawBridge3ID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.drawBridge3ID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref doorID.Value);
		action(UidType.NetworkableId, ref drawBridgeID.Value);
		action(UidType.NetworkableId, ref drawBridge2ID.Value);
		action(UidType.NetworkableId, ref drawBridge3ID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Ballista : IDisposable, IPooled, IProto<Ballista>, IProto
{
	[NonSerialized]
	public NetworkableId gunID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Ballista instance)
	{
		if (instance.ShouldPool)
		{
			instance.gunID = default(NetworkableId);
			Pool.Free<Ballista>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Ballista with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Ballista instance)
	{
		instance.gunID = gunID;
	}

	public Ballista Copy()
	{
		Ballista ballista = Pool.Get<Ballista>();
		CopyTo(ballista);
		return ballista;
	}

	public static Ballista Deserialize(BufferStream stream)
	{
		Ballista ballista = Pool.Get<Ballista>();
		Deserialize(stream, ballista, isDelta: false);
		return ballista;
	}

	public static Ballista DeserializeLengthDelimited(BufferStream stream)
	{
		Ballista ballista = Pool.Get<Ballista>();
		DeserializeLengthDelimited(stream, ballista, isDelta: false);
		return ballista;
	}

	public static Ballista DeserializeLength(BufferStream stream, int length)
	{
		Ballista ballista = Pool.Get<Ballista>();
		DeserializeLength(stream, length, ballista, isDelta: false);
		return ballista;
	}

	public static Ballista Deserialize(byte[] buffer)
	{
		Ballista ballista = Pool.Get<Ballista>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ballista, isDelta: false);
		return ballista;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Ballista previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Ballista Deserialize(BufferStream stream, Ballista instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.gunID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Ballista DeserializeLengthDelimited(BufferStream stream, Ballista instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.gunID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Ballista DeserializeLength(BufferStream stream, int length, Ballista instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.gunID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Ballista instance, Ballista previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.gunID.Value);
	}

	public static void Serialize(BufferStream stream, Ballista instance)
	{
		if (instance.gunID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.gunID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref gunID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class BallistaGun : IDisposable, IPooled, IProto<BallistaGun>, IProto
{
	[NonSerialized]
	public Magazine magazine;

	[NonSerialized]
	public float reloadProgress;

	[NonSerialized]
	public Vector3 aimDir;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BallistaGun instance)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			if (instance.magazine != null)
			{
				instance.magazine.ResetToPool();
				instance.magazine = null;
			}
			instance.reloadProgress = 0f;
			instance.aimDir = default(Vector3);
			Pool.Free<BallistaGun>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BallistaGun with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BallistaGun instance)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (magazine != null)
		{
			if (instance.magazine == null)
			{
				instance.magazine = magazine.Copy();
			}
			else
			{
				magazine.CopyTo(instance.magazine);
			}
		}
		else
		{
			instance.magazine = null;
		}
		instance.reloadProgress = reloadProgress;
		instance.aimDir = aimDir;
	}

	public BallistaGun Copy()
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		CopyTo(ballistaGun);
		return ballistaGun;
	}

	public static BallistaGun Deserialize(BufferStream stream)
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		Deserialize(stream, ballistaGun, isDelta: false);
		return ballistaGun;
	}

	public static BallistaGun DeserializeLengthDelimited(BufferStream stream)
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		DeserializeLengthDelimited(stream, ballistaGun, isDelta: false);
		return ballistaGun;
	}

	public static BallistaGun DeserializeLength(BufferStream stream, int length)
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		DeserializeLength(stream, length, ballistaGun, isDelta: false);
		return ballistaGun;
	}

	public static BallistaGun Deserialize(byte[] buffer)
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ballistaGun, isDelta: false);
		return ballistaGun;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BallistaGun previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BallistaGun Deserialize(BufferStream stream, BallistaGun instance, bool isDelta)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.magazine == null)
				{
					instance.magazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.magazine, isDelta);
				}
				break;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				break;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static BallistaGun DeserializeLengthDelimited(BufferStream stream, BallistaGun instance, bool isDelta)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.magazine == null)
				{
					instance.magazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.magazine, isDelta);
				}
				break;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				break;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BallistaGun DeserializeLength(BufferStream stream, int length, BallistaGun instance, bool isDelta)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.magazine == null)
				{
					instance.magazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.magazine, isDelta);
				}
				break;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				break;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BallistaGun instance, BallistaGun previous)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (instance.magazine != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Magazine.SerializeDelta(stream, instance.magazine, previous.magazine);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field magazine (ProtoBuf.Magazine)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.reloadProgress != previous.reloadProgress)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.reloadProgress);
		}
		if (instance.aimDir != previous.aimDir)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aimDir, previous.aimDir);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, BallistaGun instance)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.magazine != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Magazine.Serialize(stream, instance.magazine);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field magazine (ProtoBuf.Magazine)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.reloadProgress != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.reloadProgress);
		}
		if (instance.aimDir != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aimDir);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		magazine?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BatteringRam : IDisposable, IPooled, IProto<BatteringRam>, IProto
{
	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public NetworkableId headID;

	[NonSerialized]
	public float steerInput;

	[NonSerialized]
	public float driveWheelVel;

	[NonSerialized]
	public float throttleInput;

	[NonSerialized]
	public float brakeInput;

	[NonSerialized]
	public float fuelFraction;

	[NonSerialized]
	public float doorAngle;

	[NonSerialized]
	public float time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BatteringRam instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelStorageID = default(NetworkableId);
			instance.headID = default(NetworkableId);
			instance.steerInput = 0f;
			instance.driveWheelVel = 0f;
			instance.throttleInput = 0f;
			instance.brakeInput = 0f;
			instance.fuelFraction = 0f;
			instance.doorAngle = 0f;
			instance.time = 0f;
			Pool.Free<BatteringRam>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BatteringRam with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BatteringRam instance)
	{
		instance.fuelStorageID = fuelStorageID;
		instance.headID = headID;
		instance.steerInput = steerInput;
		instance.driveWheelVel = driveWheelVel;
		instance.throttleInput = throttleInput;
		instance.brakeInput = brakeInput;
		instance.fuelFraction = fuelFraction;
		instance.doorAngle = doorAngle;
		instance.time = time;
	}

	public BatteringRam Copy()
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		CopyTo(batteringRam);
		return batteringRam;
	}

	public static BatteringRam Deserialize(BufferStream stream)
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		Deserialize(stream, batteringRam, isDelta: false);
		return batteringRam;
	}

	public static BatteringRam DeserializeLengthDelimited(BufferStream stream)
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		DeserializeLengthDelimited(stream, batteringRam, isDelta: false);
		return batteringRam;
	}

	public static BatteringRam DeserializeLength(BufferStream stream, int length)
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		DeserializeLength(stream, length, batteringRam, isDelta: false);
		return batteringRam;
	}

	public static BatteringRam Deserialize(byte[] buffer)
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, batteringRam, isDelta: false);
		return batteringRam;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BatteringRam previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BatteringRam Deserialize(BufferStream stream, BatteringRam instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.headID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 29:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.doorAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BatteringRam DeserializeLengthDelimited(BufferStream stream, BatteringRam instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.headID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 29:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.doorAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BatteringRam DeserializeLength(BufferStream stream, int length, BatteringRam instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.headID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 29:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.doorAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BatteringRam instance, BatteringRam previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.headID.Value);
		if (instance.steerInput != previous.steerInput)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != previous.driveWheelVel)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != previous.throttleInput)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != previous.brakeInput)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.doorAngle != previous.doorAngle)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.doorAngle);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public static void Serialize(BufferStream stream, BatteringRam instance)
	{
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.headID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.headID.Value);
		}
		if (instance.steerInput != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.doorAngle != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.doorAngle);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
		action(UidType.NetworkableId, ref headID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TemporaryRagdoll : IDisposable, IPooled, IProto<TemporaryRagdoll>, IProto
{
	[NonSerialized]
	public NetworkableId parentID;

	[NonSerialized]
	public int mountPose;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TemporaryRagdoll instance)
	{
		if (instance.ShouldPool)
		{
			instance.parentID = default(NetworkableId);
			instance.mountPose = 0;
			Pool.Free<TemporaryRagdoll>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TemporaryRagdoll with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TemporaryRagdoll instance)
	{
		instance.parentID = parentID;
		instance.mountPose = mountPose;
	}

	public TemporaryRagdoll Copy()
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		CopyTo(temporaryRagdoll);
		return temporaryRagdoll;
	}

	public static TemporaryRagdoll Deserialize(BufferStream stream)
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		Deserialize(stream, temporaryRagdoll, isDelta: false);
		return temporaryRagdoll;
	}

	public static TemporaryRagdoll DeserializeLengthDelimited(BufferStream stream)
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		DeserializeLengthDelimited(stream, temporaryRagdoll, isDelta: false);
		return temporaryRagdoll;
	}

	public static TemporaryRagdoll DeserializeLength(BufferStream stream, int length)
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		DeserializeLength(stream, length, temporaryRagdoll, isDelta: false);
		return temporaryRagdoll;
	}

	public static TemporaryRagdoll Deserialize(byte[] buffer)
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, temporaryRagdoll, isDelta: false);
		return temporaryRagdoll;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TemporaryRagdoll previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TemporaryRagdoll Deserialize(BufferStream stream, TemporaryRagdoll instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.mountPose = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TemporaryRagdoll DeserializeLengthDelimited(BufferStream stream, TemporaryRagdoll instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.mountPose = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TemporaryRagdoll DeserializeLength(BufferStream stream, int length, TemporaryRagdoll instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.mountPose = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TemporaryRagdoll instance, TemporaryRagdoll previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		if (instance.mountPose != previous.mountPose)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.mountPose);
		}
	}

	public static void Serialize(BufferStream stream, TemporaryRagdoll instance)
	{
		if (instance.parentID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		}
		if (instance.mountPose != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.mountPose);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref parentID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ConstructableEntity : IDisposable, IPooled, IProto<ConstructableEntity>, IProto
{
	[NonSerialized]
	public List<int> addedResources;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ConstructableEntity instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.addedResources != null)
			{
				List<int> list = instance.addedResources;
				Pool.FreeUnmanaged<int>(ref list);
				instance.addedResources = list;
			}
			Pool.Free<ConstructableEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ConstructableEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ConstructableEntity instance)
	{
		if (addedResources != null)
		{
			instance.addedResources = Pool.Get<List<int>>();
			for (int i = 0; i < addedResources.Count; i++)
			{
				int item = addedResources[i];
				instance.addedResources.Add(item);
			}
		}
		else
		{
			instance.addedResources = null;
		}
	}

	public ConstructableEntity Copy()
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		CopyTo(constructableEntity);
		return constructableEntity;
	}

	public static ConstructableEntity Deserialize(BufferStream stream)
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		Deserialize(stream, constructableEntity, isDelta: false);
		return constructableEntity;
	}

	public static ConstructableEntity DeserializeLengthDelimited(BufferStream stream)
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		DeserializeLengthDelimited(stream, constructableEntity, isDelta: false);
		return constructableEntity;
	}

	public static ConstructableEntity DeserializeLength(BufferStream stream, int length)
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		DeserializeLength(stream, length, constructableEntity, isDelta: false);
		return constructableEntity;
	}

	public static ConstructableEntity Deserialize(byte[] buffer)
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, constructableEntity, isDelta: false);
		return constructableEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ConstructableEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ConstructableEntity Deserialize(BufferStream stream, ConstructableEntity instance, bool isDelta)
	{
		if (!isDelta && instance.addedResources == null)
		{
			instance.addedResources = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.addedResources.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ConstructableEntity DeserializeLengthDelimited(BufferStream stream, ConstructableEntity instance, bool isDelta)
	{
		if (!isDelta && instance.addedResources == null)
		{
			instance.addedResources = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.addedResources.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ConstructableEntity DeserializeLength(BufferStream stream, int length, ConstructableEntity instance, bool isDelta)
	{
		if (!isDelta && instance.addedResources == null)
		{
			instance.addedResources = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.addedResources.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ConstructableEntity instance, ConstructableEntity previous)
	{
		if (instance.addedResources != null)
		{
			for (int i = 0; i < instance.addedResources.Count; i++)
			{
				int num = instance.addedResources[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public static void Serialize(BufferStream stream, ConstructableEntity instance)
	{
		if (instance.addedResources != null)
		{
			for (int i = 0; i < instance.addedResources.Count; i++)
			{
				int num = instance.addedResources[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ChickenStatus : IDisposable, IPooled, IProto<ChickenStatus>, IProto
{
	[NonSerialized]
	public NetworkableId spawnedChicken;

	[NonSerialized]
	public float timeUntilHatch;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ChickenStatus instance)
	{
		if (instance.ShouldPool)
		{
			instance.spawnedChicken = default(NetworkableId);
			instance.timeUntilHatch = 0f;
			Pool.Free<ChickenStatus>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ChickenStatus with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ChickenStatus instance)
	{
		instance.spawnedChicken = spawnedChicken;
		instance.timeUntilHatch = timeUntilHatch;
	}

	public ChickenStatus Copy()
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		CopyTo(chickenStatus);
		return chickenStatus;
	}

	public static ChickenStatus Deserialize(BufferStream stream)
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		Deserialize(stream, chickenStatus, isDelta: false);
		return chickenStatus;
	}

	public static ChickenStatus DeserializeLengthDelimited(BufferStream stream)
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		DeserializeLengthDelimited(stream, chickenStatus, isDelta: false);
		return chickenStatus;
	}

	public static ChickenStatus DeserializeLength(BufferStream stream, int length)
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		DeserializeLength(stream, length, chickenStatus, isDelta: false);
		return chickenStatus;
	}

	public static ChickenStatus Deserialize(byte[] buffer)
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, chickenStatus, isDelta: false);
		return chickenStatus;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ChickenStatus previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ChickenStatus Deserialize(BufferStream stream, ChickenStatus instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.spawnedChicken = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeUntilHatch = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ChickenStatus DeserializeLengthDelimited(BufferStream stream, ChickenStatus instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.spawnedChicken = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeUntilHatch = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ChickenStatus DeserializeLength(BufferStream stream, int length, ChickenStatus instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.spawnedChicken = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeUntilHatch = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ChickenStatus instance, ChickenStatus previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.spawnedChicken.Value);
		if (instance.timeUntilHatch != previous.timeUntilHatch)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeUntilHatch);
		}
	}

	public static void Serialize(BufferStream stream, ChickenStatus instance)
	{
		if (instance.spawnedChicken != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.spawnedChicken.Value);
		}
		if (instance.timeUntilHatch != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeUntilHatch);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref spawnedChicken.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ChickenCoop : IDisposable, IPooled, IProto<ChickenCoop>, IProto
{
	[NonSerialized]
	public List<ChickenStatus> chickens;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ChickenCoop instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.chickens != null)
		{
			for (int i = 0; i < instance.chickens.Count; i++)
			{
				if (instance.chickens[i] != null)
				{
					instance.chickens[i].ResetToPool();
					instance.chickens[i] = null;
				}
			}
			List<ChickenStatus> list = instance.chickens;
			Pool.Free<ChickenStatus>(ref list, false);
			instance.chickens = list;
		}
		Pool.Free<ChickenCoop>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ChickenCoop with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ChickenCoop instance)
	{
		if (chickens != null)
		{
			instance.chickens = Pool.Get<List<ChickenStatus>>();
			for (int i = 0; i < chickens.Count; i++)
			{
				ChickenStatus item = chickens[i].Copy();
				instance.chickens.Add(item);
			}
		}
		else
		{
			instance.chickens = null;
		}
	}

	public ChickenCoop Copy()
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		CopyTo(chickenCoop);
		return chickenCoop;
	}

	public static ChickenCoop Deserialize(BufferStream stream)
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		Deserialize(stream, chickenCoop, isDelta: false);
		return chickenCoop;
	}

	public static ChickenCoop DeserializeLengthDelimited(BufferStream stream)
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		DeserializeLengthDelimited(stream, chickenCoop, isDelta: false);
		return chickenCoop;
	}

	public static ChickenCoop DeserializeLength(BufferStream stream, int length)
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		DeserializeLength(stream, length, chickenCoop, isDelta: false);
		return chickenCoop;
	}

	public static ChickenCoop Deserialize(byte[] buffer)
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, chickenCoop, isDelta: false);
		return chickenCoop;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ChickenCoop previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ChickenCoop Deserialize(BufferStream stream, ChickenCoop instance, bool isDelta)
	{
		if (!isDelta && instance.chickens == null)
		{
			instance.chickens = Pool.Get<List<ChickenStatus>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.chickens.Add(ChickenStatus.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ChickenCoop DeserializeLengthDelimited(BufferStream stream, ChickenCoop instance, bool isDelta)
	{
		if (!isDelta && instance.chickens == null)
		{
			instance.chickens = Pool.Get<List<ChickenStatus>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.chickens.Add(ChickenStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ChickenCoop DeserializeLength(BufferStream stream, int length, ChickenCoop instance, bool isDelta)
	{
		if (!isDelta && instance.chickens == null)
		{
			instance.chickens = Pool.Get<List<ChickenStatus>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.chickens.Add(ChickenStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ChickenCoop instance, ChickenCoop previous)
	{
		if (instance.chickens == null)
		{
			return;
		}
		for (int i = 0; i < instance.chickens.Count; i++)
		{
			ChickenStatus chickenStatus = instance.chickens[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ChickenStatus.SerializeDelta(stream, chickenStatus, chickenStatus);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field chickens (ProtoBuf.ChickenStatus)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ChickenCoop instance)
	{
		if (instance.chickens == null)
		{
			return;
		}
		for (int i = 0; i < instance.chickens.Count; i++)
		{
			ChickenStatus instance2 = instance.chickens[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ChickenStatus.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field chickens (ProtoBuf.ChickenStatus)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (chickens != null)
		{
			for (int i = 0; i < chickens.Count; i++)
			{
				chickens[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class FarmableAnimal : IDisposable, IPooled, IProto<FarmableAnimal>, IProto
{
	[NonSerialized]
	public float hunger;

	[NonSerialized]
	public float thirst;

	[NonSerialized]
	public float love;

	[NonSerialized]
	public float sunlight;

	[NonSerialized]
	public string animalName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FarmableAnimal instance)
	{
		if (instance.ShouldPool)
		{
			instance.hunger = 0f;
			instance.thirst = 0f;
			instance.love = 0f;
			instance.sunlight = 0f;
			instance.animalName = string.Empty;
			Pool.Free<FarmableAnimal>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FarmableAnimal with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FarmableAnimal instance)
	{
		instance.hunger = hunger;
		instance.thirst = thirst;
		instance.love = love;
		instance.sunlight = sunlight;
		instance.animalName = animalName;
	}

	public FarmableAnimal Copy()
	{
		FarmableAnimal farmableAnimal = Pool.Get<FarmableAnimal>();
		CopyTo(farmableAnimal);
		return farmableAnimal;
	}

	public static FarmableAnimal Deserialize(BufferStream stream)
	{
		FarmableAnimal farmableAnimal = Pool.Get<FarmableAnimal>();
		Deserialize(stream, farmableAnimal, isDelta: false);
		return farmableAnimal;
	}

	public static FarmableAnimal DeserializeLengthDelimited(BufferStream stream)
	{
		FarmableAnimal farmableAnimal = Pool.Get<FarmableAnimal>();
		DeserializeLengthDelimited(stream, farmableAnimal, isDelta: false);
		return farmableAnimal;
	}

	public static FarmableAnimal DeserializeLength(BufferStream stream, int length)
	{
		FarmableAnimal farmableAnimal = Pool.Get<FarmableAnimal>();
		DeserializeLength(stream, length, farmableAnimal, isDelta: false);
		return farmableAnimal;
	}

	public static FarmableAnimal Deserialize(byte[] buffer)
	{
		FarmableAnimal farmableAnimal = Pool.Get<FarmableAnimal>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, farmableAnimal, isDelta: false);
		return farmableAnimal;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FarmableAnimal previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FarmableAnimal Deserialize(BufferStream stream, FarmableAnimal instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.hunger = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.thirst = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.love = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunlight = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.animalName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FarmableAnimal DeserializeLengthDelimited(BufferStream stream, FarmableAnimal instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.hunger = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.thirst = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.love = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunlight = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.animalName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FarmableAnimal DeserializeLength(BufferStream stream, int length, FarmableAnimal instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.hunger = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.thirst = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.love = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunlight = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.animalName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FarmableAnimal instance, FarmableAnimal previous)
	{
		if (instance.hunger != previous.hunger)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.hunger);
		}
		if (instance.thirst != previous.thirst)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.thirst);
		}
		if (instance.love != previous.love)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.love);
		}
		if (instance.sunlight != previous.sunlight)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.sunlight);
		}
		if (instance.animalName != null && instance.animalName != previous.animalName)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.animalName);
		}
	}

	public static void Serialize(BufferStream stream, FarmableAnimal instance)
	{
		if (instance.hunger != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.hunger);
		}
		if (instance.thirst != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.thirst);
		}
		if (instance.love != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.love);
		}
		if (instance.sunlight != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.sunlight);
		}
		if (instance.animalName != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.animalName);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Beehive : IDisposable, IPooled, IProto<Beehive>, IProto
{
	[NonSerialized]
	public float currentProgress;

	[NonSerialized]
	public float temperature;

	[NonSerialized]
	public bool inside;

	[NonSerialized]
	public float humidity;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Beehive instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentProgress = 0f;
			instance.temperature = 0f;
			instance.inside = false;
			instance.humidity = 0f;
			Pool.Free<Beehive>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Beehive with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Beehive instance)
	{
		instance.currentProgress = currentProgress;
		instance.temperature = temperature;
		instance.inside = inside;
		instance.humidity = humidity;
	}

	public Beehive Copy()
	{
		Beehive beehive = Pool.Get<Beehive>();
		CopyTo(beehive);
		return beehive;
	}

	public static Beehive Deserialize(BufferStream stream)
	{
		Beehive beehive = Pool.Get<Beehive>();
		Deserialize(stream, beehive, isDelta: false);
		return beehive;
	}

	public static Beehive DeserializeLengthDelimited(BufferStream stream)
	{
		Beehive beehive = Pool.Get<Beehive>();
		DeserializeLengthDelimited(stream, beehive, isDelta: false);
		return beehive;
	}

	public static Beehive DeserializeLength(BufferStream stream, int length)
	{
		Beehive beehive = Pool.Get<Beehive>();
		DeserializeLength(stream, length, beehive, isDelta: false);
		return beehive;
	}

	public static Beehive Deserialize(byte[] buffer)
	{
		Beehive beehive = Pool.Get<Beehive>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, beehive, isDelta: false);
		return beehive;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Beehive previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Beehive Deserialize(BufferStream stream, Beehive instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.currentProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.inside = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.humidity = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Beehive DeserializeLengthDelimited(BufferStream stream, Beehive instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.currentProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.inside = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.humidity = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Beehive DeserializeLength(BufferStream stream, int length, Beehive instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.currentProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.inside = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.humidity = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Beehive instance, Beehive previous)
	{
		if (instance.currentProgress != previous.currentProgress)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.currentProgress);
		}
		if (instance.temperature != previous.temperature)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.inside);
		if (instance.humidity != previous.humidity)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.humidity);
		}
	}

	public static void Serialize(BufferStream stream, Beehive instance)
	{
		if (instance.currentProgress != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.currentProgress);
		}
		if (instance.temperature != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.inside)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.inside);
		}
		if (instance.humidity != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.humidity);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BeeMasterSwarm : IDisposable, IPooled, IProto<BeeMasterSwarm>, IProto
{
	[NonSerialized]
	public float population;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BeeMasterSwarm instance)
	{
		if (instance.ShouldPool)
		{
			instance.population = 0f;
			Pool.Free<BeeMasterSwarm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BeeMasterSwarm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BeeMasterSwarm instance)
	{
		instance.population = population;
	}

	public BeeMasterSwarm Copy()
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		CopyTo(beeMasterSwarm);
		return beeMasterSwarm;
	}

	public static BeeMasterSwarm Deserialize(BufferStream stream)
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		Deserialize(stream, beeMasterSwarm, isDelta: false);
		return beeMasterSwarm;
	}

	public static BeeMasterSwarm DeserializeLengthDelimited(BufferStream stream)
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		DeserializeLengthDelimited(stream, beeMasterSwarm, isDelta: false);
		return beeMasterSwarm;
	}

	public static BeeMasterSwarm DeserializeLength(BufferStream stream, int length)
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		DeserializeLength(stream, length, beeMasterSwarm, isDelta: false);
		return beeMasterSwarm;
	}

	public static BeeMasterSwarm Deserialize(byte[] buffer)
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, beeMasterSwarm, isDelta: false);
		return beeMasterSwarm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BeeMasterSwarm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BeeMasterSwarm Deserialize(BufferStream stream, BeeMasterSwarm instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.population = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BeeMasterSwarm DeserializeLengthDelimited(BufferStream stream, BeeMasterSwarm instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.population = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BeeMasterSwarm DeserializeLength(BufferStream stream, int length, BeeMasterSwarm instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.population = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BeeMasterSwarm instance, BeeMasterSwarm previous)
	{
		if (instance.population != previous.population)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.population);
		}
	}

	public static void Serialize(BufferStream stream, BeeMasterSwarm instance)
	{
		if (instance.population != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.population);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ContainerCorpseData : IDisposable, IPooled, IProto<ContainerCorpseData>, IProto
{
	[NonSerialized]
	public ulong lockOwnerId;

	[NonSerialized]
	public CodeLock codeLock;

	[NonSerialized]
	public KeyLock keyLock;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ContainerCorpseData instance)
	{
		if (instance.ShouldPool)
		{
			instance.lockOwnerId = 0uL;
			if (instance.codeLock != null)
			{
				instance.codeLock.ResetToPool();
				instance.codeLock = null;
			}
			if (instance.keyLock != null)
			{
				instance.keyLock.ResetToPool();
				instance.keyLock = null;
			}
			Pool.Free<ContainerCorpseData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ContainerCorpseData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ContainerCorpseData instance)
	{
		instance.lockOwnerId = lockOwnerId;
		if (codeLock != null)
		{
			if (instance.codeLock == null)
			{
				instance.codeLock = codeLock.Copy();
			}
			else
			{
				codeLock.CopyTo(instance.codeLock);
			}
		}
		else
		{
			instance.codeLock = null;
		}
		if (keyLock != null)
		{
			if (instance.keyLock == null)
			{
				instance.keyLock = keyLock.Copy();
			}
			else
			{
				keyLock.CopyTo(instance.keyLock);
			}
		}
		else
		{
			instance.keyLock = null;
		}
	}

	public ContainerCorpseData Copy()
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		CopyTo(containerCorpseData);
		return containerCorpseData;
	}

	public static ContainerCorpseData Deserialize(BufferStream stream)
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		Deserialize(stream, containerCorpseData, isDelta: false);
		return containerCorpseData;
	}

	public static ContainerCorpseData DeserializeLengthDelimited(BufferStream stream)
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		DeserializeLengthDelimited(stream, containerCorpseData, isDelta: false);
		return containerCorpseData;
	}

	public static ContainerCorpseData DeserializeLength(BufferStream stream, int length)
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		DeserializeLength(stream, length, containerCorpseData, isDelta: false);
		return containerCorpseData;
	}

	public static ContainerCorpseData Deserialize(byte[] buffer)
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, containerCorpseData, isDelta: false);
		return containerCorpseData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ContainerCorpseData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ContainerCorpseData Deserialize(BufferStream stream, ContainerCorpseData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lockOwnerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.codeLock == null)
				{
					instance.codeLock = CodeLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					CodeLock.DeserializeLengthDelimited(stream, instance.codeLock, isDelta);
				}
				break;
			case 26:
				if (instance.keyLock == null)
				{
					instance.keyLock = KeyLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					KeyLock.DeserializeLengthDelimited(stream, instance.keyLock, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static ContainerCorpseData DeserializeLengthDelimited(BufferStream stream, ContainerCorpseData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lockOwnerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.codeLock == null)
				{
					instance.codeLock = CodeLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					CodeLock.DeserializeLengthDelimited(stream, instance.codeLock, isDelta);
				}
				break;
			case 26:
				if (instance.keyLock == null)
				{
					instance.keyLock = KeyLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					KeyLock.DeserializeLengthDelimited(stream, instance.keyLock, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ContainerCorpseData DeserializeLength(BufferStream stream, int length, ContainerCorpseData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lockOwnerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.codeLock == null)
				{
					instance.codeLock = CodeLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					CodeLock.DeserializeLengthDelimited(stream, instance.codeLock, isDelta);
				}
				break;
			case 26:
				if (instance.keyLock == null)
				{
					instance.keyLock = KeyLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					KeyLock.DeserializeLengthDelimited(stream, instance.keyLock, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ContainerCorpseData instance, ContainerCorpseData previous)
	{
		if (instance.lockOwnerId != previous.lockOwnerId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lockOwnerId);
		}
		if (instance.codeLock != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CodeLock.SerializeDelta(stream, instance.codeLock, previous.codeLock);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.keyLock != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			KeyLock.SerializeDelta(stream, instance.keyLock, previous.keyLock);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyLock (ProtoBuf.KeyLock)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, ContainerCorpseData instance)
	{
		if (instance.lockOwnerId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lockOwnerId);
		}
		if (instance.codeLock != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CodeLock.Serialize(stream, instance.codeLock);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.keyLock != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			KeyLock.Serialize(stream, instance.keyLock);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyLock (ProtoBuf.KeyLock)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		codeLock?.InspectUids(action);
		keyLock?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class VineMountable : IDisposable, IPooled, IProto<VineMountable>, IProto
{
	[NonSerialized]
	public Vector3 anchorPoint;

	[NonSerialized]
	public VineDestination originPoint;

	[NonSerialized]
	public List<VineDestination> destinations;

	[NonSerialized]
	public VineDestination currentLocation;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VineMountable instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.anchorPoint = default(Vector3);
		if (instance.originPoint != null)
		{
			instance.originPoint.ResetToPool();
			instance.originPoint = null;
		}
		if (instance.destinations != null)
		{
			for (int i = 0; i < instance.destinations.Count; i++)
			{
				if (instance.destinations[i] != null)
				{
					instance.destinations[i].ResetToPool();
					instance.destinations[i] = null;
				}
			}
			List<VineDestination> list = instance.destinations;
			Pool.Free<VineDestination>(ref list, false);
			instance.destinations = list;
		}
		if (instance.currentLocation != null)
		{
			instance.currentLocation.ResetToPool();
			instance.currentLocation = null;
		}
		Pool.Free<VineMountable>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VineMountable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VineMountable instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.anchorPoint = anchorPoint;
		if (originPoint != null)
		{
			if (instance.originPoint == null)
			{
				instance.originPoint = originPoint.Copy();
			}
			else
			{
				originPoint.CopyTo(instance.originPoint);
			}
		}
		else
		{
			instance.originPoint = null;
		}
		if (destinations != null)
		{
			instance.destinations = Pool.Get<List<VineDestination>>();
			for (int i = 0; i < destinations.Count; i++)
			{
				VineDestination item = destinations[i].Copy();
				instance.destinations.Add(item);
			}
		}
		else
		{
			instance.destinations = null;
		}
		if (currentLocation != null)
		{
			if (instance.currentLocation == null)
			{
				instance.currentLocation = currentLocation.Copy();
			}
			else
			{
				currentLocation.CopyTo(instance.currentLocation);
			}
		}
		else
		{
			instance.currentLocation = null;
		}
	}

	public VineMountable Copy()
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		CopyTo(vineMountable);
		return vineMountable;
	}

	public static VineMountable Deserialize(BufferStream stream)
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		Deserialize(stream, vineMountable, isDelta: false);
		return vineMountable;
	}

	public static VineMountable DeserializeLengthDelimited(BufferStream stream)
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		DeserializeLengthDelimited(stream, vineMountable, isDelta: false);
		return vineMountable;
	}

	public static VineMountable DeserializeLength(BufferStream stream, int length)
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		DeserializeLength(stream, length, vineMountable, isDelta: false);
		return vineMountable;
	}

	public static VineMountable Deserialize(byte[] buffer)
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vineMountable, isDelta: false);
		return vineMountable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VineMountable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VineMountable Deserialize(BufferStream stream, VineMountable instance, bool isDelta)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.destinations == null)
		{
			instance.destinations = Pool.Get<List<VineDestination>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.anchorPoint, isDelta);
				break;
			case 18:
				if (instance.originPoint == null)
				{
					instance.originPoint = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.originPoint, isDelta);
				}
				break;
			case 26:
				instance.destinations.Add(VineDestination.DeserializeLengthDelimited(stream));
				break;
			case 34:
				if (instance.currentLocation == null)
				{
					instance.currentLocation = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.currentLocation, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static VineMountable DeserializeLengthDelimited(BufferStream stream, VineMountable instance, bool isDelta)
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.destinations == null)
		{
			instance.destinations = Pool.Get<List<VineDestination>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.anchorPoint, isDelta);
				break;
			case 18:
				if (instance.originPoint == null)
				{
					instance.originPoint = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.originPoint, isDelta);
				}
				break;
			case 26:
				instance.destinations.Add(VineDestination.DeserializeLengthDelimited(stream));
				break;
			case 34:
				if (instance.currentLocation == null)
				{
					instance.currentLocation = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.currentLocation, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VineMountable DeserializeLength(BufferStream stream, int length, VineMountable instance, bool isDelta)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.destinations == null)
		{
			instance.destinations = Pool.Get<List<VineDestination>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.anchorPoint, isDelta);
				break;
			case 18:
				if (instance.originPoint == null)
				{
					instance.originPoint = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.originPoint, isDelta);
				}
				break;
			case 26:
				instance.destinations.Add(VineDestination.DeserializeLengthDelimited(stream));
				break;
			case 34:
				if (instance.currentLocation == null)
				{
					instance.currentLocation = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.currentLocation, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VineMountable instance, VineMountable previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.anchorPoint != previous.anchorPoint)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.anchorPoint, previous.anchorPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field anchorPoint (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.originPoint != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			VineDestination.SerializeDelta(stream, instance.originPoint, previous.originPoint);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPoint (ProtoBuf.VineDestination)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.destinations != null)
		{
			for (int i = 0; i < instance.destinations.Count; i++)
			{
				VineDestination vineDestination = instance.destinations[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				VineDestination.SerializeDelta(stream, vineDestination, vineDestination);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destinations (ProtoBuf.VineDestination)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.currentLocation != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			VineDestination.SerializeDelta(stream, instance.currentLocation, previous.currentLocation);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field currentLocation (ProtoBuf.VineDestination)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
	}

	public static void Serialize(BufferStream stream, VineMountable instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.anchorPoint != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.anchorPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field anchorPoint (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.originPoint != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			VineDestination.Serialize(stream, instance.originPoint);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPoint (ProtoBuf.VineDestination)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.destinations != null)
		{
			for (int i = 0; i < instance.destinations.Count; i++)
			{
				VineDestination instance2 = instance.destinations[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				VineDestination.Serialize(stream, instance2);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destinations (ProtoBuf.VineDestination)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.currentLocation != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			VineDestination.Serialize(stream, instance.currentLocation);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field currentLocation (ProtoBuf.VineDestination)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		originPoint?.InspectUids(action);
		if (destinations != null)
		{
			for (int i = 0; i < destinations.Count; i++)
			{
				destinations[i]?.InspectUids(action);
			}
		}
		currentLocation?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TreeRespawn : IDisposable, IPooled, IProto<TreeRespawn>, IProto
{
	[NonSerialized]
	public float timeToRespawn;

	[NonSerialized]
	public int treeIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TreeRespawn instance)
	{
		if (instance.ShouldPool)
		{
			instance.timeToRespawn = 0f;
			instance.treeIndex = 0;
			Pool.Free<TreeRespawn>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TreeRespawn with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TreeRespawn instance)
	{
		instance.timeToRespawn = timeToRespawn;
		instance.treeIndex = treeIndex;
	}

	public TreeRespawn Copy()
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		CopyTo(treeRespawn);
		return treeRespawn;
	}

	public static TreeRespawn Deserialize(BufferStream stream)
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		Deserialize(stream, treeRespawn, isDelta: false);
		return treeRespawn;
	}

	public static TreeRespawn DeserializeLengthDelimited(BufferStream stream)
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		DeserializeLengthDelimited(stream, treeRespawn, isDelta: false);
		return treeRespawn;
	}

	public static TreeRespawn DeserializeLength(BufferStream stream, int length)
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		DeserializeLength(stream, length, treeRespawn, isDelta: false);
		return treeRespawn;
	}

	public static TreeRespawn Deserialize(byte[] buffer)
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, treeRespawn, isDelta: false);
		return treeRespawn;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TreeRespawn previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TreeRespawn Deserialize(BufferStream stream, TreeRespawn instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.timeToRespawn = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.treeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TreeRespawn DeserializeLengthDelimited(BufferStream stream, TreeRespawn instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.timeToRespawn = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.treeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TreeRespawn DeserializeLength(BufferStream stream, int length, TreeRespawn instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.timeToRespawn = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.treeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TreeRespawn instance, TreeRespawn previous)
	{
		if (instance.timeToRespawn != previous.timeToRespawn)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.timeToRespawn);
		}
		if (instance.treeIndex != previous.treeIndex)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.treeIndex);
		}
	}

	public static void Serialize(BufferStream stream, TreeRespawn instance)
	{
		if (instance.timeToRespawn != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.timeToRespawn);
		}
		if (instance.treeIndex != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.treeIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VineTree : IDisposable, IPooled, IProto<VineTree>, IProto
{
	[NonSerialized]
	public List<NetworkableId> spawnedVines;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VineTree instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.spawnedVines != null)
			{
				List<NetworkableId> list = instance.spawnedVines;
				Pool.FreeUnmanaged<NetworkableId>(ref list);
				instance.spawnedVines = list;
			}
			Pool.Free<VineTree>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VineTree with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VineTree instance)
	{
		if (spawnedVines != null)
		{
			instance.spawnedVines = Pool.Get<List<NetworkableId>>();
			for (int i = 0; i < spawnedVines.Count; i++)
			{
				NetworkableId item = spawnedVines[i];
				instance.spawnedVines.Add(item);
			}
		}
		else
		{
			instance.spawnedVines = null;
		}
	}

	public VineTree Copy()
	{
		VineTree vineTree = Pool.Get<VineTree>();
		CopyTo(vineTree);
		return vineTree;
	}

	public static VineTree Deserialize(BufferStream stream)
	{
		VineTree vineTree = Pool.Get<VineTree>();
		Deserialize(stream, vineTree, isDelta: false);
		return vineTree;
	}

	public static VineTree DeserializeLengthDelimited(BufferStream stream)
	{
		VineTree vineTree = Pool.Get<VineTree>();
		DeserializeLengthDelimited(stream, vineTree, isDelta: false);
		return vineTree;
	}

	public static VineTree DeserializeLength(BufferStream stream, int length)
	{
		VineTree vineTree = Pool.Get<VineTree>();
		DeserializeLength(stream, length, vineTree, isDelta: false);
		return vineTree;
	}

	public static VineTree Deserialize(byte[] buffer)
	{
		VineTree vineTree = Pool.Get<VineTree>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vineTree, isDelta: false);
		return vineTree;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VineTree previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VineTree Deserialize(BufferStream stream, VineTree instance, bool isDelta)
	{
		if (!isDelta && instance.spawnedVines == null)
		{
			instance.spawnedVines = Pool.Get<List<NetworkableId>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.spawnedVines.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VineTree DeserializeLengthDelimited(BufferStream stream, VineTree instance, bool isDelta)
	{
		if (!isDelta && instance.spawnedVines == null)
		{
			instance.spawnedVines = Pool.Get<List<NetworkableId>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.spawnedVines.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VineTree DeserializeLength(BufferStream stream, int length, VineTree instance, bool isDelta)
	{
		if (!isDelta && instance.spawnedVines == null)
		{
			instance.spawnedVines = Pool.Get<List<NetworkableId>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.spawnedVines.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VineTree instance, VineTree previous)
	{
		if (instance.spawnedVines != null)
		{
			for (int i = 0; i < instance.spawnedVines.Count; i++)
			{
				NetworkableId networkableId = instance.spawnedVines[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public static void Serialize(BufferStream stream, VineTree instance)
	{
		if (instance.spawnedVines != null)
		{
			for (int i = 0; i < instance.spawnedVines.Count; i++)
			{
				NetworkableId networkableId = instance.spawnedVines[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < spawnedVines.Count; i++)
		{
			NetworkableId value = spawnedVines[i];
			action(UidType.NetworkableId, ref value.Value);
			spawnedVines[i] = value;
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VineDestination : IDisposable, IPooled, IProto<VineDestination>, IProto
{
	[NonSerialized]
	public NetworkableId targetTree;

	[NonSerialized]
	public int index;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VineDestination instance)
	{
		if (instance.ShouldPool)
		{
			instance.targetTree = default(NetworkableId);
			instance.index = 0;
			Pool.Free<VineDestination>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VineDestination with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VineDestination instance)
	{
		instance.targetTree = targetTree;
		instance.index = index;
	}

	public VineDestination Copy()
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		CopyTo(vineDestination);
		return vineDestination;
	}

	public static VineDestination Deserialize(BufferStream stream)
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		Deserialize(stream, vineDestination, isDelta: false);
		return vineDestination;
	}

	public static VineDestination DeserializeLengthDelimited(BufferStream stream)
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		DeserializeLengthDelimited(stream, vineDestination, isDelta: false);
		return vineDestination;
	}

	public static VineDestination DeserializeLength(BufferStream stream, int length)
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		DeserializeLength(stream, length, vineDestination, isDelta: false);
		return vineDestination;
	}

	public static VineDestination Deserialize(byte[] buffer)
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vineDestination, isDelta: false);
		return vineDestination;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VineDestination previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VineDestination Deserialize(BufferStream stream, VineDestination instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetTree = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VineDestination DeserializeLengthDelimited(BufferStream stream, VineDestination instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetTree = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VineDestination DeserializeLength(BufferStream stream, int length, VineDestination instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetTree = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VineDestination instance, VineDestination previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetTree.Value);
		if (instance.index != previous.index)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
	}

	public static void Serialize(BufferStream stream, VineDestination instance)
	{
		if (instance.targetTree != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetTree.Value);
		}
		if (instance.index != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetTree.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class StaticRespawnAreaData : IDisposable, IPooled, IProto<StaticRespawnAreaData>, IProto
{
	[NonSerialized]
	public List<ulong> authorizedUsers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(StaticRespawnAreaData instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.authorizedUsers != null)
			{
				List<ulong> list = instance.authorizedUsers;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.authorizedUsers = list;
			}
			Pool.Free<StaticRespawnAreaData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose StaticRespawnAreaData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(StaticRespawnAreaData instance)
	{
		if (authorizedUsers != null)
		{
			instance.authorizedUsers = Pool.Get<List<ulong>>();
			for (int i = 0; i < authorizedUsers.Count; i++)
			{
				ulong item = authorizedUsers[i];
				instance.authorizedUsers.Add(item);
			}
		}
		else
		{
			instance.authorizedUsers = null;
		}
	}

	public StaticRespawnAreaData Copy()
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		CopyTo(staticRespawnAreaData);
		return staticRespawnAreaData;
	}

	public static StaticRespawnAreaData Deserialize(BufferStream stream)
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		Deserialize(stream, staticRespawnAreaData, isDelta: false);
		return staticRespawnAreaData;
	}

	public static StaticRespawnAreaData DeserializeLengthDelimited(BufferStream stream)
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		DeserializeLengthDelimited(stream, staticRespawnAreaData, isDelta: false);
		return staticRespawnAreaData;
	}

	public static StaticRespawnAreaData DeserializeLength(BufferStream stream, int length)
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		DeserializeLength(stream, length, staticRespawnAreaData, isDelta: false);
		return staticRespawnAreaData;
	}

	public static StaticRespawnAreaData Deserialize(byte[] buffer)
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, staticRespawnAreaData, isDelta: false);
		return staticRespawnAreaData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, StaticRespawnAreaData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static StaticRespawnAreaData Deserialize(BufferStream stream, StaticRespawnAreaData instance, bool isDelta)
	{
		if (!isDelta && instance.authorizedUsers == null)
		{
			instance.authorizedUsers = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.authorizedUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static StaticRespawnAreaData DeserializeLengthDelimited(BufferStream stream, StaticRespawnAreaData instance, bool isDelta)
	{
		if (!isDelta && instance.authorizedUsers == null)
		{
			instance.authorizedUsers = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.authorizedUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static StaticRespawnAreaData DeserializeLength(BufferStream stream, int length, StaticRespawnAreaData instance, bool isDelta)
	{
		if (!isDelta && instance.authorizedUsers == null)
		{
			instance.authorizedUsers = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.authorizedUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, StaticRespawnAreaData instance, StaticRespawnAreaData previous)
	{
		if (instance.authorizedUsers != null)
		{
			for (int i = 0; i < instance.authorizedUsers.Count; i++)
			{
				ulong val = instance.authorizedUsers[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, StaticRespawnAreaData instance)
	{
		if (instance.authorizedUsers != null)
		{
			for (int i = 0; i < instance.authorizedUsers.Count; i++)
			{
				ulong val = instance.authorizedUsers[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ItemContainer : IDisposable, IPooled, IProto<ItemContainer>, IProto
{
	[NonSerialized]
	public ItemContainerId UID;

	[NonSerialized]
	public int slots;

	[NonSerialized]
	public float temperature;

	[NonSerialized]
	public int flags;

	[NonSerialized]
	public int allowedContents;

	[NonSerialized]
	public int maxStackSize;

	[NonSerialized]
	public List<int> allowedItems;

	[NonSerialized]
	public List<int> availableSlots;

	[NonSerialized]
	public int volume;

	[NonSerialized]
	public List<Item> contents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemContainer instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.UID = default(ItemContainerId);
		instance.slots = 0;
		instance.temperature = 0f;
		instance.flags = 0;
		instance.allowedContents = 0;
		instance.maxStackSize = 0;
		if (instance.allowedItems != null)
		{
			List<int> list = instance.allowedItems;
			Pool.FreeUnmanaged<int>(ref list);
			instance.allowedItems = list;
		}
		if (instance.availableSlots != null)
		{
			List<int> list2 = instance.availableSlots;
			Pool.FreeUnmanaged<int>(ref list2);
			instance.availableSlots = list2;
		}
		instance.volume = 0;
		if (instance.contents != null)
		{
			for (int i = 0; i < instance.contents.Count; i++)
			{
				if (instance.contents[i] != null)
				{
					instance.contents[i].ResetToPool();
					instance.contents[i] = null;
				}
			}
			List<Item> list3 = instance.contents;
			Pool.Free<Item>(ref list3, false);
			instance.contents = list3;
		}
		Pool.Free<ItemContainer>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemContainer instance)
	{
		instance.UID = UID;
		instance.slots = slots;
		instance.temperature = temperature;
		instance.flags = flags;
		instance.allowedContents = allowedContents;
		instance.maxStackSize = maxStackSize;
		if (allowedItems != null)
		{
			instance.allowedItems = Pool.Get<List<int>>();
			for (int i = 0; i < allowedItems.Count; i++)
			{
				int item = allowedItems[i];
				instance.allowedItems.Add(item);
			}
		}
		else
		{
			instance.allowedItems = null;
		}
		if (availableSlots != null)
		{
			instance.availableSlots = Pool.Get<List<int>>();
			for (int j = 0; j < availableSlots.Count; j++)
			{
				int item2 = availableSlots[j];
				instance.availableSlots.Add(item2);
			}
		}
		else
		{
			instance.availableSlots = null;
		}
		instance.volume = volume;
		if (contents != null)
		{
			instance.contents = Pool.Get<List<Item>>();
			for (int k = 0; k < contents.Count; k++)
			{
				Item item3 = contents[k].Copy();
				instance.contents.Add(item3);
			}
		}
		else
		{
			instance.contents = null;
		}
	}

	public ItemContainer Copy()
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		CopyTo(itemContainer);
		return itemContainer;
	}

	public static ItemContainer Deserialize(BufferStream stream)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		Deserialize(stream, itemContainer, isDelta: false);
		return itemContainer;
	}

	public static ItemContainer DeserializeLengthDelimited(BufferStream stream)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		DeserializeLengthDelimited(stream, itemContainer, isDelta: false);
		return itemContainer;
	}

	public static ItemContainer DeserializeLength(BufferStream stream, int length)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		DeserializeLength(stream, length, itemContainer, isDelta: false);
		return itemContainer;
	}

	public static ItemContainer Deserialize(byte[] buffer)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemContainer, isDelta: false);
		return itemContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemContainer Deserialize(BufferStream stream, ItemContainer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.allowedItems == null)
			{
				instance.allowedItems = Pool.Get<List<int>>();
			}
			if (instance.availableSlots == null)
			{
				instance.availableSlots = Pool.Get<List<int>>();
			}
			if (instance.contents == null)
			{
				instance.contents = Pool.Get<List<Item>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.UID = new ItemContainerId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.slots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.allowedContents = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.maxStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.allowedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.availableSlots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 72:
				instance.volume = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.contents.Add(Item.DeserializeLengthDelimited(stream));
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static ItemContainer DeserializeLengthDelimited(BufferStream stream, ItemContainer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.allowedItems == null)
			{
				instance.allowedItems = Pool.Get<List<int>>();
			}
			if (instance.availableSlots == null)
			{
				instance.availableSlots = Pool.Get<List<int>>();
			}
			if (instance.contents == null)
			{
				instance.contents = Pool.Get<List<Item>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.UID = new ItemContainerId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.slots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.allowedContents = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.maxStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.allowedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.availableSlots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 72:
				instance.volume = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.contents.Add(Item.DeserializeLengthDelimited(stream));
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemContainer DeserializeLength(BufferStream stream, int length, ItemContainer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.allowedItems == null)
			{
				instance.allowedItems = Pool.Get<List<int>>();
			}
			if (instance.availableSlots == null)
			{
				instance.availableSlots = Pool.Get<List<int>>();
			}
			if (instance.contents == null)
			{
				instance.contents = Pool.Get<List<Item>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.UID = new ItemContainerId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.slots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.allowedContents = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.maxStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.allowedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.availableSlots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 72:
				instance.volume = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.contents.Add(Item.DeserializeLengthDelimited(stream));
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemContainer instance, ItemContainer previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.UID.Value);
		if (instance.slots != previous.slots)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slots);
		}
		if (instance.temperature != previous.temperature)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.flags != previous.flags)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.allowedContents != previous.allowedContents)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.allowedContents);
		}
		if (instance.maxStackSize != previous.maxStackSize)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxStackSize);
		}
		if (instance.allowedItems != null)
		{
			for (int i = 0; i < instance.allowedItems.Count; i++)
			{
				int num = instance.allowedItems[i];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.availableSlots != null)
		{
			for (int j = 0; j < instance.availableSlots.Count; j++)
			{
				int num2 = instance.availableSlots[j];
				stream.WriteByte(64);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
		if (instance.volume != previous.volume)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.volume);
		}
		if (instance.contents == null)
		{
			return;
		}
		for (int k = 0; k < instance.contents.Count; k++)
		{
			Item item = instance.contents[k];
			stream.WriteByte(162);
			stream.WriteByte(6);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Item.SerializeDelta(stream, item, item);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num3 < 5)
			{
				span[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span[num3++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ItemContainer instance)
	{
		if (instance.UID != default(ItemContainerId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.UID.Value);
		}
		if (instance.slots != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slots);
		}
		if (instance.temperature != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.flags != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.allowedContents != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.allowedContents);
		}
		if (instance.maxStackSize != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxStackSize);
		}
		if (instance.allowedItems != null)
		{
			for (int i = 0; i < instance.allowedItems.Count; i++)
			{
				int num = instance.allowedItems[i];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.availableSlots != null)
		{
			for (int j = 0; j < instance.availableSlots.Count; j++)
			{
				int num2 = instance.availableSlots[j];
				stream.WriteByte(64);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
		if (instance.volume != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.volume);
		}
		if (instance.contents == null)
		{
			return;
		}
		for (int k = 0; k < instance.contents.Count; k++)
		{
			Item instance2 = instance.contents[k];
			stream.WriteByte(162);
			stream.WriteByte(6);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Item.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num3 < 5)
			{
				span[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span[num3++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.ItemContainerId, ref UID.Value);
		if (contents != null)
		{
			for (int i = 0; i < contents.Count; i++)
			{
				contents[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Item : IDisposable, IPooled, IProto<Item>, IProto
{
	public class InstanceData : IDisposable, IPooled, IProto<InstanceData>, IProto
	{
		[NonSerialized]
		public int dataInt;

		[NonSerialized]
		public int blueprintTarget;

		[NonSerialized]
		public int blueprintAmount;

		[NonSerialized]
		public NetworkableId subEntity;

		[NonSerialized]
		public float dataFloat;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(InstanceData instance)
		{
			if (instance.ShouldPool)
			{
				instance.dataInt = 0;
				instance.blueprintTarget = 0;
				instance.blueprintAmount = 0;
				instance.subEntity = default(NetworkableId);
				instance.dataFloat = 0f;
				Pool.Free<InstanceData>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose InstanceData with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(InstanceData instance)
		{
			instance.dataInt = dataInt;
			instance.blueprintTarget = blueprintTarget;
			instance.blueprintAmount = blueprintAmount;
			instance.subEntity = subEntity;
			instance.dataFloat = dataFloat;
		}

		public InstanceData Copy()
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			CopyTo(instanceData);
			return instanceData;
		}

		public static InstanceData Deserialize(BufferStream stream)
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			Deserialize(stream, instanceData, isDelta: false);
			return instanceData;
		}

		public static InstanceData DeserializeLengthDelimited(BufferStream stream)
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			DeserializeLengthDelimited(stream, instanceData, isDelta: false);
			return instanceData;
		}

		public static InstanceData DeserializeLength(BufferStream stream, int length)
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			DeserializeLength(stream, length, instanceData, isDelta: false);
			return instanceData;
		}

		public static InstanceData Deserialize(byte[] buffer)
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, instanceData, isDelta: false);
			return instanceData;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, InstanceData previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static InstanceData Deserialize(BufferStream stream, InstanceData instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 45:
					instance.dataFloat = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static InstanceData DeserializeLengthDelimited(BufferStream stream, InstanceData instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 45:
					instance.dataFloat = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static InstanceData DeserializeLength(BufferStream stream, int length, InstanceData instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 45:
					instance.dataFloat = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, InstanceData instance, InstanceData previous)
		{
			if (instance.dataInt != previous.dataInt)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.dataInt);
			}
			if (instance.blueprintTarget != previous.blueprintTarget)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintTarget);
			}
			if (instance.blueprintAmount != previous.blueprintAmount)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintAmount);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.subEntity.Value);
			if (instance.dataFloat != previous.dataFloat)
			{
				stream.WriteByte(45);
				ProtocolParser.WriteSingle(stream, instance.dataFloat);
			}
		}

		public static void Serialize(BufferStream stream, InstanceData instance)
		{
			if (instance.dataInt != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.dataInt);
			}
			if (instance.blueprintTarget != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintTarget);
			}
			if (instance.blueprintAmount != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintAmount);
			}
			if (instance.subEntity != default(NetworkableId))
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, instance.subEntity.Value);
			}
			if (instance.dataFloat != 0f)
			{
				stream.WriteByte(45);
				ProtocolParser.WriteSingle(stream, instance.dataFloat);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref subEntity.Value);
		}
	}

	public class ConditionData : IDisposable, IPooled, IProto<ConditionData>, IProto
	{
		[NonSerialized]
		public float condition;

		[NonSerialized]
		public float maxCondition;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ConditionData instance)
		{
			if (instance.ShouldPool)
			{
				instance.condition = 0f;
				instance.maxCondition = 0f;
				Pool.Free<ConditionData>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ConditionData with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ConditionData instance)
		{
			instance.condition = condition;
			instance.maxCondition = maxCondition;
		}

		public ConditionData Copy()
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			CopyTo(conditionData);
			return conditionData;
		}

		public static ConditionData Deserialize(BufferStream stream)
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			Deserialize(stream, conditionData, isDelta: false);
			return conditionData;
		}

		public static ConditionData DeserializeLengthDelimited(BufferStream stream)
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			DeserializeLengthDelimited(stream, conditionData, isDelta: false);
			return conditionData;
		}

		public static ConditionData DeserializeLength(BufferStream stream, int length)
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			DeserializeLength(stream, length, conditionData, isDelta: false);
			return conditionData;
		}

		public static ConditionData Deserialize(byte[] buffer)
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, conditionData, isDelta: false);
			return conditionData;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ConditionData previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ConditionData Deserialize(BufferStream stream, ConditionData instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 13:
					instance.condition = ProtocolParser.ReadSingle(stream);
					continue;
				case 21:
					instance.maxCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ConditionData DeserializeLengthDelimited(BufferStream stream, ConditionData instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 13:
					instance.condition = ProtocolParser.ReadSingle(stream);
					continue;
				case 21:
					instance.maxCondition = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ConditionData DeserializeLength(BufferStream stream, int length, ConditionData instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 13:
					instance.condition = ProtocolParser.ReadSingle(stream);
					continue;
				case 21:
					instance.maxCondition = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ConditionData instance, ConditionData previous)
		{
			if (instance.condition != previous.condition)
			{
				stream.WriteByte(13);
				ProtocolParser.WriteSingle(stream, instance.condition);
			}
			if (instance.maxCondition != previous.maxCondition)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.maxCondition);
			}
		}

		public static void Serialize(BufferStream stream, ConditionData instance)
		{
			if (instance.condition != 0f)
			{
				stream.WriteByte(13);
				ProtocolParser.WriteSingle(stream, instance.condition);
			}
			if (instance.maxCondition != 0f)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.maxCondition);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public ItemId UID;

	[NonSerialized]
	public int itemid;

	[NonSerialized]
	public int slot;

	[NonSerialized]
	public int amount;

	[NonSerialized]
	public int flags;

	[NonSerialized]
	public float removetime;

	[NonSerialized]
	public float locktime;

	[NonSerialized]
	public NetworkableId worldEntity;

	[NonSerialized]
	public InstanceData instanceData;

	[NonSerialized]
	public NetworkableId heldEntity;

	[NonSerialized]
	public ConditionData conditionData;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public string text;

	[NonSerialized]
	public ulong skinid;

	[NonSerialized]
	public float cooktime;

	[NonSerialized]
	public string streamerName;

	[NonSerialized]
	public int ammoCount;

	[NonSerialized]
	public List<ItemOwnershipAmount> ownership;

	[NonSerialized]
	public ItemContainer contents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Item instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.UID = default(ItemId);
		instance.itemid = 0;
		instance.slot = 0;
		instance.amount = 0;
		instance.flags = 0;
		instance.removetime = 0f;
		instance.locktime = 0f;
		instance.worldEntity = default(NetworkableId);
		if (instance.instanceData != null)
		{
			instance.instanceData.ResetToPool();
			instance.instanceData = null;
		}
		instance.heldEntity = default(NetworkableId);
		if (instance.conditionData != null)
		{
			instance.conditionData.ResetToPool();
			instance.conditionData = null;
		}
		instance.name = string.Empty;
		instance.text = string.Empty;
		instance.skinid = 0uL;
		instance.cooktime = 0f;
		instance.streamerName = string.Empty;
		instance.ammoCount = 0;
		if (instance.ownership != null)
		{
			for (int i = 0; i < instance.ownership.Count; i++)
			{
				if (instance.ownership[i] != null)
				{
					instance.ownership[i].ResetToPool();
					instance.ownership[i] = null;
				}
			}
			List<ItemOwnershipAmount> list = instance.ownership;
			Pool.Free<ItemOwnershipAmount>(ref list, false);
			instance.ownership = list;
		}
		if (instance.contents != null)
		{
			instance.contents.ResetToPool();
			instance.contents = null;
		}
		Pool.Free<Item>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Item with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Item instance)
	{
		instance.UID = UID;
		instance.itemid = itemid;
		instance.slot = slot;
		instance.amount = amount;
		instance.flags = flags;
		instance.removetime = removetime;
		instance.locktime = locktime;
		instance.worldEntity = worldEntity;
		if (instanceData != null)
		{
			if (instance.instanceData == null)
			{
				instance.instanceData = instanceData.Copy();
			}
			else
			{
				instanceData.CopyTo(instance.instanceData);
			}
		}
		else
		{
			instance.instanceData = null;
		}
		instance.heldEntity = heldEntity;
		if (conditionData != null)
		{
			if (instance.conditionData == null)
			{
				instance.conditionData = conditionData.Copy();
			}
			else
			{
				conditionData.CopyTo(instance.conditionData);
			}
		}
		else
		{
			instance.conditionData = null;
		}
		instance.name = name;
		instance.text = text;
		instance.skinid = skinid;
		instance.cooktime = cooktime;
		instance.streamerName = streamerName;
		instance.ammoCount = ammoCount;
		if (ownership != null)
		{
			instance.ownership = Pool.Get<List<ItemOwnershipAmount>>();
			for (int i = 0; i < ownership.Count; i++)
			{
				ItemOwnershipAmount item = ownership[i].Copy();
				instance.ownership.Add(item);
			}
		}
		else
		{
			instance.ownership = null;
		}
		if (contents != null)
		{
			if (instance.contents == null)
			{
				instance.contents = contents.Copy();
			}
			else
			{
				contents.CopyTo(instance.contents);
			}
		}
		else
		{
			instance.contents = null;
		}
	}

	public Item Copy()
	{
		Item item = Pool.Get<Item>();
		CopyTo(item);
		return item;
	}

	public static Item Deserialize(BufferStream stream)
	{
		Item item = Pool.Get<Item>();
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLengthDelimited(BufferStream stream)
	{
		Item item = Pool.Get<Item>();
		DeserializeLengthDelimited(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLength(BufferStream stream, int length)
	{
		Item item = Pool.Get<Item>();
		DeserializeLength(stream, length, item, isDelta: false);
		return item;
	}

	public static Item Deserialize(byte[] buffer)
	{
		Item item = Pool.Get<Item>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Item previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Item Deserialize(BufferStream stream, Item instance, bool isDelta)
	{
		if (!isDelta && instance.ownership == null)
		{
			instance.ownership = Pool.Get<List<ItemOwnershipAmount>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.UID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.itemid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.removetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.locktime = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.worldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 74:
				if (instance.instanceData == null)
				{
					instance.instanceData = InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				continue;
			case 80:
				instance.heldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 90:
				if (instance.conditionData == null)
				{
					instance.conditionData = ConditionData.DeserializeLengthDelimited(stream);
				}
				else
				{
					ConditionData.DeserializeLengthDelimited(stream, instance.conditionData, isDelta);
				}
				continue;
			case 114:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 122:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.skinid = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.cooktime = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.streamerName = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.ownership.Add(ItemOwnershipAmount.DeserializeLengthDelimited(stream));
				}
				break;
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.contents == null)
					{
						instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static Item DeserializeLengthDelimited(BufferStream stream, Item instance, bool isDelta)
	{
		if (!isDelta && instance.ownership == null)
		{
			instance.ownership = Pool.Get<List<ItemOwnershipAmount>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.UID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.itemid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.removetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.locktime = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.worldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 74:
				if (instance.instanceData == null)
				{
					instance.instanceData = InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				continue;
			case 80:
				instance.heldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 90:
				if (instance.conditionData == null)
				{
					instance.conditionData = ConditionData.DeserializeLengthDelimited(stream);
				}
				else
				{
					ConditionData.DeserializeLengthDelimited(stream, instance.conditionData, isDelta);
				}
				continue;
			case 114:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 122:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.skinid = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.cooktime = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.streamerName = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.ownership.Add(ItemOwnershipAmount.DeserializeLengthDelimited(stream));
				}
				break;
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.contents == null)
					{
						instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Item DeserializeLength(BufferStream stream, int length, Item instance, bool isDelta)
	{
		if (!isDelta && instance.ownership == null)
		{
			instance.ownership = Pool.Get<List<ItemOwnershipAmount>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.UID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.itemid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.removetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.locktime = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.worldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 74:
				if (instance.instanceData == null)
				{
					instance.instanceData = InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				continue;
			case 80:
				instance.heldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 90:
				if (instance.conditionData == null)
				{
					instance.conditionData = ConditionData.DeserializeLengthDelimited(stream);
				}
				else
				{
					ConditionData.DeserializeLengthDelimited(stream, instance.conditionData, isDelta);
				}
				continue;
			case 114:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 122:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.skinid = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.cooktime = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.streamerName = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.ownership.Add(ItemOwnershipAmount.DeserializeLengthDelimited(stream));
				}
				break;
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.contents == null)
					{
						instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Item instance, Item previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.UID.Value);
		if (instance.itemid != previous.itemid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemid);
		}
		if (instance.slot != previous.slot)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slot);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.flags != previous.flags)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.removetime != previous.removetime)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.removetime);
		}
		if (instance.locktime != previous.locktime)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.locktime);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.worldEntity.Value);
		if (instance.instanceData != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			InstanceData.SerializeDelta(stream, instance.instanceData, previous.instanceData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteUInt64(stream, instance.heldEntity.Value);
		if (instance.conditionData != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			ConditionData.SerializeDelta(stream, instance.conditionData, previous.conditionData);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field conditionData (ProtoBuf.Item.ConditionData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(114);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.text != null && instance.text != previous.text)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.text);
		}
		if (instance.skinid != previous.skinid)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.skinid);
		}
		if (instance.cooktime != previous.cooktime)
		{
			stream.WriteByte(141);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.cooktime);
		}
		if (instance.streamerName != null && instance.streamerName != previous.streamerName)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
		if (instance.ammoCount != previous.ammoCount)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
		}
		if (instance.ownership != null)
		{
			for (int i = 0; i < instance.ownership.Count; i++)
			{
				ItemOwnershipAmount itemOwnershipAmount = instance.ownership[i];
				stream.WriteByte(162);
				stream.WriteByte(1);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				ItemOwnershipAmount.SerializeDelta(stream, itemOwnershipAmount, itemOwnershipAmount);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.contents == null)
		{
			return;
		}
		stream.WriteByte(162);
		stream.WriteByte(6);
		BufferStream.RangeHandle range4 = stream.GetRange(5);
		int position4 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.contents, previous.contents);
		int val2 = stream.Position - position4;
		Span<byte> span4 = range4.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
		if (num4 < 5)
		{
			span4[num4 - 1] |= 128;
			while (num4 < 4)
			{
				span4[num4++] = 128;
			}
			span4[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Item instance)
	{
		if (instance.UID != default(ItemId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.UID.Value);
		}
		if (instance.itemid != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemid);
		}
		if (instance.slot != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slot);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.flags != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.removetime != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.removetime);
		}
		if (instance.locktime != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.locktime);
		}
		if (instance.worldEntity != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.worldEntity.Value);
		}
		if (instance.instanceData != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			InstanceData.Serialize(stream, instance.instanceData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.heldEntity != default(NetworkableId))
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, instance.heldEntity.Value);
		}
		if (instance.conditionData != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			ConditionData.Serialize(stream, instance.conditionData);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field conditionData (ProtoBuf.Item.ConditionData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.name != null)
		{
			stream.WriteByte(114);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.text != null)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.text);
		}
		if (instance.skinid != 0L)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.skinid);
		}
		if (instance.cooktime != 0f)
		{
			stream.WriteByte(141);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.cooktime);
		}
		if (instance.streamerName != null)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
		if (instance.ammoCount != 0)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
		}
		if (instance.ownership != null)
		{
			for (int i = 0; i < instance.ownership.Count; i++)
			{
				ItemOwnershipAmount instance2 = instance.ownership[i];
				stream.WriteByte(162);
				stream.WriteByte(1);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				ItemOwnershipAmount.Serialize(stream, instance2);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.contents == null)
		{
			return;
		}
		stream.WriteByte(162);
		stream.WriteByte(6);
		BufferStream.RangeHandle range4 = stream.GetRange(5);
		int position4 = stream.Position;
		ItemContainer.Serialize(stream, instance.contents);
		int val2 = stream.Position - position4;
		Span<byte> span4 = range4.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
		if (num4 < 5)
		{
			span4[num4 - 1] |= 128;
			while (num4 < 4)
			{
				span4[num4++] = 128;
			}
			span4[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.ItemId, ref UID.Value);
		action(UidType.NetworkableId, ref worldEntity.Value);
		instanceData?.InspectUids(action);
		action(UidType.NetworkableId, ref heldEntity.Value);
		conditionData?.InspectUids(action);
		if (ownership != null)
		{
			for (int i = 0; i < ownership.Count; i++)
			{
				ownership[i]?.InspectUids(action);
			}
		}
		contents?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ItemOwnershipAmount : IDisposable, IPooled, IProto<ItemOwnershipAmount>, IProto
{
	[NonSerialized]
	public string username;

	[NonSerialized]
	public string reason;

	[NonSerialized]
	public int amount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemOwnershipAmount instance)
	{
		if (instance.ShouldPool)
		{
			instance.username = string.Empty;
			instance.reason = string.Empty;
			instance.amount = 0;
			Pool.Free<ItemOwnershipAmount>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemOwnershipAmount with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemOwnershipAmount instance)
	{
		instance.username = username;
		instance.reason = reason;
		instance.amount = amount;
	}

	public ItemOwnershipAmount Copy()
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		CopyTo(itemOwnershipAmount);
		return itemOwnershipAmount;
	}

	public static ItemOwnershipAmount Deserialize(BufferStream stream)
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		Deserialize(stream, itemOwnershipAmount, isDelta: false);
		return itemOwnershipAmount;
	}

	public static ItemOwnershipAmount DeserializeLengthDelimited(BufferStream stream)
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		DeserializeLengthDelimited(stream, itemOwnershipAmount, isDelta: false);
		return itemOwnershipAmount;
	}

	public static ItemOwnershipAmount DeserializeLength(BufferStream stream, int length)
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		DeserializeLength(stream, length, itemOwnershipAmount, isDelta: false);
		return itemOwnershipAmount;
	}

	public static ItemOwnershipAmount Deserialize(byte[] buffer)
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemOwnershipAmount, isDelta: false);
		return itemOwnershipAmount;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemOwnershipAmount previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemOwnershipAmount Deserialize(BufferStream stream, ItemOwnershipAmount instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 26:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 10:
				instance.reason = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemOwnershipAmount DeserializeLengthDelimited(BufferStream stream, ItemOwnershipAmount instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 26:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 10:
				instance.reason = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemOwnershipAmount DeserializeLength(BufferStream stream, int length, ItemOwnershipAmount instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 26:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 10:
				instance.reason = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemOwnershipAmount instance, ItemOwnershipAmount previous)
	{
		if (instance.username != null && instance.username != previous.username)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.username);
		}
		if (instance.reason != null && instance.reason != previous.reason)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.reason);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
	}

	public static void Serialize(BufferStream stream, ItemOwnershipAmount instance)
	{
		if (instance.username != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.username);
		}
		if (instance.reason != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.reason);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BasePlayer : IDisposable, IPooled, IProto<BasePlayer>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public ulong userid;

	[NonSerialized]
	public PlayerInventory inventory;

	[NonSerialized]
	public PlayerMetabolism metabolism;

	[NonSerialized]
	public float loadingTimeout;

	[NonSerialized]
	public ModelState modelState;

	[NonSerialized]
	public int playerFlags;

	[NonSerialized]
	public ItemId heldEntity;

	[NonSerialized]
	public float health;

	[NonSerialized]
	public PersistantPlayer persistantData;

	[NonSerialized]
	public float skinCol;

	[NonSerialized]
	public float skinTex;

	[NonSerialized]
	public float skinMesh;

	[NonSerialized]
	public PlayerLifeStory currentLife;

	[NonSerialized]
	public PlayerLifeStory previousLife;

	[NonSerialized]
	public NetworkableId mounted;

	[NonSerialized]
	public ulong currentTeam;

	[NonSerialized]
	public uint underwear;

	[NonSerialized]
	public PlayerModifiers modifiers;

	[NonSerialized]
	public int reputation;

	[NonSerialized]
	public uint loopingGesture;

	[NonSerialized]
	public Missions missions;

	[NonSerialized]
	public string respawnId;

	[NonSerialized]
	public int bagCount;

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public ItemCrafter itemCrafter;

	[NonSerialized]
	public int shelterCount;

	[NonSerialized]
	public int tutorialAllowance;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BasePlayer instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.userid = 0uL;
			if (instance.inventory != null)
			{
				instance.inventory.ResetToPool();
				instance.inventory = null;
			}
			if (instance.metabolism != null)
			{
				instance.metabolism.ResetToPool();
				instance.metabolism = null;
			}
			instance.loadingTimeout = 0f;
			if (instance.modelState != null)
			{
				instance.modelState.ResetToPool();
				instance.modelState = null;
			}
			instance.playerFlags = 0;
			instance.heldEntity = default(ItemId);
			instance.health = 0f;
			if (instance.persistantData != null)
			{
				instance.persistantData.ResetToPool();
				instance.persistantData = null;
			}
			instance.skinCol = 0f;
			instance.skinTex = 0f;
			instance.skinMesh = 0f;
			if (instance.currentLife != null)
			{
				instance.currentLife.ResetToPool();
				instance.currentLife = null;
			}
			if (instance.previousLife != null)
			{
				instance.previousLife.ResetToPool();
				instance.previousLife = null;
			}
			instance.mounted = default(NetworkableId);
			instance.currentTeam = 0uL;
			instance.underwear = 0u;
			if (instance.modifiers != null)
			{
				instance.modifiers.ResetToPool();
				instance.modifiers = null;
			}
			instance.reputation = 0;
			instance.loopingGesture = 0u;
			if (instance.missions != null)
			{
				instance.missions.ResetToPool();
				instance.missions = null;
			}
			instance.respawnId = string.Empty;
			instance.bagCount = 0;
			instance.clanId = 0L;
			if (instance.itemCrafter != null)
			{
				instance.itemCrafter.ResetToPool();
				instance.itemCrafter = null;
			}
			instance.shelterCount = 0;
			instance.tutorialAllowance = 0;
			Pool.Free<BasePlayer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BasePlayer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BasePlayer instance)
	{
		instance.name = name;
		instance.userid = userid;
		if (inventory != null)
		{
			if (instance.inventory == null)
			{
				instance.inventory = inventory.Copy();
			}
			else
			{
				inventory.CopyTo(instance.inventory);
			}
		}
		else
		{
			instance.inventory = null;
		}
		if (metabolism != null)
		{
			if (instance.metabolism == null)
			{
				instance.metabolism = metabolism.Copy();
			}
			else
			{
				metabolism.CopyTo(instance.metabolism);
			}
		}
		else
		{
			instance.metabolism = null;
		}
		instance.loadingTimeout = loadingTimeout;
		if (modelState != null)
		{
			if (instance.modelState == null)
			{
				instance.modelState = modelState.Copy();
			}
			else
			{
				modelState.CopyTo(instance.modelState);
			}
		}
		else
		{
			instance.modelState = null;
		}
		instance.playerFlags = playerFlags;
		instance.heldEntity = heldEntity;
		instance.health = health;
		if (persistantData != null)
		{
			if (instance.persistantData == null)
			{
				instance.persistantData = persistantData.Copy();
			}
			else
			{
				persistantData.CopyTo(instance.persistantData);
			}
		}
		else
		{
			instance.persistantData = null;
		}
		instance.skinCol = skinCol;
		instance.skinTex = skinTex;
		instance.skinMesh = skinMesh;
		if (currentLife != null)
		{
			if (instance.currentLife == null)
			{
				instance.currentLife = currentLife.Copy();
			}
			else
			{
				currentLife.CopyTo(instance.currentLife);
			}
		}
		else
		{
			instance.currentLife = null;
		}
		if (previousLife != null)
		{
			if (instance.previousLife == null)
			{
				instance.previousLife = previousLife.Copy();
			}
			else
			{
				previousLife.CopyTo(instance.previousLife);
			}
		}
		else
		{
			instance.previousLife = null;
		}
		instance.mounted = mounted;
		instance.currentTeam = currentTeam;
		instance.underwear = underwear;
		if (modifiers != null)
		{
			if (instance.modifiers == null)
			{
				instance.modifiers = modifiers.Copy();
			}
			else
			{
				modifiers.CopyTo(instance.modifiers);
			}
		}
		else
		{
			instance.modifiers = null;
		}
		instance.reputation = reputation;
		instance.loopingGesture = loopingGesture;
		if (missions != null)
		{
			if (instance.missions == null)
			{
				instance.missions = missions.Copy();
			}
			else
			{
				missions.CopyTo(instance.missions);
			}
		}
		else
		{
			instance.missions = null;
		}
		instance.respawnId = respawnId;
		instance.bagCount = bagCount;
		instance.clanId = clanId;
		if (itemCrafter != null)
		{
			if (instance.itemCrafter == null)
			{
				instance.itemCrafter = itemCrafter.Copy();
			}
			else
			{
				itemCrafter.CopyTo(instance.itemCrafter);
			}
		}
		else
		{
			instance.itemCrafter = null;
		}
		instance.shelterCount = shelterCount;
		instance.tutorialAllowance = tutorialAllowance;
	}

	public BasePlayer Copy()
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		CopyTo(basePlayer);
		return basePlayer;
	}

	public static BasePlayer Deserialize(BufferStream stream)
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		Deserialize(stream, basePlayer, isDelta: false);
		return basePlayer;
	}

	public static BasePlayer DeserializeLengthDelimited(BufferStream stream)
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		DeserializeLengthDelimited(stream, basePlayer, isDelta: false);
		return basePlayer;
	}

	public static BasePlayer DeserializeLength(BufferStream stream, int length)
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		DeserializeLength(stream, length, basePlayer, isDelta: false);
		return basePlayer;
	}

	public static BasePlayer Deserialize(byte[] buffer)
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, basePlayer, isDelta: false);
		return basePlayer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BasePlayer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BasePlayer Deserialize(BufferStream stream, BasePlayer instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (instance.inventory == null)
				{
					instance.inventory = PlayerInventory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerInventory.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				continue;
			case 34:
				if (instance.metabolism == null)
				{
					instance.metabolism = PlayerMetabolism.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerMetabolism.DeserializeLengthDelimited(stream, instance.metabolism, isDelta);
				}
				continue;
			case 45:
				instance.loadingTimeout = ProtocolParser.ReadSingle(stream);
				continue;
			case 50:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				continue;
			case 56:
				instance.playerFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.heldEntity = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				if (instance.persistantData == null)
				{
					instance.persistantData = PersistantPlayer.DeserializeLengthDelimited(stream);
				}
				else
				{
					PersistantPlayer.DeserializeLengthDelimited(stream, instance.persistantData, isDelta);
				}
				continue;
			case 125:
				instance.skinCol = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinTex = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinMesh = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.currentLife == null)
					{
						instance.currentLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.currentLife, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.previousLife == null)
					{
						instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.Varint)
				{
					instance.mounted = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				}
				break;
			case 23u:
				if (key.WireType == Wire.Varint)
				{
					instance.currentTeam = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 24u:
				if (key.WireType == Wire.Varint)
				{
					instance.underwear = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.modifiers == null)
					{
						instance.modifiers = PlayerModifiers.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
					}
				}
				break;
			case 26u:
				if (key.WireType == Wire.Varint)
				{
					instance.reputation = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 27u:
				if (key.WireType == Wire.Varint)
				{
					instance.loopingGesture = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 28u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.missions == null)
					{
						instance.missions = Missions.DeserializeLengthDelimited(stream);
					}
					else
					{
						Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
					}
				}
				break;
			case 29u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.respawnId = ProtocolParser.ReadString(stream);
				}
				break;
			case 30u:
				if (key.WireType == Wire.Varint)
				{
					instance.bagCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 31u:
				if (key.WireType == Wire.Varint)
				{
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.itemCrafter == null)
					{
						instance.itemCrafter = ItemCrafter.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemCrafter.DeserializeLengthDelimited(stream, instance.itemCrafter, isDelta);
					}
				}
				break;
			case 33u:
				if (key.WireType == Wire.Varint)
				{
					instance.shelterCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 34u:
				if (key.WireType == Wire.Varint)
				{
					instance.tutorialAllowance = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static BasePlayer DeserializeLengthDelimited(BufferStream stream, BasePlayer instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (instance.inventory == null)
				{
					instance.inventory = PlayerInventory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerInventory.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				continue;
			case 34:
				if (instance.metabolism == null)
				{
					instance.metabolism = PlayerMetabolism.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerMetabolism.DeserializeLengthDelimited(stream, instance.metabolism, isDelta);
				}
				continue;
			case 45:
				instance.loadingTimeout = ProtocolParser.ReadSingle(stream);
				continue;
			case 50:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				continue;
			case 56:
				instance.playerFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.heldEntity = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				if (instance.persistantData == null)
				{
					instance.persistantData = PersistantPlayer.DeserializeLengthDelimited(stream);
				}
				else
				{
					PersistantPlayer.DeserializeLengthDelimited(stream, instance.persistantData, isDelta);
				}
				continue;
			case 125:
				instance.skinCol = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinTex = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinMesh = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.currentLife == null)
					{
						instance.currentLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.currentLife, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.previousLife == null)
					{
						instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.Varint)
				{
					instance.mounted = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				}
				break;
			case 23u:
				if (key.WireType == Wire.Varint)
				{
					instance.currentTeam = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 24u:
				if (key.WireType == Wire.Varint)
				{
					instance.underwear = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.modifiers == null)
					{
						instance.modifiers = PlayerModifiers.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
					}
				}
				break;
			case 26u:
				if (key.WireType == Wire.Varint)
				{
					instance.reputation = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 27u:
				if (key.WireType == Wire.Varint)
				{
					instance.loopingGesture = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 28u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.missions == null)
					{
						instance.missions = Missions.DeserializeLengthDelimited(stream);
					}
					else
					{
						Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
					}
				}
				break;
			case 29u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.respawnId = ProtocolParser.ReadString(stream);
				}
				break;
			case 30u:
				if (key.WireType == Wire.Varint)
				{
					instance.bagCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 31u:
				if (key.WireType == Wire.Varint)
				{
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.itemCrafter == null)
					{
						instance.itemCrafter = ItemCrafter.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemCrafter.DeserializeLengthDelimited(stream, instance.itemCrafter, isDelta);
					}
				}
				break;
			case 33u:
				if (key.WireType == Wire.Varint)
				{
					instance.shelterCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 34u:
				if (key.WireType == Wire.Varint)
				{
					instance.tutorialAllowance = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BasePlayer DeserializeLength(BufferStream stream, int length, BasePlayer instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (instance.inventory == null)
				{
					instance.inventory = PlayerInventory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerInventory.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				continue;
			case 34:
				if (instance.metabolism == null)
				{
					instance.metabolism = PlayerMetabolism.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerMetabolism.DeserializeLengthDelimited(stream, instance.metabolism, isDelta);
				}
				continue;
			case 45:
				instance.loadingTimeout = ProtocolParser.ReadSingle(stream);
				continue;
			case 50:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				continue;
			case 56:
				instance.playerFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.heldEntity = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				if (instance.persistantData == null)
				{
					instance.persistantData = PersistantPlayer.DeserializeLengthDelimited(stream);
				}
				else
				{
					PersistantPlayer.DeserializeLengthDelimited(stream, instance.persistantData, isDelta);
				}
				continue;
			case 125:
				instance.skinCol = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinTex = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinMesh = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.currentLife == null)
					{
						instance.currentLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.currentLife, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.previousLife == null)
					{
						instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.Varint)
				{
					instance.mounted = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				}
				break;
			case 23u:
				if (key.WireType == Wire.Varint)
				{
					instance.currentTeam = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 24u:
				if (key.WireType == Wire.Varint)
				{
					instance.underwear = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.modifiers == null)
					{
						instance.modifiers = PlayerModifiers.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
					}
				}
				break;
			case 26u:
				if (key.WireType == Wire.Varint)
				{
					instance.reputation = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 27u:
				if (key.WireType == Wire.Varint)
				{
					instance.loopingGesture = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 28u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.missions == null)
					{
						instance.missions = Missions.DeserializeLengthDelimited(stream);
					}
					else
					{
						Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
					}
				}
				break;
			case 29u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.respawnId = ProtocolParser.ReadString(stream);
				}
				break;
			case 30u:
				if (key.WireType == Wire.Varint)
				{
					instance.bagCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 31u:
				if (key.WireType == Wire.Varint)
				{
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.itemCrafter == null)
					{
						instance.itemCrafter = ItemCrafter.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemCrafter.DeserializeLengthDelimited(stream, instance.itemCrafter, isDelta);
					}
				}
				break;
			case 33u:
				if (key.WireType == Wire.Varint)
				{
					instance.shelterCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 34u:
				if (key.WireType == Wire.Varint)
				{
					instance.tutorialAllowance = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BasePlayer instance, BasePlayer previous)
	{
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.userid != previous.userid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.inventory != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerInventory.SerializeDelta(stream, instance.inventory, previous.inventory);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.metabolism != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PlayerMetabolism.SerializeDelta(stream, instance.metabolism, previous.metabolism);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field metabolism (ProtoBuf.PlayerMetabolism)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.loadingTimeout != previous.loadingTimeout)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.loadingTimeout);
		}
		if (instance.modelState != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(2);
			int position3 = stream.Position;
			ModelState.SerializeDelta(stream, instance.modelState, previous.modelState);
			int num3 = stream.Position - position3;
			if (num3 > 16383)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modelState (global::ModelState)");
			}
			Span<byte> span3 = range3.GetSpan();
			if (ProtocolParser.WriteUInt32((uint)num3, span3, 0) < 2)
			{
				span3[0] |= 128;
				span3[1] = 0;
			}
		}
		if (instance.playerFlags != previous.playerFlags)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerFlags);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.heldEntity.Value);
		if (instance.health != previous.health)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.persistantData != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range4 = stream.GetRange(3);
			int position4 = stream.Position;
			PersistantPlayer.SerializeDelta(stream, instance.persistantData, previous.persistantData);
			int num4 = stream.Position - position4;
			if (num4 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field persistantData (ProtoBuf.PersistantPlayer)");
			}
			Span<byte> span4 = range4.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			if (num5 < 3)
			{
				span4[num5 - 1] |= 128;
				while (num5 < 2)
				{
					span4[num5++] = 128;
				}
				span4[2] = 0;
			}
		}
		if (instance.skinCol != previous.skinCol)
		{
			stream.WriteByte(125);
			ProtocolParser.WriteSingle(stream, instance.skinCol);
		}
		if (instance.skinTex != previous.skinTex)
		{
			stream.WriteByte(133);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.skinTex);
		}
		if (instance.skinMesh != previous.skinMesh)
		{
			stream.WriteByte(141);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.skinMesh);
		}
		if (instance.currentLife != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			PlayerLifeStory.SerializeDelta(stream, instance.currentLife, previous.currentLife);
			int val2 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val2, span5, 0);
			if (num6 < 5)
			{
				span5[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span5[num6++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.previousLife != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			PlayerLifeStory.SerializeDelta(stream, instance.previousLife, previous.previousLife);
			int val3 = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num7 = ProtocolParser.WriteUInt32((uint)val3, span6, 0);
			if (num7 < 5)
			{
				span6[num7 - 1] |= 128;
				while (num7 < 4)
				{
					span6[num7++] = 128;
				}
				span6[4] = 0;
			}
		}
		stream.WriteByte(176);
		stream.WriteByte(1);
		ProtocolParser.WriteUInt64(stream, instance.mounted.Value);
		if (instance.currentTeam != previous.currentTeam)
		{
			stream.WriteByte(184);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.currentTeam);
		}
		if (instance.underwear != previous.underwear)
		{
			stream.WriteByte(192);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.underwear);
		}
		if (instance.modifiers != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(1);
			BufferStream.RangeHandle range7 = stream.GetRange(3);
			int position7 = stream.Position;
			PlayerModifiers.SerializeDelta(stream, instance.modifiers, previous.modifiers);
			int num8 = stream.Position - position7;
			if (num8 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.PlayerModifiers)");
			}
			Span<byte> span7 = range7.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)num8, span7, 0);
			if (num9 < 3)
			{
				span7[num9 - 1] |= 128;
				while (num9 < 2)
				{
					span7[num9++] = 128;
				}
				span7[2] = 0;
			}
		}
		if (instance.reputation != previous.reputation)
		{
			stream.WriteByte(208);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.reputation);
		}
		if (instance.loopingGesture != previous.loopingGesture)
		{
			stream.WriteByte(216);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.loopingGesture);
		}
		if (instance.missions != null)
		{
			stream.WriteByte(226);
			stream.WriteByte(1);
			BufferStream.RangeHandle range8 = stream.GetRange(5);
			int position8 = stream.Position;
			Missions.SerializeDelta(stream, instance.missions, previous.missions);
			int val4 = stream.Position - position8;
			Span<byte> span8 = range8.GetSpan();
			int num10 = ProtocolParser.WriteUInt32((uint)val4, span8, 0);
			if (num10 < 5)
			{
				span8[num10 - 1] |= 128;
				while (num10 < 4)
				{
					span8[num10++] = 128;
				}
				span8[4] = 0;
			}
		}
		if (instance.respawnId != null && instance.respawnId != previous.respawnId)
		{
			stream.WriteByte(234);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.respawnId);
		}
		if (instance.bagCount != previous.bagCount)
		{
			stream.WriteByte(240);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bagCount);
		}
		stream.WriteByte(248);
		stream.WriteByte(1);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.itemCrafter != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(2);
			BufferStream.RangeHandle range9 = stream.GetRange(5);
			int position9 = stream.Position;
			ItemCrafter.SerializeDelta(stream, instance.itemCrafter, previous.itemCrafter);
			int val5 = stream.Position - position9;
			Span<byte> span9 = range9.GetSpan();
			int num11 = ProtocolParser.WriteUInt32((uint)val5, span9, 0);
			if (num11 < 5)
			{
				span9[num11 - 1] |= 128;
				while (num11 < 4)
				{
					span9[num11++] = 128;
				}
				span9[4] = 0;
			}
		}
		if (instance.shelterCount != previous.shelterCount)
		{
			stream.WriteByte(136);
			stream.WriteByte(2);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.shelterCount);
		}
		if (instance.tutorialAllowance != previous.tutorialAllowance)
		{
			stream.WriteByte(144);
			stream.WriteByte(2);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.tutorialAllowance);
		}
	}

	public static void Serialize(BufferStream stream, BasePlayer instance)
	{
		if (instance.name != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.userid != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.inventory != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerInventory.Serialize(stream, instance.inventory);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.metabolism != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PlayerMetabolism.Serialize(stream, instance.metabolism);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field metabolism (ProtoBuf.PlayerMetabolism)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.loadingTimeout != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.loadingTimeout);
		}
		if (instance.modelState != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(2);
			int position3 = stream.Position;
			ModelState.Serialize(stream, instance.modelState);
			int num3 = stream.Position - position3;
			if (num3 > 16383)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modelState (global::ModelState)");
			}
			Span<byte> span3 = range3.GetSpan();
			if (ProtocolParser.WriteUInt32((uint)num3, span3, 0) < 2)
			{
				span3[0] |= 128;
				span3[1] = 0;
			}
		}
		if (instance.playerFlags != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerFlags);
		}
		if (instance.heldEntity != default(ItemId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.heldEntity.Value);
		}
		if (instance.health != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.persistantData != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range4 = stream.GetRange(3);
			int position4 = stream.Position;
			PersistantPlayer.Serialize(stream, instance.persistantData);
			int num4 = stream.Position - position4;
			if (num4 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field persistantData (ProtoBuf.PersistantPlayer)");
			}
			Span<byte> span4 = range4.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			if (num5 < 3)
			{
				span4[num5 - 1] |= 128;
				while (num5 < 2)
				{
					span4[num5++] = 128;
				}
				span4[2] = 0;
			}
		}
		if (instance.skinCol != 0f)
		{
			stream.WriteByte(125);
			ProtocolParser.WriteSingle(stream, instance.skinCol);
		}
		if (instance.skinTex != 0f)
		{
			stream.WriteByte(133);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.skinTex);
		}
		if (instance.skinMesh != 0f)
		{
			stream.WriteByte(141);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.skinMesh);
		}
		if (instance.currentLife != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			PlayerLifeStory.Serialize(stream, instance.currentLife);
			int val2 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val2, span5, 0);
			if (num6 < 5)
			{
				span5[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span5[num6++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.previousLife != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			PlayerLifeStory.Serialize(stream, instance.previousLife);
			int val3 = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num7 = ProtocolParser.WriteUInt32((uint)val3, span6, 0);
			if (num7 < 5)
			{
				span6[num7 - 1] |= 128;
				while (num7 < 4)
				{
					span6[num7++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.mounted != default(NetworkableId))
		{
			stream.WriteByte(176);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.mounted.Value);
		}
		if (instance.currentTeam != 0L)
		{
			stream.WriteByte(184);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.currentTeam);
		}
		if (instance.underwear != 0)
		{
			stream.WriteByte(192);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.underwear);
		}
		if (instance.modifiers != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(1);
			BufferStream.RangeHandle range7 = stream.GetRange(3);
			int position7 = stream.Position;
			PlayerModifiers.Serialize(stream, instance.modifiers);
			int num8 = stream.Position - position7;
			if (num8 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.PlayerModifiers)");
			}
			Span<byte> span7 = range7.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)num8, span7, 0);
			if (num9 < 3)
			{
				span7[num9 - 1] |= 128;
				while (num9 < 2)
				{
					span7[num9++] = 128;
				}
				span7[2] = 0;
			}
		}
		if (instance.reputation != 0)
		{
			stream.WriteByte(208);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.reputation);
		}
		if (instance.loopingGesture != 0)
		{
			stream.WriteByte(216);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.loopingGesture);
		}
		if (instance.missions != null)
		{
			stream.WriteByte(226);
			stream.WriteByte(1);
			BufferStream.RangeHandle range8 = stream.GetRange(5);
			int position8 = stream.Position;
			Missions.Serialize(stream, instance.missions);
			int val4 = stream.Position - position8;
			Span<byte> span8 = range8.GetSpan();
			int num10 = ProtocolParser.WriteUInt32((uint)val4, span8, 0);
			if (num10 < 5)
			{
				span8[num10 - 1] |= 128;
				while (num10 < 4)
				{
					span8[num10++] = 128;
				}
				span8[4] = 0;
			}
		}
		if (instance.respawnId != null)
		{
			stream.WriteByte(234);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.respawnId);
		}
		if (instance.bagCount != 0)
		{
			stream.WriteByte(240);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bagCount);
		}
		if (instance.clanId != 0L)
		{
			stream.WriteByte(248);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.itemCrafter != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(2);
			BufferStream.RangeHandle range9 = stream.GetRange(5);
			int position9 = stream.Position;
			ItemCrafter.Serialize(stream, instance.itemCrafter);
			int val5 = stream.Position - position9;
			Span<byte> span9 = range9.GetSpan();
			int num11 = ProtocolParser.WriteUInt32((uint)val5, span9, 0);
			if (num11 < 5)
			{
				span9[num11 - 1] |= 128;
				while (num11 < 4)
				{
					span9[num11++] = 128;
				}
				span9[4] = 0;
			}
		}
		if (instance.shelterCount != 0)
		{
			stream.WriteByte(136);
			stream.WriteByte(2);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.shelterCount);
		}
		if (instance.tutorialAllowance != 0)
		{
			stream.WriteByte(144);
			stream.WriteByte(2);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.tutorialAllowance);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		inventory?.InspectUids(action);
		metabolism?.InspectUids(action);
		modelState?.InspectUids(action);
		action(UidType.ItemId, ref heldEntity.Value);
		persistantData?.InspectUids(action);
		currentLife?.InspectUids(action);
		previousLife?.InspectUids(action);
		action(UidType.NetworkableId, ref mounted.Value);
		modifiers?.InspectUids(action);
		missions?.InspectUids(action);
		itemCrafter?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerTeam : IDisposable, IPooled, IProto<PlayerTeam>, IProto
{
	public class TeamMember : IDisposable, IPooled, IProto<TeamMember>, IProto
	{
		[NonSerialized]
		public string displayName;

		[NonSerialized]
		public ulong userID;

		[NonSerialized]
		public float healthFraction;

		[NonSerialized]
		public Vector3 position;

		[NonSerialized]
		public bool online;

		[NonSerialized]
		public bool wounded;

		[NonSerialized]
		public ulong teamID;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(TeamMember instance)
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.displayName = string.Empty;
				instance.userID = 0uL;
				instance.healthFraction = 0f;
				instance.position = default(Vector3);
				instance.online = false;
				instance.wounded = false;
				instance.teamID = 0uL;
				Pool.Free<TeamMember>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose TeamMember with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(TeamMember instance)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			instance.displayName = displayName;
			instance.userID = userID;
			instance.healthFraction = healthFraction;
			instance.position = position;
			instance.online = online;
			instance.wounded = wounded;
			instance.teamID = teamID;
		}

		public TeamMember Copy()
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			CopyTo(teamMember);
			return teamMember;
		}

		public static TeamMember Deserialize(BufferStream stream)
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			Deserialize(stream, teamMember, isDelta: false);
			return teamMember;
		}

		public static TeamMember DeserializeLengthDelimited(BufferStream stream)
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			DeserializeLengthDelimited(stream, teamMember, isDelta: false);
			return teamMember;
		}

		public static TeamMember DeserializeLength(BufferStream stream, int length)
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			DeserializeLength(stream, length, teamMember, isDelta: false);
			return teamMember;
		}

		public static TeamMember Deserialize(byte[] buffer)
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, teamMember, isDelta: false);
			return teamMember;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, TeamMember previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static TeamMember Deserialize(BufferStream stream, TeamMember instance, bool isDelta)
		{
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.healthFraction = ProtocolParser.ReadSingle(stream);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 40:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.wounded = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.teamID = ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static TeamMember DeserializeLengthDelimited(BufferStream stream, TeamMember instance, bool isDelta)
		{
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.healthFraction = ProtocolParser.ReadSingle(stream);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 40:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.wounded = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.teamID = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static TeamMember DeserializeLength(BufferStream stream, int length, TeamMember instance, bool isDelta)
		{
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.healthFraction = ProtocolParser.ReadSingle(stream);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 40:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.wounded = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.teamID = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, TeamMember instance, TeamMember previous)
		{
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			if (instance.displayName != null && instance.displayName != previous.displayName)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.userID != previous.userID)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userID);
			}
			if (instance.healthFraction != previous.healthFraction)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.healthFraction);
			}
			if (instance.position != previous.position)
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.online);
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.wounded);
			if (instance.teamID != previous.teamID)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, instance.teamID);
			}
		}

		public static void Serialize(BufferStream stream, TeamMember instance)
		{
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			if (instance.displayName != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.userID != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userID);
			}
			if (instance.healthFraction != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.healthFraction);
			}
			if (instance.position != default(Vector3))
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.Serialize(stream, instance.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.online)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.online);
			}
			if (instance.wounded)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.wounded);
			}
			if (instance.teamID != 0L)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, instance.teamID);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public ulong teamID;

	[NonSerialized]
	public string teamName;

	[NonSerialized]
	public ulong teamLeader;

	[NonSerialized]
	public List<TeamMember> members;

	[NonSerialized]
	public float teamLifetime;

	[NonSerialized]
	public List<MapNote> leaderMapNotes;

	[NonSerialized]
	public List<MapNote> teamPings;

	[NonSerialized]
	public List<ulong> invites;

	[NonSerialized]
	public string joinKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerTeam instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.teamID = 0uL;
		instance.teamName = string.Empty;
		instance.teamLeader = 0uL;
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				if (instance.members[i] != null)
				{
					instance.members[i].ResetToPool();
					instance.members[i] = null;
				}
			}
			List<TeamMember> list = instance.members;
			Pool.Free<TeamMember>(ref list, false);
			instance.members = list;
		}
		instance.teamLifetime = 0f;
		if (instance.leaderMapNotes != null)
		{
			for (int j = 0; j < instance.leaderMapNotes.Count; j++)
			{
				if (instance.leaderMapNotes[j] != null)
				{
					instance.leaderMapNotes[j].ResetToPool();
					instance.leaderMapNotes[j] = null;
				}
			}
			List<MapNote> list2 = instance.leaderMapNotes;
			Pool.Free<MapNote>(ref list2, false);
			instance.leaderMapNotes = list2;
		}
		if (instance.teamPings != null)
		{
			for (int k = 0; k < instance.teamPings.Count; k++)
			{
				if (instance.teamPings[k] != null)
				{
					instance.teamPings[k].ResetToPool();
					instance.teamPings[k] = null;
				}
			}
			List<MapNote> list3 = instance.teamPings;
			Pool.Free<MapNote>(ref list3, false);
			instance.teamPings = list3;
		}
		if (instance.invites != null)
		{
			List<ulong> list4 = instance.invites;
			Pool.FreeUnmanaged<ulong>(ref list4);
			instance.invites = list4;
		}
		instance.joinKey = string.Empty;
		Pool.Free<PlayerTeam>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerTeam with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerTeam instance)
	{
		instance.teamID = teamID;
		instance.teamName = teamName;
		instance.teamLeader = teamLeader;
		if (members != null)
		{
			instance.members = Pool.Get<List<TeamMember>>();
			for (int i = 0; i < members.Count; i++)
			{
				TeamMember item = members[i].Copy();
				instance.members.Add(item);
			}
		}
		else
		{
			instance.members = null;
		}
		instance.teamLifetime = teamLifetime;
		if (leaderMapNotes != null)
		{
			instance.leaderMapNotes = Pool.Get<List<MapNote>>();
			for (int j = 0; j < leaderMapNotes.Count; j++)
			{
				MapNote item2 = leaderMapNotes[j].Copy();
				instance.leaderMapNotes.Add(item2);
			}
		}
		else
		{
			instance.leaderMapNotes = null;
		}
		if (teamPings != null)
		{
			instance.teamPings = Pool.Get<List<MapNote>>();
			for (int k = 0; k < teamPings.Count; k++)
			{
				MapNote item3 = teamPings[k].Copy();
				instance.teamPings.Add(item3);
			}
		}
		else
		{
			instance.teamPings = null;
		}
		if (invites != null)
		{
			instance.invites = Pool.Get<List<ulong>>();
			for (int l = 0; l < invites.Count; l++)
			{
				ulong item4 = invites[l];
				instance.invites.Add(item4);
			}
		}
		else
		{
			instance.invites = null;
		}
		instance.joinKey = joinKey;
	}

	public PlayerTeam Copy()
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		CopyTo(playerTeam);
		return playerTeam;
	}

	public static PlayerTeam Deserialize(BufferStream stream)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		Deserialize(stream, playerTeam, isDelta: false);
		return playerTeam;
	}

	public static PlayerTeam DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		DeserializeLengthDelimited(stream, playerTeam, isDelta: false);
		return playerTeam;
	}

	public static PlayerTeam DeserializeLength(BufferStream stream, int length)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		DeserializeLength(stream, length, playerTeam, isDelta: false);
		return playerTeam;
	}

	public static PlayerTeam Deserialize(byte[] buffer)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerTeam, isDelta: false);
		return playerTeam;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerTeam previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerTeam Deserialize(BufferStream stream, PlayerTeam instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<TeamMember>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<MapNote>>();
			}
			if (instance.teamPings == null)
			{
				instance.teamPings = Pool.Get<List<MapNote>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<ulong>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.teamLeader = ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.members.Add(TeamMember.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.teamLifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 58:
				instance.leaderMapNotes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 66:
				instance.teamPings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.invites.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 82:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerTeam DeserializeLengthDelimited(BufferStream stream, PlayerTeam instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<TeamMember>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<MapNote>>();
			}
			if (instance.teamPings == null)
			{
				instance.teamPings = Pool.Get<List<MapNote>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<ulong>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.teamLeader = ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.members.Add(TeamMember.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.teamLifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 58:
				instance.leaderMapNotes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 66:
				instance.teamPings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.invites.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 82:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerTeam DeserializeLength(BufferStream stream, int length, PlayerTeam instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<TeamMember>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<MapNote>>();
			}
			if (instance.teamPings == null)
			{
				instance.teamPings = Pool.Get<List<MapNote>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<ulong>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.teamLeader = ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.members.Add(TeamMember.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.teamLifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 58:
				instance.leaderMapNotes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 66:
				instance.teamPings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.invites.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 82:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerTeam instance, PlayerTeam previous)
	{
		if (instance.teamID != previous.teamID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.teamID);
		}
		if (instance.teamName != null && instance.teamName != previous.teamName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.teamName);
		}
		if (instance.teamLeader != previous.teamLeader)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.teamLeader);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				TeamMember teamMember = instance.members[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				TeamMember.SerializeDelta(stream, teamMember, teamMember);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.teamLifetime != previous.teamLifetime)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.teamLifetime);
		}
		if (instance.leaderMapNotes != null)
		{
			for (int j = 0; j < instance.leaderMapNotes.Count; j++)
			{
				MapNote mapNote = instance.leaderMapNotes[j];
				stream.WriteByte(58);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				MapNote.SerializeDelta(stream, mapNote, mapNote);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.teamPings != null)
		{
			for (int k = 0; k < instance.teamPings.Count; k++)
			{
				MapNote mapNote2 = instance.teamPings[k];
				stream.WriteByte(66);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				MapNote.SerializeDelta(stream, mapNote2, mapNote2);
				int val3 = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.invites != null)
		{
			for (int l = 0; l < instance.invites.Count; l++)
			{
				ulong val4 = instance.invites[l];
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, val4);
			}
		}
		if (instance.joinKey != null && instance.joinKey != previous.joinKey)
		{
			stream.WriteByte(82);
			ProtocolParser.WriteString(stream, instance.joinKey);
		}
	}

	public static void Serialize(BufferStream stream, PlayerTeam instance)
	{
		if (instance.teamID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.teamID);
		}
		if (instance.teamName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.teamName);
		}
		if (instance.teamLeader != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.teamLeader);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				TeamMember instance2 = instance.members[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				TeamMember.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.teamLifetime != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.teamLifetime);
		}
		if (instance.leaderMapNotes != null)
		{
			for (int j = 0; j < instance.leaderMapNotes.Count; j++)
			{
				MapNote instance3 = instance.leaderMapNotes[j];
				stream.WriteByte(58);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				MapNote.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.teamPings != null)
		{
			for (int k = 0; k < instance.teamPings.Count; k++)
			{
				MapNote instance4 = instance.teamPings[k];
				stream.WriteByte(66);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				MapNote.Serialize(stream, instance4);
				int val3 = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.invites != null)
		{
			for (int l = 0; l < instance.invites.Count; l++)
			{
				ulong val4 = instance.invites[l];
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, val4);
			}
		}
		if (instance.joinKey != null)
		{
			stream.WriteByte(82);
			ProtocolParser.WriteString(stream, instance.joinKey);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (members != null)
		{
			for (int i = 0; i < members.Count; i++)
			{
				members[i]?.InspectUids(action);
			}
		}
		if (leaderMapNotes != null)
		{
			for (int j = 0; j < leaderMapNotes.Count; j++)
			{
				leaderMapNotes[j]?.InspectUids(action);
			}
		}
		if (teamPings != null)
		{
			for (int k = 0; k < teamPings.Count; k++)
			{
				teamPings[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerMetabolism : IDisposable, IPooled, IProto<PlayerMetabolism>, IProto
{
	[NonSerialized]
	public float health;

	[NonSerialized]
	public float calories;

	[NonSerialized]
	public float hydration;

	[NonSerialized]
	public float heartrate;

	[NonSerialized]
	public float temperature;

	[NonSerialized]
	public float poison;

	[NonSerialized]
	public float radiation_level;

	[NonSerialized]
	public float wetness;

	[NonSerialized]
	public float dirtyness;

	[NonSerialized]
	public float oxygen;

	[NonSerialized]
	public float bleeding;

	[NonSerialized]
	public float radiation_poisoning;

	[NonSerialized]
	public float comfort;

	[NonSerialized]
	public float pending_health;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerMetabolism instance)
	{
		if (instance.ShouldPool)
		{
			instance.health = 0f;
			instance.calories = 0f;
			instance.hydration = 0f;
			instance.heartrate = 0f;
			instance.temperature = 0f;
			instance.poison = 0f;
			instance.radiation_level = 0f;
			instance.wetness = 0f;
			instance.dirtyness = 0f;
			instance.oxygen = 0f;
			instance.bleeding = 0f;
			instance.radiation_poisoning = 0f;
			instance.comfort = 0f;
			instance.pending_health = 0f;
			Pool.Free<PlayerMetabolism>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerMetabolism with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerMetabolism instance)
	{
		instance.health = health;
		instance.calories = calories;
		instance.hydration = hydration;
		instance.heartrate = heartrate;
		instance.temperature = temperature;
		instance.poison = poison;
		instance.radiation_level = radiation_level;
		instance.wetness = wetness;
		instance.dirtyness = dirtyness;
		instance.oxygen = oxygen;
		instance.bleeding = bleeding;
		instance.radiation_poisoning = radiation_poisoning;
		instance.comfort = comfort;
		instance.pending_health = pending_health;
	}

	public PlayerMetabolism Copy()
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		CopyTo(playerMetabolism);
		return playerMetabolism;
	}

	public static PlayerMetabolism Deserialize(BufferStream stream)
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		Deserialize(stream, playerMetabolism, isDelta: false);
		return playerMetabolism;
	}

	public static PlayerMetabolism DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		DeserializeLengthDelimited(stream, playerMetabolism, isDelta: false);
		return playerMetabolism;
	}

	public static PlayerMetabolism DeserializeLength(BufferStream stream, int length)
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		DeserializeLength(stream, length, playerMetabolism, isDelta: false);
		return playerMetabolism;
	}

	public static PlayerMetabolism Deserialize(byte[] buffer)
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerMetabolism, isDelta: false);
		return playerMetabolism;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerMetabolism previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerMetabolism Deserialize(BufferStream stream, PlayerMetabolism instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.calories = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.hydration = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.heartrate = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.poison = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radiation_level = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.wetness = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.dirtyness = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.bleeding = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.radiation_poisoning = ProtocolParser.ReadSingle(stream);
				continue;
			case 109:
				instance.comfort = ProtocolParser.ReadSingle(stream);
				continue;
			case 117:
				instance.pending_health = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerMetabolism DeserializeLengthDelimited(BufferStream stream, PlayerMetabolism instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.calories = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.hydration = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.heartrate = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.poison = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radiation_level = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.wetness = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.dirtyness = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.bleeding = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.radiation_poisoning = ProtocolParser.ReadSingle(stream);
				continue;
			case 109:
				instance.comfort = ProtocolParser.ReadSingle(stream);
				continue;
			case 117:
				instance.pending_health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerMetabolism DeserializeLength(BufferStream stream, int length, PlayerMetabolism instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.calories = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.hydration = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.heartrate = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.poison = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radiation_level = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.wetness = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.dirtyness = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.bleeding = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.radiation_poisoning = ProtocolParser.ReadSingle(stream);
				continue;
			case 109:
				instance.comfort = ProtocolParser.ReadSingle(stream);
				continue;
			case 117:
				instance.pending_health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerMetabolism instance, PlayerMetabolism previous)
	{
		if (instance.health != previous.health)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.calories != previous.calories)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.calories);
		}
		if (instance.hydration != previous.hydration)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.hydration);
		}
		if (instance.heartrate != previous.heartrate)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.heartrate);
		}
		if (instance.temperature != previous.temperature)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.poison != previous.poison)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.poison);
		}
		if (instance.radiation_level != previous.radiation_level)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.radiation_level);
		}
		if (instance.wetness != previous.wetness)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.wetness);
		}
		if (instance.dirtyness != previous.dirtyness)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.dirtyness);
		}
		if (instance.oxygen != previous.oxygen)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.oxygen);
		}
		if (instance.bleeding != previous.bleeding)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.bleeding);
		}
		if (instance.radiation_poisoning != previous.radiation_poisoning)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.radiation_poisoning);
		}
		if (instance.comfort != previous.comfort)
		{
			stream.WriteByte(109);
			ProtocolParser.WriteSingle(stream, instance.comfort);
		}
		if (instance.pending_health != previous.pending_health)
		{
			stream.WriteByte(117);
			ProtocolParser.WriteSingle(stream, instance.pending_health);
		}
	}

	public static void Serialize(BufferStream stream, PlayerMetabolism instance)
	{
		if (instance.health != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.calories != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.calories);
		}
		if (instance.hydration != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.hydration);
		}
		if (instance.heartrate != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.heartrate);
		}
		if (instance.temperature != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.poison != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.poison);
		}
		if (instance.radiation_level != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.radiation_level);
		}
		if (instance.wetness != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.wetness);
		}
		if (instance.dirtyness != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.dirtyness);
		}
		if (instance.oxygen != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.oxygen);
		}
		if (instance.bleeding != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.bleeding);
		}
		if (instance.radiation_poisoning != 0f)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.radiation_poisoning);
		}
		if (instance.comfort != 0f)
		{
			stream.WriteByte(109);
			ProtocolParser.WriteSingle(stream, instance.comfort);
		}
		if (instance.pending_health != 0f)
		{
			stream.WriteByte(117);
			ProtocolParser.WriteSingle(stream, instance.pending_health);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerModifiers : IDisposable, IPooled, IProto<PlayerModifiers>, IProto
{
	[NonSerialized]
	public List<Modifier> modifiers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerModifiers instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.modifiers != null)
		{
			for (int i = 0; i < instance.modifiers.Count; i++)
			{
				if (instance.modifiers[i] != null)
				{
					instance.modifiers[i].ResetToPool();
					instance.modifiers[i] = null;
				}
			}
			List<Modifier> list = instance.modifiers;
			Pool.Free<Modifier>(ref list, false);
			instance.modifiers = list;
		}
		Pool.Free<PlayerModifiers>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerModifiers with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerModifiers instance)
	{
		if (modifiers != null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
			for (int i = 0; i < modifiers.Count; i++)
			{
				Modifier item = modifiers[i].Copy();
				instance.modifiers.Add(item);
			}
		}
		else
		{
			instance.modifiers = null;
		}
	}

	public PlayerModifiers Copy()
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		CopyTo(playerModifiers);
		return playerModifiers;
	}

	public static PlayerModifiers Deserialize(BufferStream stream)
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		Deserialize(stream, playerModifiers, isDelta: false);
		return playerModifiers;
	}

	public static PlayerModifiers DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		DeserializeLengthDelimited(stream, playerModifiers, isDelta: false);
		return playerModifiers;
	}

	public static PlayerModifiers DeserializeLength(BufferStream stream, int length)
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		DeserializeLength(stream, length, playerModifiers, isDelta: false);
		return playerModifiers;
	}

	public static PlayerModifiers Deserialize(byte[] buffer)
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerModifiers, isDelta: false);
		return playerModifiers;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerModifiers previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerModifiers Deserialize(BufferStream stream, PlayerModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerModifiers DeserializeLengthDelimited(BufferStream stream, PlayerModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerModifiers DeserializeLength(BufferStream stream, int length, PlayerModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerModifiers instance, PlayerModifiers previous)
	{
		if (instance.modifiers == null)
		{
			return;
		}
		for (int i = 0; i < instance.modifiers.Count; i++)
		{
			Modifier modifier = instance.modifiers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Modifier.SerializeDelta(stream, modifier, modifier);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.Modifier)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, PlayerModifiers instance)
	{
		if (instance.modifiers == null)
		{
			return;
		}
		for (int i = 0; i < instance.modifiers.Count; i++)
		{
			Modifier instance2 = instance.modifiers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Modifier.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.Modifier)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (modifiers != null)
		{
			for (int i = 0; i < modifiers.Count; i++)
			{
				modifiers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Modifier : IDisposable, IPooled, IProto<Modifier>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public int source;

	[NonSerialized]
	public float value;

	[NonSerialized]
	public double timeRemaining;

	[NonSerialized]
	public float duration;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Modifier instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.source = 0;
			instance.value = 0f;
			instance.timeRemaining = 0.0;
			instance.duration = 0f;
			Pool.Free<Modifier>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Modifier with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Modifier instance)
	{
		instance.type = type;
		instance.source = source;
		instance.value = value;
		instance.timeRemaining = timeRemaining;
		instance.duration = duration;
	}

	public Modifier Copy()
	{
		Modifier modifier = Pool.Get<Modifier>();
		CopyTo(modifier);
		return modifier;
	}

	public static Modifier Deserialize(BufferStream stream)
	{
		Modifier modifier = Pool.Get<Modifier>();
		Deserialize(stream, modifier, isDelta: false);
		return modifier;
	}

	public static Modifier DeserializeLengthDelimited(BufferStream stream)
	{
		Modifier modifier = Pool.Get<Modifier>();
		DeserializeLengthDelimited(stream, modifier, isDelta: false);
		return modifier;
	}

	public static Modifier DeserializeLength(BufferStream stream, int length)
	{
		Modifier modifier = Pool.Get<Modifier>();
		DeserializeLength(stream, length, modifier, isDelta: false);
		return modifier;
	}

	public static Modifier Deserialize(byte[] buffer)
	{
		Modifier modifier = Pool.Get<Modifier>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, modifier, isDelta: false);
		return modifier;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Modifier previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Modifier Deserialize(BufferStream stream, Modifier instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.source = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case 33:
				instance.timeRemaining = ProtocolParser.ReadDouble(stream);
				continue;
			case 45:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Modifier DeserializeLengthDelimited(BufferStream stream, Modifier instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.source = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case 33:
				instance.timeRemaining = ProtocolParser.ReadDouble(stream);
				continue;
			case 45:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Modifier DeserializeLength(BufferStream stream, int length, Modifier instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.source = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case 33:
				instance.timeRemaining = ProtocolParser.ReadDouble(stream);
				continue;
			case 45:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Modifier instance, Modifier previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.source != previous.source)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.source);
		}
		if (instance.value != previous.value)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
		if (instance.timeRemaining != previous.timeRemaining)
		{
			stream.WriteByte(33);
			ProtocolParser.WriteDouble(stream, instance.timeRemaining);
		}
		if (instance.duration != previous.duration)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
	}

	public static void Serialize(BufferStream stream, Modifier instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.source != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.source);
		}
		if (instance.value != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
		if (instance.timeRemaining != 0.0)
		{
			stream.WriteByte(33);
			ProtocolParser.WriteDouble(stream, instance.timeRemaining);
		}
		if (instance.duration != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Missions : IDisposable, IPooled, IProto<Missions>, IProto
{
	[NonSerialized]
	public List<MissionInstance> missions;

	[NonSerialized]
	public int activeMission;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Missions instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.missions != null)
		{
			for (int i = 0; i < instance.missions.Count; i++)
			{
				if (instance.missions[i] != null)
				{
					instance.missions[i].ResetToPool();
					instance.missions[i] = null;
				}
			}
			List<MissionInstance> list = instance.missions;
			Pool.Free<MissionInstance>(ref list, false);
			instance.missions = list;
		}
		instance.activeMission = 0;
		Pool.Free<Missions>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Missions with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Missions instance)
	{
		if (missions != null)
		{
			instance.missions = Pool.Get<List<MissionInstance>>();
			for (int i = 0; i < missions.Count; i++)
			{
				MissionInstance item = missions[i].Copy();
				instance.missions.Add(item);
			}
		}
		else
		{
			instance.missions = null;
		}
		instance.activeMission = activeMission;
	}

	public Missions Copy()
	{
		Missions missions = Pool.Get<Missions>();
		CopyTo(missions);
		return missions;
	}

	public static Missions Deserialize(BufferStream stream)
	{
		Missions missions = Pool.Get<Missions>();
		Deserialize(stream, missions, isDelta: false);
		return missions;
	}

	public static Missions DeserializeLengthDelimited(BufferStream stream)
	{
		Missions missions = Pool.Get<Missions>();
		DeserializeLengthDelimited(stream, missions, isDelta: false);
		return missions;
	}

	public static Missions DeserializeLength(BufferStream stream, int length)
	{
		Missions missions = Pool.Get<Missions>();
		DeserializeLength(stream, length, missions, isDelta: false);
		return missions;
	}

	public static Missions Deserialize(byte[] buffer)
	{
		Missions missions = Pool.Get<Missions>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missions, isDelta: false);
		return missions;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Missions previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Missions Deserialize(BufferStream stream, Missions instance, bool isDelta)
	{
		if (!isDelta && instance.missions == null)
		{
			instance.missions = Pool.Get<List<MissionInstance>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.missions.Add(MissionInstance.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.activeMission = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Missions DeserializeLengthDelimited(BufferStream stream, Missions instance, bool isDelta)
	{
		if (!isDelta && instance.missions == null)
		{
			instance.missions = Pool.Get<List<MissionInstance>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.missions.Add(MissionInstance.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.activeMission = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Missions DeserializeLength(BufferStream stream, int length, Missions instance, bool isDelta)
	{
		if (!isDelta && instance.missions == null)
		{
			instance.missions = Pool.Get<List<MissionInstance>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.missions.Add(MissionInstance.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.activeMission = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Missions instance, Missions previous)
	{
		if (instance.missions != null)
		{
			for (int i = 0; i < instance.missions.Count; i++)
			{
				MissionInstance missionInstance = instance.missions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MissionInstance.SerializeDelta(stream, missionInstance, missionInstance);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.activeMission != previous.activeMission)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.activeMission);
		}
	}

	public static void Serialize(BufferStream stream, Missions instance)
	{
		if (instance.missions != null)
		{
			for (int i = 0; i < instance.missions.Count; i++)
			{
				MissionInstance instance2 = instance.missions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MissionInstance.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.activeMission != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.activeMission);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (missions != null)
		{
			for (int i = 0; i < missions.Count; i++)
			{
				missions[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ObjectiveStatus : IDisposable, IPooled, IProto<ObjectiveStatus>, IProto
{
	[NonSerialized]
	public bool started;

	[NonSerialized]
	public bool completed;

	[NonSerialized]
	public bool failed;

	[NonSerialized]
	public float progressCurrent;

	[NonSerialized]
	public float progressTarget;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ObjectiveStatus instance)
	{
		if (instance.ShouldPool)
		{
			instance.started = false;
			instance.completed = false;
			instance.failed = false;
			instance.progressCurrent = 0f;
			instance.progressTarget = 0f;
			Pool.Free<ObjectiveStatus>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ObjectiveStatus with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ObjectiveStatus instance)
	{
		instance.started = started;
		instance.completed = completed;
		instance.failed = failed;
		instance.progressCurrent = progressCurrent;
		instance.progressTarget = progressTarget;
	}

	public ObjectiveStatus Copy()
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		CopyTo(objectiveStatus);
		return objectiveStatus;
	}

	public static ObjectiveStatus Deserialize(BufferStream stream)
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		Deserialize(stream, objectiveStatus, isDelta: false);
		return objectiveStatus;
	}

	public static ObjectiveStatus DeserializeLengthDelimited(BufferStream stream)
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		DeserializeLengthDelimited(stream, objectiveStatus, isDelta: false);
		return objectiveStatus;
	}

	public static ObjectiveStatus DeserializeLength(BufferStream stream, int length)
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		DeserializeLength(stream, length, objectiveStatus, isDelta: false);
		return objectiveStatus;
	}

	public static ObjectiveStatus Deserialize(byte[] buffer)
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, objectiveStatus, isDelta: false);
		return objectiveStatus;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ObjectiveStatus previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ObjectiveStatus Deserialize(BufferStream stream, ObjectiveStatus instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.started = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.completed = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.failed = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.progressCurrent = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.progressTarget = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ObjectiveStatus DeserializeLengthDelimited(BufferStream stream, ObjectiveStatus instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.started = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.completed = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.failed = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.progressCurrent = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.progressTarget = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ObjectiveStatus DeserializeLength(BufferStream stream, int length, ObjectiveStatus instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.started = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.completed = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.failed = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.progressCurrent = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.progressTarget = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ObjectiveStatus instance, ObjectiveStatus previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.started);
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.completed);
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.failed);
		if (instance.progressCurrent != previous.progressCurrent)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.progressCurrent);
		}
		if (instance.progressTarget != previous.progressTarget)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.progressTarget);
		}
	}

	public static void Serialize(BufferStream stream, ObjectiveStatus instance)
	{
		if (instance.started)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.started);
		}
		if (instance.completed)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.completed);
		}
		if (instance.failed)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.failed);
		}
		if (instance.progressCurrent != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.progressCurrent);
		}
		if (instance.progressTarget != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.progressTarget);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MissionPoint : IDisposable, IPooled, IProto<MissionPoint>, IProto
{
	[NonSerialized]
	public string identifier;

	[NonSerialized]
	public Vector3 location;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionPoint instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.identifier = string.Empty;
			instance.location = default(Vector3);
			Pool.Free<MissionPoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionPoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionPoint instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.identifier = identifier;
		instance.location = location;
	}

	public MissionPoint Copy()
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		CopyTo(missionPoint);
		return missionPoint;
	}

	public static MissionPoint Deserialize(BufferStream stream)
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		Deserialize(stream, missionPoint, isDelta: false);
		return missionPoint;
	}

	public static MissionPoint DeserializeLengthDelimited(BufferStream stream)
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		DeserializeLengthDelimited(stream, missionPoint, isDelta: false);
		return missionPoint;
	}

	public static MissionPoint DeserializeLength(BufferStream stream, int length)
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		DeserializeLength(stream, length, missionPoint, isDelta: false);
		return missionPoint;
	}

	public static MissionPoint Deserialize(byte[] buffer)
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionPoint, isDelta: false);
		return missionPoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionPoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionPoint Deserialize(BufferStream stream, MissionPoint instance, bool isDelta)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionPoint DeserializeLengthDelimited(BufferStream stream, MissionPoint instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionPoint DeserializeLength(BufferStream stream, int length, MissionPoint instance, bool isDelta)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionPoint instance, MissionPoint previous)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		if (instance.identifier != previous.identifier)
		{
			if (instance.identifier == null)
			{
				throw new ArgumentNullException("identifier", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.identifier);
		}
		if (instance.location != previous.location)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.location, previous.location);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field location (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, MissionPoint instance)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.identifier == null)
		{
			throw new ArgumentNullException("identifier", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.identifier);
		if (instance.location != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.location);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field location (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionEntity : IDisposable, IPooled, IProto<MissionEntity>, IProto
{
	[NonSerialized]
	public string identifier;

	[NonSerialized]
	public NetworkableId entityID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.identifier = string.Empty;
			instance.entityID = default(NetworkableId);
			Pool.Free<MissionEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionEntity instance)
	{
		instance.identifier = identifier;
		instance.entityID = entityID;
	}

	public MissionEntity Copy()
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		CopyTo(missionEntity);
		return missionEntity;
	}

	public static MissionEntity Deserialize(BufferStream stream)
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		Deserialize(stream, missionEntity, isDelta: false);
		return missionEntity;
	}

	public static MissionEntity DeserializeLengthDelimited(BufferStream stream)
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		DeserializeLengthDelimited(stream, missionEntity, isDelta: false);
		return missionEntity;
	}

	public static MissionEntity DeserializeLength(BufferStream stream, int length)
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		DeserializeLength(stream, length, missionEntity, isDelta: false);
		return missionEntity;
	}

	public static MissionEntity Deserialize(byte[] buffer)
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionEntity, isDelta: false);
		return missionEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionEntity Deserialize(BufferStream stream, MissionEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionEntity DeserializeLengthDelimited(BufferStream stream, MissionEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionEntity DeserializeLength(BufferStream stream, int length, MissionEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionEntity instance, MissionEntity previous)
	{
		if (instance.identifier != previous.identifier)
		{
			if (instance.identifier == null)
			{
				throw new ArgumentNullException("identifier", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.identifier);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
	}

	public static void Serialize(BufferStream stream, MissionEntity instance)
	{
		if (instance.identifier == null)
		{
			throw new ArgumentNullException("identifier", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.identifier);
		if (instance.entityID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionReward : IDisposable, IPooled, IProto<MissionReward>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public int itemAmount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionReward instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.itemAmount = 0;
			Pool.Free<MissionReward>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionReward with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionReward instance)
	{
		instance.itemID = itemID;
		instance.itemAmount = itemAmount;
	}

	public MissionReward Copy()
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		CopyTo(missionReward);
		return missionReward;
	}

	public static MissionReward Deserialize(BufferStream stream)
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		Deserialize(stream, missionReward, isDelta: false);
		return missionReward;
	}

	public static MissionReward DeserializeLengthDelimited(BufferStream stream)
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		DeserializeLengthDelimited(stream, missionReward, isDelta: false);
		return missionReward;
	}

	public static MissionReward DeserializeLength(BufferStream stream, int length)
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		DeserializeLength(stream, length, missionReward, isDelta: false);
		return missionReward;
	}

	public static MissionReward Deserialize(byte[] buffer)
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionReward, isDelta: false);
		return missionReward;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionReward previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionReward Deserialize(BufferStream stream, MissionReward instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionReward DeserializeLengthDelimited(BufferStream stream, MissionReward instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionReward DeserializeLength(BufferStream stream, int length, MissionReward instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionReward instance, MissionReward previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.itemAmount != previous.itemAmount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemAmount);
		}
	}

	public static void Serialize(BufferStream stream, MissionReward instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.itemAmount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemAmount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionInstance : IDisposable, IPooled, IProto<MissionInstance>, IProto
{
	[NonSerialized]
	public uint missionID;

	[NonSerialized]
	public uint missionStatus;

	[NonSerialized]
	public MissionInstanceData instanceData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionInstance instance)
	{
		if (instance.ShouldPool)
		{
			instance.missionID = 0u;
			instance.missionStatus = 0u;
			if (instance.instanceData != null)
			{
				instance.instanceData.ResetToPool();
				instance.instanceData = null;
			}
			Pool.Free<MissionInstance>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionInstance with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionInstance instance)
	{
		instance.missionID = missionID;
		instance.missionStatus = missionStatus;
		if (instanceData != null)
		{
			if (instance.instanceData == null)
			{
				instance.instanceData = instanceData.Copy();
			}
			else
			{
				instanceData.CopyTo(instance.instanceData);
			}
		}
		else
		{
			instance.instanceData = null;
		}
	}

	public MissionInstance Copy()
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		CopyTo(missionInstance);
		return missionInstance;
	}

	public static MissionInstance Deserialize(BufferStream stream)
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		Deserialize(stream, missionInstance, isDelta: false);
		return missionInstance;
	}

	public static MissionInstance DeserializeLengthDelimited(BufferStream stream)
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		DeserializeLengthDelimited(stream, missionInstance, isDelta: false);
		return missionInstance;
	}

	public static MissionInstance DeserializeLength(BufferStream stream, int length)
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		DeserializeLength(stream, length, missionInstance, isDelta: false);
		return missionInstance;
	}

	public static MissionInstance Deserialize(byte[] buffer)
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionInstance, isDelta: false);
		return missionInstance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionInstance previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionInstance Deserialize(BufferStream stream, MissionInstance instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 16:
				instance.missionID = ProtocolParser.ReadUInt32(stream);
				break;
			case 24:
				instance.missionStatus = ProtocolParser.ReadUInt32(stream);
				break;
			case 98:
				if (instance.instanceData == null)
				{
					instance.instanceData = MissionInstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					MissionInstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static MissionInstance DeserializeLengthDelimited(BufferStream stream, MissionInstance instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.missionID = ProtocolParser.ReadUInt32(stream);
				break;
			case 24:
				instance.missionStatus = ProtocolParser.ReadUInt32(stream);
				break;
			case 98:
				if (instance.instanceData == null)
				{
					instance.instanceData = MissionInstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					MissionInstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionInstance DeserializeLength(BufferStream stream, int length, MissionInstance instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.missionID = ProtocolParser.ReadUInt32(stream);
				break;
			case 24:
				instance.missionStatus = ProtocolParser.ReadUInt32(stream);
				break;
			case 98:
				if (instance.instanceData == null)
				{
					instance.instanceData = MissionInstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					MissionInstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionInstance instance, MissionInstance previous)
	{
		if (instance.missionID != previous.missionID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.missionID);
		}
		if (instance.missionStatus != previous.missionStatus)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.missionStatus);
		}
		if (instance.instanceData == null)
		{
			return;
		}
		stream.WriteByte(98);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		MissionInstanceData.SerializeDelta(stream, instance.instanceData, previous.instanceData);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, MissionInstance instance)
	{
		if (instance.missionID != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.missionID);
		}
		if (instance.missionStatus != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.missionStatus);
		}
		if (instance.instanceData == null)
		{
			return;
		}
		stream.WriteByte(98);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		MissionInstanceData.Serialize(stream, instance.instanceData);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		instanceData?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MissionInstanceData : IDisposable, IPooled, IProto<MissionInstanceData>, IProto
{
	[NonSerialized]
	public NetworkableId providerID;

	[NonSerialized]
	public float startTime;

	[NonSerialized]
	public float endTime;

	[NonSerialized]
	public Vector3 missionLocation;

	[NonSerialized]
	public List<ObjectiveStatus> objectiveStatuses;

	[NonSerialized]
	public List<MissionPoint> missionPoints;

	[NonSerialized]
	public List<MissionEntity> missionEntities;

	[NonSerialized]
	public int playerInputRequired;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionInstanceData instance)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.providerID = default(NetworkableId);
		instance.startTime = 0f;
		instance.endTime = 0f;
		instance.missionLocation = default(Vector3);
		if (instance.objectiveStatuses != null)
		{
			for (int i = 0; i < instance.objectiveStatuses.Count; i++)
			{
				if (instance.objectiveStatuses[i] != null)
				{
					instance.objectiveStatuses[i].ResetToPool();
					instance.objectiveStatuses[i] = null;
				}
			}
			List<ObjectiveStatus> list = instance.objectiveStatuses;
			Pool.Free<ObjectiveStatus>(ref list, false);
			instance.objectiveStatuses = list;
		}
		if (instance.missionPoints != null)
		{
			for (int j = 0; j < instance.missionPoints.Count; j++)
			{
				if (instance.missionPoints[j] != null)
				{
					instance.missionPoints[j].ResetToPool();
					instance.missionPoints[j] = null;
				}
			}
			List<MissionPoint> list2 = instance.missionPoints;
			Pool.Free<MissionPoint>(ref list2, false);
			instance.missionPoints = list2;
		}
		if (instance.missionEntities != null)
		{
			for (int k = 0; k < instance.missionEntities.Count; k++)
			{
				if (instance.missionEntities[k] != null)
				{
					instance.missionEntities[k].ResetToPool();
					instance.missionEntities[k] = null;
				}
			}
			List<MissionEntity> list3 = instance.missionEntities;
			Pool.Free<MissionEntity>(ref list3, false);
			instance.missionEntities = list3;
		}
		instance.playerInputRequired = 0;
		Pool.Free<MissionInstanceData>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionInstanceData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionInstanceData instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.providerID = providerID;
		instance.startTime = startTime;
		instance.endTime = endTime;
		instance.missionLocation = missionLocation;
		if (objectiveStatuses != null)
		{
			instance.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			for (int i = 0; i < objectiveStatuses.Count; i++)
			{
				ObjectiveStatus item = objectiveStatuses[i].Copy();
				instance.objectiveStatuses.Add(item);
			}
		}
		else
		{
			instance.objectiveStatuses = null;
		}
		if (missionPoints != null)
		{
			instance.missionPoints = Pool.Get<List<MissionPoint>>();
			for (int j = 0; j < missionPoints.Count; j++)
			{
				MissionPoint item2 = missionPoints[j].Copy();
				instance.missionPoints.Add(item2);
			}
		}
		else
		{
			instance.missionPoints = null;
		}
		if (missionEntities != null)
		{
			instance.missionEntities = Pool.Get<List<MissionEntity>>();
			for (int k = 0; k < missionEntities.Count; k++)
			{
				MissionEntity item3 = missionEntities[k].Copy();
				instance.missionEntities.Add(item3);
			}
		}
		else
		{
			instance.missionEntities = null;
		}
		instance.playerInputRequired = playerInputRequired;
	}

	public MissionInstanceData Copy()
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		CopyTo(missionInstanceData);
		return missionInstanceData;
	}

	public static MissionInstanceData Deserialize(BufferStream stream)
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		Deserialize(stream, missionInstanceData, isDelta: false);
		return missionInstanceData;
	}

	public static MissionInstanceData DeserializeLengthDelimited(BufferStream stream)
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		DeserializeLengthDelimited(stream, missionInstanceData, isDelta: false);
		return missionInstanceData;
	}

	public static MissionInstanceData DeserializeLength(BufferStream stream, int length)
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		DeserializeLength(stream, length, missionInstanceData, isDelta: false);
		return missionInstanceData;
	}

	public static MissionInstanceData Deserialize(byte[] buffer)
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionInstanceData, isDelta: false);
		return missionInstanceData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionInstanceData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionInstanceData Deserialize(BufferStream stream, MissionInstanceData instance, bool isDelta)
	{
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.objectiveStatuses == null)
			{
				instance.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			}
			if (instance.missionPoints == null)
			{
				instance.missionPoints = Pool.Get<List<MissionPoint>>();
			}
			if (instance.missionEntities == null)
			{
				instance.missionEntities = Pool.Get<List<MissionEntity>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.providerID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.startTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.endTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.missionLocation, isDelta);
				continue;
			case 42:
				instance.objectiveStatuses.Add(ObjectiveStatus.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.missionPoints.Add(MissionPoint.DeserializeLengthDelimited(stream));
				continue;
			case 58:
				instance.missionEntities.Add(MissionEntity.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.playerInputRequired = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionInstanceData DeserializeLengthDelimited(BufferStream stream, MissionInstanceData instance, bool isDelta)
	{
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.objectiveStatuses == null)
			{
				instance.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			}
			if (instance.missionPoints == null)
			{
				instance.missionPoints = Pool.Get<List<MissionPoint>>();
			}
			if (instance.missionEntities == null)
			{
				instance.missionEntities = Pool.Get<List<MissionEntity>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.providerID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.startTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.endTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.missionLocation, isDelta);
				continue;
			case 42:
				instance.objectiveStatuses.Add(ObjectiveStatus.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.missionPoints.Add(MissionPoint.DeserializeLengthDelimited(stream));
				continue;
			case 58:
				instance.missionEntities.Add(MissionEntity.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.playerInputRequired = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionInstanceData DeserializeLength(BufferStream stream, int length, MissionInstanceData instance, bool isDelta)
	{
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.objectiveStatuses == null)
			{
				instance.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			}
			if (instance.missionPoints == null)
			{
				instance.missionPoints = Pool.Get<List<MissionPoint>>();
			}
			if (instance.missionEntities == null)
			{
				instance.missionEntities = Pool.Get<List<MissionEntity>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.providerID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.startTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.endTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.missionLocation, isDelta);
				continue;
			case 42:
				instance.objectiveStatuses.Add(ObjectiveStatus.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.missionPoints.Add(MissionPoint.DeserializeLengthDelimited(stream));
				continue;
			case 58:
				instance.missionEntities.Add(MissionEntity.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.playerInputRequired = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionInstanceData instance, MissionInstanceData previous)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.providerID.Value);
		if (instance.startTime != previous.startTime)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.startTime);
		}
		if (instance.endTime != previous.endTime)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.endTime);
		}
		if (instance.missionLocation != previous.missionLocation)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.missionLocation, previous.missionLocation);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field missionLocation (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.objectiveStatuses != null)
		{
			for (int i = 0; i < instance.objectiveStatuses.Count; i++)
			{
				ObjectiveStatus objectiveStatus = instance.objectiveStatuses[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				ObjectiveStatus.SerializeDelta(stream, objectiveStatus, objectiveStatus);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field objectiveStatuses (ProtoBuf.ObjectiveStatus)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
		}
		if (instance.missionPoints != null)
		{
			for (int j = 0; j < instance.missionPoints.Count; j++)
			{
				MissionPoint missionPoint = instance.missionPoints[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				MissionPoint.SerializeDelta(stream, missionPoint, missionPoint);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.missionEntities != null)
		{
			for (int k = 0; k < instance.missionEntities.Count; k++)
			{
				MissionEntity missionEntity = instance.missionEntities[k];
				stream.WriteByte(58);
				BufferStream.RangeHandle range4 = stream.GetRange(5);
				int position4 = stream.Position;
				MissionEntity.SerializeDelta(stream, missionEntity, missionEntity);
				int val2 = stream.Position - position4;
				Span<byte> span4 = range4.GetSpan();
				int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
				if (num4 < 5)
				{
					span4[num4 - 1] |= 128;
					while (num4 < 4)
					{
						span4[num4++] = 128;
					}
					span4[4] = 0;
				}
			}
		}
		if (instance.playerInputRequired != previous.playerInputRequired)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerInputRequired);
		}
	}

	public static void Serialize(BufferStream stream, MissionInstanceData instance)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.providerID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.providerID.Value);
		}
		if (instance.startTime != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.startTime);
		}
		if (instance.endTime != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.endTime);
		}
		if (instance.missionLocation != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.missionLocation);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field missionLocation (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.objectiveStatuses != null)
		{
			for (int i = 0; i < instance.objectiveStatuses.Count; i++)
			{
				ObjectiveStatus instance2 = instance.objectiveStatuses[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				ObjectiveStatus.Serialize(stream, instance2);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field objectiveStatuses (ProtoBuf.ObjectiveStatus)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
		}
		if (instance.missionPoints != null)
		{
			for (int j = 0; j < instance.missionPoints.Count; j++)
			{
				MissionPoint instance3 = instance.missionPoints[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				MissionPoint.Serialize(stream, instance3);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.missionEntities != null)
		{
			for (int k = 0; k < instance.missionEntities.Count; k++)
			{
				MissionEntity instance4 = instance.missionEntities[k];
				stream.WriteByte(58);
				BufferStream.RangeHandle range4 = stream.GetRange(5);
				int position4 = stream.Position;
				MissionEntity.Serialize(stream, instance4);
				int val2 = stream.Position - position4;
				Span<byte> span4 = range4.GetSpan();
				int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
				if (num4 < 5)
				{
					span4[num4 - 1] |= 128;
					while (num4 < 4)
					{
						span4[num4++] = 128;
					}
					span4[4] = 0;
				}
			}
		}
		if (instance.playerInputRequired != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerInputRequired);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref providerID.Value);
		if (objectiveStatuses != null)
		{
			for (int i = 0; i < objectiveStatuses.Count; i++)
			{
				objectiveStatuses[i]?.InspectUids(action);
			}
		}
		if (missionPoints != null)
		{
			for (int j = 0; j < missionPoints.Count; j++)
			{
				missionPoints[j]?.InspectUids(action);
			}
		}
		if (missionEntities != null)
		{
			for (int k = 0; k < missionEntities.Count; k++)
			{
				missionEntities[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerInventory : IDisposable, IPooled, IProto<PlayerInventory>, IProto
{
	[NonSerialized]
	public ItemContainer invMain;

	[NonSerialized]
	public ItemContainer invBelt;

	[NonSerialized]
	public ItemContainer invWear;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerInventory instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.invMain != null)
			{
				instance.invMain.ResetToPool();
				instance.invMain = null;
			}
			if (instance.invBelt != null)
			{
				instance.invBelt.ResetToPool();
				instance.invBelt = null;
			}
			if (instance.invWear != null)
			{
				instance.invWear.ResetToPool();
				instance.invWear = null;
			}
			Pool.Free<PlayerInventory>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerInventory with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerInventory instance)
	{
		if (invMain != null)
		{
			if (instance.invMain == null)
			{
				instance.invMain = invMain.Copy();
			}
			else
			{
				invMain.CopyTo(instance.invMain);
			}
		}
		else
		{
			instance.invMain = null;
		}
		if (invBelt != null)
		{
			if (instance.invBelt == null)
			{
				instance.invBelt = invBelt.Copy();
			}
			else
			{
				invBelt.CopyTo(instance.invBelt);
			}
		}
		else
		{
			instance.invBelt = null;
		}
		if (invWear != null)
		{
			if (instance.invWear == null)
			{
				instance.invWear = invWear.Copy();
			}
			else
			{
				invWear.CopyTo(instance.invWear);
			}
		}
		else
		{
			instance.invWear = null;
		}
	}

	public PlayerInventory Copy()
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		CopyTo(playerInventory);
		return playerInventory;
	}

	public static PlayerInventory Deserialize(BufferStream stream)
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		Deserialize(stream, playerInventory, isDelta: false);
		return playerInventory;
	}

	public static PlayerInventory DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		DeserializeLengthDelimited(stream, playerInventory, isDelta: false);
		return playerInventory;
	}

	public static PlayerInventory DeserializeLength(BufferStream stream, int length)
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		DeserializeLength(stream, length, playerInventory, isDelta: false);
		return playerInventory;
	}

	public static PlayerInventory Deserialize(byte[] buffer)
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerInventory, isDelta: false);
		return playerInventory;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerInventory previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerInventory Deserialize(BufferStream stream, PlayerInventory instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.invMain == null)
				{
					instance.invMain = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invMain, isDelta);
				}
				break;
			case 18:
				if (instance.invBelt == null)
				{
					instance.invBelt = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invBelt, isDelta);
				}
				break;
			case 26:
				if (instance.invWear == null)
				{
					instance.invWear = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invWear, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static PlayerInventory DeserializeLengthDelimited(BufferStream stream, PlayerInventory instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.invMain == null)
				{
					instance.invMain = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invMain, isDelta);
				}
				break;
			case 18:
				if (instance.invBelt == null)
				{
					instance.invBelt = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invBelt, isDelta);
				}
				break;
			case 26:
				if (instance.invWear == null)
				{
					instance.invWear = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invWear, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerInventory DeserializeLength(BufferStream stream, int length, PlayerInventory instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.invMain == null)
				{
					instance.invMain = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invMain, isDelta);
				}
				break;
			case 18:
				if (instance.invBelt == null)
				{
					instance.invBelt = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invBelt, isDelta);
				}
				break;
			case 26:
				if (instance.invWear == null)
				{
					instance.invWear = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invWear, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerInventory instance, PlayerInventory previous)
	{
		if (instance.invMain != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.invMain, previous.invMain);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.invBelt != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.invBelt, previous.invBelt);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.invWear == null)
		{
			return;
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.invWear, previous.invWear);
		int val3 = stream.Position - position3;
		Span<byte> span3 = range3.GetSpan();
		int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
		if (num3 < 5)
		{
			span3[num3 - 1] |= 128;
			while (num3 < 4)
			{
				span3[num3++] = 128;
			}
			span3[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, PlayerInventory instance)
	{
		if (instance.invMain != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance.invMain);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.invBelt != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.Serialize(stream, instance.invBelt);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.invWear == null)
		{
			return;
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		ItemContainer.Serialize(stream, instance.invWear);
		int val3 = stream.Position - position3;
		Span<byte> span3 = range3.GetSpan();
		int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
		if (num3 < 5)
		{
			span3[num3 - 1] |= 128;
			while (num3 < 4)
			{
				span3[num3++] = 128;
			}
			span3[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		invMain?.InspectUids(action);
		invBelt?.InspectUids(action);
		invWear?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PersistantPlayer : IDisposable, IPooled, IProto<PersistantPlayer>, IProto
{
	[NonSerialized]
	public List<int> unlockedItems;

	[NonSerialized]
	public int protocolVersion;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PersistantPlayer instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.unlockedItems != null)
			{
				List<int> list = instance.unlockedItems;
				Pool.FreeUnmanaged<int>(ref list);
				instance.unlockedItems = list;
			}
			instance.protocolVersion = 0;
			Pool.Free<PersistantPlayer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PersistantPlayer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PersistantPlayer instance)
	{
		if (unlockedItems != null)
		{
			instance.unlockedItems = Pool.Get<List<int>>();
			for (int i = 0; i < unlockedItems.Count; i++)
			{
				int item = unlockedItems[i];
				instance.unlockedItems.Add(item);
			}
		}
		else
		{
			instance.unlockedItems = null;
		}
		instance.protocolVersion = protocolVersion;
	}

	public PersistantPlayer Copy()
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		CopyTo(persistantPlayer);
		return persistantPlayer;
	}

	public static PersistantPlayer Deserialize(BufferStream stream)
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		Deserialize(stream, persistantPlayer, isDelta: false);
		return persistantPlayer;
	}

	public static PersistantPlayer DeserializeLengthDelimited(BufferStream stream)
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		DeserializeLengthDelimited(stream, persistantPlayer, isDelta: false);
		return persistantPlayer;
	}

	public static PersistantPlayer DeserializeLength(BufferStream stream, int length)
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		DeserializeLength(stream, length, persistantPlayer, isDelta: false);
		return persistantPlayer;
	}

	public static PersistantPlayer Deserialize(byte[] buffer)
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, persistantPlayer, isDelta: false);
		return persistantPlayer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PersistantPlayer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PersistantPlayer Deserialize(BufferStream stream, PersistantPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.unlockedItems == null)
		{
			instance.unlockedItems = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 24:
				instance.unlockedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.protocolVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static PersistantPlayer DeserializeLengthDelimited(BufferStream stream, PersistantPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.unlockedItems == null)
		{
			instance.unlockedItems = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.unlockedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.protocolVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PersistantPlayer DeserializeLength(BufferStream stream, int length, PersistantPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.unlockedItems == null)
		{
			instance.unlockedItems = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.unlockedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.protocolVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PersistantPlayer instance, PersistantPlayer previous)
	{
		if (instance.unlockedItems != null)
		{
			for (int i = 0; i < instance.unlockedItems.Count; i++)
			{
				int num = instance.unlockedItems[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.protocolVersion != previous.protocolVersion)
		{
			stream.WriteByte(160);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.protocolVersion);
		}
	}

	public static void Serialize(BufferStream stream, PersistantPlayer instance)
	{
		if (instance.unlockedItems != null)
		{
			for (int i = 0; i < instance.unlockedItems.Count; i++)
			{
				int num = instance.unlockedItems[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.protocolVersion != 0)
		{
			stream.WriteByte(160);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.protocolVersion);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerLifeStory : IDisposable, IPooled, IProto<PlayerLifeStory>, IProto
{
	public class DeathInfo : IDisposable, IPooled, IProto<DeathInfo>, IProto
	{
		[NonSerialized]
		public string attackerName;

		[NonSerialized]
		public ulong attackerSteamID;

		[NonSerialized]
		public string hitBone;

		[NonSerialized]
		public string inflictorName;

		[NonSerialized]
		public int lastDamageType;

		[NonSerialized]
		public float attackerDistance;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(DeathInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.attackerName = string.Empty;
				instance.attackerSteamID = 0uL;
				instance.hitBone = string.Empty;
				instance.inflictorName = string.Empty;
				instance.lastDamageType = 0;
				instance.attackerDistance = 0f;
				Pool.Free<DeathInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose DeathInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(DeathInfo instance)
		{
			instance.attackerName = attackerName;
			instance.attackerSteamID = attackerSteamID;
			instance.hitBone = hitBone;
			instance.inflictorName = inflictorName;
			instance.lastDamageType = lastDamageType;
			instance.attackerDistance = attackerDistance;
		}

		public DeathInfo Copy()
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			CopyTo(deathInfo);
			return deathInfo;
		}

		public static DeathInfo Deserialize(BufferStream stream)
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			Deserialize(stream, deathInfo, isDelta: false);
			return deathInfo;
		}

		public static DeathInfo DeserializeLengthDelimited(BufferStream stream)
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			DeserializeLengthDelimited(stream, deathInfo, isDelta: false);
			return deathInfo;
		}

		public static DeathInfo DeserializeLength(BufferStream stream, int length)
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			DeserializeLength(stream, length, deathInfo, isDelta: false);
			return deathInfo;
		}

		public static DeathInfo Deserialize(byte[] buffer)
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, deathInfo, isDelta: false);
			return deathInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, DeathInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static DeathInfo Deserialize(BufferStream stream, DeathInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.attackerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.hitBone = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.inflictorName = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 53:
					instance.attackerDistance = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static DeathInfo DeserializeLengthDelimited(BufferStream stream, DeathInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.attackerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.hitBone = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.inflictorName = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 53:
					instance.attackerDistance = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static DeathInfo DeserializeLength(BufferStream stream, int length, DeathInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.attackerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.hitBone = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.inflictorName = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 53:
					instance.attackerDistance = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, DeathInfo instance, DeathInfo previous)
		{
			if (instance.attackerName != null && instance.attackerName != previous.attackerName)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.attackerName);
			}
			if (instance.attackerSteamID != previous.attackerSteamID)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.attackerSteamID);
			}
			if (instance.hitBone != null && instance.hitBone != previous.hitBone)
			{
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.hitBone);
			}
			if (instance.inflictorName != null && instance.inflictorName != previous.inflictorName)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.inflictorName);
			}
			if (instance.lastDamageType != previous.lastDamageType)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.lastDamageType);
			}
			if (instance.attackerDistance != previous.attackerDistance)
			{
				stream.WriteByte(53);
				ProtocolParser.WriteSingle(stream, instance.attackerDistance);
			}
		}

		public static void Serialize(BufferStream stream, DeathInfo instance)
		{
			if (instance.attackerName != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.attackerName);
			}
			if (instance.attackerSteamID != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.attackerSteamID);
			}
			if (instance.hitBone != null)
			{
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.hitBone);
			}
			if (instance.inflictorName != null)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.inflictorName);
			}
			if (instance.lastDamageType != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.lastDamageType);
			}
			if (instance.attackerDistance != 0f)
			{
				stream.WriteByte(53);
				ProtocolParser.WriteSingle(stream, instance.attackerDistance);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class WeaponStats : IDisposable, IPooled, IProto<WeaponStats>, IProto
	{
		[NonSerialized]
		public string weaponName;

		[NonSerialized]
		public ulong shotsFired;

		[NonSerialized]
		public ulong shotsHit;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(WeaponStats instance)
		{
			if (instance.ShouldPool)
			{
				instance.weaponName = string.Empty;
				instance.shotsFired = 0uL;
				instance.shotsHit = 0uL;
				Pool.Free<WeaponStats>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose WeaponStats with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(WeaponStats instance)
		{
			instance.weaponName = weaponName;
			instance.shotsFired = shotsFired;
			instance.shotsHit = shotsHit;
		}

		public WeaponStats Copy()
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			CopyTo(weaponStats);
			return weaponStats;
		}

		public static WeaponStats Deserialize(BufferStream stream)
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			Deserialize(stream, weaponStats, isDelta: false);
			return weaponStats;
		}

		public static WeaponStats DeserializeLengthDelimited(BufferStream stream)
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			DeserializeLengthDelimited(stream, weaponStats, isDelta: false);
			return weaponStats;
		}

		public static WeaponStats DeserializeLength(BufferStream stream, int length)
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			DeserializeLength(stream, length, weaponStats, isDelta: false);
			return weaponStats;
		}

		public static WeaponStats Deserialize(byte[] buffer)
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, weaponStats, isDelta: false);
			return weaponStats;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, WeaponStats previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static WeaponStats Deserialize(BufferStream stream, WeaponStats instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.weaponName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.shotsFired = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.shotsHit = ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static WeaponStats DeserializeLengthDelimited(BufferStream stream, WeaponStats instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.weaponName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.shotsFired = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.shotsHit = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static WeaponStats DeserializeLength(BufferStream stream, int length, WeaponStats instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.weaponName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.shotsFired = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.shotsHit = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, WeaponStats instance, WeaponStats previous)
		{
			if (instance.weaponName != previous.weaponName)
			{
				if (instance.weaponName == null)
				{
					throw new ArgumentNullException("weaponName", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.weaponName);
			}
			if (instance.shotsFired != previous.shotsFired)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.shotsFired);
			}
			if (instance.shotsHit != previous.shotsHit)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.shotsHit);
			}
		}

		public static void Serialize(BufferStream stream, WeaponStats instance)
		{
			if (instance.weaponName == null)
			{
				throw new ArgumentNullException("weaponName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.weaponName);
			if (instance.shotsFired != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.shotsFired);
			}
			if (instance.shotsHit != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.shotsHit);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class GenericStat : IDisposable, IPooled, IProto<GenericStat>, IProto
	{
		[NonSerialized]
		public string key;

		[NonSerialized]
		public int value;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(GenericStat instance)
		{
			if (instance.ShouldPool)
			{
				instance.key = string.Empty;
				instance.value = 0;
				Pool.Free<GenericStat>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose GenericStat with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(GenericStat instance)
		{
			instance.key = key;
			instance.value = value;
		}

		public GenericStat Copy()
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			CopyTo(genericStat);
			return genericStat;
		}

		public static GenericStat Deserialize(BufferStream stream)
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			Deserialize(stream, genericStat, isDelta: false);
			return genericStat;
		}

		public static GenericStat DeserializeLengthDelimited(BufferStream stream)
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			DeserializeLengthDelimited(stream, genericStat, isDelta: false);
			return genericStat;
		}

		public static GenericStat DeserializeLength(BufferStream stream, int length)
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			DeserializeLength(stream, length, genericStat, isDelta: false);
			return genericStat;
		}

		public static GenericStat Deserialize(byte[] buffer)
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, genericStat, isDelta: false);
			return genericStat;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, GenericStat previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static GenericStat Deserialize(BufferStream stream, GenericStat instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.key = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.value = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static GenericStat DeserializeLengthDelimited(BufferStream stream, GenericStat instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.key = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.value = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static GenericStat DeserializeLength(BufferStream stream, int length, GenericStat instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.key = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.value = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, GenericStat instance, GenericStat previous)
		{
			if (instance.key != previous.key)
			{
				if (instance.key == null)
				{
					throw new ArgumentNullException("key", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.key);
			}
			if (instance.value != previous.value)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
			}
		}

		public static void Serialize(BufferStream stream, GenericStat instance)
		{
			if (instance.key == null)
			{
				throw new ArgumentNullException("key", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.key);
			if (instance.value != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public float secondsAlive;

	[NonSerialized]
	public float metersWalked;

	[NonSerialized]
	public float metersRun;

	[NonSerialized]
	public float secondsSleeping;

	[NonSerialized]
	public uint timeBorn;

	[NonSerialized]
	public uint timeDied;

	[NonSerialized]
	public float secondsWilderness;

	[NonSerialized]
	public float secondsSwimming;

	[NonSerialized]
	public float secondsInBase;

	[NonSerialized]
	public float secondsInMonument;

	[NonSerialized]
	public float secondsFlying;

	[NonSerialized]
	public float secondsBoating;

	[NonSerialized]
	public float secondsDriving;

	[NonSerialized]
	public float totalDamageTaken;

	[NonSerialized]
	public float totalHealing;

	[NonSerialized]
	public DeathInfo deathInfo;

	[NonSerialized]
	public List<WeaponStats> weaponStats;

	[NonSerialized]
	public int killedPlayers;

	[NonSerialized]
	public int killedScientists;

	[NonSerialized]
	public int killedAnimals;

	[NonSerialized]
	public List<GenericStat> genericStats;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerLifeStory instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.secondsAlive = 0f;
		instance.metersWalked = 0f;
		instance.metersRun = 0f;
		instance.secondsSleeping = 0f;
		instance.timeBorn = 0u;
		instance.timeDied = 0u;
		instance.secondsWilderness = 0f;
		instance.secondsSwimming = 0f;
		instance.secondsInBase = 0f;
		instance.secondsInMonument = 0f;
		instance.secondsFlying = 0f;
		instance.secondsBoating = 0f;
		instance.secondsDriving = 0f;
		instance.totalDamageTaken = 0f;
		instance.totalHealing = 0f;
		if (instance.deathInfo != null)
		{
			instance.deathInfo.ResetToPool();
			instance.deathInfo = null;
		}
		if (instance.weaponStats != null)
		{
			for (int i = 0; i < instance.weaponStats.Count; i++)
			{
				if (instance.weaponStats[i] != null)
				{
					instance.weaponStats[i].ResetToPool();
					instance.weaponStats[i] = null;
				}
			}
			List<WeaponStats> list = instance.weaponStats;
			Pool.Free<WeaponStats>(ref list, false);
			instance.weaponStats = list;
		}
		instance.killedPlayers = 0;
		instance.killedScientists = 0;
		instance.killedAnimals = 0;
		if (instance.genericStats != null)
		{
			for (int j = 0; j < instance.genericStats.Count; j++)
			{
				if (instance.genericStats[j] != null)
				{
					instance.genericStats[j].ResetToPool();
					instance.genericStats[j] = null;
				}
			}
			List<GenericStat> list2 = instance.genericStats;
			Pool.Free<GenericStat>(ref list2, false);
			instance.genericStats = list2;
		}
		Pool.Free<PlayerLifeStory>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerLifeStory with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerLifeStory instance)
	{
		instance.secondsAlive = secondsAlive;
		instance.metersWalked = metersWalked;
		instance.metersRun = metersRun;
		instance.secondsSleeping = secondsSleeping;
		instance.timeBorn = timeBorn;
		instance.timeDied = timeDied;
		instance.secondsWilderness = secondsWilderness;
		instance.secondsSwimming = secondsSwimming;
		instance.secondsInBase = secondsInBase;
		instance.secondsInMonument = secondsInMonument;
		instance.secondsFlying = secondsFlying;
		instance.secondsBoating = secondsBoating;
		instance.secondsDriving = secondsDriving;
		instance.totalDamageTaken = totalDamageTaken;
		instance.totalHealing = totalHealing;
		if (deathInfo != null)
		{
			if (instance.deathInfo == null)
			{
				instance.deathInfo = deathInfo.Copy();
			}
			else
			{
				deathInfo.CopyTo(instance.deathInfo);
			}
		}
		else
		{
			instance.deathInfo = null;
		}
		if (weaponStats != null)
		{
			instance.weaponStats = Pool.Get<List<WeaponStats>>();
			for (int i = 0; i < weaponStats.Count; i++)
			{
				WeaponStats item = weaponStats[i].Copy();
				instance.weaponStats.Add(item);
			}
		}
		else
		{
			instance.weaponStats = null;
		}
		instance.killedPlayers = killedPlayers;
		instance.killedScientists = killedScientists;
		instance.killedAnimals = killedAnimals;
		if (genericStats != null)
		{
			instance.genericStats = Pool.Get<List<GenericStat>>();
			for (int j = 0; j < genericStats.Count; j++)
			{
				GenericStat item2 = genericStats[j].Copy();
				instance.genericStats.Add(item2);
			}
		}
		else
		{
			instance.genericStats = null;
		}
	}

	public PlayerLifeStory Copy()
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		CopyTo(playerLifeStory);
		return playerLifeStory;
	}

	public static PlayerLifeStory Deserialize(BufferStream stream)
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		Deserialize(stream, playerLifeStory, isDelta: false);
		return playerLifeStory;
	}

	public static PlayerLifeStory DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		DeserializeLengthDelimited(stream, playerLifeStory, isDelta: false);
		return playerLifeStory;
	}

	public static PlayerLifeStory DeserializeLength(BufferStream stream, int length)
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		DeserializeLength(stream, length, playerLifeStory, isDelta: false);
		return playerLifeStory;
	}

	public static PlayerLifeStory Deserialize(byte[] buffer)
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerLifeStory, isDelta: false);
		return playerLifeStory;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerLifeStory previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerLifeStory Deserialize(BufferStream stream, PlayerLifeStory instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.weaponStats == null)
			{
				instance.weaponStats = Pool.Get<List<WeaponStats>>();
			}
			if (instance.genericStats == null)
			{
				instance.genericStats = Pool.Get<List<GenericStat>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsAlive = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 101u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersWalked = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 102u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersRun = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 103u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSleeping = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 104u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeBorn = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 105u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeDied = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 110u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsWilderness = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 111u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSwimming = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 112u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInBase = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 113u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInMonument = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 114u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsFlying = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 115u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsBoating = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 116u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsDriving = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 150u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalDamageTaken = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 151u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalHealing = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 200u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.deathInfo == null)
					{
						instance.deathInfo = DeathInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						DeathInfo.DeserializeLengthDelimited(stream, instance.deathInfo, isDelta);
					}
				}
				break;
			case 300u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.weaponStats.Add(WeaponStats.DeserializeLengthDelimited(stream));
				}
				break;
			case 301u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 302u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedScientists = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 303u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedAnimals = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 400u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.genericStats.Add(GenericStat.DeserializeLengthDelimited(stream));
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	public static PlayerLifeStory DeserializeLengthDelimited(BufferStream stream, PlayerLifeStory instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.weaponStats == null)
			{
				instance.weaponStats = Pool.Get<List<WeaponStats>>();
			}
			if (instance.genericStats == null)
			{
				instance.genericStats = Pool.Get<List<GenericStat>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsAlive = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 101u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersWalked = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 102u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersRun = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 103u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSleeping = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 104u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeBorn = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 105u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeDied = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 110u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsWilderness = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 111u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSwimming = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 112u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInBase = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 113u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInMonument = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 114u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsFlying = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 115u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsBoating = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 116u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsDriving = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 150u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalDamageTaken = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 151u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalHealing = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 200u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.deathInfo == null)
					{
						instance.deathInfo = DeathInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						DeathInfo.DeserializeLengthDelimited(stream, instance.deathInfo, isDelta);
					}
				}
				break;
			case 300u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.weaponStats.Add(WeaponStats.DeserializeLengthDelimited(stream));
				}
				break;
			case 301u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 302u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedScientists = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 303u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedAnimals = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 400u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.genericStats.Add(GenericStat.DeserializeLengthDelimited(stream));
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	public static PlayerLifeStory DeserializeLength(BufferStream stream, int length, PlayerLifeStory instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.weaponStats == null)
			{
				instance.weaponStats = Pool.Get<List<WeaponStats>>();
			}
			if (instance.genericStats == null)
			{
				instance.genericStats = Pool.Get<List<GenericStat>>();
			}
		}
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsAlive = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 101u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersWalked = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 102u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersRun = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 103u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSleeping = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 104u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeBorn = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 105u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeDied = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 110u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsWilderness = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 111u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSwimming = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 112u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInBase = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 113u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInMonument = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 114u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsFlying = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 115u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsBoating = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 116u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsDriving = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 150u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalDamageTaken = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 151u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalHealing = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 200u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.deathInfo == null)
					{
						instance.deathInfo = DeathInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						DeathInfo.DeserializeLengthDelimited(stream, instance.deathInfo, isDelta);
					}
				}
				break;
			case 300u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.weaponStats.Add(WeaponStats.DeserializeLengthDelimited(stream));
				}
				break;
			case 301u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 302u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedScientists = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 303u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedAnimals = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 400u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.genericStats.Add(GenericStat.DeserializeLengthDelimited(stream));
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerLifeStory instance, PlayerLifeStory previous)
	{
		if (instance.secondsAlive != previous.secondsAlive)
		{
			stream.WriteByte(165);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsAlive);
		}
		if (instance.metersWalked != previous.metersWalked)
		{
			stream.WriteByte(173);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.metersWalked);
		}
		if (instance.metersRun != previous.metersRun)
		{
			stream.WriteByte(181);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.metersRun);
		}
		if (instance.secondsSleeping != previous.secondsSleeping)
		{
			stream.WriteByte(189);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsSleeping);
		}
		if (instance.timeBorn != previous.timeBorn)
		{
			stream.WriteByte(192);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt32(stream, instance.timeBorn);
		}
		if (instance.timeDied != previous.timeDied)
		{
			stream.WriteByte(200);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt32(stream, instance.timeDied);
		}
		if (instance.secondsWilderness != previous.secondsWilderness)
		{
			stream.WriteByte(245);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsWilderness);
		}
		if (instance.secondsSwimming != previous.secondsSwimming)
		{
			stream.WriteByte(253);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsSwimming);
		}
		if (instance.secondsInBase != previous.secondsInBase)
		{
			stream.WriteByte(133);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsInBase);
		}
		if (instance.secondsInMonument != previous.secondsInMonument)
		{
			stream.WriteByte(141);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsInMonument);
		}
		if (instance.secondsFlying != previous.secondsFlying)
		{
			stream.WriteByte(149);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsFlying);
		}
		if (instance.secondsBoating != previous.secondsBoating)
		{
			stream.WriteByte(157);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsBoating);
		}
		if (instance.secondsDriving != previous.secondsDriving)
		{
			stream.WriteByte(165);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsDriving);
		}
		if (instance.totalDamageTaken != previous.totalDamageTaken)
		{
			stream.WriteByte(181);
			stream.WriteByte(9);
			ProtocolParser.WriteSingle(stream, instance.totalDamageTaken);
		}
		if (instance.totalHealing != previous.totalHealing)
		{
			stream.WriteByte(189);
			stream.WriteByte(9);
			ProtocolParser.WriteSingle(stream, instance.totalHealing);
		}
		if (instance.deathInfo != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(12);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			DeathInfo.SerializeDelta(stream, instance.deathInfo, previous.deathInfo);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.weaponStats != null)
		{
			for (int i = 0; i < instance.weaponStats.Count; i++)
			{
				WeaponStats weaponStats = instance.weaponStats[i];
				stream.WriteByte(226);
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WeaponStats.SerializeDelta(stream, weaponStats, weaponStats);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.killedPlayers != previous.killedPlayers)
		{
			stream.WriteByte(232);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedPlayers);
		}
		if (instance.killedScientists != previous.killedScientists)
		{
			stream.WriteByte(240);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedScientists);
		}
		if (instance.killedAnimals != previous.killedAnimals)
		{
			stream.WriteByte(248);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedAnimals);
		}
		if (instance.genericStats == null)
		{
			return;
		}
		for (int j = 0; j < instance.genericStats.Count; j++)
		{
			GenericStat genericStat = instance.genericStats[j];
			stream.WriteByte(130);
			stream.WriteByte(25);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			GenericStat.SerializeDelta(stream, genericStat, genericStat);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, PlayerLifeStory instance)
	{
		if (instance.secondsAlive != 0f)
		{
			stream.WriteByte(165);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsAlive);
		}
		if (instance.metersWalked != 0f)
		{
			stream.WriteByte(173);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.metersWalked);
		}
		if (instance.metersRun != 0f)
		{
			stream.WriteByte(181);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.metersRun);
		}
		if (instance.secondsSleeping != 0f)
		{
			stream.WriteByte(189);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsSleeping);
		}
		if (instance.timeBorn != 0)
		{
			stream.WriteByte(192);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt32(stream, instance.timeBorn);
		}
		if (instance.timeDied != 0)
		{
			stream.WriteByte(200);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt32(stream, instance.timeDied);
		}
		if (instance.secondsWilderness != 0f)
		{
			stream.WriteByte(245);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsWilderness);
		}
		if (instance.secondsSwimming != 0f)
		{
			stream.WriteByte(253);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsSwimming);
		}
		if (instance.secondsInBase != 0f)
		{
			stream.WriteByte(133);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsInBase);
		}
		if (instance.secondsInMonument != 0f)
		{
			stream.WriteByte(141);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsInMonument);
		}
		if (instance.secondsFlying != 0f)
		{
			stream.WriteByte(149);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsFlying);
		}
		if (instance.secondsBoating != 0f)
		{
			stream.WriteByte(157);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsBoating);
		}
		if (instance.secondsDriving != 0f)
		{
			stream.WriteByte(165);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsDriving);
		}
		if (instance.totalDamageTaken != 0f)
		{
			stream.WriteByte(181);
			stream.WriteByte(9);
			ProtocolParser.WriteSingle(stream, instance.totalDamageTaken);
		}
		if (instance.totalHealing != 0f)
		{
			stream.WriteByte(189);
			stream.WriteByte(9);
			ProtocolParser.WriteSingle(stream, instance.totalHealing);
		}
		if (instance.deathInfo != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(12);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			DeathInfo.Serialize(stream, instance.deathInfo);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.weaponStats != null)
		{
			for (int i = 0; i < instance.weaponStats.Count; i++)
			{
				WeaponStats instance2 = instance.weaponStats[i];
				stream.WriteByte(226);
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WeaponStats.Serialize(stream, instance2);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.killedPlayers != 0)
		{
			stream.WriteByte(232);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedPlayers);
		}
		if (instance.killedScientists != 0)
		{
			stream.WriteByte(240);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedScientists);
		}
		if (instance.killedAnimals != 0)
		{
			stream.WriteByte(248);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedAnimals);
		}
		if (instance.genericStats == null)
		{
			return;
		}
		for (int j = 0; j < instance.genericStats.Count; j++)
		{
			GenericStat instance3 = instance.genericStats[j];
			stream.WriteByte(130);
			stream.WriteByte(25);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			GenericStat.Serialize(stream, instance3);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		deathInfo?.InspectUids(action);
		if (weaponStats != null)
		{
			for (int i = 0; i < weaponStats.Count; i++)
			{
				weaponStats[i]?.InspectUids(action);
			}
		}
		if (genericStats != null)
		{
			for (int j = 0; j < genericStats.Count; j++)
			{
				genericStats[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MapNote : IDisposable, IPooled, IProto<MapNote>, IProto
{
	[NonSerialized]
	public int noteType;

	[NonSerialized]
	public Vector3 worldPosition;

	[NonSerialized]
	public int icon;

	[NonSerialized]
	public int colourIndex;

	[NonSerialized]
	public string label;

	[NonSerialized]
	public bool isPing;

	[NonSerialized]
	public float timeRemaining;

	[NonSerialized]
	public float totalDuration;

	[NonSerialized]
	public NetworkableId associatedId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MapNote instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.noteType = 0;
			instance.worldPosition = default(Vector3);
			instance.icon = 0;
			instance.colourIndex = 0;
			instance.label = string.Empty;
			instance.isPing = false;
			instance.timeRemaining = 0f;
			instance.totalDuration = 0f;
			instance.associatedId = default(NetworkableId);
			Pool.Free<MapNote>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MapNote with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MapNote instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.noteType = noteType;
		instance.worldPosition = worldPosition;
		instance.icon = icon;
		instance.colourIndex = colourIndex;
		instance.label = label;
		instance.isPing = isPing;
		instance.timeRemaining = timeRemaining;
		instance.totalDuration = totalDuration;
		instance.associatedId = associatedId;
	}

	public MapNote Copy()
	{
		MapNote mapNote = Pool.Get<MapNote>();
		CopyTo(mapNote);
		return mapNote;
	}

	public static MapNote Deserialize(BufferStream stream)
	{
		MapNote mapNote = Pool.Get<MapNote>();
		Deserialize(stream, mapNote, isDelta: false);
		return mapNote;
	}

	public static MapNote DeserializeLengthDelimited(BufferStream stream)
	{
		MapNote mapNote = Pool.Get<MapNote>();
		DeserializeLengthDelimited(stream, mapNote, isDelta: false);
		return mapNote;
	}

	public static MapNote DeserializeLength(BufferStream stream, int length)
	{
		MapNote mapNote = Pool.Get<MapNote>();
		DeserializeLength(stream, length, mapNote, isDelta: false);
		return mapNote;
	}

	public static MapNote Deserialize(byte[] buffer)
	{
		MapNote mapNote = Pool.Get<MapNote>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mapNote, isDelta: false);
		return mapNote;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MapNote previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MapNote Deserialize(BufferStream stream, MapNote instance, bool isDelta)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 24:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.isPing = ProtocolParser.ReadBool(stream);
				continue;
			case 61:
				instance.timeRemaining = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.totalDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.associatedId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MapNote DeserializeLengthDelimited(BufferStream stream, MapNote instance, bool isDelta)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 24:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.isPing = ProtocolParser.ReadBool(stream);
				continue;
			case 61:
				instance.timeRemaining = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.totalDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.associatedId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MapNote DeserializeLength(BufferStream stream, int length, MapNote instance, bool isDelta)
	{
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 24:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.isPing = ProtocolParser.ReadBool(stream);
				continue;
			case 61:
				instance.timeRemaining = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.totalDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.associatedId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MapNote instance, MapNote previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.noteType != previous.noteType)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
		if (instance.worldPosition != previous.worldPosition)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.worldPosition, previous.worldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.icon != previous.icon)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != previous.colourIndex)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null && instance.label != previous.label)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.label);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.isPing);
		if (instance.timeRemaining != previous.timeRemaining)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.timeRemaining);
		}
		if (instance.totalDuration != previous.totalDuration)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.totalDuration);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteUInt64(stream, instance.associatedId.Value);
	}

	public static void Serialize(BufferStream stream, MapNote instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.noteType != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
		if (instance.worldPosition != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.worldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.icon != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.label);
		}
		if (instance.isPing)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.isPing);
		}
		if (instance.timeRemaining != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.timeRemaining);
		}
		if (instance.totalDuration != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.totalDuration);
		}
		if (instance.associatedId != default(NetworkableId))
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, instance.associatedId.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref associatedId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MapNoteList : IDisposable, IPooled, IProto<MapNoteList>, IProto
{
	[NonSerialized]
	public List<MapNote> notes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MapNoteList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.notes != null)
		{
			for (int i = 0; i < instance.notes.Count; i++)
			{
				if (instance.notes[i] != null)
				{
					instance.notes[i].ResetToPool();
					instance.notes[i] = null;
				}
			}
			List<MapNote> list = instance.notes;
			Pool.Free<MapNote>(ref list, false);
			instance.notes = list;
		}
		Pool.Free<MapNoteList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MapNoteList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MapNoteList instance)
	{
		if (notes != null)
		{
			instance.notes = Pool.Get<List<MapNote>>();
			for (int i = 0; i < notes.Count; i++)
			{
				MapNote item = notes[i].Copy();
				instance.notes.Add(item);
			}
		}
		else
		{
			instance.notes = null;
		}
	}

	public MapNoteList Copy()
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		CopyTo(mapNoteList);
		return mapNoteList;
	}

	public static MapNoteList Deserialize(BufferStream stream)
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		Deserialize(stream, mapNoteList, isDelta: false);
		return mapNoteList;
	}

	public static MapNoteList DeserializeLengthDelimited(BufferStream stream)
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		DeserializeLengthDelimited(stream, mapNoteList, isDelta: false);
		return mapNoteList;
	}

	public static MapNoteList DeserializeLength(BufferStream stream, int length)
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		DeserializeLength(stream, length, mapNoteList, isDelta: false);
		return mapNoteList;
	}

	public static MapNoteList Deserialize(byte[] buffer)
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mapNoteList, isDelta: false);
		return mapNoteList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MapNoteList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MapNoteList Deserialize(BufferStream stream, MapNoteList instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<MapNote>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.notes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MapNoteList DeserializeLengthDelimited(BufferStream stream, MapNoteList instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<MapNote>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.notes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MapNoteList DeserializeLength(BufferStream stream, int length, MapNoteList instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<MapNote>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.notes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MapNoteList instance, MapNoteList previous)
	{
		if (instance.notes == null)
		{
			return;
		}
		for (int i = 0; i < instance.notes.Count; i++)
		{
			MapNote mapNote = instance.notes[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			MapNote.SerializeDelta(stream, mapNote, mapNote);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, MapNoteList instance)
	{
		if (instance.notes == null)
		{
			return;
		}
		for (int i = 0; i < instance.notes.Count; i++)
		{
			MapNote instance2 = instance.notes[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			MapNote.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (notes != null)
		{
			for (int i = 0; i < notes.Count; i++)
			{
				notes[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ItemCrafter : IDisposable, IPooled, IProto<ItemCrafter>, IProto
{
	public class Task : IDisposable, IPooled, IProto<Task>, IProto
	{
		[NonSerialized]
		public int itemID;

		[NonSerialized]
		public float remainingTime;

		[NonSerialized]
		public int taskUID;

		[NonSerialized]
		public bool cancelled;

		[NonSerialized]
		public Item.InstanceData instanceData;

		[NonSerialized]
		public int amount;

		[NonSerialized]
		public int skinID;

		[NonSerialized]
		public List<Item> takenItems;

		[NonSerialized]
		public int numCrafted;

		[NonSerialized]
		public float conditionScale;

		[NonSerialized]
		public NetworkableId workbenchEntity;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Task instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			instance.itemID = 0;
			instance.remainingTime = 0f;
			instance.taskUID = 0;
			instance.cancelled = false;
			if (instance.instanceData != null)
			{
				instance.instanceData.ResetToPool();
				instance.instanceData = null;
			}
			instance.amount = 0;
			instance.skinID = 0;
			if (instance.takenItems != null)
			{
				for (int i = 0; i < instance.takenItems.Count; i++)
				{
					if (instance.takenItems[i] != null)
					{
						instance.takenItems[i].ResetToPool();
						instance.takenItems[i] = null;
					}
				}
				List<Item> list = instance.takenItems;
				Pool.Free<Item>(ref list, false);
				instance.takenItems = list;
			}
			instance.numCrafted = 0;
			instance.conditionScale = 0f;
			instance.workbenchEntity = default(NetworkableId);
			Pool.Free<Task>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Task with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Task instance)
		{
			instance.itemID = itemID;
			instance.remainingTime = remainingTime;
			instance.taskUID = taskUID;
			instance.cancelled = cancelled;
			if (instanceData != null)
			{
				if (instance.instanceData == null)
				{
					instance.instanceData = instanceData.Copy();
				}
				else
				{
					instanceData.CopyTo(instance.instanceData);
				}
			}
			else
			{
				instance.instanceData = null;
			}
			instance.amount = amount;
			instance.skinID = skinID;
			if (takenItems != null)
			{
				instance.takenItems = Pool.Get<List<Item>>();
				for (int i = 0; i < takenItems.Count; i++)
				{
					Item item = takenItems[i].Copy();
					instance.takenItems.Add(item);
				}
			}
			else
			{
				instance.takenItems = null;
			}
			instance.numCrafted = numCrafted;
			instance.conditionScale = conditionScale;
			instance.workbenchEntity = workbenchEntity;
		}

		public Task Copy()
		{
			Task task = Pool.Get<Task>();
			CopyTo(task);
			return task;
		}

		public static Task Deserialize(BufferStream stream)
		{
			Task task = Pool.Get<Task>();
			Deserialize(stream, task, isDelta: false);
			return task;
		}

		public static Task DeserializeLengthDelimited(BufferStream stream)
		{
			Task task = Pool.Get<Task>();
			DeserializeLengthDelimited(stream, task, isDelta: false);
			return task;
		}

		public static Task DeserializeLength(BufferStream stream, int length)
		{
			Task task = Pool.Get<Task>();
			DeserializeLength(stream, length, task, isDelta: false);
			return task;
		}

		public static Task Deserialize(byte[] buffer)
		{
			Task task = Pool.Get<Task>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, task, isDelta: false);
			return task;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Task previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Task Deserialize(BufferStream stream, Task instance, bool isDelta)
		{
			if (!isDelta && instance.takenItems == null)
			{
				instance.takenItems = Pool.Get<List<Item>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 21:
					instance.remainingTime = ProtocolParser.ReadSingle(stream);
					break;
				case 24:
					instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 32:
					instance.cancelled = ProtocolParser.ReadBool(stream);
					break;
				case 42:
					if (instance.instanceData == null)
					{
						instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
					}
					else
					{
						Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
					}
					break;
				case 48:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 56:
					instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 66:
					instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
					break;
				case 72:
					instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 85:
					instance.conditionScale = ProtocolParser.ReadSingle(stream);
					break;
				case 88:
					instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
					return instance;
				}
			}
		}

		public static Task DeserializeLengthDelimited(BufferStream stream, Task instance, bool isDelta)
		{
			if (!isDelta && instance.takenItems == null)
			{
				instance.takenItems = Pool.Get<List<Item>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 21:
					instance.remainingTime = ProtocolParser.ReadSingle(stream);
					break;
				case 24:
					instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 32:
					instance.cancelled = ProtocolParser.ReadBool(stream);
					break;
				case 42:
					if (instance.instanceData == null)
					{
						instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
					}
					else
					{
						Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
					}
					break;
				case 48:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 56:
					instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 66:
					instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
					break;
				case 72:
					instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 85:
					instance.conditionScale = ProtocolParser.ReadSingle(stream);
					break;
				case 88:
					instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Task DeserializeLength(BufferStream stream, int length, Task instance, bool isDelta)
		{
			if (!isDelta && instance.takenItems == null)
			{
				instance.takenItems = Pool.Get<List<Item>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 21:
					instance.remainingTime = ProtocolParser.ReadSingle(stream);
					break;
				case 24:
					instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 32:
					instance.cancelled = ProtocolParser.ReadBool(stream);
					break;
				case 42:
					if (instance.instanceData == null)
					{
						instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
					}
					else
					{
						Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
					}
					break;
				case 48:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 56:
					instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 66:
					instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
					break;
				case 72:
					instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 85:
					instance.conditionScale = ProtocolParser.ReadSingle(stream);
					break;
				case 88:
					instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Task instance, Task previous)
		{
			if (instance.itemID != previous.itemID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
			}
			if (instance.remainingTime != previous.remainingTime)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.remainingTime);
			}
			if (instance.taskUID != previous.taskUID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.taskUID);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.cancelled);
			if (instance.instanceData != null)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Item.InstanceData.SerializeDelta(stream, instance.instanceData, previous.instanceData);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.amount != previous.amount)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
			}
			if (instance.skinID != previous.skinID)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.skinID);
			}
			if (instance.takenItems != null)
			{
				for (int i = 0; i < instance.takenItems.Count; i++)
				{
					Item item = instance.takenItems[i];
					stream.WriteByte(66);
					BufferStream.RangeHandle range2 = stream.GetRange(5);
					int position2 = stream.Position;
					Item.SerializeDelta(stream, item, item);
					int val = stream.Position - position2;
					Span<byte> span2 = range2.GetSpan();
					int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
					if (num2 < 5)
					{
						span2[num2 - 1] |= 128;
						while (num2 < 4)
						{
							span2[num2++] = 128;
						}
						span2[4] = 0;
					}
				}
			}
			if (instance.numCrafted != previous.numCrafted)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.numCrafted);
			}
			if (instance.conditionScale != previous.conditionScale)
			{
				stream.WriteByte(85);
				ProtocolParser.WriteSingle(stream, instance.conditionScale);
			}
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, instance.workbenchEntity.Value);
		}

		public static void Serialize(BufferStream stream, Task instance)
		{
			if (instance.itemID != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
			}
			if (instance.remainingTime != 0f)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.remainingTime);
			}
			if (instance.taskUID != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.taskUID);
			}
			if (instance.cancelled)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteBool(stream, instance.cancelled);
			}
			if (instance.instanceData != null)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Item.InstanceData.Serialize(stream, instance.instanceData);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.amount != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
			}
			if (instance.skinID != 0)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.skinID);
			}
			if (instance.takenItems != null)
			{
				for (int i = 0; i < instance.takenItems.Count; i++)
				{
					Item instance2 = instance.takenItems[i];
					stream.WriteByte(66);
					BufferStream.RangeHandle range2 = stream.GetRange(5);
					int position2 = stream.Position;
					Item.Serialize(stream, instance2);
					int val = stream.Position - position2;
					Span<byte> span2 = range2.GetSpan();
					int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
					if (num2 < 5)
					{
						span2[num2 - 1] |= 128;
						while (num2 < 4)
						{
							span2[num2++] = 128;
						}
						span2[4] = 0;
					}
				}
			}
			if (instance.numCrafted != 0)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.numCrafted);
			}
			if (instance.conditionScale != 0f)
			{
				stream.WriteByte(85);
				ProtocolParser.WriteSingle(stream, instance.conditionScale);
			}
			if (instance.workbenchEntity != default(NetworkableId))
			{
				stream.WriteByte(88);
				ProtocolParser.WriteUInt64(stream, instance.workbenchEntity.Value);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			instanceData?.InspectUids(action);
			if (takenItems != null)
			{
				for (int i = 0; i < takenItems.Count; i++)
				{
					takenItems[i]?.InspectUids(action);
				}
			}
			action(UidType.Clear, ref workbenchEntity.Value);
		}
	}

	[NonSerialized]
	public List<Task> queue;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemCrafter instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.queue != null)
		{
			for (int i = 0; i < instance.queue.Count; i++)
			{
				if (instance.queue[i] != null)
				{
					instance.queue[i].ResetToPool();
					instance.queue[i] = null;
				}
			}
			List<Task> list = instance.queue;
			Pool.Free<Task>(ref list, false);
			instance.queue = list;
		}
		Pool.Free<ItemCrafter>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemCrafter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemCrafter instance)
	{
		if (queue != null)
		{
			instance.queue = Pool.Get<List<Task>>();
			for (int i = 0; i < queue.Count; i++)
			{
				Task item = queue[i].Copy();
				instance.queue.Add(item);
			}
		}
		else
		{
			instance.queue = null;
		}
	}

	public ItemCrafter Copy()
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		CopyTo(itemCrafter);
		return itemCrafter;
	}

	public static ItemCrafter Deserialize(BufferStream stream)
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		Deserialize(stream, itemCrafter, isDelta: false);
		return itemCrafter;
	}

	public static ItemCrafter DeserializeLengthDelimited(BufferStream stream)
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		DeserializeLengthDelimited(stream, itemCrafter, isDelta: false);
		return itemCrafter;
	}

	public static ItemCrafter DeserializeLength(BufferStream stream, int length)
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		DeserializeLength(stream, length, itemCrafter, isDelta: false);
		return itemCrafter;
	}

	public static ItemCrafter Deserialize(byte[] buffer)
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemCrafter, isDelta: false);
		return itemCrafter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemCrafter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemCrafter Deserialize(BufferStream stream, ItemCrafter instance, bool isDelta)
	{
		if (!isDelta && instance.queue == null)
		{
			instance.queue = Pool.Get<List<Task>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.queue.Add(Task.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemCrafter DeserializeLengthDelimited(BufferStream stream, ItemCrafter instance, bool isDelta)
	{
		if (!isDelta && instance.queue == null)
		{
			instance.queue = Pool.Get<List<Task>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.queue.Add(Task.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemCrafter DeserializeLength(BufferStream stream, int length, ItemCrafter instance, bool isDelta)
	{
		if (!isDelta && instance.queue == null)
		{
			instance.queue = Pool.Get<List<Task>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.queue.Add(Task.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemCrafter instance, ItemCrafter previous)
	{
		if (instance.queue == null)
		{
			return;
		}
		for (int i = 0; i < instance.queue.Count; i++)
		{
			Task task = instance.queue[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Task.SerializeDelta(stream, task, task);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ItemCrafter instance)
	{
		if (instance.queue == null)
		{
			return;
		}
		for (int i = 0; i < instance.queue.Count; i++)
		{
			Task instance2 = instance.queue[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Task.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (queue != null)
		{
			for (int i = 0; i < queue.Count; i++)
			{
				queue[i]?.InspectUids(action);
			}
		}
	}
}


