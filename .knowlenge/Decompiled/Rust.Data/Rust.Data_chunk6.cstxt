using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class SpawnOptions : IDisposable, IPooled, IProto<SpawnOptions>, IProto
{
	public enum RespawnType
	{
		SleepingBag = 1,
		Bed,
		BeachTowel,
		Camper,
		Static
	}

	public enum RespawnState
	{
		OK = 1,
		Occupied,
		Underwater,
		InNoRespawnZone
	}

	[NonSerialized]
	public RespawnType type;

	[NonSerialized]
	public NetworkableId id;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public float unlockSeconds;

	[NonSerialized]
	public Vector3 worldPosition;

	[NonSerialized]
	public RespawnState respawnState;

	[NonSerialized]
	public bool mobile;

	[NonSerialized]
	public string nexusZone;

	[NonSerialized]
	public bool corpse;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpawnOptions instance)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.type = (RespawnType)0;
			instance.id = default(NetworkableId);
			instance.name = string.Empty;
			instance.unlockSeconds = 0f;
			instance.worldPosition = default(Vector3);
			instance.respawnState = (RespawnState)0;
			instance.mobile = false;
			instance.nexusZone = string.Empty;
			instance.corpse = false;
			Pool.Free<SpawnOptions>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpawnOptions with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpawnOptions instance)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.type = type;
		instance.id = id;
		instance.name = name;
		instance.unlockSeconds = unlockSeconds;
		instance.worldPosition = worldPosition;
		instance.respawnState = respawnState;
		instance.mobile = mobile;
		instance.nexusZone = nexusZone;
		instance.corpse = corpse;
	}

	public SpawnOptions Copy()
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		CopyTo(spawnOptions);
		return spawnOptions;
	}

	public static SpawnOptions Deserialize(BufferStream stream)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		Deserialize(stream, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public static SpawnOptions DeserializeLengthDelimited(BufferStream stream)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		DeserializeLengthDelimited(stream, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public static SpawnOptions DeserializeLength(BufferStream stream, int length)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		DeserializeLength(stream, length, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public static SpawnOptions Deserialize(byte[] buffer)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpawnOptions previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpawnOptions Deserialize(BufferStream stream, SpawnOptions instance, bool isDelta)
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.respawnState = RespawnState.OK;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 37:
				instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 48:
				instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.corpse = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpawnOptions DeserializeLengthDelimited(BufferStream stream, SpawnOptions instance, bool isDelta)
	{
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.respawnState = RespawnState.OK;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 37:
				instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 48:
				instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.corpse = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpawnOptions DeserializeLength(BufferStream stream, int length, SpawnOptions instance, bool isDelta)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.respawnState = RespawnState.OK;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 37:
				instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 48:
				instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.corpse = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpawnOptions instance, SpawnOptions previous)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.id.Value);
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.unlockSeconds != previous.unlockSeconds)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
		}
		if (instance.worldPosition != previous.worldPosition)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.worldPosition, previous.worldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.mobile);
		if (instance.nexusZone != null && instance.nexusZone != previous.nexusZone)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.corpse);
	}

	public static void Serialize(BufferStream stream, SpawnOptions instance)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.id != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.id.Value);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.unlockSeconds != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
		}
		if (instance.worldPosition != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.worldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
		if (instance.mobile)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.mobile);
		}
		if (instance.nexusZone != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		if (instance.corpse)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.corpse);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref id.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ClientInfo : IDisposable, IPooled, IProto<ClientInfo>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public string value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClientInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.value = string.Empty;
			Pool.Free<ClientInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClientInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClientInfo instance)
	{
		instance.name = name;
		instance.value = value;
	}

	public ClientInfo Copy()
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		CopyTo(clientInfo);
		return clientInfo;
	}

	public static ClientInfo Deserialize(BufferStream stream)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		Deserialize(stream, clientInfo, isDelta: false);
		return clientInfo;
	}

	public static ClientInfo DeserializeLengthDelimited(BufferStream stream)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		DeserializeLengthDelimited(stream, clientInfo, isDelta: false);
		return clientInfo;
	}

	public static ClientInfo DeserializeLength(BufferStream stream, int length)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		DeserializeLength(stream, length, clientInfo, isDelta: false);
		return clientInfo;
	}

	public static ClientInfo Deserialize(byte[] buffer)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clientInfo, isDelta: false);
		return clientInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClientInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClientInfo Deserialize(BufferStream stream, ClientInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.value = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClientInfo DeserializeLengthDelimited(BufferStream stream, ClientInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.value = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClientInfo DeserializeLength(BufferStream stream, int length, ClientInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.value = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClientInfo instance, ClientInfo previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.value != previous.value)
		{
			if (instance.value == null)
			{
				throw new ArgumentNullException("value", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, ClientInfo instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.value == null)
		{
			throw new ArgumentNullException("value", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.value);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum MessageType
{
	Request = 1,
	Receive,
	Done
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class arcadeEnt : IDisposable, IPooled, IProto<arcadeEnt>, IProto
{
	[NonSerialized]
	public uint id;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public uint spriteID;

	[NonSerialized]
	public uint soundID;

	[NonSerialized]
	public bool visible;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 heading;

	[NonSerialized]
	public bool enabled;

	[NonSerialized]
	public Vector3 scale;

	[NonSerialized]
	public Vector3 colliderScale;

	[NonSerialized]
	public float alpha;

	[NonSerialized]
	public uint prefabID;

	[NonSerialized]
	public uint parentID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(arcadeEnt instance)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.id = 0u;
			instance.name = string.Empty;
			instance.spriteID = 0u;
			instance.soundID = 0u;
			instance.visible = false;
			instance.position = default(Vector3);
			instance.heading = default(Vector3);
			instance.enabled = false;
			instance.scale = default(Vector3);
			instance.colliderScale = default(Vector3);
			instance.alpha = 0f;
			instance.prefabID = 0u;
			instance.parentID = 0u;
			Pool.Free<arcadeEnt>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose arcadeEnt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(arcadeEnt instance)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		instance.id = id;
		instance.name = name;
		instance.spriteID = spriteID;
		instance.soundID = soundID;
		instance.visible = visible;
		instance.position = position;
		instance.heading = heading;
		instance.enabled = enabled;
		instance.scale = scale;
		instance.colliderScale = colliderScale;
		instance.alpha = alpha;
		instance.prefabID = prefabID;
		instance.parentID = parentID;
	}

	public arcadeEnt Copy()
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		CopyTo(arcadeEnt);
		return arcadeEnt;
	}

	public static arcadeEnt Deserialize(BufferStream stream)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		Deserialize(stream, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public static arcadeEnt DeserializeLengthDelimited(BufferStream stream)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		DeserializeLengthDelimited(stream, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public static arcadeEnt DeserializeLength(BufferStream stream, int length)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		DeserializeLength(stream, length, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public static arcadeEnt Deserialize(byte[] buffer)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, arcadeEnt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static arcadeEnt Deserialize(BufferStream stream, arcadeEnt instance, bool isDelta)
	{
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.spriteID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.soundID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 40:
				instance.visible = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
				continue;
			case 64:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
				continue;
			case 93:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 96:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 104:
				instance.parentID = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static arcadeEnt DeserializeLengthDelimited(BufferStream stream, arcadeEnt instance, bool isDelta)
	{
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.spriteID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.soundID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 40:
				instance.visible = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
				continue;
			case 64:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
				continue;
			case 93:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 96:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 104:
				instance.parentID = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static arcadeEnt DeserializeLength(BufferStream stream, int length, arcadeEnt instance, bool isDelta)
	{
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.spriteID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.soundID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 40:
				instance.visible = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
				continue;
			case 64:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
				continue;
			case 93:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 96:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 104:
				instance.parentID = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, arcadeEnt instance, arcadeEnt previous)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		if (instance.id != previous.id)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.spriteID != previous.spriteID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.spriteID);
		}
		if (instance.soundID != previous.soundID)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.soundID);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.visible);
		if (instance.position != previous.position)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.heading != previous.heading)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.heading, previous.heading);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heading (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.enabled);
		if (instance.scale != previous.scale)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.scale, previous.scale);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.colliderScale != previous.colliderScale)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.colliderScale, previous.colliderScale);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colliderScale (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		if (instance.alpha != previous.alpha)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.prefabID != previous.prefabID)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.prefabID);
		}
		if (instance.parentID != previous.parentID)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt32(stream, instance.parentID);
		}
	}

	public static void Serialize(BufferStream stream, arcadeEnt instance)
	{
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		if (instance.id != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.spriteID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.spriteID);
		}
		if (instance.soundID != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.soundID);
		}
		if (instance.visible)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.visible);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.heading != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.heading);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heading (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.enabled)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.enabled);
		}
		if (instance.scale != default(Vector3))
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.scale);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.colliderScale != default(Vector3))
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.colliderScale);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colliderScale (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		if (instance.alpha != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.prefabID != 0)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.prefabID);
		}
		if (instance.parentID != 0)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt32(stream, instance.parentID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class DirectoryEntry : IDisposable, IPooled, IProto<DirectoryEntry>, IProto
{
	[NonSerialized]
	public int phoneNumber;

	[NonSerialized]
	public string phoneName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DirectoryEntry instance)
	{
		if (instance.ShouldPool)
		{
			instance.phoneNumber = 0;
			instance.phoneName = string.Empty;
			Pool.Free<DirectoryEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DirectoryEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DirectoryEntry instance)
	{
		instance.phoneNumber = phoneNumber;
		instance.phoneName = phoneName;
	}

	public DirectoryEntry Copy()
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		CopyTo(directoryEntry);
		return directoryEntry;
	}

	public static DirectoryEntry Deserialize(BufferStream stream)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		Deserialize(stream, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public static DirectoryEntry DeserializeLengthDelimited(BufferStream stream)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		DeserializeLengthDelimited(stream, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public static DirectoryEntry DeserializeLength(BufferStream stream, int length)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		DeserializeLength(stream, length, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public static DirectoryEntry Deserialize(byte[] buffer)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DirectoryEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DirectoryEntry Deserialize(BufferStream stream, DirectoryEntry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.phoneName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DirectoryEntry DeserializeLengthDelimited(BufferStream stream, DirectoryEntry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.phoneName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DirectoryEntry DeserializeLength(BufferStream stream, int length, DirectoryEntry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.phoneName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DirectoryEntry instance, DirectoryEntry previous)
	{
		if (instance.phoneNumber != previous.phoneNumber)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		if (instance.phoneName != previous.phoneName)
		{
			if (instance.phoneName == null)
			{
				throw new ArgumentNullException("phoneName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}
	}

	public static void Serialize(BufferStream stream, DirectoryEntry instance)
	{
		if (instance.phoneNumber != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		if (instance.phoneName == null)
		{
			throw new ArgumentNullException("phoneName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.phoneName);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum Category
{
	Line,
	Log,
	Text,
	Sphere,
	Box
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Monument : IDisposable, IPooled, IProto<Monument>, IProto
{
	[NonSerialized]
	public string token;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Monument instance)
	{
		if (instance.ShouldPool)
		{
			instance.token = string.Empty;
			instance.x = 0f;
			instance.y = 0f;
			Pool.Free<Monument>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Monument with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Monument instance)
	{
		instance.token = token;
		instance.x = x;
		instance.y = y;
	}

	public Monument Copy()
	{
		Monument monument = Pool.Get<Monument>();
		CopyTo(monument);
		return monument;
	}

	public static Monument Deserialize(BufferStream stream)
	{
		Monument monument = Pool.Get<Monument>();
		Deserialize(stream, monument, isDelta: false);
		return monument;
	}

	public static Monument DeserializeLengthDelimited(BufferStream stream)
	{
		Monument monument = Pool.Get<Monument>();
		DeserializeLengthDelimited(stream, monument, isDelta: false);
		return monument;
	}

	public static Monument DeserializeLength(BufferStream stream, int length)
	{
		Monument monument = Pool.Get<Monument>();
		DeserializeLength(stream, length, monument, isDelta: false);
		return monument;
	}

	public static Monument Deserialize(byte[] buffer)
	{
		Monument monument = Pool.Get<Monument>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, monument, isDelta: false);
		return monument;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Monument previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Monument Deserialize(BufferStream stream, Monument instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.token = ProtocolParser.ReadString(stream);
				continue;
			case 21:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Monument DeserializeLengthDelimited(BufferStream stream, Monument instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.token = ProtocolParser.ReadString(stream);
				continue;
			case 21:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Monument DeserializeLength(BufferStream stream, int length, Monument instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.token = ProtocolParser.ReadString(stream);
				continue;
			case 21:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Monument instance, Monument previous)
	{
		if (instance.token != previous.token)
		{
			if (instance.token == null)
			{
				throw new ArgumentNullException("token", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.token);
		}
		if (instance.x != previous.x)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
	}

	public static void Serialize(BufferStream stream, Monument instance)
	{
		if (instance.token == null)
		{
			throw new ArgumentNullException("token", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.token);
		if (instance.x != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Item : IDisposable, IPooled, IProto<Item>, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public int quantity;

	[NonSerialized]
	public bool itemIsBlueprint;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Item instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
			Pool.Free<Item>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Item with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Item instance)
	{
		instance.itemId = itemId;
		instance.quantity = quantity;
		instance.itemIsBlueprint = itemIsBlueprint;
	}

	public Item Copy()
	{
		Item item = Pool.Get<Item>();
		CopyTo(item);
		return item;
	}

	public static Item Deserialize(BufferStream stream)
	{
		Item item = Pool.Get<Item>();
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLengthDelimited(BufferStream stream)
	{
		Item item = Pool.Get<Item>();
		DeserializeLengthDelimited(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLength(BufferStream stream, int length)
	{
		Item item = Pool.Get<Item>();
		DeserializeLength(stream, length, item, isDelta: false);
		return item;
	}

	public static Item Deserialize(byte[] buffer)
	{
		Item item = Pool.Get<Item>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Item previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Item Deserialize(BufferStream stream, Item instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Item DeserializeLengthDelimited(BufferStream stream, Item instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Item DeserializeLength(BufferStream stream, int length, Item instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Item instance, Item previous)
	{
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != previous.quantity)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
	}

	public static void Serialize(BufferStream stream, Item instance)
	{
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		if (instance.itemIsBlueprint)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Member : IDisposable, IPooled, IProto<Member>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public bool isOnline;

	[NonSerialized]
	public uint spawnTime;

	[NonSerialized]
	public bool isAlive;

	[NonSerialized]
	public uint deathTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Member instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.name = string.Empty;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
			Pool.Free<Member>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Member with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Member instance)
	{
		instance.steamId = steamId;
		instance.name = name;
		instance.x = x;
		instance.y = y;
		instance.isOnline = isOnline;
		instance.spawnTime = spawnTime;
		instance.isAlive = isAlive;
		instance.deathTime = deathTime;
	}

	public Member Copy()
	{
		Member member = Pool.Get<Member>();
		CopyTo(member);
		return member;
	}

	public static Member Deserialize(BufferStream stream)
	{
		Member member = Pool.Get<Member>();
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLengthDelimited(BufferStream stream)
	{
		Member member = Pool.Get<Member>();
		DeserializeLengthDelimited(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLength(BufferStream stream, int length)
	{
		Member member = Pool.Get<Member>();
		DeserializeLength(stream, length, member, isDelta: false);
		return member;
	}

	public static Member Deserialize(byte[] buffer)
	{
		Member member = Pool.Get<Member>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Member previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Member Deserialize(BufferStream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.isOnline = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.spawnTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.isAlive = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.deathTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Member DeserializeLengthDelimited(BufferStream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.isOnline = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.spawnTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.isAlive = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.deathTime = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Member DeserializeLength(BufferStream stream, int length, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.isOnline = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.spawnTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.isAlive = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.deathTime = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Member instance, Member previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.x != previous.x)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.isOnline);
		if (instance.spawnTime != previous.spawnTime)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.spawnTime);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.isAlive);
		if (instance.deathTime != previous.deathTime)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.deathTime);
		}
	}

	public static void Serialize(BufferStream stream, Member instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.x != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.isOnline)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isOnline);
		}
		if (instance.spawnTime != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.spawnTime);
		}
		if (instance.isAlive)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isAlive);
		}
		if (instance.deathTime != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.deathTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Note : IDisposable, IPooled, IProto<Note>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public int icon;

	[NonSerialized]
	public int colourIndex;

	[NonSerialized]
	public string label;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Note instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
			instance.label = string.Empty;
			Pool.Free<Note>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Note with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Note instance)
	{
		instance.type = type;
		instance.x = x;
		instance.y = y;
		instance.icon = icon;
		instance.colourIndex = colourIndex;
		instance.label = label;
	}

	public Note Copy()
	{
		Note note = Pool.Get<Note>();
		CopyTo(note);
		return note;
	}

	public static Note Deserialize(BufferStream stream)
	{
		Note note = Pool.Get<Note>();
		Deserialize(stream, note, isDelta: false);
		return note;
	}

	public static Note DeserializeLengthDelimited(BufferStream stream)
	{
		Note note = Pool.Get<Note>();
		DeserializeLengthDelimited(stream, note, isDelta: false);
		return note;
	}

	public static Note DeserializeLength(BufferStream stream, int length)
	{
		Note note = Pool.Get<Note>();
		DeserializeLength(stream, length, note, isDelta: false);
		return note;
	}

	public static Note Deserialize(byte[] buffer)
	{
		Note note = Pool.Get<Note>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, note, isDelta: false);
		return note;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Note previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Note Deserialize(BufferStream stream, Note instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Note DeserializeLengthDelimited(BufferStream stream, Note instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Note DeserializeLength(BufferStream stream, int length, Note instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Note instance, Note previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.x != previous.x)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.icon != previous.icon)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != previous.colourIndex)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null && instance.label != previous.label)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteString(stream, instance.label);
		}
	}

	public static void Serialize(BufferStream stream, Note instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.x != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.icon != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteString(stream, instance.label);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SellOrder : IDisposable, IPooled, IProto<SellOrder>, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public int quantity;

	[NonSerialized]
	public int currencyId;

	[NonSerialized]
	public int costPerItem;

	[NonSerialized]
	public int amountInStock;

	[NonSerialized]
	public bool itemIsBlueprint;

	[NonSerialized]
	public bool currencyIsBlueprint;

	[NonSerialized]
	public float itemCondition;

	[NonSerialized]
	public float itemConditionMax;

	[NonSerialized]
	public float priceMultiplier;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SellOrder instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
			Pool.Free<SellOrder>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SellOrder with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SellOrder instance)
	{
		instance.itemId = itemId;
		instance.quantity = quantity;
		instance.currencyId = currencyId;
		instance.costPerItem = costPerItem;
		instance.amountInStock = amountInStock;
		instance.itemIsBlueprint = itemIsBlueprint;
		instance.currencyIsBlueprint = currencyIsBlueprint;
		instance.itemCondition = itemCondition;
		instance.itemConditionMax = itemConditionMax;
		instance.priceMultiplier = priceMultiplier;
	}

	public SellOrder Copy()
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		CopyTo(sellOrder);
		return sellOrder;
	}

	public static SellOrder Deserialize(BufferStream stream)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		Deserialize(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder DeserializeLengthDelimited(BufferStream stream)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		DeserializeLengthDelimited(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder DeserializeLength(BufferStream stream, int length)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		DeserializeLength(stream, length, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder Deserialize(byte[] buffer)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SellOrder previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SellOrder Deserialize(BufferStream stream, SellOrder instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SellOrder DeserializeLengthDelimited(BufferStream stream, SellOrder instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SellOrder DeserializeLength(BufferStream stream, int length, SellOrder instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SellOrder instance, SellOrder previous)
	{
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != previous.quantity)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		if (instance.currencyId != previous.currencyId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
		}
		if (instance.costPerItem != previous.costPerItem)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
		}
		if (instance.amountInStock != previous.amountInStock)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
		if (instance.itemCondition != previous.itemCondition)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.itemCondition);
		}
		if (instance.itemConditionMax != previous.itemConditionMax)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
		}
		if (instance.priceMultiplier != previous.priceMultiplier)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
		}
	}

	public static void Serialize(BufferStream stream, SellOrder instance)
	{
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		if (instance.currencyId != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
		}
		if (instance.costPerItem != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
		}
		if (instance.amountInStock != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
		}
		if (instance.itemIsBlueprint)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		}
		if (instance.currencyIsBlueprint)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
		}
		if (instance.itemCondition != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.itemCondition);
		}
		if (instance.itemConditionMax != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
		}
		if (instance.priceMultiplier != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum EntityType
{
	Tree = 1,
	Player
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Entity : IDisposable, IPooled, IProto<Entity>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public EntityType type;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 rotation;

	[NonSerialized]
	public Vector3 size;

	[NonSerialized]
	public string name;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entity instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.type = (EntityType)0;
			instance.position = default(Vector3);
			instance.rotation = default(Vector3);
			instance.size = default(Vector3);
			instance.name = string.Empty;
			Pool.Free<Entity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entity instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.entityId = entityId;
		instance.type = type;
		instance.position = position;
		instance.rotation = rotation;
		instance.size = size;
		instance.name = name;
	}

	public Entity Copy()
	{
		Entity entity = Pool.Get<Entity>();
		CopyTo(entity);
		return entity;
	}

	public static Entity Deserialize(BufferStream stream)
	{
		Entity entity = Pool.Get<Entity>();
		Deserialize(stream, entity, isDelta: false);
		return entity;
	}

	public static Entity DeserializeLengthDelimited(BufferStream stream)
	{
		Entity entity = Pool.Get<Entity>();
		DeserializeLengthDelimited(stream, entity, isDelta: false);
		return entity;
	}

	public static Entity DeserializeLength(BufferStream stream, int length)
	{
		Entity entity = Pool.Get<Entity>();
		DeserializeLength(stream, length, entity, isDelta: false);
		return entity;
	}

	public static Entity Deserialize(byte[] buffer)
	{
		Entity entity = Pool.Get<Entity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entity, isDelta: false);
		return entity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Entity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entity Deserialize(BufferStream stream, Entity instance, bool isDelta)
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 50:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entity DeserializeLengthDelimited(BufferStream stream, Entity instance, bool isDelta)
	{
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 50:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entity DeserializeLength(BufferStream stream, int length, Entity instance, bool isDelta)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 50:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Entity instance, Entity previous)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.position != previous.position)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rotation, previous.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.size != previous.size)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.size, previous.size);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public static void Serialize(BufferStream stream, Entity instance)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.size != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.size);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.name != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Role : IDisposable, IPooled, IProto<Role>, IProto
{
	[NonSerialized]
	public int roleId;

	[NonSerialized]
	public int rank;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public bool canSetMotd;

	[NonSerialized]
	public bool canSetLogo;

	[NonSerialized]
	public bool canInvite;

	[NonSerialized]
	public bool canKick;

	[NonSerialized]
	public bool canPromote;

	[NonSerialized]
	public bool canDemote;

	[NonSerialized]
	public bool canSetPlayerNotes;

	[NonSerialized]
	public bool canAccessLogs;

	[NonSerialized]
	public bool canAccessScoreEvents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Role instance)
	{
		if (instance.ShouldPool)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.name = string.Empty;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
			Pool.Free<Role>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Role with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Role instance)
	{
		instance.roleId = roleId;
		instance.rank = rank;
		instance.name = name;
		instance.canSetMotd = canSetMotd;
		instance.canSetLogo = canSetLogo;
		instance.canInvite = canInvite;
		instance.canKick = canKick;
		instance.canPromote = canPromote;
		instance.canDemote = canDemote;
		instance.canSetPlayerNotes = canSetPlayerNotes;
		instance.canAccessLogs = canAccessLogs;
		instance.canAccessScoreEvents = canAccessScoreEvents;
	}

	public Role Copy()
	{
		Role role = Pool.Get<Role>();
		CopyTo(role);
		return role;
	}

	public static Role Deserialize(BufferStream stream)
	{
		Role role = Pool.Get<Role>();
		Deserialize(stream, role, isDelta: false);
		return role;
	}

	public static Role DeserializeLengthDelimited(BufferStream stream)
	{
		Role role = Pool.Get<Role>();
		DeserializeLengthDelimited(stream, role, isDelta: false);
		return role;
	}

	public static Role DeserializeLength(BufferStream stream, int length)
	{
		Role role = Pool.Get<Role>();
		DeserializeLength(stream, length, role, isDelta: false);
		return role;
	}

	public static Role Deserialize(byte[] buffer)
	{
		Role role = Pool.Get<Role>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, role, isDelta: false);
		return role;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Role previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Role Deserialize(BufferStream stream, Role instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rank = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.canSetMotd = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.canSetLogo = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.canInvite = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.canKick = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.canPromote = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.canDemote = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.canAccessLogs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Role DeserializeLengthDelimited(BufferStream stream, Role instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rank = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.canSetMotd = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.canSetLogo = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.canInvite = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.canKick = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.canPromote = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.canDemote = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.canAccessLogs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Role DeserializeLength(BufferStream stream, int length, Role instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rank = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.canSetMotd = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.canSetLogo = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.canInvite = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.canKick = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.canPromote = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.canDemote = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.canAccessLogs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Role instance, Role previous)
	{
		if (instance.roleId != previous.roleId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		if (instance.rank != previous.rank)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.canSetMotd);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.canSetLogo);
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.canInvite);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.canKick);
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.canPromote);
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.canDemote);
		stream.WriteByte(80);
		ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
		stream.WriteByte(88);
		ProtocolParser.WriteBool(stream, instance.canAccessLogs);
		stream.WriteByte(96);
		ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
	}

	public static void Serialize(BufferStream stream, Role instance)
	{
		if (instance.roleId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		if (instance.rank != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.canSetMotd)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.canSetMotd);
		}
		if (instance.canSetLogo)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.canSetLogo);
		}
		if (instance.canInvite)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.canInvite);
		}
		if (instance.canKick)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.canKick);
		}
		if (instance.canPromote)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.canPromote);
		}
		if (instance.canDemote)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.canDemote);
		}
		if (instance.canSetPlayerNotes)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
		}
		if (instance.canAccessLogs)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteBool(stream, instance.canAccessLogs);
		}
		if (instance.canAccessScoreEvents)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Member : IDisposable, IPooled, IProto<Member>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public int roleId;

	[NonSerialized]
	public long joined;

	[NonSerialized]
	public long lastSeen;

	[NonSerialized]
	public string notes;

	[NonSerialized]
	public bool online;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Member instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.notes = string.Empty;
			instance.online = false;
			Pool.Free<Member>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Member with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Member instance)
	{
		instance.steamId = steamId;
		instance.roleId = roleId;
		instance.joined = joined;
		instance.lastSeen = lastSeen;
		instance.notes = notes;
		instance.online = online;
	}

	public Member Copy()
	{
		Member member = Pool.Get<Member>();
		CopyTo(member);
		return member;
	}

	public static Member Deserialize(BufferStream stream)
	{
		Member member = Pool.Get<Member>();
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLengthDelimited(BufferStream stream)
	{
		Member member = Pool.Get<Member>();
		DeserializeLengthDelimited(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLength(BufferStream stream, int length)
	{
		Member member = Pool.Get<Member>();
		DeserializeLength(stream, length, member, isDelta: false);
		return member;
	}

	public static Member Deserialize(byte[] buffer)
	{
		Member member = Pool.Get<Member>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Member previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Member Deserialize(BufferStream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.online = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.joined = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Member DeserializeLengthDelimited(BufferStream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.online = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.joined = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Member DeserializeLength(BufferStream stream, int length, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.online = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.joined = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Member instance, Member previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.roleId != previous.roleId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
		if (instance.notes != null && instance.notes != previous.notes)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.notes);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.online);
	}

	public static void Serialize(BufferStream stream, Member instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.roleId != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		if (instance.joined != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
		}
		if (instance.lastSeen != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
		}
		if (instance.notes != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.notes);
		}
		if (instance.online)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.online);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Invite : IDisposable, IPooled, IProto<Invite>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public ulong recruiter;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Invite instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
			Pool.Free<Invite>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Invite with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Invite instance)
	{
		instance.steamId = steamId;
		instance.recruiter = recruiter;
		instance.timestamp = timestamp;
	}

	public Invite Copy()
	{
		Invite invite = Pool.Get<Invite>();
		CopyTo(invite);
		return invite;
	}

	public static Invite Deserialize(BufferStream stream)
	{
		Invite invite = Pool.Get<Invite>();
		Deserialize(stream, invite, isDelta: false);
		return invite;
	}

	public static Invite DeserializeLengthDelimited(BufferStream stream)
	{
		Invite invite = Pool.Get<Invite>();
		DeserializeLengthDelimited(stream, invite, isDelta: false);
		return invite;
	}

	public static Invite DeserializeLength(BufferStream stream, int length)
	{
		Invite invite = Pool.Get<Invite>();
		DeserializeLength(stream, length, invite, isDelta: false);
		return invite;
	}

	public static Invite Deserialize(byte[] buffer)
	{
		Invite invite = Pool.Get<Invite>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, invite, isDelta: false);
		return invite;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Invite previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Invite Deserialize(BufferStream stream, Invite instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Invite DeserializeLengthDelimited(BufferStream stream, Invite instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Invite DeserializeLength(BufferStream stream, int length, Invite instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Invite instance, Invite previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.recruiter != previous.recruiter)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, Invite instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.recruiter != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
{
	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public string eventKey;

	[NonSerialized]
	public string arg1;

	[NonSerialized]
	public string arg2;

	[NonSerialized]
	public string arg3;

	[NonSerialized]
	public string arg4;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entry instance)
	{
		if (instance.ShouldPool)
		{
			instance.timestamp = 0L;
			instance.eventKey = string.Empty;
			instance.arg1 = string.Empty;
			instance.arg2 = string.Empty;
			instance.arg3 = string.Empty;
			instance.arg4 = string.Empty;
			Pool.Free<Entry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entry instance)
	{
		instance.timestamp = timestamp;
		instance.eventKey = eventKey;
		instance.arg1 = arg1;
		instance.arg2 = arg2;
		instance.arg3 = arg3;
		instance.arg4 = arg4;
	}

	public Entry Copy()
	{
		Entry entry = Pool.Get<Entry>();
		CopyTo(entry);
		return entry;
	}

	public static Entry Deserialize(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLengthDelimited(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLength(BufferStream stream, int length)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLength(stream, length, entry, isDelta: false);
		return entry;
	}

	public static Entry Deserialize(byte[] buffer)
	{
		Entry entry = Pool.Get<Entry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.eventKey = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.arg3 = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.arg4 = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.eventKey = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.arg3 = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.arg4 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.eventKey = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.arg3 = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.arg4 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.eventKey != previous.eventKey)
		{
			if (instance.eventKey == null)
			{
				throw new ArgumentNullException("eventKey", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.eventKey);
		}
		if (instance.arg1 != null && instance.arg1 != previous.arg1)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null && instance.arg2 != previous.arg2)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
		if (instance.arg3 != null && instance.arg3 != previous.arg3)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.arg3);
		}
		if (instance.arg4 != null && instance.arg4 != previous.arg4)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.arg4);
		}
	}

	public static void Serialize(BufferStream stream, Entry instance)
	{
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.eventKey == null)
		{
			throw new ArgumentNullException("eventKey", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.eventKey);
		if (instance.arg1 != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
		if (instance.arg3 != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.arg3);
		}
		if (instance.arg4 != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.arg4);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
{
	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public int type;

	[NonSerialized]
	public int score;

	[NonSerialized]
	public int multiplier;

	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public ulong otherSteamId;

	[NonSerialized]
	public long otherClanId;

	[NonSerialized]
	public string arg1;

	[NonSerialized]
	public string arg2;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entry instance)
	{
		if (instance.ShouldPool)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
			instance.arg1 = string.Empty;
			instance.arg2 = string.Empty;
			Pool.Free<Entry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entry instance)
	{
		instance.timestamp = timestamp;
		instance.type = type;
		instance.score = score;
		instance.multiplier = multiplier;
		instance.steamId = steamId;
		instance.otherSteamId = otherSteamId;
		instance.otherClanId = otherClanId;
		instance.arg1 = arg1;
		instance.arg2 = arg2;
	}

	public Entry Copy()
	{
		Entry entry = Pool.Get<Entry>();
		CopyTo(entry);
		return entry;
	}

	public static Entry Deserialize(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLengthDelimited(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLength(BufferStream stream, int length)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLength(stream, length, entry, isDelta: false);
		return entry;
	}

	public static Entry Deserialize(byte[] buffer)
	{
		Entry entry = Pool.Get<Entry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 74:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 74:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 74:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.type != previous.type)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.score != previous.score)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
		if (instance.multiplier != previous.multiplier)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.otherSteamId != previous.otherSteamId)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
		if (instance.arg1 != null && instance.arg1 != previous.arg1)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null && instance.arg2 != previous.arg2)
		{
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
	}

	public static void Serialize(BufferStream stream, Entry instance)
	{
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.score != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
		if (instance.multiplier != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
		if (instance.steamId != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.otherSteamId != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
		}
		if (instance.otherClanId != 0L)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
		}
		if (instance.arg1 != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null)
		{
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Invitation : IDisposable, IPooled, IProto<Invitation>, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public ulong recruiter;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Invitation instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
			Pool.Free<Invitation>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Invitation with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Invitation instance)
	{
		instance.clanId = clanId;
		instance.recruiter = recruiter;
		instance.timestamp = timestamp;
	}

	public Invitation Copy()
	{
		Invitation invitation = Pool.Get<Invitation>();
		CopyTo(invitation);
		return invitation;
	}

	public static Invitation Deserialize(BufferStream stream)
	{
		Invitation invitation = Pool.Get<Invitation>();
		Deserialize(stream, invitation, isDelta: false);
		return invitation;
	}

	public static Invitation DeserializeLengthDelimited(BufferStream stream)
	{
		Invitation invitation = Pool.Get<Invitation>();
		DeserializeLengthDelimited(stream, invitation, isDelta: false);
		return invitation;
	}

	public static Invitation DeserializeLength(BufferStream stream, int length)
	{
		Invitation invitation = Pool.Get<Invitation>();
		DeserializeLength(stream, length, invitation, isDelta: false);
		return invitation;
	}

	public static Invitation Deserialize(byte[] buffer)
	{
		Invitation invitation = Pool.Get<Invitation>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, invitation, isDelta: false);
		return invitation;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Invitation previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Invitation Deserialize(BufferStream stream, Invitation instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Invitation DeserializeLengthDelimited(BufferStream stream, Invitation instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Invitation DeserializeLength(BufferStream stream, int length, Invitation instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Invitation instance, Invitation previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.recruiter != previous.recruiter)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, Invitation instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.recruiter != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public long score;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entry instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			instance.name = string.Empty;
			instance.score = 0L;
			Pool.Free<Entry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entry instance)
	{
		instance.clanId = clanId;
		instance.name = name;
		instance.score = score;
	}

	public Entry Copy()
	{
		Entry entry = Pool.Get<Entry>();
		CopyTo(entry);
		return entry;
	}

	public static Entry Deserialize(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLengthDelimited(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLength(BufferStream stream, int length)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLength(stream, length, entry, isDelta: false);
		return entry;
	}

	public static Entry Deserialize(byte[] buffer)
	{
		Entry entry = Pool.Get<Entry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.score = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.score = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.score = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
	}

	public static void Serialize(BufferStream stream, Entry instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.score != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class RelationshipData : IDisposable, IPooled, IProto<RelationshipData>, IProto
{
	[NonSerialized]
	public RelationshipManager.PlayerRelationshipInfo info;

	[NonSerialized]
	public ArraySegment<byte> mugshotData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RelationshipData instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.info != null)
			{
				instance.info.ResetToPool();
				instance.info = null;
			}
			if (instance.mugshotData.Array != null)
			{
				BufferStream.Shared.ArrayPool.Return(instance.mugshotData.Array);
			}
			instance.mugshotData = default(ArraySegment<byte>);
			Pool.Free<RelationshipData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RelationshipData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RelationshipData instance)
	{
		if (info != null)
		{
			if (instance.info == null)
			{
				instance.info = info.Copy();
			}
			else
			{
				info.CopyTo(instance.info);
			}
		}
		else
		{
			instance.info = null;
		}
		if (mugshotData.Array == null)
		{
			instance.mugshotData = default(ArraySegment<byte>);
			return;
		}
		byte[] array = BufferStream.Shared.ArrayPool.Rent(mugshotData.Count);
		Array.Copy(mugshotData.Array, 0, array, 0, mugshotData.Count);
		instance.mugshotData = new ArraySegment<byte>(array, 0, mugshotData.Count);
	}

	public RelationshipData Copy()
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		CopyTo(relationshipData);
		return relationshipData;
	}

	public static RelationshipData Deserialize(BufferStream stream)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		Deserialize(stream, relationshipData, isDelta: false);
		return relationshipData;
	}

	public static RelationshipData DeserializeLengthDelimited(BufferStream stream)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		DeserializeLengthDelimited(stream, relationshipData, isDelta: false);
		return relationshipData;
	}

	public static RelationshipData DeserializeLength(BufferStream stream, int length)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		DeserializeLength(stream, length, relationshipData, isDelta: false);
		return relationshipData;
	}

	public static RelationshipData Deserialize(byte[] buffer)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, relationshipData, isDelta: false);
		return relationshipData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RelationshipData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RelationshipData Deserialize(BufferStream stream, RelationshipData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.info == null)
				{
					instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				break;
			case 18:
				instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static RelationshipData DeserializeLengthDelimited(BufferStream stream, RelationshipData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.info == null)
				{
					instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				break;
			case 18:
				instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RelationshipData DeserializeLength(BufferStream stream, int length, RelationshipData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.info == null)
				{
					instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				break;
			case 18:
				instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RelationshipData instance, RelationshipData previous)
	{
		if (instance.info == null)
		{
			throw new ArgumentNullException("info", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		RelationshipManager.PlayerRelationshipInfo.SerializeDelta(stream, instance.info, previous.info);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
		if (instance.mugshotData.Array != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
		}
	}

	public static void Serialize(BufferStream stream, RelationshipData instance)
	{
		if (instance.info == null)
		{
			throw new ArgumentNullException("info", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		RelationshipManager.PlayerRelationshipInfo.Serialize(stream, instance.info);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
		if (instance.mugshotData.Array != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		info?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Message : IDisposable, IPooled, IProto<Message>, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public ulong userId;

	[NonSerialized]
	public string text;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Message instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			instance.userId = 0uL;
			instance.text = string.Empty;
			instance.name = string.Empty;
			instance.timestamp = 0L;
			Pool.Free<Message>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Message with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Message instance)
	{
		instance.clanId = clanId;
		instance.userId = userId;
		instance.text = text;
		instance.name = name;
		instance.timestamp = timestamp;
	}

	public Message Copy()
	{
		Message message = Pool.Get<Message>();
		CopyTo(message);
		return message;
	}

	public static Message Deserialize(BufferStream stream)
	{
		Message message = Pool.Get<Message>();
		Deserialize(stream, message, isDelta: false);
		return message;
	}

	public static Message DeserializeLengthDelimited(BufferStream stream)
	{
		Message message = Pool.Get<Message>();
		DeserializeLengthDelimited(stream, message, isDelta: false);
		return message;
	}

	public static Message DeserializeLength(BufferStream stream, int length)
	{
		Message message = Pool.Get<Message>();
		DeserializeLength(stream, length, message, isDelta: false);
		return message;
	}

	public static Message Deserialize(byte[] buffer)
	{
		Message message = Pool.Get<Message>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, message, isDelta: false);
		return message;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Message previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Message Deserialize(BufferStream stream, Message instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Message DeserializeLengthDelimited(BufferStream stream, Message instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Message DeserializeLength(BufferStream stream, int length, Message instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Message instance, Message previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.text != previous.text)
		{
			if (instance.text == null)
			{
				throw new ArgumentNullException("text", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.text);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, Message instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.userId != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.text == null)
		{
			throw new ArgumentNullException("text", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.text);
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LineVec : IDisposable, IPooled, IProto<LineVec>, IProto
{
	[NonSerialized]
	public Vector4 vec;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LineVec instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.vec = default(Vector4);
			Pool.Free<LineVec>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LineVec with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LineVec instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.vec = vec;
	}

	public LineVec Copy()
	{
		LineVec lineVec = Pool.Get<LineVec>();
		CopyTo(lineVec);
		return lineVec;
	}

	public static LineVec Deserialize(BufferStream stream)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		Deserialize(stream, lineVec, isDelta: false);
		return lineVec;
	}

	public static LineVec DeserializeLengthDelimited(BufferStream stream)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		DeserializeLengthDelimited(stream, lineVec, isDelta: false);
		return lineVec;
	}

	public static LineVec DeserializeLength(BufferStream stream, int length)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		DeserializeLength(stream, length, lineVec, isDelta: false);
		return lineVec;
	}

	public static LineVec Deserialize(byte[] buffer)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lineVec, isDelta: false);
		return lineVec;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LineVec previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LineVec Deserialize(BufferStream stream, LineVec instance, bool isDelta)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LineVec DeserializeLengthDelimited(BufferStream stream, LineVec instance, bool isDelta)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LineVec DeserializeLength(BufferStream stream, int length, LineVec instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LineVec instance, LineVec previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.vec != previous.vec)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.vec, previous.vec);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, LineVec instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.vec != default(Vector4))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.Serialize(stream, instance.vec);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LinePointList : IDisposable, IPooled, IProto<LinePointList>, IProto
{
	[NonSerialized]
	public Vector4 a;

	[NonSerialized]
	public Vector4 b;

	[NonSerialized]
	public Vector4 c;

	[NonSerialized]
	public Vector4 d;

	[NonSerialized]
	public Vector4 e;

	[NonSerialized]
	public Vector4 f;

	[NonSerialized]
	public Vector4 g;

	[NonSerialized]
	public Vector4 h;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LinePointList instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.a = default(Vector4);
			instance.b = default(Vector4);
			instance.c = default(Vector4);
			instance.d = default(Vector4);
			instance.e = default(Vector4);
			instance.f = default(Vector4);
			instance.g = default(Vector4);
			instance.h = default(Vector4);
			Pool.Free<LinePointList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LinePointList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LinePointList instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.a = a;
		instance.b = b;
		instance.c = c;
		instance.d = d;
		instance.e = e;
		instance.f = f;
		instance.g = g;
		instance.h = h;
	}

	public LinePointList Copy()
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		CopyTo(linePointList);
		return linePointList;
	}

	public static LinePointList Deserialize(BufferStream stream)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		Deserialize(stream, linePointList, isDelta: false);
		return linePointList;
	}

	public static LinePointList DeserializeLengthDelimited(BufferStream stream)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		DeserializeLengthDelimited(stream, linePointList, isDelta: false);
		return linePointList;
	}

	public static LinePointList DeserializeLength(BufferStream stream, int length)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		DeserializeLength(stream, length, linePointList, isDelta: false);
		return linePointList;
	}

	public static LinePointList Deserialize(byte[] buffer)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, linePointList, isDelta: false);
		return linePointList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LinePointList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LinePointList Deserialize(BufferStream stream, LinePointList instance, bool isDelta)
	{
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
				continue;
			case 18:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
				continue;
			case 34:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
				continue;
			case 42:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
				continue;
			case 50:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
				continue;
			case 58:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LinePointList DeserializeLengthDelimited(BufferStream stream, LinePointList instance, bool isDelta)
	{
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
				continue;
			case 18:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
				continue;
			case 34:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
				continue;
			case 42:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
				continue;
			case 50:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
				continue;
			case 58:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LinePointList DeserializeLength(BufferStream stream, int length, LinePointList instance, bool isDelta)
	{
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
				continue;
			case 18:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
				continue;
			case 34:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
				continue;
			case 42:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
				continue;
			case 50:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
				continue;
			case 58:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LinePointList instance, LinePointList previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.a != previous.a)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.a, previous.a);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.b != previous.b)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.b, previous.b);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.c != previous.c)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.c, previous.c);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.d != previous.d)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.d, previous.d);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.e != previous.e)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.e, previous.e);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.f != previous.f)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.f, previous.f);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.g != previous.g)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.g, previous.g);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.h != previous.h)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.h, previous.h);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
	}

	public static void Serialize(BufferStream stream, LinePointList instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		if (instance.a != default(Vector4))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.Serialize(stream, instance.a);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.b != default(Vector4))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.b);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.c != default(Vector4))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.c);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.d != default(Vector4))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.d);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.e != default(Vector4))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.e);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.f != default(Vector4))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.f);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.g != default(Vector4))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.g);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.h != default(Vector4))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.h);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PlayerStoredVehicle : IDisposable, IPooled, IProto<PlayerStoredVehicle>, IProto
{
	[NonSerialized]
	public string shortname;

	[NonSerialized]
	public string resourcePath;

	[NonSerialized]
	public float health;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerStoredVehicle instance)
	{
		if (instance.ShouldPool)
		{
			instance.shortname = string.Empty;
			instance.resourcePath = string.Empty;
			instance.health = 0f;
			Pool.Free<PlayerStoredVehicle>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerStoredVehicle with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerStoredVehicle instance)
	{
		instance.shortname = shortname;
		instance.resourcePath = resourcePath;
		instance.health = health;
	}

	public PlayerStoredVehicle Copy()
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		CopyTo(playerStoredVehicle);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle Deserialize(BufferStream stream)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		Deserialize(stream, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		DeserializeLengthDelimited(stream, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		DeserializeLength(stream, length, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle Deserialize(byte[] buffer)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerStoredVehicle previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerStoredVehicle Deserialize(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.shortname = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.resourcePath = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shortname = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.resourcePath = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length, PlayerStoredVehicle instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shortname = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.resourcePath = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerStoredVehicle instance, PlayerStoredVehicle previous)
	{
		if (instance.shortname != null && instance.shortname != previous.shortname)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.shortname);
		}
		if (instance.resourcePath != null && instance.resourcePath != previous.resourcePath)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.resourcePath);
		}
		if (instance.health != previous.health)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
	}

	public static void Serialize(BufferStream stream, PlayerStoredVehicle instance)
	{
		if (instance.shortname != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.shortname);
		}
		if (instance.resourcePath != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.resourcePath);
		}
		if (instance.health != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Result : IDisposable, IPooled, IProto<Result>, IProto
{
	[NonSerialized]
	public ulong ID;

	[NonSerialized]
	public int winnings;

	[NonSerialized]
	public int resultCode;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Result instance)
	{
		if (instance.ShouldPool)
		{
			instance.ID = 0uL;
			instance.winnings = 0;
			instance.resultCode = 0;
			Pool.Free<Result>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Result with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Result instance)
	{
		instance.ID = ID;
		instance.winnings = winnings;
		instance.resultCode = resultCode;
	}

	public Result Copy()
	{
		Result result = Pool.Get<Result>();
		CopyTo(result);
		return result;
	}

	public static Result Deserialize(BufferStream stream)
	{
		Result result = Pool.Get<Result>();
		Deserialize(stream, result, isDelta: false);
		return result;
	}

	public static Result DeserializeLengthDelimited(BufferStream stream)
	{
		Result result = Pool.Get<Result>();
		DeserializeLengthDelimited(stream, result, isDelta: false);
		return result;
	}

	public static Result DeserializeLength(BufferStream stream, int length)
	{
		Result result = Pool.Get<Result>();
		DeserializeLength(stream, length, result, isDelta: false);
		return result;
	}

	public static Result Deserialize(byte[] buffer)
	{
		Result result = Pool.Get<Result>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, result, isDelta: false);
		return result;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Result previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Result Deserialize(BufferStream stream, Result instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.ID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Result DeserializeLengthDelimited(BufferStream stream, Result instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Result DeserializeLength(BufferStream stream, int length, Result instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Result instance, Result previous)
	{
		if (instance.ID != previous.ID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.ID);
		}
		if (instance.winnings != previous.winnings)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
		}
		if (instance.resultCode != previous.resultCode)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
		}
	}

	public static void Serialize(BufferStream stream, Result instance)
	{
		if (instance.ID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.ID);
		}
		if (instance.winnings != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
		}
		if (instance.resultCode != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum RespawnType
{
	SleepingBag = 1,
	Bed,
	BeachTowel,
	Camper,
	Static
}


public enum RespawnState
{
	OK = 1,
	Occupied,
	Underwater,
	InNoRespawnZone
}


