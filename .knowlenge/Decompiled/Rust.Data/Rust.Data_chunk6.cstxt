using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ItemFilter : IDisposable, IPooled, IProto<ItemFilter>, IProto
{
	[NonSerialized]
	public int itemDef;

	[NonSerialized]
	public int itemCategory;

	[NonSerialized]
	public int maxAmountInDestination;

	[NonSerialized]
	public int isBlueprint;

	[NonSerialized]
	public int bufferAmount;

	[NonSerialized]
	public int retainMinimum;

	[NonSerialized]
	public int bufferTransferRemaining;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemFilter instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemDef = 0;
			instance.itemCategory = 0;
			instance.maxAmountInDestination = 0;
			instance.isBlueprint = 0;
			instance.bufferAmount = 0;
			instance.retainMinimum = 0;
			instance.bufferTransferRemaining = 0;
			Pool.Free<ItemFilter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemFilter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemFilter instance)
	{
		instance.itemDef = itemDef;
		instance.itemCategory = itemCategory;
		instance.maxAmountInDestination = maxAmountInDestination;
		instance.isBlueprint = isBlueprint;
		instance.bufferAmount = bufferAmount;
		instance.retainMinimum = retainMinimum;
		instance.bufferTransferRemaining = bufferTransferRemaining;
	}

	public ItemFilter Copy()
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		CopyTo(itemFilter);
		return itemFilter;
	}

	public static ItemFilter Deserialize(BufferStream stream)
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		Deserialize(stream, itemFilter, isDelta: false);
		return itemFilter;
	}

	public static ItemFilter DeserializeLengthDelimited(BufferStream stream)
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		DeserializeLengthDelimited(stream, itemFilter, isDelta: false);
		return itemFilter;
	}

	public static ItemFilter DeserializeLength(BufferStream stream, int length)
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		DeserializeLength(stream, length, itemFilter, isDelta: false);
		return itemFilter;
	}

	public static ItemFilter Deserialize(byte[] buffer)
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemFilter, isDelta: false);
		return itemFilter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemFilter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemFilter Deserialize(BufferStream stream, ItemFilter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemFilter DeserializeLengthDelimited(BufferStream stream, ItemFilter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemFilter DeserializeLength(BufferStream stream, int length, ItemFilter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemFilter instance, ItemFilter previous)
	{
		if (instance.itemDef != previous.itemDef)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemDef);
		}
		if (instance.itemCategory != previous.itemCategory)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCategory);
		}
		if (instance.maxAmountInDestination != previous.maxAmountInDestination)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxAmountInDestination);
		}
		if (instance.isBlueprint != previous.isBlueprint)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.isBlueprint);
		}
		if (instance.bufferAmount != previous.bufferAmount)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferAmount);
		}
		if (instance.retainMinimum != previous.retainMinimum)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.retainMinimum);
		}
		if (instance.bufferTransferRemaining != previous.bufferTransferRemaining)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferTransferRemaining);
		}
	}

	public static void Serialize(BufferStream stream, ItemFilter instance)
	{
		if (instance.itemDef != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemDef);
		}
		if (instance.itemCategory != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCategory);
		}
		if (instance.maxAmountInDestination != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxAmountInDestination);
		}
		if (instance.isBlueprint != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.isBlueprint);
		}
		if (instance.bufferAmount != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferAmount);
		}
		if (instance.retainMinimum != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.retainMinimum);
		}
		if (instance.bufferTransferRemaining != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferTransferRemaining);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ItemFilterList : IDisposable, IPooled, IProto<ItemFilterList>, IProto
{
	[NonSerialized]
	public List<ItemFilter> filters;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemFilterList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.filters != null)
		{
			for (int i = 0; i < instance.filters.Count; i++)
			{
				if (instance.filters[i] != null)
				{
					instance.filters[i].ResetToPool();
					instance.filters[i] = null;
				}
			}
			List<ItemFilter> list = instance.filters;
			Pool.Free<ItemFilter>(ref list, false);
			instance.filters = list;
		}
		Pool.Free<ItemFilterList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemFilterList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemFilterList instance)
	{
		if (filters != null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
			for (int i = 0; i < filters.Count; i++)
			{
				ItemFilter item = filters[i].Copy();
				instance.filters.Add(item);
			}
		}
		else
		{
			instance.filters = null;
		}
	}

	public ItemFilterList Copy()
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		CopyTo(itemFilterList);
		return itemFilterList;
	}

	public static ItemFilterList Deserialize(BufferStream stream)
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		Deserialize(stream, itemFilterList, isDelta: false);
		return itemFilterList;
	}

	public static ItemFilterList DeserializeLengthDelimited(BufferStream stream)
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		DeserializeLengthDelimited(stream, itemFilterList, isDelta: false);
		return itemFilterList;
	}

	public static ItemFilterList DeserializeLength(BufferStream stream, int length)
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		DeserializeLength(stream, length, itemFilterList, isDelta: false);
		return itemFilterList;
	}

	public static ItemFilterList Deserialize(byte[] buffer)
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemFilterList, isDelta: false);
		return itemFilterList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemFilterList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemFilterList Deserialize(BufferStream stream, ItemFilterList instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemFilterList DeserializeLengthDelimited(BufferStream stream, ItemFilterList instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemFilterList DeserializeLength(BufferStream stream, int length, ItemFilterList instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemFilterList instance, ItemFilterList previous)
	{
		if (instance.filters == null)
		{
			return;
		}
		for (int i = 0; i < instance.filters.Count; i++)
		{
			ItemFilter itemFilter = instance.filters[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ItemFilter.SerializeDelta(stream, itemFilter, itemFilter);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field filters (ProtoBuf.IndustrialConveyor.ItemFilter)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ItemFilterList instance)
	{
		if (instance.filters == null)
		{
			return;
		}
		for (int i = 0; i < instance.filters.Count; i++)
		{
			ItemFilter instance2 = instance.filters[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ItemFilter.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field filters (ProtoBuf.IndustrialConveyor.ItemFilter)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (filters != null)
		{
			for (int i = 0; i < filters.Count; i++)
			{
				filters[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public struct ItemTransfer : IProto<ItemTransfer>, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public int amount;

	public static void ResetToPool(ItemTransfer instance)
	{
		instance.itemId = 0;
		instance.amount = 0;
	}

	public void CopyTo(ItemTransfer instance)
	{
		instance.itemId = itemId;
		instance.amount = amount;
	}

	public ItemTransfer Copy()
	{
		ItemTransfer itemTransfer = default(ItemTransfer);
		CopyTo(itemTransfer);
		return itemTransfer;
	}

	public static ItemTransfer Deserialize(BufferStream stream)
	{
		ItemTransfer instance = default(ItemTransfer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static ItemTransfer DeserializeLengthDelimited(BufferStream stream)
	{
		ItemTransfer instance = default(ItemTransfer);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static ItemTransfer DeserializeLength(BufferStream stream, int length)
	{
		ItemTransfer instance = default(ItemTransfer);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static ItemTransfer Deserialize(byte[] buffer)
	{
		ItemTransfer instance = default(ItemTransfer);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, ItemTransfer previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static ItemTransfer Deserialize(BufferStream stream, ref ItemTransfer instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemTransfer DeserializeLengthDelimited(BufferStream stream, ref ItemTransfer instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemTransfer DeserializeLength(BufferStream stream, int length, ref ItemTransfer instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemTransfer instance, ItemTransfer previous)
	{
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
	}

	public static void Serialize(BufferStream stream, ItemTransfer instance)
	{
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class AssociatedFile : IDisposable, IPooled, IProto<AssociatedFile>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public uint crc;

	[NonSerialized]
	public uint numID;

	[NonSerialized]
	public byte[] data;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AssociatedFile instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.crc = 0u;
			instance.numID = 0u;
			instance.data = null;
			Pool.Free<AssociatedFile>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AssociatedFile with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AssociatedFile instance)
	{
		instance.type = type;
		instance.crc = crc;
		instance.numID = numID;
		if (data == null)
		{
			instance.data = null;
			return;
		}
		instance.data = new byte[data.Length];
		Array.Copy(data, instance.data, instance.data.Length);
	}

	public AssociatedFile Copy()
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		CopyTo(associatedFile);
		return associatedFile;
	}

	public static AssociatedFile Deserialize(BufferStream stream)
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		Deserialize(stream, associatedFile, isDelta: false);
		return associatedFile;
	}

	public static AssociatedFile DeserializeLengthDelimited(BufferStream stream)
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		DeserializeLengthDelimited(stream, associatedFile, isDelta: false);
		return associatedFile;
	}

	public static AssociatedFile DeserializeLength(BufferStream stream, int length)
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		DeserializeLength(stream, length, associatedFile, isDelta: false);
		return associatedFile;
	}

	public static AssociatedFile Deserialize(byte[] buffer)
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, associatedFile, isDelta: false);
		return associatedFile;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AssociatedFile previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AssociatedFile Deserialize(BufferStream stream, AssociatedFile instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.numID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AssociatedFile DeserializeLengthDelimited(BufferStream stream, AssociatedFile instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.numID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AssociatedFile DeserializeLength(BufferStream stream, int length, AssociatedFile instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.numID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AssociatedFile instance, AssociatedFile previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.crc != previous.crc)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
		if (instance.numID != previous.numID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.numID);
		}
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteBytes(stream, instance.data);
	}

	public static void Serialize(BufferStream stream, AssociatedFile instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.crc != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
		if (instance.numID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.numID);
		}
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteBytes(stream, instance.data);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ScheduleEntry : IDisposable, IPooled, IProto<ScheduleEntry>, IProto
{
	[NonSerialized]
	public int nextZoneId;

	[NonSerialized]
	public int estimate;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ScheduleEntry instance)
	{
		if (instance.ShouldPool)
		{
			instance.nextZoneId = 0;
			instance.estimate = 0;
			Pool.Free<ScheduleEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ScheduleEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ScheduleEntry instance)
	{
		instance.nextZoneId = nextZoneId;
		instance.estimate = estimate;
	}

	public ScheduleEntry Copy()
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		CopyTo(scheduleEntry);
		return scheduleEntry;
	}

	public static ScheduleEntry Deserialize(BufferStream stream)
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		Deserialize(stream, scheduleEntry, isDelta: false);
		return scheduleEntry;
	}

	public static ScheduleEntry DeserializeLengthDelimited(BufferStream stream)
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		DeserializeLengthDelimited(stream, scheduleEntry, isDelta: false);
		return scheduleEntry;
	}

	public static ScheduleEntry DeserializeLength(BufferStream stream, int length)
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		DeserializeLength(stream, length, scheduleEntry, isDelta: false);
		return scheduleEntry;
	}

	public static ScheduleEntry Deserialize(byte[] buffer)
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, scheduleEntry, isDelta: false);
		return scheduleEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ScheduleEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ScheduleEntry Deserialize(BufferStream stream, ScheduleEntry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ScheduleEntry DeserializeLengthDelimited(BufferStream stream, ScheduleEntry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ScheduleEntry DeserializeLength(BufferStream stream, int length, ScheduleEntry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ScheduleEntry instance, ScheduleEntry previous)
	{
		if (instance.nextZoneId != previous.nextZoneId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextZoneId);
		}
		if (instance.estimate != previous.estimate)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.estimate);
		}
	}

	public static void Serialize(BufferStream stream, ScheduleEntry instance)
	{
		if (instance.nextZoneId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextZoneId);
		}
		if (instance.estimate != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.estimate);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class QueuedMove : IDisposable, IPooled, IProto<QueuedMove>, IProto
{
	[NonSerialized]
	public NetworkableId targetEntity;

	[NonSerialized]
	public Vector3 targetWorldPosition;

	[NonSerialized]
	public Vector4 targetWorldRotation;

	[NonSerialized]
	public bool hasTarget;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(QueuedMove instance)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.targetEntity = default(NetworkableId);
			instance.targetWorldPosition = default(Vector3);
			instance.targetWorldRotation = default(Vector4);
			instance.hasTarget = false;
			Pool.Free<QueuedMove>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose QueuedMove with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(QueuedMove instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.targetEntity = targetEntity;
		instance.targetWorldPosition = targetWorldPosition;
		instance.targetWorldRotation = targetWorldRotation;
		instance.hasTarget = hasTarget;
	}

	public QueuedMove Copy()
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		CopyTo(queuedMove);
		return queuedMove;
	}

	public static QueuedMove Deserialize(BufferStream stream)
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		Deserialize(stream, queuedMove, isDelta: false);
		return queuedMove;
	}

	public static QueuedMove DeserializeLengthDelimited(BufferStream stream)
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		DeserializeLengthDelimited(stream, queuedMove, isDelta: false);
		return queuedMove;
	}

	public static QueuedMove DeserializeLength(BufferStream stream, int length)
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		DeserializeLength(stream, length, queuedMove, isDelta: false);
		return queuedMove;
	}

	public static QueuedMove Deserialize(byte[] buffer)
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, queuedMove, isDelta: false);
		return queuedMove;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, QueuedMove previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static QueuedMove Deserialize(BufferStream stream, QueuedMove instance, bool isDelta)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
				continue;
			case 32:
				instance.hasTarget = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static QueuedMove DeserializeLengthDelimited(BufferStream stream, QueuedMove instance, bool isDelta)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
				continue;
			case 32:
				instance.hasTarget = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static QueuedMove DeserializeLength(BufferStream stream, int length, QueuedMove instance, bool isDelta)
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
				continue;
			case 32:
				instance.hasTarget = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, QueuedMove instance, QueuedMove previous)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetEntity.Value);
		if (instance.targetWorldPosition != previous.targetWorldPosition)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.targetWorldPosition, previous.targetWorldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.targetWorldRotation != previous.targetWorldRotation)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.targetWorldRotation, previous.targetWorldRotation);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldRotation (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.hasTarget);
	}

	public static void Serialize(BufferStream stream, QueuedMove instance)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		if (instance.targetEntity != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetEntity.Value);
		}
		if (instance.targetWorldPosition != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.targetWorldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.targetWorldRotation != default(Vector4))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.targetWorldRotation);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldRotation (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.hasTarget)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.hasTarget);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetEntity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class InstanceData : IDisposable, IPooled, IProto<InstanceData>, IProto
{
	[NonSerialized]
	public int dataInt;

	[NonSerialized]
	public int blueprintTarget;

	[NonSerialized]
	public int blueprintAmount;

	[NonSerialized]
	public NetworkableId subEntity;

	[NonSerialized]
	public float dataFloat;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InstanceData instance)
	{
		if (instance.ShouldPool)
		{
			instance.dataInt = 0;
			instance.blueprintTarget = 0;
			instance.blueprintAmount = 0;
			instance.subEntity = default(NetworkableId);
			instance.dataFloat = 0f;
			Pool.Free<InstanceData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InstanceData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InstanceData instance)
	{
		instance.dataInt = dataInt;
		instance.blueprintTarget = blueprintTarget;
		instance.blueprintAmount = blueprintAmount;
		instance.subEntity = subEntity;
		instance.dataFloat = dataFloat;
	}

	public InstanceData Copy()
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		CopyTo(instanceData);
		return instanceData;
	}

	public static InstanceData Deserialize(BufferStream stream)
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		Deserialize(stream, instanceData, isDelta: false);
		return instanceData;
	}

	public static InstanceData DeserializeLengthDelimited(BufferStream stream)
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		DeserializeLengthDelimited(stream, instanceData, isDelta: false);
		return instanceData;
	}

	public static InstanceData DeserializeLength(BufferStream stream, int length)
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		DeserializeLength(stream, length, instanceData, isDelta: false);
		return instanceData;
	}

	public static InstanceData Deserialize(byte[] buffer)
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instanceData, isDelta: false);
		return instanceData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InstanceData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InstanceData Deserialize(BufferStream stream, InstanceData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.dataFloat = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InstanceData DeserializeLengthDelimited(BufferStream stream, InstanceData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.dataFloat = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InstanceData DeserializeLength(BufferStream stream, int length, InstanceData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.dataFloat = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InstanceData instance, InstanceData previous)
	{
		if (instance.dataInt != previous.dataInt)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dataInt);
		}
		if (instance.blueprintTarget != previous.blueprintTarget)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintTarget);
		}
		if (instance.blueprintAmount != previous.blueprintAmount)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintAmount);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.subEntity.Value);
		if (instance.dataFloat != previous.dataFloat)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.dataFloat);
		}
	}

	public static void Serialize(BufferStream stream, InstanceData instance)
	{
		if (instance.dataInt != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dataInt);
		}
		if (instance.blueprintTarget != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintTarget);
		}
		if (instance.blueprintAmount != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintAmount);
		}
		if (instance.subEntity != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.subEntity.Value);
		}
		if (instance.dataFloat != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.dataFloat);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref subEntity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ConditionData : IDisposable, IPooled, IProto<ConditionData>, IProto
{
	[NonSerialized]
	public float condition;

	[NonSerialized]
	public float maxCondition;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ConditionData instance)
	{
		if (instance.ShouldPool)
		{
			instance.condition = 0f;
			instance.maxCondition = 0f;
			Pool.Free<ConditionData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ConditionData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ConditionData instance)
	{
		instance.condition = condition;
		instance.maxCondition = maxCondition;
	}

	public ConditionData Copy()
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		CopyTo(conditionData);
		return conditionData;
	}

	public static ConditionData Deserialize(BufferStream stream)
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		Deserialize(stream, conditionData, isDelta: false);
		return conditionData;
	}

	public static ConditionData DeserializeLengthDelimited(BufferStream stream)
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		DeserializeLengthDelimited(stream, conditionData, isDelta: false);
		return conditionData;
	}

	public static ConditionData DeserializeLength(BufferStream stream, int length)
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		DeserializeLength(stream, length, conditionData, isDelta: false);
		return conditionData;
	}

	public static ConditionData Deserialize(byte[] buffer)
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, conditionData, isDelta: false);
		return conditionData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ConditionData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ConditionData Deserialize(BufferStream stream, ConditionData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.condition = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.maxCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ConditionData DeserializeLengthDelimited(BufferStream stream, ConditionData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.condition = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.maxCondition = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ConditionData DeserializeLength(BufferStream stream, int length, ConditionData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.condition = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.maxCondition = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ConditionData instance, ConditionData previous)
	{
		if (instance.condition != previous.condition)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.condition);
		}
		if (instance.maxCondition != previous.maxCondition)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.maxCondition);
		}
	}

	public static void Serialize(BufferStream stream, ConditionData instance)
	{
		if (instance.condition != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.condition);
		}
		if (instance.maxCondition != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.maxCondition);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TeamMember : IDisposable, IPooled, IProto<TeamMember>, IProto
{
	[NonSerialized]
	public string displayName;

	[NonSerialized]
	public ulong userID;

	[NonSerialized]
	public float healthFraction;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public bool online;

	[NonSerialized]
	public bool wounded;

	[NonSerialized]
	public ulong teamID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TeamMember instance)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.displayName = string.Empty;
			instance.userID = 0uL;
			instance.healthFraction = 0f;
			instance.position = default(Vector3);
			instance.online = false;
			instance.wounded = false;
			instance.teamID = 0uL;
			Pool.Free<TeamMember>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TeamMember with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TeamMember instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.displayName = displayName;
		instance.userID = userID;
		instance.healthFraction = healthFraction;
		instance.position = position;
		instance.online = online;
		instance.wounded = wounded;
		instance.teamID = teamID;
	}

	public TeamMember Copy()
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		CopyTo(teamMember);
		return teamMember;
	}

	public static TeamMember Deserialize(BufferStream stream)
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		Deserialize(stream, teamMember, isDelta: false);
		return teamMember;
	}

	public static TeamMember DeserializeLengthDelimited(BufferStream stream)
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		DeserializeLengthDelimited(stream, teamMember, isDelta: false);
		return teamMember;
	}

	public static TeamMember DeserializeLength(BufferStream stream, int length)
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		DeserializeLength(stream, length, teamMember, isDelta: false);
		return teamMember;
	}

	public static TeamMember Deserialize(byte[] buffer)
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, teamMember, isDelta: false);
		return teamMember;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TeamMember previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TeamMember Deserialize(BufferStream stream, TeamMember instance, bool isDelta)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 40:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.wounded = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TeamMember DeserializeLengthDelimited(BufferStream stream, TeamMember instance, bool isDelta)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 40:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.wounded = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TeamMember DeserializeLength(BufferStream stream, int length, TeamMember instance, bool isDelta)
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 40:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.wounded = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TeamMember instance, TeamMember previous)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.displayName != null && instance.displayName != previous.displayName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.userID != previous.userID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userID);
		}
		if (instance.healthFraction != previous.healthFraction)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.healthFraction);
		}
		if (instance.position != previous.position)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.online);
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.wounded);
		if (instance.teamID != previous.teamID)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.teamID);
		}
	}

	public static void Serialize(BufferStream stream, TeamMember instance)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		if (instance.displayName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.userID != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userID);
		}
		if (instance.healthFraction != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.healthFraction);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.online)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.online);
		}
		if (instance.wounded)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.wounded);
		}
		if (instance.teamID != 0L)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.teamID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class DeathInfo : IDisposable, IPooled, IProto<DeathInfo>, IProto
{
	[NonSerialized]
	public string attackerName;

	[NonSerialized]
	public ulong attackerSteamID;

	[NonSerialized]
	public string hitBone;

	[NonSerialized]
	public string inflictorName;

	[NonSerialized]
	public int lastDamageType;

	[NonSerialized]
	public float attackerDistance;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DeathInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.attackerName = string.Empty;
			instance.attackerSteamID = 0uL;
			instance.hitBone = string.Empty;
			instance.inflictorName = string.Empty;
			instance.lastDamageType = 0;
			instance.attackerDistance = 0f;
			Pool.Free<DeathInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DeathInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DeathInfo instance)
	{
		instance.attackerName = attackerName;
		instance.attackerSteamID = attackerSteamID;
		instance.hitBone = hitBone;
		instance.inflictorName = inflictorName;
		instance.lastDamageType = lastDamageType;
		instance.attackerDistance = attackerDistance;
	}

	public DeathInfo Copy()
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		CopyTo(deathInfo);
		return deathInfo;
	}

	public static DeathInfo Deserialize(BufferStream stream)
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		Deserialize(stream, deathInfo, isDelta: false);
		return deathInfo;
	}

	public static DeathInfo DeserializeLengthDelimited(BufferStream stream)
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		DeserializeLengthDelimited(stream, deathInfo, isDelta: false);
		return deathInfo;
	}

	public static DeathInfo DeserializeLength(BufferStream stream, int length)
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		DeserializeLength(stream, length, deathInfo, isDelta: false);
		return deathInfo;
	}

	public static DeathInfo Deserialize(byte[] buffer)
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, deathInfo, isDelta: false);
		return deathInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DeathInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DeathInfo Deserialize(BufferStream stream, DeathInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.attackerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.hitBone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.inflictorName = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.attackerDistance = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DeathInfo DeserializeLengthDelimited(BufferStream stream, DeathInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.attackerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.hitBone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.inflictorName = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.attackerDistance = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DeathInfo DeserializeLength(BufferStream stream, int length, DeathInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.attackerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.hitBone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.inflictorName = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.attackerDistance = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DeathInfo instance, DeathInfo previous)
	{
		if (instance.attackerName != null && instance.attackerName != previous.attackerName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.attackerName);
		}
		if (instance.attackerSteamID != previous.attackerSteamID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.attackerSteamID);
		}
		if (instance.hitBone != null && instance.hitBone != previous.hitBone)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.hitBone);
		}
		if (instance.inflictorName != null && instance.inflictorName != previous.inflictorName)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.inflictorName);
		}
		if (instance.lastDamageType != previous.lastDamageType)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastDamageType);
		}
		if (instance.attackerDistance != previous.attackerDistance)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.attackerDistance);
		}
	}

	public static void Serialize(BufferStream stream, DeathInfo instance)
	{
		if (instance.attackerName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.attackerName);
		}
		if (instance.attackerSteamID != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.attackerSteamID);
		}
		if (instance.hitBone != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.hitBone);
		}
		if (instance.inflictorName != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.inflictorName);
		}
		if (instance.lastDamageType != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastDamageType);
		}
		if (instance.attackerDistance != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.attackerDistance);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class WeaponStats : IDisposable, IPooled, IProto<WeaponStats>, IProto
{
	[NonSerialized]
	public string weaponName;

	[NonSerialized]
	public ulong shotsFired;

	[NonSerialized]
	public ulong shotsHit;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WeaponStats instance)
	{
		if (instance.ShouldPool)
		{
			instance.weaponName = string.Empty;
			instance.shotsFired = 0uL;
			instance.shotsHit = 0uL;
			Pool.Free<WeaponStats>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WeaponStats with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WeaponStats instance)
	{
		instance.weaponName = weaponName;
		instance.shotsFired = shotsFired;
		instance.shotsHit = shotsHit;
	}

	public WeaponStats Copy()
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		CopyTo(weaponStats);
		return weaponStats;
	}

	public static WeaponStats Deserialize(BufferStream stream)
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		Deserialize(stream, weaponStats, isDelta: false);
		return weaponStats;
	}

	public static WeaponStats DeserializeLengthDelimited(BufferStream stream)
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		DeserializeLengthDelimited(stream, weaponStats, isDelta: false);
		return weaponStats;
	}

	public static WeaponStats DeserializeLength(BufferStream stream, int length)
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		DeserializeLength(stream, length, weaponStats, isDelta: false);
		return weaponStats;
	}

	public static WeaponStats Deserialize(byte[] buffer)
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, weaponStats, isDelta: false);
		return weaponStats;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WeaponStats previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WeaponStats Deserialize(BufferStream stream, WeaponStats instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.weaponName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.shotsFired = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.shotsHit = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WeaponStats DeserializeLengthDelimited(BufferStream stream, WeaponStats instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.weaponName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.shotsFired = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.shotsHit = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WeaponStats DeserializeLength(BufferStream stream, int length, WeaponStats instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.weaponName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.shotsFired = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.shotsHit = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WeaponStats instance, WeaponStats previous)
	{
		if (instance.weaponName != previous.weaponName)
		{
			if (instance.weaponName == null)
			{
				throw new ArgumentNullException("weaponName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.weaponName);
		}
		if (instance.shotsFired != previous.shotsFired)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.shotsFired);
		}
		if (instance.shotsHit != previous.shotsHit)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.shotsHit);
		}
	}

	public static void Serialize(BufferStream stream, WeaponStats instance)
	{
		if (instance.weaponName == null)
		{
			throw new ArgumentNullException("weaponName", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.weaponName);
		if (instance.shotsFired != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.shotsFired);
		}
		if (instance.shotsHit != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.shotsHit);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class GenericStat : IDisposable, IPooled, IProto<GenericStat>, IProto
{
	[NonSerialized]
	public string key;

	[NonSerialized]
	public int value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(GenericStat instance)
	{
		if (instance.ShouldPool)
		{
			instance.key = string.Empty;
			instance.value = 0;
			Pool.Free<GenericStat>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose GenericStat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(GenericStat instance)
	{
		instance.key = key;
		instance.value = value;
	}

	public GenericStat Copy()
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		CopyTo(genericStat);
		return genericStat;
	}

	public static GenericStat Deserialize(BufferStream stream)
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		Deserialize(stream, genericStat, isDelta: false);
		return genericStat;
	}

	public static GenericStat DeserializeLengthDelimited(BufferStream stream)
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		DeserializeLengthDelimited(stream, genericStat, isDelta: false);
		return genericStat;
	}

	public static GenericStat DeserializeLength(BufferStream stream, int length)
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		DeserializeLength(stream, length, genericStat, isDelta: false);
		return genericStat;
	}

	public static GenericStat Deserialize(byte[] buffer)
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, genericStat, isDelta: false);
		return genericStat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, GenericStat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static GenericStat Deserialize(BufferStream stream, GenericStat instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.key = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static GenericStat DeserializeLengthDelimited(BufferStream stream, GenericStat instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.key = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static GenericStat DeserializeLength(BufferStream stream, int length, GenericStat instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.key = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, GenericStat instance, GenericStat previous)
	{
		if (instance.key != previous.key)
		{
			if (instance.key == null)
			{
				throw new ArgumentNullException("key", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.key);
		}
		if (instance.value != previous.value)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
		}
	}

	public static void Serialize(BufferStream stream, GenericStat instance)
	{
		if (instance.key == null)
		{
			throw new ArgumentNullException("key", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.key);
		if (instance.value != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Task : IDisposable, IPooled, IProto<Task>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public float remainingTime;

	[NonSerialized]
	public int taskUID;

	[NonSerialized]
	public bool cancelled;

	[NonSerialized]
	public Item.InstanceData instanceData;

	[NonSerialized]
	public int amount;

	[NonSerialized]
	public int skinID;

	[NonSerialized]
	public List<Item> takenItems;

	[NonSerialized]
	public int numCrafted;

	[NonSerialized]
	public float conditionScale;

	[NonSerialized]
	public NetworkableId workbenchEntity;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Task instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.itemID = 0;
		instance.remainingTime = 0f;
		instance.taskUID = 0;
		instance.cancelled = false;
		if (instance.instanceData != null)
		{
			instance.instanceData.ResetToPool();
			instance.instanceData = null;
		}
		instance.amount = 0;
		instance.skinID = 0;
		if (instance.takenItems != null)
		{
			for (int i = 0; i < instance.takenItems.Count; i++)
			{
				if (instance.takenItems[i] != null)
				{
					instance.takenItems[i].ResetToPool();
					instance.takenItems[i] = null;
				}
			}
			List<Item> list = instance.takenItems;
			Pool.Free<Item>(ref list, false);
			instance.takenItems = list;
		}
		instance.numCrafted = 0;
		instance.conditionScale = 0f;
		instance.workbenchEntity = default(NetworkableId);
		Pool.Free<Task>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Task with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Task instance)
	{
		instance.itemID = itemID;
		instance.remainingTime = remainingTime;
		instance.taskUID = taskUID;
		instance.cancelled = cancelled;
		if (instanceData != null)
		{
			if (instance.instanceData == null)
			{
				instance.instanceData = instanceData.Copy();
			}
			else
			{
				instanceData.CopyTo(instance.instanceData);
			}
		}
		else
		{
			instance.instanceData = null;
		}
		instance.amount = amount;
		instance.skinID = skinID;
		if (takenItems != null)
		{
			instance.takenItems = Pool.Get<List<Item>>();
			for (int i = 0; i < takenItems.Count; i++)
			{
				Item item = takenItems[i].Copy();
				instance.takenItems.Add(item);
			}
		}
		else
		{
			instance.takenItems = null;
		}
		instance.numCrafted = numCrafted;
		instance.conditionScale = conditionScale;
		instance.workbenchEntity = workbenchEntity;
	}

	public Task Copy()
	{
		Task task = Pool.Get<Task>();
		CopyTo(task);
		return task;
	}

	public static Task Deserialize(BufferStream stream)
	{
		Task task = Pool.Get<Task>();
		Deserialize(stream, task, isDelta: false);
		return task;
	}

	public static Task DeserializeLengthDelimited(BufferStream stream)
	{
		Task task = Pool.Get<Task>();
		DeserializeLengthDelimited(stream, task, isDelta: false);
		return task;
	}

	public static Task DeserializeLength(BufferStream stream, int length)
	{
		Task task = Pool.Get<Task>();
		DeserializeLength(stream, length, task, isDelta: false);
		return task;
	}

	public static Task Deserialize(byte[] buffer)
	{
		Task task = Pool.Get<Task>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, task, isDelta: false);
		return task;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Task previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Task Deserialize(BufferStream stream, Task instance, bool isDelta)
	{
		if (!isDelta && instance.takenItems == null)
		{
			instance.takenItems = Pool.Get<List<Item>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 21:
				instance.remainingTime = ProtocolParser.ReadSingle(stream);
				break;
			case 24:
				instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.cancelled = ProtocolParser.ReadBool(stream);
				break;
			case 42:
				if (instance.instanceData == null)
				{
					instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			case 48:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 66:
				instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
				break;
			case 72:
				instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 85:
				instance.conditionScale = ProtocolParser.ReadSingle(stream);
				break;
			case 88:
				instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static Task DeserializeLengthDelimited(BufferStream stream, Task instance, bool isDelta)
	{
		if (!isDelta && instance.takenItems == null)
		{
			instance.takenItems = Pool.Get<List<Item>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 21:
				instance.remainingTime = ProtocolParser.ReadSingle(stream);
				break;
			case 24:
				instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.cancelled = ProtocolParser.ReadBool(stream);
				break;
			case 42:
				if (instance.instanceData == null)
				{
					instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			case 48:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 66:
				instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
				break;
			case 72:
				instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 85:
				instance.conditionScale = ProtocolParser.ReadSingle(stream);
				break;
			case 88:
				instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Task DeserializeLength(BufferStream stream, int length, Task instance, bool isDelta)
	{
		if (!isDelta && instance.takenItems == null)
		{
			instance.takenItems = Pool.Get<List<Item>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 21:
				instance.remainingTime = ProtocolParser.ReadSingle(stream);
				break;
			case 24:
				instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.cancelled = ProtocolParser.ReadBool(stream);
				break;
			case 42:
				if (instance.instanceData == null)
				{
					instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			case 48:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 66:
				instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
				break;
			case 72:
				instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 85:
				instance.conditionScale = ProtocolParser.ReadSingle(stream);
				break;
			case 88:
				instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Task instance, Task previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.remainingTime != previous.remainingTime)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.remainingTime);
		}
		if (instance.taskUID != previous.taskUID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.taskUID);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.cancelled);
		if (instance.instanceData != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Item.InstanceData.SerializeDelta(stream, instance.instanceData, previous.instanceData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.skinID != previous.skinID)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.skinID);
		}
		if (instance.takenItems != null)
		{
			for (int i = 0; i < instance.takenItems.Count; i++)
			{
				Item item = instance.takenItems[i];
				stream.WriteByte(66);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Item.SerializeDelta(stream, item, item);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.numCrafted != previous.numCrafted)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numCrafted);
		}
		if (instance.conditionScale != previous.conditionScale)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.conditionScale);
		}
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, instance.workbenchEntity.Value);
	}

	public static void Serialize(BufferStream stream, Task instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.remainingTime != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.remainingTime);
		}
		if (instance.taskUID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.taskUID);
		}
		if (instance.cancelled)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.cancelled);
		}
		if (instance.instanceData != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Item.InstanceData.Serialize(stream, instance.instanceData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.skinID != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.skinID);
		}
		if (instance.takenItems != null)
		{
			for (int i = 0; i < instance.takenItems.Count; i++)
			{
				Item instance2 = instance.takenItems[i];
				stream.WriteByte(66);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Item.Serialize(stream, instance2);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.numCrafted != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numCrafted);
		}
		if (instance.conditionScale != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.conditionScale);
		}
		if (instance.workbenchEntity != default(NetworkableId))
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, instance.workbenchEntity.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		instanceData?.InspectUids(action);
		if (takenItems != null)
		{
			for (int i = 0; i < takenItems.Count; i++)
			{
				takenItems[i]?.InspectUids(action);
			}
		}
		action(UidType.Clear, ref workbenchEntity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Projectile : IDisposable, IPooled, IProto<Projectile>, IProto
{
	[NonSerialized]
	public int projectileID;

	[NonSerialized]
	public Vector3 startPos;

	[NonSerialized]
	public Vector3 startVel;

	[NonSerialized]
	public int seed;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Projectile instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.projectileID = 0;
			instance.startPos = default(Vector3);
			instance.startVel = default(Vector3);
			instance.seed = 0;
			Pool.Free<Projectile>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Projectile with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Projectile instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.projectileID = projectileID;
		instance.startPos = startPos;
		instance.startVel = startVel;
		instance.seed = seed;
	}

	public Projectile Copy()
	{
		Projectile projectile = Pool.Get<Projectile>();
		CopyTo(projectile);
		return projectile;
	}

	public static Projectile Deserialize(BufferStream stream)
	{
		Projectile projectile = Pool.Get<Projectile>();
		Deserialize(stream, projectile, isDelta: false);
		return projectile;
	}

	public static Projectile DeserializeLengthDelimited(BufferStream stream)
	{
		Projectile projectile = Pool.Get<Projectile>();
		DeserializeLengthDelimited(stream, projectile, isDelta: false);
		return projectile;
	}

	public static Projectile DeserializeLength(BufferStream stream, int length)
	{
		Projectile projectile = Pool.Get<Projectile>();
		DeserializeLength(stream, length, projectile, isDelta: false);
		return projectile;
	}

	public static Projectile Deserialize(byte[] buffer)
	{
		Projectile projectile = Pool.Get<Projectile>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, projectile, isDelta: false);
		return projectile;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Projectile previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Projectile Deserialize(BufferStream stream, Projectile instance, bool isDelta)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
				continue;
			case 32:
				instance.seed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Projectile DeserializeLengthDelimited(BufferStream stream, Projectile instance, bool isDelta)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
				continue;
			case 32:
				instance.seed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Projectile DeserializeLength(BufferStream stream, int length, Projectile instance, bool isDelta)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
				continue;
			case 32:
				instance.seed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Projectile instance, Projectile previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != previous.projectileID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.startPos != previous.startPos)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.startPos, previous.startPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.startVel != previous.startVel)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.startVel, previous.startVel);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startVel (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.seed != previous.seed)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.seed);
		}
	}

	public static void Serialize(BufferStream stream, Projectile instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.startPos != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.startPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.startVel != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.startVel);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startVel (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.seed != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.seed);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class SpawnOptions : IDisposable, IPooled, IProto<SpawnOptions>, IProto
{
	public enum RespawnType
	{
		SleepingBag = 1,
		Bed,
		BeachTowel,
		Camper,
		Static
	}

	public enum RespawnState
	{
		OK = 1,
		Occupied,
		Underwater,
		InNoRespawnZone
	}

	[NonSerialized]
	public RespawnType type;

	[NonSerialized]
	public NetworkableId id;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public float unlockSeconds;

	[NonSerialized]
	public Vector3 worldPosition;

	[NonSerialized]
	public RespawnState respawnState;

	[NonSerialized]
	public bool mobile;

	[NonSerialized]
	public string nexusZone;

	[NonSerialized]
	public bool corpse;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpawnOptions instance)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.type = (RespawnType)0;
			instance.id = default(NetworkableId);
			instance.name = string.Empty;
			instance.unlockSeconds = 0f;
			instance.worldPosition = default(Vector3);
			instance.respawnState = (RespawnState)0;
			instance.mobile = false;
			instance.nexusZone = string.Empty;
			instance.corpse = false;
			Pool.Free<SpawnOptions>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpawnOptions with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpawnOptions instance)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.type = type;
		instance.id = id;
		instance.name = name;
		instance.unlockSeconds = unlockSeconds;
		instance.worldPosition = worldPosition;
		instance.respawnState = respawnState;
		instance.mobile = mobile;
		instance.nexusZone = nexusZone;
		instance.corpse = corpse;
	}

	public SpawnOptions Copy()
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		CopyTo(spawnOptions);
		return spawnOptions;
	}

	public static SpawnOptions Deserialize(BufferStream stream)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		Deserialize(stream, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public static SpawnOptions DeserializeLengthDelimited(BufferStream stream)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		DeserializeLengthDelimited(stream, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public static SpawnOptions DeserializeLength(BufferStream stream, int length)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		DeserializeLength(stream, length, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public static SpawnOptions Deserialize(byte[] buffer)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpawnOptions previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpawnOptions Deserialize(BufferStream stream, SpawnOptions instance, bool isDelta)
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.respawnState = RespawnState.OK;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 37:
				instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 48:
				instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.corpse = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpawnOptions DeserializeLengthDelimited(BufferStream stream, SpawnOptions instance, bool isDelta)
	{
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.respawnState = RespawnState.OK;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 37:
				instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 48:
				instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.corpse = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpawnOptions DeserializeLength(BufferStream stream, int length, SpawnOptions instance, bool isDelta)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.respawnState = RespawnState.OK;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 37:
				instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 48:
				instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.corpse = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpawnOptions instance, SpawnOptions previous)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.id.Value);
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.unlockSeconds != previous.unlockSeconds)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
		}
		if (instance.worldPosition != previous.worldPosition)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.worldPosition, previous.worldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.mobile);
		if (instance.nexusZone != null && instance.nexusZone != previous.nexusZone)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.corpse);
	}

	public static void Serialize(BufferStream stream, SpawnOptions instance)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.id != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.id.Value);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.unlockSeconds != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
		}
		if (instance.worldPosition != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.worldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
		if (instance.mobile)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.mobile);
		}
		if (instance.nexusZone != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		if (instance.corpse)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.corpse);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref id.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ClientInfo : IDisposable, IPooled, IProto<ClientInfo>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public string value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClientInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.value = string.Empty;
			Pool.Free<ClientInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClientInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClientInfo instance)
	{
		instance.name = name;
		instance.value = value;
	}

	public ClientInfo Copy()
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		CopyTo(clientInfo);
		return clientInfo;
	}

	public static ClientInfo Deserialize(BufferStream stream)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		Deserialize(stream, clientInfo, isDelta: false);
		return clientInfo;
	}

	public static ClientInfo DeserializeLengthDelimited(BufferStream stream)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		DeserializeLengthDelimited(stream, clientInfo, isDelta: false);
		return clientInfo;
	}

	public static ClientInfo DeserializeLength(BufferStream stream, int length)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		DeserializeLength(stream, length, clientInfo, isDelta: false);
		return clientInfo;
	}

	public static ClientInfo Deserialize(byte[] buffer)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clientInfo, isDelta: false);
		return clientInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClientInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClientInfo Deserialize(BufferStream stream, ClientInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.value = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClientInfo DeserializeLengthDelimited(BufferStream stream, ClientInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.value = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClientInfo DeserializeLength(BufferStream stream, int length, ClientInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.value = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClientInfo instance, ClientInfo previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.value != previous.value)
		{
			if (instance.value == null)
			{
				throw new ArgumentNullException("value", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, ClientInfo instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.value == null)
		{
			throw new ArgumentNullException("value", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.value);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum MessageType
{
	Request = 1,
	Receive,
	Done
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class arcadeEnt : IDisposable, IPooled, IProto<arcadeEnt>, IProto
{
	[NonSerialized]
	public uint id;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public uint spriteID;

	[NonSerialized]
	public uint soundID;

	[NonSerialized]
	public bool visible;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 heading;

	[NonSerialized]
	public bool enabled;

	[NonSerialized]
	public Vector3 scale;

	[NonSerialized]
	public Vector3 colliderScale;

	[NonSerialized]
	public float alpha;

	[NonSerialized]
	public uint prefabID;

	[NonSerialized]
	public uint parentID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(arcadeEnt instance)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.id = 0u;
			instance.name = string.Empty;
			instance.spriteID = 0u;
			instance.soundID = 0u;
			instance.visible = false;
			instance.position = default(Vector3);
			instance.heading = default(Vector3);
			instance.enabled = false;
			instance.scale = default(Vector3);
			instance.colliderScale = default(Vector3);
			instance.alpha = 0f;
			instance.prefabID = 0u;
			instance.parentID = 0u;
			Pool.Free<arcadeEnt>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose arcadeEnt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(arcadeEnt instance)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		instance.id = id;
		instance.name = name;
		instance.spriteID = spriteID;
		instance.soundID = soundID;
		instance.visible = visible;
		instance.position = position;
		instance.heading = heading;
		instance.enabled = enabled;
		instance.scale = scale;
		instance.colliderScale = colliderScale;
		instance.alpha = alpha;
		instance.prefabID = prefabID;
		instance.parentID = parentID;
	}

	public arcadeEnt Copy()
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		CopyTo(arcadeEnt);
		return arcadeEnt;
	}

	public static arcadeEnt Deserialize(BufferStream stream)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		Deserialize(stream, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public static arcadeEnt DeserializeLengthDelimited(BufferStream stream)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		DeserializeLengthDelimited(stream, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public static arcadeEnt DeserializeLength(BufferStream stream, int length)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		DeserializeLength(stream, length, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public static arcadeEnt Deserialize(byte[] buffer)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, arcadeEnt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static arcadeEnt Deserialize(BufferStream stream, arcadeEnt instance, bool isDelta)
	{
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.spriteID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.soundID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 40:
				instance.visible = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
				continue;
			case 64:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
				continue;
			case 93:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 96:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 104:
				instance.parentID = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static arcadeEnt DeserializeLengthDelimited(BufferStream stream, arcadeEnt instance, bool isDelta)
	{
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.spriteID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.soundID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 40:
				instance.visible = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
				continue;
			case 64:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
				continue;
			case 93:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 96:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 104:
				instance.parentID = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static arcadeEnt DeserializeLength(BufferStream stream, int length, arcadeEnt instance, bool isDelta)
	{
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.spriteID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.soundID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 40:
				instance.visible = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
				continue;
			case 64:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
				continue;
			case 93:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 96:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 104:
				instance.parentID = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, arcadeEnt instance, arcadeEnt previous)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		if (instance.id != previous.id)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.spriteID != previous.spriteID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.spriteID);
		}
		if (instance.soundID != previous.soundID)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.soundID);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.visible);
		if (instance.position != previous.position)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.heading != previous.heading)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.heading, previous.heading);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heading (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.enabled);
		if (instance.scale != previous.scale)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.scale, previous.scale);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.colliderScale != previous.colliderScale)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.colliderScale, previous.colliderScale);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colliderScale (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		if (instance.alpha != previous.alpha)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.prefabID != previous.prefabID)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.prefabID);
		}
		if (instance.parentID != previous.parentID)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt32(stream, instance.parentID);
		}
	}

	public static void Serialize(BufferStream stream, arcadeEnt instance)
	{
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		if (instance.id != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.spriteID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.spriteID);
		}
		if (instance.soundID != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.soundID);
		}
		if (instance.visible)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.visible);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.heading != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.heading);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heading (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.enabled)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.enabled);
		}
		if (instance.scale != default(Vector3))
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.scale);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.colliderScale != default(Vector3))
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.colliderScale);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colliderScale (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		if (instance.alpha != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.prefabID != 0)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.prefabID);
		}
		if (instance.parentID != 0)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt32(stream, instance.parentID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class DirectoryEntry : IDisposable, IPooled, IProto<DirectoryEntry>, IProto
{
	[NonSerialized]
	public int phoneNumber;

	[NonSerialized]
	public string phoneName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DirectoryEntry instance)
	{
		if (instance.ShouldPool)
		{
			instance.phoneNumber = 0;
			instance.phoneName = string.Empty;
			Pool.Free<DirectoryEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DirectoryEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DirectoryEntry instance)
	{
		instance.phoneNumber = phoneNumber;
		instance.phoneName = phoneName;
	}

	public DirectoryEntry Copy()
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		CopyTo(directoryEntry);
		return directoryEntry;
	}

	public static DirectoryEntry Deserialize(BufferStream stream)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		Deserialize(stream, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public static DirectoryEntry DeserializeLengthDelimited(BufferStream stream)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		DeserializeLengthDelimited(stream, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public static DirectoryEntry DeserializeLength(BufferStream stream, int length)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		DeserializeLength(stream, length, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public static DirectoryEntry Deserialize(byte[] buffer)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DirectoryEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DirectoryEntry Deserialize(BufferStream stream, DirectoryEntry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.phoneName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DirectoryEntry DeserializeLengthDelimited(BufferStream stream, DirectoryEntry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.phoneName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DirectoryEntry DeserializeLength(BufferStream stream, int length, DirectoryEntry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.phoneName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DirectoryEntry instance, DirectoryEntry previous)
	{
		if (instance.phoneNumber != previous.phoneNumber)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		if (instance.phoneName != previous.phoneName)
		{
			if (instance.phoneName == null)
			{
				throw new ArgumentNullException("phoneName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}
	}

	public static void Serialize(BufferStream stream, DirectoryEntry instance)
	{
		if (instance.phoneNumber != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		if (instance.phoneName == null)
		{
			throw new ArgumentNullException("phoneName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.phoneName);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum Category
{
	Line,
	Log,
	Text,
	Sphere,
	Box
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Monument : IDisposable, IPooled, IProto<Monument>, IProto
{
	[NonSerialized]
	public string token;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Monument instance)
	{
		if (instance.ShouldPool)
		{
			instance.token = string.Empty;
			instance.x = 0f;
			instance.y = 0f;
			Pool.Free<Monument>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Monument with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Monument instance)
	{
		instance.token = token;
		instance.x = x;
		instance.y = y;
	}

	public Monument Copy()
	{
		Monument monument = Pool.Get<Monument>();
		CopyTo(monument);
		return monument;
	}

	public static Monument Deserialize(BufferStream stream)
	{
		Monument monument = Pool.Get<Monument>();
		Deserialize(stream, monument, isDelta: false);
		return monument;
	}

	public static Monument DeserializeLengthDelimited(BufferStream stream)
	{
		Monument monument = Pool.Get<Monument>();
		DeserializeLengthDelimited(stream, monument, isDelta: false);
		return monument;
	}

	public static Monument DeserializeLength(BufferStream stream, int length)
	{
		Monument monument = Pool.Get<Monument>();
		DeserializeLength(stream, length, monument, isDelta: false);
		return monument;
	}

	public static Monument Deserialize(byte[] buffer)
	{
		Monument monument = Pool.Get<Monument>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, monument, isDelta: false);
		return monument;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Monument previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Monument Deserialize(BufferStream stream, Monument instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.token = ProtocolParser.ReadString(stream);
				continue;
			case 21:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Monument DeserializeLengthDelimited(BufferStream stream, Monument instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.token = ProtocolParser.ReadString(stream);
				continue;
			case 21:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Monument DeserializeLength(BufferStream stream, int length, Monument instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.token = ProtocolParser.ReadString(stream);
				continue;
			case 21:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Monument instance, Monument previous)
	{
		if (instance.token != previous.token)
		{
			if (instance.token == null)
			{
				throw new ArgumentNullException("token", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.token);
		}
		if (instance.x != previous.x)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
	}

	public static void Serialize(BufferStream stream, Monument instance)
	{
		if (instance.token == null)
		{
			throw new ArgumentNullException("token", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.token);
		if (instance.x != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Item : IDisposable, IPooled, IProto<Item>, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public int quantity;

	[NonSerialized]
	public bool itemIsBlueprint;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Item instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
			Pool.Free<Item>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Item with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Item instance)
	{
		instance.itemId = itemId;
		instance.quantity = quantity;
		instance.itemIsBlueprint = itemIsBlueprint;
	}

	public Item Copy()
	{
		Item item = Pool.Get<Item>();
		CopyTo(item);
		return item;
	}

	public static Item Deserialize(BufferStream stream)
	{
		Item item = Pool.Get<Item>();
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLengthDelimited(BufferStream stream)
	{
		Item item = Pool.Get<Item>();
		DeserializeLengthDelimited(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLength(BufferStream stream, int length)
	{
		Item item = Pool.Get<Item>();
		DeserializeLength(stream, length, item, isDelta: false);
		return item;
	}

	public static Item Deserialize(byte[] buffer)
	{
		Item item = Pool.Get<Item>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Item previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Item Deserialize(BufferStream stream, Item instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Item DeserializeLengthDelimited(BufferStream stream, Item instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Item DeserializeLength(BufferStream stream, int length, Item instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Item instance, Item previous)
	{
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != previous.quantity)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
	}

	public static void Serialize(BufferStream stream, Item instance)
	{
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		if (instance.itemIsBlueprint)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Member : IDisposable, IPooled, IProto<Member>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public bool isOnline;

	[NonSerialized]
	public uint spawnTime;

	[NonSerialized]
	public bool isAlive;

	[NonSerialized]
	public uint deathTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Member instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.name = string.Empty;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
			Pool.Free<Member>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Member with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Member instance)
	{
		instance.steamId = steamId;
		instance.name = name;
		instance.x = x;
		instance.y = y;
		instance.isOnline = isOnline;
		instance.spawnTime = spawnTime;
		instance.isAlive = isAlive;
		instance.deathTime = deathTime;
	}

	public Member Copy()
	{
		Member member = Pool.Get<Member>();
		CopyTo(member);
		return member;
	}

	public static Member Deserialize(BufferStream stream)
	{
		Member member = Pool.Get<Member>();
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLengthDelimited(BufferStream stream)
	{
		Member member = Pool.Get<Member>();
		DeserializeLengthDelimited(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLength(BufferStream stream, int length)
	{
		Member member = Pool.Get<Member>();
		DeserializeLength(stream, length, member, isDelta: false);
		return member;
	}

	public static Member Deserialize(byte[] buffer)
	{
		Member member = Pool.Get<Member>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Member previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Member Deserialize(BufferStream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.isOnline = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.spawnTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.isAlive = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.deathTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Member DeserializeLengthDelimited(BufferStream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.isOnline = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.spawnTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.isAlive = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.deathTime = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Member DeserializeLength(BufferStream stream, int length, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.isOnline = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.spawnTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.isAlive = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.deathTime = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Member instance, Member previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.x != previous.x)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.isOnline);
		if (instance.spawnTime != previous.spawnTime)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.spawnTime);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.isAlive);
		if (instance.deathTime != previous.deathTime)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.deathTime);
		}
	}

	public static void Serialize(BufferStream stream, Member instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.x != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.isOnline)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isOnline);
		}
		if (instance.spawnTime != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.spawnTime);
		}
		if (instance.isAlive)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isAlive);
		}
		if (instance.deathTime != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.deathTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Note : IDisposable, IPooled, IProto<Note>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public int icon;

	[NonSerialized]
	public int colourIndex;

	[NonSerialized]
	public string label;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Note instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
			instance.label = string.Empty;
			Pool.Free<Note>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Note with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Note instance)
	{
		instance.type = type;
		instance.x = x;
		instance.y = y;
		instance.icon = icon;
		instance.colourIndex = colourIndex;
		instance.label = label;
	}

	public Note Copy()
	{
		Note note = Pool.Get<Note>();
		CopyTo(note);
		return note;
	}

	public static Note Deserialize(BufferStream stream)
	{
		Note note = Pool.Get<Note>();
		Deserialize(stream, note, isDelta: false);
		return note;
	}

	public static Note DeserializeLengthDelimited(BufferStream stream)
	{
		Note note = Pool.Get<Note>();
		DeserializeLengthDelimited(stream, note, isDelta: false);
		return note;
	}

	public static Note DeserializeLength(BufferStream stream, int length)
	{
		Note note = Pool.Get<Note>();
		DeserializeLength(stream, length, note, isDelta: false);
		return note;
	}

	public static Note Deserialize(byte[] buffer)
	{
		Note note = Pool.Get<Note>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, note, isDelta: false);
		return note;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Note previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Note Deserialize(BufferStream stream, Note instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Note DeserializeLengthDelimited(BufferStream stream, Note instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Note DeserializeLength(BufferStream stream, int length, Note instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Note instance, Note previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.x != previous.x)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.icon != previous.icon)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != previous.colourIndex)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null && instance.label != previous.label)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteString(stream, instance.label);
		}
	}

	public static void Serialize(BufferStream stream, Note instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.x != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.icon != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteString(stream, instance.label);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SellOrder : IDisposable, IPooled, IProto<SellOrder>, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public int quantity;

	[NonSerialized]
	public int currencyId;

	[NonSerialized]
	public int costPerItem;

	[NonSerialized]
	public int amountInStock;

	[NonSerialized]
	public bool itemIsBlueprint;

	[NonSerialized]
	public bool currencyIsBlueprint;

	[NonSerialized]
	public float itemCondition;

	[NonSerialized]
	public float itemConditionMax;

	[NonSerialized]
	public float priceMultiplier;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SellOrder instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
			Pool.Free<SellOrder>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SellOrder with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SellOrder instance)
	{
		instance.itemId = itemId;
		instance.quantity = quantity;
		instance.currencyId = currencyId;
		instance.costPerItem = costPerItem;
		instance.amountInStock = amountInStock;
		instance.itemIsBlueprint = itemIsBlueprint;
		instance.currencyIsBlueprint = currencyIsBlueprint;
		instance.itemCondition = itemCondition;
		instance.itemConditionMax = itemConditionMax;
		instance.priceMultiplier = priceMultiplier;
	}

	public SellOrder Copy()
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		CopyTo(sellOrder);
		return sellOrder;
	}

	public static SellOrder Deserialize(BufferStream stream)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		Deserialize(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder DeserializeLengthDelimited(BufferStream stream)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		DeserializeLengthDelimited(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder DeserializeLength(BufferStream stream, int length)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		DeserializeLength(stream, length, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder Deserialize(byte[] buffer)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SellOrder previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SellOrder Deserialize(BufferStream stream, SellOrder instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SellOrder DeserializeLengthDelimited(BufferStream stream, SellOrder instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SellOrder DeserializeLength(BufferStream stream, int length, SellOrder instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SellOrder instance, SellOrder previous)
	{
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != previous.quantity)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		if (instance.currencyId != previous.currencyId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
		}
		if (instance.costPerItem != previous.costPerItem)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
		}
		if (instance.amountInStock != previous.amountInStock)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
		if (instance.itemCondition != previous.itemCondition)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.itemCondition);
		}
		if (instance.itemConditionMax != previous.itemConditionMax)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
		}
		if (instance.priceMultiplier != previous.priceMultiplier)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
		}
	}

	public static void Serialize(BufferStream stream, SellOrder instance)
	{
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		if (instance.currencyId != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
		}
		if (instance.costPerItem != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
		}
		if (instance.amountInStock != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
		}
		if (instance.itemIsBlueprint)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		}
		if (instance.currencyIsBlueprint)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
		}
		if (instance.itemCondition != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.itemCondition);
		}
		if (instance.itemConditionMax != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
		}
		if (instance.priceMultiplier != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum EntityType
{
	Tree = 1,
	Player
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Entity : IDisposable, IPooled, IProto<Entity>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public EntityType type;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 rotation;

	[NonSerialized]
	public Vector3 size;

	[NonSerialized]
	public string name;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entity instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.type = (EntityType)0;
			instance.position = default(Vector3);
			instance.rotation = default(Vector3);
			instance.size = default(Vector3);
			instance.name = string.Empty;
			Pool.Free<Entity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entity instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.entityId = entityId;
		instance.type = type;
		instance.position = position;
		instance.rotation = rotation;
		instance.size = size;
		instance.name = name;
	}

	public Entity Copy()
	{
		Entity entity = Pool.Get<Entity>();
		CopyTo(entity);
		return entity;
	}

	public static Entity Deserialize(BufferStream stream)
	{
		Entity entity = Pool.Get<Entity>();
		Deserialize(stream, entity, isDelta: false);
		return entity;
	}

	public static Entity DeserializeLengthDelimited(BufferStream stream)
	{
		Entity entity = Pool.Get<Entity>();
		DeserializeLengthDelimited(stream, entity, isDelta: false);
		return entity;
	}

	public static Entity DeserializeLength(BufferStream stream, int length)
	{
		Entity entity = Pool.Get<Entity>();
		DeserializeLength(stream, length, entity, isDelta: false);
		return entity;
	}

	public static Entity Deserialize(byte[] buffer)
	{
		Entity entity = Pool.Get<Entity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entity, isDelta: false);
		return entity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Entity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entity Deserialize(BufferStream stream, Entity instance, bool isDelta)
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 50:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entity DeserializeLengthDelimited(BufferStream stream, Entity instance, bool isDelta)
	{
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 50:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entity DeserializeLength(BufferStream stream, int length, Entity instance, bool isDelta)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 50:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Entity instance, Entity previous)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.position != previous.position)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rotation, previous.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.size != previous.size)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.size, previous.size);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public static void Serialize(BufferStream stream, Entity instance)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.size != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.size);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.name != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Role : IDisposable, IPooled, IProto<Role>, IProto
{
	[NonSerialized]
	public int roleId;

	[NonSerialized]
	public int rank;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public bool canSetMotd;

	[NonSerialized]
	public bool canSetLogo;

	[NonSerialized]
	public bool canInvite;

	[NonSerialized]
	public bool canKick;

	[NonSerialized]
	public bool canPromote;

	[NonSerialized]
	public bool canDemote;

	[NonSerialized]
	public bool canSetPlayerNotes;

	[NonSerialized]
	public bool canAccessLogs;

	[NonSerialized]
	public bool canAccessScoreEvents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Role instance)
	{
		if (instance.ShouldPool)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.name = string.Empty;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
			Pool.Free<Role>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Role with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Role instance)
	{
		instance.roleId = roleId;
		instance.rank = rank;
		instance.name = name;
		instance.canSetMotd = canSetMotd;
		instance.canSetLogo = canSetLogo;
		instance.canInvite = canInvite;
		instance.canKick = canKick;
		instance.canPromote = canPromote;
		instance.canDemote = canDemote;
		instance.canSetPlayerNotes = canSetPlayerNotes;
		instance.canAccessLogs = canAccessLogs;
		instance.canAccessScoreEvents = canAccessScoreEvents;
	}

	public Role Copy()
	{
		Role role = Pool.Get<Role>();
		CopyTo(role);
		return role;
	}

	public static Role Deserialize(BufferStream stream)
	{
		Role role = Pool.Get<Role>();
		Deserialize(stream, role, isDelta: false);
		return role;
	}

	public static Role DeserializeLengthDelimited(BufferStream stream)
	{
		Role role = Pool.Get<Role>();
		DeserializeLengthDelimited(stream, role, isDelta: false);
		return role;
	}

	public static Role DeserializeLength(BufferStream stream, int length)
	{
		Role role = Pool.Get<Role>();
		DeserializeLength(stream, length, role, isDelta: false);
		return role;
	}

	public static Role Deserialize(byte[] buffer)
	{
		Role role = Pool.Get<Role>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, role, isDelta: false);
		return role;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Role previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Role Deserialize(BufferStream stream, Role instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rank = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.canSetMotd = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.canSetLogo = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.canInvite = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.canKick = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.canPromote = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.canDemote = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.canAccessLogs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Role DeserializeLengthDelimited(BufferStream stream, Role instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rank = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.canSetMotd = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.canSetLogo = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.canInvite = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.canKick = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.canPromote = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.canDemote = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.canAccessLogs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Role DeserializeLength(BufferStream stream, int length, Role instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rank = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.canSetMotd = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.canSetLogo = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.canInvite = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.canKick = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.canPromote = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.canDemote = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.canAccessLogs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Role instance, Role previous)
	{
		if (instance.roleId != previous.roleId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		if (instance.rank != previous.rank)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.canSetMotd);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.canSetLogo);
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.canInvite);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.canKick);
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.canPromote);
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.canDemote);
		stream.WriteByte(80);
		ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
		stream.WriteByte(88);
		ProtocolParser.WriteBool(stream, instance.canAccessLogs);
		stream.WriteByte(96);
		ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
	}

	public static void Serialize(BufferStream stream, Role instance)
	{
		if (instance.roleId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		if (instance.rank != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.canSetMotd)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.canSetMotd);
		}
		if (instance.canSetLogo)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.canSetLogo);
		}
		if (instance.canInvite)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.canInvite);
		}
		if (instance.canKick)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.canKick);
		}
		if (instance.canPromote)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.canPromote);
		}
		if (instance.canDemote)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.canDemote);
		}
		if (instance.canSetPlayerNotes)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
		}
		if (instance.canAccessLogs)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteBool(stream, instance.canAccessLogs);
		}
		if (instance.canAccessScoreEvents)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Member : IDisposable, IPooled, IProto<Member>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public int roleId;

	[NonSerialized]
	public long joined;

	[NonSerialized]
	public long lastSeen;

	[NonSerialized]
	public string notes;

	[NonSerialized]
	public bool online;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Member instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.notes = string.Empty;
			instance.online = false;
			Pool.Free<Member>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Member with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Member instance)
	{
		instance.steamId = steamId;
		instance.roleId = roleId;
		instance.joined = joined;
		instance.lastSeen = lastSeen;
		instance.notes = notes;
		instance.online = online;
	}

	public Member Copy()
	{
		Member member = Pool.Get<Member>();
		CopyTo(member);
		return member;
	}

	public static Member Deserialize(BufferStream stream)
	{
		Member member = Pool.Get<Member>();
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLengthDelimited(BufferStream stream)
	{
		Member member = Pool.Get<Member>();
		DeserializeLengthDelimited(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLength(BufferStream stream, int length)
	{
		Member member = Pool.Get<Member>();
		DeserializeLength(stream, length, member, isDelta: false);
		return member;
	}

	public static Member Deserialize(byte[] buffer)
	{
		Member member = Pool.Get<Member>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Member previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Member Deserialize(BufferStream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.online = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.joined = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Member DeserializeLengthDelimited(BufferStream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.online = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.joined = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Member DeserializeLength(BufferStream stream, int length, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.online = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.joined = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Member instance, Member previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.roleId != previous.roleId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
		if (instance.notes != null && instance.notes != previous.notes)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.notes);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.online);
	}

	public static void Serialize(BufferStream stream, Member instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.roleId != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		if (instance.joined != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
		}
		if (instance.lastSeen != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
		}
		if (instance.notes != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.notes);
		}
		if (instance.online)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.online);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Invite : IDisposable, IPooled, IProto<Invite>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public ulong recruiter;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Invite instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
			Pool.Free<Invite>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Invite with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Invite instance)
	{
		instance.steamId = steamId;
		instance.recruiter = recruiter;
		instance.timestamp = timestamp;
	}

	public Invite Copy()
	{
		Invite invite = Pool.Get<Invite>();
		CopyTo(invite);
		return invite;
	}

	public static Invite Deserialize(BufferStream stream)
	{
		Invite invite = Pool.Get<Invite>();
		Deserialize(stream, invite, isDelta: false);
		return invite;
	}

	public static Invite DeserializeLengthDelimited(BufferStream stream)
	{
		Invite invite = Pool.Get<Invite>();
		DeserializeLengthDelimited(stream, invite, isDelta: false);
		return invite;
	}

	public static Invite DeserializeLength(BufferStream stream, int length)
	{
		Invite invite = Pool.Get<Invite>();
		DeserializeLength(stream, length, invite, isDelta: false);
		return invite;
	}

	public static Invite Deserialize(byte[] buffer)
	{
		Invite invite = Pool.Get<Invite>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, invite, isDelta: false);
		return invite;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Invite previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Invite Deserialize(BufferStream stream, Invite instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Invite DeserializeLengthDelimited(BufferStream stream, Invite instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Invite DeserializeLength(BufferStream stream, int length, Invite instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Invite instance, Invite previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.recruiter != previous.recruiter)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, Invite instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.recruiter != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
{
	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public string eventKey;

	[NonSerialized]
	public string arg1;

	[NonSerialized]
	public string arg2;

	[NonSerialized]
	public string arg3;

	[NonSerialized]
	public string arg4;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entry instance)
	{
		if (instance.ShouldPool)
		{
			instance.timestamp = 0L;
			instance.eventKey = string.Empty;
			instance.arg1 = string.Empty;
			instance.arg2 = string.Empty;
			instance.arg3 = string.Empty;
			instance.arg4 = string.Empty;
			Pool.Free<Entry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entry instance)
	{
		instance.timestamp = timestamp;
		instance.eventKey = eventKey;
		instance.arg1 = arg1;
		instance.arg2 = arg2;
		instance.arg3 = arg3;
		instance.arg4 = arg4;
	}

	public Entry Copy()
	{
		Entry entry = Pool.Get<Entry>();
		CopyTo(entry);
		return entry;
	}

	public static Entry Deserialize(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLengthDelimited(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLength(BufferStream stream, int length)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLength(stream, length, entry, isDelta: false);
		return entry;
	}

	public static Entry Deserialize(byte[] buffer)
	{
		Entry entry = Pool.Get<Entry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.eventKey = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.arg3 = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.arg4 = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.eventKey = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.arg3 = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.arg4 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.eventKey = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.arg3 = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.arg4 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.eventKey != previous.eventKey)
		{
			if (instance.eventKey == null)
			{
				throw new ArgumentNullException("eventKey", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.eventKey);
		}
		if (instance.arg1 != null && instance.arg1 != previous.arg1)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null && instance.arg2 != previous.arg2)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
		if (instance.arg3 != null && instance.arg3 != previous.arg3)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.arg3);
		}
		if (instance.arg4 != null && instance.arg4 != previous.arg4)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.arg4);
		}
	}

	public static void Serialize(BufferStream stream, Entry instance)
	{
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.eventKey == null)
		{
			throw new ArgumentNullException("eventKey", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.eventKey);
		if (instance.arg1 != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
		if (instance.arg3 != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.arg3);
		}
		if (instance.arg4 != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.arg4);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
{
	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public int type;

	[NonSerialized]
	public int score;

	[NonSerialized]
	public int multiplier;

	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public ulong otherSteamId;

	[NonSerialized]
	public long otherClanId;

	[NonSerialized]
	public string arg1;

	[NonSerialized]
	public string arg2;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entry instance)
	{
		if (instance.ShouldPool)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
			instance.arg1 = string.Empty;
			instance.arg2 = string.Empty;
			Pool.Free<Entry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entry instance)
	{
		instance.timestamp = timestamp;
		instance.type = type;
		instance.score = score;
		instance.multiplier = multiplier;
		instance.steamId = steamId;
		instance.otherSteamId = otherSteamId;
		instance.otherClanId = otherClanId;
		instance.arg1 = arg1;
		instance.arg2 = arg2;
	}

	public Entry Copy()
	{
		Entry entry = Pool.Get<Entry>();
		CopyTo(entry);
		return entry;
	}

	public static Entry Deserialize(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLengthDelimited(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLength(BufferStream stream, int length)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLength(stream, length, entry, isDelta: false);
		return entry;
	}

	public static Entry Deserialize(byte[] buffer)
	{
		Entry entry = Pool.Get<Entry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 74:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 74:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 74:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.type != previous.type)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.score != previous.score)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
		if (instance.multiplier != previous.multiplier)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.otherSteamId != previous.otherSteamId)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
		if (instance.arg1 != null && instance.arg1 != previous.arg1)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null && instance.arg2 != previous.arg2)
		{
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
	}

	public static void Serialize(BufferStream stream, Entry instance)
	{
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.score != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
		if (instance.multiplier != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
		if (instance.steamId != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.otherSteamId != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
		}
		if (instance.otherClanId != 0L)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
		}
		if (instance.arg1 != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null)
		{
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Invitation : IDisposable, IPooled, IProto<Invitation>, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public ulong recruiter;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Invitation instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
			Pool.Free<Invitation>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Invitation with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Invitation instance)
	{
		instance.clanId = clanId;
		instance.recruiter = recruiter;
		instance.timestamp = timestamp;
	}

	public Invitation Copy()
	{
		Invitation invitation = Pool.Get<Invitation>();
		CopyTo(invitation);
		return invitation;
	}

	public static Invitation Deserialize(BufferStream stream)
	{
		Invitation invitation = Pool.Get<Invitation>();
		Deserialize(stream, invitation, isDelta: false);
		return invitation;
	}

	public static Invitation DeserializeLengthDelimited(BufferStream stream)
	{
		Invitation invitation = Pool.Get<Invitation>();
		DeserializeLengthDelimited(stream, invitation, isDelta: false);
		return invitation;
	}

	public static Invitation DeserializeLength(BufferStream stream, int length)
	{
		Invitation invitation = Pool.Get<Invitation>();
		DeserializeLength(stream, length, invitation, isDelta: false);
		return invitation;
	}

	public static Invitation Deserialize(byte[] buffer)
	{
		Invitation invitation = Pool.Get<Invitation>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, invitation, isDelta: false);
		return invitation;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Invitation previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Invitation Deserialize(BufferStream stream, Invitation instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Invitation DeserializeLengthDelimited(BufferStream stream, Invitation instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Invitation DeserializeLength(BufferStream stream, int length, Invitation instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Invitation instance, Invitation previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.recruiter != previous.recruiter)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, Invitation instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.recruiter != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public long score;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entry instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			instance.name = string.Empty;
			instance.score = 0L;
			Pool.Free<Entry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entry instance)
	{
		instance.clanId = clanId;
		instance.name = name;
		instance.score = score;
	}

	public Entry Copy()
	{
		Entry entry = Pool.Get<Entry>();
		CopyTo(entry);
		return entry;
	}

	public static Entry Deserialize(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLengthDelimited(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLength(BufferStream stream, int length)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLength(stream, length, entry, isDelta: false);
		return entry;
	}

	public static Entry Deserialize(byte[] buffer)
	{
		Entry entry = Pool.Get<Entry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.score = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.score = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.score = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
	}

	public static void Serialize(BufferStream stream, Entry instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.score != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class RelationshipData : IDisposable, IPooled, IProto<RelationshipData>, IProto
{
	[NonSerialized]
	public RelationshipManager.PlayerRelationshipInfo info;

	[NonSerialized]
	public ArraySegment<byte> mugshotData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RelationshipData instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.info != null)
			{
				instance.info.ResetToPool();
				instance.info = null;
			}
			if (instance.mugshotData.Array != null)
			{
				BufferStream.Shared.ArrayPool.Return(instance.mugshotData.Array);
			}
			instance.mugshotData = default(ArraySegment<byte>);
			Pool.Free<RelationshipData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RelationshipData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RelationshipData instance)
	{
		if (info != null)
		{
			if (instance.info == null)
			{
				instance.info = info.Copy();
			}
			else
			{
				info.CopyTo(instance.info);
			}
		}
		else
		{
			instance.info = null;
		}
		if (mugshotData.Array == null)
		{
			instance.mugshotData = default(ArraySegment<byte>);
			return;
		}
		byte[] array = BufferStream.Shared.ArrayPool.Rent(mugshotData.Count);
		Array.Copy(mugshotData.Array, 0, array, 0, mugshotData.Count);
		instance.mugshotData = new ArraySegment<byte>(array, 0, mugshotData.Count);
	}

	public RelationshipData Copy()
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		CopyTo(relationshipData);
		return relationshipData;
	}

	public static RelationshipData Deserialize(BufferStream stream)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		Deserialize(stream, relationshipData, isDelta: false);
		return relationshipData;
	}

	public static RelationshipData DeserializeLengthDelimited(BufferStream stream)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		DeserializeLengthDelimited(stream, relationshipData, isDelta: false);
		return relationshipData;
	}

	public static RelationshipData DeserializeLength(BufferStream stream, int length)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		DeserializeLength(stream, length, relationshipData, isDelta: false);
		return relationshipData;
	}

	public static RelationshipData Deserialize(byte[] buffer)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, relationshipData, isDelta: false);
		return relationshipData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RelationshipData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RelationshipData Deserialize(BufferStream stream, RelationshipData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.info == null)
				{
					instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				break;
			case 18:
				instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static RelationshipData DeserializeLengthDelimited(BufferStream stream, RelationshipData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.info == null)
				{
					instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				break;
			case 18:
				instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RelationshipData DeserializeLength(BufferStream stream, int length, RelationshipData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.info == null)
				{
					instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				break;
			case 18:
				instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RelationshipData instance, RelationshipData previous)
	{
		if (instance.info == null)
		{
			throw new ArgumentNullException("info", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		RelationshipManager.PlayerRelationshipInfo.SerializeDelta(stream, instance.info, previous.info);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
		if (instance.mugshotData.Array != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
		}
	}

	public static void Serialize(BufferStream stream, RelationshipData instance)
	{
		if (instance.info == null)
		{
			throw new ArgumentNullException("info", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		RelationshipManager.PlayerRelationshipInfo.Serialize(stream, instance.info);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
		if (instance.mugshotData.Array != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		info?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Message : IDisposable, IPooled, IProto<Message>, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public ulong userId;

	[NonSerialized]
	public string text;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Message instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			instance.userId = 0uL;
			instance.text = string.Empty;
			instance.name = string.Empty;
			instance.timestamp = 0L;
			Pool.Free<Message>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Message with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Message instance)
	{
		instance.clanId = clanId;
		instance.userId = userId;
		instance.text = text;
		instance.name = name;
		instance.timestamp = timestamp;
	}

	public Message Copy()
	{
		Message message = Pool.Get<Message>();
		CopyTo(message);
		return message;
	}

	public static Message Deserialize(BufferStream stream)
	{
		Message message = Pool.Get<Message>();
		Deserialize(stream, message, isDelta: false);
		return message;
	}

	public static Message DeserializeLengthDelimited(BufferStream stream)
	{
		Message message = Pool.Get<Message>();
		DeserializeLengthDelimited(stream, message, isDelta: false);
		return message;
	}

	public static Message DeserializeLength(BufferStream stream, int length)
	{
		Message message = Pool.Get<Message>();
		DeserializeLength(stream, length, message, isDelta: false);
		return message;
	}

	public static Message Deserialize(byte[] buffer)
	{
		Message message = Pool.Get<Message>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, message, isDelta: false);
		return message;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Message previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Message Deserialize(BufferStream stream, Message instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Message DeserializeLengthDelimited(BufferStream stream, Message instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Message DeserializeLength(BufferStream stream, int length, Message instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Message instance, Message previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.text != previous.text)
		{
			if (instance.text == null)
			{
				throw new ArgumentNullException("text", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.text);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, Message instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.userId != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.text == null)
		{
			throw new ArgumentNullException("text", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.text);
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LineVec : IDisposable, IPooled, IProto<LineVec>, IProto
{
	[NonSerialized]
	public Vector4 vec;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LineVec instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.vec = default(Vector4);
			Pool.Free<LineVec>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LineVec with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LineVec instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.vec = vec;
	}

	public LineVec Copy()
	{
		LineVec lineVec = Pool.Get<LineVec>();
		CopyTo(lineVec);
		return lineVec;
	}

	public static LineVec Deserialize(BufferStream stream)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		Deserialize(stream, lineVec, isDelta: false);
		return lineVec;
	}

	public static LineVec DeserializeLengthDelimited(BufferStream stream)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		DeserializeLengthDelimited(stream, lineVec, isDelta: false);
		return lineVec;
	}

	public static LineVec DeserializeLength(BufferStream stream, int length)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		DeserializeLength(stream, length, lineVec, isDelta: false);
		return lineVec;
	}

	public static LineVec Deserialize(byte[] buffer)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lineVec, isDelta: false);
		return lineVec;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LineVec previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LineVec Deserialize(BufferStream stream, LineVec instance, bool isDelta)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LineVec DeserializeLengthDelimited(BufferStream stream, LineVec instance, bool isDelta)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LineVec DeserializeLength(BufferStream stream, int length, LineVec instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LineVec instance, LineVec previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.vec != previous.vec)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.vec, previous.vec);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, LineVec instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.vec != default(Vector4))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.Serialize(stream, instance.vec);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LinePointList : IDisposable, IPooled, IProto<LinePointList>, IProto
{
	[NonSerialized]
	public Vector4 a;

	[NonSerialized]
	public Vector4 b;

	[NonSerialized]
	public Vector4 c;

	[NonSerialized]
	public Vector4 d;

	[NonSerialized]
	public Vector4 e;

	[NonSerialized]
	public Vector4 f;

	[NonSerialized]
	public Vector4 g;

	[NonSerialized]
	public Vector4 h;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LinePointList instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.a = default(Vector4);
			instance.b = default(Vector4);
			instance.c = default(Vector4);
			instance.d = default(Vector4);
			instance.e = default(Vector4);
			instance.f = default(Vector4);
			instance.g = default(Vector4);
			instance.h = default(Vector4);
			Pool.Free<LinePointList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LinePointList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LinePointList instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.a = a;
		instance.b = b;
		instance.c = c;
		instance.d = d;
		instance.e = e;
		instance.f = f;
		instance.g = g;
		instance.h = h;
	}

	public LinePointList Copy()
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		CopyTo(linePointList);
		return linePointList;
	}

	public static LinePointList Deserialize(BufferStream stream)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		Deserialize(stream, linePointList, isDelta: false);
		return linePointList;
	}

	public static LinePointList DeserializeLengthDelimited(BufferStream stream)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		DeserializeLengthDelimited(stream, linePointList, isDelta: false);
		return linePointList;
	}

	public static LinePointList DeserializeLength(BufferStream stream, int length)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		DeserializeLength(stream, length, linePointList, isDelta: false);
		return linePointList;
	}

	public static LinePointList Deserialize(byte[] buffer)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, linePointList, isDelta: false);
		return linePointList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LinePointList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LinePointList Deserialize(BufferStream stream, LinePointList instance, bool isDelta)
	{
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
				continue;
			case 18:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
				continue;
			case 34:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
				continue;
			case 42:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
				continue;
			case 50:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
				continue;
			case 58:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LinePointList DeserializeLengthDelimited(BufferStream stream, LinePointList instance, bool isDelta)
	{
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
				continue;
			case 18:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
				continue;
			case 34:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
				continue;
			case 42:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
				continue;
			case 50:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
				continue;
			case 58:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LinePointList DeserializeLength(BufferStream stream, int length, LinePointList instance, bool isDelta)
	{
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
				continue;
			case 18:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
				continue;
			case 34:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
				continue;
			case 42:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
				continue;
			case 50:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
				continue;
			case 58:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LinePointList instance, LinePointList previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.a != previous.a)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.a, previous.a);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.b != previous.b)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.b, previous.b);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.c != previous.c)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.c, previous.c);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.d != previous.d)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.d, previous.d);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.e != previous.e)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.e, previous.e);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.f != previous.f)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.f, previous.f);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.g != previous.g)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.g, previous.g);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.h != previous.h)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.h, previous.h);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
	}

	public static void Serialize(BufferStream stream, LinePointList instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		if (instance.a != default(Vector4))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.Serialize(stream, instance.a);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.b != default(Vector4))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.b);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.c != default(Vector4))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.c);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.d != default(Vector4))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.d);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.e != default(Vector4))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.e);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.f != default(Vector4))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.f);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.g != default(Vector4))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.g);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.h != default(Vector4))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.h);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PlayerStoredVehicle : IDisposable, IPooled, IProto<PlayerStoredVehicle>, IProto
{
	[NonSerialized]
	public string shortname;

	[NonSerialized]
	public string resourcePath;

	[NonSerialized]
	public float health;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerStoredVehicle instance)
	{
		if (instance.ShouldPool)
		{
			instance.shortname = string.Empty;
			instance.resourcePath = string.Empty;
			instance.health = 0f;
			Pool.Free<PlayerStoredVehicle>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerStoredVehicle with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerStoredVehicle instance)
	{
		instance.shortname = shortname;
		instance.resourcePath = resourcePath;
		instance.health = health;
	}

	public PlayerStoredVehicle Copy()
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		CopyTo(playerStoredVehicle);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle Deserialize(BufferStream stream)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		Deserialize(stream, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		DeserializeLengthDelimited(stream, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		DeserializeLength(stream, length, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle Deserialize(byte[] buffer)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerStoredVehicle previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerStoredVehicle Deserialize(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.shortname = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.resourcePath = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shortname = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.resourcePath = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length, PlayerStoredVehicle instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shortname = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.resourcePath = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerStoredVehicle instance, PlayerStoredVehicle previous)
	{
		if (instance.shortname != null && instance.shortname != previous.shortname)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.shortname);
		}
		if (instance.resourcePath != null && instance.resourcePath != previous.resourcePath)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.resourcePath);
		}
		if (instance.health != previous.health)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
	}

	public static void Serialize(BufferStream stream, PlayerStoredVehicle instance)
	{
		if (instance.shortname != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.shortname);
		}
		if (instance.resourcePath != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.resourcePath);
		}
		if (instance.health != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Result : IDisposable, IPooled, IProto<Result>, IProto
{
	[NonSerialized]
	public ulong ID;

	[NonSerialized]
	public int winnings;

	[NonSerialized]
	public int resultCode;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Result instance)
	{
		if (instance.ShouldPool)
		{
			instance.ID = 0uL;
			instance.winnings = 0;
			instance.resultCode = 0;
			Pool.Free<Result>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Result with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Result instance)
	{
		instance.ID = ID;
		instance.winnings = winnings;
		instance.resultCode = resultCode;
	}

	public Result Copy()
	{
		Result result = Pool.Get<Result>();
		CopyTo(result);
		return result;
	}

	public static Result Deserialize(BufferStream stream)
	{
		Result result = Pool.Get<Result>();
		Deserialize(stream, result, isDelta: false);
		return result;
	}

	public static Result DeserializeLengthDelimited(BufferStream stream)
	{
		Result result = Pool.Get<Result>();
		DeserializeLengthDelimited(stream, result, isDelta: false);
		return result;
	}

	public static Result DeserializeLength(BufferStream stream, int length)
	{
		Result result = Pool.Get<Result>();
		DeserializeLength(stream, length, result, isDelta: false);
		return result;
	}

	public static Result Deserialize(byte[] buffer)
	{
		Result result = Pool.Get<Result>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, result, isDelta: false);
		return result;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Result previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Result Deserialize(BufferStream stream, Result instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.ID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Result DeserializeLengthDelimited(BufferStream stream, Result instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Result DeserializeLength(BufferStream stream, int length, Result instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Result instance, Result previous)
	{
		if (instance.ID != previous.ID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.ID);
		}
		if (instance.winnings != previous.winnings)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
		}
		if (instance.resultCode != previous.resultCode)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
		}
	}

	public static void Serialize(BufferStream stream, Result instance)
	{
		if (instance.ID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.ID);
		}
		if (instance.winnings != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
		}
		if (instance.resultCode != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum RespawnType
{
	SleepingBag = 1,
	Bed,
	BeachTowel,
	Camper,
	Static
}


public enum RespawnState
{
	OK = 1,
	Occupied,
	Underwater,
	InNoRespawnZone
}


