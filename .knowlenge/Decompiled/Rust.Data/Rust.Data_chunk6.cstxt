using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PendingOrder : IDisposable, IPooled, IProto<PendingOrder>, IProto
{
	[NonSerialized]
	public NetworkableId vendingMachineId;

	[NonSerialized]
	public NetworkableId droneId;

	[NonSerialized]
	public TimeUntil timeUntilExpiry;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PendingOrder instance)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.vendingMachineId = default(NetworkableId);
			instance.droneId = default(NetworkableId);
			instance.timeUntilExpiry = TimeUntil.op_Implicit(0f);
			Pool.Free<PendingOrder>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PendingOrder with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PendingOrder instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.vendingMachineId = vendingMachineId;
		instance.droneId = droneId;
		instance.timeUntilExpiry = timeUntilExpiry;
	}

	public PendingOrder Copy()
	{
		PendingOrder pendingOrder = Pool.Get<PendingOrder>();
		CopyTo(pendingOrder);
		return pendingOrder;
	}

	public static PendingOrder Deserialize(BufferStream stream)
	{
		PendingOrder pendingOrder = Pool.Get<PendingOrder>();
		Deserialize(stream, pendingOrder, isDelta: false);
		return pendingOrder;
	}

	public static PendingOrder DeserializeLengthDelimited(BufferStream stream)
	{
		PendingOrder pendingOrder = Pool.Get<PendingOrder>();
		DeserializeLengthDelimited(stream, pendingOrder, isDelta: false);
		return pendingOrder;
	}

	public static PendingOrder DeserializeLength(BufferStream stream, int length)
	{
		PendingOrder pendingOrder = Pool.Get<PendingOrder>();
		DeserializeLength(stream, length, pendingOrder, isDelta: false);
		return pendingOrder;
	}

	public static PendingOrder Deserialize(byte[] buffer)
	{
		PendingOrder pendingOrder = Pool.Get<PendingOrder>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pendingOrder, isDelta: false);
		return pendingOrder;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PendingOrder previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PendingOrder Deserialize(BufferStream stream, PendingOrder instance, bool isDelta)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 37:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PendingOrder DeserializeLengthDelimited(BufferStream stream, PendingOrder instance, bool isDelta)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 37:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PendingOrder DeserializeLength(BufferStream stream, int length, PendingOrder instance, bool isDelta)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 37:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PendingOrder instance, PendingOrder previous)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.droneId.Value);
		if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != TimeUntil.op_Implicit(previous.timeUntilExpiry))
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
		}
	}

	public static void Serialize(BufferStream stream, PendingOrder instance)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (instance.vendingMachineId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
		}
		if (instance.droneId != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.droneId.Value);
		}
		if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref vendingMachineId.Value);
		action(UidType.NetworkableId, ref droneId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class TeamInfo : IDisposable, IPooled, IProto<TeamInfo>, IProto
{
	[NonSerialized]
	public int score;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TeamInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.score = 0;
			Pool.Free<TeamInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TeamInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TeamInfo instance)
	{
		instance.score = score;
	}

	public TeamInfo Copy()
	{
		TeamInfo teamInfo = Pool.Get<TeamInfo>();
		CopyTo(teamInfo);
		return teamInfo;
	}

	public static TeamInfo Deserialize(BufferStream stream)
	{
		TeamInfo teamInfo = Pool.Get<TeamInfo>();
		Deserialize(stream, teamInfo, isDelta: false);
		return teamInfo;
	}

	public static TeamInfo DeserializeLengthDelimited(BufferStream stream)
	{
		TeamInfo teamInfo = Pool.Get<TeamInfo>();
		DeserializeLengthDelimited(stream, teamInfo, isDelta: false);
		return teamInfo;
	}

	public static TeamInfo DeserializeLength(BufferStream stream, int length)
	{
		TeamInfo teamInfo = Pool.Get<TeamInfo>();
		DeserializeLength(stream, length, teamInfo, isDelta: false);
		return teamInfo;
	}

	public static TeamInfo Deserialize(byte[] buffer)
	{
		TeamInfo teamInfo = Pool.Get<TeamInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, teamInfo, isDelta: false);
		return teamInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TeamInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TeamInfo Deserialize(BufferStream stream, TeamInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TeamInfo DeserializeLengthDelimited(BufferStream stream, TeamInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TeamInfo DeserializeLength(BufferStream stream, int length, TeamInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TeamInfo instance, TeamInfo previous)
	{
		if (instance.score != previous.score)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public static void Serialize(BufferStream stream, TeamInfo instance)
	{
		if (instance.score != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ScoreColumn : IDisposable, IPooled, IProto<ScoreColumn>, IProto
{
	[NonSerialized]
	public string name;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ScoreColumn instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			Pool.Free<ScoreColumn>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ScoreColumn with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ScoreColumn instance)
	{
		instance.name = name;
	}

	public ScoreColumn Copy()
	{
		ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
		CopyTo(scoreColumn);
		return scoreColumn;
	}

	public static ScoreColumn Deserialize(BufferStream stream)
	{
		ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
		Deserialize(stream, scoreColumn, isDelta: false);
		return scoreColumn;
	}

	public static ScoreColumn DeserializeLengthDelimited(BufferStream stream)
	{
		ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
		DeserializeLengthDelimited(stream, scoreColumn, isDelta: false);
		return scoreColumn;
	}

	public static ScoreColumn DeserializeLength(BufferStream stream, int length)
	{
		ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
		DeserializeLength(stream, length, scoreColumn, isDelta: false);
		return scoreColumn;
	}

	public static ScoreColumn Deserialize(byte[] buffer)
	{
		ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, scoreColumn, isDelta: false);
		return scoreColumn;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ScoreColumn previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ScoreColumn Deserialize(BufferStream stream, ScoreColumn instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ScoreColumn DeserializeLengthDelimited(BufferStream stream, ScoreColumn instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ScoreColumn DeserializeLength(BufferStream stream, int length, ScoreColumn instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ScoreColumn instance, ScoreColumn previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public static void Serialize(BufferStream stream, ScoreColumn instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PlayerScore : IDisposable, IPooled, IProto<PlayerScore>, IProto
{
	[NonSerialized]
	public string playerName;

	[NonSerialized]
	public ulong userid;

	[NonSerialized]
	public List<int> scores;

	[NonSerialized]
	public int team;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerScore instance)
	{
		if (instance.ShouldPool)
		{
			instance.playerName = string.Empty;
			instance.userid = 0uL;
			if (instance.scores != null)
			{
				List<int> list = instance.scores;
				Pool.FreeUnmanaged<int>(ref list);
				instance.scores = list;
			}
			instance.team = 0;
			Pool.Free<PlayerScore>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerScore with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerScore instance)
	{
		instance.playerName = playerName;
		instance.userid = userid;
		if (scores != null)
		{
			instance.scores = Pool.Get<List<int>>();
			for (int i = 0; i < scores.Count; i++)
			{
				int item = scores[i];
				instance.scores.Add(item);
			}
		}
		else
		{
			instance.scores = null;
		}
		instance.team = team;
	}

	public PlayerScore Copy()
	{
		PlayerScore playerScore = Pool.Get<PlayerScore>();
		CopyTo(playerScore);
		return playerScore;
	}

	public static PlayerScore Deserialize(BufferStream stream)
	{
		PlayerScore playerScore = Pool.Get<PlayerScore>();
		Deserialize(stream, playerScore, isDelta: false);
		return playerScore;
	}

	public static PlayerScore DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerScore playerScore = Pool.Get<PlayerScore>();
		DeserializeLengthDelimited(stream, playerScore, isDelta: false);
		return playerScore;
	}

	public static PlayerScore DeserializeLength(BufferStream stream, int length)
	{
		PlayerScore playerScore = Pool.Get<PlayerScore>();
		DeserializeLength(stream, length, playerScore, isDelta: false);
		return playerScore;
	}

	public static PlayerScore Deserialize(byte[] buffer)
	{
		PlayerScore playerScore = Pool.Get<PlayerScore>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerScore, isDelta: false);
		return playerScore;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerScore previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerScore Deserialize(BufferStream stream, PlayerScore instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.scores.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.team = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerScore DeserializeLengthDelimited(BufferStream stream, PlayerScore instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.scores.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.team = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerScore DeserializeLength(BufferStream stream, int length, PlayerScore instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.scores.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.team = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerScore instance, PlayerScore previous)
	{
		if (instance.playerName != previous.playerName)
		{
			if (instance.playerName == null)
			{
				throw new ArgumentNullException("playerName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.userid != previous.userid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				int num = instance.scores[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.team != previous.team)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.team);
		}
	}

	public static void Serialize(BufferStream stream, PlayerScore instance)
	{
		if (instance.playerName == null)
		{
			throw new ArgumentNullException("playerName", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.playerName);
		if (instance.userid != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				int num = instance.scores[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.team != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.team);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ReclaimInfo : IDisposable, IPooled, IProto<ReclaimInfo>, IProto
{
	[NonSerialized]
	public ulong victimID;

	[NonSerialized]
	public ItemContainer mainInventory;

	[NonSerialized]
	public ItemContainer wearInventory;

	[NonSerialized]
	public ItemContainer beltInventory;

	[NonSerialized]
	public ItemContainer backpackInventory;

	[NonSerialized]
	public int reclaimId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ReclaimInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.victimID = 0uL;
			if (instance.mainInventory != null)
			{
				instance.mainInventory.ResetToPool();
				instance.mainInventory = null;
			}
			if (instance.wearInventory != null)
			{
				instance.wearInventory.ResetToPool();
				instance.wearInventory = null;
			}
			if (instance.beltInventory != null)
			{
				instance.beltInventory.ResetToPool();
				instance.beltInventory = null;
			}
			if (instance.backpackInventory != null)
			{
				instance.backpackInventory.ResetToPool();
				instance.backpackInventory = null;
			}
			instance.reclaimId = 0;
			Pool.Free<ReclaimInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ReclaimInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ReclaimInfo instance)
	{
		instance.victimID = victimID;
		if (mainInventory != null)
		{
			if (instance.mainInventory == null)
			{
				instance.mainInventory = mainInventory.Copy();
			}
			else
			{
				mainInventory.CopyTo(instance.mainInventory);
			}
		}
		else
		{
			instance.mainInventory = null;
		}
		if (wearInventory != null)
		{
			if (instance.wearInventory == null)
			{
				instance.wearInventory = wearInventory.Copy();
			}
			else
			{
				wearInventory.CopyTo(instance.wearInventory);
			}
		}
		else
		{
			instance.wearInventory = null;
		}
		if (beltInventory != null)
		{
			if (instance.beltInventory == null)
			{
				instance.beltInventory = beltInventory.Copy();
			}
			else
			{
				beltInventory.CopyTo(instance.beltInventory);
			}
		}
		else
		{
			instance.beltInventory = null;
		}
		if (backpackInventory != null)
		{
			if (instance.backpackInventory == null)
			{
				instance.backpackInventory = backpackInventory.Copy();
			}
			else
			{
				backpackInventory.CopyTo(instance.backpackInventory);
			}
		}
		else
		{
			instance.backpackInventory = null;
		}
		instance.reclaimId = reclaimId;
	}

	public ReclaimInfo Copy()
	{
		ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
		CopyTo(reclaimInfo);
		return reclaimInfo;
	}

	public static ReclaimInfo Deserialize(BufferStream stream)
	{
		ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
		Deserialize(stream, reclaimInfo, isDelta: false);
		return reclaimInfo;
	}

	public static ReclaimInfo DeserializeLengthDelimited(BufferStream stream)
	{
		ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
		DeserializeLengthDelimited(stream, reclaimInfo, isDelta: false);
		return reclaimInfo;
	}

	public static ReclaimInfo DeserializeLength(BufferStream stream, int length)
	{
		ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
		DeserializeLength(stream, length, reclaimInfo, isDelta: false);
		return reclaimInfo;
	}

	public static ReclaimInfo Deserialize(byte[] buffer)
	{
		ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, reclaimInfo, isDelta: false);
		return reclaimInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ReclaimInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ReclaimInfo Deserialize(BufferStream stream, ReclaimInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.victimID = ProtocolParser.ReadUInt64(stream);
				break;
			case 34:
				if (instance.mainInventory == null)
				{
					instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
				}
				break;
			case 42:
				if (instance.wearInventory == null)
				{
					instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
				}
				break;
			case 50:
				if (instance.beltInventory == null)
				{
					instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
				}
				break;
			case 58:
				if (instance.backpackInventory == null)
				{
					instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
				}
				break;
			case 64:
				instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static ReclaimInfo DeserializeLengthDelimited(BufferStream stream, ReclaimInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.victimID = ProtocolParser.ReadUInt64(stream);
				break;
			case 34:
				if (instance.mainInventory == null)
				{
					instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
				}
				break;
			case 42:
				if (instance.wearInventory == null)
				{
					instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
				}
				break;
			case 50:
				if (instance.beltInventory == null)
				{
					instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
				}
				break;
			case 58:
				if (instance.backpackInventory == null)
				{
					instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
				}
				break;
			case 64:
				instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ReclaimInfo DeserializeLength(BufferStream stream, int length, ReclaimInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.victimID = ProtocolParser.ReadUInt64(stream);
				break;
			case 34:
				if (instance.mainInventory == null)
				{
					instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
				}
				break;
			case 42:
				if (instance.wearInventory == null)
				{
					instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
				}
				break;
			case 50:
				if (instance.beltInventory == null)
				{
					instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
				}
				break;
			case 58:
				if (instance.backpackInventory == null)
				{
					instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
				}
				break;
			case 64:
				instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ReclaimInfo instance, ReclaimInfo previous)
	{
		if (instance.victimID != previous.victimID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.victimID);
		}
		if (instance.mainInventory == null)
		{
			throw new ArgumentNullException("mainInventory", "Required by proto specification.");
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.mainInventory, previous.mainInventory);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
		if (instance.wearInventory == null)
		{
			throw new ArgumentNullException("wearInventory", "Required by proto specification.");
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.wearInventory, previous.wearInventory);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
		if (instance.beltInventory == null)
		{
			throw new ArgumentNullException("beltInventory", "Required by proto specification.");
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.beltInventory, previous.beltInventory);
		int val3 = stream.Position - position3;
		Span<byte> span3 = range3.GetSpan();
		int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
		if (num3 < 5)
		{
			span3[num3 - 1] |= 128;
			while (num3 < 4)
			{
				span3[num3++] = 128;
			}
			span3[4] = 0;
		}
		if (instance.backpackInventory == null)
		{
			throw new ArgumentNullException("backpackInventory", "Required by proto specification.");
		}
		stream.WriteByte(58);
		BufferStream.RangeHandle range4 = stream.GetRange(5);
		int position4 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.backpackInventory, previous.backpackInventory);
		int val4 = stream.Position - position4;
		Span<byte> span4 = range4.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
		if (num4 < 5)
		{
			span4[num4 - 1] |= 128;
			while (num4 < 4)
			{
				span4[num4++] = 128;
			}
			span4[4] = 0;
		}
		if (instance.reclaimId != previous.reclaimId)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.reclaimId);
		}
	}

	public static void Serialize(BufferStream stream, ReclaimInfo instance)
	{
		if (instance.victimID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.victimID);
		}
		if (instance.mainInventory == null)
		{
			throw new ArgumentNullException("mainInventory", "Required by proto specification.");
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.Serialize(stream, instance.mainInventory);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
		if (instance.wearInventory == null)
		{
			throw new ArgumentNullException("wearInventory", "Required by proto specification.");
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		ItemContainer.Serialize(stream, instance.wearInventory);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
		if (instance.beltInventory == null)
		{
			throw new ArgumentNullException("beltInventory", "Required by proto specification.");
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		ItemContainer.Serialize(stream, instance.beltInventory);
		int val3 = stream.Position - position3;
		Span<byte> span3 = range3.GetSpan();
		int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
		if (num3 < 5)
		{
			span3[num3 - 1] |= 128;
			while (num3 < 4)
			{
				span3[num3++] = 128;
			}
			span3[4] = 0;
		}
		if (instance.backpackInventory == null)
		{
			throw new ArgumentNullException("backpackInventory", "Required by proto specification.");
		}
		stream.WriteByte(58);
		BufferStream.RangeHandle range4 = stream.GetRange(5);
		int position4 = stream.Position;
		ItemContainer.Serialize(stream, instance.backpackInventory);
		int val4 = stream.Position - position4;
		Span<byte> span4 = range4.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
		if (num4 < 5)
		{
			span4[num4 - 1] |= 128;
			while (num4 < 4)
			{
				span4[num4++] = 128;
			}
			span4[4] = 0;
		}
		if (instance.reclaimId != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.reclaimId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		mainInventory?.InspectUids(action);
		wearInventory?.InspectUids(action);
		beltInventory?.InspectUids(action);
		backpackInventory?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class CardPlayer : IDisposable, IPooled, IProto<CardPlayer>, IProto
{
	[NonSerialized]
	public ulong userid;

	[NonSerialized]
	public List<int> cards;

	[NonSerialized]
	public int scrap;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public int availableInputs;

	[NonSerialized]
	public int betThisRound;

	[NonSerialized]
	public int betThisTurn;

	[NonSerialized]
	public bool leftRoundEarly;

	[NonSerialized]
	public bool sendCardDetails;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CardPlayer instance)
	{
		if (instance.ShouldPool)
		{
			instance.userid = 0uL;
			if (instance.cards != null)
			{
				List<int> list = instance.cards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.cards = list;
			}
			instance.scrap = 0;
			instance.state = 0;
			instance.availableInputs = 0;
			instance.betThisRound = 0;
			instance.betThisTurn = 0;
			instance.leftRoundEarly = false;
			instance.sendCardDetails = false;
			Pool.Free<CardPlayer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CardPlayer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CardPlayer instance)
	{
		instance.userid = userid;
		if (cards != null)
		{
			instance.cards = Pool.Get<List<int>>();
			for (int i = 0; i < cards.Count; i++)
			{
				int item = cards[i];
				instance.cards.Add(item);
			}
		}
		else
		{
			instance.cards = null;
		}
		instance.scrap = scrap;
		instance.state = state;
		instance.availableInputs = availableInputs;
		instance.betThisRound = betThisRound;
		instance.betThisTurn = betThisTurn;
		instance.leftRoundEarly = leftRoundEarly;
		instance.sendCardDetails = sendCardDetails;
	}

	public CardPlayer Copy()
	{
		CardPlayer cardPlayer = Pool.Get<CardPlayer>();
		CopyTo(cardPlayer);
		return cardPlayer;
	}

	public static CardPlayer Deserialize(BufferStream stream)
	{
		CardPlayer cardPlayer = Pool.Get<CardPlayer>();
		Deserialize(stream, cardPlayer, isDelta: false);
		return cardPlayer;
	}

	public static CardPlayer DeserializeLengthDelimited(BufferStream stream)
	{
		CardPlayer cardPlayer = Pool.Get<CardPlayer>();
		DeserializeLengthDelimited(stream, cardPlayer, isDelta: false);
		return cardPlayer;
	}

	public static CardPlayer DeserializeLength(BufferStream stream, int length)
	{
		CardPlayer cardPlayer = Pool.Get<CardPlayer>();
		DeserializeLength(stream, length, cardPlayer, isDelta: false);
		return cardPlayer;
	}

	public static CardPlayer Deserialize(byte[] buffer)
	{
		CardPlayer cardPlayer = Pool.Get<CardPlayer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cardPlayer, isDelta: false);
		return cardPlayer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CardPlayer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CardPlayer Deserialize(BufferStream stream, CardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.sendCardDetails = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CardPlayer DeserializeLengthDelimited(BufferStream stream, CardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.sendCardDetails = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CardPlayer DeserializeLength(BufferStream stream, int length, CardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.sendCardDetails = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CardPlayer instance, CardPlayer previous)
	{
		if (instance.userid != previous.userid)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.cards != null)
		{
			for (int i = 0; i < instance.cards.Count; i++)
			{
				int num = instance.cards[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.scrap != previous.scrap)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scrap);
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.availableInputs != previous.availableInputs)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.availableInputs);
		}
		if (instance.betThisRound != previous.betThisRound)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisRound);
		}
		if (instance.betThisTurn != previous.betThisTurn)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisTurn);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.leftRoundEarly);
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.sendCardDetails);
	}

	public static void Serialize(BufferStream stream, CardPlayer instance)
	{
		if (instance.userid != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.cards != null)
		{
			for (int i = 0; i < instance.cards.Count; i++)
			{
				int num = instance.cards[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.scrap != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scrap);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.availableInputs != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.availableInputs);
		}
		if (instance.betThisRound != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisRound);
		}
		if (instance.betThisTurn != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisTurn);
		}
		if (instance.leftRoundEarly)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.leftRoundEarly);
		}
		if (instance.sendCardDetails)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.sendCardDetails);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class TexasHoldEm : IDisposable, IPooled, IProto<TexasHoldEm>, IProto
{
	[NonSerialized]
	public int dealerIndex;

	[NonSerialized]
	public List<int> communityCards;

	[NonSerialized]
	public int biggestRaiseThisTurn;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TexasHoldEm instance)
	{
		if (instance.ShouldPool)
		{
			instance.dealerIndex = 0;
			if (instance.communityCards != null)
			{
				List<int> list = instance.communityCards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.communityCards = list;
			}
			instance.biggestRaiseThisTurn = 0;
			Pool.Free<TexasHoldEm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TexasHoldEm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TexasHoldEm instance)
	{
		instance.dealerIndex = dealerIndex;
		if (communityCards != null)
		{
			instance.communityCards = Pool.Get<List<int>>();
			for (int i = 0; i < communityCards.Count; i++)
			{
				int item = communityCards[i];
				instance.communityCards.Add(item);
			}
		}
		else
		{
			instance.communityCards = null;
		}
		instance.biggestRaiseThisTurn = biggestRaiseThisTurn;
	}

	public TexasHoldEm Copy()
	{
		TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
		CopyTo(texasHoldEm);
		return texasHoldEm;
	}

	public static TexasHoldEm Deserialize(BufferStream stream)
	{
		TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
		Deserialize(stream, texasHoldEm, isDelta: false);
		return texasHoldEm;
	}

	public static TexasHoldEm DeserializeLengthDelimited(BufferStream stream)
	{
		TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
		DeserializeLengthDelimited(stream, texasHoldEm, isDelta: false);
		return texasHoldEm;
	}

	public static TexasHoldEm DeserializeLength(BufferStream stream, int length)
	{
		TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
		DeserializeLength(stream, length, texasHoldEm, isDelta: false);
		return texasHoldEm;
	}

	public static TexasHoldEm Deserialize(byte[] buffer)
	{
		TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, texasHoldEm, isDelta: false);
		return texasHoldEm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TexasHoldEm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TexasHoldEm Deserialize(BufferStream stream, TexasHoldEm instance, bool isDelta)
	{
		if (!isDelta && instance.communityCards == null)
		{
			instance.communityCards = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TexasHoldEm DeserializeLengthDelimited(BufferStream stream, TexasHoldEm instance, bool isDelta)
	{
		if (!isDelta && instance.communityCards == null)
		{
			instance.communityCards = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TexasHoldEm DeserializeLength(BufferStream stream, int length, TexasHoldEm instance, bool isDelta)
	{
		if (!isDelta && instance.communityCards == null)
		{
			instance.communityCards = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TexasHoldEm instance, TexasHoldEm previous)
	{
		if (instance.dealerIndex != previous.dealerIndex)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dealerIndex);
		}
		if (instance.communityCards != null)
		{
			for (int i = 0; i < instance.communityCards.Count; i++)
			{
				int num = instance.communityCards[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.biggestRaiseThisTurn != previous.biggestRaiseThisTurn)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.biggestRaiseThisTurn);
		}
	}

	public static void Serialize(BufferStream stream, TexasHoldEm instance)
	{
		if (instance.dealerIndex != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dealerIndex);
		}
		if (instance.communityCards != null)
		{
			for (int i = 0; i < instance.communityCards.Count; i++)
			{
				int num = instance.communityCards[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.biggestRaiseThisTurn != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.biggestRaiseThisTurn);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class RoundResults : IDisposable, IPooled, IProto<RoundResults>, IProto
{
	public class Result : IDisposable, IPooled, IProto<Result>, IProto
	{
		[NonSerialized]
		public ulong ID;

		[NonSerialized]
		public int winnings;

		[NonSerialized]
		public int resultCode;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Result instance)
		{
			if (instance.ShouldPool)
			{
				instance.ID = 0uL;
				instance.winnings = 0;
				instance.resultCode = 0;
				Pool.Free<Result>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Result with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Result instance)
		{
			instance.ID = ID;
			instance.winnings = winnings;
			instance.resultCode = resultCode;
		}

		public Result Copy()
		{
			Result result = Pool.Get<Result>();
			CopyTo(result);
			return result;
		}

		public static Result Deserialize(BufferStream stream)
		{
			Result result = Pool.Get<Result>();
			Deserialize(stream, result, isDelta: false);
			return result;
		}

		public static Result DeserializeLengthDelimited(BufferStream stream)
		{
			Result result = Pool.Get<Result>();
			DeserializeLengthDelimited(stream, result, isDelta: false);
			return result;
		}

		public static Result DeserializeLength(BufferStream stream, int length)
		{
			Result result = Pool.Get<Result>();
			DeserializeLength(stream, length, result, isDelta: false);
			return result;
		}

		public static Result Deserialize(byte[] buffer)
		{
			Result result = Pool.Get<Result>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, result, isDelta: false);
			return result;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Result previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Result Deserialize(BufferStream stream, Result instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.ID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Result DeserializeLengthDelimited(BufferStream stream, Result instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.ID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Result DeserializeLength(BufferStream stream, int length, Result instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.ID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Result instance, Result previous)
		{
			if (instance.ID != previous.ID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.ID);
			}
			if (instance.winnings != previous.winnings)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
			}
			if (instance.resultCode != previous.resultCode)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
			}
		}

		public static void Serialize(BufferStream stream, Result instance)
		{
			if (instance.ID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.ID);
			}
			if (instance.winnings != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
			}
			if (instance.resultCode != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Result> results;

	[NonSerialized]
	public int winningScore;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RoundResults instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.results != null)
		{
			for (int i = 0; i < instance.results.Count; i++)
			{
				if (instance.results[i] != null)
				{
					instance.results[i].ResetToPool();
					instance.results[i] = null;
				}
			}
			List<Result> list = instance.results;
			Pool.Free<Result>(ref list, false);
			instance.results = list;
		}
		instance.winningScore = 0;
		Pool.Free<RoundResults>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RoundResults with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RoundResults instance)
	{
		if (results != null)
		{
			instance.results = Pool.Get<List<Result>>();
			for (int i = 0; i < results.Count; i++)
			{
				Result item = results[i].Copy();
				instance.results.Add(item);
			}
		}
		else
		{
			instance.results = null;
		}
		instance.winningScore = winningScore;
	}

	public RoundResults Copy()
	{
		RoundResults roundResults = Pool.Get<RoundResults>();
		CopyTo(roundResults);
		return roundResults;
	}

	public static RoundResults Deserialize(BufferStream stream)
	{
		RoundResults roundResults = Pool.Get<RoundResults>();
		Deserialize(stream, roundResults, isDelta: false);
		return roundResults;
	}

	public static RoundResults DeserializeLengthDelimited(BufferStream stream)
	{
		RoundResults roundResults = Pool.Get<RoundResults>();
		DeserializeLengthDelimited(stream, roundResults, isDelta: false);
		return roundResults;
	}

	public static RoundResults DeserializeLength(BufferStream stream, int length)
	{
		RoundResults roundResults = Pool.Get<RoundResults>();
		DeserializeLength(stream, length, roundResults, isDelta: false);
		return roundResults;
	}

	public static RoundResults Deserialize(byte[] buffer)
	{
		RoundResults roundResults = Pool.Get<RoundResults>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, roundResults, isDelta: false);
		return roundResults;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RoundResults previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RoundResults Deserialize(BufferStream stream, RoundResults instance, bool isDelta)
	{
		if (!isDelta && instance.results == null)
		{
			instance.results = Pool.Get<List<Result>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.results.Add(Result.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RoundResults DeserializeLengthDelimited(BufferStream stream, RoundResults instance, bool isDelta)
	{
		if (!isDelta && instance.results == null)
		{
			instance.results = Pool.Get<List<Result>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.results.Add(Result.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RoundResults DeserializeLength(BufferStream stream, int length, RoundResults instance, bool isDelta)
	{
		if (!isDelta && instance.results == null)
		{
			instance.results = Pool.Get<List<Result>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.results.Add(Result.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RoundResults instance, RoundResults previous)
	{
		if (instance.results != null)
		{
			for (int i = 0; i < instance.results.Count; i++)
			{
				Result result = instance.results[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Result.SerializeDelta(stream, result, result);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field results (ProtoBuf.CardGame.RoundResults.Result)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.winningScore != previous.winningScore)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.winningScore);
		}
	}

	public static void Serialize(BufferStream stream, RoundResults instance)
	{
		if (instance.results != null)
		{
			for (int i = 0; i < instance.results.Count; i++)
			{
				Result instance2 = instance.results[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Result.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field results (ProtoBuf.CardGame.RoundResults.Result)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.winningScore != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.winningScore);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (results != null)
		{
			for (int i = 0; i < results.Count; i++)
			{
				results[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Blackjack : IDisposable, IPooled, IProto<Blackjack>, IProto
{
	[NonSerialized]
	public List<int> dealerCards;

	[NonSerialized]
	public List<BlackjackCardPlayer> players;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Blackjack instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.dealerCards != null)
		{
			List<int> list = instance.dealerCards;
			Pool.FreeUnmanaged<int>(ref list);
			instance.dealerCards = list;
		}
		if (instance.players != null)
		{
			for (int i = 0; i < instance.players.Count; i++)
			{
				if (instance.players[i] != null)
				{
					instance.players[i].ResetToPool();
					instance.players[i] = null;
				}
			}
			List<BlackjackCardPlayer> list2 = instance.players;
			Pool.Free<BlackjackCardPlayer>(ref list2, false);
			instance.players = list2;
		}
		Pool.Free<Blackjack>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Blackjack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Blackjack instance)
	{
		if (dealerCards != null)
		{
			instance.dealerCards = Pool.Get<List<int>>();
			for (int i = 0; i < dealerCards.Count; i++)
			{
				int item = dealerCards[i];
				instance.dealerCards.Add(item);
			}
		}
		else
		{
			instance.dealerCards = null;
		}
		if (players != null)
		{
			instance.players = Pool.Get<List<BlackjackCardPlayer>>();
			for (int j = 0; j < players.Count; j++)
			{
				BlackjackCardPlayer item2 = players[j].Copy();
				instance.players.Add(item2);
			}
		}
		else
		{
			instance.players = null;
		}
	}

	public Blackjack Copy()
	{
		Blackjack blackjack = Pool.Get<Blackjack>();
		CopyTo(blackjack);
		return blackjack;
	}

	public static Blackjack Deserialize(BufferStream stream)
	{
		Blackjack blackjack = Pool.Get<Blackjack>();
		Deserialize(stream, blackjack, isDelta: false);
		return blackjack;
	}

	public static Blackjack DeserializeLengthDelimited(BufferStream stream)
	{
		Blackjack blackjack = Pool.Get<Blackjack>();
		DeserializeLengthDelimited(stream, blackjack, isDelta: false);
		return blackjack;
	}

	public static Blackjack DeserializeLength(BufferStream stream, int length)
	{
		Blackjack blackjack = Pool.Get<Blackjack>();
		DeserializeLength(stream, length, blackjack, isDelta: false);
		return blackjack;
	}

	public static Blackjack Deserialize(byte[] buffer)
	{
		Blackjack blackjack = Pool.Get<Blackjack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, blackjack, isDelta: false);
		return blackjack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Blackjack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Blackjack Deserialize(BufferStream stream, Blackjack instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.dealerCards == null)
			{
				instance.dealerCards = Pool.Get<List<int>>();
			}
			if (instance.players == null)
			{
				instance.players = Pool.Get<List<BlackjackCardPlayer>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Blackjack DeserializeLengthDelimited(BufferStream stream, Blackjack instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.dealerCards == null)
			{
				instance.dealerCards = Pool.Get<List<int>>();
			}
			if (instance.players == null)
			{
				instance.players = Pool.Get<List<BlackjackCardPlayer>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Blackjack DeserializeLength(BufferStream stream, int length, Blackjack instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.dealerCards == null)
			{
				instance.dealerCards = Pool.Get<List<int>>();
			}
			if (instance.players == null)
			{
				instance.players = Pool.Get<List<BlackjackCardPlayer>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Blackjack instance, Blackjack previous)
	{
		if (instance.dealerCards != null)
		{
			for (int i = 0; i < instance.dealerCards.Count; i++)
			{
				int num = instance.dealerCards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.players == null)
		{
			return;
		}
		for (int j = 0; j < instance.players.Count; j++)
		{
			BlackjackCardPlayer blackjackCardPlayer = instance.players[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			BlackjackCardPlayer.SerializeDelta(stream, blackjackCardPlayer, blackjackCardPlayer);
			int num2 = stream.Position - position;
			if (num2 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.BlackjackCardPlayer)");
			}
			Span<byte> span = range.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
			if (num3 < 3)
			{
				span[num3 - 1] |= 128;
				while (num3 < 2)
				{
					span[num3++] = 128;
				}
				span[2] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, Blackjack instance)
	{
		if (instance.dealerCards != null)
		{
			for (int i = 0; i < instance.dealerCards.Count; i++)
			{
				int num = instance.dealerCards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.players == null)
		{
			return;
		}
		for (int j = 0; j < instance.players.Count; j++)
		{
			BlackjackCardPlayer instance2 = instance.players[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			BlackjackCardPlayer.Serialize(stream, instance2);
			int num2 = stream.Position - position;
			if (num2 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.BlackjackCardPlayer)");
			}
			Span<byte> span = range.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
			if (num3 < 3)
			{
				span[num3 - 1] |= 128;
				while (num3 < 2)
				{
					span[num3++] = 128;
				}
				span[2] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (players != null)
		{
			for (int i = 0; i < players.Count; i++)
			{
				players[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class BlackjackCardPlayer : IDisposable, IPooled, IProto<BlackjackCardPlayer>, IProto
{
	[NonSerialized]
	public List<int> splitCards;

	[NonSerialized]
	public int splitBetThisRound;

	[NonSerialized]
	public int insuranceBetThisRound;

	[NonSerialized]
	public bool playingSplitCards;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BlackjackCardPlayer instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.splitCards != null)
			{
				List<int> list = instance.splitCards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.splitCards = list;
			}
			instance.splitBetThisRound = 0;
			instance.insuranceBetThisRound = 0;
			instance.playingSplitCards = false;
			Pool.Free<BlackjackCardPlayer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BlackjackCardPlayer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BlackjackCardPlayer instance)
	{
		if (splitCards != null)
		{
			instance.splitCards = Pool.Get<List<int>>();
			for (int i = 0; i < splitCards.Count; i++)
			{
				int item = splitCards[i];
				instance.splitCards.Add(item);
			}
		}
		else
		{
			instance.splitCards = null;
		}
		instance.splitBetThisRound = splitBetThisRound;
		instance.insuranceBetThisRound = insuranceBetThisRound;
		instance.playingSplitCards = playingSplitCards;
	}

	public BlackjackCardPlayer Copy()
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		CopyTo(blackjackCardPlayer);
		return blackjackCardPlayer;
	}

	public static BlackjackCardPlayer Deserialize(BufferStream stream)
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		Deserialize(stream, blackjackCardPlayer, isDelta: false);
		return blackjackCardPlayer;
	}

	public static BlackjackCardPlayer DeserializeLengthDelimited(BufferStream stream)
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		DeserializeLengthDelimited(stream, blackjackCardPlayer, isDelta: false);
		return blackjackCardPlayer;
	}

	public static BlackjackCardPlayer DeserializeLength(BufferStream stream, int length)
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		DeserializeLength(stream, length, blackjackCardPlayer, isDelta: false);
		return blackjackCardPlayer;
	}

	public static BlackjackCardPlayer Deserialize(byte[] buffer)
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, blackjackCardPlayer, isDelta: false);
		return blackjackCardPlayer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BlackjackCardPlayer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BlackjackCardPlayer Deserialize(BufferStream stream, BlackjackCardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.splitCards == null)
		{
			instance.splitCards = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.playingSplitCards = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BlackjackCardPlayer DeserializeLengthDelimited(BufferStream stream, BlackjackCardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.splitCards == null)
		{
			instance.splitCards = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.playingSplitCards = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BlackjackCardPlayer DeserializeLength(BufferStream stream, int length, BlackjackCardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.splitCards == null)
		{
			instance.splitCards = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.playingSplitCards = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BlackjackCardPlayer instance, BlackjackCardPlayer previous)
	{
		if (instance.splitCards != null)
		{
			for (int i = 0; i < instance.splitCards.Count; i++)
			{
				int num = instance.splitCards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.splitBetThisRound != previous.splitBetThisRound)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.splitBetThisRound);
		}
		if (instance.insuranceBetThisRound != previous.insuranceBetThisRound)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.insuranceBetThisRound);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.playingSplitCards);
	}

	public static void Serialize(BufferStream stream, BlackjackCardPlayer instance)
	{
		if (instance.splitCards != null)
		{
			for (int i = 0; i < instance.splitCards.Count; i++)
			{
				int num = instance.splitCards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.splitBetThisRound != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.splitBetThisRound);
		}
		if (instance.insuranceBetThisRound != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.insuranceBetThisRound);
		}
		if (instance.playingSplitCards)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.playingSplitCards);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class CardList : IDisposable, IPooled, IProto<CardList>, IProto
{
	[NonSerialized]
	public List<int> cards;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CardList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.cards != null)
			{
				List<int> list = instance.cards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.cards = list;
			}
			Pool.Free<CardList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CardList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CardList instance)
	{
		if (cards != null)
		{
			instance.cards = Pool.Get<List<int>>();
			for (int i = 0; i < cards.Count; i++)
			{
				int item = cards[i];
				instance.cards.Add(item);
			}
		}
		else
		{
			instance.cards = null;
		}
	}

	public CardList Copy()
	{
		CardList cardList = Pool.Get<CardList>();
		CopyTo(cardList);
		return cardList;
	}

	public static CardList Deserialize(BufferStream stream)
	{
		CardList cardList = Pool.Get<CardList>();
		Deserialize(stream, cardList, isDelta: false);
		return cardList;
	}

	public static CardList DeserializeLengthDelimited(BufferStream stream)
	{
		CardList cardList = Pool.Get<CardList>();
		DeserializeLengthDelimited(stream, cardList, isDelta: false);
		return cardList;
	}

	public static CardList DeserializeLength(BufferStream stream, int length)
	{
		CardList cardList = Pool.Get<CardList>();
		DeserializeLength(stream, length, cardList, isDelta: false);
		return cardList;
	}

	public static CardList Deserialize(byte[] buffer)
	{
		CardList cardList = Pool.Get<CardList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cardList, isDelta: false);
		return cardList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CardList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CardList Deserialize(BufferStream stream, CardList instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CardList DeserializeLengthDelimited(BufferStream stream, CardList instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CardList DeserializeLength(BufferStream stream, int length, CardList instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CardList instance, CardList previous)
	{
		if (instance.cards != null)
		{
			for (int i = 0; i < instance.cards.Count; i++)
			{
				int num = instance.cards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public static void Serialize(BufferStream stream, CardList instance)
	{
		if (instance.cards != null)
		{
			for (int i = 0; i < instance.cards.Count; i++)
			{
				int num = instance.cards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Design : IDisposable, IPooled, IProto<Design>, IProto
{
	[NonSerialized]
	public List<Star> stars;

	[NonSerialized]
	public ulong editedBy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Design instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.stars != null)
		{
			for (int i = 0; i < instance.stars.Count; i++)
			{
				if (instance.stars[i] != null)
				{
					instance.stars[i].ResetToPool();
					instance.stars[i] = null;
				}
			}
			List<Star> list = instance.stars;
			Pool.Free<Star>(ref list, false);
			instance.stars = list;
		}
		instance.editedBy = 0uL;
		Pool.Free<Design>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Design with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Design instance)
	{
		if (stars != null)
		{
			instance.stars = Pool.Get<List<Star>>();
			for (int i = 0; i < stars.Count; i++)
			{
				Star item = stars[i].Copy();
				instance.stars.Add(item);
			}
		}
		else
		{
			instance.stars = null;
		}
		instance.editedBy = editedBy;
	}

	public Design Copy()
	{
		Design design = Pool.Get<Design>();
		CopyTo(design);
		return design;
	}

	public static Design Deserialize(BufferStream stream)
	{
		Design design = Pool.Get<Design>();
		Deserialize(stream, design, isDelta: false);
		return design;
	}

	public static Design DeserializeLengthDelimited(BufferStream stream)
	{
		Design design = Pool.Get<Design>();
		DeserializeLengthDelimited(stream, design, isDelta: false);
		return design;
	}

	public static Design DeserializeLength(BufferStream stream, int length)
	{
		Design design = Pool.Get<Design>();
		DeserializeLength(stream, length, design, isDelta: false);
		return design;
	}

	public static Design Deserialize(byte[] buffer)
	{
		Design design = Pool.Get<Design>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, design, isDelta: false);
		return design;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Design previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Design Deserialize(BufferStream stream, Design instance, bool isDelta)
	{
		if (!isDelta && instance.stars == null)
		{
			instance.stars = Pool.Get<List<Star>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.stars.Add(Star.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Design DeserializeLengthDelimited(BufferStream stream, Design instance, bool isDelta)
	{
		if (!isDelta && instance.stars == null)
		{
			instance.stars = Pool.Get<List<Star>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.stars.Add(Star.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Design DeserializeLength(BufferStream stream, int length, Design instance, bool isDelta)
	{
		if (!isDelta && instance.stars == null)
		{
			instance.stars = Pool.Get<List<Star>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.stars.Add(Star.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Design instance, Design previous)
	{
		if (instance.stars != null)
		{
			for (int i = 0; i < instance.stars.Count; i++)
			{
				Star star = instance.stars[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Star.SerializeDelta(stream, star, star);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stars (ProtoBuf.PatternFirework.Star)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.editedBy != previous.editedBy)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.editedBy);
		}
	}

	public static void Serialize(BufferStream stream, Design instance)
	{
		if (instance.stars != null)
		{
			for (int i = 0; i < instance.stars.Count; i++)
			{
				Star instance2 = instance.stars[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Star.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stars (ProtoBuf.PatternFirework.Star)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.editedBy != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.editedBy);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (stars != null)
		{
			for (int i = 0; i < stars.Count; i++)
			{
				stars[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Star : IDisposable, IPooled, IProto<Star>, IProto
{
	[NonSerialized]
	public Vector2 position;

	[NonSerialized]
	public Color color;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Star instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.position = default(Vector2);
			instance.color = default(Color);
			Pool.Free<Star>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Star with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Star instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.position = position;
		instance.color = color;
	}

	public Star Copy()
	{
		Star star = Pool.Get<Star>();
		CopyTo(star);
		return star;
	}

	public static Star Deserialize(BufferStream stream)
	{
		Star star = Pool.Get<Star>();
		Deserialize(stream, star, isDelta: false);
		return star;
	}

	public static Star DeserializeLengthDelimited(BufferStream stream)
	{
		Star star = Pool.Get<Star>();
		DeserializeLengthDelimited(stream, star, isDelta: false);
		return star;
	}

	public static Star DeserializeLength(BufferStream stream, int length)
	{
		Star star = Pool.Get<Star>();
		DeserializeLength(stream, length, star, isDelta: false);
		return star;
	}

	public static Star Deserialize(byte[] buffer)
	{
		Star star = Pool.Get<Star>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, star, isDelta: false);
		return star;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Star previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Star Deserialize(BufferStream stream, Star instance, bool isDelta)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Star DeserializeLengthDelimited(BufferStream stream, Star instance, bool isDelta)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Star DeserializeLength(BufferStream stream, int length, Star instance, bool isDelta)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Star instance, Star previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (instance.position != previous.position)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector2Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector2)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.color != previous.color)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.color, previous.color);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, Star instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (instance.position != default(Vector2))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector2Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector2)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.color != default(Color))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			ColorSerialized.Serialize(stream, instance.color);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SavedDesign : IDisposable, IPooled, IProto<SavedDesign>, IProto
{
	[NonSerialized]
	public int version;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public Design design;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SavedDesign instance)
	{
		if (instance.ShouldPool)
		{
			instance.version = 0;
			instance.name = string.Empty;
			if (instance.design != null)
			{
				instance.design.ResetToPool();
				instance.design = null;
			}
			Pool.Free<SavedDesign>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SavedDesign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SavedDesign instance)
	{
		instance.version = version;
		instance.name = name;
		if (design != null)
		{
			if (instance.design == null)
			{
				instance.design = design.Copy();
			}
			else
			{
				design.CopyTo(instance.design);
			}
		}
		else
		{
			instance.design = null;
		}
	}

	public SavedDesign Copy()
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		CopyTo(savedDesign);
		return savedDesign;
	}

	public static SavedDesign Deserialize(BufferStream stream)
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		Deserialize(stream, savedDesign, isDelta: false);
		return savedDesign;
	}

	public static SavedDesign DeserializeLengthDelimited(BufferStream stream)
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		DeserializeLengthDelimited(stream, savedDesign, isDelta: false);
		return savedDesign;
	}

	public static SavedDesign DeserializeLength(BufferStream stream, int length)
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		DeserializeLength(stream, length, savedDesign, isDelta: false);
		return savedDesign;
	}

	public static SavedDesign Deserialize(byte[] buffer)
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, savedDesign, isDelta: false);
		return savedDesign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SavedDesign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SavedDesign Deserialize(BufferStream stream, SavedDesign instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.version = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				break;
			case 26:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static SavedDesign DeserializeLengthDelimited(BufferStream stream, SavedDesign instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.version = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				break;
			case 26:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SavedDesign DeserializeLength(BufferStream stream, int length, SavedDesign instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.version = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				break;
			case 26:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SavedDesign instance, SavedDesign previous)
	{
		if (instance.version != previous.version)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.version);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.design == null)
		{
			throw new ArgumentNullException("design", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		Design.SerializeDelta(stream, instance.design, previous.design);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, SavedDesign instance)
	{
		if (instance.version != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.version);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.design == null)
		{
			throw new ArgumentNullException("design", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		Design.Serialize(stream, instance.design);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		design?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class CookingItem : IDisposable, IPooled, IProto<CookingItem>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public int slotIndex;

	[NonSerialized]
	public int initialStackSize;

	[NonSerialized]
	public float cookingProgress;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CookingItem instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.slotIndex = 0;
			instance.initialStackSize = 0;
			instance.cookingProgress = 0f;
			Pool.Free<CookingItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CookingItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CookingItem instance)
	{
		instance.itemID = itemID;
		instance.slotIndex = slotIndex;
		instance.initialStackSize = initialStackSize;
		instance.cookingProgress = cookingProgress;
	}

	public CookingItem Copy()
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		CopyTo(cookingItem);
		return cookingItem;
	}

	public static CookingItem Deserialize(BufferStream stream)
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		Deserialize(stream, cookingItem, isDelta: false);
		return cookingItem;
	}

	public static CookingItem DeserializeLengthDelimited(BufferStream stream)
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		DeserializeLengthDelimited(stream, cookingItem, isDelta: false);
		return cookingItem;
	}

	public static CookingItem DeserializeLength(BufferStream stream, int length)
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		DeserializeLength(stream, length, cookingItem, isDelta: false);
		return cookingItem;
	}

	public static CookingItem Deserialize(byte[] buffer)
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cookingItem, isDelta: false);
		return cookingItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CookingItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CookingItem Deserialize(BufferStream stream, CookingItem instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.cookingProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CookingItem DeserializeLengthDelimited(BufferStream stream, CookingItem instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.cookingProgress = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CookingItem DeserializeLength(BufferStream stream, int length, CookingItem instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.cookingProgress = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CookingItem instance, CookingItem previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.slotIndex != previous.slotIndex)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
		}
		if (instance.initialStackSize != previous.initialStackSize)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.initialStackSize);
		}
		if (instance.cookingProgress != previous.cookingProgress)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.cookingProgress);
		}
	}

	public static void Serialize(BufferStream stream, CookingItem instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.slotIndex != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
		}
		if (instance.initialStackSize != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.initialStackSize);
		}
		if (instance.cookingProgress != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.cookingProgress);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ItemFilter : IDisposable, IPooled, IProto<ItemFilter>, IProto
{
	[NonSerialized]
	public int itemDef;

	[NonSerialized]
	public int itemCategory;

	[NonSerialized]
	public int maxAmountInDestination;

	[NonSerialized]
	public int isBlueprint;

	[NonSerialized]
	public int bufferAmount;

	[NonSerialized]
	public int retainMinimum;

	[NonSerialized]
	public int bufferTransferRemaining;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemFilter instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemDef = 0;
			instance.itemCategory = 0;
			instance.maxAmountInDestination = 0;
			instance.isBlueprint = 0;
			instance.bufferAmount = 0;
			instance.retainMinimum = 0;
			instance.bufferTransferRemaining = 0;
			Pool.Free<ItemFilter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemFilter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemFilter instance)
	{
		instance.itemDef = itemDef;
		instance.itemCategory = itemCategory;
		instance.maxAmountInDestination = maxAmountInDestination;
		instance.isBlueprint = isBlueprint;
		instance.bufferAmount = bufferAmount;
		instance.retainMinimum = retainMinimum;
		instance.bufferTransferRemaining = bufferTransferRemaining;
	}

	public ItemFilter Copy()
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		CopyTo(itemFilter);
		return itemFilter;
	}

	public static ItemFilter Deserialize(BufferStream stream)
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		Deserialize(stream, itemFilter, isDelta: false);
		return itemFilter;
	}

	public static ItemFilter DeserializeLengthDelimited(BufferStream stream)
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		DeserializeLengthDelimited(stream, itemFilter, isDelta: false);
		return itemFilter;
	}

	public static ItemFilter DeserializeLength(BufferStream stream, int length)
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		DeserializeLength(stream, length, itemFilter, isDelta: false);
		return itemFilter;
	}

	public static ItemFilter Deserialize(byte[] buffer)
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemFilter, isDelta: false);
		return itemFilter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemFilter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemFilter Deserialize(BufferStream stream, ItemFilter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemFilter DeserializeLengthDelimited(BufferStream stream, ItemFilter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemFilter DeserializeLength(BufferStream stream, int length, ItemFilter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemFilter instance, ItemFilter previous)
	{
		if (instance.itemDef != previous.itemDef)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemDef);
		}
		if (instance.itemCategory != previous.itemCategory)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCategory);
		}
		if (instance.maxAmountInDestination != previous.maxAmountInDestination)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxAmountInDestination);
		}
		if (instance.isBlueprint != previous.isBlueprint)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.isBlueprint);
		}
		if (instance.bufferAmount != previous.bufferAmount)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferAmount);
		}
		if (instance.retainMinimum != previous.retainMinimum)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.retainMinimum);
		}
		if (instance.bufferTransferRemaining != previous.bufferTransferRemaining)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferTransferRemaining);
		}
	}

	public static void Serialize(BufferStream stream, ItemFilter instance)
	{
		if (instance.itemDef != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemDef);
		}
		if (instance.itemCategory != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCategory);
		}
		if (instance.maxAmountInDestination != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxAmountInDestination);
		}
		if (instance.isBlueprint != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.isBlueprint);
		}
		if (instance.bufferAmount != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferAmount);
		}
		if (instance.retainMinimum != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.retainMinimum);
		}
		if (instance.bufferTransferRemaining != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferTransferRemaining);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ItemFilterList : IDisposable, IPooled, IProto<ItemFilterList>, IProto
{
	[NonSerialized]
	public List<ItemFilter> filters;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemFilterList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.filters != null)
		{
			for (int i = 0; i < instance.filters.Count; i++)
			{
				if (instance.filters[i] != null)
				{
					instance.filters[i].ResetToPool();
					instance.filters[i] = null;
				}
			}
			List<ItemFilter> list = instance.filters;
			Pool.Free<ItemFilter>(ref list, false);
			instance.filters = list;
		}
		Pool.Free<ItemFilterList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemFilterList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemFilterList instance)
	{
		if (filters != null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
			for (int i = 0; i < filters.Count; i++)
			{
				ItemFilter item = filters[i].Copy();
				instance.filters.Add(item);
			}
		}
		else
		{
			instance.filters = null;
		}
	}

	public ItemFilterList Copy()
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		CopyTo(itemFilterList);
		return itemFilterList;
	}

	public static ItemFilterList Deserialize(BufferStream stream)
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		Deserialize(stream, itemFilterList, isDelta: false);
		return itemFilterList;
	}

	public static ItemFilterList DeserializeLengthDelimited(BufferStream stream)
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		DeserializeLengthDelimited(stream, itemFilterList, isDelta: false);
		return itemFilterList;
	}

	public static ItemFilterList DeserializeLength(BufferStream stream, int length)
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		DeserializeLength(stream, length, itemFilterList, isDelta: false);
		return itemFilterList;
	}

	public static ItemFilterList Deserialize(byte[] buffer)
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemFilterList, isDelta: false);
		return itemFilterList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemFilterList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemFilterList Deserialize(BufferStream stream, ItemFilterList instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemFilterList DeserializeLengthDelimited(BufferStream stream, ItemFilterList instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemFilterList DeserializeLength(BufferStream stream, int length, ItemFilterList instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemFilterList instance, ItemFilterList previous)
	{
		if (instance.filters == null)
		{
			return;
		}
		for (int i = 0; i < instance.filters.Count; i++)
		{
			ItemFilter itemFilter = instance.filters[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ItemFilter.SerializeDelta(stream, itemFilter, itemFilter);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field filters (ProtoBuf.IndustrialConveyor.ItemFilter)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ItemFilterList instance)
	{
		if (instance.filters == null)
		{
			return;
		}
		for (int i = 0; i < instance.filters.Count; i++)
		{
			ItemFilter instance2 = instance.filters[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ItemFilter.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field filters (ProtoBuf.IndustrialConveyor.ItemFilter)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (filters != null)
		{
			for (int i = 0; i < filters.Count; i++)
			{
				filters[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public struct ItemTransfer : IProto<ItemTransfer>, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public int amount;

	public static void ResetToPool(ItemTransfer instance)
	{
		instance.itemId = 0;
		instance.amount = 0;
	}

	public void CopyTo(ItemTransfer instance)
	{
		instance.itemId = itemId;
		instance.amount = amount;
	}

	public ItemTransfer Copy()
	{
		ItemTransfer itemTransfer = default(ItemTransfer);
		CopyTo(itemTransfer);
		return itemTransfer;
	}

	public static ItemTransfer Deserialize(BufferStream stream)
	{
		ItemTransfer instance = default(ItemTransfer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static ItemTransfer DeserializeLengthDelimited(BufferStream stream)
	{
		ItemTransfer instance = default(ItemTransfer);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static ItemTransfer DeserializeLength(BufferStream stream, int length)
	{
		ItemTransfer instance = default(ItemTransfer);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static ItemTransfer Deserialize(byte[] buffer)
	{
		ItemTransfer instance = default(ItemTransfer);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, ItemTransfer previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static ItemTransfer Deserialize(BufferStream stream, ref ItemTransfer instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemTransfer DeserializeLengthDelimited(BufferStream stream, ref ItemTransfer instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemTransfer DeserializeLength(BufferStream stream, int length, ref ItemTransfer instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemTransfer instance, ItemTransfer previous)
	{
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
	}

	public static void Serialize(BufferStream stream, ItemTransfer instance)
	{
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class AssociatedFile : IDisposable, IPooled, IProto<AssociatedFile>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public uint crc;

	[NonSerialized]
	public uint numID;

	[NonSerialized]
	public byte[] data;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AssociatedFile instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.crc = 0u;
			instance.numID = 0u;
			instance.data = null;
			Pool.Free<AssociatedFile>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AssociatedFile with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AssociatedFile instance)
	{
		instance.type = type;
		instance.crc = crc;
		instance.numID = numID;
		if (data == null)
		{
			instance.data = null;
			return;
		}
		instance.data = new byte[data.Length];
		Array.Copy(data, instance.data, instance.data.Length);
	}

	public AssociatedFile Copy()
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		CopyTo(associatedFile);
		return associatedFile;
	}

	public static AssociatedFile Deserialize(BufferStream stream)
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		Deserialize(stream, associatedFile, isDelta: false);
		return associatedFile;
	}

	public static AssociatedFile DeserializeLengthDelimited(BufferStream stream)
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		DeserializeLengthDelimited(stream, associatedFile, isDelta: false);
		return associatedFile;
	}

	public static AssociatedFile DeserializeLength(BufferStream stream, int length)
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		DeserializeLength(stream, length, associatedFile, isDelta: false);
		return associatedFile;
	}

	public static AssociatedFile Deserialize(byte[] buffer)
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, associatedFile, isDelta: false);
		return associatedFile;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AssociatedFile previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AssociatedFile Deserialize(BufferStream stream, AssociatedFile instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.numID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AssociatedFile DeserializeLengthDelimited(BufferStream stream, AssociatedFile instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.numID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AssociatedFile DeserializeLength(BufferStream stream, int length, AssociatedFile instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.numID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AssociatedFile instance, AssociatedFile previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.crc != previous.crc)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
		if (instance.numID != previous.numID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.numID);
		}
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteBytes(stream, instance.data);
	}

	public static void Serialize(BufferStream stream, AssociatedFile instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.crc != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
		if (instance.numID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.numID);
		}
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteBytes(stream, instance.data);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ScheduleEntry : IDisposable, IPooled, IProto<ScheduleEntry>, IProto
{
	[NonSerialized]
	public int nextZoneId;

	[NonSerialized]
	public int estimate;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ScheduleEntry instance)
	{
		if (instance.ShouldPool)
		{
			instance.nextZoneId = 0;
			instance.estimate = 0;
			Pool.Free<ScheduleEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ScheduleEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ScheduleEntry instance)
	{
		instance.nextZoneId = nextZoneId;
		instance.estimate = estimate;
	}

	public ScheduleEntry Copy()
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		CopyTo(scheduleEntry);
		return scheduleEntry;
	}

	public static ScheduleEntry Deserialize(BufferStream stream)
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		Deserialize(stream, scheduleEntry, isDelta: false);
		return scheduleEntry;
	}

	public static ScheduleEntry DeserializeLengthDelimited(BufferStream stream)
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		DeserializeLengthDelimited(stream, scheduleEntry, isDelta: false);
		return scheduleEntry;
	}

	public static ScheduleEntry DeserializeLength(BufferStream stream, int length)
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		DeserializeLength(stream, length, scheduleEntry, isDelta: false);
		return scheduleEntry;
	}

	public static ScheduleEntry Deserialize(byte[] buffer)
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, scheduleEntry, isDelta: false);
		return scheduleEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ScheduleEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ScheduleEntry Deserialize(BufferStream stream, ScheduleEntry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ScheduleEntry DeserializeLengthDelimited(BufferStream stream, ScheduleEntry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ScheduleEntry DeserializeLength(BufferStream stream, int length, ScheduleEntry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ScheduleEntry instance, ScheduleEntry previous)
	{
		if (instance.nextZoneId != previous.nextZoneId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextZoneId);
		}
		if (instance.estimate != previous.estimate)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.estimate);
		}
	}

	public static void Serialize(BufferStream stream, ScheduleEntry instance)
	{
		if (instance.nextZoneId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextZoneId);
		}
		if (instance.estimate != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.estimate);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class QueuedMove : IDisposable, IPooled, IProto<QueuedMove>, IProto
{
	[NonSerialized]
	public NetworkableId targetEntity;

	[NonSerialized]
	public Vector3 targetWorldPosition;

	[NonSerialized]
	public Vector4 targetWorldRotation;

	[NonSerialized]
	public bool hasTarget;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(QueuedMove instance)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.targetEntity = default(NetworkableId);
			instance.targetWorldPosition = default(Vector3);
			instance.targetWorldRotation = default(Vector4);
			instance.hasTarget = false;
			Pool.Free<QueuedMove>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose QueuedMove with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(QueuedMove instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.targetEntity = targetEntity;
		instance.targetWorldPosition = targetWorldPosition;
		instance.targetWorldRotation = targetWorldRotation;
		instance.hasTarget = hasTarget;
	}

	public QueuedMove Copy()
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		CopyTo(queuedMove);
		return queuedMove;
	}

	public static QueuedMove Deserialize(BufferStream stream)
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		Deserialize(stream, queuedMove, isDelta: false);
		return queuedMove;
	}

	public static QueuedMove DeserializeLengthDelimited(BufferStream stream)
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		DeserializeLengthDelimited(stream, queuedMove, isDelta: false);
		return queuedMove;
	}

	public static QueuedMove DeserializeLength(BufferStream stream, int length)
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		DeserializeLength(stream, length, queuedMove, isDelta: false);
		return queuedMove;
	}

	public static QueuedMove Deserialize(byte[] buffer)
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, queuedMove, isDelta: false);
		return queuedMove;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, QueuedMove previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static QueuedMove Deserialize(BufferStream stream, QueuedMove instance, bool isDelta)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
				continue;
			case 32:
				instance.hasTarget = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static QueuedMove DeserializeLengthDelimited(BufferStream stream, QueuedMove instance, bool isDelta)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
				continue;
			case 32:
				instance.hasTarget = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static QueuedMove DeserializeLength(BufferStream stream, int length, QueuedMove instance, bool isDelta)
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
				continue;
			case 32:
				instance.hasTarget = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, QueuedMove instance, QueuedMove previous)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetEntity.Value);
		if (instance.targetWorldPosition != previous.targetWorldPosition)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.targetWorldPosition, previous.targetWorldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.targetWorldRotation != previous.targetWorldRotation)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.targetWorldRotation, previous.targetWorldRotation);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldRotation (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.hasTarget);
	}

	public static void Serialize(BufferStream stream, QueuedMove instance)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		if (instance.targetEntity != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetEntity.Value);
		}
		if (instance.targetWorldPosition != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.targetWorldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.targetWorldRotation != default(Vector4))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.targetWorldRotation);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldRotation (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.hasTarget)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.hasTarget);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetEntity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ClothingItem : IDisposable, IPooled, IProto<ClothingItem>, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public ulong skin;

	[NonSerialized]
	public ItemId uid;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClothingItem instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemId = 0;
			instance.skin = 0uL;
			instance.uid = default(ItemId);
			Pool.Free<ClothingItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClothingItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClothingItem instance)
	{
		instance.itemId = itemId;
		instance.skin = skin;
		instance.uid = uid;
	}

	public ClothingItem Copy()
	{
		ClothingItem clothingItem = Pool.Get<ClothingItem>();
		CopyTo(clothingItem);
		return clothingItem;
	}

	public static ClothingItem Deserialize(BufferStream stream)
	{
		ClothingItem clothingItem = Pool.Get<ClothingItem>();
		Deserialize(stream, clothingItem, isDelta: false);
		return clothingItem;
	}

	public static ClothingItem DeserializeLengthDelimited(BufferStream stream)
	{
		ClothingItem clothingItem = Pool.Get<ClothingItem>();
		DeserializeLengthDelimited(stream, clothingItem, isDelta: false);
		return clothingItem;
	}

	public static ClothingItem DeserializeLength(BufferStream stream, int length)
	{
		ClothingItem clothingItem = Pool.Get<ClothingItem>();
		DeserializeLength(stream, length, clothingItem, isDelta: false);
		return clothingItem;
	}

	public static ClothingItem Deserialize(byte[] buffer)
	{
		ClothingItem clothingItem = Pool.Get<ClothingItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clothingItem, isDelta: false);
		return clothingItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClothingItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClothingItem Deserialize(BufferStream stream, ClothingItem instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.skin = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.uid = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClothingItem DeserializeLengthDelimited(BufferStream stream, ClothingItem instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.skin = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.uid = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClothingItem DeserializeLength(BufferStream stream, int length, ClothingItem instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.skin = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.uid = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClothingItem instance, ClothingItem previous)
	{
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.skin != previous.skin)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.skin);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.uid.Value);
	}

	public static void Serialize(BufferStream stream, ClothingItem instance)
	{
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.skin != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.skin);
		}
		if (instance.uid != default(ItemId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.ItemId, ref uid.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class InstanceData : IDisposable, IPooled, IProto<InstanceData>, IProto
{
	[NonSerialized]
	public int dataInt;

	[NonSerialized]
	public int blueprintTarget;

	[NonSerialized]
	public int blueprintAmount;

	[NonSerialized]
	public NetworkableId subEntity;

	[NonSerialized]
	public float dataFloat;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InstanceData instance)
	{
		if (instance.ShouldPool)
		{
			instance.dataInt = 0;
			instance.blueprintTarget = 0;
			instance.blueprintAmount = 0;
			instance.subEntity = default(NetworkableId);
			instance.dataFloat = 0f;
			Pool.Free<InstanceData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InstanceData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InstanceData instance)
	{
		instance.dataInt = dataInt;
		instance.blueprintTarget = blueprintTarget;
		instance.blueprintAmount = blueprintAmount;
		instance.subEntity = subEntity;
		instance.dataFloat = dataFloat;
	}

	public InstanceData Copy()
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		CopyTo(instanceData);
		return instanceData;
	}

	public static InstanceData Deserialize(BufferStream stream)
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		Deserialize(stream, instanceData, isDelta: false);
		return instanceData;
	}

	public static InstanceData DeserializeLengthDelimited(BufferStream stream)
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		DeserializeLengthDelimited(stream, instanceData, isDelta: false);
		return instanceData;
	}

	public static InstanceData DeserializeLength(BufferStream stream, int length)
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		DeserializeLength(stream, length, instanceData, isDelta: false);
		return instanceData;
	}

	public static InstanceData Deserialize(byte[] buffer)
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instanceData, isDelta: false);
		return instanceData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InstanceData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InstanceData Deserialize(BufferStream stream, InstanceData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.dataFloat = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InstanceData DeserializeLengthDelimited(BufferStream stream, InstanceData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.dataFloat = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InstanceData DeserializeLength(BufferStream stream, int length, InstanceData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.dataFloat = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InstanceData instance, InstanceData previous)
	{
		if (instance.dataInt != previous.dataInt)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dataInt);
		}
		if (instance.blueprintTarget != previous.blueprintTarget)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintTarget);
		}
		if (instance.blueprintAmount != previous.blueprintAmount)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintAmount);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.subEntity.Value);
		if (instance.dataFloat != previous.dataFloat)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.dataFloat);
		}
	}

	public static void Serialize(BufferStream stream, InstanceData instance)
	{
		if (instance.dataInt != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dataInt);
		}
		if (instance.blueprintTarget != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintTarget);
		}
		if (instance.blueprintAmount != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintAmount);
		}
		if (instance.subEntity != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.subEntity.Value);
		}
		if (instance.dataFloat != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.dataFloat);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref subEntity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ConditionData : IDisposable, IPooled, IProto<ConditionData>, IProto
{
	[NonSerialized]
	public float condition;

	[NonSerialized]
	public float maxCondition;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ConditionData instance)
	{
		if (instance.ShouldPool)
		{
			instance.condition = 0f;
			instance.maxCondition = 0f;
			Pool.Free<ConditionData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ConditionData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ConditionData instance)
	{
		instance.condition = condition;
		instance.maxCondition = maxCondition;
	}

	public ConditionData Copy()
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		CopyTo(conditionData);
		return conditionData;
	}

	public static ConditionData Deserialize(BufferStream stream)
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		Deserialize(stream, conditionData, isDelta: false);
		return conditionData;
	}

	public static ConditionData DeserializeLengthDelimited(BufferStream stream)
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		DeserializeLengthDelimited(stream, conditionData, isDelta: false);
		return conditionData;
	}

	public static ConditionData DeserializeLength(BufferStream stream, int length)
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		DeserializeLength(stream, length, conditionData, isDelta: false);
		return conditionData;
	}

	public static ConditionData Deserialize(byte[] buffer)
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, conditionData, isDelta: false);
		return conditionData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ConditionData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ConditionData Deserialize(BufferStream stream, ConditionData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.condition = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.maxCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ConditionData DeserializeLengthDelimited(BufferStream stream, ConditionData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.condition = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.maxCondition = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ConditionData DeserializeLength(BufferStream stream, int length, ConditionData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.condition = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.maxCondition = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ConditionData instance, ConditionData previous)
	{
		if (instance.condition != previous.condition)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.condition);
		}
		if (instance.maxCondition != previous.maxCondition)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.maxCondition);
		}
	}

	public static void Serialize(BufferStream stream, ConditionData instance)
	{
		if (instance.condition != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.condition);
		}
		if (instance.maxCondition != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.maxCondition);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Projectile : IDisposable, IPooled, IProto<Projectile>, IProto
{
	[NonSerialized]
	public int projectileID;

	[NonSerialized]
	public Vector3 startPos;

	[NonSerialized]
	public Vector3 startVel;

	[NonSerialized]
	public int seed;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Projectile instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.projectileID = 0;
			instance.startPos = default(Vector3);
			instance.startVel = default(Vector3);
			instance.seed = 0;
			Pool.Free<Projectile>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Projectile with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Projectile instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.projectileID = projectileID;
		instance.startPos = startPos;
		instance.startVel = startVel;
		instance.seed = seed;
	}

	public Projectile Copy()
	{
		Projectile projectile = Pool.Get<Projectile>();
		CopyTo(projectile);
		return projectile;
	}

	public static Projectile Deserialize(BufferStream stream)
	{
		Projectile projectile = Pool.Get<Projectile>();
		Deserialize(stream, projectile, isDelta: false);
		return projectile;
	}

	public static Projectile DeserializeLengthDelimited(BufferStream stream)
	{
		Projectile projectile = Pool.Get<Projectile>();
		DeserializeLengthDelimited(stream, projectile, isDelta: false);
		return projectile;
	}

	public static Projectile DeserializeLength(BufferStream stream, int length)
	{
		Projectile projectile = Pool.Get<Projectile>();
		DeserializeLength(stream, length, projectile, isDelta: false);
		return projectile;
	}

	public static Projectile Deserialize(byte[] buffer)
	{
		Projectile projectile = Pool.Get<Projectile>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, projectile, isDelta: false);
		return projectile;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Projectile previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Projectile Deserialize(BufferStream stream, Projectile instance, bool isDelta)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
				continue;
			case 32:
				instance.seed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Projectile DeserializeLengthDelimited(BufferStream stream, Projectile instance, bool isDelta)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
				continue;
			case 32:
				instance.seed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Projectile DeserializeLength(BufferStream stream, int length, Projectile instance, bool isDelta)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
				continue;
			case 32:
				instance.seed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Projectile instance, Projectile previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != previous.projectileID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.startPos != previous.startPos)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.startPos, previous.startPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.startVel != previous.startVel)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.startVel, previous.startVel);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startVel (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.seed != previous.seed)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.seed);
		}
	}

	public static void Serialize(BufferStream stream, Projectile instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.startPos != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.startPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.startVel != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.startVel);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startVel (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.seed != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.seed);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class SpawnOptions : IDisposable, IPooled, IProto<SpawnOptions>, IProto
{
	public enum RespawnType
	{
		SleepingBag = 1,
		Bed,
		BeachTowel,
		Camper,
		Static
	}

	public enum RespawnState
	{
		OK = 1,
		Occupied,
		Underwater,
		InNoRespawnZone
	}

	[NonSerialized]
	public RespawnType type;

	[NonSerialized]
	public NetworkableId id;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public float unlockSeconds;

	[NonSerialized]
	public Vector3 worldPosition;

	[NonSerialized]
	public RespawnState respawnState;

	[NonSerialized]
	public bool mobile;

	[NonSerialized]
	public string nexusZone;

	[NonSerialized]
	public bool corpse;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpawnOptions instance)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.type = (RespawnType)0;
			instance.id = default(NetworkableId);
			instance.name = string.Empty;
			instance.unlockSeconds = 0f;
			instance.worldPosition = default(Vector3);
			instance.respawnState = (RespawnState)0;
			instance.mobile = false;
			instance.nexusZone = string.Empty;
			instance.corpse = false;
			Pool.Free<SpawnOptions>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpawnOptions with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpawnOptions instance)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.type = type;
		instance.id = id;
		instance.name = name;
		instance.unlockSeconds = unlockSeconds;
		instance.worldPosition = worldPosition;
		instance.respawnState = respawnState;
		instance.mobile = mobile;
		instance.nexusZone = nexusZone;
		instance.corpse = corpse;
	}

	public SpawnOptions Copy()
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		CopyTo(spawnOptions);
		return spawnOptions;
	}

	public static SpawnOptions Deserialize(BufferStream stream)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		Deserialize(stream, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public static SpawnOptions DeserializeLengthDelimited(BufferStream stream)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		DeserializeLengthDelimited(stream, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public static SpawnOptions DeserializeLength(BufferStream stream, int length)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		DeserializeLength(stream, length, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public static SpawnOptions Deserialize(byte[] buffer)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpawnOptions previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpawnOptions Deserialize(BufferStream stream, SpawnOptions instance, bool isDelta)
	{
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.respawnState = RespawnState.OK;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 37:
				instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 48:
				instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.corpse = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpawnOptions DeserializeLengthDelimited(BufferStream stream, SpawnOptions instance, bool isDelta)
	{
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.respawnState = RespawnState.OK;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 37:
				instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 48:
				instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.corpse = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpawnOptions DeserializeLength(BufferStream stream, int length, SpawnOptions instance, bool isDelta)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.respawnState = RespawnState.OK;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 37:
				instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 48:
				instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.corpse = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpawnOptions instance, SpawnOptions previous)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.id.Value);
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.unlockSeconds != previous.unlockSeconds)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
		}
		if (instance.worldPosition != previous.worldPosition)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.worldPosition, previous.worldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.mobile);
		if (instance.nexusZone != null && instance.nexusZone != previous.nexusZone)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.corpse);
	}

	public static void Serialize(BufferStream stream, SpawnOptions instance)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.id != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.id.Value);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.unlockSeconds != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
		}
		if (instance.worldPosition != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.worldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
		if (instance.mobile)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.mobile);
		}
		if (instance.nexusZone != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		if (instance.corpse)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.corpse);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref id.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ClientInfo : IDisposable, IPooled, IProto<ClientInfo>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public string value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClientInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.value = string.Empty;
			Pool.Free<ClientInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClientInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClientInfo instance)
	{
		instance.name = name;
		instance.value = value;
	}

	public ClientInfo Copy()
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		CopyTo(clientInfo);
		return clientInfo;
	}

	public static ClientInfo Deserialize(BufferStream stream)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		Deserialize(stream, clientInfo, isDelta: false);
		return clientInfo;
	}

	public static ClientInfo DeserializeLengthDelimited(BufferStream stream)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		DeserializeLengthDelimited(stream, clientInfo, isDelta: false);
		return clientInfo;
	}

	public static ClientInfo DeserializeLength(BufferStream stream, int length)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		DeserializeLength(stream, length, clientInfo, isDelta: false);
		return clientInfo;
	}

	public static ClientInfo Deserialize(byte[] buffer)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clientInfo, isDelta: false);
		return clientInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClientInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClientInfo Deserialize(BufferStream stream, ClientInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.value = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClientInfo DeserializeLengthDelimited(BufferStream stream, ClientInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.value = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClientInfo DeserializeLength(BufferStream stream, int length, ClientInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.value = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClientInfo instance, ClientInfo previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.value != previous.value)
		{
			if (instance.value == null)
			{
				throw new ArgumentNullException("value", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, ClientInfo instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.value == null)
		{
			throw new ArgumentNullException("value", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.value);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum MessageType
{
	Request = 1,
	Receive,
	Done
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class arcadeEnt : IDisposable, IPooled, IProto<arcadeEnt>, IProto
{
	[NonSerialized]
	public uint id;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public uint spriteID;

	[NonSerialized]
	public uint soundID;

	[NonSerialized]
	public bool visible;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 heading;

	[NonSerialized]
	public bool enabled;

	[NonSerialized]
	public Vector3 scale;

	[NonSerialized]
	public Vector3 colliderScale;

	[NonSerialized]
	public float alpha;

	[NonSerialized]
	public uint prefabID;

	[NonSerialized]
	public uint parentID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(arcadeEnt instance)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.id = 0u;
			instance.name = string.Empty;
			instance.spriteID = 0u;
			instance.soundID = 0u;
			instance.visible = false;
			instance.position = default(Vector3);
			instance.heading = default(Vector3);
			instance.enabled = false;
			instance.scale = default(Vector3);
			instance.colliderScale = default(Vector3);
			instance.alpha = 0f;
			instance.prefabID = 0u;
			instance.parentID = 0u;
			Pool.Free<arcadeEnt>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose arcadeEnt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(arcadeEnt instance)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		instance.id = id;
		instance.name = name;
		instance.spriteID = spriteID;
		instance.soundID = soundID;
		instance.visible = visible;
		instance.position = position;
		instance.heading = heading;
		instance.enabled = enabled;
		instance.scale = scale;
		instance.colliderScale = colliderScale;
		instance.alpha = alpha;
		instance.prefabID = prefabID;
		instance.parentID = parentID;
	}

	public arcadeEnt Copy()
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		CopyTo(arcadeEnt);
		return arcadeEnt;
	}

	public static arcadeEnt Deserialize(BufferStream stream)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		Deserialize(stream, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public static arcadeEnt DeserializeLengthDelimited(BufferStream stream)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		DeserializeLengthDelimited(stream, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public static arcadeEnt DeserializeLength(BufferStream stream, int length)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		DeserializeLength(stream, length, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public static arcadeEnt Deserialize(byte[] buffer)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, arcadeEnt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static arcadeEnt Deserialize(BufferStream stream, arcadeEnt instance, bool isDelta)
	{
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.spriteID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.soundID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 40:
				instance.visible = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
				continue;
			case 64:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
				continue;
			case 93:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 96:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 104:
				instance.parentID = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static arcadeEnt DeserializeLengthDelimited(BufferStream stream, arcadeEnt instance, bool isDelta)
	{
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.spriteID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.soundID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 40:
				instance.visible = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
				continue;
			case 64:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
				continue;
			case 93:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 96:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 104:
				instance.parentID = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static arcadeEnt DeserializeLength(BufferStream stream, int length, arcadeEnt instance, bool isDelta)
	{
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.spriteID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.soundID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 40:
				instance.visible = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
				continue;
			case 64:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
				continue;
			case 93:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 96:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 104:
				instance.parentID = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, arcadeEnt instance, arcadeEnt previous)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		if (instance.id != previous.id)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.spriteID != previous.spriteID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.spriteID);
		}
		if (instance.soundID != previous.soundID)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.soundID);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.visible);
		if (instance.position != previous.position)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.heading != previous.heading)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.heading, previous.heading);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heading (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.enabled);
		if (instance.scale != previous.scale)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.scale, previous.scale);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.colliderScale != previous.colliderScale)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.colliderScale, previous.colliderScale);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colliderScale (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		if (instance.alpha != previous.alpha)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.prefabID != previous.prefabID)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.prefabID);
		}
		if (instance.parentID != previous.parentID)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt32(stream, instance.parentID);
		}
	}

	public static void Serialize(BufferStream stream, arcadeEnt instance)
	{
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		if (instance.id != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.spriteID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.spriteID);
		}
		if (instance.soundID != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.soundID);
		}
		if (instance.visible)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.visible);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.heading != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.heading);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heading (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.enabled)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.enabled);
		}
		if (instance.scale != default(Vector3))
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.scale);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.colliderScale != default(Vector3))
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.colliderScale);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colliderScale (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		if (instance.alpha != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.prefabID != 0)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.prefabID);
		}
		if (instance.parentID != 0)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt32(stream, instance.parentID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class DirectoryEntry : IDisposable, IPooled, IProto<DirectoryEntry>, IProto
{
	[NonSerialized]
	public int phoneNumber;

	[NonSerialized]
	public string phoneName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DirectoryEntry instance)
	{
		if (instance.ShouldPool)
		{
			instance.phoneNumber = 0;
			instance.phoneName = string.Empty;
			Pool.Free<DirectoryEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DirectoryEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DirectoryEntry instance)
	{
		instance.phoneNumber = phoneNumber;
		instance.phoneName = phoneName;
	}

	public DirectoryEntry Copy()
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		CopyTo(directoryEntry);
		return directoryEntry;
	}

	public static DirectoryEntry Deserialize(BufferStream stream)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		Deserialize(stream, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public static DirectoryEntry DeserializeLengthDelimited(BufferStream stream)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		DeserializeLengthDelimited(stream, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public static DirectoryEntry DeserializeLength(BufferStream stream, int length)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		DeserializeLength(stream, length, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public static DirectoryEntry Deserialize(byte[] buffer)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DirectoryEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DirectoryEntry Deserialize(BufferStream stream, DirectoryEntry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.phoneName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DirectoryEntry DeserializeLengthDelimited(BufferStream stream, DirectoryEntry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.phoneName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DirectoryEntry DeserializeLength(BufferStream stream, int length, DirectoryEntry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.phoneName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DirectoryEntry instance, DirectoryEntry previous)
	{
		if (instance.phoneNumber != previous.phoneNumber)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		if (instance.phoneName != previous.phoneName)
		{
			if (instance.phoneName == null)
			{
				throw new ArgumentNullException("phoneName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}
	}

	public static void Serialize(BufferStream stream, DirectoryEntry instance)
	{
		if (instance.phoneNumber != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		if (instance.phoneName == null)
		{
			throw new ArgumentNullException("phoneName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.phoneName);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum Category
{
	Line,
	Log,
	Text,
	Sphere,
	Box
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TeamMember : IDisposable, IPooled, IProto<TeamMember>, IProto
{
	[NonSerialized]
	public string displayName;

	[NonSerialized]
	public ulong userID;

	[NonSerialized]
	public float healthFraction;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public bool online;

	[NonSerialized]
	public bool wounded;

	[NonSerialized]
	public ulong teamID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TeamMember instance)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.displayName = string.Empty;
			instance.userID = 0uL;
			instance.healthFraction = 0f;
			instance.position = default(Vector3);
			instance.online = false;
			instance.wounded = false;
			instance.teamID = 0uL;
			Pool.Free<TeamMember>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TeamMember with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TeamMember instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.displayName = displayName;
		instance.userID = userID;
		instance.healthFraction = healthFraction;
		instance.position = position;
		instance.online = online;
		instance.wounded = wounded;
		instance.teamID = teamID;
	}

	public TeamMember Copy()
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		CopyTo(teamMember);
		return teamMember;
	}

	public static TeamMember Deserialize(BufferStream stream)
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		Deserialize(stream, teamMember, isDelta: false);
		return teamMember;
	}

	public static TeamMember DeserializeLengthDelimited(BufferStream stream)
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		DeserializeLengthDelimited(stream, teamMember, isDelta: false);
		return teamMember;
	}

	public static TeamMember DeserializeLength(BufferStream stream, int length)
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		DeserializeLength(stream, length, teamMember, isDelta: false);
		return teamMember;
	}

	public static TeamMember Deserialize(byte[] buffer)
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, teamMember, isDelta: false);
		return teamMember;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TeamMember previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TeamMember Deserialize(BufferStream stream, TeamMember instance, bool isDelta)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 40:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.wounded = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TeamMember DeserializeLengthDelimited(BufferStream stream, TeamMember instance, bool isDelta)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 40:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.wounded = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TeamMember DeserializeLength(BufferStream stream, int length, TeamMember instance, bool isDelta)
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 40:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.wounded = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TeamMember instance, TeamMember previous)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.displayName != null && instance.displayName != previous.displayName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.userID != previous.userID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userID);
		}
		if (instance.healthFraction != previous.healthFraction)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.healthFraction);
		}
		if (instance.position != previous.position)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.online);
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.wounded);
		if (instance.teamID != previous.teamID)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.teamID);
		}
	}

	public static void Serialize(BufferStream stream, TeamMember instance)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		if (instance.displayName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.userID != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userID);
		}
		if (instance.healthFraction != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.healthFraction);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.online)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.online);
		}
		if (instance.wounded)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.wounded);
		}
		if (instance.teamID != 0L)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.teamID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class DeathInfo : IDisposable, IPooled, IProto<DeathInfo>, IProto
{
	[NonSerialized]
	public string attackerName;

	[NonSerialized]
	public ulong attackerSteamID;

	[NonSerialized]
	public string hitBone;

	[NonSerialized]
	public string inflictorName;

	[NonSerialized]
	public int lastDamageType;

	[NonSerialized]
	public float attackerDistance;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DeathInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.attackerName = string.Empty;
			instance.attackerSteamID = 0uL;
			instance.hitBone = string.Empty;
			instance.inflictorName = string.Empty;
			instance.lastDamageType = 0;
			instance.attackerDistance = 0f;
			Pool.Free<DeathInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DeathInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DeathInfo instance)
	{
		instance.attackerName = attackerName;
		instance.attackerSteamID = attackerSteamID;
		instance.hitBone = hitBone;
		instance.inflictorName = inflictorName;
		instance.lastDamageType = lastDamageType;
		instance.attackerDistance = attackerDistance;
	}

	public DeathInfo Copy()
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		CopyTo(deathInfo);
		return deathInfo;
	}

	public static DeathInfo Deserialize(BufferStream stream)
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		Deserialize(stream, deathInfo, isDelta: false);
		return deathInfo;
	}

	public static DeathInfo DeserializeLengthDelimited(BufferStream stream)
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		DeserializeLengthDelimited(stream, deathInfo, isDelta: false);
		return deathInfo;
	}

	public static DeathInfo DeserializeLength(BufferStream stream, int length)
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		DeserializeLength(stream, length, deathInfo, isDelta: false);
		return deathInfo;
	}

	public static DeathInfo Deserialize(byte[] buffer)
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, deathInfo, isDelta: false);
		return deathInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DeathInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DeathInfo Deserialize(BufferStream stream, DeathInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.attackerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.hitBone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.inflictorName = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.attackerDistance = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DeathInfo DeserializeLengthDelimited(BufferStream stream, DeathInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.attackerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.hitBone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.inflictorName = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.attackerDistance = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DeathInfo DeserializeLength(BufferStream stream, int length, DeathInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.attackerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.hitBone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.inflictorName = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.attackerDistance = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DeathInfo instance, DeathInfo previous)
	{
		if (instance.attackerName != null && instance.attackerName != previous.attackerName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.attackerName);
		}
		if (instance.attackerSteamID != previous.attackerSteamID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.attackerSteamID);
		}
		if (instance.hitBone != null && instance.hitBone != previous.hitBone)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.hitBone);
		}
		if (instance.inflictorName != null && instance.inflictorName != previous.inflictorName)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.inflictorName);
		}
		if (instance.lastDamageType != previous.lastDamageType)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastDamageType);
		}
		if (instance.attackerDistance != previous.attackerDistance)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.attackerDistance);
		}
	}

	public static void Serialize(BufferStream stream, DeathInfo instance)
	{
		if (instance.attackerName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.attackerName);
		}
		if (instance.attackerSteamID != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.attackerSteamID);
		}
		if (instance.hitBone != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.hitBone);
		}
		if (instance.inflictorName != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.inflictorName);
		}
		if (instance.lastDamageType != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastDamageType);
		}
		if (instance.attackerDistance != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.attackerDistance);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class WeaponStats : IDisposable, IPooled, IProto<WeaponStats>, IProto
{
	[NonSerialized]
	public string weaponName;

	[NonSerialized]
	public ulong shotsFired;

	[NonSerialized]
	public ulong shotsHit;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WeaponStats instance)
	{
		if (instance.ShouldPool)
		{
			instance.weaponName = string.Empty;
			instance.shotsFired = 0uL;
			instance.shotsHit = 0uL;
			Pool.Free<WeaponStats>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WeaponStats with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WeaponStats instance)
	{
		instance.weaponName = weaponName;
		instance.shotsFired = shotsFired;
		instance.shotsHit = shotsHit;
	}

	public WeaponStats Copy()
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		CopyTo(weaponStats);
		return weaponStats;
	}

	public static WeaponStats Deserialize(BufferStream stream)
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		Deserialize(stream, weaponStats, isDelta: false);
		return weaponStats;
	}

	public static WeaponStats DeserializeLengthDelimited(BufferStream stream)
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		DeserializeLengthDelimited(stream, weaponStats, isDelta: false);
		return weaponStats;
	}

	public static WeaponStats DeserializeLength(BufferStream stream, int length)
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		DeserializeLength(stream, length, weaponStats, isDelta: false);
		return weaponStats;
	}

	public static WeaponStats Deserialize(byte[] buffer)
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, weaponStats, isDelta: false);
		return weaponStats;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WeaponStats previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WeaponStats Deserialize(BufferStream stream, WeaponStats instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.weaponName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.shotsFired = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.shotsHit = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WeaponStats DeserializeLengthDelimited(BufferStream stream, WeaponStats instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.weaponName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.shotsFired = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.shotsHit = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WeaponStats DeserializeLength(BufferStream stream, int length, WeaponStats instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.weaponName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.shotsFired = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.shotsHit = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WeaponStats instance, WeaponStats previous)
	{
		if (instance.weaponName != previous.weaponName)
		{
			if (instance.weaponName == null)
			{
				throw new ArgumentNullException("weaponName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.weaponName);
		}
		if (instance.shotsFired != previous.shotsFired)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.shotsFired);
		}
		if (instance.shotsHit != previous.shotsHit)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.shotsHit);
		}
	}

	public static void Serialize(BufferStream stream, WeaponStats instance)
	{
		if (instance.weaponName == null)
		{
			throw new ArgumentNullException("weaponName", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.weaponName);
		if (instance.shotsFired != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.shotsFired);
		}
		if (instance.shotsHit != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.shotsHit);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class GenericStat : IDisposable, IPooled, IProto<GenericStat>, IProto
{
	[NonSerialized]
	public string key;

	[NonSerialized]
	public int value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(GenericStat instance)
	{
		if (instance.ShouldPool)
		{
			instance.key = string.Empty;
			instance.value = 0;
			Pool.Free<GenericStat>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose GenericStat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(GenericStat instance)
	{
		instance.key = key;
		instance.value = value;
	}

	public GenericStat Copy()
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		CopyTo(genericStat);
		return genericStat;
	}

	public static GenericStat Deserialize(BufferStream stream)
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		Deserialize(stream, genericStat, isDelta: false);
		return genericStat;
	}

	public static GenericStat DeserializeLengthDelimited(BufferStream stream)
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		DeserializeLengthDelimited(stream, genericStat, isDelta: false);
		return genericStat;
	}

	public static GenericStat DeserializeLength(BufferStream stream, int length)
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		DeserializeLength(stream, length, genericStat, isDelta: false);
		return genericStat;
	}

	public static GenericStat Deserialize(byte[] buffer)
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, genericStat, isDelta: false);
		return genericStat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, GenericStat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static GenericStat Deserialize(BufferStream stream, GenericStat instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.key = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static GenericStat DeserializeLengthDelimited(BufferStream stream, GenericStat instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.key = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static GenericStat DeserializeLength(BufferStream stream, int length, GenericStat instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.key = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, GenericStat instance, GenericStat previous)
	{
		if (instance.key != previous.key)
		{
			if (instance.key == null)
			{
				throw new ArgumentNullException("key", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.key);
		}
		if (instance.value != previous.value)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
		}
	}

	public static void Serialize(BufferStream stream, GenericStat instance)
	{
		if (instance.key == null)
		{
			throw new ArgumentNullException("key", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.key);
		if (instance.value != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Task : IDisposable, IPooled, IProto<Task>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public float remainingTime;

	[NonSerialized]
	public int taskUID;

	[NonSerialized]
	public bool cancelled;

	[NonSerialized]
	public Item.InstanceData instanceData;

	[NonSerialized]
	public int amount;

	[NonSerialized]
	public int skinID;

	[NonSerialized]
	public List<Item> takenItems;

	[NonSerialized]
	public int numCrafted;

	[NonSerialized]
	public float conditionScale;

	[NonSerialized]
	public NetworkableId workbenchEntity;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Task instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.itemID = 0;
		instance.remainingTime = 0f;
		instance.taskUID = 0;
		instance.cancelled = false;
		if (instance.instanceData != null)
		{
			instance.instanceData.ResetToPool();
			instance.instanceData = null;
		}
		instance.amount = 0;
		instance.skinID = 0;
		if (instance.takenItems != null)
		{
			for (int i = 0; i < instance.takenItems.Count; i++)
			{
				if (instance.takenItems[i] != null)
				{
					instance.takenItems[i].ResetToPool();
					instance.takenItems[i] = null;
				}
			}
			List<Item> list = instance.takenItems;
			Pool.Free<Item>(ref list, false);
			instance.takenItems = list;
		}
		instance.numCrafted = 0;
		instance.conditionScale = 0f;
		instance.workbenchEntity = default(NetworkableId);
		Pool.Free<Task>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Task with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Task instance)
	{
		instance.itemID = itemID;
		instance.remainingTime = remainingTime;
		instance.taskUID = taskUID;
		instance.cancelled = cancelled;
		if (instanceData != null)
		{
			if (instance.instanceData == null)
			{
				instance.instanceData = instanceData.Copy();
			}
			else
			{
				instanceData.CopyTo(instance.instanceData);
			}
		}
		else
		{
			instance.instanceData = null;
		}
		instance.amount = amount;
		instance.skinID = skinID;
		if (takenItems != null)
		{
			instance.takenItems = Pool.Get<List<Item>>();
			for (int i = 0; i < takenItems.Count; i++)
			{
				Item item = takenItems[i].Copy();
				instance.takenItems.Add(item);
			}
		}
		else
		{
			instance.takenItems = null;
		}
		instance.numCrafted = numCrafted;
		instance.conditionScale = conditionScale;
		instance.workbenchEntity = workbenchEntity;
	}

	public Task Copy()
	{
		Task task = Pool.Get<Task>();
		CopyTo(task);
		return task;
	}

	public static Task Deserialize(BufferStream stream)
	{
		Task task = Pool.Get<Task>();
		Deserialize(stream, task, isDelta: false);
		return task;
	}

	public static Task DeserializeLengthDelimited(BufferStream stream)
	{
		Task task = Pool.Get<Task>();
		DeserializeLengthDelimited(stream, task, isDelta: false);
		return task;
	}

	public static Task DeserializeLength(BufferStream stream, int length)
	{
		Task task = Pool.Get<Task>();
		DeserializeLength(stream, length, task, isDelta: false);
		return task;
	}

	public static Task Deserialize(byte[] buffer)
	{
		Task task = Pool.Get<Task>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, task, isDelta: false);
		return task;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Task previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Task Deserialize(BufferStream stream, Task instance, bool isDelta)
	{
		if (!isDelta && instance.takenItems == null)
		{
			instance.takenItems = Pool.Get<List<Item>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 21:
				instance.remainingTime = ProtocolParser.ReadSingle(stream);
				break;
			case 24:
				instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.cancelled = ProtocolParser.ReadBool(stream);
				break;
			case 42:
				if (instance.instanceData == null)
				{
					instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			case 48:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 66:
				instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
				break;
			case 72:
				instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 85:
				instance.conditionScale = ProtocolParser.ReadSingle(stream);
				break;
			case 88:
				instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Task DeserializeLengthDelimited(BufferStream stream, Task instance, bool isDelta)
	{
		if (!isDelta && instance.takenItems == null)
		{
			instance.takenItems = Pool.Get<List<Item>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 21:
				instance.remainingTime = ProtocolParser.ReadSingle(stream);
				break;
			case 24:
				instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.cancelled = ProtocolParser.ReadBool(stream);
				break;
			case 42:
				if (instance.instanceData == null)
				{
					instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			case 48:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 66:
				instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
				break;
			case 72:
				instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 85:
				instance.conditionScale = ProtocolParser.ReadSingle(stream);
				break;
			case 88:
				instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Task DeserializeLength(BufferStream stream, int length, Task instance, bool isDelta)
	{
		if (!isDelta && instance.takenItems == null)
		{
			instance.takenItems = Pool.Get<List<Item>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 21:
				instance.remainingTime = ProtocolParser.ReadSingle(stream);
				break;
			case 24:
				instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.cancelled = ProtocolParser.ReadBool(stream);
				break;
			case 42:
				if (instance.instanceData == null)
				{
					instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			case 48:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 66:
				instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
				break;
			case 72:
				instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 85:
				instance.conditionScale = ProtocolParser.ReadSingle(stream);
				break;
			case 88:
				instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Task instance, Task previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.remainingTime != previous.remainingTime)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.remainingTime);
		}
		if (instance.taskUID != previous.taskUID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.taskUID);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.cancelled);
		if (instance.instanceData != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Item.InstanceData.SerializeDelta(stream, instance.instanceData, previous.instanceData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.skinID != previous.skinID)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.skinID);
		}
		if (instance.takenItems != null)
		{
			for (int i = 0; i < instance.takenItems.Count; i++)
			{
				Item item = instance.takenItems[i];
				stream.WriteByte(66);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Item.SerializeDelta(stream, item, item);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.numCrafted != previous.numCrafted)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numCrafted);
		}
		if (instance.conditionScale != previous.conditionScale)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.conditionScale);
		}
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, instance.workbenchEntity.Value);
	}

	public static void Serialize(BufferStream stream, Task instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.remainingTime != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.remainingTime);
		}
		if (instance.taskUID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.taskUID);
		}
		if (instance.cancelled)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.cancelled);
		}
		if (instance.instanceData != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Item.InstanceData.Serialize(stream, instance.instanceData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.skinID != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.skinID);
		}
		if (instance.takenItems != null)
		{
			for (int i = 0; i < instance.takenItems.Count; i++)
			{
				Item instance2 = instance.takenItems[i];
				stream.WriteByte(66);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Item.Serialize(stream, instance2);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.numCrafted != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numCrafted);
		}
		if (instance.conditionScale != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.conditionScale);
		}
		if (instance.workbenchEntity != default(NetworkableId))
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, instance.workbenchEntity.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		instanceData?.InspectUids(action);
		if (takenItems != null)
		{
			for (int i = 0; i < takenItems.Count; i++)
			{
				takenItems[i]?.InspectUids(action);
			}
		}
		action(UidType.Clear, ref workbenchEntity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class RelationshipData : IDisposable, IPooled, IProto<RelationshipData>, IProto
{
	[NonSerialized]
	public RelationshipManager.PlayerRelationshipInfo info;

	[NonSerialized]
	public ArraySegment<byte> mugshotData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RelationshipData instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.info != null)
			{
				instance.info.ResetToPool();
				instance.info = null;
			}
			if (instance.mugshotData.Array != null)
			{
				BufferStream.Shared.ArrayPool.Return(instance.mugshotData.Array);
			}
			instance.mugshotData = default(ArraySegment<byte>);
			Pool.Free<RelationshipData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RelationshipData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RelationshipData instance)
	{
		if (info != null)
		{
			if (instance.info == null)
			{
				instance.info = info.Copy();
			}
			else
			{
				info.CopyTo(instance.info);
			}
		}
		else
		{
			instance.info = null;
		}
		if (mugshotData.Array == null)
		{
			instance.mugshotData = default(ArraySegment<byte>);
			return;
		}
		byte[] array = BufferStream.Shared.ArrayPool.Rent(mugshotData.Count);
		Array.Copy(mugshotData.Array, 0, array, 0, mugshotData.Count);
		instance.mugshotData = new ArraySegment<byte>(array, 0, mugshotData.Count);
	}

	public RelationshipData Copy()
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		CopyTo(relationshipData);
		return relationshipData;
	}

	public static RelationshipData Deserialize(BufferStream stream)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		Deserialize(stream, relationshipData, isDelta: false);
		return relationshipData;
	}

	public static RelationshipData DeserializeLengthDelimited(BufferStream stream)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		DeserializeLengthDelimited(stream, relationshipData, isDelta: false);
		return relationshipData;
	}

	public static RelationshipData DeserializeLength(BufferStream stream, int length)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		DeserializeLength(stream, length, relationshipData, isDelta: false);
		return relationshipData;
	}

	public static RelationshipData Deserialize(byte[] buffer)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, relationshipData, isDelta: false);
		return relationshipData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RelationshipData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RelationshipData Deserialize(BufferStream stream, RelationshipData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.info == null)
				{
					instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				break;
			case 18:
				instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static RelationshipData DeserializeLengthDelimited(BufferStream stream, RelationshipData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.info == null)
				{
					instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				break;
			case 18:
				instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RelationshipData DeserializeLength(BufferStream stream, int length, RelationshipData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.info == null)
				{
					instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				break;
			case 18:
				instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RelationshipData instance, RelationshipData previous)
	{
		if (instance.info == null)
		{
			throw new ArgumentNullException("info", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		RelationshipManager.PlayerRelationshipInfo.SerializeDelta(stream, instance.info, previous.info);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
		if (instance.mugshotData.Array != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
		}
	}

	public static void Serialize(BufferStream stream, RelationshipData instance)
	{
		if (instance.info == null)
		{
			throw new ArgumentNullException("info", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		RelationshipManager.PlayerRelationshipInfo.Serialize(stream, instance.info);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
		if (instance.mugshotData.Array != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		info?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Message : IDisposable, IPooled, IProto<Message>, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public ulong userId;

	[NonSerialized]
	public string text;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Message instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			instance.userId = 0uL;
			instance.text = string.Empty;
			instance.name = string.Empty;
			instance.timestamp = 0L;
			Pool.Free<Message>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Message with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Message instance)
	{
		instance.clanId = clanId;
		instance.userId = userId;
		instance.text = text;
		instance.name = name;
		instance.timestamp = timestamp;
	}

	public Message Copy()
	{
		Message message = Pool.Get<Message>();
		CopyTo(message);
		return message;
	}

	public static Message Deserialize(BufferStream stream)
	{
		Message message = Pool.Get<Message>();
		Deserialize(stream, message, isDelta: false);
		return message;
	}

	public static Message DeserializeLengthDelimited(BufferStream stream)
	{
		Message message = Pool.Get<Message>();
		DeserializeLengthDelimited(stream, message, isDelta: false);
		return message;
	}

	public static Message DeserializeLength(BufferStream stream, int length)
	{
		Message message = Pool.Get<Message>();
		DeserializeLength(stream, length, message, isDelta: false);
		return message;
	}

	public static Message Deserialize(byte[] buffer)
	{
		Message message = Pool.Get<Message>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, message, isDelta: false);
		return message;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Message previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Message Deserialize(BufferStream stream, Message instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Message DeserializeLengthDelimited(BufferStream stream, Message instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Message DeserializeLength(BufferStream stream, int length, Message instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Message instance, Message previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.text != previous.text)
		{
			if (instance.text == null)
			{
				throw new ArgumentNullException("text", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.text);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, Message instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.userId != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.text == null)
		{
			throw new ArgumentNullException("text", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.text);
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LineVec : IDisposable, IPooled, IProto<LineVec>, IProto
{
	[NonSerialized]
	public Vector4 vec;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LineVec instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.vec = default(Vector4);
			Pool.Free<LineVec>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LineVec with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LineVec instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.vec = vec;
	}

	public LineVec Copy()
	{
		LineVec lineVec = Pool.Get<LineVec>();
		CopyTo(lineVec);
		return lineVec;
	}

	public static LineVec Deserialize(BufferStream stream)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		Deserialize(stream, lineVec, isDelta: false);
		return lineVec;
	}

	public static LineVec DeserializeLengthDelimited(BufferStream stream)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		DeserializeLengthDelimited(stream, lineVec, isDelta: false);
		return lineVec;
	}

	public static LineVec DeserializeLength(BufferStream stream, int length)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		DeserializeLength(stream, length, lineVec, isDelta: false);
		return lineVec;
	}

	public static LineVec Deserialize(byte[] buffer)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lineVec, isDelta: false);
		return lineVec;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LineVec previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LineVec Deserialize(BufferStream stream, LineVec instance, bool isDelta)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LineVec DeserializeLengthDelimited(BufferStream stream, LineVec instance, bool isDelta)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LineVec DeserializeLength(BufferStream stream, int length, LineVec instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LineVec instance, LineVec previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.vec != previous.vec)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.vec, previous.vec);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, LineVec instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.vec != default(Vector4))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.Serialize(stream, instance.vec);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LinePointList : IDisposable, IPooled, IProto<LinePointList>, IProto
{
	[NonSerialized]
	public Vector4 a;

	[NonSerialized]
	public Vector4 b;

	[NonSerialized]
	public Vector4 c;

	[NonSerialized]
	public Vector4 d;

	[NonSerialized]
	public Vector4 e;

	[NonSerialized]
	public Vector4 f;

	[NonSerialized]
	public Vector4 g;

	[NonSerialized]
	public Vector4 h;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LinePointList instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.a = default(Vector4);
			instance.b = default(Vector4);
			instance.c = default(Vector4);
			instance.d = default(Vector4);
			instance.e = default(Vector4);
			instance.f = default(Vector4);
			instance.g = default(Vector4);
			instance.h = default(Vector4);
			Pool.Free<LinePointList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LinePointList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LinePointList instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.a = a;
		instance.b = b;
		instance.c = c;
		instance.d = d;
		instance.e = e;
		instance.f = f;
		instance.g = g;
		instance.h = h;
	}

	public LinePointList Copy()
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		CopyTo(linePointList);
		return linePointList;
	}

	public static LinePointList Deserialize(BufferStream stream)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		Deserialize(stream, linePointList, isDelta: false);
		return linePointList;
	}

	public static LinePointList DeserializeLengthDelimited(BufferStream stream)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		DeserializeLengthDelimited(stream, linePointList, isDelta: false);
		return linePointList;
	}

	public static LinePointList DeserializeLength(BufferStream stream, int length)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		DeserializeLength(stream, length, linePointList, isDelta: false);
		return linePointList;
	}

	public static LinePointList Deserialize(byte[] buffer)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, linePointList, isDelta: false);
		return linePointList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LinePointList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LinePointList Deserialize(BufferStream stream, LinePointList instance, bool isDelta)
	{
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
				continue;
			case 18:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
				continue;
			case 34:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
				continue;
			case 42:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
				continue;
			case 50:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
				continue;
			case 58:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LinePointList DeserializeLengthDelimited(BufferStream stream, LinePointList instance, bool isDelta)
	{
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
				continue;
			case 18:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
				continue;
			case 34:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
				continue;
			case 42:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
				continue;
			case 50:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
				continue;
			case 58:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LinePointList DeserializeLength(BufferStream stream, int length, LinePointList instance, bool isDelta)
	{
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
				continue;
			case 18:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
				continue;
			case 34:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
				continue;
			case 42:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
				continue;
			case 50:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
				continue;
			case 58:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LinePointList instance, LinePointList previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.a != previous.a)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.a, previous.a);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.b != previous.b)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.b, previous.b);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.c != previous.c)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.c, previous.c);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.d != previous.d)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.d, previous.d);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.e != previous.e)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.e, previous.e);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.f != previous.f)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.f, previous.f);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.g != previous.g)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.g, previous.g);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.h != previous.h)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.h, previous.h);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
	}

	public static void Serialize(BufferStream stream, LinePointList instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		if (instance.a != default(Vector4))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.Serialize(stream, instance.a);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.b != default(Vector4))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.b);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.c != default(Vector4))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.c);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.d != default(Vector4))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.d);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.e != default(Vector4))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.e);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.f != default(Vector4))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.f);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.g != default(Vector4))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.g);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.h != default(Vector4))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.h);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PlayerStoredVehicle : IDisposable, IPooled, IProto<PlayerStoredVehicle>, IProto
{
	[NonSerialized]
	public string shortname;

	[NonSerialized]
	public string resourcePath;

	[NonSerialized]
	public float health;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerStoredVehicle instance)
	{
		if (instance.ShouldPool)
		{
			instance.shortname = string.Empty;
			instance.resourcePath = string.Empty;
			instance.health = 0f;
			Pool.Free<PlayerStoredVehicle>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerStoredVehicle with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerStoredVehicle instance)
	{
		instance.shortname = shortname;
		instance.resourcePath = resourcePath;
		instance.health = health;
	}

	public PlayerStoredVehicle Copy()
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		CopyTo(playerStoredVehicle);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle Deserialize(BufferStream stream)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		Deserialize(stream, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		DeserializeLengthDelimited(stream, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		DeserializeLength(stream, length, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle Deserialize(byte[] buffer)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerStoredVehicle previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerStoredVehicle Deserialize(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.shortname = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.resourcePath = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shortname = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.resourcePath = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length, PlayerStoredVehicle instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shortname = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.resourcePath = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerStoredVehicle instance, PlayerStoredVehicle previous)
	{
		if (instance.shortname != null && instance.shortname != previous.shortname)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.shortname);
		}
		if (instance.resourcePath != null && instance.resourcePath != previous.resourcePath)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.resourcePath);
		}
		if (instance.health != previous.health)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
	}

	public static void Serialize(BufferStream stream, PlayerStoredVehicle instance)
	{
		if (instance.shortname != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.shortname);
		}
		if (instance.resourcePath != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.resourcePath);
		}
		if (instance.health != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Result : IDisposable, IPooled, IProto<Result>, IProto
{
	[NonSerialized]
	public ulong ID;

	[NonSerialized]
	public int winnings;

	[NonSerialized]
	public int resultCode;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Result instance)
	{
		if (instance.ShouldPool)
		{
			instance.ID = 0uL;
			instance.winnings = 0;
			instance.resultCode = 0;
			Pool.Free<Result>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Result with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Result instance)
	{
		instance.ID = ID;
		instance.winnings = winnings;
		instance.resultCode = resultCode;
	}

	public Result Copy()
	{
		Result result = Pool.Get<Result>();
		CopyTo(result);
		return result;
	}

	public static Result Deserialize(BufferStream stream)
	{
		Result result = Pool.Get<Result>();
		Deserialize(stream, result, isDelta: false);
		return result;
	}

	public static Result DeserializeLengthDelimited(BufferStream stream)
	{
		Result result = Pool.Get<Result>();
		DeserializeLengthDelimited(stream, result, isDelta: false);
		return result;
	}

	public static Result DeserializeLength(BufferStream stream, int length)
	{
		Result result = Pool.Get<Result>();
		DeserializeLength(stream, length, result, isDelta: false);
		return result;
	}

	public static Result Deserialize(byte[] buffer)
	{
		Result result = Pool.Get<Result>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, result, isDelta: false);
		return result;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Result previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Result Deserialize(BufferStream stream, Result instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.ID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Result DeserializeLengthDelimited(BufferStream stream, Result instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Result DeserializeLength(BufferStream stream, int length, Result instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Result instance, Result previous)
	{
		if (instance.ID != previous.ID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.ID);
		}
		if (instance.winnings != previous.winnings)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
		}
		if (instance.resultCode != previous.resultCode)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
		}
	}

	public static void Serialize(BufferStream stream, Result instance)
	{
		if (instance.ID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.ID);
		}
		if (instance.winnings != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
		}
		if (instance.resultCode != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum RespawnType
{
	SleepingBag = 1,
	Bed,
	BeachTowel,
	Camper,
	Static
}


public enum RespawnState
{
	OK = 1,
	Occupied,
	Underwater,
	InNoRespawnZone
}


