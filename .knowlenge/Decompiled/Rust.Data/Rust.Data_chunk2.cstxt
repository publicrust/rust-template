using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseProjectile : IDisposable, IPooled, IProto<BaseProjectile>, IProto
{
	[NonSerialized]
	public Magazine primaryMagazine;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseProjectile instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.primaryMagazine != null)
			{
				instance.primaryMagazine.ResetToPool();
				instance.primaryMagazine = null;
			}
			Pool.Free<BaseProjectile>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseProjectile with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseProjectile instance)
	{
		if (primaryMagazine != null)
		{
			if (instance.primaryMagazine == null)
			{
				instance.primaryMagazine = primaryMagazine.Copy();
			}
			else
			{
				primaryMagazine.CopyTo(instance.primaryMagazine);
			}
		}
		else
		{
			instance.primaryMagazine = null;
		}
	}

	public BaseProjectile Copy()
	{
		BaseProjectile baseProjectile = Pool.Get<BaseProjectile>();
		CopyTo(baseProjectile);
		return baseProjectile;
	}

	public static BaseProjectile Deserialize(BufferStream stream)
	{
		BaseProjectile baseProjectile = Pool.Get<BaseProjectile>();
		Deserialize(stream, baseProjectile, isDelta: false);
		return baseProjectile;
	}

	public static BaseProjectile DeserializeLengthDelimited(BufferStream stream)
	{
		BaseProjectile baseProjectile = Pool.Get<BaseProjectile>();
		DeserializeLengthDelimited(stream, baseProjectile, isDelta: false);
		return baseProjectile;
	}

	public static BaseProjectile DeserializeLength(BufferStream stream, int length)
	{
		BaseProjectile baseProjectile = Pool.Get<BaseProjectile>();
		DeserializeLength(stream, length, baseProjectile, isDelta: false);
		return baseProjectile;
	}

	public static BaseProjectile Deserialize(byte[] buffer)
	{
		BaseProjectile baseProjectile = Pool.Get<BaseProjectile>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseProjectile, isDelta: false);
		return baseProjectile;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseProjectile previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseProjectile Deserialize(BufferStream stream, BaseProjectile instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.primaryMagazine == null)
				{
					instance.primaryMagazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.primaryMagazine, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static BaseProjectile DeserializeLengthDelimited(BufferStream stream, BaseProjectile instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.primaryMagazine == null)
				{
					instance.primaryMagazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.primaryMagazine, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseProjectile DeserializeLength(BufferStream stream, int length, BaseProjectile instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.primaryMagazine == null)
				{
					instance.primaryMagazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.primaryMagazine, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseProjectile instance, BaseProjectile previous)
	{
		if (instance.primaryMagazine != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Magazine.SerializeDelta(stream, instance.primaryMagazine, previous.primaryMagazine);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field primaryMagazine (ProtoBuf.Magazine)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, BaseProjectile instance)
	{
		if (instance.primaryMagazine != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Magazine.Serialize(stream, instance.primaryMagazine);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field primaryMagazine (ProtoBuf.Magazine)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		primaryMagazine?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Sign : IDisposable, IPooled, IProto<Sign>, IProto
{
	[NonSerialized]
	public uint imageid;

	[NonSerialized]
	public List<uint> imageIds;

	[NonSerialized]
	public List<ulong> editHistory;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Sign instance)
	{
		if (instance.ShouldPool)
		{
			instance.imageid = 0u;
			if (instance.imageIds != null)
			{
				List<uint> list = instance.imageIds;
				Pool.FreeUnmanaged<uint>(ref list);
				instance.imageIds = list;
			}
			if (instance.editHistory != null)
			{
				List<ulong> list2 = instance.editHistory;
				Pool.FreeUnmanaged<ulong>(ref list2);
				instance.editHistory = list2;
			}
			Pool.Free<Sign>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Sign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Sign instance)
	{
		instance.imageid = imageid;
		if (imageIds != null)
		{
			instance.imageIds = Pool.Get<List<uint>>();
			for (int i = 0; i < imageIds.Count; i++)
			{
				uint item = imageIds[i];
				instance.imageIds.Add(item);
			}
		}
		else
		{
			instance.imageIds = null;
		}
		if (editHistory != null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
			for (int j = 0; j < editHistory.Count; j++)
			{
				ulong item2 = editHistory[j];
				instance.editHistory.Add(item2);
			}
		}
		else
		{
			instance.editHistory = null;
		}
	}

	public Sign Copy()
	{
		Sign sign = Pool.Get<Sign>();
		CopyTo(sign);
		return sign;
	}

	public static Sign Deserialize(BufferStream stream)
	{
		Sign sign = Pool.Get<Sign>();
		Deserialize(stream, sign, isDelta: false);
		return sign;
	}

	public static Sign DeserializeLengthDelimited(BufferStream stream)
	{
		Sign sign = Pool.Get<Sign>();
		DeserializeLengthDelimited(stream, sign, isDelta: false);
		return sign;
	}

	public static Sign DeserializeLength(BufferStream stream, int length)
	{
		Sign sign = Pool.Get<Sign>();
		DeserializeLength(stream, length, sign, isDelta: false);
		return sign;
	}

	public static Sign Deserialize(byte[] buffer)
	{
		Sign sign = Pool.Get<Sign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sign, isDelta: false);
		return sign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Sign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Sign Deserialize(BufferStream stream, Sign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.imageIds == null)
			{
				instance.imageIds = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 24:
				instance.imageid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.imageIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 40:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Sign DeserializeLengthDelimited(BufferStream stream, Sign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.imageIds == null)
			{
				instance.imageIds = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.imageid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.imageIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 40:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Sign DeserializeLength(BufferStream stream, int length, Sign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.imageIds == null)
			{
				instance.imageIds = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.imageid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.imageIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 40:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Sign instance, Sign previous)
	{
		if (instance.imageid != previous.imageid)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.imageid);
		}
		if (instance.imageIds != null)
		{
			for (int i = 0; i < instance.imageIds.Count; i++)
			{
				uint val = instance.imageIds[i];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.editHistory != null)
		{
			for (int j = 0; j < instance.editHistory.Count; j++)
			{
				ulong val2 = instance.editHistory[j];
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public static void Serialize(BufferStream stream, Sign instance)
	{
		if (instance.imageid != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.imageid);
		}
		if (instance.imageIds != null)
		{
			for (int i = 0; i < instance.imageIds.Count; i++)
			{
				uint val = instance.imageIds[i];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.editHistory != null)
		{
			for (int j = 0; j < instance.editHistory.Count; j++)
			{
				ulong val2 = instance.editHistory[j];
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MapEntity : IDisposable, IPooled, IProto<MapEntity>, IProto
{
	[NonSerialized]
	public List<uint> fogImages;

	[NonSerialized]
	public List<uint> paintImages;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MapEntity instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.fogImages != null)
			{
				List<uint> list = instance.fogImages;
				Pool.FreeUnmanaged<uint>(ref list);
				instance.fogImages = list;
			}
			if (instance.paintImages != null)
			{
				List<uint> list2 = instance.paintImages;
				Pool.FreeUnmanaged<uint>(ref list2);
				instance.paintImages = list2;
			}
			Pool.Free<MapEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MapEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MapEntity instance)
	{
		if (fogImages != null)
		{
			instance.fogImages = Pool.Get<List<uint>>();
			for (int i = 0; i < fogImages.Count; i++)
			{
				uint item = fogImages[i];
				instance.fogImages.Add(item);
			}
		}
		else
		{
			instance.fogImages = null;
		}
		if (paintImages != null)
		{
			instance.paintImages = Pool.Get<List<uint>>();
			for (int j = 0; j < paintImages.Count; j++)
			{
				uint item2 = paintImages[j];
				instance.paintImages.Add(item2);
			}
		}
		else
		{
			instance.paintImages = null;
		}
	}

	public MapEntity Copy()
	{
		MapEntity mapEntity = Pool.Get<MapEntity>();
		CopyTo(mapEntity);
		return mapEntity;
	}

	public static MapEntity Deserialize(BufferStream stream)
	{
		MapEntity mapEntity = Pool.Get<MapEntity>();
		Deserialize(stream, mapEntity, isDelta: false);
		return mapEntity;
	}

	public static MapEntity DeserializeLengthDelimited(BufferStream stream)
	{
		MapEntity mapEntity = Pool.Get<MapEntity>();
		DeserializeLengthDelimited(stream, mapEntity, isDelta: false);
		return mapEntity;
	}

	public static MapEntity DeserializeLength(BufferStream stream, int length)
	{
		MapEntity mapEntity = Pool.Get<MapEntity>();
		DeserializeLength(stream, length, mapEntity, isDelta: false);
		return mapEntity;
	}

	public static MapEntity Deserialize(byte[] buffer)
	{
		MapEntity mapEntity = Pool.Get<MapEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mapEntity, isDelta: false);
		return mapEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MapEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MapEntity Deserialize(BufferStream stream, MapEntity instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.fogImages == null)
			{
				instance.fogImages = Pool.Get<List<uint>>();
			}
			if (instance.paintImages == null)
			{
				instance.paintImages = Pool.Get<List<uint>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.fogImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.paintImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MapEntity DeserializeLengthDelimited(BufferStream stream, MapEntity instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.fogImages == null)
			{
				instance.fogImages = Pool.Get<List<uint>>();
			}
			if (instance.paintImages == null)
			{
				instance.paintImages = Pool.Get<List<uint>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fogImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.paintImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MapEntity DeserializeLength(BufferStream stream, int length, MapEntity instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.fogImages == null)
			{
				instance.fogImages = Pool.Get<List<uint>>();
			}
			if (instance.paintImages == null)
			{
				instance.paintImages = Pool.Get<List<uint>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fogImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.paintImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MapEntity instance, MapEntity previous)
	{
		if (instance.fogImages != null)
		{
			for (int i = 0; i < instance.fogImages.Count; i++)
			{
				uint val = instance.fogImages[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.paintImages != null)
		{
			for (int j = 0; j < instance.paintImages.Count; j++)
			{
				uint val2 = instance.paintImages[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt32(stream, val2);
			}
		}
	}

	public static void Serialize(BufferStream stream, MapEntity instance)
	{
		if (instance.fogImages != null)
		{
			for (int i = 0; i < instance.fogImages.Count; i++)
			{
				uint val = instance.fogImages[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.paintImages != null)
		{
			for (int j = 0; j < instance.paintImages.Count; j++)
			{
				uint val2 = instance.paintImages[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt32(stream, val2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ResearchTable : IDisposable, IPooled, IProto<ResearchTable>, IProto
{
	[NonSerialized]
	public float researchTimeLeft;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ResearchTable instance)
	{
		if (instance.ShouldPool)
		{
			instance.researchTimeLeft = 0f;
			Pool.Free<ResearchTable>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ResearchTable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ResearchTable instance)
	{
		instance.researchTimeLeft = researchTimeLeft;
	}

	public ResearchTable Copy()
	{
		ResearchTable researchTable = Pool.Get<ResearchTable>();
		CopyTo(researchTable);
		return researchTable;
	}

	public static ResearchTable Deserialize(BufferStream stream)
	{
		ResearchTable researchTable = Pool.Get<ResearchTable>();
		Deserialize(stream, researchTable, isDelta: false);
		return researchTable;
	}

	public static ResearchTable DeserializeLengthDelimited(BufferStream stream)
	{
		ResearchTable researchTable = Pool.Get<ResearchTable>();
		DeserializeLengthDelimited(stream, researchTable, isDelta: false);
		return researchTable;
	}

	public static ResearchTable DeserializeLength(BufferStream stream, int length)
	{
		ResearchTable researchTable = Pool.Get<ResearchTable>();
		DeserializeLength(stream, length, researchTable, isDelta: false);
		return researchTable;
	}

	public static ResearchTable Deserialize(byte[] buffer)
	{
		ResearchTable researchTable = Pool.Get<ResearchTable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, researchTable, isDelta: false);
		return researchTable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ResearchTable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ResearchTable Deserialize(BufferStream stream, ResearchTable instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.researchTimeLeft = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ResearchTable DeserializeLengthDelimited(BufferStream stream, ResearchTable instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.researchTimeLeft = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ResearchTable DeserializeLength(BufferStream stream, int length, ResearchTable instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.researchTimeLeft = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ResearchTable instance, ResearchTable previous)
	{
		if (instance.researchTimeLeft != previous.researchTimeLeft)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.researchTimeLeft);
		}
	}

	public static void Serialize(BufferStream stream, ResearchTable instance)
	{
		if (instance.researchTimeLeft != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.researchTimeLeft);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DudExplosive : IDisposable, IPooled, IProto<DudExplosive>, IProto
{
	[NonSerialized]
	public float fuseTimeLeft;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DudExplosive instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuseTimeLeft = 0f;
			Pool.Free<DudExplosive>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DudExplosive with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DudExplosive instance)
	{
		instance.fuseTimeLeft = fuseTimeLeft;
	}

	public DudExplosive Copy()
	{
		DudExplosive dudExplosive = Pool.Get<DudExplosive>();
		CopyTo(dudExplosive);
		return dudExplosive;
	}

	public static DudExplosive Deserialize(BufferStream stream)
	{
		DudExplosive dudExplosive = Pool.Get<DudExplosive>();
		Deserialize(stream, dudExplosive, isDelta: false);
		return dudExplosive;
	}

	public static DudExplosive DeserializeLengthDelimited(BufferStream stream)
	{
		DudExplosive dudExplosive = Pool.Get<DudExplosive>();
		DeserializeLengthDelimited(stream, dudExplosive, isDelta: false);
		return dudExplosive;
	}

	public static DudExplosive DeserializeLength(BufferStream stream, int length)
	{
		DudExplosive dudExplosive = Pool.Get<DudExplosive>();
		DeserializeLength(stream, length, dudExplosive, isDelta: false);
		return dudExplosive;
	}

	public static DudExplosive Deserialize(byte[] buffer)
	{
		DudExplosive dudExplosive = Pool.Get<DudExplosive>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, dudExplosive, isDelta: false);
		return dudExplosive;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DudExplosive previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DudExplosive Deserialize(BufferStream stream, DudExplosive instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.fuseTimeLeft = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DudExplosive DeserializeLengthDelimited(BufferStream stream, DudExplosive instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fuseTimeLeft = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DudExplosive DeserializeLength(BufferStream stream, int length, DudExplosive instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fuseTimeLeft = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DudExplosive instance, DudExplosive previous)
	{
		if (instance.fuseTimeLeft != previous.fuseTimeLeft)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fuseTimeLeft);
		}
	}

	public static void Serialize(BufferStream stream, DudExplosive instance)
	{
		if (instance.fuseTimeLeft != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fuseTimeLeft);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ResourceExtractor : IDisposable, IPooled, IProto<ResourceExtractor>, IProto
{
	[NonSerialized]
	public ItemContainer fuelContents;

	[NonSerialized]
	public ItemContainer outputContents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ResourceExtractor instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.fuelContents != null)
			{
				instance.fuelContents.ResetToPool();
				instance.fuelContents = null;
			}
			if (instance.outputContents != null)
			{
				instance.outputContents.ResetToPool();
				instance.outputContents = null;
			}
			Pool.Free<ResourceExtractor>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ResourceExtractor with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ResourceExtractor instance)
	{
		if (fuelContents != null)
		{
			if (instance.fuelContents == null)
			{
				instance.fuelContents = fuelContents.Copy();
			}
			else
			{
				fuelContents.CopyTo(instance.fuelContents);
			}
		}
		else
		{
			instance.fuelContents = null;
		}
		if (outputContents != null)
		{
			if (instance.outputContents == null)
			{
				instance.outputContents = outputContents.Copy();
			}
			else
			{
				outputContents.CopyTo(instance.outputContents);
			}
		}
		else
		{
			instance.outputContents = null;
		}
	}

	public ResourceExtractor Copy()
	{
		ResourceExtractor resourceExtractor = Pool.Get<ResourceExtractor>();
		CopyTo(resourceExtractor);
		return resourceExtractor;
	}

	public static ResourceExtractor Deserialize(BufferStream stream)
	{
		ResourceExtractor resourceExtractor = Pool.Get<ResourceExtractor>();
		Deserialize(stream, resourceExtractor, isDelta: false);
		return resourceExtractor;
	}

	public static ResourceExtractor DeserializeLengthDelimited(BufferStream stream)
	{
		ResourceExtractor resourceExtractor = Pool.Get<ResourceExtractor>();
		DeserializeLengthDelimited(stream, resourceExtractor, isDelta: false);
		return resourceExtractor;
	}

	public static ResourceExtractor DeserializeLength(BufferStream stream, int length)
	{
		ResourceExtractor resourceExtractor = Pool.Get<ResourceExtractor>();
		DeserializeLength(stream, length, resourceExtractor, isDelta: false);
		return resourceExtractor;
	}

	public static ResourceExtractor Deserialize(byte[] buffer)
	{
		ResourceExtractor resourceExtractor = Pool.Get<ResourceExtractor>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, resourceExtractor, isDelta: false);
		return resourceExtractor;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ResourceExtractor previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ResourceExtractor Deserialize(BufferStream stream, ResourceExtractor instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.fuelContents == null)
				{
					instance.fuelContents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.fuelContents, isDelta);
				}
				break;
			case 18:
				if (instance.outputContents == null)
				{
					instance.outputContents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.outputContents, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static ResourceExtractor DeserializeLengthDelimited(BufferStream stream, ResourceExtractor instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.fuelContents == null)
				{
					instance.fuelContents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.fuelContents, isDelta);
				}
				break;
			case 18:
				if (instance.outputContents == null)
				{
					instance.outputContents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.outputContents, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ResourceExtractor DeserializeLength(BufferStream stream, int length, ResourceExtractor instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.fuelContents == null)
				{
					instance.fuelContents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.fuelContents, isDelta);
				}
				break;
			case 18:
				if (instance.outputContents == null)
				{
					instance.outputContents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.outputContents, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ResourceExtractor instance, ResourceExtractor previous)
	{
		if (instance.fuelContents != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.fuelContents, previous.fuelContents);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.outputContents == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.outputContents, previous.outputContents);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, ResourceExtractor instance)
	{
		if (instance.fuelContents != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance.fuelContents);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.outputContents == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		ItemContainer.Serialize(stream, instance.outputContents);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		fuelContents?.InspectUids(action);
		outputContents?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MiningQuarry : IDisposable, IPooled, IProto<MiningQuarry>, IProto
{
	[NonSerialized]
	public ResourceExtractor extractor;

	[NonSerialized]
	public int staticType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MiningQuarry instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.extractor != null)
			{
				instance.extractor.ResetToPool();
				instance.extractor = null;
			}
			instance.staticType = 0;
			Pool.Free<MiningQuarry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MiningQuarry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MiningQuarry instance)
	{
		if (extractor != null)
		{
			if (instance.extractor == null)
			{
				instance.extractor = extractor.Copy();
			}
			else
			{
				extractor.CopyTo(instance.extractor);
			}
		}
		else
		{
			instance.extractor = null;
		}
		instance.staticType = staticType;
	}

	public MiningQuarry Copy()
	{
		MiningQuarry miningQuarry = Pool.Get<MiningQuarry>();
		CopyTo(miningQuarry);
		return miningQuarry;
	}

	public static MiningQuarry Deserialize(BufferStream stream)
	{
		MiningQuarry miningQuarry = Pool.Get<MiningQuarry>();
		Deserialize(stream, miningQuarry, isDelta: false);
		return miningQuarry;
	}

	public static MiningQuarry DeserializeLengthDelimited(BufferStream stream)
	{
		MiningQuarry miningQuarry = Pool.Get<MiningQuarry>();
		DeserializeLengthDelimited(stream, miningQuarry, isDelta: false);
		return miningQuarry;
	}

	public static MiningQuarry DeserializeLength(BufferStream stream, int length)
	{
		MiningQuarry miningQuarry = Pool.Get<MiningQuarry>();
		DeserializeLength(stream, length, miningQuarry, isDelta: false);
		return miningQuarry;
	}

	public static MiningQuarry Deserialize(byte[] buffer)
	{
		MiningQuarry miningQuarry = Pool.Get<MiningQuarry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, miningQuarry, isDelta: false);
		return miningQuarry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MiningQuarry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MiningQuarry Deserialize(BufferStream stream, MiningQuarry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.extractor == null)
				{
					instance.extractor = ResourceExtractor.DeserializeLengthDelimited(stream);
				}
				else
				{
					ResourceExtractor.DeserializeLengthDelimited(stream, instance.extractor, isDelta);
				}
				break;
			case 16:
				instance.staticType = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static MiningQuarry DeserializeLengthDelimited(BufferStream stream, MiningQuarry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.extractor == null)
				{
					instance.extractor = ResourceExtractor.DeserializeLengthDelimited(stream);
				}
				else
				{
					ResourceExtractor.DeserializeLengthDelimited(stream, instance.extractor, isDelta);
				}
				break;
			case 16:
				instance.staticType = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MiningQuarry DeserializeLength(BufferStream stream, int length, MiningQuarry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.extractor == null)
				{
					instance.extractor = ResourceExtractor.DeserializeLengthDelimited(stream);
				}
				else
				{
					ResourceExtractor.DeserializeLengthDelimited(stream, instance.extractor, isDelta);
				}
				break;
			case 16:
				instance.staticType = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MiningQuarry instance, MiningQuarry previous)
	{
		if (instance.extractor != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ResourceExtractor.SerializeDelta(stream, instance.extractor, previous.extractor);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.staticType != previous.staticType)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.staticType);
		}
	}

	public static void Serialize(BufferStream stream, MiningQuarry instance)
	{
		if (instance.extractor != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ResourceExtractor.Serialize(stream, instance.extractor);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.staticType != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.staticType);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		extractor?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class GrowableEntity : IDisposable, IPooled, IProto<GrowableEntity>, IProto
{
	[NonSerialized]
	public int state;

	[NonSerialized]
	public float age;

	[NonSerialized]
	public int water;

	[NonSerialized]
	public float healthy;

	[NonSerialized]
	public float totalAge;

	[NonSerialized]
	public float growthAge;

	[NonSerialized]
	public float yieldFraction;

	[NonSerialized]
	public float stageAge;

	[NonSerialized]
	public int genes;

	[NonSerialized]
	public float lightModifier;

	[NonSerialized]
	public float waterModifier;

	[NonSerialized]
	public float groundModifier;

	[NonSerialized]
	public float happiness;

	[NonSerialized]
	public float temperatureModifier;

	[NonSerialized]
	public float waterConsumption;

	[NonSerialized]
	public float yieldPool;

	[NonSerialized]
	public bool fertilized;

	[NonSerialized]
	public int previousGenes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(GrowableEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.state = 0;
			instance.age = 0f;
			instance.water = 0;
			instance.healthy = 0f;
			instance.totalAge = 0f;
			instance.growthAge = 0f;
			instance.yieldFraction = 0f;
			instance.stageAge = 0f;
			instance.genes = 0;
			instance.lightModifier = 0f;
			instance.waterModifier = 0f;
			instance.groundModifier = 0f;
			instance.happiness = 0f;
			instance.temperatureModifier = 0f;
			instance.waterConsumption = 0f;
			instance.yieldPool = 0f;
			instance.fertilized = false;
			instance.previousGenes = 0;
			Pool.Free<GrowableEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose GrowableEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(GrowableEntity instance)
	{
		instance.state = state;
		instance.age = age;
		instance.water = water;
		instance.healthy = healthy;
		instance.totalAge = totalAge;
		instance.growthAge = growthAge;
		instance.yieldFraction = yieldFraction;
		instance.stageAge = stageAge;
		instance.genes = genes;
		instance.lightModifier = lightModifier;
		instance.waterModifier = waterModifier;
		instance.groundModifier = groundModifier;
		instance.happiness = happiness;
		instance.temperatureModifier = temperatureModifier;
		instance.waterConsumption = waterConsumption;
		instance.yieldPool = yieldPool;
		instance.fertilized = fertilized;
		instance.previousGenes = previousGenes;
	}

	public GrowableEntity Copy()
	{
		GrowableEntity growableEntity = Pool.Get<GrowableEntity>();
		CopyTo(growableEntity);
		return growableEntity;
	}

	public static GrowableEntity Deserialize(BufferStream stream)
	{
		GrowableEntity growableEntity = Pool.Get<GrowableEntity>();
		Deserialize(stream, growableEntity, isDelta: false);
		return growableEntity;
	}

	public static GrowableEntity DeserializeLengthDelimited(BufferStream stream)
	{
		GrowableEntity growableEntity = Pool.Get<GrowableEntity>();
		DeserializeLengthDelimited(stream, growableEntity, isDelta: false);
		return growableEntity;
	}

	public static GrowableEntity DeserializeLength(BufferStream stream, int length)
	{
		GrowableEntity growableEntity = Pool.Get<GrowableEntity>();
		DeserializeLength(stream, length, growableEntity, isDelta: false);
		return growableEntity;
	}

	public static GrowableEntity Deserialize(byte[] buffer)
	{
		GrowableEntity growableEntity = Pool.Get<GrowableEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, growableEntity, isDelta: false);
		return growableEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, GrowableEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static GrowableEntity Deserialize(BufferStream stream, GrowableEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.age = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.water = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.healthy = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.totalAge = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.growthAge = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.yieldFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.stageAge = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.genes = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 85:
				instance.lightModifier = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.waterModifier = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.groundModifier = ProtocolParser.ReadSingle(stream);
				continue;
			case 109:
				instance.happiness = ProtocolParser.ReadSingle(stream);
				continue;
			case 117:
				instance.temperatureModifier = ProtocolParser.ReadSingle(stream);
				continue;
			case 125:
				instance.waterConsumption = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.yieldPool = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.fertilized = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.Varint)
				{
					instance.previousGenes = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static GrowableEntity DeserializeLengthDelimited(BufferStream stream, GrowableEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.age = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.water = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.healthy = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.totalAge = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.growthAge = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.yieldFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.stageAge = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.genes = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 85:
				instance.lightModifier = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.waterModifier = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.groundModifier = ProtocolParser.ReadSingle(stream);
				continue;
			case 109:
				instance.happiness = ProtocolParser.ReadSingle(stream);
				continue;
			case 117:
				instance.temperatureModifier = ProtocolParser.ReadSingle(stream);
				continue;
			case 125:
				instance.waterConsumption = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.yieldPool = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.fertilized = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.Varint)
				{
					instance.previousGenes = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static GrowableEntity DeserializeLength(BufferStream stream, int length, GrowableEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.age = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.water = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.healthy = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.totalAge = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.growthAge = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.yieldFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.stageAge = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.genes = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 85:
				instance.lightModifier = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.waterModifier = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.groundModifier = ProtocolParser.ReadSingle(stream);
				continue;
			case 109:
				instance.happiness = ProtocolParser.ReadSingle(stream);
				continue;
			case 117:
				instance.temperatureModifier = ProtocolParser.ReadSingle(stream);
				continue;
			case 125:
				instance.waterConsumption = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.yieldPool = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.fertilized = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.Varint)
				{
					instance.previousGenes = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, GrowableEntity instance, GrowableEntity previous)
	{
		if (instance.state != previous.state)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.age != previous.age)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.age);
		}
		if (instance.water != previous.water)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.water);
		}
		if (instance.healthy != previous.healthy)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.healthy);
		}
		if (instance.totalAge != previous.totalAge)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.totalAge);
		}
		if (instance.growthAge != previous.growthAge)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.growthAge);
		}
		if (instance.yieldFraction != previous.yieldFraction)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.yieldFraction);
		}
		if (instance.stageAge != previous.stageAge)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.stageAge);
		}
		if (instance.genes != previous.genes)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genes);
		}
		if (instance.lightModifier != previous.lightModifier)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.lightModifier);
		}
		if (instance.waterModifier != previous.waterModifier)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.waterModifier);
		}
		if (instance.groundModifier != previous.groundModifier)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.groundModifier);
		}
		if (instance.happiness != previous.happiness)
		{
			stream.WriteByte(109);
			ProtocolParser.WriteSingle(stream, instance.happiness);
		}
		if (instance.temperatureModifier != previous.temperatureModifier)
		{
			stream.WriteByte(117);
			ProtocolParser.WriteSingle(stream, instance.temperatureModifier);
		}
		if (instance.waterConsumption != previous.waterConsumption)
		{
			stream.WriteByte(125);
			ProtocolParser.WriteSingle(stream, instance.waterConsumption);
		}
		if (instance.yieldPool != previous.yieldPool)
		{
			stream.WriteByte(133);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.yieldPool);
		}
		stream.WriteByte(136);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.fertilized);
		if (instance.previousGenes != previous.previousGenes)
		{
			stream.WriteByte(144);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.previousGenes);
		}
	}

	public static void Serialize(BufferStream stream, GrowableEntity instance)
	{
		if (instance.state != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.age != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.age);
		}
		if (instance.water != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.water);
		}
		if (instance.healthy != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.healthy);
		}
		if (instance.totalAge != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.totalAge);
		}
		if (instance.growthAge != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.growthAge);
		}
		if (instance.yieldFraction != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.yieldFraction);
		}
		if (instance.stageAge != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.stageAge);
		}
		if (instance.genes != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genes);
		}
		if (instance.lightModifier != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.lightModifier);
		}
		if (instance.waterModifier != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.waterModifier);
		}
		if (instance.groundModifier != 0f)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.groundModifier);
		}
		if (instance.happiness != 0f)
		{
			stream.WriteByte(109);
			ProtocolParser.WriteSingle(stream, instance.happiness);
		}
		if (instance.temperatureModifier != 0f)
		{
			stream.WriteByte(117);
			ProtocolParser.WriteSingle(stream, instance.temperatureModifier);
		}
		if (instance.waterConsumption != 0f)
		{
			stream.WriteByte(125);
			ProtocolParser.WriteSingle(stream, instance.waterConsumption);
		}
		if (instance.yieldPool != 0f)
		{
			stream.WriteByte(133);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.yieldPool);
		}
		if (instance.fertilized)
		{
			stream.WriteByte(136);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.fertilized);
		}
		if (instance.previousGenes != 0)
		{
			stream.WriteByte(144);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.previousGenes);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Landmine : IDisposable, IPooled, IProto<Landmine>, IProto
{
	[NonSerialized]
	public ulong triggeredID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Landmine instance)
	{
		if (instance.ShouldPool)
		{
			instance.triggeredID = 0uL;
			Pool.Free<Landmine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Landmine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Landmine instance)
	{
		instance.triggeredID = triggeredID;
	}

	public Landmine Copy()
	{
		Landmine landmine = Pool.Get<Landmine>();
		CopyTo(landmine);
		return landmine;
	}

	public static Landmine Deserialize(BufferStream stream)
	{
		Landmine landmine = Pool.Get<Landmine>();
		Deserialize(stream, landmine, isDelta: false);
		return landmine;
	}

	public static Landmine DeserializeLengthDelimited(BufferStream stream)
	{
		Landmine landmine = Pool.Get<Landmine>();
		DeserializeLengthDelimited(stream, landmine, isDelta: false);
		return landmine;
	}

	public static Landmine DeserializeLength(BufferStream stream, int length)
	{
		Landmine landmine = Pool.Get<Landmine>();
		DeserializeLength(stream, length, landmine, isDelta: false);
		return landmine;
	}

	public static Landmine Deserialize(byte[] buffer)
	{
		Landmine landmine = Pool.Get<Landmine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, landmine, isDelta: false);
		return landmine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Landmine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Landmine Deserialize(BufferStream stream, Landmine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.triggeredID = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Landmine DeserializeLengthDelimited(BufferStream stream, Landmine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.triggeredID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Landmine DeserializeLength(BufferStream stream, int length, Landmine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.triggeredID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Landmine instance, Landmine previous)
	{
		if (instance.triggeredID != previous.triggeredID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.triggeredID);
		}
	}

	public static void Serialize(BufferStream stream, Landmine instance)
	{
		if (instance.triggeredID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.triggeredID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseVehicle : IDisposable, IPooled, IProto<BaseVehicle>, IProto
{
	public class MountPoint : IDisposable, IPooled, IProto<MountPoint>, IProto
	{
		[NonSerialized]
		public int index;

		[NonSerialized]
		public NetworkableId mountableId;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(MountPoint instance)
		{
			if (instance.ShouldPool)
			{
				instance.index = 0;
				instance.mountableId = default(NetworkableId);
				Pool.Free<MountPoint>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose MountPoint with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(MountPoint instance)
		{
			instance.index = index;
			instance.mountableId = mountableId;
		}

		public MountPoint Copy()
		{
			MountPoint mountPoint = Pool.Get<MountPoint>();
			CopyTo(mountPoint);
			return mountPoint;
		}

		public static MountPoint Deserialize(BufferStream stream)
		{
			MountPoint mountPoint = Pool.Get<MountPoint>();
			Deserialize(stream, mountPoint, isDelta: false);
			return mountPoint;
		}

		public static MountPoint DeserializeLengthDelimited(BufferStream stream)
		{
			MountPoint mountPoint = Pool.Get<MountPoint>();
			DeserializeLengthDelimited(stream, mountPoint, isDelta: false);
			return mountPoint;
		}

		public static MountPoint DeserializeLength(BufferStream stream, int length)
		{
			MountPoint mountPoint = Pool.Get<MountPoint>();
			DeserializeLength(stream, length, mountPoint, isDelta: false);
			return mountPoint;
		}

		public static MountPoint Deserialize(byte[] buffer)
		{
			MountPoint mountPoint = Pool.Get<MountPoint>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, mountPoint, isDelta: false);
			return mountPoint;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, MountPoint previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static MountPoint Deserialize(BufferStream stream, MountPoint instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.index = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.mountableId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static MountPoint DeserializeLengthDelimited(BufferStream stream, MountPoint instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.index = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.mountableId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static MountPoint DeserializeLength(BufferStream stream, int length, MountPoint instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.index = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.mountableId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, MountPoint instance, MountPoint previous)
		{
			if (instance.index != previous.index)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
			}
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.mountableId.Value);
		}

		public static void Serialize(BufferStream stream, MountPoint instance)
		{
			if (instance.index != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
			}
			if (instance.mountableId != default(NetworkableId))
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.mountableId.Value);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref mountableId.Value);
		}
	}

	[NonSerialized]
	public List<MountPoint> mountPoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseVehicle instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.mountPoints != null)
		{
			for (int i = 0; i < instance.mountPoints.Count; i++)
			{
				if (instance.mountPoints[i] != null)
				{
					instance.mountPoints[i].ResetToPool();
					instance.mountPoints[i] = null;
				}
			}
			List<MountPoint> list = instance.mountPoints;
			Pool.Free<MountPoint>(ref list, false);
			instance.mountPoints = list;
		}
		Pool.Free<BaseVehicle>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseVehicle with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseVehicle instance)
	{
		if (mountPoints != null)
		{
			instance.mountPoints = Pool.Get<List<MountPoint>>();
			for (int i = 0; i < mountPoints.Count; i++)
			{
				MountPoint item = mountPoints[i].Copy();
				instance.mountPoints.Add(item);
			}
		}
		else
		{
			instance.mountPoints = null;
		}
	}

	public BaseVehicle Copy()
	{
		BaseVehicle baseVehicle = Pool.Get<BaseVehicle>();
		CopyTo(baseVehicle);
		return baseVehicle;
	}

	public static BaseVehicle Deserialize(BufferStream stream)
	{
		BaseVehicle baseVehicle = Pool.Get<BaseVehicle>();
		Deserialize(stream, baseVehicle, isDelta: false);
		return baseVehicle;
	}

	public static BaseVehicle DeserializeLengthDelimited(BufferStream stream)
	{
		BaseVehicle baseVehicle = Pool.Get<BaseVehicle>();
		DeserializeLengthDelimited(stream, baseVehicle, isDelta: false);
		return baseVehicle;
	}

	public static BaseVehicle DeserializeLength(BufferStream stream, int length)
	{
		BaseVehicle baseVehicle = Pool.Get<BaseVehicle>();
		DeserializeLength(stream, length, baseVehicle, isDelta: false);
		return baseVehicle;
	}

	public static BaseVehicle Deserialize(byte[] buffer)
	{
		BaseVehicle baseVehicle = Pool.Get<BaseVehicle>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseVehicle, isDelta: false);
		return baseVehicle;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseVehicle previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseVehicle Deserialize(BufferStream stream, BaseVehicle instance, bool isDelta)
	{
		if (!isDelta && instance.mountPoints == null)
		{
			instance.mountPoints = Pool.Get<List<MountPoint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.mountPoints.Add(MountPoint.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseVehicle DeserializeLengthDelimited(BufferStream stream, BaseVehicle instance, bool isDelta)
	{
		if (!isDelta && instance.mountPoints == null)
		{
			instance.mountPoints = Pool.Get<List<MountPoint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.mountPoints.Add(MountPoint.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseVehicle DeserializeLength(BufferStream stream, int length, BaseVehicle instance, bool isDelta)
	{
		if (!isDelta && instance.mountPoints == null)
		{
			instance.mountPoints = Pool.Get<List<MountPoint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.mountPoints.Add(MountPoint.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseVehicle instance, BaseVehicle previous)
	{
		if (instance.mountPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.mountPoints.Count; i++)
		{
			MountPoint mountPoint = instance.mountPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			MountPoint.SerializeDelta(stream, mountPoint, mountPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mountPoints (ProtoBuf.BaseVehicle.MountPoint)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, BaseVehicle instance)
	{
		if (instance.mountPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.mountPoints.Count; i++)
		{
			MountPoint instance2 = instance.mountPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			MountPoint.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mountPoints (ProtoBuf.BaseVehicle.MountPoint)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (mountPoints != null)
		{
			for (int i = 0; i < mountPoints.Count; i++)
			{
				mountPoints[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Helicopter : IDisposable, IPooled, IProto<Helicopter>, IProto
{
	[NonSerialized]
	public Vector3 tiltRot;

	[NonSerialized]
	public Vector3 leftGun;

	[NonSerialized]
	public Vector3 rightGun;

	[NonSerialized]
	public Vector3 spotlightVec;

	[NonSerialized]
	public List<float> weakspothealths;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Helicopter instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.tiltRot = default(Vector3);
			instance.leftGun = default(Vector3);
			instance.rightGun = default(Vector3);
			instance.spotlightVec = default(Vector3);
			if (instance.weakspothealths != null)
			{
				List<float> list = instance.weakspothealths;
				Pool.FreeUnmanaged<float>(ref list);
				instance.weakspothealths = list;
			}
			Pool.Free<Helicopter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Helicopter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Helicopter instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.tiltRot = tiltRot;
		instance.leftGun = leftGun;
		instance.rightGun = rightGun;
		instance.spotlightVec = spotlightVec;
		if (weakspothealths != null)
		{
			instance.weakspothealths = Pool.Get<List<float>>();
			for (int i = 0; i < weakspothealths.Count; i++)
			{
				float item = weakspothealths[i];
				instance.weakspothealths.Add(item);
			}
		}
		else
		{
			instance.weakspothealths = null;
		}
	}

	public Helicopter Copy()
	{
		Helicopter helicopter = Pool.Get<Helicopter>();
		CopyTo(helicopter);
		return helicopter;
	}

	public static Helicopter Deserialize(BufferStream stream)
	{
		Helicopter helicopter = Pool.Get<Helicopter>();
		Deserialize(stream, helicopter, isDelta: false);
		return helicopter;
	}

	public static Helicopter DeserializeLengthDelimited(BufferStream stream)
	{
		Helicopter helicopter = Pool.Get<Helicopter>();
		DeserializeLengthDelimited(stream, helicopter, isDelta: false);
		return helicopter;
	}

	public static Helicopter DeserializeLength(BufferStream stream, int length)
	{
		Helicopter helicopter = Pool.Get<Helicopter>();
		DeserializeLength(stream, length, helicopter, isDelta: false);
		return helicopter;
	}

	public static Helicopter Deserialize(byte[] buffer)
	{
		Helicopter helicopter = Pool.Get<Helicopter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, helicopter, isDelta: false);
		return helicopter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Helicopter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Helicopter Deserialize(BufferStream stream, Helicopter instance, bool isDelta)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.weakspothealths == null)
		{
			instance.weakspothealths = Pool.Get<List<float>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.tiltRot, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftGun, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightGun, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.spotlightVec, isDelta);
				continue;
			case 45:
				instance.weakspothealths.Add(ProtocolParser.ReadSingle(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Helicopter DeserializeLengthDelimited(BufferStream stream, Helicopter instance, bool isDelta)
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.weakspothealths == null)
		{
			instance.weakspothealths = Pool.Get<List<float>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.tiltRot, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftGun, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightGun, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.spotlightVec, isDelta);
				continue;
			case 45:
				instance.weakspothealths.Add(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Helicopter DeserializeLength(BufferStream stream, int length, Helicopter instance, bool isDelta)
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.weakspothealths == null)
		{
			instance.weakspothealths = Pool.Get<List<float>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.tiltRot, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftGun, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightGun, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.spotlightVec, isDelta);
				continue;
			case 45:
				instance.weakspothealths.Add(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Helicopter instance, Helicopter previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		if (instance.tiltRot != previous.tiltRot)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.tiltRot, previous.tiltRot);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field tiltRot (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.leftGun != previous.leftGun)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.leftGun, previous.leftGun);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field leftGun (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rightGun != previous.rightGun)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rightGun, previous.rightGun);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rightGun (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.spotlightVec != previous.spotlightVec)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.spotlightVec, previous.spotlightVec);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spotlightVec (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.weakspothealths != null)
		{
			for (int i = 0; i < instance.weakspothealths.Count; i++)
			{
				float f = instance.weakspothealths[i];
				stream.WriteByte(45);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public static void Serialize(BufferStream stream, Helicopter instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.tiltRot != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.tiltRot);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field tiltRot (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.leftGun != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.leftGun);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field leftGun (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rightGun != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rightGun);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rightGun (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.spotlightVec != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.spotlightVec);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spotlightVec (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.weakspothealths != null)
		{
			for (int i = 0; i < instance.weakspothealths.Count; i++)
			{
				float f = instance.weakspothealths[i];
				stream.WriteByte(45);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ServerGib : IDisposable, IPooled, IProto<ServerGib>, IProto
{
	[NonSerialized]
	public string gibName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ServerGib instance)
	{
		if (instance.ShouldPool)
		{
			instance.gibName = string.Empty;
			Pool.Free<ServerGib>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ServerGib with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ServerGib instance)
	{
		instance.gibName = gibName;
	}

	public ServerGib Copy()
	{
		ServerGib serverGib = Pool.Get<ServerGib>();
		CopyTo(serverGib);
		return serverGib;
	}

	public static ServerGib Deserialize(BufferStream stream)
	{
		ServerGib serverGib = Pool.Get<ServerGib>();
		Deserialize(stream, serverGib, isDelta: false);
		return serverGib;
	}

	public static ServerGib DeserializeLengthDelimited(BufferStream stream)
	{
		ServerGib serverGib = Pool.Get<ServerGib>();
		DeserializeLengthDelimited(stream, serverGib, isDelta: false);
		return serverGib;
	}

	public static ServerGib DeserializeLength(BufferStream stream, int length)
	{
		ServerGib serverGib = Pool.Get<ServerGib>();
		DeserializeLength(stream, length, serverGib, isDelta: false);
		return serverGib;
	}

	public static ServerGib Deserialize(byte[] buffer)
	{
		ServerGib serverGib = Pool.Get<ServerGib>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, serverGib, isDelta: false);
		return serverGib;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ServerGib previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ServerGib Deserialize(BufferStream stream, ServerGib instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.gibName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ServerGib DeserializeLengthDelimited(BufferStream stream, ServerGib instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.gibName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ServerGib DeserializeLength(BufferStream stream, int length, ServerGib instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.gibName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ServerGib instance, ServerGib previous)
	{
		if (instance.gibName != null && instance.gibName != previous.gibName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.gibName);
		}
	}

	public static void Serialize(BufferStream stream, ServerGib instance)
	{
		if (instance.gibName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.gibName);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class AutoTurret : IDisposable, IPooled, IProto<AutoTurret>, IProto
{
	[NonSerialized]
	public Vector3 aimPos;

	[NonSerialized]
	public Vector3 aimDir;

	[NonSerialized]
	public uint targetID;

	[NonSerialized]
	public List<PlayerNameID> users;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AutoTurret instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.aimPos = default(Vector3);
		instance.aimDir = default(Vector3);
		instance.targetID = 0u;
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				if (instance.users[i] != null)
				{
					instance.users[i].ResetToPool();
					instance.users[i] = null;
				}
			}
			List<PlayerNameID> list = instance.users;
			Pool.Free<PlayerNameID>(ref list, false);
			instance.users = list;
		}
		Pool.Free<AutoTurret>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AutoTurret with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AutoTurret instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.aimPos = aimPos;
		instance.aimDir = aimDir;
		instance.targetID = targetID;
		if (users != null)
		{
			instance.users = Pool.Get<List<PlayerNameID>>();
			for (int i = 0; i < users.Count; i++)
			{
				PlayerNameID item = users[i].Copy();
				instance.users.Add(item);
			}
		}
		else
		{
			instance.users = null;
		}
	}

	public AutoTurret Copy()
	{
		AutoTurret autoTurret = Pool.Get<AutoTurret>();
		CopyTo(autoTurret);
		return autoTurret;
	}

	public static AutoTurret Deserialize(BufferStream stream)
	{
		AutoTurret autoTurret = Pool.Get<AutoTurret>();
		Deserialize(stream, autoTurret, isDelta: false);
		return autoTurret;
	}

	public static AutoTurret DeserializeLengthDelimited(BufferStream stream)
	{
		AutoTurret autoTurret = Pool.Get<AutoTurret>();
		DeserializeLengthDelimited(stream, autoTurret, isDelta: false);
		return autoTurret;
	}

	public static AutoTurret DeserializeLength(BufferStream stream, int length)
	{
		AutoTurret autoTurret = Pool.Get<AutoTurret>();
		DeserializeLength(stream, length, autoTurret, isDelta: false);
		return autoTurret;
	}

	public static AutoTurret Deserialize(byte[] buffer)
	{
		AutoTurret autoTurret = Pool.Get<AutoTurret>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, autoTurret, isDelta: false);
		return autoTurret;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AutoTurret previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AutoTurret Deserialize(BufferStream stream, AutoTurret instance, bool isDelta)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.users == null)
		{
			instance.users = Pool.Get<List<PlayerNameID>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				continue;
			case 24:
				instance.targetID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.users.Add(PlayerNameID.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AutoTurret DeserializeLengthDelimited(BufferStream stream, AutoTurret instance, bool isDelta)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.users == null)
		{
			instance.users = Pool.Get<List<PlayerNameID>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				continue;
			case 24:
				instance.targetID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.users.Add(PlayerNameID.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AutoTurret DeserializeLength(BufferStream stream, int length, AutoTurret instance, bool isDelta)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.users == null)
		{
			instance.users = Pool.Get<List<PlayerNameID>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				continue;
			case 24:
				instance.targetID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.users.Add(PlayerNameID.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AutoTurret instance, AutoTurret previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aimPos != previous.aimPos)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aimPos, previous.aimPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.aimDir != previous.aimDir)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aimDir, previous.aimDir);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.targetID != previous.targetID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.targetID);
		}
		if (instance.users == null)
		{
			return;
		}
		for (int i = 0; i < instance.users.Count; i++)
		{
			PlayerNameID playerNameID = instance.users[i];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			PlayerNameID.SerializeDelta(stream, playerNameID, playerNameID);
			int val = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AutoTurret instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aimPos != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aimPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.aimDir != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aimDir);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.targetID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.targetID);
		}
		if (instance.users == null)
		{
			return;
		}
		for (int i = 0; i < instance.users.Count; i++)
		{
			PlayerNameID instance2 = instance.users[i];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			PlayerNameID.Serialize(stream, instance2);
			int val = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (users != null)
		{
			for (int i = 0; i < users.Count; i++)
			{
				users[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SphereEntity : IDisposable, IPooled, IProto<SphereEntity>, IProto
{
	[NonSerialized]
	public float radius;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SphereEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.radius = 0f;
			Pool.Free<SphereEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SphereEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SphereEntity instance)
	{
		instance.radius = radius;
	}

	public SphereEntity Copy()
	{
		SphereEntity sphereEntity = Pool.Get<SphereEntity>();
		CopyTo(sphereEntity);
		return sphereEntity;
	}

	public static SphereEntity Deserialize(BufferStream stream)
	{
		SphereEntity sphereEntity = Pool.Get<SphereEntity>();
		Deserialize(stream, sphereEntity, isDelta: false);
		return sphereEntity;
	}

	public static SphereEntity DeserializeLengthDelimited(BufferStream stream)
	{
		SphereEntity sphereEntity = Pool.Get<SphereEntity>();
		DeserializeLengthDelimited(stream, sphereEntity, isDelta: false);
		return sphereEntity;
	}

	public static SphereEntity DeserializeLength(BufferStream stream, int length)
	{
		SphereEntity sphereEntity = Pool.Get<SphereEntity>();
		DeserializeLength(stream, length, sphereEntity, isDelta: false);
		return sphereEntity;
	}

	public static SphereEntity Deserialize(byte[] buffer)
	{
		SphereEntity sphereEntity = Pool.Get<SphereEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sphereEntity, isDelta: false);
		return sphereEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SphereEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SphereEntity Deserialize(BufferStream stream, SphereEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SphereEntity DeserializeLengthDelimited(BufferStream stream, SphereEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SphereEntity DeserializeLength(BufferStream stream, int length, SphereEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SphereEntity instance, SphereEntity previous)
	{
		if (instance.radius != previous.radius)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.radius);
		}
	}

	public static void Serialize(BufferStream stream, SphereEntity instance)
	{
		if (instance.radius != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.radius);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class StabilityEntity : IDisposable, IPooled, IProto<StabilityEntity>, IProto
{
	[NonSerialized]
	public float stability;

	[NonSerialized]
	public int distanceFromGround;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(StabilityEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.stability = 0f;
			instance.distanceFromGround = 0;
			Pool.Free<StabilityEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose StabilityEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(StabilityEntity instance)
	{
		instance.stability = stability;
		instance.distanceFromGround = distanceFromGround;
	}

	public StabilityEntity Copy()
	{
		StabilityEntity stabilityEntity = Pool.Get<StabilityEntity>();
		CopyTo(stabilityEntity);
		return stabilityEntity;
	}

	public static StabilityEntity Deserialize(BufferStream stream)
	{
		StabilityEntity stabilityEntity = Pool.Get<StabilityEntity>();
		Deserialize(stream, stabilityEntity, isDelta: false);
		return stabilityEntity;
	}

	public static StabilityEntity DeserializeLengthDelimited(BufferStream stream)
	{
		StabilityEntity stabilityEntity = Pool.Get<StabilityEntity>();
		DeserializeLengthDelimited(stream, stabilityEntity, isDelta: false);
		return stabilityEntity;
	}

	public static StabilityEntity DeserializeLength(BufferStream stream, int length)
	{
		StabilityEntity stabilityEntity = Pool.Get<StabilityEntity>();
		DeserializeLength(stream, length, stabilityEntity, isDelta: false);
		return stabilityEntity;
	}

	public static StabilityEntity Deserialize(byte[] buffer)
	{
		StabilityEntity stabilityEntity = Pool.Get<StabilityEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, stabilityEntity, isDelta: false);
		return stabilityEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, StabilityEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static StabilityEntity Deserialize(BufferStream stream, StabilityEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.stability = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.distanceFromGround = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static StabilityEntity DeserializeLengthDelimited(BufferStream stream, StabilityEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.stability = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.distanceFromGround = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static StabilityEntity DeserializeLength(BufferStream stream, int length, StabilityEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.stability = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.distanceFromGround = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, StabilityEntity instance, StabilityEntity previous)
	{
		if (instance.stability != previous.stability)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.stability);
		}
		if (instance.distanceFromGround != previous.distanceFromGround)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.distanceFromGround);
		}
	}

	public static void Serialize(BufferStream stream, StabilityEntity instance)
	{
		if (instance.stability != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.stability);
		}
		if (instance.distanceFromGround != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.distanceFromGround);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class OwnerInfo : IDisposable, IPooled, IProto<OwnerInfo>, IProto
{
	[NonSerialized]
	public ulong steamid;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(OwnerInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamid = 0uL;
			Pool.Free<OwnerInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose OwnerInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(OwnerInfo instance)
	{
		instance.steamid = steamid;
	}

	public OwnerInfo Copy()
	{
		OwnerInfo ownerInfo = Pool.Get<OwnerInfo>();
		CopyTo(ownerInfo);
		return ownerInfo;
	}

	public static OwnerInfo Deserialize(BufferStream stream)
	{
		OwnerInfo ownerInfo = Pool.Get<OwnerInfo>();
		Deserialize(stream, ownerInfo, isDelta: false);
		return ownerInfo;
	}

	public static OwnerInfo DeserializeLengthDelimited(BufferStream stream)
	{
		OwnerInfo ownerInfo = Pool.Get<OwnerInfo>();
		DeserializeLengthDelimited(stream, ownerInfo, isDelta: false);
		return ownerInfo;
	}

	public static OwnerInfo DeserializeLength(BufferStream stream, int length)
	{
		OwnerInfo ownerInfo = Pool.Get<OwnerInfo>();
		DeserializeLength(stream, length, ownerInfo, isDelta: false);
		return ownerInfo;
	}

	public static OwnerInfo Deserialize(byte[] buffer)
	{
		OwnerInfo ownerInfo = Pool.Get<OwnerInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ownerInfo, isDelta: false);
		return ownerInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, OwnerInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static OwnerInfo Deserialize(BufferStream stream, OwnerInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static OwnerInfo DeserializeLengthDelimited(BufferStream stream, OwnerInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static OwnerInfo DeserializeLength(BufferStream stream, int length, OwnerInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, OwnerInfo instance, OwnerInfo previous)
	{
		if (instance.steamid != previous.steamid)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamid);
		}
	}

	public static void Serialize(BufferStream stream, OwnerInfo instance)
	{
		if (instance.steamid != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamid);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DecayEntity : IDisposable, IPooled, IProto<DecayEntity>, IProto
{
	[NonSerialized]
	public float decayTimer;

	[NonSerialized]
	public uint buildingID;

	[NonSerialized]
	public float upkeepTimer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DecayEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.decayTimer = 0f;
			instance.buildingID = 0u;
			instance.upkeepTimer = 0f;
			Pool.Free<DecayEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DecayEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DecayEntity instance)
	{
		instance.decayTimer = decayTimer;
		instance.buildingID = buildingID;
		instance.upkeepTimer = upkeepTimer;
	}

	public DecayEntity Copy()
	{
		DecayEntity decayEntity = Pool.Get<DecayEntity>();
		CopyTo(decayEntity);
		return decayEntity;
	}

	public static DecayEntity Deserialize(BufferStream stream)
	{
		DecayEntity decayEntity = Pool.Get<DecayEntity>();
		Deserialize(stream, decayEntity, isDelta: false);
		return decayEntity;
	}

	public static DecayEntity DeserializeLengthDelimited(BufferStream stream)
	{
		DecayEntity decayEntity = Pool.Get<DecayEntity>();
		DeserializeLengthDelimited(stream, decayEntity, isDelta: false);
		return decayEntity;
	}

	public static DecayEntity DeserializeLength(BufferStream stream, int length)
	{
		DecayEntity decayEntity = Pool.Get<DecayEntity>();
		DeserializeLength(stream, length, decayEntity, isDelta: false);
		return decayEntity;
	}

	public static DecayEntity Deserialize(byte[] buffer)
	{
		DecayEntity decayEntity = Pool.Get<DecayEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, decayEntity, isDelta: false);
		return decayEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DecayEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DecayEntity Deserialize(BufferStream stream, DecayEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.decayTimer = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.buildingID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 29:
				instance.upkeepTimer = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DecayEntity DeserializeLengthDelimited(BufferStream stream, DecayEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.decayTimer = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.buildingID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 29:
				instance.upkeepTimer = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DecayEntity DeserializeLength(BufferStream stream, int length, DecayEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.decayTimer = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.buildingID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 29:
				instance.upkeepTimer = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DecayEntity instance, DecayEntity previous)
	{
		if (instance.decayTimer != previous.decayTimer)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.decayTimer);
		}
		if (instance.buildingID != previous.buildingID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.buildingID);
		}
		if (instance.upkeepTimer != previous.upkeepTimer)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.upkeepTimer);
		}
	}

	public static void Serialize(BufferStream stream, DecayEntity instance)
	{
		if (instance.decayTimer != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.decayTimer);
		}
		if (instance.buildingID != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.buildingID);
		}
		if (instance.upkeepTimer != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.upkeepTimer);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Spawnable : IDisposable, IPooled, IProto<Spawnable>, IProto
{
	[NonSerialized]
	public uint population;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Spawnable instance)
	{
		if (instance.ShouldPool)
		{
			instance.population = 0u;
			Pool.Free<Spawnable>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Spawnable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Spawnable instance)
	{
		instance.population = population;
	}

	public Spawnable Copy()
	{
		Spawnable spawnable = Pool.Get<Spawnable>();
		CopyTo(spawnable);
		return spawnable;
	}

	public static Spawnable Deserialize(BufferStream stream)
	{
		Spawnable spawnable = Pool.Get<Spawnable>();
		Deserialize(stream, spawnable, isDelta: false);
		return spawnable;
	}

	public static Spawnable DeserializeLengthDelimited(BufferStream stream)
	{
		Spawnable spawnable = Pool.Get<Spawnable>();
		DeserializeLengthDelimited(stream, spawnable, isDelta: false);
		return spawnable;
	}

	public static Spawnable DeserializeLength(BufferStream stream, int length)
	{
		Spawnable spawnable = Pool.Get<Spawnable>();
		DeserializeLength(stream, length, spawnable, isDelta: false);
		return spawnable;
	}

	public static Spawnable Deserialize(byte[] buffer)
	{
		Spawnable spawnable = Pool.Get<Spawnable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spawnable, isDelta: false);
		return spawnable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Spawnable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Spawnable Deserialize(BufferStream stream, Spawnable instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.population = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Spawnable DeserializeLengthDelimited(BufferStream stream, Spawnable instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.population = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Spawnable DeserializeLength(BufferStream stream, int length, Spawnable instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.population = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Spawnable instance, Spawnable previous)
	{
		if (instance.population != previous.population)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.population);
		}
	}

	public static void Serialize(BufferStream stream, Spawnable instance)
	{
		if (instance.population != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.population);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class SpinnerWheel : IDisposable, IPooled, IProto<SpinnerWheel>, IProto
{
	[NonSerialized]
	public Vector3 spin;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpinnerWheel instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.spin = default(Vector3);
			Pool.Free<SpinnerWheel>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpinnerWheel with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpinnerWheel instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.spin = spin;
	}

	public SpinnerWheel Copy()
	{
		SpinnerWheel spinnerWheel = Pool.Get<SpinnerWheel>();
		CopyTo(spinnerWheel);
		return spinnerWheel;
	}

	public static SpinnerWheel Deserialize(BufferStream stream)
	{
		SpinnerWheel spinnerWheel = Pool.Get<SpinnerWheel>();
		Deserialize(stream, spinnerWheel, isDelta: false);
		return spinnerWheel;
	}

	public static SpinnerWheel DeserializeLengthDelimited(BufferStream stream)
	{
		SpinnerWheel spinnerWheel = Pool.Get<SpinnerWheel>();
		DeserializeLengthDelimited(stream, spinnerWheel, isDelta: false);
		return spinnerWheel;
	}

	public static SpinnerWheel DeserializeLength(BufferStream stream, int length)
	{
		SpinnerWheel spinnerWheel = Pool.Get<SpinnerWheel>();
		DeserializeLength(stream, length, spinnerWheel, isDelta: false);
		return spinnerWheel;
	}

	public static SpinnerWheel Deserialize(byte[] buffer)
	{
		SpinnerWheel spinnerWheel = Pool.Get<SpinnerWheel>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spinnerWheel, isDelta: false);
		return spinnerWheel;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpinnerWheel previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpinnerWheel Deserialize(BufferStream stream, SpinnerWheel instance, bool isDelta)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.spin, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpinnerWheel DeserializeLengthDelimited(BufferStream stream, SpinnerWheel instance, bool isDelta)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.spin, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpinnerWheel DeserializeLength(BufferStream stream, int length, SpinnerWheel instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.spin, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpinnerWheel instance, SpinnerWheel previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spin != previous.spin)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.spin, previous.spin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, SpinnerWheel instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spin != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.spin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Lift : IDisposable, IPooled, IProto<Lift>, IProto
{
	[NonSerialized]
	public int floor;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Lift instance)
	{
		if (instance.ShouldPool)
		{
			instance.floor = 0;
			Pool.Free<Lift>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Lift with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Lift instance)
	{
		instance.floor = floor;
	}

	public Lift Copy()
	{
		Lift lift = Pool.Get<Lift>();
		CopyTo(lift);
		return lift;
	}

	public static Lift Deserialize(BufferStream stream)
	{
		Lift lift = Pool.Get<Lift>();
		Deserialize(stream, lift, isDelta: false);
		return lift;
	}

	public static Lift DeserializeLengthDelimited(BufferStream stream)
	{
		Lift lift = Pool.Get<Lift>();
		DeserializeLengthDelimited(stream, lift, isDelta: false);
		return lift;
	}

	public static Lift DeserializeLength(BufferStream stream, int length)
	{
		Lift lift = Pool.Get<Lift>();
		DeserializeLength(stream, length, lift, isDelta: false);
		return lift;
	}

	public static Lift Deserialize(byte[] buffer)
	{
		Lift lift = Pool.Get<Lift>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lift, isDelta: false);
		return lift;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Lift previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Lift Deserialize(BufferStream stream, Lift instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Lift DeserializeLengthDelimited(BufferStream stream, Lift instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Lift DeserializeLength(BufferStream stream, int length, Lift instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Lift instance, Lift previous)
	{
		if (instance.floor != previous.floor)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.floor);
		}
	}

	public static void Serialize(BufferStream stream, Lift instance)
	{
		if (instance.floor != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.floor);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachine : IDisposable, IPooled, IProto<VendingMachine>, IProto
{
	public class SellOrder : IDisposable, IPooled, IProto<SellOrder>, IProto
	{
		[NonSerialized]
		public int itemToSellID;

		[NonSerialized]
		public int itemToSellAmount;

		[NonSerialized]
		public int currencyID;

		[NonSerialized]
		public int currencyAmountPerItem;

		[NonSerialized]
		public int inStock;

		[NonSerialized]
		public bool currencyIsBP;

		[NonSerialized]
		public bool itemToSellIsBP;

		[NonSerialized]
		public float itemCondition;

		[NonSerialized]
		public float itemConditionMax;

		[NonSerialized]
		public int instanceData;

		[NonSerialized]
		public List<int> attachmentsList;

		[NonSerialized]
		public int totalAttachmentSlots;

		[NonSerialized]
		public float priceMultiplier;

		[NonSerialized]
		public int ammoType;

		[NonSerialized]
		public int ammoCount;

		[NonSerialized]
		public float receivedQuantityMultiplier;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SellOrder instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemToSellID = 0;
				instance.itemToSellAmount = 0;
				instance.currencyID = 0;
				instance.currencyAmountPerItem = 0;
				instance.inStock = 0;
				instance.currencyIsBP = false;
				instance.itemToSellIsBP = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.instanceData = 0;
				if (instance.attachmentsList != null)
				{
					List<int> list = instance.attachmentsList;
					Pool.FreeUnmanaged<int>(ref list);
					instance.attachmentsList = list;
				}
				instance.totalAttachmentSlots = 0;
				instance.priceMultiplier = 0f;
				instance.ammoType = 0;
				instance.ammoCount = 0;
				instance.receivedQuantityMultiplier = 0f;
				Pool.Free<SellOrder>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SellOrder with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SellOrder instance)
		{
			instance.itemToSellID = itemToSellID;
			instance.itemToSellAmount = itemToSellAmount;
			instance.currencyID = currencyID;
			instance.currencyAmountPerItem = currencyAmountPerItem;
			instance.inStock = inStock;
			instance.currencyIsBP = currencyIsBP;
			instance.itemToSellIsBP = itemToSellIsBP;
			instance.itemCondition = itemCondition;
			instance.itemConditionMax = itemConditionMax;
			instance.instanceData = instanceData;
			if (attachmentsList != null)
			{
				instance.attachmentsList = Pool.Get<List<int>>();
				for (int i = 0; i < attachmentsList.Count; i++)
				{
					int item = attachmentsList[i];
					instance.attachmentsList.Add(item);
				}
			}
			else
			{
				instance.attachmentsList = null;
			}
			instance.totalAttachmentSlots = totalAttachmentSlots;
			instance.priceMultiplier = priceMultiplier;
			instance.ammoType = ammoType;
			instance.ammoCount = ammoCount;
			instance.receivedQuantityMultiplier = receivedQuantityMultiplier;
		}

		public SellOrder Copy()
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			CopyTo(sellOrder);
			return sellOrder;
		}

		public static SellOrder Deserialize(BufferStream stream)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			Deserialize(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder DeserializeLengthDelimited(BufferStream stream)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			DeserializeLengthDelimited(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder DeserializeLength(BufferStream stream, int length)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			DeserializeLength(stream, length, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder Deserialize(byte[] buffer)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SellOrder previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SellOrder Deserialize(BufferStream stream, SellOrder instance, bool isDelta)
		{
			if (!isDelta && instance.attachmentsList == null)
			{
				instance.attachmentsList = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemToSellID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.itemToSellAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.currencyAmountPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.inStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.currencyIsBP = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.itemToSellIsBP = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 80:
					instance.instanceData = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 88:
					instance.attachmentsList.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 96:
					instance.totalAttachmentSlots = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 109:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				case 112:
					instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 120:
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				if (key.Field == 16)
				{
					if (key.WireType == Wire.Fixed32)
					{
						instance.receivedQuantityMultiplier = ProtocolParser.ReadSingle(stream);
					}
				}
				else
				{
					ProtocolParser.SkipKey(stream, key);
				}
			}
		}

		public static SellOrder DeserializeLengthDelimited(BufferStream stream, SellOrder instance, bool isDelta)
		{
			if (!isDelta && instance.attachmentsList == null)
			{
				instance.attachmentsList = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemToSellID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.itemToSellAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.currencyAmountPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.inStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.currencyIsBP = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.itemToSellIsBP = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 80:
					instance.instanceData = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 88:
					instance.attachmentsList.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 96:
					instance.totalAttachmentSlots = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 109:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				case 112:
					instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 120:
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				if (key.Field == 16)
				{
					if (key.WireType == Wire.Fixed32)
					{
						instance.receivedQuantityMultiplier = ProtocolParser.ReadSingle(stream);
					}
				}
				else
				{
					ProtocolParser.SkipKey(stream, key);
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SellOrder DeserializeLength(BufferStream stream, int length, SellOrder instance, bool isDelta)
		{
			if (!isDelta && instance.attachmentsList == null)
			{
				instance.attachmentsList = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemToSellID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.itemToSellAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.currencyAmountPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.inStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.currencyIsBP = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.itemToSellIsBP = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 80:
					instance.instanceData = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 88:
					instance.attachmentsList.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 96:
					instance.totalAttachmentSlots = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 109:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				case 112:
					instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 120:
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				if (key.Field == 16)
				{
					if (key.WireType == Wire.Fixed32)
					{
						instance.receivedQuantityMultiplier = ProtocolParser.ReadSingle(stream);
					}
				}
				else
				{
					ProtocolParser.SkipKey(stream, key);
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SellOrder instance, SellOrder previous)
		{
			if (instance.itemToSellID != previous.itemToSellID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellID);
			}
			if (instance.itemToSellAmount != previous.itemToSellAmount)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellAmount);
			}
			if (instance.currencyID != previous.currencyID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyID);
			}
			if (instance.currencyAmountPerItem != previous.currencyAmountPerItem)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyAmountPerItem);
			}
			if (instance.inStock != previous.inStock)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.inStock);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.currencyIsBP);
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.itemToSellIsBP);
			if (instance.itemCondition != previous.itemCondition)
			{
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, instance.itemCondition);
			}
			if (instance.itemConditionMax != previous.itemConditionMax)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
			}
			if (instance.instanceData != previous.instanceData)
			{
				stream.WriteByte(80);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.instanceData);
			}
			if (instance.attachmentsList != null)
			{
				for (int i = 0; i < instance.attachmentsList.Count; i++)
				{
					int num = instance.attachmentsList[i];
					stream.WriteByte(88);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.totalAttachmentSlots != previous.totalAttachmentSlots)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAttachmentSlots);
			}
			if (instance.priceMultiplier != previous.priceMultiplier)
			{
				stream.WriteByte(109);
				ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
			}
			if (instance.ammoType != previous.ammoType)
			{
				stream.WriteByte(112);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
			}
			if (instance.ammoCount != previous.ammoCount)
			{
				stream.WriteByte(120);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
			}
			if (instance.receivedQuantityMultiplier != previous.receivedQuantityMultiplier)
			{
				stream.WriteByte(133);
				stream.WriteByte(1);
				ProtocolParser.WriteSingle(stream, instance.receivedQuantityMultiplier);
			}
		}

		public static void Serialize(BufferStream stream, SellOrder instance)
		{
			if (instance.itemToSellID != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellID);
			}
			if (instance.itemToSellAmount != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellAmount);
			}
			if (instance.currencyID != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyID);
			}
			if (instance.currencyAmountPerItem != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyAmountPerItem);
			}
			if (instance.inStock != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.inStock);
			}
			if (instance.currencyIsBP)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.currencyIsBP);
			}
			if (instance.itemToSellIsBP)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.itemToSellIsBP);
			}
			if (instance.itemCondition != 0f)
			{
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, instance.itemCondition);
			}
			if (instance.itemConditionMax != 0f)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
			}
			if (instance.instanceData != 0)
			{
				stream.WriteByte(80);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.instanceData);
			}
			if (instance.attachmentsList != null)
			{
				for (int i = 0; i < instance.attachmentsList.Count; i++)
				{
					int num = instance.attachmentsList[i];
					stream.WriteByte(88);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.totalAttachmentSlots != 0)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAttachmentSlots);
			}
			if (instance.priceMultiplier != 0f)
			{
				stream.WriteByte(109);
				ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
			}
			if (instance.ammoType != 0)
			{
				stream.WriteByte(112);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
			}
			if (instance.ammoCount != 0)
			{
				stream.WriteByte(120);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
			}
			if (instance.receivedQuantityMultiplier != 0f)
			{
				stream.WriteByte(133);
				stream.WriteByte(1);
				ProtocolParser.WriteSingle(stream, instance.receivedQuantityMultiplier);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class SellOrderContainer : IDisposable, IPooled, IProto<SellOrderContainer>, IProto
	{
		[NonSerialized]
		public List<SellOrder> sellOrders;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SellOrderContainer instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.sellOrders != null)
			{
				for (int i = 0; i < instance.sellOrders.Count; i++)
				{
					if (instance.sellOrders[i] != null)
					{
						instance.sellOrders[i].ResetToPool();
						instance.sellOrders[i] = null;
					}
				}
				List<SellOrder> list = instance.sellOrders;
				Pool.Free<SellOrder>(ref list, false);
				instance.sellOrders = list;
			}
			Pool.Free<SellOrderContainer>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SellOrderContainer with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SellOrderContainer instance)
		{
			if (sellOrders != null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
				for (int i = 0; i < sellOrders.Count; i++)
				{
					SellOrder item = sellOrders[i].Copy();
					instance.sellOrders.Add(item);
				}
			}
			else
			{
				instance.sellOrders = null;
			}
		}

		public SellOrderContainer Copy()
		{
			SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
			CopyTo(sellOrderContainer);
			return sellOrderContainer;
		}

		public static SellOrderContainer Deserialize(BufferStream stream)
		{
			SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
			Deserialize(stream, sellOrderContainer, isDelta: false);
			return sellOrderContainer;
		}

		public static SellOrderContainer DeserializeLengthDelimited(BufferStream stream)
		{
			SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
			DeserializeLengthDelimited(stream, sellOrderContainer, isDelta: false);
			return sellOrderContainer;
		}

		public static SellOrderContainer DeserializeLength(BufferStream stream, int length)
		{
			SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
			DeserializeLength(stream, length, sellOrderContainer, isDelta: false);
			return sellOrderContainer;
		}

		public static SellOrderContainer Deserialize(byte[] buffer)
		{
			SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, sellOrderContainer, isDelta: false);
			return sellOrderContainer;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SellOrderContainer previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SellOrderContainer Deserialize(BufferStream stream, SellOrderContainer instance, bool isDelta)
		{
			if (!isDelta && instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static SellOrderContainer DeserializeLengthDelimited(BufferStream stream, SellOrderContainer instance, bool isDelta)
		{
			if (!isDelta && instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SellOrderContainer DeserializeLength(BufferStream stream, int length, SellOrderContainer instance, bool isDelta)
		{
			if (!isDelta && instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SellOrderContainer instance, SellOrderContainer previous)
		{
			if (instance.sellOrders == null)
			{
				return;
			}
			for (int i = 0; i < instance.sellOrders.Count; i++)
			{
				SellOrder sellOrder = instance.sellOrders[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				SellOrder.SerializeDelta(stream, sellOrder, sellOrder);
				int num = stream.Position - position;
				if (num > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.VendingMachine.SellOrder)");
				}
				Span<byte> span = range.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
				if (num2 < 3)
				{
					span[num2 - 1] |= 128;
					while (num2 < 2)
					{
						span[num2++] = 128;
					}
					span[2] = 0;
				}
			}
		}

		public static void Serialize(BufferStream stream, SellOrderContainer instance)
		{
			if (instance.sellOrders == null)
			{
				return;
			}
			for (int i = 0; i < instance.sellOrders.Count; i++)
			{
				SellOrder instance2 = instance.sellOrders[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				SellOrder.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.VendingMachine.SellOrder)");
				}
				Span<byte> span = range.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
				if (num2 < 3)
				{
					span[num2 - 1] |= 128;
					while (num2 < 2)
					{
						span[num2++] = 128;
					}
					span[2] = 0;
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (sellOrders != null)
			{
				for (int i = 0; i < sellOrders.Count; i++)
				{
					sellOrders[i]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public SellOrderContainer sellOrderContainer;

	[NonSerialized]
	public string shopName;

	[NonSerialized]
	public int vmoIndex;

	[NonSerialized]
	public NetworkableId networkID;

	[NonSerialized]
	public string translationToken;

	[NonSerialized]
	public ulong nameLastEditedBy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachine instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.sellOrderContainer != null)
			{
				instance.sellOrderContainer.ResetToPool();
				instance.sellOrderContainer = null;
			}
			instance.shopName = string.Empty;
			instance.vmoIndex = 0;
			instance.networkID = default(NetworkableId);
			instance.translationToken = string.Empty;
			instance.nameLastEditedBy = 0uL;
			Pool.Free<VendingMachine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachine instance)
	{
		if (sellOrderContainer != null)
		{
			if (instance.sellOrderContainer == null)
			{
				instance.sellOrderContainer = sellOrderContainer.Copy();
			}
			else
			{
				sellOrderContainer.CopyTo(instance.sellOrderContainer);
			}
		}
		else
		{
			instance.sellOrderContainer = null;
		}
		instance.shopName = shopName;
		instance.vmoIndex = vmoIndex;
		instance.networkID = networkID;
		instance.translationToken = translationToken;
		instance.nameLastEditedBy = nameLastEditedBy;
	}

	public VendingMachine Copy()
	{
		VendingMachine vendingMachine = Pool.Get<VendingMachine>();
		CopyTo(vendingMachine);
		return vendingMachine;
	}

	public static VendingMachine Deserialize(BufferStream stream)
	{
		VendingMachine vendingMachine = Pool.Get<VendingMachine>();
		Deserialize(stream, vendingMachine, isDelta: false);
		return vendingMachine;
	}

	public static VendingMachine DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachine vendingMachine = Pool.Get<VendingMachine>();
		DeserializeLengthDelimited(stream, vendingMachine, isDelta: false);
		return vendingMachine;
	}

	public static VendingMachine DeserializeLength(BufferStream stream, int length)
	{
		VendingMachine vendingMachine = Pool.Get<VendingMachine>();
		DeserializeLength(stream, length, vendingMachine, isDelta: false);
		return vendingMachine;
	}

	public static VendingMachine Deserialize(byte[] buffer)
	{
		VendingMachine vendingMachine = Pool.Get<VendingMachine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachine, isDelta: false);
		return vendingMachine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachine Deserialize(BufferStream stream, VendingMachine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.sellOrderContainer == null)
				{
					instance.sellOrderContainer = SellOrderContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					SellOrderContainer.DeserializeLengthDelimited(stream, instance.sellOrderContainer, isDelta);
				}
				break;
			case 18:
				instance.shopName = ProtocolParser.ReadString(stream);
				break;
			case 24:
				instance.vmoIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.networkID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.translationToken = ProtocolParser.ReadString(stream);
				break;
			case 48:
				instance.nameLastEditedBy = ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static VendingMachine DeserializeLengthDelimited(BufferStream stream, VendingMachine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.sellOrderContainer == null)
				{
					instance.sellOrderContainer = SellOrderContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					SellOrderContainer.DeserializeLengthDelimited(stream, instance.sellOrderContainer, isDelta);
				}
				break;
			case 18:
				instance.shopName = ProtocolParser.ReadString(stream);
				break;
			case 24:
				instance.vmoIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.networkID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.translationToken = ProtocolParser.ReadString(stream);
				break;
			case 48:
				instance.nameLastEditedBy = ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachine DeserializeLength(BufferStream stream, int length, VendingMachine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.sellOrderContainer == null)
				{
					instance.sellOrderContainer = SellOrderContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					SellOrderContainer.DeserializeLengthDelimited(stream, instance.sellOrderContainer, isDelta);
				}
				break;
			case 18:
				instance.shopName = ProtocolParser.ReadString(stream);
				break;
			case 24:
				instance.vmoIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.networkID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.translationToken = ProtocolParser.ReadString(stream);
				break;
			case 48:
				instance.nameLastEditedBy = ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachine instance, VendingMachine previous)
	{
		if (instance.sellOrderContainer != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			SellOrderContainer.SerializeDelta(stream, instance.sellOrderContainer, previous.sellOrderContainer);
			int num = stream.Position - position;
			if (num > int.MaxValue)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrderContainer (ProtoBuf.VendingMachine.SellOrderContainer)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 5)
			{
				span[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span[num2++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.shopName != null && instance.shopName != previous.shopName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.shopName);
		}
		if (instance.vmoIndex != previous.vmoIndex)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.vmoIndex);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.networkID.Value);
		if (instance.translationToken != null && instance.translationToken != previous.translationToken)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.translationToken);
		}
		if (instance.nameLastEditedBy != previous.nameLastEditedBy)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.nameLastEditedBy);
		}
	}

	public static void Serialize(BufferStream stream, VendingMachine instance)
	{
		if (instance.sellOrderContainer != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			SellOrderContainer.Serialize(stream, instance.sellOrderContainer);
			int num = stream.Position - position;
			if (num > int.MaxValue)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrderContainer (ProtoBuf.VendingMachine.SellOrderContainer)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 5)
			{
				span[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span[num2++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.shopName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.shopName);
		}
		if (instance.vmoIndex != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.vmoIndex);
		}
		if (instance.networkID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.networkID.Value);
		}
		if (instance.translationToken != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.translationToken);
		}
		if (instance.nameLastEditedBy != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.nameLastEditedBy);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		sellOrderContainer?.InspectUids(action);
		action(UidType.NetworkableId, ref networkID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachineStats : IDisposable, IPooled, IProto<VendingMachineStats>, IProto
{
	[NonSerialized]
	public List<VendingMachinePurchaseHistoryEntryMessage> purchaseHistory;

	[NonSerialized]
	public List<ulong> customers;

	[NonSerialized]
	public List<int> customersVisits;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachineStats instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.purchaseHistory != null)
		{
			for (int i = 0; i < instance.purchaseHistory.Count; i++)
			{
				if (instance.purchaseHistory[i] != null)
				{
					instance.purchaseHistory[i].ResetToPool();
					instance.purchaseHistory[i] = null;
				}
			}
			List<VendingMachinePurchaseHistoryEntryMessage> list = instance.purchaseHistory;
			Pool.Free<VendingMachinePurchaseHistoryEntryMessage>(ref list, false);
			instance.purchaseHistory = list;
		}
		if (instance.customers != null)
		{
			List<ulong> list2 = instance.customers;
			Pool.FreeUnmanaged<ulong>(ref list2);
			instance.customers = list2;
		}
		if (instance.customersVisits != null)
		{
			List<int> list3 = instance.customersVisits;
			Pool.FreeUnmanaged<int>(ref list3);
			instance.customersVisits = list3;
		}
		Pool.Free<VendingMachineStats>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachineStats with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachineStats instance)
	{
		if (purchaseHistory != null)
		{
			instance.purchaseHistory = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			for (int i = 0; i < purchaseHistory.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage item = purchaseHistory[i].Copy();
				instance.purchaseHistory.Add(item);
			}
		}
		else
		{
			instance.purchaseHistory = null;
		}
		if (customers != null)
		{
			instance.customers = Pool.Get<List<ulong>>();
			for (int j = 0; j < customers.Count; j++)
			{
				ulong item2 = customers[j];
				instance.customers.Add(item2);
			}
		}
		else
		{
			instance.customers = null;
		}
		if (customersVisits != null)
		{
			instance.customersVisits = Pool.Get<List<int>>();
			for (int k = 0; k < customersVisits.Count; k++)
			{
				int item3 = customersVisits[k];
				instance.customersVisits.Add(item3);
			}
		}
		else
		{
			instance.customersVisits = null;
		}
	}

	public VendingMachineStats Copy()
	{
		VendingMachineStats vendingMachineStats = Pool.Get<VendingMachineStats>();
		CopyTo(vendingMachineStats);
		return vendingMachineStats;
	}

	public static VendingMachineStats Deserialize(BufferStream stream)
	{
		VendingMachineStats vendingMachineStats = Pool.Get<VendingMachineStats>();
		Deserialize(stream, vendingMachineStats, isDelta: false);
		return vendingMachineStats;
	}

	public static VendingMachineStats DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachineStats vendingMachineStats = Pool.Get<VendingMachineStats>();
		DeserializeLengthDelimited(stream, vendingMachineStats, isDelta: false);
		return vendingMachineStats;
	}

	public static VendingMachineStats DeserializeLength(BufferStream stream, int length)
	{
		VendingMachineStats vendingMachineStats = Pool.Get<VendingMachineStats>();
		DeserializeLength(stream, length, vendingMachineStats, isDelta: false);
		return vendingMachineStats;
	}

	public static VendingMachineStats Deserialize(byte[] buffer)
	{
		VendingMachineStats vendingMachineStats = Pool.Get<VendingMachineStats>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachineStats, isDelta: false);
		return vendingMachineStats;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachineStats previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachineStats Deserialize(BufferStream stream, VendingMachineStats instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.purchaseHistory == null)
			{
				instance.purchaseHistory = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.customers == null)
			{
				instance.customers = Pool.Get<List<ulong>>();
			}
			if (instance.customersVisits == null)
			{
				instance.customersVisits = Pool.Get<List<int>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.purchaseHistory.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.customers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.customersVisits.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachineStats DeserializeLengthDelimited(BufferStream stream, VendingMachineStats instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.purchaseHistory == null)
			{
				instance.purchaseHistory = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.customers == null)
			{
				instance.customers = Pool.Get<List<ulong>>();
			}
			if (instance.customersVisits == null)
			{
				instance.customersVisits = Pool.Get<List<int>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.purchaseHistory.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.customers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.customersVisits.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachineStats DeserializeLength(BufferStream stream, int length, VendingMachineStats instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.purchaseHistory == null)
			{
				instance.purchaseHistory = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.customers == null)
			{
				instance.customers = Pool.Get<List<ulong>>();
			}
			if (instance.customersVisits == null)
			{
				instance.customersVisits = Pool.Get<List<int>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.purchaseHistory.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.customers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.customersVisits.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachineStats instance, VendingMachineStats previous)
	{
		if (instance.purchaseHistory != null)
		{
			for (int i = 0; i < instance.purchaseHistory.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = instance.purchaseHistory[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VendingMachinePurchaseHistoryEntryMessage.SerializeDelta(stream, vendingMachinePurchaseHistoryEntryMessage, vendingMachinePurchaseHistoryEntryMessage);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field purchaseHistory (ProtoBuf.VendingMachinePurchaseHistoryEntryMessage)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.customers != null)
		{
			for (int j = 0; j < instance.customers.Count; j++)
			{
				ulong val = instance.customers[j];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.customersVisits != null)
		{
			for (int k = 0; k < instance.customersVisits.Count; k++)
			{
				int num2 = instance.customersVisits[k];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
	}

	public static void Serialize(BufferStream stream, VendingMachineStats instance)
	{
		if (instance.purchaseHistory != null)
		{
			for (int i = 0; i < instance.purchaseHistory.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage instance2 = instance.purchaseHistory[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VendingMachinePurchaseHistoryEntryMessage.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field purchaseHistory (ProtoBuf.VendingMachinePurchaseHistoryEntryMessage)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.customers != null)
		{
			for (int j = 0; j < instance.customers.Count; j++)
			{
				ulong val = instance.customers[j];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.customersVisits != null)
		{
			for (int k = 0; k < instance.customersVisits.Count; k++)
			{
				int num2 = instance.customersVisits[k];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (purchaseHistory != null)
		{
			for (int i = 0; i < purchaseHistory.Count; i++)
			{
				purchaseHistory[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class BradleyAPC : IDisposable, IPooled, IProto<BradleyAPC>, IProto
{
	[NonSerialized]
	public float engineThrottle;

	[NonSerialized]
	public float throttleLeft;

	[NonSerialized]
	public float throttleRight;

	[NonSerialized]
	public Vector3 mainGunVec;

	[NonSerialized]
	public Vector3 topTurretVec;

	[NonSerialized]
	public Vector3 rearGunVec;

	[NonSerialized]
	public Vector3 leftSideGun1;

	[NonSerialized]
	public Vector3 leftSideGun2;

	[NonSerialized]
	public Vector3 rightSideGun1;

	[NonSerialized]
	public Vector3 rightSideGun2;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BradleyAPC instance)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.engineThrottle = 0f;
			instance.throttleLeft = 0f;
			instance.throttleRight = 0f;
			instance.mainGunVec = default(Vector3);
			instance.topTurretVec = default(Vector3);
			instance.rearGunVec = default(Vector3);
			instance.leftSideGun1 = default(Vector3);
			instance.leftSideGun2 = default(Vector3);
			instance.rightSideGun1 = default(Vector3);
			instance.rightSideGun2 = default(Vector3);
			Pool.Free<BradleyAPC>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BradleyAPC with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BradleyAPC instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		instance.engineThrottle = engineThrottle;
		instance.throttleLeft = throttleLeft;
		instance.throttleRight = throttleRight;
		instance.mainGunVec = mainGunVec;
		instance.topTurretVec = topTurretVec;
		instance.rearGunVec = rearGunVec;
		instance.leftSideGun1 = leftSideGun1;
		instance.leftSideGun2 = leftSideGun2;
		instance.rightSideGun1 = rightSideGun1;
		instance.rightSideGun2 = rightSideGun2;
	}

	public BradleyAPC Copy()
	{
		BradleyAPC bradleyAPC = Pool.Get<BradleyAPC>();
		CopyTo(bradleyAPC);
		return bradleyAPC;
	}

	public static BradleyAPC Deserialize(BufferStream stream)
	{
		BradleyAPC bradleyAPC = Pool.Get<BradleyAPC>();
		Deserialize(stream, bradleyAPC, isDelta: false);
		return bradleyAPC;
	}

	public static BradleyAPC DeserializeLengthDelimited(BufferStream stream)
	{
		BradleyAPC bradleyAPC = Pool.Get<BradleyAPC>();
		DeserializeLengthDelimited(stream, bradleyAPC, isDelta: false);
		return bradleyAPC;
	}

	public static BradleyAPC DeserializeLength(BufferStream stream, int length)
	{
		BradleyAPC bradleyAPC = Pool.Get<BradleyAPC>();
		DeserializeLength(stream, length, bradleyAPC, isDelta: false);
		return bradleyAPC;
	}

	public static BradleyAPC Deserialize(byte[] buffer)
	{
		BradleyAPC bradleyAPC = Pool.Get<BradleyAPC>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, bradleyAPC, isDelta: false);
		return bradleyAPC;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BradleyAPC previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BradleyAPC Deserialize(BufferStream stream, BradleyAPC instance, bool isDelta)
	{
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.engineThrottle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.throttleLeft = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleRight = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mainGunVec, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.topTurretVec, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rearGunVec, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftSideGun1, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftSideGun2, isDelta);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightSideGun1, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightSideGun2, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BradleyAPC DeserializeLengthDelimited(BufferStream stream, BradleyAPC instance, bool isDelta)
	{
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.engineThrottle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.throttleLeft = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleRight = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mainGunVec, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.topTurretVec, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rearGunVec, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftSideGun1, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftSideGun2, isDelta);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightSideGun1, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightSideGun2, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BradleyAPC DeserializeLength(BufferStream stream, int length, BradleyAPC instance, bool isDelta)
	{
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.engineThrottle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.throttleLeft = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleRight = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mainGunVec, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.topTurretVec, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rearGunVec, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftSideGun1, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftSideGun2, isDelta);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightSideGun1, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightSideGun2, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BradleyAPC instance, BradleyAPC previous)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.engineThrottle != previous.engineThrottle)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.engineThrottle);
		}
		if (instance.throttleLeft != previous.throttleLeft)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.throttleLeft);
		}
		if (instance.throttleRight != previous.throttleRight)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleRight);
		}
		if (instance.mainGunVec != previous.mainGunVec)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.mainGunVec, previous.mainGunVec);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mainGunVec (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.topTurretVec != previous.topTurretVec)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.topTurretVec, previous.topTurretVec);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topTurretVec (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rearGunVec != previous.rearGunVec)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rearGunVec, previous.rearGunVec);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rearGunVec (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.leftSideGun1 != previous.leftSideGun1)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.leftSideGun1, previous.leftSideGun1);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field leftSideGun1 (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.leftSideGun2 != previous.leftSideGun2)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.leftSideGun2, previous.leftSideGun2);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field leftSideGun2 (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.rightSideGun1 != previous.rightSideGun1)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rightSideGun1, previous.rightSideGun1);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rightSideGun1 (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.rightSideGun2 != previous.rightSideGun2)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rightSideGun2, previous.rightSideGun2);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rightSideGun2 (UnityEngine.Vector3)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
	}

	public static void Serialize(BufferStream stream, BradleyAPC instance)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		if (instance.engineThrottle != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.engineThrottle);
		}
		if (instance.throttleLeft != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.throttleLeft);
		}
		if (instance.throttleRight != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleRight);
		}
		if (instance.mainGunVec != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.mainGunVec);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mainGunVec (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.topTurretVec != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.topTurretVec);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topTurretVec (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rearGunVec != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rearGunVec);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rearGunVec (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.leftSideGun1 != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.leftSideGun1);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field leftSideGun1 (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.leftSideGun2 != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.leftSideGun2);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field leftSideGun2 (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.rightSideGun1 != default(Vector3))
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rightSideGun1);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rightSideGun1 (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.rightSideGun2 != default(Vector3))
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rightSideGun2);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rightSideGun2 (UnityEngine.Vector3)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WaterWell : IDisposable, IPooled, IProto<WaterWell>, IProto
{
	[NonSerialized]
	public float pressure;

	[NonSerialized]
	public float waterLevel;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WaterWell instance)
	{
		if (instance.ShouldPool)
		{
			instance.pressure = 0f;
			instance.waterLevel = 0f;
			Pool.Free<WaterWell>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WaterWell with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WaterWell instance)
	{
		instance.pressure = pressure;
		instance.waterLevel = waterLevel;
	}

	public WaterWell Copy()
	{
		WaterWell waterWell = Pool.Get<WaterWell>();
		CopyTo(waterWell);
		return waterWell;
	}

	public static WaterWell Deserialize(BufferStream stream)
	{
		WaterWell waterWell = Pool.Get<WaterWell>();
		Deserialize(stream, waterWell, isDelta: false);
		return waterWell;
	}

	public static WaterWell DeserializeLengthDelimited(BufferStream stream)
	{
		WaterWell waterWell = Pool.Get<WaterWell>();
		DeserializeLengthDelimited(stream, waterWell, isDelta: false);
		return waterWell;
	}

	public static WaterWell DeserializeLength(BufferStream stream, int length)
	{
		WaterWell waterWell = Pool.Get<WaterWell>();
		DeserializeLength(stream, length, waterWell, isDelta: false);
		return waterWell;
	}

	public static WaterWell Deserialize(byte[] buffer)
	{
		WaterWell waterWell = Pool.Get<WaterWell>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, waterWell, isDelta: false);
		return waterWell;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WaterWell previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WaterWell Deserialize(BufferStream stream, WaterWell instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.pressure = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.waterLevel = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WaterWell DeserializeLengthDelimited(BufferStream stream, WaterWell instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.pressure = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.waterLevel = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WaterWell DeserializeLength(BufferStream stream, int length, WaterWell instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.pressure = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.waterLevel = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WaterWell instance, WaterWell previous)
	{
		if (instance.pressure != previous.pressure)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.pressure);
		}
		if (instance.waterLevel != previous.waterLevel)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.waterLevel);
		}
	}

	public static void Serialize(BufferStream stream, WaterWell instance)
	{
		if (instance.pressure != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.pressure);
		}
		if (instance.waterLevel != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.waterLevel);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class HotAirBalloon : IDisposable, IPooled, IProto<HotAirBalloon>, IProto
{
	[NonSerialized]
	public float inflationAmount;

	[NonSerialized]
	public Vector3 velocity;

	[NonSerialized]
	public float sinceLastBlast;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(HotAirBalloon instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.inflationAmount = 0f;
			instance.velocity = default(Vector3);
			instance.sinceLastBlast = 0f;
			Pool.Free<HotAirBalloon>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose HotAirBalloon with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(HotAirBalloon instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.inflationAmount = inflationAmount;
		instance.velocity = velocity;
		instance.sinceLastBlast = sinceLastBlast;
	}

	public HotAirBalloon Copy()
	{
		HotAirBalloon hotAirBalloon = Pool.Get<HotAirBalloon>();
		CopyTo(hotAirBalloon);
		return hotAirBalloon;
	}

	public static HotAirBalloon Deserialize(BufferStream stream)
	{
		HotAirBalloon hotAirBalloon = Pool.Get<HotAirBalloon>();
		Deserialize(stream, hotAirBalloon, isDelta: false);
		return hotAirBalloon;
	}

	public static HotAirBalloon DeserializeLengthDelimited(BufferStream stream)
	{
		HotAirBalloon hotAirBalloon = Pool.Get<HotAirBalloon>();
		DeserializeLengthDelimited(stream, hotAirBalloon, isDelta: false);
		return hotAirBalloon;
	}

	public static HotAirBalloon DeserializeLength(BufferStream stream, int length)
	{
		HotAirBalloon hotAirBalloon = Pool.Get<HotAirBalloon>();
		DeserializeLength(stream, length, hotAirBalloon, isDelta: false);
		return hotAirBalloon;
	}

	public static HotAirBalloon Deserialize(byte[] buffer)
	{
		HotAirBalloon hotAirBalloon = Pool.Get<HotAirBalloon>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, hotAirBalloon, isDelta: false);
		return hotAirBalloon;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, HotAirBalloon previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static HotAirBalloon Deserialize(BufferStream stream, HotAirBalloon instance, bool isDelta)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.inflationAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.velocity, isDelta);
				continue;
			case 29:
				instance.sinceLastBlast = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static HotAirBalloon DeserializeLengthDelimited(BufferStream stream, HotAirBalloon instance, bool isDelta)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.inflationAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.velocity, isDelta);
				continue;
			case 29:
				instance.sinceLastBlast = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static HotAirBalloon DeserializeLength(BufferStream stream, int length, HotAirBalloon instance, bool isDelta)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.inflationAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.velocity, isDelta);
				continue;
			case 29:
				instance.sinceLastBlast = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, HotAirBalloon instance, HotAirBalloon previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.inflationAmount != previous.inflationAmount)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.inflationAmount);
		}
		if (instance.velocity != previous.velocity)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.velocity, previous.velocity);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field velocity (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.sinceLastBlast != previous.sinceLastBlast)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.sinceLastBlast);
		}
	}

	public static void Serialize(BufferStream stream, HotAirBalloon instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (instance.inflationAmount != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.inflationAmount);
		}
		if (instance.velocity != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.velocity);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field velocity (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.sinceLastBlast != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.sinceLastBlast);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class SAMSite : IDisposable, IPooled, IProto<SAMSite>, IProto
{
	[NonSerialized]
	public Vector3 aimDir;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SAMSite instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.aimDir = default(Vector3);
			Pool.Free<SAMSite>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SAMSite with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SAMSite instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.aimDir = aimDir;
	}

	public SAMSite Copy()
	{
		SAMSite sAMSite = Pool.Get<SAMSite>();
		CopyTo(sAMSite);
		return sAMSite;
	}

	public static SAMSite Deserialize(BufferStream stream)
	{
		SAMSite sAMSite = Pool.Get<SAMSite>();
		Deserialize(stream, sAMSite, isDelta: false);
		return sAMSite;
	}

	public static SAMSite DeserializeLengthDelimited(BufferStream stream)
	{
		SAMSite sAMSite = Pool.Get<SAMSite>();
		DeserializeLengthDelimited(stream, sAMSite, isDelta: false);
		return sAMSite;
	}

	public static SAMSite DeserializeLength(BufferStream stream, int length)
	{
		SAMSite sAMSite = Pool.Get<SAMSite>();
		DeserializeLength(stream, length, sAMSite, isDelta: false);
		return sAMSite;
	}

	public static SAMSite Deserialize(byte[] buffer)
	{
		SAMSite sAMSite = Pool.Get<SAMSite>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sAMSite, isDelta: false);
		return sAMSite;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SAMSite previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SAMSite Deserialize(BufferStream stream, SAMSite instance, bool isDelta)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SAMSite DeserializeLengthDelimited(BufferStream stream, SAMSite instance, bool isDelta)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SAMSite DeserializeLength(BufferStream stream, int length, SAMSite instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SAMSite instance, SAMSite previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aimDir != previous.aimDir)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aimDir, previous.aimDir);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, SAMSite instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aimDir != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aimDir);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Motorboat : IDisposable, IPooled, IProto<Motorboat>, IProto
{
	[NonSerialized]
	public NetworkableId storageid;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Motorboat instance)
	{
		if (instance.ShouldPool)
		{
			instance.storageid = default(NetworkableId);
			instance.fuelStorageID = default(NetworkableId);
			Pool.Free<Motorboat>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Motorboat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Motorboat instance)
	{
		instance.storageid = storageid;
		instance.fuelStorageID = fuelStorageID;
	}

	public Motorboat Copy()
	{
		Motorboat motorboat = Pool.Get<Motorboat>();
		CopyTo(motorboat);
		return motorboat;
	}

	public static Motorboat Deserialize(BufferStream stream)
	{
		Motorboat motorboat = Pool.Get<Motorboat>();
		Deserialize(stream, motorboat, isDelta: false);
		return motorboat;
	}

	public static Motorboat DeserializeLengthDelimited(BufferStream stream)
	{
		Motorboat motorboat = Pool.Get<Motorboat>();
		DeserializeLengthDelimited(stream, motorboat, isDelta: false);
		return motorboat;
	}

	public static Motorboat DeserializeLength(BufferStream stream, int length)
	{
		Motorboat motorboat = Pool.Get<Motorboat>();
		DeserializeLength(stream, length, motorboat, isDelta: false);
		return motorboat;
	}

	public static Motorboat Deserialize(byte[] buffer)
	{
		Motorboat motorboat = Pool.Get<Motorboat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, motorboat, isDelta: false);
		return motorboat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Motorboat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Motorboat Deserialize(BufferStream stream, Motorboat instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.storageid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Motorboat DeserializeLengthDelimited(BufferStream stream, Motorboat instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.storageid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Motorboat DeserializeLength(BufferStream stream, int length, Motorboat instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.storageid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Motorboat instance, Motorboat previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.storageid.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
	}

	public static void Serialize(BufferStream stream, Motorboat instance)
	{
		if (instance.storageid != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.storageid.Value);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref storageid.Value);
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Minicopter : IDisposable, IPooled, IProto<Minicopter>, IProto
{
	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelFraction;

	[NonSerialized]
	public float pitch;

	[NonSerialized]
	public float roll;

	[NonSerialized]
	public float yaw;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Minicopter instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelFraction = 0f;
			instance.pitch = 0f;
			instance.roll = 0f;
			instance.yaw = 0f;
			Pool.Free<Minicopter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Minicopter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Minicopter instance)
	{
		instance.fuelStorageID = fuelStorageID;
		instance.fuelFraction = fuelFraction;
		instance.pitch = pitch;
		instance.roll = roll;
		instance.yaw = yaw;
	}

	public Minicopter Copy()
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		CopyTo(minicopter);
		return minicopter;
	}

	public static Minicopter Deserialize(BufferStream stream)
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		Deserialize(stream, minicopter, isDelta: false);
		return minicopter;
	}

	public static Minicopter DeserializeLengthDelimited(BufferStream stream)
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		DeserializeLengthDelimited(stream, minicopter, isDelta: false);
		return minicopter;
	}

	public static Minicopter DeserializeLength(BufferStream stream, int length)
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		DeserializeLength(stream, length, minicopter, isDelta: false);
		return minicopter;
	}

	public static Minicopter Deserialize(byte[] buffer)
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, minicopter, isDelta: false);
		return minicopter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Minicopter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Minicopter Deserialize(BufferStream stream, Minicopter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.roll = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Minicopter DeserializeLengthDelimited(BufferStream stream, Minicopter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.roll = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Minicopter DeserializeLength(BufferStream stream, int length, Minicopter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.roll = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Minicopter instance, Minicopter previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.pitch != previous.pitch)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
		if (instance.roll != previous.roll)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.roll);
		}
		if (instance.yaw != previous.yaw)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
	}

	public static void Serialize(BufferStream stream, Minicopter instance)
	{
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.pitch != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
		if (instance.roll != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.roll);
		}
		if (instance.yaw != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ModularVehicle : IDisposable, IPooled, IProto<ModularVehicle>, IProto
{
	[NonSerialized]
	public bool editable;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ModularVehicle instance)
	{
		if (instance.ShouldPool)
		{
			instance.editable = false;
			Pool.Free<ModularVehicle>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ModularVehicle with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ModularVehicle instance)
	{
		instance.editable = editable;
	}

	public ModularVehicle Copy()
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		CopyTo(modularVehicle);
		return modularVehicle;
	}

	public static ModularVehicle Deserialize(BufferStream stream)
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		Deserialize(stream, modularVehicle, isDelta: false);
		return modularVehicle;
	}

	public static ModularVehicle DeserializeLengthDelimited(BufferStream stream)
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		DeserializeLengthDelimited(stream, modularVehicle, isDelta: false);
		return modularVehicle;
	}

	public static ModularVehicle DeserializeLength(BufferStream stream, int length)
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		DeserializeLength(stream, length, modularVehicle, isDelta: false);
		return modularVehicle;
	}

	public static ModularVehicle Deserialize(byte[] buffer)
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, modularVehicle, isDelta: false);
		return modularVehicle;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ModularVehicle previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ModularVehicle Deserialize(BufferStream stream, ModularVehicle instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.editable = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ModularVehicle DeserializeLengthDelimited(BufferStream stream, ModularVehicle instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.editable = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ModularVehicle DeserializeLength(BufferStream stream, int length, ModularVehicle instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.editable = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ModularVehicle instance, ModularVehicle previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.editable);
	}

	public static void Serialize(BufferStream stream, ModularVehicle instance)
	{
		if (instance.editable)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.editable);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ModularCar : IDisposable, IPooled, IProto<ModularCar>, IProto
{
	[NonSerialized]
	public float steerAngle;

	[NonSerialized]
	public float driveWheelVel;

	[NonSerialized]
	public float throttleInput;

	[NonSerialized]
	public float brakeInput;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelFraction;

	[NonSerialized]
	public bool hasLock;

	[NonSerialized]
	public string lockCode;

	[NonSerialized]
	public List<ulong> whitelistUsers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ModularCar instance)
	{
		if (instance.ShouldPool)
		{
			instance.steerAngle = 0f;
			instance.driveWheelVel = 0f;
			instance.throttleInput = 0f;
			instance.brakeInput = 0f;
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelFraction = 0f;
			instance.hasLock = false;
			instance.lockCode = string.Empty;
			if (instance.whitelistUsers != null)
			{
				List<ulong> list = instance.whitelistUsers;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.whitelistUsers = list;
			}
			Pool.Free<ModularCar>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ModularCar with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ModularCar instance)
	{
		instance.steerAngle = steerAngle;
		instance.driveWheelVel = driveWheelVel;
		instance.throttleInput = throttleInput;
		instance.brakeInput = brakeInput;
		instance.fuelStorageID = fuelStorageID;
		instance.fuelFraction = fuelFraction;
		instance.hasLock = hasLock;
		instance.lockCode = lockCode;
		if (whitelistUsers != null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
			for (int i = 0; i < whitelistUsers.Count; i++)
			{
				ulong item = whitelistUsers[i];
				instance.whitelistUsers.Add(item);
			}
		}
		else
		{
			instance.whitelistUsers = null;
		}
	}

	public ModularCar Copy()
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		CopyTo(modularCar);
		return modularCar;
	}

	public static ModularCar Deserialize(BufferStream stream)
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		Deserialize(stream, modularCar, isDelta: false);
		return modularCar;
	}

	public static ModularCar DeserializeLengthDelimited(BufferStream stream)
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		DeserializeLengthDelimited(stream, modularCar, isDelta: false);
		return modularCar;
	}

	public static ModularCar DeserializeLength(BufferStream stream, int length)
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		DeserializeLength(stream, length, modularCar, isDelta: false);
		return modularCar;
	}

	public static ModularCar Deserialize(byte[] buffer)
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, modularCar, isDelta: false);
		return modularCar;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ModularCar previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ModularCar Deserialize(BufferStream stream, ModularCar instance, bool isDelta)
	{
		if (!isDelta && instance.whitelistUsers == null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.steerAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 53:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.whitelistUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ModularCar DeserializeLengthDelimited(BufferStream stream, ModularCar instance, bool isDelta)
	{
		if (!isDelta && instance.whitelistUsers == null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 53:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.whitelistUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ModularCar DeserializeLength(BufferStream stream, int length, ModularCar instance, bool isDelta)
	{
		if (!isDelta && instance.whitelistUsers == null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 53:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.whitelistUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ModularCar instance, ModularCar previous)
	{
		if (instance.steerAngle != previous.steerAngle)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerAngle);
		}
		if (instance.driveWheelVel != previous.driveWheelVel)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != previous.throttleInput)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != previous.brakeInput)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.hasLock);
		if (instance.lockCode != null && instance.lockCode != previous.lockCode)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.lockCode);
		}
		if (instance.whitelistUsers != null)
		{
			for (int i = 0; i < instance.whitelistUsers.Count; i++)
			{
				ulong val = instance.whitelistUsers[i];
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, ModularCar instance)
	{
		if (instance.steerAngle != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerAngle);
		}
		if (instance.driveWheelVel != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.hasLock)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.hasLock);
		}
		if (instance.lockCode != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.lockCode);
		}
		if (instance.whitelistUsers != null)
		{
			for (int i = 0; i < instance.whitelistUsers.Count; i++)
			{
				ulong val = instance.whitelistUsers[i];
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SimpleUID : IDisposable, IPooled, IProto<SimpleUID>, IProto
{
	[NonSerialized]
	public NetworkableId uid;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SimpleUID instance)
	{
		if (instance.ShouldPool)
		{
			instance.uid = default(NetworkableId);
			Pool.Free<SimpleUID>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SimpleUID with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SimpleUID instance)
	{
		instance.uid = uid;
	}

	public SimpleUID Copy()
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		CopyTo(simpleUID);
		return simpleUID;
	}

	public static SimpleUID Deserialize(BufferStream stream)
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		Deserialize(stream, simpleUID, isDelta: false);
		return simpleUID;
	}

	public static SimpleUID DeserializeLengthDelimited(BufferStream stream)
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		DeserializeLengthDelimited(stream, simpleUID, isDelta: false);
		return simpleUID;
	}

	public static SimpleUID DeserializeLength(BufferStream stream, int length)
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		DeserializeLength(stream, length, simpleUID, isDelta: false);
		return simpleUID;
	}

	public static SimpleUID Deserialize(byte[] buffer)
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, simpleUID, isDelta: false);
		return simpleUID;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SimpleUID previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SimpleUID Deserialize(BufferStream stream, SimpleUID instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SimpleUID DeserializeLengthDelimited(BufferStream stream, SimpleUID instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SimpleUID DeserializeLength(BufferStream stream, int length, SimpleUID instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SimpleUID instance, SimpleUID previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.uid.Value);
	}

	public static void Serialize(BufferStream stream, SimpleUID instance)
	{
		if (instance.uid != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref uid.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SimpleUInt : IDisposable, IPooled, IProto<SimpleUInt>, IProto
{
	[NonSerialized]
	public uint value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SimpleUInt instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0u;
			Pool.Free<SimpleUInt>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SimpleUInt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SimpleUInt instance)
	{
		instance.value = value;
	}

	public SimpleUInt Copy()
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		CopyTo(simpleUInt);
		return simpleUInt;
	}

	public static SimpleUInt Deserialize(BufferStream stream)
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		Deserialize(stream, simpleUInt, isDelta: false);
		return simpleUInt;
	}

	public static SimpleUInt DeserializeLengthDelimited(BufferStream stream)
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		DeserializeLengthDelimited(stream, simpleUInt, isDelta: false);
		return simpleUInt;
	}

	public static SimpleUInt DeserializeLength(BufferStream stream, int length)
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		DeserializeLength(stream, length, simpleUInt, isDelta: false);
		return simpleUInt;
	}

	public static SimpleUInt Deserialize(byte[] buffer)
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, simpleUInt, isDelta: false);
		return simpleUInt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SimpleUInt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SimpleUInt Deserialize(BufferStream stream, SimpleUInt instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SimpleUInt DeserializeLengthDelimited(BufferStream stream, SimpleUInt instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SimpleUInt DeserializeLength(BufferStream stream, int length, SimpleUInt instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SimpleUInt instance, SimpleUInt previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, SimpleUInt instance)
	{
		if (instance.value != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SimpleInt : IDisposable, IPooled, IProto<SimpleInt>, IProto
{
	[NonSerialized]
	public int value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SimpleInt instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0;
			Pool.Free<SimpleInt>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SimpleInt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SimpleInt instance)
	{
		instance.value = value;
	}

	public SimpleInt Copy()
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		CopyTo(simpleInt);
		return simpleInt;
	}

	public static SimpleInt Deserialize(BufferStream stream)
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		Deserialize(stream, simpleInt, isDelta: false);
		return simpleInt;
	}

	public static SimpleInt DeserializeLengthDelimited(BufferStream stream)
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		DeserializeLengthDelimited(stream, simpleInt, isDelta: false);
		return simpleInt;
	}

	public static SimpleInt DeserializeLength(BufferStream stream, int length)
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		DeserializeLength(stream, length, simpleInt, isDelta: false);
		return simpleInt;
	}

	public static SimpleInt Deserialize(byte[] buffer)
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, simpleInt, isDelta: false);
		return simpleInt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SimpleInt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SimpleInt Deserialize(BufferStream stream, SimpleInt instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SimpleInt DeserializeLengthDelimited(BufferStream stream, SimpleInt instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SimpleInt DeserializeLength(BufferStream stream, int length, SimpleInt instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SimpleInt instance, SimpleInt previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
		}
	}

	public static void Serialize(BufferStream stream, SimpleInt instance)
	{
		if (instance.value != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VehicleLift : IDisposable, IPooled, IProto<VehicleLift>, IProto
{
	[NonSerialized]
	public bool platformIsOccupied;

	[NonSerialized]
	public bool editableOccupant;

	[NonSerialized]
	public bool driveableOccupant;

	[NonSerialized]
	public int occupantLockState;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VehicleLift instance)
	{
		if (instance.ShouldPool)
		{
			instance.platformIsOccupied = false;
			instance.editableOccupant = false;
			instance.driveableOccupant = false;
			instance.occupantLockState = 0;
			Pool.Free<VehicleLift>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VehicleLift with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VehicleLift instance)
	{
		instance.platformIsOccupied = platformIsOccupied;
		instance.editableOccupant = editableOccupant;
		instance.driveableOccupant = driveableOccupant;
		instance.occupantLockState = occupantLockState;
	}

	public VehicleLift Copy()
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		CopyTo(vehicleLift);
		return vehicleLift;
	}

	public static VehicleLift Deserialize(BufferStream stream)
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		Deserialize(stream, vehicleLift, isDelta: false);
		return vehicleLift;
	}

	public static VehicleLift DeserializeLengthDelimited(BufferStream stream)
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		DeserializeLengthDelimited(stream, vehicleLift, isDelta: false);
		return vehicleLift;
	}

	public static VehicleLift DeserializeLength(BufferStream stream, int length)
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		DeserializeLength(stream, length, vehicleLift, isDelta: false);
		return vehicleLift;
	}

	public static VehicleLift Deserialize(byte[] buffer)
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vehicleLift, isDelta: false);
		return vehicleLift;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VehicleLift previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VehicleLift Deserialize(BufferStream stream, VehicleLift instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.platformIsOccupied = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.editableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.driveableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.occupantLockState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VehicleLift DeserializeLengthDelimited(BufferStream stream, VehicleLift instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.platformIsOccupied = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.editableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.driveableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.occupantLockState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VehicleLift DeserializeLength(BufferStream stream, int length, VehicleLift instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.platformIsOccupied = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.editableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.driveableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.occupantLockState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VehicleLift instance, VehicleLift previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.platformIsOccupied);
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.editableOccupant);
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.driveableOccupant);
		if (instance.occupantLockState != previous.occupantLockState)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.occupantLockState);
		}
	}

	public static void Serialize(BufferStream stream, VehicleLift instance)
	{
		if (instance.platformIsOccupied)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.platformIsOccupied);
		}
		if (instance.editableOccupant)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.editableOccupant);
		}
		if (instance.driveableOccupant)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.driveableOccupant);
		}
		if (instance.occupantLockState != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.occupantLockState);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class EngineStorage : IDisposable, IPooled, IProto<EngineStorage>, IProto
{
	[NonSerialized]
	public bool isUsable;

	[NonSerialized]
	public float accelerationBoost;

	[NonSerialized]
	public float topSpeedBoost;

	[NonSerialized]
	public float fuelEconomyBoost;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EngineStorage instance)
	{
		if (instance.ShouldPool)
		{
			instance.isUsable = false;
			instance.accelerationBoost = 0f;
			instance.topSpeedBoost = 0f;
			instance.fuelEconomyBoost = 0f;
			Pool.Free<EngineStorage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EngineStorage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EngineStorage instance)
	{
		instance.isUsable = isUsable;
		instance.accelerationBoost = accelerationBoost;
		instance.topSpeedBoost = topSpeedBoost;
		instance.fuelEconomyBoost = fuelEconomyBoost;
	}

	public EngineStorage Copy()
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		CopyTo(engineStorage);
		return engineStorage;
	}

	public static EngineStorage Deserialize(BufferStream stream)
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		Deserialize(stream, engineStorage, isDelta: false);
		return engineStorage;
	}

	public static EngineStorage DeserializeLengthDelimited(BufferStream stream)
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		DeserializeLengthDelimited(stream, engineStorage, isDelta: false);
		return engineStorage;
	}

	public static EngineStorage DeserializeLength(BufferStream stream, int length)
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		DeserializeLength(stream, length, engineStorage, isDelta: false);
		return engineStorage;
	}

	public static EngineStorage Deserialize(byte[] buffer)
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, engineStorage, isDelta: false);
		return engineStorage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EngineStorage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EngineStorage Deserialize(BufferStream stream, EngineStorage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.isUsable = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.accelerationBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.topSpeedBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.fuelEconomyBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EngineStorage DeserializeLengthDelimited(BufferStream stream, EngineStorage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.isUsable = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.accelerationBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.topSpeedBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.fuelEconomyBoost = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EngineStorage DeserializeLength(BufferStream stream, int length, EngineStorage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.isUsable = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.accelerationBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.topSpeedBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.fuelEconomyBoost = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EngineStorage instance, EngineStorage previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.isUsable);
		if (instance.accelerationBoost != previous.accelerationBoost)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.accelerationBoost);
		}
		if (instance.topSpeedBoost != previous.topSpeedBoost)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.topSpeedBoost);
		}
		if (instance.fuelEconomyBoost != previous.fuelEconomyBoost)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.fuelEconomyBoost);
		}
	}

	public static void Serialize(BufferStream stream, EngineStorage instance)
	{
		if (instance.isUsable)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.isUsable);
		}
		if (instance.accelerationBoost != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.accelerationBoost);
		}
		if (instance.topSpeedBoost != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.topSpeedBoost);
		}
		if (instance.fuelEconomyBoost != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.fuelEconomyBoost);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class IOEntity : IDisposable, IPooled, IProto<IOEntity>, IProto
{
	public class IOConnection : IDisposable, IPooled, IProto<IOConnection>, IProto
	{
		public class LineVec : IDisposable, IPooled, IProto<LineVec>, IProto
		{
			[NonSerialized]
			public Vector4 vec;

			public bool ShouldPool = true;

			private bool _disposed;

			public static void ResetToPool(LineVec instance)
			{
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				if (instance.ShouldPool)
				{
					instance.vec = default(Vector4);
					Pool.Free<LineVec>(ref instance);
				}
			}

			public void ResetToPool()
			{
				ResetToPool(this);
			}

			public virtual void Dispose()
			{
				if (!ShouldPool)
				{
					throw new Exception("Trying to dispose LineVec with ShouldPool set to false!");
				}
				if (!_disposed)
				{
					ResetToPool();
					_disposed = true;
				}
			}

			public virtual void EnterPool()
			{
				_disposed = true;
			}

			public virtual void LeavePool()
			{
				_disposed = false;
			}

			public void CopyTo(LineVec instance)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				instance.vec = vec;
			}

			public LineVec Copy()
			{
				LineVec lineVec = Pool.Get<LineVec>();
				CopyTo(lineVec);
				return lineVec;
			}

			public static LineVec Deserialize(BufferStream stream)
			{
				LineVec lineVec = Pool.Get<LineVec>();
				Deserialize(stream, lineVec, isDelta: false);
				return lineVec;
			}

			public static LineVec DeserializeLengthDelimited(BufferStream stream)
			{
				LineVec lineVec = Pool.Get<LineVec>();
				DeserializeLengthDelimited(stream, lineVec, isDelta: false);
				return lineVec;
			}

			public static LineVec DeserializeLength(BufferStream stream, int length)
			{
				LineVec lineVec = Pool.Get<LineVec>();
				DeserializeLength(stream, length, lineVec, isDelta: false);
				return lineVec;
			}

			public static LineVec Deserialize(byte[] buffer)
			{
				LineVec lineVec = Pool.Get<LineVec>();
				using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
				Deserialize(stream, lineVec, isDelta: false);
				return lineVec;
			}

			public void FromProto(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void WriteToStream(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public virtual void WriteToStreamDelta(BufferStream stream, LineVec previous)
			{
				if (previous == null)
				{
					Serialize(stream, this);
				}
				else
				{
					SerializeDelta(stream, this, previous);
				}
			}

			public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
			{
				DeserializeLength(stream, size, this, isDelta);
			}

			public static LineVec Deserialize(BufferStream stream, LineVec instance, bool isDelta)
			{
				//IL_001a: Unknown result type (might be due to invalid IL or missing references)
				while (true)
				{
					int num = stream.ReadByte();
					switch (num)
					{
					case 10:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
						continue;
					case -1:
						return instance;
					}
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
			}

			public static LineVec DeserializeLengthDelimited(BufferStream stream, LineVec instance, bool isDelta)
			{
				//IL_0051: Unknown result type (might be due to invalid IL or missing references)
				long num = ProtocolParser.ReadUInt32(stream);
				num += stream.Position;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static LineVec DeserializeLength(BufferStream stream, int length, LineVec instance, bool isDelta)
			{
				//IL_0049: Unknown result type (might be due to invalid IL or missing references)
				long num = stream.Position + length;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static void SerializeDelta(BufferStream stream, LineVec instance, LineVec previous)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_002c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0032: Unknown result type (might be due to invalid IL or missing references)
				if (instance.vec != previous.vec)
				{
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.vec, previous.vec);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}

			public static void Serialize(BufferStream stream, LineVec instance)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0008: Unknown result type (might be due to invalid IL or missing references)
				//IL_000e: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				if (instance.vec != default(Vector4))
				{
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Vector4Serialized.Serialize(stream, instance.vec);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}

			public void ToProto(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public void InspectUids(UidInspector<ulong> action)
			{
			}
		}

		public class LinePointList : IDisposable, IPooled, IProto<LinePointList>, IProto
		{
			[NonSerialized]
			public Vector4 a;

			[NonSerialized]
			public Vector4 b;

			[NonSerialized]
			public Vector4 c;

			[NonSerialized]
			public Vector4 d;

			[NonSerialized]
			public Vector4 e;

			[NonSerialized]
			public Vector4 f;

			[NonSerialized]
			public Vector4 g;

			[NonSerialized]
			public Vector4 h;

			public bool ShouldPool = true;

			private bool _disposed;

			public static void ResetToPool(LinePointList instance)
			{
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0027: Unknown result type (might be due to invalid IL or missing references)
				//IL_0033: Unknown result type (might be due to invalid IL or missing references)
				//IL_003f: Unknown result type (might be due to invalid IL or missing references)
				//IL_004b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0057: Unknown result type (might be due to invalid IL or missing references)
				//IL_0063: Unknown result type (might be due to invalid IL or missing references)
				if (instance.ShouldPool)
				{
					instance.a = default(Vector4);
					instance.b = default(Vector4);
					instance.c = default(Vector4);
					instance.d = default(Vector4);
					instance.e = default(Vector4);
					instance.f = default(Vector4);
					instance.g = default(Vector4);
					instance.h = default(Vector4);
					Pool.Free<LinePointList>(ref instance);
				}
			}

			public void ResetToPool()
			{
				ResetToPool(this);
			}

			public virtual void Dispose()
			{
				if (!ShouldPool)
				{
					throw new Exception("Trying to dispose LinePointList with ShouldPool set to false!");
				}
				if (!_disposed)
				{
					ResetToPool();
					_disposed = true;
				}
			}

			public virtual void EnterPool()
			{
				_disposed = true;
			}

			public virtual void LeavePool()
			{
				_disposed = false;
			}

			public void CopyTo(LinePointList instance)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_000e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_001a: Unknown result type (might be due to invalid IL or missing references)
				//IL_001f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_002b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0032: Unknown result type (might be due to invalid IL or missing references)
				//IL_0037: Unknown result type (might be due to invalid IL or missing references)
				//IL_003e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_004a: Unknown result type (might be due to invalid IL or missing references)
				//IL_004f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0056: Unknown result type (might be due to invalid IL or missing references)
				//IL_005b: Unknown result type (might be due to invalid IL or missing references)
				instance.a = a;
				instance.b = b;
				instance.c = c;
				instance.d = d;
				instance.e = e;
				instance.f = f;
				instance.g = g;
				instance.h = h;
			}

			public LinePointList Copy()
			{
				LinePointList linePointList = Pool.Get<LinePointList>();
				CopyTo(linePointList);
				return linePointList;
			}

			public static LinePointList Deserialize(BufferStream stream)
			{
				LinePointList linePointList = Pool.Get<LinePointList>();
				Deserialize(stream, linePointList, isDelta: false);
				return linePointList;
			}

			public static LinePointList DeserializeLengthDelimited(BufferStream stream)
			{
				LinePointList linePointList = Pool.Get<LinePointList>();
				DeserializeLengthDelimited(stream, linePointList, isDelta: false);
				return linePointList;
			}

			public static LinePointList DeserializeLength(BufferStream stream, int length)
			{
				LinePointList linePointList = Pool.Get<LinePointList>();
				DeserializeLength(stream, length, linePointList, isDelta: false);
				return linePointList;
			}

			public static LinePointList Deserialize(byte[] buffer)
			{
				LinePointList linePointList = Pool.Get<LinePointList>();
				using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
				Deserialize(stream, linePointList, isDelta: false);
				return linePointList;
			}

			public void FromProto(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void WriteToStream(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public virtual void WriteToStreamDelta(BufferStream stream, LinePointList previous)
			{
				if (previous == null)
				{
					Serialize(stream, this);
				}
				else
				{
					SerializeDelta(stream, this, previous);
				}
			}

			public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
			{
				DeserializeLength(stream, size, this, isDelta);
			}

			public static LinePointList Deserialize(BufferStream stream, LinePointList instance, bool isDelta)
			{
				//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
				//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
				//IL_0086: Unknown result type (might be due to invalid IL or missing references)
				//IL_0066: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
				//IL_0099: Unknown result type (might be due to invalid IL or missing references)
				//IL_0076: Unknown result type (might be due to invalid IL or missing references)
				while (true)
				{
					int num = stream.ReadByte();
					switch (num)
					{
					case 10:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
						continue;
					case 18:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
						continue;
					case 26:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
						continue;
					case 34:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
						continue;
					case 42:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
						continue;
					case 50:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
						continue;
					case 58:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
						continue;
					case 66:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
						continue;
					case -1:
						return instance;
					}
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
			}

			public static LinePointList DeserializeLengthDelimited(BufferStream stream, LinePointList instance, bool isDelta)
			{
				//IL_010f: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
				//IL_009d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0122: Unknown result type (might be due to invalid IL or missing references)
				//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
				long num = ProtocolParser.ReadUInt32(stream);
				num += stream.Position;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
						continue;
					case 18:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
						continue;
					case 26:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
						continue;
					case 34:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
						continue;
					case 42:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
						continue;
					case 50:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
						continue;
					case 58:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
						continue;
					case 66:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static LinePointList DeserializeLength(BufferStream stream, int length, LinePointList instance, bool isDelta)
			{
				//IL_0107: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
				//IL_0095: Unknown result type (might be due to invalid IL or missing references)
				//IL_011a: Unknown result type (might be due to invalid IL or missing references)
				//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
				//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
				long num = stream.Position + length;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
						continue;
					case 18:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
						continue;
					case 26:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
						continue;
					case 34:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
						continue;
					case 42:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
						continue;
					case 50:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
						continue;
					case 58:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
						continue;
					case 66:
						Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static void SerializeDelta(BufferStream stream, LinePointList instance, LinePointList previous)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_0065: Unknown result type (might be due to invalid IL or missing references)
				//IL_006b: Unknown result type (might be due to invalid IL or missing references)
				//IL_002c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0032: Unknown result type (might be due to invalid IL or missing references)
				//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
				//IL_0091: Unknown result type (might be due to invalid IL or missing references)
				//IL_0097: Unknown result type (might be due to invalid IL or missing references)
				//IL_0136: Unknown result type (might be due to invalid IL or missing references)
				//IL_013c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
				//IL_0100: Unknown result type (might be due to invalid IL or missing references)
				//IL_019f: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
				//IL_0163: Unknown result type (might be due to invalid IL or missing references)
				//IL_0169: Unknown result type (might be due to invalid IL or missing references)
				//IL_0208: Unknown result type (might be due to invalid IL or missing references)
				//IL_020e: Unknown result type (might be due to invalid IL or missing references)
				//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
				//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
				//IL_0271: Unknown result type (might be due to invalid IL or missing references)
				//IL_0277: Unknown result type (might be due to invalid IL or missing references)
				//IL_0235: Unknown result type (might be due to invalid IL or missing references)
				//IL_023b: Unknown result type (might be due to invalid IL or missing references)
				//IL_02da: Unknown result type (might be due to invalid IL or missing references)
				//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
				//IL_029e: Unknown result type (might be due to invalid IL or missing references)
				//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
				//IL_0307: Unknown result type (might be due to invalid IL or missing references)
				//IL_030d: Unknown result type (might be due to invalid IL or missing references)
				if (instance.a != previous.a)
				{
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.a, previous.a);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
				if (instance.b != previous.b)
				{
					stream.WriteByte(18);
					BufferStream.RangeHandle range2 = stream.GetRange(1);
					int position2 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.b, previous.b);
					int num2 = stream.Position - position2;
					if (num2 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
					}
					Span<byte> span2 = range2.GetSpan();
					ProtocolParser.WriteUInt32((uint)num2, span2, 0);
				}
				if (instance.c != previous.c)
				{
					stream.WriteByte(26);
					BufferStream.RangeHandle range3 = stream.GetRange(1);
					int position3 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.c, previous.c);
					int num3 = stream.Position - position3;
					if (num3 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
					}
					Span<byte> span3 = range3.GetSpan();
					ProtocolParser.WriteUInt32((uint)num3, span3, 0);
				}
				if (instance.d != previous.d)
				{
					stream.WriteByte(34);
					BufferStream.RangeHandle range4 = stream.GetRange(1);
					int position4 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.d, previous.d);
					int num4 = stream.Position - position4;
					if (num4 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
					}
					Span<byte> span4 = range4.GetSpan();
					ProtocolParser.WriteUInt32((uint)num4, span4, 0);
				}
				if (instance.e != previous.e)
				{
					stream.WriteByte(42);
					BufferStream.RangeHandle range5 = stream.GetRange(1);
					int position5 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.e, previous.e);
					int num5 = stream.Position - position5;
					if (num5 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
					}
					Span<byte> span5 = range5.GetSpan();
					ProtocolParser.WriteUInt32((uint)num5, span5, 0);
				}
				if (instance.f != previous.f)
				{
					stream.WriteByte(50);
					BufferStream.RangeHandle range6 = stream.GetRange(1);
					int position6 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.f, previous.f);
					int num6 = stream.Position - position6;
					if (num6 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
					}
					Span<byte> span6 = range6.GetSpan();
					ProtocolParser.WriteUInt32((uint)num6, span6, 0);
				}
				if (instance.g != previous.g)
				{
					stream.WriteByte(58);
					BufferStream.RangeHandle range7 = stream.GetRange(1);
					int position7 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.g, previous.g);
					int num7 = stream.Position - position7;
					if (num7 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
					}
					Span<byte> span7 = range7.GetSpan();
					ProtocolParser.WriteUInt32((uint)num7, span7, 0);
				}
				if (instance.h != previous.h)
				{
					stream.WriteByte(66);
					BufferStream.RangeHandle range8 = stream.GetRange(1);
					int position8 = stream.Position;
					Vector4Serialized.SerializeDelta(stream, instance.h, previous.h);
					int num8 = stream.Position - position8;
					if (num8 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
					}
					Span<byte> span8 = range8.GetSpan();
					ProtocolParser.WriteUInt32((uint)num8, span8, 0);
				}
			}

			public static void Serialize(BufferStream stream, LinePointList instance)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0008: Unknown result type (might be due to invalid IL or missing references)
				//IL_000e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0069: Unknown result type (might be due to invalid IL or missing references)
				//IL_006f: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
				//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
				//IL_0092: Unknown result type (might be due to invalid IL or missing references)
				//IL_012e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0135: Unknown result type (might be due to invalid IL or missing references)
				//IL_013b: Unknown result type (might be due to invalid IL or missing references)
				//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
				//IL_0194: Unknown result type (might be due to invalid IL or missing references)
				//IL_019b: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
				//IL_015e: Unknown result type (might be due to invalid IL or missing references)
				//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
				//IL_0201: Unknown result type (might be due to invalid IL or missing references)
				//IL_0207: Unknown result type (might be due to invalid IL or missing references)
				//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
				//IL_0260: Unknown result type (might be due to invalid IL or missing references)
				//IL_0267: Unknown result type (might be due to invalid IL or missing references)
				//IL_026d: Unknown result type (might be due to invalid IL or missing references)
				//IL_022a: Unknown result type (might be due to invalid IL or missing references)
				//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
				//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
				//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
				//IL_0290: Unknown result type (might be due to invalid IL or missing references)
				//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
				if (instance.a != default(Vector4))
				{
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Vector4Serialized.Serialize(stream, instance.a);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
				if (instance.b != default(Vector4))
				{
					stream.WriteByte(18);
					BufferStream.RangeHandle range2 = stream.GetRange(1);
					int position2 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.b);
					int num2 = stream.Position - position2;
					if (num2 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
					}
					Span<byte> span2 = range2.GetSpan();
					ProtocolParser.WriteUInt32((uint)num2, span2, 0);
				}
				if (instance.c != default(Vector4))
				{
					stream.WriteByte(26);
					BufferStream.RangeHandle range3 = stream.GetRange(1);
					int position3 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.c);
					int num3 = stream.Position - position3;
					if (num3 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
					}
					Span<byte> span3 = range3.GetSpan();
					ProtocolParser.WriteUInt32((uint)num3, span3, 0);
				}
				if (instance.d != default(Vector4))
				{
					stream.WriteByte(34);
					BufferStream.RangeHandle range4 = stream.GetRange(1);
					int position4 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.d);
					int num4 = stream.Position - position4;
					if (num4 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
					}
					Span<byte> span4 = range4.GetSpan();
					ProtocolParser.WriteUInt32((uint)num4, span4, 0);
				}
				if (instance.e != default(Vector4))
				{
					stream.WriteByte(42);
					BufferStream.RangeHandle range5 = stream.GetRange(1);
					int position5 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.e);
					int num5 = stream.Position - position5;
					if (num5 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
					}
					Span<byte> span5 = range5.GetSpan();
					ProtocolParser.WriteUInt32((uint)num5, span5, 0);
				}
				if (instance.f != default(Vector4))
				{
					stream.WriteByte(50);
					BufferStream.RangeHandle range6 = stream.GetRange(1);
					int position6 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.f);
					int num6 = stream.Position - position6;
					if (num6 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
					}
					Span<byte> span6 = range6.GetSpan();
					ProtocolParser.WriteUInt32((uint)num6, span6, 0);
				}
				if (instance.g != default(Vector4))
				{
					stream.WriteByte(58);
					BufferStream.RangeHandle range7 = stream.GetRange(1);
					int position7 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.g);
					int num7 = stream.Position - position7;
					if (num7 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
					}
					Span<byte> span7 = range7.GetSpan();
					ProtocolParser.WriteUInt32((uint)num7, span7, 0);
				}
				if (instance.h != default(Vector4))
				{
					stream.WriteByte(66);
					BufferStream.RangeHandle range8 = stream.GetRange(1);
					int position8 = stream.Position;
					Vector4Serialized.Serialize(stream, instance.h);
					int num8 = stream.Position - position8;
					if (num8 > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
					}
					Span<byte> span8 = range8.GetSpan();
					ProtocolParser.WriteUInt32((uint)num8, span8, 0);
				}
			}

			public void ToProto(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public void InspectUids(UidInspector<ulong> action)
			{
			}
		}

		[NonSerialized]
		public string niceName;

		[NonSerialized]
		public int type;

		[NonSerialized]
		public NetworkableId connectedID;

		[NonSerialized]
		public int connectedToSlot;

		[NonSerialized]
		public bool inUse;

		[NonSerialized]
		public List<LineVec> linePointList;

		[NonSerialized]
		public int colour;

		[NonSerialized]
		public Vector3 worldSpaceRotation;

		[NonSerialized]
		public float lineThickness;

		[NonSerialized]
		public List<WireLineAnchorInfo> lineAnchorList;

		[NonSerialized]
		public Vector3 originPosition;

		[NonSerialized]
		public Vector3 originRotation;

		[NonSerialized]
		public List<float> slackLevels;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(IOConnection instance)
		{
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0119: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Unknown result type (might be due to invalid IL or missing references)
			if (!instance.ShouldPool)
			{
				return;
			}
			instance.niceName = string.Empty;
			instance.type = 0;
			instance.connectedID = default(NetworkableId);
			instance.connectedToSlot = 0;
			instance.inUse = false;
			if (instance.linePointList != null)
			{
				for (int i = 0; i < instance.linePointList.Count; i++)
				{
					if (instance.linePointList[i] != null)
					{
						instance.linePointList[i].ResetToPool();
						instance.linePointList[i] = null;
					}
				}
				List<LineVec> list = instance.linePointList;
				Pool.Free<LineVec>(ref list, false);
				instance.linePointList = list;
			}
			instance.colour = 0;
			instance.worldSpaceRotation = default(Vector3);
			instance.lineThickness = 0f;
			if (instance.lineAnchorList != null)
			{
				for (int j = 0; j < instance.lineAnchorList.Count; j++)
				{
					if (instance.lineAnchorList[j] != null)
					{
						instance.lineAnchorList[j].ResetToPool();
						instance.lineAnchorList[j] = null;
					}
				}
				List<WireLineAnchorInfo> list2 = instance.lineAnchorList;
				Pool.Free<WireLineAnchorInfo>(ref list2, false);
				instance.lineAnchorList = list2;
			}
			instance.originPosition = default(Vector3);
			instance.originRotation = default(Vector3);
			if (instance.slackLevels != null)
			{
				List<float> list3 = instance.slackLevels;
				Pool.FreeUnmanaged<float>(ref list3);
				instance.slackLevels = list3;
			}
			Pool.Free<IOConnection>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose IOConnection with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(IOConnection instance)
		{
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0102: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			instance.niceName = niceName;
			instance.type = type;
			instance.connectedID = connectedID;
			instance.connectedToSlot = connectedToSlot;
			instance.inUse = inUse;
			if (linePointList != null)
			{
				instance.linePointList = Pool.Get<List<LineVec>>();
				for (int i = 0; i < linePointList.Count; i++)
				{
					LineVec item = linePointList[i].Copy();
					instance.linePointList.Add(item);
				}
			}
			else
			{
				instance.linePointList = null;
			}
			instance.colour = colour;
			instance.worldSpaceRotation = worldSpaceRotation;
			instance.lineThickness = lineThickness;
			if (lineAnchorList != null)
			{
				instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
				for (int j = 0; j < lineAnchorList.Count; j++)
				{
					WireLineAnchorInfo item2 = lineAnchorList[j].Copy();
					instance.lineAnchorList.Add(item2);
				}
			}
			else
			{
				instance.lineAnchorList = null;
			}
			instance.originPosition = originPosition;
			instance.originRotation = originRotation;
			if (slackLevels != null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
				for (int k = 0; k < slackLevels.Count; k++)
				{
					float item3 = slackLevels[k];
					instance.slackLevels.Add(item3);
				}
			}
			else
			{
				instance.slackLevels = null;
			}
		}

		public IOConnection Copy()
		{
			IOConnection iOConnection = Pool.Get<IOConnection>();
			CopyTo(iOConnection);
			return iOConnection;
		}

		public static IOConnection Deserialize(BufferStream stream)
		{
			IOConnection iOConnection = Pool.Get<IOConnection>();
			Deserialize(stream, iOConnection, isDelta: false);
			return iOConnection;
		}

		public static IOConnection DeserializeLengthDelimited(BufferStream stream)
		{
			IOConnection iOConnection = Pool.Get<IOConnection>();
			DeserializeLengthDelimited(stream, iOConnection, isDelta: false);
			return iOConnection;
		}

		public static IOConnection DeserializeLength(BufferStream stream, int length)
		{
			IOConnection iOConnection = Pool.Get<IOConnection>();
			DeserializeLength(stream, length, iOConnection, isDelta: false);
			return iOConnection;
		}

		public static IOConnection Deserialize(byte[] buffer)
		{
			IOConnection iOConnection = Pool.Get<IOConnection>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, iOConnection, isDelta: false);
			return iOConnection;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, IOConnection previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static IOConnection Deserialize(BufferStream stream, IOConnection instance, bool isDelta)
		{
			//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_016b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				if (instance.linePointList == null)
				{
					instance.linePointList = Pool.Get<List<LineVec>>();
				}
				if (instance.lineAnchorList == null)
				{
					instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
				}
				if (instance.slackLevels == null)
				{
					instance.slackLevels = Pool.Get<List<float>>();
				}
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.niceName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.connectedID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 32:
					instance.connectedToSlot = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.inUse = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					instance.linePointList.Add(LineVec.DeserializeLengthDelimited(stream));
					continue;
				case 56:
					instance.colour = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldSpaceRotation, isDelta);
					continue;
				case 77:
					instance.lineThickness = ProtocolParser.ReadSingle(stream);
					continue;
				case 82:
					instance.lineAnchorList.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
					continue;
				case 90:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originPosition, isDelta);
					continue;
				case 98:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originRotation, isDelta);
					continue;
				case 109:
					instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static IOConnection DeserializeLengthDelimited(BufferStream stream, IOConnection instance, bool isDelta)
		{
			//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				if (instance.linePointList == null)
				{
					instance.linePointList = Pool.Get<List<LineVec>>();
				}
				if (instance.lineAnchorList == null)
				{
					instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
				}
				if (instance.slackLevels == null)
				{
					instance.slackLevels = Pool.Get<List<float>>();
				}
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.niceName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.connectedID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 32:
					instance.connectedToSlot = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.inUse = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					instance.linePointList.Add(LineVec.DeserializeLengthDelimited(stream));
					continue;
				case 56:
					instance.colour = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldSpaceRotation, isDelta);
					continue;
				case 77:
					instance.lineThickness = ProtocolParser.ReadSingle(stream);
					continue;
				case 82:
					instance.lineAnchorList.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
					continue;
				case 90:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originPosition, isDelta);
					continue;
				case 98:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originRotation, isDelta);
					continue;
				case 109:
					instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static IOConnection DeserializeLength(BufferStream stream, int length, IOConnection instance, bool isDelta)
		{
			//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_019a: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				if (instance.linePointList == null)
				{
					instance.linePointList = Pool.Get<List<LineVec>>();
				}
				if (instance.lineAnchorList == null)
				{
					instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
				}
				if (instance.slackLevels == null)
				{
					instance.slackLevels = Pool.Get<List<float>>();
				}
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.niceName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.connectedID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 32:
					instance.connectedToSlot = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.inUse = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					instance.linePointList.Add(LineVec.DeserializeLengthDelimited(stream));
					continue;
				case 56:
					instance.colour = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldSpaceRotation, isDelta);
					continue;
				case 77:
					instance.lineThickness = ProtocolParser.ReadSingle(stream);
					continue;
				case 82:
					instance.lineAnchorList.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
					continue;
				case 90:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originPosition, isDelta);
					continue;
				case 98:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originRotation, isDelta);
					continue;
				case 109:
					instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, IOConnection instance, IOConnection previous)
		{
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0140: Unknown result type (might be due to invalid IL or missing references)
			//IL_0167: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_027d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0283: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0313: Unknown result type (might be due to invalid IL or missing references)
			//IL_0319: Unknown result type (might be due to invalid IL or missing references)
			if (instance.niceName != null && instance.niceName != previous.niceName)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.niceName);
			}
			if (instance.type != previous.type)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.connectedID.Value);
			if (instance.connectedToSlot != previous.connectedToSlot)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.connectedToSlot);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.inUse);
			if (instance.linePointList != null)
			{
				for (int i = 0; i < instance.linePointList.Count; i++)
				{
					LineVec lineVec = instance.linePointList[i];
					stream.WriteByte(50);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					LineVec.SerializeDelta(stream, lineVec, lineVec);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePointList (ProtoBuf.IOEntity.IOConnection.LineVec)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.colour != previous.colour)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.colour);
			}
			if (instance.worldSpaceRotation != previous.worldSpaceRotation)
			{
				stream.WriteByte(66);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.worldSpaceRotation, previous.worldSpaceRotation);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldSpaceRotation (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.lineThickness != previous.lineThickness)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.lineThickness);
			}
			if (instance.lineAnchorList != null)
			{
				for (int j = 0; j < instance.lineAnchorList.Count; j++)
				{
					WireLineAnchorInfo wireLineAnchorInfo = instance.lineAnchorList[j];
					stream.WriteByte(82);
					BufferStream.RangeHandle range3 = stream.GetRange(5);
					int position3 = stream.Position;
					WireLineAnchorInfo.SerializeDelta(stream, wireLineAnchorInfo, wireLineAnchorInfo);
					int val = stream.Position - position3;
					Span<byte> span3 = range3.GetSpan();
					int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
					if (num3 < 5)
					{
						span3[num3 - 1] |= 128;
						while (num3 < 4)
						{
							span3[num3++] = 128;
						}
						span3[4] = 0;
					}
				}
			}
			if (instance.originPosition != previous.originPosition)
			{
				stream.WriteByte(90);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.originPosition, previous.originPosition);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPosition (UnityEngine.Vector3)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
			if (instance.originRotation != previous.originRotation)
			{
				stream.WriteByte(98);
				BufferStream.RangeHandle range5 = stream.GetRange(1);
				int position5 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.originRotation, previous.originRotation);
				int num5 = stream.Position - position5;
				if (num5 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originRotation (UnityEngine.Vector3)");
				}
				Span<byte> span5 = range5.GetSpan();
				ProtocolParser.WriteUInt32((uint)num5, span5, 0);
			}
			if (instance.slackLevels != null)
			{
				for (int k = 0; k < instance.slackLevels.Count; k++)
				{
					float f = instance.slackLevels[k];
					stream.WriteByte(109);
					ProtocolParser.WriteSingle(stream, f);
				}
			}
		}

		public static void Serialize(BufferStream stream, IOConnection instance)
		{
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_0272: Unknown result type (might be due to invalid IL or missing references)
			//IL_0279: Unknown result type (might be due to invalid IL or missing references)
			//IL_027f: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_030a: Unknown result type (might be due to invalid IL or missing references)
			if (instance.niceName != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.niceName);
			}
			if (instance.type != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.connectedID != default(NetworkableId))
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.connectedID.Value);
			}
			if (instance.connectedToSlot != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.connectedToSlot);
			}
			if (instance.inUse)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.inUse);
			}
			if (instance.linePointList != null)
			{
				for (int i = 0; i < instance.linePointList.Count; i++)
				{
					LineVec instance2 = instance.linePointList[i];
					stream.WriteByte(50);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					LineVec.Serialize(stream, instance2);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePointList (ProtoBuf.IOEntity.IOConnection.LineVec)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.colour != 0)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.colour);
			}
			if (instance.worldSpaceRotation != default(Vector3))
			{
				stream.WriteByte(66);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.worldSpaceRotation);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldSpaceRotation (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.lineThickness != 0f)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.lineThickness);
			}
			if (instance.lineAnchorList != null)
			{
				for (int j = 0; j < instance.lineAnchorList.Count; j++)
				{
					WireLineAnchorInfo instance3 = instance.lineAnchorList[j];
					stream.WriteByte(82);
					BufferStream.RangeHandle range3 = stream.GetRange(5);
					int position3 = stream.Position;
					WireLineAnchorInfo.Serialize(stream, instance3);
					int val = stream.Position - position3;
					Span<byte> span3 = range3.GetSpan();
					int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
					if (num3 < 5)
					{
						span3[num3 - 1] |= 128;
						while (num3 < 4)
						{
							span3[num3++] = 128;
						}
						span3[4] = 0;
					}
				}
			}
			if (instance.originPosition != default(Vector3))
			{
				stream.WriteByte(90);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.originPosition);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPosition (UnityEngine.Vector3)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
			if (instance.originRotation != default(Vector3))
			{
				stream.WriteByte(98);
				BufferStream.RangeHandle range5 = stream.GetRange(1);
				int position5 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.originRotation);
				int num5 = stream.Position - position5;
				if (num5 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originRotation (UnityEngine.Vector3)");
				}
				Span<byte> span5 = range5.GetSpan();
				ProtocolParser.WriteUInt32((uint)num5, span5, 0);
			}
			if (instance.slackLevels != null)
			{
				for (int k = 0; k < instance.slackLevels.Count; k++)
				{
					float f = instance.slackLevels[k];
					stream.WriteByte(109);
					ProtocolParser.WriteSingle(stream, f);
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref connectedID.Value);
			if (linePointList != null)
			{
				for (int i = 0; i < linePointList.Count; i++)
				{
					linePointList[i]?.InspectUids(action);
				}
			}
			if (lineAnchorList != null)
			{
				for (int j = 0; j < lineAnchorList.Count; j++)
				{
					lineAnchorList[j]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public List<IOConnection> inputs;

	[NonSerialized]
	public List<IOConnection> outputs;

	[NonSerialized]
	public NetworkableId genericEntRef1;

	[NonSerialized]
	public NetworkableId genericEntRef2;

	[NonSerialized]
	public NetworkableId genericEntRef3;

	[NonSerialized]
	public int genericInt1;

	[NonSerialized]
	public int genericInt2;

	[NonSerialized]
	public float genericFloat1;

	[NonSerialized]
	public float genericFloat2;

	[NonSerialized]
	public int genericInt3;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(IOEntity instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.inputs != null)
		{
			for (int i = 0; i < instance.inputs.Count; i++)
			{
				if (instance.inputs[i] != null)
				{
					instance.inputs[i].ResetToPool();
					instance.inputs[i] = null;
				}
			}
			List<IOConnection> list = instance.inputs;
			Pool.Free<IOConnection>(ref list, false);
			instance.inputs = list;
		}
		if (instance.outputs != null)
		{
			for (int j = 0; j < instance.outputs.Count; j++)
			{
				if (instance.outputs[j] != null)
				{
					instance.outputs[j].ResetToPool();
					instance.outputs[j] = null;
				}
			}
			List<IOConnection> list2 = instance.outputs;
			Pool.Free<IOConnection>(ref list2, false);
			instance.outputs = list2;
		}
		instance.genericEntRef1 = default(NetworkableId);
		instance.genericEntRef2 = default(NetworkableId);
		instance.genericEntRef3 = default(NetworkableId);
		instance.genericInt1 = 0;
		instance.genericInt2 = 0;
		instance.genericFloat1 = 0f;
		instance.genericFloat2 = 0f;
		instance.genericInt3 = 0;
		Pool.Free<IOEntity>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose IOEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(IOEntity instance)
	{
		if (inputs != null)
		{
			instance.inputs = Pool.Get<List<IOConnection>>();
			for (int i = 0; i < inputs.Count; i++)
			{
				IOConnection item = inputs[i].Copy();
				instance.inputs.Add(item);
			}
		}
		else
		{
			instance.inputs = null;
		}
		if (outputs != null)
		{
			instance.outputs = Pool.Get<List<IOConnection>>();
			for (int j = 0; j < outputs.Count; j++)
			{
				IOConnection item2 = outputs[j].Copy();
				instance.outputs.Add(item2);
			}
		}
		else
		{
			instance.outputs = null;
		}
		instance.genericEntRef1 = genericEntRef1;
		instance.genericEntRef2 = genericEntRef2;
		instance.genericEntRef3 = genericEntRef3;
		instance.genericInt1 = genericInt1;
		instance.genericInt2 = genericInt2;
		instance.genericFloat1 = genericFloat1;
		instance.genericFloat2 = genericFloat2;
		instance.genericInt3 = genericInt3;
	}

	public IOEntity Copy()
	{
		IOEntity iOEntity = Pool.Get<IOEntity>();
		CopyTo(iOEntity);
		return iOEntity;
	}

	public static IOEntity Deserialize(BufferStream stream)
	{
		IOEntity iOEntity = Pool.Get<IOEntity>();
		Deserialize(stream, iOEntity, isDelta: false);
		return iOEntity;
	}

	public static IOEntity DeserializeLengthDelimited(BufferStream stream)
	{
		IOEntity iOEntity = Pool.Get<IOEntity>();
		DeserializeLengthDelimited(stream, iOEntity, isDelta: false);
		return iOEntity;
	}

	public static IOEntity DeserializeLength(BufferStream stream, int length)
	{
		IOEntity iOEntity = Pool.Get<IOEntity>();
		DeserializeLength(stream, length, iOEntity, isDelta: false);
		return iOEntity;
	}

	public static IOEntity Deserialize(byte[] buffer)
	{
		IOEntity iOEntity = Pool.Get<IOEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, iOEntity, isDelta: false);
		return iOEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, IOEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static IOEntity Deserialize(BufferStream stream, IOEntity instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.inputs == null)
			{
				instance.inputs = Pool.Get<List<IOConnection>>();
			}
			if (instance.outputs == null)
			{
				instance.outputs = Pool.Get<List<IOConnection>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.inputs.Add(IOConnection.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.outputs.Add(IOConnection.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.genericEntRef1 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.genericEntRef2 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.genericEntRef3 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 69:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static IOEntity DeserializeLengthDelimited(BufferStream stream, IOEntity instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.inputs == null)
			{
				instance.inputs = Pool.Get<List<IOConnection>>();
			}
			if (instance.outputs == null)
			{
				instance.outputs = Pool.Get<List<IOConnection>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.inputs.Add(IOConnection.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.outputs.Add(IOConnection.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.genericEntRef1 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.genericEntRef2 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.genericEntRef3 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 69:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static IOEntity DeserializeLength(BufferStream stream, int length, IOEntity instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.inputs == null)
			{
				instance.inputs = Pool.Get<List<IOConnection>>();
			}
			if (instance.outputs == null)
			{
				instance.outputs = Pool.Get<List<IOConnection>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.inputs.Add(IOConnection.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.outputs.Add(IOConnection.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.genericEntRef1 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.genericEntRef2 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.genericEntRef3 = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 69:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, IOEntity instance, IOEntity previous)
	{
		if (instance.inputs != null)
		{
			for (int i = 0; i < instance.inputs.Count; i++)
			{
				IOConnection iOConnection = instance.inputs[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				IOConnection.SerializeDelta(stream, iOConnection, iOConnection);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.outputs != null)
		{
			for (int j = 0; j < instance.outputs.Count; j++)
			{
				IOConnection iOConnection2 = instance.outputs[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				IOConnection.SerializeDelta(stream, iOConnection2, iOConnection2);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.genericEntRef1.Value);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.genericEntRef2.Value);
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.genericEntRef3.Value);
		if (instance.genericInt1 != previous.genericInt1)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt1);
		}
		if (instance.genericInt2 != previous.genericInt2)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt2);
		}
		if (instance.genericFloat1 != previous.genericFloat1)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.genericFloat1);
		}
		if (instance.genericFloat2 != previous.genericFloat2)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.genericFloat2);
		}
		if (instance.genericInt3 != previous.genericInt3)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt3);
		}
	}

	public static void Serialize(BufferStream stream, IOEntity instance)
	{
		if (instance.inputs != null)
		{
			for (int i = 0; i < instance.inputs.Count; i++)
			{
				IOConnection instance2 = instance.inputs[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				IOConnection.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.outputs != null)
		{
			for (int j = 0; j < instance.outputs.Count; j++)
			{
				IOConnection instance3 = instance.outputs[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				IOConnection.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.genericEntRef1 != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.genericEntRef1.Value);
		}
		if (instance.genericEntRef2 != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.genericEntRef2.Value);
		}
		if (instance.genericEntRef3 != default(NetworkableId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.genericEntRef3.Value);
		}
		if (instance.genericInt1 != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt1);
		}
		if (instance.genericInt2 != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt2);
		}
		if (instance.genericFloat1 != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.genericFloat1);
		}
		if (instance.genericFloat2 != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.genericFloat2);
		}
		if (instance.genericInt3 != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt3);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (inputs != null)
		{
			for (int i = 0; i < inputs.Count; i++)
			{
				inputs[i]?.InspectUids(action);
			}
		}
		if (outputs != null)
		{
			for (int j = 0; j < outputs.Count; j++)
			{
				outputs[j]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref genericEntRef1.Value);
		action(UidType.NetworkableId, ref genericEntRef2.Value);
		action(UidType.NetworkableId, ref genericEntRef3.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PuzzleReset : IDisposable, IPooled, IProto<PuzzleReset>, IProto
{
	[NonSerialized]
	public bool playerBlocksReset;

	[NonSerialized]
	public float playerDetectionRadius;

	[NonSerialized]
	public Vector3 playerDetectionOrigin;

	[NonSerialized]
	public float timeBetweenResets;

	[NonSerialized]
	public bool scaleWithServerPopulation;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PuzzleReset instance)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.playerBlocksReset = false;
			instance.playerDetectionRadius = 0f;
			instance.playerDetectionOrigin = default(Vector3);
			instance.timeBetweenResets = 0f;
			instance.scaleWithServerPopulation = false;
			Pool.Free<PuzzleReset>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PuzzleReset with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PuzzleReset instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.playerBlocksReset = playerBlocksReset;
		instance.playerDetectionRadius = playerDetectionRadius;
		instance.playerDetectionOrigin = playerDetectionOrigin;
		instance.timeBetweenResets = timeBetweenResets;
		instance.scaleWithServerPopulation = scaleWithServerPopulation;
	}

	public PuzzleReset Copy()
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		CopyTo(puzzleReset);
		return puzzleReset;
	}

	public static PuzzleReset Deserialize(BufferStream stream)
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		Deserialize(stream, puzzleReset, isDelta: false);
		return puzzleReset;
	}

	public static PuzzleReset DeserializeLengthDelimited(BufferStream stream)
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		DeserializeLengthDelimited(stream, puzzleReset, isDelta: false);
		return puzzleReset;
	}

	public static PuzzleReset DeserializeLength(BufferStream stream, int length)
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		DeserializeLength(stream, length, puzzleReset, isDelta: false);
		return puzzleReset;
	}

	public static PuzzleReset Deserialize(byte[] buffer)
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, puzzleReset, isDelta: false);
		return puzzleReset;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PuzzleReset previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PuzzleReset Deserialize(BufferStream stream, PuzzleReset instance, bool isDelta)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.playerBlocksReset = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.playerDetectionRadius = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerDetectionOrigin, isDelta);
				continue;
			case 37:
				instance.timeBetweenResets = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.scaleWithServerPopulation = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PuzzleReset DeserializeLengthDelimited(BufferStream stream, PuzzleReset instance, bool isDelta)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerBlocksReset = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.playerDetectionRadius = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerDetectionOrigin, isDelta);
				continue;
			case 37:
				instance.timeBetweenResets = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.scaleWithServerPopulation = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PuzzleReset DeserializeLength(BufferStream stream, int length, PuzzleReset instance, bool isDelta)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerBlocksReset = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.playerDetectionRadius = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerDetectionOrigin, isDelta);
				continue;
			case 37:
				instance.timeBetweenResets = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.scaleWithServerPopulation = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PuzzleReset instance, PuzzleReset previous)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.playerBlocksReset);
		if (instance.playerDetectionRadius != previous.playerDetectionRadius)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.playerDetectionRadius);
		}
		if (instance.playerDetectionOrigin != previous.playerDetectionOrigin)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.playerDetectionOrigin, previous.playerDetectionOrigin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerDetectionOrigin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.timeBetweenResets != previous.timeBetweenResets)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.timeBetweenResets);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.scaleWithServerPopulation);
	}

	public static void Serialize(BufferStream stream, PuzzleReset instance)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.playerBlocksReset)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.playerBlocksReset);
		}
		if (instance.playerDetectionRadius != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.playerDetectionRadius);
		}
		if (instance.playerDetectionOrigin != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.playerDetectionOrigin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerDetectionOrigin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.timeBetweenResets != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.timeBetweenResets);
		}
		if (instance.scaleWithServerPopulation)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.scaleWithServerPopulation);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class RelationshipManager : IDisposable, IPooled, IProto<RelationshipManager>, IProto
{
	public class PlayerRelationshipInfo : IDisposable, IPooled, IProto<PlayerRelationshipInfo>, IProto
	{
		[NonSerialized]
		public ulong playerID;

		[NonSerialized]
		public int type;

		[NonSerialized]
		public int weight;

		[NonSerialized]
		public uint mugshotCrc;

		[NonSerialized]
		public string displayName;

		[NonSerialized]
		public string notes;

		[NonSerialized]
		public float timeSinceSeen;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerRelationshipInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.playerID = 0uL;
				instance.type = 0;
				instance.weight = 0;
				instance.mugshotCrc = 0u;
				instance.displayName = string.Empty;
				instance.notes = string.Empty;
				instance.timeSinceSeen = 0f;
				Pool.Free<PlayerRelationshipInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerRelationshipInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerRelationshipInfo instance)
		{
			instance.playerID = playerID;
			instance.type = type;
			instance.weight = weight;
			instance.mugshotCrc = mugshotCrc;
			instance.displayName = displayName;
			instance.notes = notes;
			instance.timeSinceSeen = timeSinceSeen;
		}

		public PlayerRelationshipInfo Copy()
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			CopyTo(playerRelationshipInfo);
			return playerRelationshipInfo;
		}

		public static PlayerRelationshipInfo Deserialize(BufferStream stream)
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			Deserialize(stream, playerRelationshipInfo, isDelta: false);
			return playerRelationshipInfo;
		}

		public static PlayerRelationshipInfo DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			DeserializeLengthDelimited(stream, playerRelationshipInfo, isDelta: false);
			return playerRelationshipInfo;
		}

		public static PlayerRelationshipInfo DeserializeLength(BufferStream stream, int length)
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			DeserializeLength(stream, length, playerRelationshipInfo, isDelta: false);
			return playerRelationshipInfo;
		}

		public static PlayerRelationshipInfo Deserialize(byte[] buffer)
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerRelationshipInfo, isDelta: false);
			return playerRelationshipInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerRelationshipInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerRelationshipInfo Deserialize(BufferStream stream, PlayerRelationshipInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.weight = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 42:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 61:
					instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerRelationshipInfo DeserializeLengthDelimited(BufferStream stream, PlayerRelationshipInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.weight = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 42:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 61:
					instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerRelationshipInfo DeserializeLength(BufferStream stream, int length, PlayerRelationshipInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.weight = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 42:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 61:
					instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerRelationshipInfo instance, PlayerRelationshipInfo previous)
		{
			if (instance.playerID != previous.playerID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.type != previous.type)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.weight != previous.weight)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.weight);
			}
			if (instance.mugshotCrc != previous.mugshotCrc)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, instance.mugshotCrc);
			}
			if (instance.displayName != null && instance.displayName != previous.displayName)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.notes != null && instance.notes != previous.notes)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.notes);
			}
			if (instance.timeSinceSeen != previous.timeSinceSeen)
			{
				stream.WriteByte(61);
				ProtocolParser.WriteSingle(stream, instance.timeSinceSeen);
			}
		}

		public static void Serialize(BufferStream stream, PlayerRelationshipInfo instance)
		{
			if (instance.playerID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.type != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.weight != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.weight);
			}
			if (instance.mugshotCrc != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, instance.mugshotCrc);
			}
			if (instance.displayName != null)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.notes != null)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.notes);
			}
			if (instance.timeSinceSeen != 0f)
			{
				stream.WriteByte(61);
				ProtocolParser.WriteSingle(stream, instance.timeSinceSeen);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class PlayerRelationships : IDisposable, IPooled, IProto<PlayerRelationships>, IProto
	{
		[NonSerialized]
		public ulong playerID;

		[NonSerialized]
		public List<PlayerRelationshipInfo> relations;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerRelationships instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			instance.playerID = 0uL;
			if (instance.relations != null)
			{
				for (int i = 0; i < instance.relations.Count; i++)
				{
					if (instance.relations[i] != null)
					{
						instance.relations[i].ResetToPool();
						instance.relations[i] = null;
					}
				}
				List<PlayerRelationshipInfo> list = instance.relations;
				Pool.Free<PlayerRelationshipInfo>(ref list, false);
				instance.relations = list;
			}
			Pool.Free<PlayerRelationships>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerRelationships with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerRelationships instance)
		{
			instance.playerID = playerID;
			if (relations != null)
			{
				instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
				for (int i = 0; i < relations.Count; i++)
				{
					PlayerRelationshipInfo item = relations[i].Copy();
					instance.relations.Add(item);
				}
			}
			else
			{
				instance.relations = null;
			}
		}

		public PlayerRelationships Copy()
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			CopyTo(playerRelationships);
			return playerRelationships;
		}

		public static PlayerRelationships Deserialize(BufferStream stream)
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			Deserialize(stream, playerRelationships, isDelta: false);
			return playerRelationships;
		}

		public static PlayerRelationships DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			DeserializeLengthDelimited(stream, playerRelationships, isDelta: false);
			return playerRelationships;
		}

		public static PlayerRelationships DeserializeLength(BufferStream stream, int length)
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			DeserializeLength(stream, length, playerRelationships, isDelta: false);
			return playerRelationships;
		}

		public static PlayerRelationships Deserialize(byte[] buffer)
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerRelationships, isDelta: false);
			return playerRelationships;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerRelationships previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerRelationships Deserialize(BufferStream stream, PlayerRelationships instance, bool isDelta)
		{
			if (!isDelta && instance.relations == null)
			{
				instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerRelationships DeserializeLengthDelimited(BufferStream stream, PlayerRelationships instance, bool isDelta)
		{
			if (!isDelta && instance.relations == null)
			{
				instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerRelationships DeserializeLength(BufferStream stream, int length, PlayerRelationships instance, bool isDelta)
		{
			if (!isDelta && instance.relations == null)
			{
				instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerRelationships instance, PlayerRelationships previous)
		{
			if (instance.playerID != previous.playerID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.relations == null)
			{
				return;
			}
			for (int i = 0; i < instance.relations.Count; i++)
			{
				PlayerRelationshipInfo playerRelationshipInfo = instance.relations[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerRelationshipInfo.SerializeDelta(stream, playerRelationshipInfo, playerRelationshipInfo);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public static void Serialize(BufferStream stream, PlayerRelationships instance)
		{
			if (instance.playerID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.relations == null)
			{
				return;
			}
			for (int i = 0; i < instance.relations.Count; i++)
			{
				PlayerRelationshipInfo instance2 = instance.relations[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerRelationshipInfo.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (relations != null)
			{
				for (int i = 0; i < relations.Count; i++)
				{
					relations[i]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public ulong lastTeamIndex;

	[NonSerialized]
	public List<PlayerTeam> teamList;

	[NonSerialized]
	public int maxTeamSize;

	[NonSerialized]
	public List<PlayerRelationships> relationships;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RelationshipManager instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.lastTeamIndex = 0uL;
		if (instance.teamList != null)
		{
			for (int i = 0; i < instance.teamList.Count; i++)
			{
				if (instance.teamList[i] != null)
				{
					instance.teamList[i].ResetToPool();
					instance.teamList[i] = null;
				}
			}
			List<PlayerTeam> list = instance.teamList;
			Pool.Free<PlayerTeam>(ref list, false);
			instance.teamList = list;
		}
		instance.maxTeamSize = 0;
		if (instance.relationships != null)
		{
			for (int j = 0; j < instance.relationships.Count; j++)
			{
				if (instance.relationships[j] != null)
				{
					instance.relationships[j].ResetToPool();
					instance.relationships[j] = null;
				}
			}
			List<PlayerRelationships> list2 = instance.relationships;
			Pool.Free<PlayerRelationships>(ref list2, false);
			instance.relationships = list2;
		}
		Pool.Free<RelationshipManager>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RelationshipManager with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RelationshipManager instance)
	{
		instance.lastTeamIndex = lastTeamIndex;
		if (teamList != null)
		{
			instance.teamList = Pool.Get<List<PlayerTeam>>();
			for (int i = 0; i < teamList.Count; i++)
			{
				PlayerTeam item = teamList[i].Copy();
				instance.teamList.Add(item);
			}
		}
		else
		{
			instance.teamList = null;
		}
		instance.maxTeamSize = maxTeamSize;
		if (relationships != null)
		{
			instance.relationships = Pool.Get<List<PlayerRelationships>>();
			for (int j = 0; j < relationships.Count; j++)
			{
				PlayerRelationships item2 = relationships[j].Copy();
				instance.relationships.Add(item2);
			}
		}
		else
		{
			instance.relationships = null;
		}
	}

	public RelationshipManager Copy()
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		CopyTo(relationshipManager);
		return relationshipManager;
	}

	public static RelationshipManager Deserialize(BufferStream stream)
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		Deserialize(stream, relationshipManager, isDelta: false);
		return relationshipManager;
	}

	public static RelationshipManager DeserializeLengthDelimited(BufferStream stream)
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		DeserializeLengthDelimited(stream, relationshipManager, isDelta: false);
		return relationshipManager;
	}

	public static RelationshipManager DeserializeLength(BufferStream stream, int length)
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		DeserializeLength(stream, length, relationshipManager, isDelta: false);
		return relationshipManager;
	}

	public static RelationshipManager Deserialize(byte[] buffer)
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, relationshipManager, isDelta: false);
		return relationshipManager;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RelationshipManager previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RelationshipManager Deserialize(BufferStream stream, RelationshipManager instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teamList == null)
			{
				instance.teamList = Pool.Get<List<PlayerTeam>>();
			}
			if (instance.relationships == null)
			{
				instance.relationships = Pool.Get<List<PlayerRelationships>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lastTeamIndex = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamList.Add(PlayerTeam.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.maxTeamSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.relationships.Add(PlayerRelationships.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RelationshipManager DeserializeLengthDelimited(BufferStream stream, RelationshipManager instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teamList == null)
			{
				instance.teamList = Pool.Get<List<PlayerTeam>>();
			}
			if (instance.relationships == null)
			{
				instance.relationships = Pool.Get<List<PlayerRelationships>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lastTeamIndex = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamList.Add(PlayerTeam.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.maxTeamSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.relationships.Add(PlayerRelationships.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RelationshipManager DeserializeLength(BufferStream stream, int length, RelationshipManager instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teamList == null)
			{
				instance.teamList = Pool.Get<List<PlayerTeam>>();
			}
			if (instance.relationships == null)
			{
				instance.relationships = Pool.Get<List<PlayerRelationships>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lastTeamIndex = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamList.Add(PlayerTeam.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.maxTeamSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.relationships.Add(PlayerRelationships.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RelationshipManager instance, RelationshipManager previous)
	{
		if (instance.lastTeamIndex != previous.lastTeamIndex)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lastTeamIndex);
		}
		if (instance.teamList != null)
		{
			for (int i = 0; i < instance.teamList.Count; i++)
			{
				PlayerTeam playerTeam = instance.teamList[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerTeam.SerializeDelta(stream, playerTeam, playerTeam);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.maxTeamSize != previous.maxTeamSize)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxTeamSize);
		}
		if (instance.relationships == null)
		{
			return;
		}
		for (int j = 0; j < instance.relationships.Count; j++)
		{
			PlayerRelationships playerRelationships = instance.relationships[j];
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerRelationships.SerializeDelta(stream, playerRelationships, playerRelationships);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, RelationshipManager instance)
	{
		if (instance.lastTeamIndex != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lastTeamIndex);
		}
		if (instance.teamList != null)
		{
			for (int i = 0; i < instance.teamList.Count; i++)
			{
				PlayerTeam instance2 = instance.teamList[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerTeam.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.maxTeamSize != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxTeamSize);
		}
		if (instance.relationships == null)
		{
			return;
		}
		for (int j = 0; j < instance.relationships.Count; j++)
		{
			PlayerRelationships instance3 = instance.relationships[j];
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerRelationships.Serialize(stream, instance3);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (teamList != null)
		{
			for (int i = 0; i < teamList.Count; i++)
			{
				teamList[i]?.InspectUids(action);
			}
		}
		if (relationships != null)
		{
			for (int j = 0; j < relationships.Count; j++)
			{
				relationships[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class EggHunt : IDisposable, IPooled, IProto<EggHunt>, IProto
{
	public class EggHunter : IDisposable, IPooled, IProto<EggHunter>, IProto
	{
		[NonSerialized]
		public string displayName;

		[NonSerialized]
		public int numEggs;

		[NonSerialized]
		public ulong playerID;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(EggHunter instance)
		{
			if (instance.ShouldPool)
			{
				instance.displayName = string.Empty;
				instance.numEggs = 0;
				instance.playerID = 0uL;
				Pool.Free<EggHunter>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose EggHunter with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(EggHunter instance)
		{
			instance.displayName = displayName;
			instance.numEggs = numEggs;
			instance.playerID = playerID;
		}

		public EggHunter Copy()
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			CopyTo(eggHunter);
			return eggHunter;
		}

		public static EggHunter Deserialize(BufferStream stream)
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			Deserialize(stream, eggHunter, isDelta: false);
			return eggHunter;
		}

		public static EggHunter DeserializeLengthDelimited(BufferStream stream)
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			DeserializeLengthDelimited(stream, eggHunter, isDelta: false);
			return eggHunter;
		}

		public static EggHunter DeserializeLength(BufferStream stream, int length)
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			DeserializeLength(stream, length, eggHunter, isDelta: false);
			return eggHunter;
		}

		public static EggHunter Deserialize(byte[] buffer)
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, eggHunter, isDelta: false);
			return eggHunter;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, EggHunter previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static EggHunter Deserialize(BufferStream stream, EggHunter instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static EggHunter DeserializeLengthDelimited(BufferStream stream, EggHunter instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static EggHunter DeserializeLength(BufferStream stream, int length, EggHunter instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, EggHunter instance, EggHunter previous)
		{
			if (instance.displayName != null && instance.displayName != previous.displayName)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.numEggs != previous.numEggs)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.numEggs);
			}
			if (instance.playerID != previous.playerID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
		}

		public static void Serialize(BufferStream stream, EggHunter instance)
		{
			if (instance.displayName != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.numEggs != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.numEggs);
			}
			if (instance.playerID != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<EggHunter> hunters;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EggHunt instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.hunters != null)
		{
			for (int i = 0; i < instance.hunters.Count; i++)
			{
				if (instance.hunters[i] != null)
				{
					instance.hunters[i].ResetToPool();
					instance.hunters[i] = null;
				}
			}
			List<EggHunter> list = instance.hunters;
			Pool.Free<EggHunter>(ref list, false);
			instance.hunters = list;
		}
		Pool.Free<EggHunt>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EggHunt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EggHunt instance)
	{
		if (hunters != null)
		{
			instance.hunters = Pool.Get<List<EggHunter>>();
			for (int i = 0; i < hunters.Count; i++)
			{
				EggHunter item = hunters[i].Copy();
				instance.hunters.Add(item);
			}
		}
		else
		{
			instance.hunters = null;
		}
	}

	public EggHunt Copy()
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		CopyTo(eggHunt);
		return eggHunt;
	}

	public static EggHunt Deserialize(BufferStream stream)
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		Deserialize(stream, eggHunt, isDelta: false);
		return eggHunt;
	}

	public static EggHunt DeserializeLengthDelimited(BufferStream stream)
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		DeserializeLengthDelimited(stream, eggHunt, isDelta: false);
		return eggHunt;
	}

	public static EggHunt DeserializeLength(BufferStream stream, int length)
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		DeserializeLength(stream, length, eggHunt, isDelta: false);
		return eggHunt;
	}

	public static EggHunt Deserialize(byte[] buffer)
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, eggHunt, isDelta: false);
		return eggHunt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EggHunt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EggHunt Deserialize(BufferStream stream, EggHunt instance, bool isDelta)
	{
		if (!isDelta && instance.hunters == null)
		{
			instance.hunters = Pool.Get<List<EggHunter>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.hunters.Add(EggHunter.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EggHunt DeserializeLengthDelimited(BufferStream stream, EggHunt instance, bool isDelta)
	{
		if (!isDelta && instance.hunters == null)
		{
			instance.hunters = Pool.Get<List<EggHunter>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.hunters.Add(EggHunter.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EggHunt DeserializeLength(BufferStream stream, int length, EggHunt instance, bool isDelta)
	{
		if (!isDelta && instance.hunters == null)
		{
			instance.hunters = Pool.Get<List<EggHunter>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.hunters.Add(EggHunter.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EggHunt instance, EggHunt previous)
	{
		if (instance.hunters == null)
		{
			return;
		}
		for (int i = 0; i < instance.hunters.Count; i++)
		{
			EggHunter eggHunter = instance.hunters[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			EggHunter.SerializeDelta(stream, eggHunter, eggHunter);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, EggHunt instance)
	{
		if (instance.hunters == null)
		{
			return;
		}
		for (int i = 0; i < instance.hunters.Count; i++)
		{
			EggHunter instance2 = instance.hunters[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			EggHunter.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (hunters != null)
		{
			for (int i = 0; i < hunters.Count; i++)
			{
				hunters[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ArcadeMachine : IDisposable, IPooled, IProto<ArcadeMachine>, IProto
{
	public class ScoreEntry : IDisposable, IPooled, IProto<ScoreEntry>, IProto
	{
		[NonSerialized]
		public ulong playerID;

		[NonSerialized]
		public string displayName;

		[NonSerialized]
		public int score;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ScoreEntry instance)
		{
			if (instance.ShouldPool)
			{
				instance.playerID = 0uL;
				instance.displayName = string.Empty;
				instance.score = 0;
				Pool.Free<ScoreEntry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ScoreEntry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ScoreEntry instance)
		{
			instance.playerID = playerID;
			instance.displayName = displayName;
			instance.score = score;
		}

		public ScoreEntry Copy()
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			CopyTo(scoreEntry);
			return scoreEntry;
		}

		public static ScoreEntry Deserialize(BufferStream stream)
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			Deserialize(stream, scoreEntry, isDelta: false);
			return scoreEntry;
		}

		public static ScoreEntry DeserializeLengthDelimited(BufferStream stream)
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			DeserializeLengthDelimited(stream, scoreEntry, isDelta: false);
			return scoreEntry;
		}

		public static ScoreEntry DeserializeLength(BufferStream stream, int length)
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			DeserializeLength(stream, length, scoreEntry, isDelta: false);
			return scoreEntry;
		}

		public static ScoreEntry Deserialize(byte[] buffer)
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, scoreEntry, isDelta: false);
			return scoreEntry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ScoreEntry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ScoreEntry Deserialize(BufferStream stream, ScoreEntry instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ScoreEntry DeserializeLengthDelimited(BufferStream stream, ScoreEntry instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ScoreEntry DeserializeLength(BufferStream stream, int length, ScoreEntry instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ScoreEntry instance, ScoreEntry previous)
		{
			if (instance.playerID != previous.playerID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.displayName != null && instance.displayName != previous.displayName)
			{
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.score != previous.score)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public static void Serialize(BufferStream stream, ScoreEntry instance)
		{
			if (instance.playerID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.displayName != null)
			{
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.score != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<ScoreEntry> scores;

	[NonSerialized]
	public int genericInt1;

	[NonSerialized]
	public int genericInt2;

	[NonSerialized]
	public int genericInt3;

	[NonSerialized]
	public int genericInt4;

	[NonSerialized]
	public float genericFloat1;

	[NonSerialized]
	public float genericFloat2;

	[NonSerialized]
	public float genericFloat3;

	[NonSerialized]
	public float genericFloat4;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ArcadeMachine instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				if (instance.scores[i] != null)
				{
					instance.scores[i].ResetToPool();
					instance.scores[i] = null;
				}
			}
			List<ScoreEntry> list = instance.scores;
			Pool.Free<ScoreEntry>(ref list, false);
			instance.scores = list;
		}
		instance.genericInt1 = 0;
		instance.genericInt2 = 0;
		instance.genericInt3 = 0;
		instance.genericInt4 = 0;
		instance.genericFloat1 = 0f;
		instance.genericFloat2 = 0f;
		instance.genericFloat3 = 0f;
		instance.genericFloat4 = 0f;
		Pool.Free<ArcadeMachine>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ArcadeMachine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ArcadeMachine instance)
	{
		if (scores != null)
		{
			instance.scores = Pool.Get<List<ScoreEntry>>();
			for (int i = 0; i < scores.Count; i++)
			{
				ScoreEntry item = scores[i].Copy();
				instance.scores.Add(item);
			}
		}
		else
		{
			instance.scores = null;
		}
		instance.genericInt1 = genericInt1;
		instance.genericInt2 = genericInt2;
		instance.genericInt3 = genericInt3;
		instance.genericInt4 = genericInt4;
		instance.genericFloat1 = genericFloat1;
		instance.genericFloat2 = genericFloat2;
		instance.genericFloat3 = genericFloat3;
		instance.genericFloat4 = genericFloat4;
	}

	public ArcadeMachine Copy()
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		CopyTo(arcadeMachine);
		return arcadeMachine;
	}

	public static ArcadeMachine Deserialize(BufferStream stream)
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		Deserialize(stream, arcadeMachine, isDelta: false);
		return arcadeMachine;
	}

	public static ArcadeMachine DeserializeLengthDelimited(BufferStream stream)
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		DeserializeLengthDelimited(stream, arcadeMachine, isDelta: false);
		return arcadeMachine;
	}

	public static ArcadeMachine DeserializeLength(BufferStream stream, int length)
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		DeserializeLength(stream, length, arcadeMachine, isDelta: false);
		return arcadeMachine;
	}

	public static ArcadeMachine Deserialize(byte[] buffer)
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, arcadeMachine, isDelta: false);
		return arcadeMachine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ArcadeMachine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ArcadeMachine Deserialize(BufferStream stream, ArcadeMachine instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<ScoreEntry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.scores.Add(ScoreEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.genericInt4 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.genericFloat3 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat4 = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ArcadeMachine DeserializeLengthDelimited(BufferStream stream, ArcadeMachine instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<ScoreEntry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.scores.Add(ScoreEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.genericInt4 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.genericFloat3 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat4 = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ArcadeMachine DeserializeLength(BufferStream stream, int length, ArcadeMachine instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<ScoreEntry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.scores.Add(ScoreEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.genericInt4 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.genericFloat3 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat4 = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ArcadeMachine instance, ArcadeMachine previous)
	{
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				ScoreEntry scoreEntry = instance.scores[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ScoreEntry.SerializeDelta(stream, scoreEntry, scoreEntry);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.genericInt1 != previous.genericInt1)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt1);
		}
		if (instance.genericInt2 != previous.genericInt2)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt2);
		}
		if (instance.genericInt3 != previous.genericInt3)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt3);
		}
		if (instance.genericInt4 != previous.genericInt4)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt4);
		}
		if (instance.genericFloat1 != previous.genericFloat1)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.genericFloat1);
		}
		if (instance.genericFloat2 != previous.genericFloat2)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.genericFloat2);
		}
		if (instance.genericFloat3 != previous.genericFloat3)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.genericFloat3);
		}
		if (instance.genericFloat4 != previous.genericFloat4)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.genericFloat4);
		}
	}

	public static void Serialize(BufferStream stream, ArcadeMachine instance)
	{
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				ScoreEntry instance2 = instance.scores[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ScoreEntry.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.genericInt1 != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt1);
		}
		if (instance.genericInt2 != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt2);
		}
		if (instance.genericInt3 != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt3);
		}
		if (instance.genericInt4 != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt4);
		}
		if (instance.genericFloat1 != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.genericFloat1);
		}
		if (instance.genericFloat2 != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.genericFloat2);
		}
		if (instance.genericFloat3 != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.genericFloat3);
		}
		if (instance.genericFloat4 != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.genericFloat4);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (scores != null)
		{
			for (int i = 0; i < scores.Count; i++)
			{
				scores[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Horse : IDisposable, IPooled, IProto<Horse>, IProto
{
	[NonSerialized]
	public float stamina;

	[NonSerialized]
	public float maxStamina;

	[NonSerialized]
	public int gait;

	[NonSerialized]
	public float equipmentSpeedMod;

	[NonSerialized]
	public int breedIndex;

	[NonSerialized]
	public NetworkableId towEntityId;

	[NonSerialized]
	public ItemContainer equipmentContainer;

	[NonSerialized]
	public ItemContainer storageContainer;

	[NonSerialized]
	public int numStorageSlots;

	[NonSerialized]
	public NetworkableId playerLeadingId;

	[NonSerialized]
	public HorseModifiers modifiers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Horse instance)
	{
		if (instance.ShouldPool)
		{
			instance.stamina = 0f;
			instance.maxStamina = 0f;
			instance.gait = 0;
			instance.equipmentSpeedMod = 0f;
			instance.breedIndex = 0;
			instance.towEntityId = default(NetworkableId);
			if (instance.equipmentContainer != null)
			{
				instance.equipmentContainer.ResetToPool();
				instance.equipmentContainer = null;
			}
			if (instance.storageContainer != null)
			{
				instance.storageContainer.ResetToPool();
				instance.storageContainer = null;
			}
			instance.numStorageSlots = 0;
			instance.playerLeadingId = default(NetworkableId);
			if (instance.modifiers != null)
			{
				instance.modifiers.ResetToPool();
				instance.modifiers = null;
			}
			Pool.Free<Horse>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Horse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Horse instance)
	{
		instance.stamina = stamina;
		instance.maxStamina = maxStamina;
		instance.gait = gait;
		instance.equipmentSpeedMod = equipmentSpeedMod;
		instance.breedIndex = breedIndex;
		instance.towEntityId = towEntityId;
		if (equipmentContainer != null)
		{
			if (instance.equipmentContainer == null)
			{
				instance.equipmentContainer = equipmentContainer.Copy();
			}
			else
			{
				equipmentContainer.CopyTo(instance.equipmentContainer);
			}
		}
		else
		{
			instance.equipmentContainer = null;
		}
		if (storageContainer != null)
		{
			if (instance.storageContainer == null)
			{
				instance.storageContainer = storageContainer.Copy();
			}
			else
			{
				storageContainer.CopyTo(instance.storageContainer);
			}
		}
		else
		{
			instance.storageContainer = null;
		}
		instance.numStorageSlots = numStorageSlots;
		instance.playerLeadingId = playerLeadingId;
		if (modifiers != null)
		{
			if (instance.modifiers == null)
			{
				instance.modifiers = modifiers.Copy();
			}
			else
			{
				modifiers.CopyTo(instance.modifiers);
			}
		}
		else
		{
			instance.modifiers = null;
		}
	}

	public Horse Copy()
	{
		Horse horse = Pool.Get<Horse>();
		CopyTo(horse);
		return horse;
	}

	public static Horse Deserialize(BufferStream stream)
	{
		Horse horse = Pool.Get<Horse>();
		Deserialize(stream, horse, isDelta: false);
		return horse;
	}

	public static Horse DeserializeLengthDelimited(BufferStream stream)
	{
		Horse horse = Pool.Get<Horse>();
		DeserializeLengthDelimited(stream, horse, isDelta: false);
		return horse;
	}

	public static Horse DeserializeLength(BufferStream stream, int length)
	{
		Horse horse = Pool.Get<Horse>();
		DeserializeLength(stream, length, horse, isDelta: false);
		return horse;
	}

	public static Horse Deserialize(byte[] buffer)
	{
		Horse horse = Pool.Get<Horse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, horse, isDelta: false);
		return horse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Horse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Horse Deserialize(BufferStream stream, Horse instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.stamina = ProtocolParser.ReadSingle(stream);
				break;
			case 21:
				instance.maxStamina = ProtocolParser.ReadSingle(stream);
				break;
			case 24:
				instance.gait = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 37:
				instance.equipmentSpeedMod = ProtocolParser.ReadSingle(stream);
				break;
			case 40:
				instance.breedIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.towEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 58:
				if (instance.equipmentContainer == null)
				{
					instance.equipmentContainer = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.equipmentContainer, isDelta);
				}
				break;
			case 66:
				if (instance.storageContainer == null)
				{
					instance.storageContainer = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.storageContainer, isDelta);
				}
				break;
			case 72:
				instance.numStorageSlots = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 80:
				instance.playerLeadingId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 90:
				if (instance.modifiers == null)
				{
					instance.modifiers = HorseModifiers.DeserializeLengthDelimited(stream);
				}
				else
				{
					HorseModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static Horse DeserializeLengthDelimited(BufferStream stream, Horse instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.stamina = ProtocolParser.ReadSingle(stream);
				break;
			case 21:
				instance.maxStamina = ProtocolParser.ReadSingle(stream);
				break;
			case 24:
				instance.gait = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 37:
				instance.equipmentSpeedMod = ProtocolParser.ReadSingle(stream);
				break;
			case 40:
				instance.breedIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.towEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 58:
				if (instance.equipmentContainer == null)
				{
					instance.equipmentContainer = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.equipmentContainer, isDelta);
				}
				break;
			case 66:
				if (instance.storageContainer == null)
				{
					instance.storageContainer = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.storageContainer, isDelta);
				}
				break;
			case 72:
				instance.numStorageSlots = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 80:
				instance.playerLeadingId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 90:
				if (instance.modifiers == null)
				{
					instance.modifiers = HorseModifiers.DeserializeLengthDelimited(stream);
				}
				else
				{
					HorseModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Horse DeserializeLength(BufferStream stream, int length, Horse instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.stamina = ProtocolParser.ReadSingle(stream);
				break;
			case 21:
				instance.maxStamina = ProtocolParser.ReadSingle(stream);
				break;
			case 24:
				instance.gait = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 37:
				instance.equipmentSpeedMod = ProtocolParser.ReadSingle(stream);
				break;
			case 40:
				instance.breedIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.towEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 58:
				if (instance.equipmentContainer == null)
				{
					instance.equipmentContainer = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.equipmentContainer, isDelta);
				}
				break;
			case 66:
				if (instance.storageContainer == null)
				{
					instance.storageContainer = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.storageContainer, isDelta);
				}
				break;
			case 72:
				instance.numStorageSlots = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 80:
				instance.playerLeadingId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 90:
				if (instance.modifiers == null)
				{
					instance.modifiers = HorseModifiers.DeserializeLengthDelimited(stream);
				}
				else
				{
					HorseModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Horse instance, Horse previous)
	{
		if (instance.stamina != previous.stamina)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.stamina);
		}
		if (instance.maxStamina != previous.maxStamina)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.maxStamina);
		}
		if (instance.gait != previous.gait)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gait);
		}
		if (instance.equipmentSpeedMod != previous.equipmentSpeedMod)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.equipmentSpeedMod);
		}
		if (instance.breedIndex != previous.breedIndex)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.breedIndex);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, instance.towEntityId.Value);
		if (instance.equipmentContainer != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.equipmentContainer, previous.equipmentContainer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.storageContainer != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.storageContainer, previous.storageContainer);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.numStorageSlots != previous.numStorageSlots)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numStorageSlots);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteUInt64(stream, instance.playerLeadingId.Value);
		if (instance.modifiers == null)
		{
			return;
		}
		stream.WriteByte(90);
		BufferStream.RangeHandle range3 = stream.GetRange(3);
		int position3 = stream.Position;
		HorseModifiers.SerializeDelta(stream, instance.modifiers, previous.modifiers);
		int num3 = stream.Position - position3;
		if (num3 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.HorseModifiers)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		if (num4 < 3)
		{
			span3[num4 - 1] |= 128;
			while (num4 < 2)
			{
				span3[num4++] = 128;
			}
			span3[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Horse instance)
	{
		if (instance.stamina != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.stamina);
		}
		if (instance.maxStamina != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.maxStamina);
		}
		if (instance.gait != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gait);
		}
		if (instance.equipmentSpeedMod != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.equipmentSpeedMod);
		}
		if (instance.breedIndex != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.breedIndex);
		}
		if (instance.towEntityId != default(NetworkableId))
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.towEntityId.Value);
		}
		if (instance.equipmentContainer != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance.equipmentContainer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.storageContainer != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.Serialize(stream, instance.storageContainer);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.numStorageSlots != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numStorageSlots);
		}
		if (instance.playerLeadingId != default(NetworkableId))
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, instance.playerLeadingId.Value);
		}
		if (instance.modifiers == null)
		{
			return;
		}
		stream.WriteByte(90);
		BufferStream.RangeHandle range3 = stream.GetRange(3);
		int position3 = stream.Position;
		HorseModifiers.Serialize(stream, instance.modifiers);
		int num3 = stream.Position - position3;
		if (num3 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.HorseModifiers)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		if (num4 < 3)
		{
			span3[num4 - 1] |= 128;
			while (num4 < 2)
			{
				span3[num4++] = 128;
			}
			span3[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref towEntityId.Value);
		equipmentContainer?.InspectUids(action);
		storageContainer?.InspectUids(action);
		action(UidType.NetworkableId, ref playerLeadingId.Value);
		modifiers?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class HorseModifiers : IDisposable, IPooled, IProto<HorseModifiers>, IProto
{
	[NonSerialized]
	public List<Modifier> modifiers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(HorseModifiers instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.modifiers != null)
		{
			for (int i = 0; i < instance.modifiers.Count; i++)
			{
				if (instance.modifiers[i] != null)
				{
					instance.modifiers[i].ResetToPool();
					instance.modifiers[i] = null;
				}
			}
			List<Modifier> list = instance.modifiers;
			Pool.Free<Modifier>(ref list, false);
			instance.modifiers = list;
		}
		Pool.Free<HorseModifiers>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose HorseModifiers with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(HorseModifiers instance)
	{
		if (modifiers != null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
			for (int i = 0; i < modifiers.Count; i++)
			{
				Modifier item = modifiers[i].Copy();
				instance.modifiers.Add(item);
			}
		}
		else
		{
			instance.modifiers = null;
		}
	}

	public HorseModifiers Copy()
	{
		HorseModifiers horseModifiers = Pool.Get<HorseModifiers>();
		CopyTo(horseModifiers);
		return horseModifiers;
	}

	public static HorseModifiers Deserialize(BufferStream stream)
	{
		HorseModifiers horseModifiers = Pool.Get<HorseModifiers>();
		Deserialize(stream, horseModifiers, isDelta: false);
		return horseModifiers;
	}

	public static HorseModifiers DeserializeLengthDelimited(BufferStream stream)
	{
		HorseModifiers horseModifiers = Pool.Get<HorseModifiers>();
		DeserializeLengthDelimited(stream, horseModifiers, isDelta: false);
		return horseModifiers;
	}

	public static HorseModifiers DeserializeLength(BufferStream stream, int length)
	{
		HorseModifiers horseModifiers = Pool.Get<HorseModifiers>();
		DeserializeLength(stream, length, horseModifiers, isDelta: false);
		return horseModifiers;
	}

	public static HorseModifiers Deserialize(byte[] buffer)
	{
		HorseModifiers horseModifiers = Pool.Get<HorseModifiers>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, horseModifiers, isDelta: false);
		return horseModifiers;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, HorseModifiers previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static HorseModifiers Deserialize(BufferStream stream, HorseModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static HorseModifiers DeserializeLengthDelimited(BufferStream stream, HorseModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static HorseModifiers DeserializeLength(BufferStream stream, int length, HorseModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, HorseModifiers instance, HorseModifiers previous)
	{
		if (instance.modifiers == null)
		{
			return;
		}
		for (int i = 0; i < instance.modifiers.Count; i++)
		{
			Modifier modifier = instance.modifiers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Modifier.SerializeDelta(stream, modifier, modifier);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.Modifier)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, HorseModifiers instance)
	{
		if (instance.modifiers == null)
		{
			return;
		}
		for (int i = 0; i < instance.modifiers.Count; i++)
		{
			Modifier instance2 = instance.modifiers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Modifier.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.Modifier)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (modifiers != null)
		{
			for (int i = 0; i < modifiers.Count; i++)
			{
				modifiers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SmartAlarm : IDisposable, IPooled, IProto<SmartAlarm>, IProto
{
	[NonSerialized]
	public List<ulong> subscriptions;

	[NonSerialized]
	public string notificationTitle;

	[NonSerialized]
	public string notificationBody;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SmartAlarm instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.subscriptions != null)
			{
				List<ulong> list = instance.subscriptions;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.subscriptions = list;
			}
			instance.notificationTitle = string.Empty;
			instance.notificationBody = string.Empty;
			Pool.Free<SmartAlarm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SmartAlarm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SmartAlarm instance)
	{
		if (subscriptions != null)
		{
			instance.subscriptions = Pool.Get<List<ulong>>();
			for (int i = 0; i < subscriptions.Count; i++)
			{
				ulong item = subscriptions[i];
				instance.subscriptions.Add(item);
			}
		}
		else
		{
			instance.subscriptions = null;
		}
		instance.notificationTitle = notificationTitle;
		instance.notificationBody = notificationBody;
	}

	public SmartAlarm Copy()
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		CopyTo(smartAlarm);
		return smartAlarm;
	}

	public static SmartAlarm Deserialize(BufferStream stream)
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		Deserialize(stream, smartAlarm, isDelta: false);
		return smartAlarm;
	}

	public static SmartAlarm DeserializeLengthDelimited(BufferStream stream)
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		DeserializeLengthDelimited(stream, smartAlarm, isDelta: false);
		return smartAlarm;
	}

	public static SmartAlarm DeserializeLength(BufferStream stream, int length)
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		DeserializeLength(stream, length, smartAlarm, isDelta: false);
		return smartAlarm;
	}

	public static SmartAlarm Deserialize(byte[] buffer)
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, smartAlarm, isDelta: false);
		return smartAlarm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SmartAlarm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SmartAlarm Deserialize(BufferStream stream, SmartAlarm instance, bool isDelta)
	{
		if (!isDelta && instance.subscriptions == null)
		{
			instance.subscriptions = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.subscriptions.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.notificationTitle = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.notificationBody = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SmartAlarm DeserializeLengthDelimited(BufferStream stream, SmartAlarm instance, bool isDelta)
	{
		if (!isDelta && instance.subscriptions == null)
		{
			instance.subscriptions = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.subscriptions.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.notificationTitle = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.notificationBody = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SmartAlarm DeserializeLength(BufferStream stream, int length, SmartAlarm instance, bool isDelta)
	{
		if (!isDelta && instance.subscriptions == null)
		{
			instance.subscriptions = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.subscriptions.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.notificationTitle = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.notificationBody = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SmartAlarm instance, SmartAlarm previous)
	{
		if (instance.subscriptions != null)
		{
			for (int i = 0; i < instance.subscriptions.Count; i++)
			{
				ulong val = instance.subscriptions[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.notificationTitle != null && instance.notificationTitle != previous.notificationTitle)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.notificationTitle);
		}
		if (instance.notificationBody != null && instance.notificationBody != previous.notificationBody)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.notificationBody);
		}
	}

	public static void Serialize(BufferStream stream, SmartAlarm instance)
	{
		if (instance.subscriptions != null)
		{
			for (int i = 0; i < instance.subscriptions.Count; i++)
			{
				ulong val = instance.subscriptions[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.notificationTitle != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.notificationTitle);
		}
		if (instance.notificationBody != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.notificationBody);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class InstrumentRecording : IDisposable, IPooled, IProto<InstrumentRecording>, IProto
{
	[NonSerialized]
	public List<InstrumentRecordingNote> notes;

	[NonSerialized]
	public int forInstrument;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InstrumentRecording instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.notes != null)
		{
			for (int i = 0; i < instance.notes.Count; i++)
			{
				if (instance.notes[i] != null)
				{
					instance.notes[i].ResetToPool();
					instance.notes[i] = null;
				}
			}
			List<InstrumentRecordingNote> list = instance.notes;
			Pool.Free<InstrumentRecordingNote>(ref list, false);
			instance.notes = list;
		}
		instance.forInstrument = 0;
		Pool.Free<InstrumentRecording>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InstrumentRecording with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InstrumentRecording instance)
	{
		if (notes != null)
		{
			instance.notes = Pool.Get<List<InstrumentRecordingNote>>();
			for (int i = 0; i < notes.Count; i++)
			{
				InstrumentRecordingNote item = notes[i].Copy();
				instance.notes.Add(item);
			}
		}
		else
		{
			instance.notes = null;
		}
		instance.forInstrument = forInstrument;
	}

	public InstrumentRecording Copy()
	{
		InstrumentRecording instrumentRecording = Pool.Get<InstrumentRecording>();
		CopyTo(instrumentRecording);
		return instrumentRecording;
	}

	public static InstrumentRecording Deserialize(BufferStream stream)
	{
		InstrumentRecording instrumentRecording = Pool.Get<InstrumentRecording>();
		Deserialize(stream, instrumentRecording, isDelta: false);
		return instrumentRecording;
	}

	public static InstrumentRecording DeserializeLengthDelimited(BufferStream stream)
	{
		InstrumentRecording instrumentRecording = Pool.Get<InstrumentRecording>();
		DeserializeLengthDelimited(stream, instrumentRecording, isDelta: false);
		return instrumentRecording;
	}

	public static InstrumentRecording DeserializeLength(BufferStream stream, int length)
	{
		InstrumentRecording instrumentRecording = Pool.Get<InstrumentRecording>();
		DeserializeLength(stream, length, instrumentRecording, isDelta: false);
		return instrumentRecording;
	}

	public static InstrumentRecording Deserialize(byte[] buffer)
	{
		InstrumentRecording instrumentRecording = Pool.Get<InstrumentRecording>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instrumentRecording, isDelta: false);
		return instrumentRecording;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InstrumentRecording previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InstrumentRecording Deserialize(BufferStream stream, InstrumentRecording instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<InstrumentRecordingNote>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.notes.Add(InstrumentRecordingNote.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.forInstrument = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InstrumentRecording DeserializeLengthDelimited(BufferStream stream, InstrumentRecording instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<InstrumentRecordingNote>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.notes.Add(InstrumentRecordingNote.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.forInstrument = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InstrumentRecording DeserializeLength(BufferStream stream, int length, InstrumentRecording instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<InstrumentRecordingNote>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.notes.Add(InstrumentRecordingNote.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.forInstrument = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InstrumentRecording instance, InstrumentRecording previous)
	{
		if (instance.notes != null)
		{
			for (int i = 0; i < instance.notes.Count; i++)
			{
				InstrumentRecordingNote instrumentRecordingNote = instance.notes[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				InstrumentRecordingNote.SerializeDelta(stream, instrumentRecordingNote, instrumentRecordingNote);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field notes (ProtoBuf.InstrumentRecordingNote)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.forInstrument != previous.forInstrument)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.forInstrument);
		}
	}

	public static void Serialize(BufferStream stream, InstrumentRecording instance)
	{
		if (instance.notes != null)
		{
			for (int i = 0; i < instance.notes.Count; i++)
			{
				InstrumentRecordingNote instance2 = instance.notes[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				InstrumentRecordingNote.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field notes (ProtoBuf.InstrumentRecordingNote)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.forInstrument != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.forInstrument);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (notes != null)
		{
			for (int i = 0; i < notes.Count; i++)
			{
				notes[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class InstrumentRecordingNote : IDisposable, IPooled, IProto<InstrumentRecordingNote>, IProto
{
	[NonSerialized]
	public float startTime;

	[NonSerialized]
	public float duration;

	[NonSerialized]
	public int note;

	[NonSerialized]
	public int octave;

	[NonSerialized]
	public float velocity;

	[NonSerialized]
	public int noteType;

	[NonSerialized]
	public bool shouldPlay;

	[NonSerialized]
	public bool hasPlayed;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InstrumentRecordingNote instance)
	{
		if (instance.ShouldPool)
		{
			instance.startTime = 0f;
			instance.duration = 0f;
			instance.note = 0;
			instance.octave = 0;
			instance.velocity = 0f;
			instance.noteType = 0;
			instance.shouldPlay = false;
			instance.hasPlayed = false;
			Pool.Free<InstrumentRecordingNote>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InstrumentRecordingNote with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InstrumentRecordingNote instance)
	{
		instance.startTime = startTime;
		instance.duration = duration;
		instance.note = note;
		instance.octave = octave;
		instance.velocity = velocity;
		instance.noteType = noteType;
		instance.shouldPlay = shouldPlay;
		instance.hasPlayed = hasPlayed;
	}

	public InstrumentRecordingNote Copy()
	{
		InstrumentRecordingNote instrumentRecordingNote = Pool.Get<InstrumentRecordingNote>();
		CopyTo(instrumentRecordingNote);
		return instrumentRecordingNote;
	}

	public static InstrumentRecordingNote Deserialize(BufferStream stream)
	{
		InstrumentRecordingNote instrumentRecordingNote = Pool.Get<InstrumentRecordingNote>();
		Deserialize(stream, instrumentRecordingNote, isDelta: false);
		return instrumentRecordingNote;
	}

	public static InstrumentRecordingNote DeserializeLengthDelimited(BufferStream stream)
	{
		InstrumentRecordingNote instrumentRecordingNote = Pool.Get<InstrumentRecordingNote>();
		DeserializeLengthDelimited(stream, instrumentRecordingNote, isDelta: false);
		return instrumentRecordingNote;
	}

	public static InstrumentRecordingNote DeserializeLength(BufferStream stream, int length)
	{
		InstrumentRecordingNote instrumentRecordingNote = Pool.Get<InstrumentRecordingNote>();
		DeserializeLength(stream, length, instrumentRecordingNote, isDelta: false);
		return instrumentRecordingNote;
	}

	public static InstrumentRecordingNote Deserialize(byte[] buffer)
	{
		InstrumentRecordingNote instrumentRecordingNote = Pool.Get<InstrumentRecordingNote>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instrumentRecordingNote, isDelta: false);
		return instrumentRecordingNote;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InstrumentRecordingNote previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InstrumentRecordingNote Deserialize(BufferStream stream, InstrumentRecordingNote instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.startTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.note = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.octave = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 45:
				instance.velocity = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.shouldPlay = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.hasPlayed = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InstrumentRecordingNote DeserializeLengthDelimited(BufferStream stream, InstrumentRecordingNote instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.startTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.note = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.octave = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 45:
				instance.velocity = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.shouldPlay = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.hasPlayed = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InstrumentRecordingNote DeserializeLength(BufferStream stream, int length, InstrumentRecordingNote instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.startTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.note = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.octave = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 45:
				instance.velocity = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.shouldPlay = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.hasPlayed = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InstrumentRecordingNote instance, InstrumentRecordingNote previous)
	{
		if (instance.startTime != previous.startTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.startTime);
		}
		if (instance.duration != previous.duration)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
		if (instance.note != previous.note)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.note);
		}
		if (instance.octave != previous.octave)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.octave);
		}
		if (instance.velocity != previous.velocity)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.velocity);
		}
		if (instance.noteType != previous.noteType)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.shouldPlay);
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.hasPlayed);
	}

	public static void Serialize(BufferStream stream, InstrumentRecordingNote instance)
	{
		if (instance.startTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.startTime);
		}
		if (instance.duration != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
		if (instance.note != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.note);
		}
		if (instance.octave != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.octave);
		}
		if (instance.velocity != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.velocity);
		}
		if (instance.noteType != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
		if (instance.shouldPlay)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.shouldPlay);
		}
		if (instance.hasPlayed)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.hasPlayed);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class InstrumentMidiBindings : IDisposable, IPooled, IProto<InstrumentMidiBindings>, IProto
{
	[NonSerialized]
	public List<InstrumentMidiBinding> bindings;

	[NonSerialized]
	public uint forInstrument;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InstrumentMidiBindings instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.bindings != null)
		{
			for (int i = 0; i < instance.bindings.Count; i++)
			{
				if (instance.bindings[i] != null)
				{
					instance.bindings[i].ResetToPool();
					instance.bindings[i] = null;
				}
			}
			List<InstrumentMidiBinding> list = instance.bindings;
			Pool.Free<InstrumentMidiBinding>(ref list, false);
			instance.bindings = list;
		}
		instance.forInstrument = 0u;
		Pool.Free<InstrumentMidiBindings>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InstrumentMidiBindings with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InstrumentMidiBindings instance)
	{
		if (bindings != null)
		{
			instance.bindings = Pool.Get<List<InstrumentMidiBinding>>();
			for (int i = 0; i < bindings.Count; i++)
			{
				InstrumentMidiBinding item = bindings[i].Copy();
				instance.bindings.Add(item);
			}
		}
		else
		{
			instance.bindings = null;
		}
		instance.forInstrument = forInstrument;
	}

	public InstrumentMidiBindings Copy()
	{
		InstrumentMidiBindings instrumentMidiBindings = Pool.Get<InstrumentMidiBindings>();
		CopyTo(instrumentMidiBindings);
		return instrumentMidiBindings;
	}

	public static InstrumentMidiBindings Deserialize(BufferStream stream)
	{
		InstrumentMidiBindings instrumentMidiBindings = Pool.Get<InstrumentMidiBindings>();
		Deserialize(stream, instrumentMidiBindings, isDelta: false);
		return instrumentMidiBindings;
	}

	public static InstrumentMidiBindings DeserializeLengthDelimited(BufferStream stream)
	{
		InstrumentMidiBindings instrumentMidiBindings = Pool.Get<InstrumentMidiBindings>();
		DeserializeLengthDelimited(stream, instrumentMidiBindings, isDelta: false);
		return instrumentMidiBindings;
	}

	public static InstrumentMidiBindings DeserializeLength(BufferStream stream, int length)
	{
		InstrumentMidiBindings instrumentMidiBindings = Pool.Get<InstrumentMidiBindings>();
		DeserializeLength(stream, length, instrumentMidiBindings, isDelta: false);
		return instrumentMidiBindings;
	}

	public static InstrumentMidiBindings Deserialize(byte[] buffer)
	{
		InstrumentMidiBindings instrumentMidiBindings = Pool.Get<InstrumentMidiBindings>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instrumentMidiBindings, isDelta: false);
		return instrumentMidiBindings;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InstrumentMidiBindings previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InstrumentMidiBindings Deserialize(BufferStream stream, InstrumentMidiBindings instance, bool isDelta)
	{
		if (!isDelta && instance.bindings == null)
		{
			instance.bindings = Pool.Get<List<InstrumentMidiBinding>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.bindings.Add(InstrumentMidiBinding.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.forInstrument = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InstrumentMidiBindings DeserializeLengthDelimited(BufferStream stream, InstrumentMidiBindings instance, bool isDelta)
	{
		if (!isDelta && instance.bindings == null)
		{
			instance.bindings = Pool.Get<List<InstrumentMidiBinding>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.bindings.Add(InstrumentMidiBinding.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.forInstrument = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InstrumentMidiBindings DeserializeLength(BufferStream stream, int length, InstrumentMidiBindings instance, bool isDelta)
	{
		if (!isDelta && instance.bindings == null)
		{
			instance.bindings = Pool.Get<List<InstrumentMidiBinding>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.bindings.Add(InstrumentMidiBinding.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.forInstrument = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InstrumentMidiBindings instance, InstrumentMidiBindings previous)
	{
		if (instance.bindings != null)
		{
			for (int i = 0; i < instance.bindings.Count; i++)
			{
				InstrumentMidiBinding instrumentMidiBinding = instance.bindings[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				InstrumentMidiBinding.SerializeDelta(stream, instrumentMidiBinding, instrumentMidiBinding);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bindings (ProtoBuf.InstrumentMidiBinding)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.forInstrument != previous.forInstrument)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.forInstrument);
		}
	}

	public static void Serialize(BufferStream stream, InstrumentMidiBindings instance)
	{
		if (instance.bindings != null)
		{
			for (int i = 0; i < instance.bindings.Count; i++)
			{
				InstrumentMidiBinding instance2 = instance.bindings[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				InstrumentMidiBinding.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bindings (ProtoBuf.InstrumentMidiBinding)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.forInstrument != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.forInstrument);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (bindings != null)
		{
			for (int i = 0; i < bindings.Count; i++)
			{
				bindings[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class InstrumentMidiBinding : IDisposable, IPooled, IProto<InstrumentMidiBinding>, IProto
{
	[NonSerialized]
	public int noteFrom;

	[NonSerialized]
	public int note;

	[NonSerialized]
	public int noteOctave;

	[NonSerialized]
	public int noteType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InstrumentMidiBinding instance)
	{
		if (instance.ShouldPool)
		{
			instance.noteFrom = 0;
			instance.note = 0;
			instance.noteOctave = 0;
			instance.noteType = 0;
			Pool.Free<InstrumentMidiBinding>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InstrumentMidiBinding with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InstrumentMidiBinding instance)
	{
		instance.noteFrom = noteFrom;
		instance.note = note;
		instance.noteOctave = noteOctave;
		instance.noteType = noteType;
	}

	public InstrumentMidiBinding Copy()
	{
		InstrumentMidiBinding instrumentMidiBinding = Pool.Get<InstrumentMidiBinding>();
		CopyTo(instrumentMidiBinding);
		return instrumentMidiBinding;
	}

	public static InstrumentMidiBinding Deserialize(BufferStream stream)
	{
		InstrumentMidiBinding instrumentMidiBinding = Pool.Get<InstrumentMidiBinding>();
		Deserialize(stream, instrumentMidiBinding, isDelta: false);
		return instrumentMidiBinding;
	}

	public static InstrumentMidiBinding DeserializeLengthDelimited(BufferStream stream)
	{
		InstrumentMidiBinding instrumentMidiBinding = Pool.Get<InstrumentMidiBinding>();
		DeserializeLengthDelimited(stream, instrumentMidiBinding, isDelta: false);
		return instrumentMidiBinding;
	}

	public static InstrumentMidiBinding DeserializeLength(BufferStream stream, int length)
	{
		InstrumentMidiBinding instrumentMidiBinding = Pool.Get<InstrumentMidiBinding>();
		DeserializeLength(stream, length, instrumentMidiBinding, isDelta: false);
		return instrumentMidiBinding;
	}

	public static InstrumentMidiBinding Deserialize(byte[] buffer)
	{
		InstrumentMidiBinding instrumentMidiBinding = Pool.Get<InstrumentMidiBinding>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instrumentMidiBinding, isDelta: false);
		return instrumentMidiBinding;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InstrumentMidiBinding previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InstrumentMidiBinding Deserialize(BufferStream stream, InstrumentMidiBinding instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.noteFrom = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.note = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.noteOctave = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InstrumentMidiBinding DeserializeLengthDelimited(BufferStream stream, InstrumentMidiBinding instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.noteFrom = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.note = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.noteOctave = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InstrumentMidiBinding DeserializeLength(BufferStream stream, int length, InstrumentMidiBinding instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.noteFrom = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.note = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.noteOctave = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InstrumentMidiBinding instance, InstrumentMidiBinding previous)
	{
		if (instance.noteFrom != previous.noteFrom)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteFrom);
		}
		if (instance.note != previous.note)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.note);
		}
		if (instance.noteOctave != previous.noteOctave)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteOctave);
		}
		if (instance.noteType != previous.noteType)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
	}

	public static void Serialize(BufferStream stream, InstrumentMidiBinding instance)
	{
		if (instance.noteFrom != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteFrom);
		}
		if (instance.note != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.note);
		}
		if (instance.noteOctave != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteOctave);
		}
		if (instance.noteType != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LightString : IDisposable, IPooled, IProto<LightString>, IProto
{
	public class StringPoint : IDisposable, IPooled, IProto<StringPoint>, IProto
	{
		[NonSerialized]
		public Vector3 point;

		[NonSerialized]
		public Vector3 normal;

		[NonSerialized]
		public float slack;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(StringPoint instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.point = default(Vector3);
				instance.normal = default(Vector3);
				instance.slack = 0f;
				Pool.Free<StringPoint>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose StringPoint with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(StringPoint instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			instance.point = point;
			instance.normal = normal;
			instance.slack = slack;
		}

		public StringPoint Copy()
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			CopyTo(stringPoint);
			return stringPoint;
		}

		public static StringPoint Deserialize(BufferStream stream)
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			Deserialize(stream, stringPoint, isDelta: false);
			return stringPoint;
		}

		public static StringPoint DeserializeLengthDelimited(BufferStream stream)
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			DeserializeLengthDelimited(stream, stringPoint, isDelta: false);
			return stringPoint;
		}

		public static StringPoint DeserializeLength(BufferStream stream, int length)
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			DeserializeLength(stream, length, stringPoint, isDelta: false);
			return stringPoint;
		}

		public static StringPoint Deserialize(byte[] buffer)
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, stringPoint, isDelta: false);
			return stringPoint;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, StringPoint previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static StringPoint Deserialize(BufferStream stream, StringPoint instance, bool isDelta)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
					continue;
				case 29:
					instance.slack = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static StringPoint DeserializeLengthDelimited(BufferStream stream, StringPoint instance, bool isDelta)
		{
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
					continue;
				case 29:
					instance.slack = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static StringPoint DeserializeLength(BufferStream stream, int length, StringPoint instance, bool isDelta)
		{
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
					continue;
				case 29:
					instance.slack = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, StringPoint instance, StringPoint previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			if (instance.point != previous.point)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.point, previous.point);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field point (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.normal != previous.normal)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.slack != previous.slack)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.slack);
			}
		}

		public static void Serialize(BufferStream stream, StringPoint instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			if (instance.point != default(Vector3))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance.point);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field point (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.normal != default(Vector3))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.normal);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.slack != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.slack);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<StringPoint> points;

	[NonSerialized]
	public int lengthUsed;

	[NonSerialized]
	public int animationStyle;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LightString instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.points != null)
		{
			for (int i = 0; i < instance.points.Count; i++)
			{
				if (instance.points[i] != null)
				{
					instance.points[i].ResetToPool();
					instance.points[i] = null;
				}
			}
			List<StringPoint> list = instance.points;
			Pool.Free<StringPoint>(ref list, false);
			instance.points = list;
		}
		instance.lengthUsed = 0;
		instance.animationStyle = 0;
		Pool.Free<LightString>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LightString with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LightString instance)
	{
		if (points != null)
		{
			instance.points = Pool.Get<List<StringPoint>>();
			for (int i = 0; i < points.Count; i++)
			{
				StringPoint item = points[i].Copy();
				instance.points.Add(item);
			}
		}
		else
		{
			instance.points = null;
		}
		instance.lengthUsed = lengthUsed;
		instance.animationStyle = animationStyle;
	}

	public LightString Copy()
	{
		LightString lightString = Pool.Get<LightString>();
		CopyTo(lightString);
		return lightString;
	}

	public static LightString Deserialize(BufferStream stream)
	{
		LightString lightString = Pool.Get<LightString>();
		Deserialize(stream, lightString, isDelta: false);
		return lightString;
	}

	public static LightString DeserializeLengthDelimited(BufferStream stream)
	{
		LightString lightString = Pool.Get<LightString>();
		DeserializeLengthDelimited(stream, lightString, isDelta: false);
		return lightString;
	}

	public static LightString DeserializeLength(BufferStream stream, int length)
	{
		LightString lightString = Pool.Get<LightString>();
		DeserializeLength(stream, length, lightString, isDelta: false);
		return lightString;
	}

	public static LightString Deserialize(byte[] buffer)
	{
		LightString lightString = Pool.Get<LightString>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lightString, isDelta: false);
		return lightString;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LightString previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LightString Deserialize(BufferStream stream, LightString instance, bool isDelta)
	{
		if (!isDelta && instance.points == null)
		{
			instance.points = Pool.Get<List<StringPoint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.points.Add(StringPoint.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lengthUsed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.animationStyle = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LightString DeserializeLengthDelimited(BufferStream stream, LightString instance, bool isDelta)
	{
		if (!isDelta && instance.points == null)
		{
			instance.points = Pool.Get<List<StringPoint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.points.Add(StringPoint.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lengthUsed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.animationStyle = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LightString DeserializeLength(BufferStream stream, int length, LightString instance, bool isDelta)
	{
		if (!isDelta && instance.points == null)
		{
			instance.points = Pool.Get<List<StringPoint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.points.Add(StringPoint.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lengthUsed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.animationStyle = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LightString instance, LightString previous)
	{
		if (instance.points != null)
		{
			for (int i = 0; i < instance.points.Count; i++)
			{
				StringPoint stringPoint = instance.points[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				StringPoint.SerializeDelta(stream, stringPoint, stringPoint);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field points (ProtoBuf.LightString.StringPoint)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.lengthUsed != previous.lengthUsed)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lengthUsed);
		}
		if (instance.animationStyle != previous.animationStyle)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.animationStyle);
		}
	}

	public static void Serialize(BufferStream stream, LightString instance)
	{
		if (instance.points != null)
		{
			for (int i = 0; i < instance.points.Count; i++)
			{
				StringPoint instance2 = instance.points[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				StringPoint.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field points (ProtoBuf.LightString.StringPoint)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.lengthUsed != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lengthUsed);
		}
		if (instance.animationStyle != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.animationStyle);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (points != null)
		{
			for (int i = 0; i < points.Count; i++)
			{
				points[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class LightDeployer : IDisposable, IPooled, IProto<LightDeployer>, IProto
{
	[NonSerialized]
	public NetworkableId active;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LightDeployer instance)
	{
		if (instance.ShouldPool)
		{
			instance.active = default(NetworkableId);
			Pool.Free<LightDeployer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LightDeployer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LightDeployer instance)
	{
		instance.active = active;
	}

	public LightDeployer Copy()
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		CopyTo(lightDeployer);
		return lightDeployer;
	}

	public static LightDeployer Deserialize(BufferStream stream)
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		Deserialize(stream, lightDeployer, isDelta: false);
		return lightDeployer;
	}

	public static LightDeployer DeserializeLengthDelimited(BufferStream stream)
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		DeserializeLengthDelimited(stream, lightDeployer, isDelta: false);
		return lightDeployer;
	}

	public static LightDeployer DeserializeLength(BufferStream stream, int length)
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		DeserializeLength(stream, length, lightDeployer, isDelta: false);
		return lightDeployer;
	}

	public static LightDeployer Deserialize(byte[] buffer)
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lightDeployer, isDelta: false);
		return lightDeployer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LightDeployer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LightDeployer Deserialize(BufferStream stream, LightDeployer instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.active = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LightDeployer DeserializeLengthDelimited(BufferStream stream, LightDeployer instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.active = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LightDeployer DeserializeLength(BufferStream stream, int length, LightDeployer instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.active = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LightDeployer instance, LightDeployer previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.active.Value);
	}

	public static void Serialize(BufferStream stream, LightDeployer instance)
	{
		if (instance.active != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.active.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref active.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class RCEntity : IDisposable, IPooled, IProto<RCEntity>, IProto
{
	[NonSerialized]
	public Vector3 aim;

	[NonSerialized]
	public float zoom;

	[NonSerialized]
	public string identifier;

	[NonSerialized]
	public string password;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RCEntity instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.aim = default(Vector3);
			instance.zoom = 0f;
			instance.identifier = string.Empty;
			instance.password = string.Empty;
			Pool.Free<RCEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RCEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RCEntity instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.aim = aim;
		instance.zoom = zoom;
		instance.identifier = identifier;
		instance.password = password;
	}

	public RCEntity Copy()
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		CopyTo(rCEntity);
		return rCEntity;
	}

	public static RCEntity Deserialize(BufferStream stream)
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		Deserialize(stream, rCEntity, isDelta: false);
		return rCEntity;
	}

	public static RCEntity DeserializeLengthDelimited(BufferStream stream)
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		DeserializeLengthDelimited(stream, rCEntity, isDelta: false);
		return rCEntity;
	}

	public static RCEntity DeserializeLength(BufferStream stream, int length)
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		DeserializeLength(stream, length, rCEntity, isDelta: false);
		return rCEntity;
	}

	public static RCEntity Deserialize(byte[] buffer)
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, rCEntity, isDelta: false);
		return rCEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RCEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RCEntity Deserialize(BufferStream stream, RCEntity instance, bool isDelta)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aim, isDelta);
				continue;
			case 21:
				instance.zoom = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.password = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RCEntity DeserializeLengthDelimited(BufferStream stream, RCEntity instance, bool isDelta)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aim, isDelta);
				continue;
			case 21:
				instance.zoom = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.password = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RCEntity DeserializeLength(BufferStream stream, int length, RCEntity instance, bool isDelta)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aim, isDelta);
				continue;
			case 21:
				instance.zoom = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.password = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RCEntity instance, RCEntity previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aim != previous.aim)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aim, previous.aim);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aim (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.zoom != previous.zoom)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.zoom);
		}
		if (instance.identifier != null && instance.identifier != previous.identifier)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.identifier);
		}
		if (instance.password != null && instance.password != previous.password)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.password);
		}
	}

	public static void Serialize(BufferStream stream, RCEntity instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aim != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aim);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aim (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.zoom != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.zoom);
		}
		if (instance.identifier != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.identifier);
		}
		if (instance.password != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.password);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ComputerStation : IDisposable, IPooled, IProto<ComputerStation>, IProto
{
	[NonSerialized]
	public string bookmarks;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ComputerStation instance)
	{
		if (instance.ShouldPool)
		{
			instance.bookmarks = string.Empty;
			Pool.Free<ComputerStation>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ComputerStation with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ComputerStation instance)
	{
		instance.bookmarks = bookmarks;
	}

	public ComputerStation Copy()
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		CopyTo(computerStation);
		return computerStation;
	}

	public static ComputerStation Deserialize(BufferStream stream)
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		Deserialize(stream, computerStation, isDelta: false);
		return computerStation;
	}

	public static ComputerStation DeserializeLengthDelimited(BufferStream stream)
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		DeserializeLengthDelimited(stream, computerStation, isDelta: false);
		return computerStation;
	}

	public static ComputerStation DeserializeLength(BufferStream stream, int length)
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		DeserializeLength(stream, length, computerStation, isDelta: false);
		return computerStation;
	}

	public static ComputerStation Deserialize(byte[] buffer)
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, computerStation, isDelta: false);
		return computerStation;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ComputerStation previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ComputerStation Deserialize(BufferStream stream, ComputerStation instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.bookmarks = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ComputerStation DeserializeLengthDelimited(BufferStream stream, ComputerStation instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.bookmarks = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ComputerStation DeserializeLength(BufferStream stream, int length, ComputerStation instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.bookmarks = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ComputerStation instance, ComputerStation previous)
	{
		if (instance.bookmarks != null && instance.bookmarks != previous.bookmarks)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.bookmarks);
		}
	}

	public static void Serialize(BufferStream stream, ComputerStation instance)
	{
		if (instance.bookmarks != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.bookmarks);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Composter : IDisposable, IPooled, IProto<Composter>, IProto
{
	[NonSerialized]
	public float fertilizerProductionProgress;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Composter instance)
	{
		if (instance.ShouldPool)
		{
			instance.fertilizerProductionProgress = 0f;
			Pool.Free<Composter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Composter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Composter instance)
	{
		instance.fertilizerProductionProgress = fertilizerProductionProgress;
	}

	public Composter Copy()
	{
		Composter composter = Pool.Get<Composter>();
		CopyTo(composter);
		return composter;
	}

	public static Composter Deserialize(BufferStream stream)
	{
		Composter composter = Pool.Get<Composter>();
		Deserialize(stream, composter, isDelta: false);
		return composter;
	}

	public static Composter DeserializeLengthDelimited(BufferStream stream)
	{
		Composter composter = Pool.Get<Composter>();
		DeserializeLengthDelimited(stream, composter, isDelta: false);
		return composter;
	}

	public static Composter DeserializeLength(BufferStream stream, int length)
	{
		Composter composter = Pool.Get<Composter>();
		DeserializeLength(stream, length, composter, isDelta: false);
		return composter;
	}

	public static Composter Deserialize(byte[] buffer)
	{
		Composter composter = Pool.Get<Composter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, composter, isDelta: false);
		return composter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Composter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Composter Deserialize(BufferStream stream, Composter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.fertilizerProductionProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Composter DeserializeLengthDelimited(BufferStream stream, Composter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fertilizerProductionProgress = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Composter DeserializeLength(BufferStream stream, int length, Composter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fertilizerProductionProgress = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Composter instance, Composter previous)
	{
		if (instance.fertilizerProductionProgress != previous.fertilizerProductionProgress)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fertilizerProductionProgress);
		}
	}

	public static void Serialize(BufferStream stream, Composter instance)
	{
		if (instance.fertilizerProductionProgress != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fertilizerProductionProgress);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VehicleVendor : IDisposable, IPooled, IProto<VehicleVendor>, IProto
{
	public class PlayerStorage : IDisposable, IPooled, IProto<PlayerStorage>, IProto
	{
		public class PlayerStoredVehicle : IDisposable, IPooled, IProto<PlayerStoredVehicle>, IProto
		{
			[NonSerialized]
			public string shortname;

			[NonSerialized]
			public string resourcePath;

			[NonSerialized]
			public float health;

			public bool ShouldPool = true;

			private bool _disposed;

			public static void ResetToPool(PlayerStoredVehicle instance)
			{
				if (instance.ShouldPool)
				{
					instance.shortname = string.Empty;
					instance.resourcePath = string.Empty;
					instance.health = 0f;
					Pool.Free<PlayerStoredVehicle>(ref instance);
				}
			}

			public void ResetToPool()
			{
				ResetToPool(this);
			}

			public virtual void Dispose()
			{
				if (!ShouldPool)
				{
					throw new Exception("Trying to dispose PlayerStoredVehicle with ShouldPool set to false!");
				}
				if (!_disposed)
				{
					ResetToPool();
					_disposed = true;
				}
			}

			public virtual void EnterPool()
			{
				_disposed = true;
			}

			public virtual void LeavePool()
			{
				_disposed = false;
			}

			public void CopyTo(PlayerStoredVehicle instance)
			{
				instance.shortname = shortname;
				instance.resourcePath = resourcePath;
				instance.health = health;
			}

			public PlayerStoredVehicle Copy()
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				CopyTo(playerStoredVehicle);
				return playerStoredVehicle;
			}

			public static PlayerStoredVehicle Deserialize(BufferStream stream)
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				Deserialize(stream, playerStoredVehicle, isDelta: false);
				return playerStoredVehicle;
			}

			public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream)
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				DeserializeLengthDelimited(stream, playerStoredVehicle, isDelta: false);
				return playerStoredVehicle;
			}

			public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length)
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				DeserializeLength(stream, length, playerStoredVehicle, isDelta: false);
				return playerStoredVehicle;
			}

			public static PlayerStoredVehicle Deserialize(byte[] buffer)
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
				Deserialize(stream, playerStoredVehicle, isDelta: false);
				return playerStoredVehicle;
			}

			public void FromProto(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void WriteToStream(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public virtual void WriteToStreamDelta(BufferStream stream, PlayerStoredVehicle previous)
			{
				if (previous == null)
				{
					Serialize(stream, this);
				}
				else
				{
					SerializeDelta(stream, this, previous);
				}
			}

			public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
			{
				DeserializeLength(stream, size, this, isDelta);
			}

			public static PlayerStoredVehicle Deserialize(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
			{
				while (true)
				{
					int num = stream.ReadByte();
					switch (num)
					{
					case 10:
						instance.shortname = ProtocolParser.ReadString(stream);
						continue;
					case 18:
						instance.resourcePath = ProtocolParser.ReadString(stream);
						continue;
					case 29:
						instance.health = ProtocolParser.ReadSingle(stream);
						continue;
					case -1:
						return instance;
					}
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
			}

			public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
			{
				long num = ProtocolParser.ReadUInt32(stream);
				num += stream.Position;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						instance.shortname = ProtocolParser.ReadString(stream);
						continue;
					case 18:
						instance.resourcePath = ProtocolParser.ReadString(stream);
						continue;
					case 29:
						instance.health = ProtocolParser.ReadSingle(stream);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length, PlayerStoredVehicle instance, bool isDelta)
			{
				long num = stream.Position + length;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						instance.shortname = ProtocolParser.ReadString(stream);
						continue;
					case 18:
						instance.resourcePath = ProtocolParser.ReadString(stream);
						continue;
					case 29:
						instance.health = ProtocolParser.ReadSingle(stream);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static void SerializeDelta(BufferStream stream, PlayerStoredVehicle instance, PlayerStoredVehicle previous)
			{
				if (instance.shortname != null && instance.shortname != previous.shortname)
				{
					stream.WriteByte(10);
					ProtocolParser.WriteString(stream, instance.shortname);
				}
				if (instance.resourcePath != null && instance.resourcePath != previous.resourcePath)
				{
					stream.WriteByte(18);
					ProtocolParser.WriteString(stream, instance.resourcePath);
				}
				if (instance.health != previous.health)
				{
					stream.WriteByte(29);
					ProtocolParser.WriteSingle(stream, instance.health);
				}
			}

			public static void Serialize(BufferStream stream, PlayerStoredVehicle instance)
			{
				if (instance.shortname != null)
				{
					stream.WriteByte(10);
					ProtocolParser.WriteString(stream, instance.shortname);
				}
				if (instance.resourcePath != null)
				{
					stream.WriteByte(18);
					ProtocolParser.WriteString(stream, instance.resourcePath);
				}
				if (instance.health != 0f)
				{
					stream.WriteByte(29);
					ProtocolParser.WriteSingle(stream, instance.health);
				}
			}

			public void ToProto(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public void InspectUids(UidInspector<ulong> action)
			{
			}
		}

		[NonSerialized]
		public ulong userid;

		[NonSerialized]
		public List<PlayerStoredVehicle> storedVehicles;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerStorage instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			instance.userid = 0uL;
			if (instance.storedVehicles != null)
			{
				for (int i = 0; i < instance.storedVehicles.Count; i++)
				{
					if (instance.storedVehicles[i] != null)
					{
						instance.storedVehicles[i].ResetToPool();
						instance.storedVehicles[i] = null;
					}
				}
				List<PlayerStoredVehicle> list = instance.storedVehicles;
				Pool.Free<PlayerStoredVehicle>(ref list, false);
				instance.storedVehicles = list;
			}
			Pool.Free<PlayerStorage>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerStorage with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerStorage instance)
		{
			instance.userid = userid;
			if (storedVehicles != null)
			{
				instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
				for (int i = 0; i < storedVehicles.Count; i++)
				{
					PlayerStoredVehicle item = storedVehicles[i].Copy();
					instance.storedVehicles.Add(item);
				}
			}
			else
			{
				instance.storedVehicles = null;
			}
		}

		public PlayerStorage Copy()
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			CopyTo(playerStorage);
			return playerStorage;
		}

		public static PlayerStorage Deserialize(BufferStream stream)
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			Deserialize(stream, playerStorage, isDelta: false);
			return playerStorage;
		}

		public static PlayerStorage DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			DeserializeLengthDelimited(stream, playerStorage, isDelta: false);
			return playerStorage;
		}

		public static PlayerStorage DeserializeLength(BufferStream stream, int length)
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			DeserializeLength(stream, length, playerStorage, isDelta: false);
			return playerStorage;
		}

		public static PlayerStorage Deserialize(byte[] buffer)
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerStorage, isDelta: false);
			return playerStorage;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerStorage previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerStorage Deserialize(BufferStream stream, PlayerStorage instance, bool isDelta)
		{
			if (!isDelta && instance.storedVehicles == null)
			{
				instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerStorage DeserializeLengthDelimited(BufferStream stream, PlayerStorage instance, bool isDelta)
		{
			if (!isDelta && instance.storedVehicles == null)
			{
				instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerStorage DeserializeLength(BufferStream stream, int length, PlayerStorage instance, bool isDelta)
		{
			if (!isDelta && instance.storedVehicles == null)
			{
				instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerStorage instance, PlayerStorage previous)
		{
			if (instance.userid != previous.userid)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.storedVehicles == null)
			{
				return;
			}
			for (int i = 0; i < instance.storedVehicles.Count; i++)
			{
				PlayerStoredVehicle playerStoredVehicle = instance.storedVehicles[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerStoredVehicle.SerializeDelta(stream, playerStoredVehicle, playerStoredVehicle);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public static void Serialize(BufferStream stream, PlayerStorage instance)
		{
			if (instance.userid != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.storedVehicles == null)
			{
				return;
			}
			for (int i = 0; i < instance.storedVehicles.Count; i++)
			{
				PlayerStoredVehicle instance2 = instance.storedVehicles[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerStoredVehicle.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (storedVehicles != null)
			{
				for (int i = 0; i < storedVehicles.Count; i++)
				{
					storedVehicles[i]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public List<PlayerStorage> playerStorage;

	[NonSerialized]
	public NetworkableId spawnerRef;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VehicleVendor instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.playerStorage != null)
		{
			for (int i = 0; i < instance.playerStorage.Count; i++)
			{
				if (instance.playerStorage[i] != null)
				{
					instance.playerStorage[i].ResetToPool();
					instance.playerStorage[i] = null;
				}
			}
			List<PlayerStorage> list = instance.playerStorage;
			Pool.Free<PlayerStorage>(ref list, false);
			instance.playerStorage = list;
		}
		instance.spawnerRef = default(NetworkableId);
		Pool.Free<VehicleVendor>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VehicleVendor with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VehicleVendor instance)
	{
		if (playerStorage != null)
		{
			instance.playerStorage = Pool.Get<List<PlayerStorage>>();
			for (int i = 0; i < playerStorage.Count; i++)
			{
				PlayerStorage item = playerStorage[i].Copy();
				instance.playerStorage.Add(item);
			}
		}
		else
		{
			instance.playerStorage = null;
		}
		instance.spawnerRef = spawnerRef;
	}

	public VehicleVendor Copy()
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		CopyTo(vehicleVendor);
		return vehicleVendor;
	}

	public static VehicleVendor Deserialize(BufferStream stream)
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		Deserialize(stream, vehicleVendor, isDelta: false);
		return vehicleVendor;
	}

	public static VehicleVendor DeserializeLengthDelimited(BufferStream stream)
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		DeserializeLengthDelimited(stream, vehicleVendor, isDelta: false);
		return vehicleVendor;
	}

	public static VehicleVendor DeserializeLength(BufferStream stream, int length)
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		DeserializeLength(stream, length, vehicleVendor, isDelta: false);
		return vehicleVendor;
	}

	public static VehicleVendor Deserialize(byte[] buffer)
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vehicleVendor, isDelta: false);
		return vehicleVendor;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VehicleVendor previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VehicleVendor Deserialize(BufferStream stream, VehicleVendor instance, bool isDelta)
	{
		if (!isDelta && instance.playerStorage == null)
		{
			instance.playerStorage = Pool.Get<List<PlayerStorage>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.playerStorage.Add(PlayerStorage.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.spawnerRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VehicleVendor DeserializeLengthDelimited(BufferStream stream, VehicleVendor instance, bool isDelta)
	{
		if (!isDelta && instance.playerStorage == null)
		{
			instance.playerStorage = Pool.Get<List<PlayerStorage>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerStorage.Add(PlayerStorage.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.spawnerRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VehicleVendor DeserializeLength(BufferStream stream, int length, VehicleVendor instance, bool isDelta)
	{
		if (!isDelta && instance.playerStorage == null)
		{
			instance.playerStorage = Pool.Get<List<PlayerStorage>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerStorage.Add(PlayerStorage.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.spawnerRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VehicleVendor instance, VehicleVendor previous)
	{
		if (instance.playerStorage != null)
		{
			for (int i = 0; i < instance.playerStorage.Count; i++)
			{
				PlayerStorage playerStorage = instance.playerStorage[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerStorage.SerializeDelta(stream, playerStorage, playerStorage);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.spawnerRef.Value);
	}

	public static void Serialize(BufferStream stream, VehicleVendor instance)
	{
		if (instance.playerStorage != null)
		{
			for (int i = 0; i < instance.playerStorage.Count; i++)
			{
				PlayerStorage instance2 = instance.playerStorage[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerStorage.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.spawnerRef != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.spawnerRef.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (playerStorage != null)
		{
			for (int i = 0; i < playerStorage.Count; i++)
			{
				playerStorage[i]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref spawnerRef.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ShopKeeper : IDisposable, IPooled, IProto<ShopKeeper>, IProto
{
	[NonSerialized]
	public NetworkableId vendingRef;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ShopKeeper instance)
	{
		if (instance.ShouldPool)
		{
			instance.vendingRef = default(NetworkableId);
			Pool.Free<ShopKeeper>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ShopKeeper with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ShopKeeper instance)
	{
		instance.vendingRef = vendingRef;
	}

	public ShopKeeper Copy()
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		CopyTo(shopKeeper);
		return shopKeeper;
	}

	public static ShopKeeper Deserialize(BufferStream stream)
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		Deserialize(stream, shopKeeper, isDelta: false);
		return shopKeeper;
	}

	public static ShopKeeper DeserializeLengthDelimited(BufferStream stream)
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		DeserializeLengthDelimited(stream, shopKeeper, isDelta: false);
		return shopKeeper;
	}

	public static ShopKeeper DeserializeLength(BufferStream stream, int length)
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		DeserializeLength(stream, length, shopKeeper, isDelta: false);
		return shopKeeper;
	}

	public static ShopKeeper Deserialize(byte[] buffer)
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, shopKeeper, isDelta: false);
		return shopKeeper;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ShopKeeper previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ShopKeeper Deserialize(BufferStream stream, ShopKeeper instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.vendingRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ShopKeeper DeserializeLengthDelimited(BufferStream stream, ShopKeeper instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.vendingRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ShopKeeper DeserializeLength(BufferStream stream, int length, ShopKeeper instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.vendingRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ShopKeeper instance, ShopKeeper previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.vendingRef.Value);
	}

	public static void Serialize(BufferStream stream, ShopKeeper instance)
	{
		if (instance.vendingRef != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.vendingRef.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref vendingRef.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WaterPool : IDisposable, IPooled, IProto<WaterPool>, IProto
{
	[NonSerialized]
	public float fillAmount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WaterPool instance)
	{
		if (instance.ShouldPool)
		{
			instance.fillAmount = 0f;
			Pool.Free<WaterPool>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WaterPool with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WaterPool instance)
	{
		instance.fillAmount = fillAmount;
	}

	public WaterPool Copy()
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		CopyTo(waterPool);
		return waterPool;
	}

	public static WaterPool Deserialize(BufferStream stream)
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		Deserialize(stream, waterPool, isDelta: false);
		return waterPool;
	}

	public static WaterPool DeserializeLengthDelimited(BufferStream stream)
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		DeserializeLengthDelimited(stream, waterPool, isDelta: false);
		return waterPool;
	}

	public static WaterPool DeserializeLength(BufferStream stream, int length)
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		DeserializeLength(stream, length, waterPool, isDelta: false);
		return waterPool;
	}

	public static WaterPool Deserialize(byte[] buffer)
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, waterPool, isDelta: false);
		return waterPool;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WaterPool previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WaterPool Deserialize(BufferStream stream, WaterPool instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.fillAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WaterPool DeserializeLengthDelimited(BufferStream stream, WaterPool instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fillAmount = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WaterPool DeserializeLength(BufferStream stream, int length, WaterPool instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fillAmount = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WaterPool instance, WaterPool previous)
	{
		if (instance.fillAmount != previous.fillAmount)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fillAmount);
		}
	}

	public static void Serialize(BufferStream stream, WaterPool instance)
	{
		if (instance.fillAmount != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fillAmount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Photo : IDisposable, IPooled, IProto<Photo>, IProto
{
	[NonSerialized]
	public ulong photographerSteamId;

	[NonSerialized]
	public uint imageCrc;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Photo instance)
	{
		if (instance.ShouldPool)
		{
			instance.photographerSteamId = 0uL;
			instance.imageCrc = 0u;
			Pool.Free<Photo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Photo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Photo instance)
	{
		instance.photographerSteamId = photographerSteamId;
		instance.imageCrc = imageCrc;
	}

	public Photo Copy()
	{
		Photo photo = Pool.Get<Photo>();
		CopyTo(photo);
		return photo;
	}

	public static Photo Deserialize(BufferStream stream)
	{
		Photo photo = Pool.Get<Photo>();
		Deserialize(stream, photo, isDelta: false);
		return photo;
	}

	public static Photo DeserializeLengthDelimited(BufferStream stream)
	{
		Photo photo = Pool.Get<Photo>();
		DeserializeLengthDelimited(stream, photo, isDelta: false);
		return photo;
	}

	public static Photo DeserializeLength(BufferStream stream, int length)
	{
		Photo photo = Pool.Get<Photo>();
		DeserializeLength(stream, length, photo, isDelta: false);
		return photo;
	}

	public static Photo Deserialize(byte[] buffer)
	{
		Photo photo = Pool.Get<Photo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, photo, isDelta: false);
		return photo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Photo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Photo Deserialize(BufferStream stream, Photo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.photographerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Photo DeserializeLengthDelimited(BufferStream stream, Photo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.photographerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Photo DeserializeLength(BufferStream stream, int length, Photo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.photographerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Photo instance, Photo previous)
	{
		if (instance.photographerSteamId != previous.photographerSteamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.photographerSteamId);
		}
		if (instance.imageCrc != previous.imageCrc)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
	}

	public static void Serialize(BufferStream stream, Photo instance)
	{
		if (instance.photographerSteamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.photographerSteamId);
		}
		if (instance.imageCrc != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PhotoFrame : IDisposable, IPooled, IProto<PhotoFrame>, IProto
{
	[NonSerialized]
	public NetworkableId photoEntityId;

	[NonSerialized]
	public uint overlayImageCrc;

	[NonSerialized]
	public List<ulong> editHistory;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PhotoFrame instance)
	{
		if (instance.ShouldPool)
		{
			instance.photoEntityId = default(NetworkableId);
			instance.overlayImageCrc = 0u;
			if (instance.editHistory != null)
			{
				List<ulong> list = instance.editHistory;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.editHistory = list;
			}
			Pool.Free<PhotoFrame>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PhotoFrame with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PhotoFrame instance)
	{
		instance.photoEntityId = photoEntityId;
		instance.overlayImageCrc = overlayImageCrc;
		if (editHistory != null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
			for (int i = 0; i < editHistory.Count; i++)
			{
				ulong item = editHistory[i];
				instance.editHistory.Add(item);
			}
		}
		else
		{
			instance.editHistory = null;
		}
	}

	public PhotoFrame Copy()
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		CopyTo(photoFrame);
		return photoFrame;
	}

	public static PhotoFrame Deserialize(BufferStream stream)
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		Deserialize(stream, photoFrame, isDelta: false);
		return photoFrame;
	}

	public static PhotoFrame DeserializeLengthDelimited(BufferStream stream)
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		DeserializeLengthDelimited(stream, photoFrame, isDelta: false);
		return photoFrame;
	}

	public static PhotoFrame DeserializeLength(BufferStream stream, int length)
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		DeserializeLength(stream, length, photoFrame, isDelta: false);
		return photoFrame;
	}

	public static PhotoFrame Deserialize(byte[] buffer)
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, photoFrame, isDelta: false);
		return photoFrame;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PhotoFrame previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PhotoFrame Deserialize(BufferStream stream, PhotoFrame instance, bool isDelta)
	{
		if (!isDelta && instance.editHistory == null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.photoEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.overlayImageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PhotoFrame DeserializeLengthDelimited(BufferStream stream, PhotoFrame instance, bool isDelta)
	{
		if (!isDelta && instance.editHistory == null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.photoEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.overlayImageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PhotoFrame DeserializeLength(BufferStream stream, int length, PhotoFrame instance, bool isDelta)
	{
		if (!isDelta && instance.editHistory == null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.photoEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.overlayImageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PhotoFrame instance, PhotoFrame previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.photoEntityId.Value);
		if (instance.overlayImageCrc != previous.overlayImageCrc)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.overlayImageCrc);
		}
		if (instance.editHistory != null)
		{
			for (int i = 0; i < instance.editHistory.Count; i++)
			{
				ulong val = instance.editHistory[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, PhotoFrame instance)
	{
		if (instance.photoEntityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.photoEntityId.Value);
		}
		if (instance.overlayImageCrc != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.overlayImageCrc);
		}
		if (instance.editHistory != null)
		{
			for (int i = 0; i < instance.editHistory.Count; i++)
			{
				ulong val = instance.editHistory[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref photoEntityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VehicleModule : IDisposable, IPooled, IProto<VehicleModule>, IProto
{
	[NonSerialized]
	public int socketIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VehicleModule instance)
	{
		if (instance.ShouldPool)
		{
			instance.socketIndex = 0;
			Pool.Free<VehicleModule>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VehicleModule with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VehicleModule instance)
	{
		instance.socketIndex = socketIndex;
	}

	public VehicleModule Copy()
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		CopyTo(vehicleModule);
		return vehicleModule;
	}

	public static VehicleModule Deserialize(BufferStream stream)
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		Deserialize(stream, vehicleModule, isDelta: false);
		return vehicleModule;
	}

	public static VehicleModule DeserializeLengthDelimited(BufferStream stream)
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		DeserializeLengthDelimited(stream, vehicleModule, isDelta: false);
		return vehicleModule;
	}

	public static VehicleModule DeserializeLength(BufferStream stream, int length)
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		DeserializeLength(stream, length, vehicleModule, isDelta: false);
		return vehicleModule;
	}

	public static VehicleModule Deserialize(byte[] buffer)
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vehicleModule, isDelta: false);
		return vehicleModule;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VehicleModule previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VehicleModule Deserialize(BufferStream stream, VehicleModule instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.socketIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VehicleModule DeserializeLengthDelimited(BufferStream stream, VehicleModule instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.socketIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VehicleModule DeserializeLength(BufferStream stream, int length, VehicleModule instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.socketIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VehicleModule instance, VehicleModule previous)
	{
		if (instance.socketIndex != previous.socketIndex)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.socketIndex);
		}
	}

	public static void Serialize(BufferStream stream, VehicleModule instance)
	{
		if (instance.socketIndex != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.socketIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MixingTable : IDisposable, IPooled, IProto<MixingTable>, IProto
{
	[NonSerialized]
	public float totalMixTime;

	[NonSerialized]
	public float remainingMixTime;

	[NonSerialized]
	public int currentRecipe;

	[NonSerialized]
	public int pendingItem;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MixingTable instance)
	{
		if (instance.ShouldPool)
		{
			instance.totalMixTime = 0f;
			instance.remainingMixTime = 0f;
			instance.currentRecipe = 0;
			instance.pendingItem = 0;
			Pool.Free<MixingTable>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MixingTable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MixingTable instance)
	{
		instance.totalMixTime = totalMixTime;
		instance.remainingMixTime = remainingMixTime;
		instance.currentRecipe = currentRecipe;
		instance.pendingItem = pendingItem;
	}

	public MixingTable Copy()
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		CopyTo(mixingTable);
		return mixingTable;
	}

	public static MixingTable Deserialize(BufferStream stream)
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		Deserialize(stream, mixingTable, isDelta: false);
		return mixingTable;
	}

	public static MixingTable DeserializeLengthDelimited(BufferStream stream)
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		DeserializeLengthDelimited(stream, mixingTable, isDelta: false);
		return mixingTable;
	}

	public static MixingTable DeserializeLength(BufferStream stream, int length)
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		DeserializeLength(stream, length, mixingTable, isDelta: false);
		return mixingTable;
	}

	public static MixingTable Deserialize(byte[] buffer)
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mixingTable, isDelta: false);
		return mixingTable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MixingTable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MixingTable Deserialize(BufferStream stream, MixingTable instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.totalMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.remainingMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.currentRecipe = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.pendingItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MixingTable DeserializeLengthDelimited(BufferStream stream, MixingTable instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.totalMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.remainingMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.currentRecipe = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.pendingItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MixingTable DeserializeLength(BufferStream stream, int length, MixingTable instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.totalMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.remainingMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.currentRecipe = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.pendingItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MixingTable instance, MixingTable previous)
	{
		if (instance.totalMixTime != previous.totalMixTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.totalMixTime);
		}
		if (instance.remainingMixTime != previous.remainingMixTime)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.remainingMixTime);
		}
		if (instance.currentRecipe != previous.currentRecipe)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentRecipe);
		}
		if (instance.pendingItem != previous.pendingItem)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.pendingItem);
		}
	}

	public static void Serialize(BufferStream stream, MixingTable instance)
	{
		if (instance.totalMixTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.totalMixTime);
		}
		if (instance.remainingMixTime != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.remainingMixTime);
		}
		if (instance.currentRecipe != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentRecipe);
		}
		if (instance.pendingItem != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.pendingItem);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Elevator : IDisposable, IPooled, IProto<Elevator>, IProto
{
	[NonSerialized]
	public int floor;

	[NonSerialized]
	public NetworkableId spawnedLift;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Elevator instance)
	{
		if (instance.ShouldPool)
		{
			instance.floor = 0;
			instance.spawnedLift = default(NetworkableId);
			Pool.Free<Elevator>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Elevator with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Elevator instance)
	{
		instance.floor = floor;
		instance.spawnedLift = spawnedLift;
	}

	public Elevator Copy()
	{
		Elevator elevator = Pool.Get<Elevator>();
		CopyTo(elevator);
		return elevator;
	}

	public static Elevator Deserialize(BufferStream stream)
	{
		Elevator elevator = Pool.Get<Elevator>();
		Deserialize(stream, elevator, isDelta: false);
		return elevator;
	}

	public static Elevator DeserializeLengthDelimited(BufferStream stream)
	{
		Elevator elevator = Pool.Get<Elevator>();
		DeserializeLengthDelimited(stream, elevator, isDelta: false);
		return elevator;
	}

	public static Elevator DeserializeLength(BufferStream stream, int length)
	{
		Elevator elevator = Pool.Get<Elevator>();
		DeserializeLength(stream, length, elevator, isDelta: false);
		return elevator;
	}

	public static Elevator Deserialize(byte[] buffer)
	{
		Elevator elevator = Pool.Get<Elevator>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, elevator, isDelta: false);
		return elevator;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Elevator previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Elevator Deserialize(BufferStream stream, Elevator instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.spawnedLift = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Elevator DeserializeLengthDelimited(BufferStream stream, Elevator instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.spawnedLift = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Elevator DeserializeLength(BufferStream stream, int length, Elevator instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.spawnedLift = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Elevator instance, Elevator previous)
	{
		if (instance.floor != previous.floor)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.floor);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.spawnedLift.Value);
	}

	public static void Serialize(BufferStream stream, Elevator instance)
	{
		if (instance.floor != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.floor);
		}
		if (instance.spawnedLift != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.spawnedLift.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref spawnedLift.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SkullTrophy : IDisposable, IPooled, IProto<SkullTrophy>, IProto
{
	[NonSerialized]
	public string playerName;

	[NonSerialized]
	public string streamerName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SkullTrophy instance)
	{
		if (instance.ShouldPool)
		{
			instance.playerName = string.Empty;
			instance.streamerName = string.Empty;
			Pool.Free<SkullTrophy>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SkullTrophy with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SkullTrophy instance)
	{
		instance.playerName = playerName;
		instance.streamerName = streamerName;
	}

	public SkullTrophy Copy()
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		CopyTo(skullTrophy);
		return skullTrophy;
	}

	public static SkullTrophy Deserialize(BufferStream stream)
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		Deserialize(stream, skullTrophy, isDelta: false);
		return skullTrophy;
	}

	public static SkullTrophy DeserializeLengthDelimited(BufferStream stream)
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		DeserializeLengthDelimited(stream, skullTrophy, isDelta: false);
		return skullTrophy;
	}

	public static SkullTrophy DeserializeLength(BufferStream stream, int length)
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		DeserializeLength(stream, length, skullTrophy, isDelta: false);
		return skullTrophy;
	}

	public static SkullTrophy Deserialize(byte[] buffer)
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, skullTrophy, isDelta: false);
		return skullTrophy;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SkullTrophy previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SkullTrophy Deserialize(BufferStream stream, SkullTrophy instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.streamerName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SkullTrophy DeserializeLengthDelimited(BufferStream stream, SkullTrophy instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.streamerName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SkullTrophy DeserializeLength(BufferStream stream, int length, SkullTrophy instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.streamerName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SkullTrophy instance, SkullTrophy previous)
	{
		if (instance.playerName != null && instance.playerName != previous.playerName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.streamerName != null && instance.streamerName != previous.streamerName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
	}

	public static void Serialize(BufferStream stream, SkullTrophy instance)
	{
		if (instance.playerName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.streamerName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Cassette : IDisposable, IPooled, IProto<Cassette>, IProto
{
	[NonSerialized]
	public uint audioId;

	[NonSerialized]
	public NetworkableId holder;

	[NonSerialized]
	public ulong creatorSteamId;

	[NonSerialized]
	public int preloadAudioId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Cassette instance)
	{
		if (instance.ShouldPool)
		{
			instance.audioId = 0u;
			instance.holder = default(NetworkableId);
			instance.creatorSteamId = 0uL;
			instance.preloadAudioId = 0;
			Pool.Free<Cassette>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Cassette with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Cassette instance)
	{
		instance.audioId = audioId;
		instance.holder = holder;
		instance.creatorSteamId = creatorSteamId;
		instance.preloadAudioId = preloadAudioId;
	}

	public Cassette Copy()
	{
		Cassette cassette = Pool.Get<Cassette>();
		CopyTo(cassette);
		return cassette;
	}

	public static Cassette Deserialize(BufferStream stream)
	{
		Cassette cassette = Pool.Get<Cassette>();
		Deserialize(stream, cassette, isDelta: false);
		return cassette;
	}

	public static Cassette DeserializeLengthDelimited(BufferStream stream)
	{
		Cassette cassette = Pool.Get<Cassette>();
		DeserializeLengthDelimited(stream, cassette, isDelta: false);
		return cassette;
	}

	public static Cassette DeserializeLength(BufferStream stream, int length)
	{
		Cassette cassette = Pool.Get<Cassette>();
		DeserializeLength(stream, length, cassette, isDelta: false);
		return cassette;
	}

	public static Cassette Deserialize(byte[] buffer)
	{
		Cassette cassette = Pool.Get<Cassette>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cassette, isDelta: false);
		return cassette;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Cassette previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Cassette Deserialize(BufferStream stream, Cassette instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 24:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.holder = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.creatorSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.preloadAudioId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Cassette DeserializeLengthDelimited(BufferStream stream, Cassette instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.holder = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.creatorSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.preloadAudioId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Cassette DeserializeLength(BufferStream stream, int length, Cassette instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.holder = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.creatorSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.preloadAudioId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Cassette instance, Cassette previous)
	{
		if (instance.audioId != previous.audioId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.audioId);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.holder.Value);
		if (instance.creatorSteamId != previous.creatorSteamId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.creatorSteamId);
		}
		if (instance.preloadAudioId != previous.preloadAudioId)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.preloadAudioId);
		}
	}

	public static void Serialize(BufferStream stream, Cassette instance)
	{
		if (instance.audioId != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.audioId);
		}
		if (instance.holder != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.holder.Value);
		}
		if (instance.creatorSteamId != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.creatorSteamId);
		}
		if (instance.preloadAudioId != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.preloadAudioId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref holder.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Telephone : IDisposable, IPooled, IProto<Telephone>, IProto
{
	[NonSerialized]
	public int lastNumber;

	[NonSerialized]
	public int phoneNumber;

	[NonSerialized]
	public NetworkableId usingPlayer;

	[NonSerialized]
	public string phoneName;

	[NonSerialized]
	public PhoneDirectory savedNumbers;

	[NonSerialized]
	public List<VoicemailEntry> voicemail;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Telephone instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.lastNumber = 0;
		instance.phoneNumber = 0;
		instance.usingPlayer = default(NetworkableId);
		instance.phoneName = string.Empty;
		if (instance.savedNumbers != null)
		{
			instance.savedNumbers.ResetToPool();
			instance.savedNumbers = null;
		}
		if (instance.voicemail != null)
		{
			for (int i = 0; i < instance.voicemail.Count; i++)
			{
				if (instance.voicemail[i] != null)
				{
					instance.voicemail[i].ResetToPool();
					instance.voicemail[i] = null;
				}
			}
			List<VoicemailEntry> list = instance.voicemail;
			Pool.Free<VoicemailEntry>(ref list, false);
			instance.voicemail = list;
		}
		Pool.Free<Telephone>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Telephone with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Telephone instance)
	{
		instance.lastNumber = lastNumber;
		instance.phoneNumber = phoneNumber;
		instance.usingPlayer = usingPlayer;
		instance.phoneName = phoneName;
		if (savedNumbers != null)
		{
			if (instance.savedNumbers == null)
			{
				instance.savedNumbers = savedNumbers.Copy();
			}
			else
			{
				savedNumbers.CopyTo(instance.savedNumbers);
			}
		}
		else
		{
			instance.savedNumbers = null;
		}
		if (voicemail != null)
		{
			instance.voicemail = Pool.Get<List<VoicemailEntry>>();
			for (int i = 0; i < voicemail.Count; i++)
			{
				VoicemailEntry item = voicemail[i].Copy();
				instance.voicemail.Add(item);
			}
		}
		else
		{
			instance.voicemail = null;
		}
	}

	public Telephone Copy()
	{
		Telephone telephone = Pool.Get<Telephone>();
		CopyTo(telephone);
		return telephone;
	}

	public static Telephone Deserialize(BufferStream stream)
	{
		Telephone telephone = Pool.Get<Telephone>();
		Deserialize(stream, telephone, isDelta: false);
		return telephone;
	}

	public static Telephone DeserializeLengthDelimited(BufferStream stream)
	{
		Telephone telephone = Pool.Get<Telephone>();
		DeserializeLengthDelimited(stream, telephone, isDelta: false);
		return telephone;
	}

	public static Telephone DeserializeLength(BufferStream stream, int length)
	{
		Telephone telephone = Pool.Get<Telephone>();
		DeserializeLength(stream, length, telephone, isDelta: false);
		return telephone;
	}

	public static Telephone Deserialize(byte[] buffer)
	{
		Telephone telephone = Pool.Get<Telephone>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, telephone, isDelta: false);
		return telephone;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Telephone previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Telephone Deserialize(BufferStream stream, Telephone instance, bool isDelta)
	{
		if (!isDelta && instance.voicemail == null)
		{
			instance.voicemail = Pool.Get<List<VoicemailEntry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lastNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.usingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.phoneName = ProtocolParser.ReadString(stream);
				break;
			case 50:
				if (instance.savedNumbers == null)
				{
					instance.savedNumbers = PhoneDirectory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PhoneDirectory.DeserializeLengthDelimited(stream, instance.savedNumbers, isDelta);
				}
				break;
			case 58:
				instance.voicemail.Add(VoicemailEntry.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static Telephone DeserializeLengthDelimited(BufferStream stream, Telephone instance, bool isDelta)
	{
		if (!isDelta && instance.voicemail == null)
		{
			instance.voicemail = Pool.Get<List<VoicemailEntry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lastNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.usingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.phoneName = ProtocolParser.ReadString(stream);
				break;
			case 50:
				if (instance.savedNumbers == null)
				{
					instance.savedNumbers = PhoneDirectory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PhoneDirectory.DeserializeLengthDelimited(stream, instance.savedNumbers, isDelta);
				}
				break;
			case 58:
				instance.voicemail.Add(VoicemailEntry.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Telephone DeserializeLength(BufferStream stream, int length, Telephone instance, bool isDelta)
	{
		if (!isDelta && instance.voicemail == null)
		{
			instance.voicemail = Pool.Get<List<VoicemailEntry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lastNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.usingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.phoneName = ProtocolParser.ReadString(stream);
				break;
			case 50:
				if (instance.savedNumbers == null)
				{
					instance.savedNumbers = PhoneDirectory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PhoneDirectory.DeserializeLengthDelimited(stream, instance.savedNumbers, isDelta);
				}
				break;
			case 58:
				instance.voicemail.Add(VoicemailEntry.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Telephone instance, Telephone previous)
	{
		if (instance.lastNumber != previous.lastNumber)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastNumber);
		}
		if (instance.phoneNumber != previous.phoneNumber)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.usingPlayer.Value);
		if (instance.phoneName != null && instance.phoneName != previous.phoneName)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}
		if (instance.savedNumbers != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PhoneDirectory.SerializeDelta(stream, instance.savedNumbers, previous.savedNumbers);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.voicemail == null)
		{
			return;
		}
		for (int i = 0; i < instance.voicemail.Count; i++)
		{
			VoicemailEntry voicemailEntry = instance.voicemail[i];
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			VoicemailEntry.SerializeDelta(stream, voicemailEntry, voicemailEntry);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, Telephone instance)
	{
		if (instance.lastNumber != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastNumber);
		}
		if (instance.phoneNumber != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		if (instance.usingPlayer != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.usingPlayer.Value);
		}
		if (instance.phoneName != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}
		if (instance.savedNumbers != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PhoneDirectory.Serialize(stream, instance.savedNumbers);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.voicemail == null)
		{
			return;
		}
		for (int i = 0; i < instance.voicemail.Count; i++)
		{
			VoicemailEntry instance2 = instance.voicemail[i];
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			VoicemailEntry.Serialize(stream, instance2);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref usingPlayer.Value);
		savedNumbers?.InspectUids(action);
		if (voicemail != null)
		{
			for (int i = 0; i < voicemail.Count; i++)
			{
				voicemail[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BoomBox : IDisposable, IPooled, IProto<BoomBox>, IProto
{
	[NonSerialized]
	public string radioIp;

	[NonSerialized]
	public ulong assignedRadioBy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BoomBox instance)
	{
		if (instance.ShouldPool)
		{
			instance.radioIp = string.Empty;
			instance.assignedRadioBy = 0uL;
			Pool.Free<BoomBox>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BoomBox with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BoomBox instance)
	{
		instance.radioIp = radioIp;
		instance.assignedRadioBy = assignedRadioBy;
	}

	public BoomBox Copy()
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		CopyTo(boomBox);
		return boomBox;
	}

	public static BoomBox Deserialize(BufferStream stream)
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		Deserialize(stream, boomBox, isDelta: false);
		return boomBox;
	}

	public static BoomBox DeserializeLengthDelimited(BufferStream stream)
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		DeserializeLengthDelimited(stream, boomBox, isDelta: false);
		return boomBox;
	}

	public static BoomBox DeserializeLength(BufferStream stream, int length)
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		DeserializeLength(stream, length, boomBox, isDelta: false);
		return boomBox;
	}

	public static BoomBox Deserialize(byte[] buffer)
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, boomBox, isDelta: false);
		return boomBox;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BoomBox previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BoomBox Deserialize(BufferStream stream, BoomBox instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.radioIp = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.assignedRadioBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BoomBox DeserializeLengthDelimited(BufferStream stream, BoomBox instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.radioIp = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.assignedRadioBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BoomBox DeserializeLength(BufferStream stream, int length, BoomBox instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.radioIp = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.assignedRadioBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BoomBox instance, BoomBox previous)
	{
		if (instance.radioIp != null && instance.radioIp != previous.radioIp)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.radioIp);
		}
		if (instance.assignedRadioBy != previous.assignedRadioBy)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.assignedRadioBy);
		}
	}

	public static void Serialize(BufferStream stream, BoomBox instance)
	{
		if (instance.radioIp != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.radioIp);
		}
		if (instance.assignedRadioBy != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.assignedRadioBy);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class NeonSign : IDisposable, IPooled, IProto<NeonSign>, IProto
{
	public class Lights : IDisposable, IPooled, IProto<Lights>, IProto
	{
		[NonSerialized]
		public Color topLeft;

		[NonSerialized]
		public Color topRight;

		[NonSerialized]
		public Color bottomLeft;

		[NonSerialized]
		public Color bottomRight;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Lights instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.topLeft = default(Color);
				instance.topRight = default(Color);
				instance.bottomLeft = default(Color);
				instance.bottomRight = default(Color);
				Pool.Free<Lights>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Lights with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Lights instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			instance.topLeft = topLeft;
			instance.topRight = topRight;
			instance.bottomLeft = bottomLeft;
			instance.bottomRight = bottomRight;
		}

		public Lights Copy()
		{
			Lights lights = Pool.Get<Lights>();
			CopyTo(lights);
			return lights;
		}

		public static Lights Deserialize(BufferStream stream)
		{
			Lights lights = Pool.Get<Lights>();
			Deserialize(stream, lights, isDelta: false);
			return lights;
		}

		public static Lights DeserializeLengthDelimited(BufferStream stream)
		{
			Lights lights = Pool.Get<Lights>();
			DeserializeLengthDelimited(stream, lights, isDelta: false);
			return lights;
		}

		public static Lights DeserializeLength(BufferStream stream, int length)
		{
			Lights lights = Pool.Get<Lights>();
			DeserializeLength(stream, length, lights, isDelta: false);
			return lights;
		}

		public static Lights Deserialize(byte[] buffer)
		{
			Lights lights = Pool.Get<Lights>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, lights, isDelta: false);
			return lights;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Lights previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Lights Deserialize(BufferStream stream, Lights instance, bool isDelta)
		{
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
					continue;
				case 26:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
					continue;
				case 34:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Lights DeserializeLengthDelimited(BufferStream stream, Lights instance, bool isDelta)
		{
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
					continue;
				case 26:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
					continue;
				case 34:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Lights DeserializeLength(BufferStream stream, int length, Lights instance, bool isDelta)
		{
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
					continue;
				case 26:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
					continue;
				case 34:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Lights instance, Lights previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_013c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0169: Unknown result type (might be due to invalid IL or missing references)
			if (instance.topLeft != previous.topLeft)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.topLeft, previous.topLeft);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topLeft (UnityEngine.Color)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.topRight != previous.topRight)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.topRight, previous.topRight);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topRight (UnityEngine.Color)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.bottomLeft != previous.bottomLeft)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.bottomLeft, previous.bottomLeft);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomLeft (UnityEngine.Color)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
			if (instance.bottomRight != previous.bottomRight)
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.bottomRight, previous.bottomRight);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomRight (UnityEngine.Color)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
		}

		public static void Serialize(BufferStream stream, Lights instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_012e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_015e: Unknown result type (might be due to invalid IL or missing references)
			if (instance.topLeft != default(Color))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ColorSerialized.Serialize(stream, instance.topLeft);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topLeft (UnityEngine.Color)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.topRight != default(Color))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				ColorSerialized.Serialize(stream, instance.topRight);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topRight (UnityEngine.Color)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.bottomLeft != default(Color))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				ColorSerialized.Serialize(stream, instance.bottomLeft);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomLeft (UnityEngine.Color)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
			if (instance.bottomRight != default(Color))
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				ColorSerialized.Serialize(stream, instance.bottomRight);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomRight (UnityEngine.Color)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Lights> frameLighting;

	[NonSerialized]
	public int currentFrame;

	[NonSerialized]
	public float animationSpeed;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NeonSign instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.frameLighting != null)
		{
			for (int i = 0; i < instance.frameLighting.Count; i++)
			{
				if (instance.frameLighting[i] != null)
				{
					instance.frameLighting[i].ResetToPool();
					instance.frameLighting[i] = null;
				}
			}
			List<Lights> list = instance.frameLighting;
			Pool.Free<Lights>(ref list, false);
			instance.frameLighting = list;
		}
		instance.currentFrame = 0;
		instance.animationSpeed = 0f;
		Pool.Free<NeonSign>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NeonSign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NeonSign instance)
	{
		if (frameLighting != null)
		{
			instance.frameLighting = Pool.Get<List<Lights>>();
			for (int i = 0; i < frameLighting.Count; i++)
			{
				Lights item = frameLighting[i].Copy();
				instance.frameLighting.Add(item);
			}
		}
		else
		{
			instance.frameLighting = null;
		}
		instance.currentFrame = currentFrame;
		instance.animationSpeed = animationSpeed;
	}

	public NeonSign Copy()
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		CopyTo(neonSign);
		return neonSign;
	}

	public static NeonSign Deserialize(BufferStream stream)
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		Deserialize(stream, neonSign, isDelta: false);
		return neonSign;
	}

	public static NeonSign DeserializeLengthDelimited(BufferStream stream)
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		DeserializeLengthDelimited(stream, neonSign, isDelta: false);
		return neonSign;
	}

	public static NeonSign DeserializeLength(BufferStream stream, int length)
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		DeserializeLength(stream, length, neonSign, isDelta: false);
		return neonSign;
	}

	public static NeonSign Deserialize(byte[] buffer)
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, neonSign, isDelta: false);
		return neonSign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NeonSign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NeonSign Deserialize(BufferStream stream, NeonSign instance, bool isDelta)
	{
		if (!isDelta && instance.frameLighting == null)
		{
			instance.frameLighting = Pool.Get<List<Lights>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 42:
				instance.frameLighting.Add(Lights.DeserializeLengthDelimited(stream));
				continue;
			case 48:
				instance.currentFrame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.animationSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NeonSign DeserializeLengthDelimited(BufferStream stream, NeonSign instance, bool isDelta)
	{
		if (!isDelta && instance.frameLighting == null)
		{
			instance.frameLighting = Pool.Get<List<Lights>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 42:
				instance.frameLighting.Add(Lights.DeserializeLengthDelimited(stream));
				continue;
			case 48:
				instance.currentFrame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.animationSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NeonSign DeserializeLength(BufferStream stream, int length, NeonSign instance, bool isDelta)
	{
		if (!isDelta && instance.frameLighting == null)
		{
			instance.frameLighting = Pool.Get<List<Lights>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 42:
				instance.frameLighting.Add(Lights.DeserializeLengthDelimited(stream));
				continue;
			case 48:
				instance.currentFrame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.animationSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NeonSign instance, NeonSign previous)
	{
		if (instance.frameLighting != null)
		{
			for (int i = 0; i < instance.frameLighting.Count; i++)
			{
				Lights lights = instance.frameLighting[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Lights.SerializeDelta(stream, lights, lights);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field frameLighting (ProtoBuf.NeonSign.Lights)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.currentFrame != previous.currentFrame)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentFrame);
		}
		if (instance.animationSpeed != previous.animationSpeed)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.animationSpeed);
		}
	}

	public static void Serialize(BufferStream stream, NeonSign instance)
	{
		if (instance.frameLighting != null)
		{
			for (int i = 0; i < instance.frameLighting.Count; i++)
			{
				Lights instance2 = instance.frameLighting[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Lights.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field frameLighting (ProtoBuf.NeonSign.Lights)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.currentFrame != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentFrame);
		}
		if (instance.animationSpeed != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.animationSpeed);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (frameLighting != null)
		{
			for (int i = 0; i < frameLighting.Count; i++)
			{
				frameLighting[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TrainEngine : IDisposable, IPooled, IProto<TrainEngine>, IProto
{
	[NonSerialized]
	public int throttleSetting;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TrainEngine instance)
	{
		if (instance.ShouldPool)
		{
			instance.throttleSetting = 0;
			instance.fuelStorageID = default(NetworkableId);
			Pool.Free<TrainEngine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TrainEngine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TrainEngine instance)
	{
		instance.throttleSetting = throttleSetting;
		instance.fuelStorageID = fuelStorageID;
	}

	public TrainEngine Copy()
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		CopyTo(trainEngine);
		return trainEngine;
	}

	public static TrainEngine Deserialize(BufferStream stream)
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		Deserialize(stream, trainEngine, isDelta: false);
		return trainEngine;
	}

	public static TrainEngine DeserializeLengthDelimited(BufferStream stream)
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		DeserializeLengthDelimited(stream, trainEngine, isDelta: false);
		return trainEngine;
	}

	public static TrainEngine DeserializeLength(BufferStream stream, int length)
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		DeserializeLength(stream, length, trainEngine, isDelta: false);
		return trainEngine;
	}

	public static TrainEngine Deserialize(byte[] buffer)
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, trainEngine, isDelta: false);
		return trainEngine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TrainEngine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TrainEngine Deserialize(BufferStream stream, TrainEngine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.throttleSetting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TrainEngine DeserializeLengthDelimited(BufferStream stream, TrainEngine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.throttleSetting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TrainEngine DeserializeLength(BufferStream stream, int length, TrainEngine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.throttleSetting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TrainEngine instance, TrainEngine previous)
	{
		if (instance.throttleSetting != previous.throttleSetting)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.throttleSetting);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
	}

	public static void Serialize(BufferStream stream, TrainEngine instance)
	{
		if (instance.throttleSetting != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.throttleSetting);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SubEntityList : IDisposable, IPooled, IProto<SubEntityList>, IProto
{
	[NonSerialized]
	public List<NetworkableId> subEntityIds;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SubEntityList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.subEntityIds != null)
			{
				List<NetworkableId> list = instance.subEntityIds;
				Pool.FreeUnmanaged<NetworkableId>(ref list);
				instance.subEntityIds = list;
			}
			Pool.Free<SubEntityList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SubEntityList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SubEntityList instance)
	{
		if (subEntityIds != null)
		{
			instance.subEntityIds = Pool.Get<List<NetworkableId>>();
			for (int i = 0; i < subEntityIds.Count; i++)
			{
				NetworkableId item = subEntityIds[i];
				instance.subEntityIds.Add(item);
			}
		}
		else
		{
			instance.subEntityIds = null;
		}
	}

	public SubEntityList Copy()
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		CopyTo(subEntityList);
		return subEntityList;
	}

	public static SubEntityList Deserialize(BufferStream stream)
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		Deserialize(stream, subEntityList, isDelta: false);
		return subEntityList;
	}

	public static SubEntityList DeserializeLengthDelimited(BufferStream stream)
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		DeserializeLengthDelimited(stream, subEntityList, isDelta: false);
		return subEntityList;
	}

	public static SubEntityList DeserializeLength(BufferStream stream, int length)
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		DeserializeLength(stream, length, subEntityList, isDelta: false);
		return subEntityList;
	}

	public static SubEntityList Deserialize(byte[] buffer)
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, subEntityList, isDelta: false);
		return subEntityList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SubEntityList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SubEntityList Deserialize(BufferStream stream, SubEntityList instance, bool isDelta)
	{
		if (!isDelta && instance.subEntityIds == null)
		{
			instance.subEntityIds = Pool.Get<List<NetworkableId>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.subEntityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SubEntityList DeserializeLengthDelimited(BufferStream stream, SubEntityList instance, bool isDelta)
	{
		if (!isDelta && instance.subEntityIds == null)
		{
			instance.subEntityIds = Pool.Get<List<NetworkableId>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.subEntityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SubEntityList DeserializeLength(BufferStream stream, int length, SubEntityList instance, bool isDelta)
	{
		if (!isDelta && instance.subEntityIds == null)
		{
			instance.subEntityIds = Pool.Get<List<NetworkableId>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.subEntityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SubEntityList instance, SubEntityList previous)
	{
		if (instance.subEntityIds != null)
		{
			for (int i = 0; i < instance.subEntityIds.Count; i++)
			{
				NetworkableId networkableId = instance.subEntityIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public static void Serialize(BufferStream stream, SubEntityList instance)
	{
		if (instance.subEntityIds != null)
		{
			for (int i = 0; i < instance.subEntityIds.Count; i++)
			{
				NetworkableId networkableId = instance.subEntityIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < subEntityIds.Count; i++)
		{
			NetworkableId value = subEntityIds[i];
			action(UidType.NetworkableId, ref value.Value);
			subEntityIds[i] = value;
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MarketTerminal : IDisposable, IPooled, IProto<MarketTerminal>, IProto
{
	public class PendingOrder : IDisposable, IPooled, IProto<PendingOrder>, IProto
	{
		[NonSerialized]
		public NetworkableId vendingMachineId;

		[NonSerialized]
		public NetworkableId droneId;

		[NonSerialized]
		public TimeUntil timeUntilExpiry;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PendingOrder instance)
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.vendingMachineId = default(NetworkableId);
				instance.droneId = default(NetworkableId);
				instance.timeUntilExpiry = TimeUntil.op_Implicit(0f);
				Pool.Free<PendingOrder>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PendingOrder with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PendingOrder instance)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			instance.vendingMachineId = vendingMachineId;
			instance.droneId = droneId;
			instance.timeUntilExpiry = timeUntilExpiry;
		}

		public PendingOrder Copy()
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			CopyTo(pendingOrder);
			return pendingOrder;
		}

		public static PendingOrder Deserialize(BufferStream stream)
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			Deserialize(stream, pendingOrder, isDelta: false);
			return pendingOrder;
		}

		public static PendingOrder DeserializeLengthDelimited(BufferStream stream)
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			DeserializeLengthDelimited(stream, pendingOrder, isDelta: false);
			return pendingOrder;
		}

		public static PendingOrder DeserializeLength(BufferStream stream, int length)
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			DeserializeLength(stream, length, pendingOrder, isDelta: false);
			return pendingOrder;
		}

		public static PendingOrder Deserialize(byte[] buffer)
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, pendingOrder, isDelta: false);
			return pendingOrder;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PendingOrder previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PendingOrder Deserialize(BufferStream stream, PendingOrder instance, bool isDelta)
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 37:
					instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PendingOrder DeserializeLengthDelimited(BufferStream stream, PendingOrder instance, bool isDelta)
		{
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 37:
					instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PendingOrder DeserializeLength(BufferStream stream, int length, PendingOrder instance, bool isDelta)
		{
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 37:
					instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PendingOrder instance, PendingOrder previous)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.droneId.Value);
			if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != TimeUntil.op_Implicit(previous.timeUntilExpiry))
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
			}
		}

		public static void Serialize(BufferStream stream, PendingOrder instance)
		{
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			if (instance.vendingMachineId != default(NetworkableId))
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
			}
			if (instance.droneId != default(NetworkableId))
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.droneId.Value);
			}
			if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref vendingMachineId.Value);
			action(UidType.NetworkableId, ref droneId.Value);
		}
	}

	[NonSerialized]
	public ulong customerSteamId;

	[NonSerialized]
	public NetworkableId marketplaceId;

	[NonSerialized]
	public List<PendingOrder> orders;

	[NonSerialized]
	public string customerName;

	[NonSerialized]
	public TimeUntil timeUntilExpiry;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MarketTerminal instance)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.customerSteamId = 0uL;
		instance.marketplaceId = default(NetworkableId);
		if (instance.orders != null)
		{
			for (int i = 0; i < instance.orders.Count; i++)
			{
				if (instance.orders[i] != null)
				{
					instance.orders[i].ResetToPool();
					instance.orders[i] = null;
				}
			}
			List<PendingOrder> list = instance.orders;
			Pool.Free<PendingOrder>(ref list, false);
			instance.orders = list;
		}
		instance.customerName = string.Empty;
		instance.timeUntilExpiry = TimeUntil.op_Implicit(0f);
		Pool.Free<MarketTerminal>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MarketTerminal with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MarketTerminal instance)
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		instance.customerSteamId = customerSteamId;
		instance.marketplaceId = marketplaceId;
		if (orders != null)
		{
			instance.orders = Pool.Get<List<PendingOrder>>();
			for (int i = 0; i < orders.Count; i++)
			{
				PendingOrder item = orders[i].Copy();
				instance.orders.Add(item);
			}
		}
		else
		{
			instance.orders = null;
		}
		instance.customerName = customerName;
		instance.timeUntilExpiry = timeUntilExpiry;
	}

	public MarketTerminal Copy()
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		CopyTo(marketTerminal);
		return marketTerminal;
	}

	public static MarketTerminal Deserialize(BufferStream stream)
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		Deserialize(stream, marketTerminal, isDelta: false);
		return marketTerminal;
	}

	public static MarketTerminal DeserializeLengthDelimited(BufferStream stream)
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		DeserializeLengthDelimited(stream, marketTerminal, isDelta: false);
		return marketTerminal;
	}

	public static MarketTerminal DeserializeLength(BufferStream stream, int length)
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		DeserializeLength(stream, length, marketTerminal, isDelta: false);
		return marketTerminal;
	}

	public static MarketTerminal Deserialize(byte[] buffer)
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, marketTerminal, isDelta: false);
		return marketTerminal;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MarketTerminal previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MarketTerminal Deserialize(BufferStream stream, MarketTerminal instance, bool isDelta)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.orders == null)
		{
			instance.orders = Pool.Get<List<PendingOrder>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.customerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.orders.Add(PendingOrder.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.customerName = ProtocolParser.ReadString(stream);
				continue;
			case 53:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MarketTerminal DeserializeLengthDelimited(BufferStream stream, MarketTerminal instance, bool isDelta)
	{
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.orders == null)
		{
			instance.orders = Pool.Get<List<PendingOrder>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.customerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.orders.Add(PendingOrder.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.customerName = ProtocolParser.ReadString(stream);
				continue;
			case 53:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MarketTerminal DeserializeLength(BufferStream stream, int length, MarketTerminal instance, bool isDelta)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.orders == null)
		{
			instance.orders = Pool.Get<List<PendingOrder>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.customerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.orders.Add(PendingOrder.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.customerName = ProtocolParser.ReadString(stream);
				continue;
			case 53:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MarketTerminal instance, MarketTerminal previous)
	{
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		if (instance.customerSteamId != previous.customerSteamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.customerSteamId);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.marketplaceId.Value);
		if (instance.orders != null)
		{
			for (int i = 0; i < instance.orders.Count; i++)
			{
				PendingOrder pendingOrder = instance.orders[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				PendingOrder.SerializeDelta(stream, pendingOrder, pendingOrder);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field orders (ProtoBuf.MarketTerminal.PendingOrder)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.customerName != null && instance.customerName != previous.customerName)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.customerName);
		}
		if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != TimeUntil.op_Implicit(previous.timeUntilExpiry))
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
		}
	}

	public static void Serialize(BufferStream stream, MarketTerminal instance)
	{
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		if (instance.customerSteamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.customerSteamId);
		}
		if (instance.marketplaceId != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.marketplaceId.Value);
		}
		if (instance.orders != null)
		{
			for (int i = 0; i < instance.orders.Count; i++)
			{
				PendingOrder instance2 = instance.orders[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				PendingOrder.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field orders (ProtoBuf.MarketTerminal.PendingOrder)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.customerName != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.customerName);
		}
		if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref marketplaceId.Value);
		if (orders != null)
		{
			for (int i = 0; i < orders.Count; i++)
			{
				orders[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DeliveryDrone : IDisposable, IPooled, IProto<DeliveryDrone>, IProto
{
	[NonSerialized]
	public NetworkableId marketplaceId;

	[NonSerialized]
	public NetworkableId terminalId;

	[NonSerialized]
	public NetworkableId vendingMachineId;

	[NonSerialized]
	public int state;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DeliveryDrone instance)
	{
		if (instance.ShouldPool)
		{
			instance.marketplaceId = default(NetworkableId);
			instance.terminalId = default(NetworkableId);
			instance.vendingMachineId = default(NetworkableId);
			instance.state = 0;
			Pool.Free<DeliveryDrone>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DeliveryDrone with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DeliveryDrone instance)
	{
		instance.marketplaceId = marketplaceId;
		instance.terminalId = terminalId;
		instance.vendingMachineId = vendingMachineId;
		instance.state = state;
	}

	public DeliveryDrone Copy()
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		CopyTo(deliveryDrone);
		return deliveryDrone;
	}

	public static DeliveryDrone Deserialize(BufferStream stream)
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		Deserialize(stream, deliveryDrone, isDelta: false);
		return deliveryDrone;
	}

	public static DeliveryDrone DeserializeLengthDelimited(BufferStream stream)
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		DeserializeLengthDelimited(stream, deliveryDrone, isDelta: false);
		return deliveryDrone;
	}

	public static DeliveryDrone DeserializeLength(BufferStream stream, int length)
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		DeserializeLength(stream, length, deliveryDrone, isDelta: false);
		return deliveryDrone;
	}

	public static DeliveryDrone Deserialize(byte[] buffer)
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, deliveryDrone, isDelta: false);
		return deliveryDrone;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DeliveryDrone previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DeliveryDrone Deserialize(BufferStream stream, DeliveryDrone instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.terminalId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DeliveryDrone DeserializeLengthDelimited(BufferStream stream, DeliveryDrone instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.terminalId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DeliveryDrone DeserializeLength(BufferStream stream, int length, DeliveryDrone instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.terminalId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DeliveryDrone instance, DeliveryDrone previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.marketplaceId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.terminalId.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
		if (instance.state != previous.state)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
	}

	public static void Serialize(BufferStream stream, DeliveryDrone instance)
	{
		if (instance.marketplaceId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.marketplaceId.Value);
		}
		if (instance.terminalId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.terminalId.Value);
		}
		if (instance.vendingMachineId != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref marketplaceId.Value);
		action(UidType.NetworkableId, ref terminalId.Value);
		action(UidType.NetworkableId, ref vendingMachineId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class GameMode : IDisposable, IPooled, IProto<GameMode>, IProto
{
	public class TeamInfo : IDisposable, IPooled, IProto<TeamInfo>, IProto
	{
		[NonSerialized]
		public int score;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(TeamInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.score = 0;
				Pool.Free<TeamInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose TeamInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(TeamInfo instance)
		{
			instance.score = score;
		}

		public TeamInfo Copy()
		{
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			CopyTo(teamInfo);
			return teamInfo;
		}

		public static TeamInfo Deserialize(BufferStream stream)
		{
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			Deserialize(stream, teamInfo, isDelta: false);
			return teamInfo;
		}

		public static TeamInfo DeserializeLengthDelimited(BufferStream stream)
		{
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			DeserializeLengthDelimited(stream, teamInfo, isDelta: false);
			return teamInfo;
		}

		public static TeamInfo DeserializeLength(BufferStream stream, int length)
		{
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			DeserializeLength(stream, length, teamInfo, isDelta: false);
			return teamInfo;
		}

		public static TeamInfo Deserialize(byte[] buffer)
		{
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, teamInfo, isDelta: false);
			return teamInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, TeamInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static TeamInfo Deserialize(BufferStream stream, TeamInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static TeamInfo DeserializeLengthDelimited(BufferStream stream, TeamInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static TeamInfo DeserializeLength(BufferStream stream, int length, TeamInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, TeamInfo instance, TeamInfo previous)
		{
			if (instance.score != previous.score)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public static void Serialize(BufferStream stream, TeamInfo instance)
		{
			if (instance.score != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class ScoreColumn : IDisposable, IPooled, IProto<ScoreColumn>, IProto
	{
		[NonSerialized]
		public string name;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ScoreColumn instance)
		{
			if (instance.ShouldPool)
			{
				instance.name = string.Empty;
				Pool.Free<ScoreColumn>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ScoreColumn with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ScoreColumn instance)
		{
			instance.name = name;
		}

		public ScoreColumn Copy()
		{
			ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
			CopyTo(scoreColumn);
			return scoreColumn;
		}

		public static ScoreColumn Deserialize(BufferStream stream)
		{
			ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
			Deserialize(stream, scoreColumn, isDelta: false);
			return scoreColumn;
		}

		public static ScoreColumn DeserializeLengthDelimited(BufferStream stream)
		{
			ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
			DeserializeLengthDelimited(stream, scoreColumn, isDelta: false);
			return scoreColumn;
		}

		public static ScoreColumn DeserializeLength(BufferStream stream, int length)
		{
			ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
			DeserializeLength(stream, length, scoreColumn, isDelta: false);
			return scoreColumn;
		}

		public static ScoreColumn Deserialize(byte[] buffer)
		{
			ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, scoreColumn, isDelta: false);
			return scoreColumn;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ScoreColumn previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ScoreColumn Deserialize(BufferStream stream, ScoreColumn instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ScoreColumn DeserializeLengthDelimited(BufferStream stream, ScoreColumn instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ScoreColumn DeserializeLength(BufferStream stream, int length, ScoreColumn instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ScoreColumn instance, ScoreColumn previous)
		{
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.name);
			}
		}

		public static void Serialize(BufferStream stream, ScoreColumn instance)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class PlayerScore : IDisposable, IPooled, IProto<PlayerScore>, IProto
	{
		[NonSerialized]
		public string playerName;

		[NonSerialized]
		public ulong userid;

		[NonSerialized]
		public List<int> scores;

		[NonSerialized]
		public int team;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerScore instance)
		{
			if (instance.ShouldPool)
			{
				instance.playerName = string.Empty;
				instance.userid = 0uL;
				if (instance.scores != null)
				{
					List<int> list = instance.scores;
					Pool.FreeUnmanaged<int>(ref list);
					instance.scores = list;
				}
				instance.team = 0;
				Pool.Free<PlayerScore>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerScore with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerScore instance)
		{
			instance.playerName = playerName;
			instance.userid = userid;
			if (scores != null)
			{
				instance.scores = Pool.Get<List<int>>();
				for (int i = 0; i < scores.Count; i++)
				{
					int item = scores[i];
					instance.scores.Add(item);
				}
			}
			else
			{
				instance.scores = null;
			}
			instance.team = team;
		}

		public PlayerScore Copy()
		{
			PlayerScore playerScore = Pool.Get<PlayerScore>();
			CopyTo(playerScore);
			return playerScore;
		}

		public static PlayerScore Deserialize(BufferStream stream)
		{
			PlayerScore playerScore = Pool.Get<PlayerScore>();
			Deserialize(stream, playerScore, isDelta: false);
			return playerScore;
		}

		public static PlayerScore DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerScore playerScore = Pool.Get<PlayerScore>();
			DeserializeLengthDelimited(stream, playerScore, isDelta: false);
			return playerScore;
		}

		public static PlayerScore DeserializeLength(BufferStream stream, int length)
		{
			PlayerScore playerScore = Pool.Get<PlayerScore>();
			DeserializeLength(stream, length, playerScore, isDelta: false);
			return playerScore;
		}

		public static PlayerScore Deserialize(byte[] buffer)
		{
			PlayerScore playerScore = Pool.Get<PlayerScore>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerScore, isDelta: false);
			return playerScore;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerScore previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerScore Deserialize(BufferStream stream, PlayerScore instance, bool isDelta)
		{
			if (!isDelta && instance.scores == null)
			{
				instance.scores = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.playerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.scores.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 32:
					instance.team = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerScore DeserializeLengthDelimited(BufferStream stream, PlayerScore instance, bool isDelta)
		{
			if (!isDelta && instance.scores == null)
			{
				instance.scores = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.playerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.scores.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 32:
					instance.team = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerScore DeserializeLength(BufferStream stream, int length, PlayerScore instance, bool isDelta)
		{
			if (!isDelta && instance.scores == null)
			{
				instance.scores = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.playerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.scores.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 32:
					instance.team = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerScore instance, PlayerScore previous)
		{
			if (instance.playerName != previous.playerName)
			{
				if (instance.playerName == null)
				{
					throw new ArgumentNullException("playerName", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.playerName);
			}
			if (instance.userid != previous.userid)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.scores != null)
			{
				for (int i = 0; i < instance.scores.Count; i++)
				{
					int num = instance.scores[i];
					stream.WriteByte(24);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.team != previous.team)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.team);
			}
		}

		public static void Serialize(BufferStream stream, PlayerScore instance)
		{
			if (instance.playerName == null)
			{
				throw new ArgumentNullException("playerName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.playerName);
			if (instance.userid != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.scores != null)
			{
				for (int i = 0; i < instance.scores.Count; i++)
				{
					int num = instance.scores[i];
					stream.WriteByte(24);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.team != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.team);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<TeamInfo> teams;

	[NonSerialized]
	public List<ScoreColumn> scoreColumns;

	[NonSerialized]
	public List<PlayerScore> playerScores;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(GameMode instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.teams != null)
		{
			for (int i = 0; i < instance.teams.Count; i++)
			{
				if (instance.teams[i] != null)
				{
					instance.teams[i].ResetToPool();
					instance.teams[i] = null;
				}
			}
			List<TeamInfo> list = instance.teams;
			Pool.Free<TeamInfo>(ref list, false);
			instance.teams = list;
		}
		if (instance.scoreColumns != null)
		{
			for (int j = 0; j < instance.scoreColumns.Count; j++)
			{
				if (instance.scoreColumns[j] != null)
				{
					instance.scoreColumns[j].ResetToPool();
					instance.scoreColumns[j] = null;
				}
			}
			List<ScoreColumn> list2 = instance.scoreColumns;
			Pool.Free<ScoreColumn>(ref list2, false);
			instance.scoreColumns = list2;
		}
		if (instance.playerScores != null)
		{
			for (int k = 0; k < instance.playerScores.Count; k++)
			{
				if (instance.playerScores[k] != null)
				{
					instance.playerScores[k].ResetToPool();
					instance.playerScores[k] = null;
				}
			}
			List<PlayerScore> list3 = instance.playerScores;
			Pool.Free<PlayerScore>(ref list3, false);
			instance.playerScores = list3;
		}
		Pool.Free<GameMode>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose GameMode with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(GameMode instance)
	{
		if (teams != null)
		{
			instance.teams = Pool.Get<List<TeamInfo>>();
			for (int i = 0; i < teams.Count; i++)
			{
				TeamInfo item = teams[i].Copy();
				instance.teams.Add(item);
			}
		}
		else
		{
			instance.teams = null;
		}
		if (scoreColumns != null)
		{
			instance.scoreColumns = Pool.Get<List<ScoreColumn>>();
			for (int j = 0; j < scoreColumns.Count; j++)
			{
				ScoreColumn item2 = scoreColumns[j].Copy();
				instance.scoreColumns.Add(item2);
			}
		}
		else
		{
			instance.scoreColumns = null;
		}
		if (playerScores != null)
		{
			instance.playerScores = Pool.Get<List<PlayerScore>>();
			for (int k = 0; k < playerScores.Count; k++)
			{
				PlayerScore item3 = playerScores[k].Copy();
				instance.playerScores.Add(item3);
			}
		}
		else
		{
			instance.playerScores = null;
		}
	}

	public GameMode Copy()
	{
		GameMode gameMode = Pool.Get<GameMode>();
		CopyTo(gameMode);
		return gameMode;
	}

	public static GameMode Deserialize(BufferStream stream)
	{
		GameMode gameMode = Pool.Get<GameMode>();
		Deserialize(stream, gameMode, isDelta: false);
		return gameMode;
	}

	public static GameMode DeserializeLengthDelimited(BufferStream stream)
	{
		GameMode gameMode = Pool.Get<GameMode>();
		DeserializeLengthDelimited(stream, gameMode, isDelta: false);
		return gameMode;
	}

	public static GameMode DeserializeLength(BufferStream stream, int length)
	{
		GameMode gameMode = Pool.Get<GameMode>();
		DeserializeLength(stream, length, gameMode, isDelta: false);
		return gameMode;
	}

	public static GameMode Deserialize(byte[] buffer)
	{
		GameMode gameMode = Pool.Get<GameMode>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, gameMode, isDelta: false);
		return gameMode;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, GameMode previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static GameMode Deserialize(BufferStream stream, GameMode instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teams == null)
			{
				instance.teams = Pool.Get<List<TeamInfo>>();
			}
			if (instance.scoreColumns == null)
			{
				instance.scoreColumns = Pool.Get<List<ScoreColumn>>();
			}
			if (instance.playerScores == null)
			{
				instance.playerScores = Pool.Get<List<PlayerScore>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.teams.Add(TeamInfo.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.scoreColumns.Add(ScoreColumn.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.playerScores.Add(PlayerScore.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static GameMode DeserializeLengthDelimited(BufferStream stream, GameMode instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teams == null)
			{
				instance.teams = Pool.Get<List<TeamInfo>>();
			}
			if (instance.scoreColumns == null)
			{
				instance.scoreColumns = Pool.Get<List<ScoreColumn>>();
			}
			if (instance.playerScores == null)
			{
				instance.playerScores = Pool.Get<List<PlayerScore>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.teams.Add(TeamInfo.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.scoreColumns.Add(ScoreColumn.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.playerScores.Add(PlayerScore.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static GameMode DeserializeLength(BufferStream stream, int length, GameMode instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teams == null)
			{
				instance.teams = Pool.Get<List<TeamInfo>>();
			}
			if (instance.scoreColumns == null)
			{
				instance.scoreColumns = Pool.Get<List<ScoreColumn>>();
			}
			if (instance.playerScores == null)
			{
				instance.playerScores = Pool.Get<List<PlayerScore>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.teams.Add(TeamInfo.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.scoreColumns.Add(ScoreColumn.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.playerScores.Add(PlayerScore.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, GameMode instance, GameMode previous)
	{
		if (instance.teams != null)
		{
			for (int i = 0; i < instance.teams.Count; i++)
			{
				TeamInfo teamInfo = instance.teams[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				TeamInfo.SerializeDelta(stream, teamInfo, teamInfo);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field teams (ProtoBuf.GameMode.TeamInfo)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.scoreColumns != null)
		{
			for (int j = 0; j < instance.scoreColumns.Count; j++)
			{
				ScoreColumn scoreColumn = instance.scoreColumns[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				ScoreColumn.SerializeDelta(stream, scoreColumn, scoreColumn);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.playerScores == null)
		{
			return;
		}
		for (int k = 0; k < instance.playerScores.Count; k++)
		{
			PlayerScore playerScore = instance.playerScores[k];
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			PlayerScore.SerializeDelta(stream, playerScore, playerScore);
			int val2 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val2, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, GameMode instance)
	{
		if (instance.teams != null)
		{
			for (int i = 0; i < instance.teams.Count; i++)
			{
				TeamInfo instance2 = instance.teams[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				TeamInfo.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field teams (ProtoBuf.GameMode.TeamInfo)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.scoreColumns != null)
		{
			for (int j = 0; j < instance.scoreColumns.Count; j++)
			{
				ScoreColumn instance3 = instance.scoreColumns[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				ScoreColumn.Serialize(stream, instance3);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.playerScores == null)
		{
			return;
		}
		for (int k = 0; k < instance.playerScores.Count; k++)
		{
			PlayerScore instance4 = instance.playerScores[k];
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			PlayerScore.Serialize(stream, instance4);
			int val2 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val2, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (teams != null)
		{
			for (int i = 0; i < teams.Count; i++)
			{
				teams[i]?.InspectUids(action);
			}
		}
		if (scoreColumns != null)
		{
			for (int j = 0; j < scoreColumns.Count; j++)
			{
				scoreColumns[j]?.InspectUids(action);
			}
		}
		if (playerScores != null)
		{
			for (int k = 0; k < playerScores.Count; k++)
			{
				playerScores[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ReclaimManager : IDisposable, IPooled, IProto<ReclaimManager>, IProto
{
	public class ReclaimInfo : IDisposable, IPooled, IProto<ReclaimInfo>, IProto
	{
		[NonSerialized]
		public ulong victimID;

		[NonSerialized]
		public ItemContainer mainInventory;

		[NonSerialized]
		public ItemContainer wearInventory;

		[NonSerialized]
		public ItemContainer beltInventory;

		[NonSerialized]
		public ItemContainer backpackInventory;

		[NonSerialized]
		public int reclaimId;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ReclaimInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.victimID = 0uL;
				if (instance.mainInventory != null)
				{
					instance.mainInventory.ResetToPool();
					instance.mainInventory = null;
				}
				if (instance.wearInventory != null)
				{
					instance.wearInventory.ResetToPool();
					instance.wearInventory = null;
				}
				if (instance.beltInventory != null)
				{
					instance.beltInventory.ResetToPool();
					instance.beltInventory = null;
				}
				if (instance.backpackInventory != null)
				{
					instance.backpackInventory.ResetToPool();
					instance.backpackInventory = null;
				}
				instance.reclaimId = 0;
				Pool.Free<ReclaimInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ReclaimInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ReclaimInfo instance)
		{
			instance.victimID = victimID;
			if (mainInventory != null)
			{
				if (instance.mainInventory == null)
				{
					instance.mainInventory = mainInventory.Copy();
				}
				else
				{
					mainInventory.CopyTo(instance.mainInventory);
				}
			}
			else
			{
				instance.mainInventory = null;
			}
			if (wearInventory != null)
			{
				if (instance.wearInventory == null)
				{
					instance.wearInventory = wearInventory.Copy();
				}
				else
				{
					wearInventory.CopyTo(instance.wearInventory);
				}
			}
			else
			{
				instance.wearInventory = null;
			}
			if (beltInventory != null)
			{
				if (instance.beltInventory == null)
				{
					instance.beltInventory = beltInventory.Copy();
				}
				else
				{
					beltInventory.CopyTo(instance.beltInventory);
				}
			}
			else
			{
				instance.beltInventory = null;
			}
			if (backpackInventory != null)
			{
				if (instance.backpackInventory == null)
				{
					instance.backpackInventory = backpackInventory.Copy();
				}
				else
				{
					backpackInventory.CopyTo(instance.backpackInventory);
				}
			}
			else
			{
				instance.backpackInventory = null;
			}
			instance.reclaimId = reclaimId;
		}

		public ReclaimInfo Copy()
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			CopyTo(reclaimInfo);
			return reclaimInfo;
		}

		public static ReclaimInfo Deserialize(BufferStream stream)
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			Deserialize(stream, reclaimInfo, isDelta: false);
			return reclaimInfo;
		}

		public static ReclaimInfo DeserializeLengthDelimited(BufferStream stream)
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			DeserializeLengthDelimited(stream, reclaimInfo, isDelta: false);
			return reclaimInfo;
		}

		public static ReclaimInfo DeserializeLength(BufferStream stream, int length)
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			DeserializeLength(stream, length, reclaimInfo, isDelta: false);
			return reclaimInfo;
		}

		public static ReclaimInfo Deserialize(byte[] buffer)
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, reclaimInfo, isDelta: false);
			return reclaimInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ReclaimInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ReclaimInfo Deserialize(BufferStream stream, ReclaimInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.victimID = ProtocolParser.ReadUInt64(stream);
					break;
				case 34:
					if (instance.mainInventory == null)
					{
						instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
					}
					break;
				case 42:
					if (instance.wearInventory == null)
					{
						instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
					}
					break;
				case 50:
					if (instance.beltInventory == null)
					{
						instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
					}
					break;
				case 58:
					if (instance.backpackInventory == null)
					{
						instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
					}
					break;
				case 64:
					instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
					return instance;
				}
			}
		}

		public static ReclaimInfo DeserializeLengthDelimited(BufferStream stream, ReclaimInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.victimID = ProtocolParser.ReadUInt64(stream);
					break;
				case 34:
					if (instance.mainInventory == null)
					{
						instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
					}
					break;
				case 42:
					if (instance.wearInventory == null)
					{
						instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
					}
					break;
				case 50:
					if (instance.beltInventory == null)
					{
						instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
					}
					break;
				case 58:
					if (instance.backpackInventory == null)
					{
						instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
					}
					break;
				case 64:
					instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ReclaimInfo DeserializeLength(BufferStream stream, int length, ReclaimInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.victimID = ProtocolParser.ReadUInt64(stream);
					break;
				case 34:
					if (instance.mainInventory == null)
					{
						instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
					}
					break;
				case 42:
					if (instance.wearInventory == null)
					{
						instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
					}
					break;
				case 50:
					if (instance.beltInventory == null)
					{
						instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
					}
					break;
				case 58:
					if (instance.backpackInventory == null)
					{
						instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
					}
					break;
				case 64:
					instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ReclaimInfo instance, ReclaimInfo previous)
		{
			if (instance.victimID != previous.victimID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.victimID);
			}
			if (instance.mainInventory == null)
			{
				throw new ArgumentNullException("mainInventory", "Required by proto specification.");
			}
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.mainInventory, previous.mainInventory);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
			if (instance.wearInventory == null)
			{
				throw new ArgumentNullException("wearInventory", "Required by proto specification.");
			}
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.wearInventory, previous.wearInventory);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
			if (instance.beltInventory == null)
			{
				throw new ArgumentNullException("beltInventory", "Required by proto specification.");
			}
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.beltInventory, previous.beltInventory);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
			if (instance.backpackInventory == null)
			{
				throw new ArgumentNullException("backpackInventory", "Required by proto specification.");
			}
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.backpackInventory, previous.backpackInventory);
			int val4 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
			if (instance.reclaimId != previous.reclaimId)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.reclaimId);
			}
		}

		public static void Serialize(BufferStream stream, ReclaimInfo instance)
		{
			if (instance.victimID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.victimID);
			}
			if (instance.mainInventory == null)
			{
				throw new ArgumentNullException("mainInventory", "Required by proto specification.");
			}
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance.mainInventory);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
			if (instance.wearInventory == null)
			{
				throw new ArgumentNullException("wearInventory", "Required by proto specification.");
			}
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.Serialize(stream, instance.wearInventory);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
			if (instance.beltInventory == null)
			{
				throw new ArgumentNullException("beltInventory", "Required by proto specification.");
			}
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			ItemContainer.Serialize(stream, instance.beltInventory);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
			if (instance.backpackInventory == null)
			{
				throw new ArgumentNullException("backpackInventory", "Required by proto specification.");
			}
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			ItemContainer.Serialize(stream, instance.backpackInventory);
			int val4 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
			if (instance.reclaimId != 0)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.reclaimId);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			mainInventory?.InspectUids(action);
			wearInventory?.InspectUids(action);
			beltInventory?.InspectUids(action);
			backpackInventory?.InspectUids(action);
		}
	}

	[NonSerialized]
	public List<ReclaimInfo> reclaimEntries;

	[NonSerialized]
	public int lastReclaimID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ReclaimManager instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.reclaimEntries != null)
		{
			for (int i = 0; i < instance.reclaimEntries.Count; i++)
			{
				if (instance.reclaimEntries[i] != null)
				{
					instance.reclaimEntries[i].ResetToPool();
					instance.reclaimEntries[i] = null;
				}
			}
			List<ReclaimInfo> list = instance.reclaimEntries;
			Pool.Free<ReclaimInfo>(ref list, false);
			instance.reclaimEntries = list;
		}
		instance.lastReclaimID = 0;
		Pool.Free<ReclaimManager>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ReclaimManager with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ReclaimManager instance)
	{
		if (reclaimEntries != null)
		{
			instance.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
			for (int i = 0; i < reclaimEntries.Count; i++)
			{
				ReclaimInfo item = reclaimEntries[i].Copy();
				instance.reclaimEntries.Add(item);
			}
		}
		else
		{
			instance.reclaimEntries = null;
		}
		instance.lastReclaimID = lastReclaimID;
	}

	public ReclaimManager Copy()
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		CopyTo(reclaimManager);
		return reclaimManager;
	}

	public static ReclaimManager Deserialize(BufferStream stream)
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		Deserialize(stream, reclaimManager, isDelta: false);
		return reclaimManager;
	}

	public static ReclaimManager DeserializeLengthDelimited(BufferStream stream)
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		DeserializeLengthDelimited(stream, reclaimManager, isDelta: false);
		return reclaimManager;
	}

	public static ReclaimManager DeserializeLength(BufferStream stream, int length)
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		DeserializeLength(stream, length, reclaimManager, isDelta: false);
		return reclaimManager;
	}

	public static ReclaimManager Deserialize(byte[] buffer)
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, reclaimManager, isDelta: false);
		return reclaimManager;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ReclaimManager previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ReclaimManager Deserialize(BufferStream stream, ReclaimManager instance, bool isDelta)
	{
		if (!isDelta && instance.reclaimEntries == null)
		{
			instance.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.reclaimEntries.Add(ReclaimInfo.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lastReclaimID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ReclaimManager DeserializeLengthDelimited(BufferStream stream, ReclaimManager instance, bool isDelta)
	{
		if (!isDelta && instance.reclaimEntries == null)
		{
			instance.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.reclaimEntries.Add(ReclaimInfo.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lastReclaimID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ReclaimManager DeserializeLength(BufferStream stream, int length, ReclaimManager instance, bool isDelta)
	{
		if (!isDelta && instance.reclaimEntries == null)
		{
			instance.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.reclaimEntries.Add(ReclaimInfo.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lastReclaimID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ReclaimManager instance, ReclaimManager previous)
	{
		if (instance.reclaimEntries != null)
		{
			for (int i = 0; i < instance.reclaimEntries.Count; i++)
			{
				ReclaimInfo reclaimInfo = instance.reclaimEntries[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ReclaimInfo.SerializeDelta(stream, reclaimInfo, reclaimInfo);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.lastReclaimID != previous.lastReclaimID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastReclaimID);
		}
	}

	public static void Serialize(BufferStream stream, ReclaimManager instance)
	{
		if (instance.reclaimEntries != null)
		{
			for (int i = 0; i < instance.reclaimEntries.Count; i++)
			{
				ReclaimInfo instance2 = instance.reclaimEntries[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ReclaimInfo.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.lastReclaimID != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastReclaimID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (reclaimEntries != null)
		{
			for (int i = 0; i < reclaimEntries.Count; i++)
			{
				reclaimEntries[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ReclaimTerminal : IDisposable, IPooled, IProto<ReclaimTerminal>, IProto
{
	[NonSerialized]
	public int itemCount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ReclaimTerminal instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemCount = 0;
			Pool.Free<ReclaimTerminal>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ReclaimTerminal with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ReclaimTerminal instance)
	{
		instance.itemCount = itemCount;
	}

	public ReclaimTerminal Copy()
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		CopyTo(reclaimTerminal);
		return reclaimTerminal;
	}

	public static ReclaimTerminal Deserialize(BufferStream stream)
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		Deserialize(stream, reclaimTerminal, isDelta: false);
		return reclaimTerminal;
	}

	public static ReclaimTerminal DeserializeLengthDelimited(BufferStream stream)
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		DeserializeLengthDelimited(stream, reclaimTerminal, isDelta: false);
		return reclaimTerminal;
	}

	public static ReclaimTerminal DeserializeLength(BufferStream stream, int length)
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		DeserializeLength(stream, length, reclaimTerminal, isDelta: false);
		return reclaimTerminal;
	}

	public static ReclaimTerminal Deserialize(byte[] buffer)
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, reclaimTerminal, isDelta: false);
		return reclaimTerminal;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ReclaimTerminal previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ReclaimTerminal Deserialize(BufferStream stream, ReclaimTerminal instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ReclaimTerminal DeserializeLengthDelimited(BufferStream stream, ReclaimTerminal instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ReclaimTerminal DeserializeLength(BufferStream stream, int length, ReclaimTerminal instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ReclaimTerminal instance, ReclaimTerminal previous)
	{
		if (instance.itemCount != previous.itemCount)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCount);
		}
	}

	public static void Serialize(BufferStream stream, ReclaimTerminal instance)
	{
		if (instance.itemCount != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SlotMachine : IDisposable, IPooled, IProto<SlotMachine>, IProto
{
	[NonSerialized]
	public int oldResult1;

	[NonSerialized]
	public int oldResult2;

	[NonSerialized]
	public int oldResult3;

	[NonSerialized]
	public int newResult1;

	[NonSerialized]
	public int newResult2;

	[NonSerialized]
	public int newResult3;

	[NonSerialized]
	public bool isSpinning;

	[NonSerialized]
	public float spinTime;

	[NonSerialized]
	public NetworkableId storageID;

	[NonSerialized]
	public int multiplier;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SlotMachine instance)
	{
		if (instance.ShouldPool)
		{
			instance.oldResult1 = 0;
			instance.oldResult2 = 0;
			instance.oldResult3 = 0;
			instance.newResult1 = 0;
			instance.newResult2 = 0;
			instance.newResult3 = 0;
			instance.isSpinning = false;
			instance.spinTime = 0f;
			instance.storageID = default(NetworkableId);
			instance.multiplier = 0;
			Pool.Free<SlotMachine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SlotMachine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SlotMachine instance)
	{
		instance.oldResult1 = oldResult1;
		instance.oldResult2 = oldResult2;
		instance.oldResult3 = oldResult3;
		instance.newResult1 = newResult1;
		instance.newResult2 = newResult2;
		instance.newResult3 = newResult3;
		instance.isSpinning = isSpinning;
		instance.spinTime = spinTime;
		instance.storageID = storageID;
		instance.multiplier = multiplier;
	}

	public SlotMachine Copy()
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		CopyTo(slotMachine);
		return slotMachine;
	}

	public static SlotMachine Deserialize(BufferStream stream)
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		Deserialize(stream, slotMachine, isDelta: false);
		return slotMachine;
	}

	public static SlotMachine DeserializeLengthDelimited(BufferStream stream)
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		DeserializeLengthDelimited(stream, slotMachine, isDelta: false);
		return slotMachine;
	}

	public static SlotMachine DeserializeLength(BufferStream stream, int length)
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		DeserializeLength(stream, length, slotMachine, isDelta: false);
		return slotMachine;
	}

	public static SlotMachine Deserialize(byte[] buffer)
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, slotMachine, isDelta: false);
		return slotMachine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SlotMachine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SlotMachine Deserialize(BufferStream stream, SlotMachine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.oldResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oldResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.oldResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.newResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.newResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.newResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isSpinning = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.spinTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 80:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SlotMachine DeserializeLengthDelimited(BufferStream stream, SlotMachine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.oldResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oldResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.oldResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.newResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.newResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.newResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isSpinning = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.spinTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 80:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SlotMachine DeserializeLength(BufferStream stream, int length, SlotMachine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.oldResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oldResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.oldResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.newResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.newResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.newResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isSpinning = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.spinTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 80:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SlotMachine instance, SlotMachine previous)
	{
		if (instance.oldResult1 != previous.oldResult1)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult1);
		}
		if (instance.oldResult2 != previous.oldResult2)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult2);
		}
		if (instance.oldResult3 != previous.oldResult3)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult3);
		}
		if (instance.newResult1 != previous.newResult1)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult1);
		}
		if (instance.newResult2 != previous.newResult2)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult2);
		}
		if (instance.newResult3 != previous.newResult3)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult3);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.isSpinning);
		if (instance.spinTime != previous.spinTime)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.spinTime);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		if (instance.multiplier != previous.multiplier)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
	}

	public static void Serialize(BufferStream stream, SlotMachine instance)
	{
		if (instance.oldResult1 != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult1);
		}
		if (instance.oldResult2 != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult2);
		}
		if (instance.oldResult3 != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult3);
		}
		if (instance.newResult1 != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult1);
		}
		if (instance.newResult2 != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult2);
		}
		if (instance.newResult3 != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult3);
		}
		if (instance.isSpinning)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isSpinning);
		}
		if (instance.spinTime != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.spinTime);
		}
		if (instance.storageID != default(NetworkableId))
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		}
		if (instance.multiplier != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref storageID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CardGame : IDisposable, IPooled, IProto<CardGame>, IProto
{
	public class CardPlayer : IDisposable, IPooled, IProto<CardPlayer>, IProto
	{
		[NonSerialized]
		public ulong userid;

		[NonSerialized]
		public List<int> cards;

		[NonSerialized]
		public int scrap;

		[NonSerialized]
		public int state;

		[NonSerialized]
		public int availableInputs;

		[NonSerialized]
		public int betThisRound;

		[NonSerialized]
		public int betThisTurn;

		[NonSerialized]
		public bool leftRoundEarly;

		[NonSerialized]
		public bool sendCardDetails;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(CardPlayer instance)
		{
			if (instance.ShouldPool)
			{
				instance.userid = 0uL;
				if (instance.cards != null)
				{
					List<int> list = instance.cards;
					Pool.FreeUnmanaged<int>(ref list);
					instance.cards = list;
				}
				instance.scrap = 0;
				instance.state = 0;
				instance.availableInputs = 0;
				instance.betThisRound = 0;
				instance.betThisTurn = 0;
				instance.leftRoundEarly = false;
				instance.sendCardDetails = false;
				Pool.Free<CardPlayer>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose CardPlayer with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(CardPlayer instance)
		{
			instance.userid = userid;
			if (cards != null)
			{
				instance.cards = Pool.Get<List<int>>();
				for (int i = 0; i < cards.Count; i++)
				{
					int item = cards[i];
					instance.cards.Add(item);
				}
			}
			else
			{
				instance.cards = null;
			}
			instance.scrap = scrap;
			instance.state = state;
			instance.availableInputs = availableInputs;
			instance.betThisRound = betThisRound;
			instance.betThisTurn = betThisTurn;
			instance.leftRoundEarly = leftRoundEarly;
			instance.sendCardDetails = sendCardDetails;
		}

		public CardPlayer Copy()
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			CopyTo(cardPlayer);
			return cardPlayer;
		}

		public static CardPlayer Deserialize(BufferStream stream)
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			Deserialize(stream, cardPlayer, isDelta: false);
			return cardPlayer;
		}

		public static CardPlayer DeserializeLengthDelimited(BufferStream stream)
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			DeserializeLengthDelimited(stream, cardPlayer, isDelta: false);
			return cardPlayer;
		}

		public static CardPlayer DeserializeLength(BufferStream stream, int length)
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			DeserializeLength(stream, length, cardPlayer, isDelta: false);
			return cardPlayer;
		}

		public static CardPlayer Deserialize(byte[] buffer)
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, cardPlayer, isDelta: false);
			return cardPlayer;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, CardPlayer previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static CardPlayer Deserialize(BufferStream stream, CardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.state = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 64:
					instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.sendCardDetails = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static CardPlayer DeserializeLengthDelimited(BufferStream stream, CardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.state = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 64:
					instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.sendCardDetails = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static CardPlayer DeserializeLength(BufferStream stream, int length, CardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.state = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 64:
					instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.sendCardDetails = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, CardPlayer instance, CardPlayer previous)
		{
			if (instance.userid != previous.userid)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.cards != null)
			{
				for (int i = 0; i < instance.cards.Count; i++)
				{
					int num = instance.cards[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.scrap != previous.scrap)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.scrap);
			}
			if (instance.state != previous.state)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
			}
			if (instance.availableInputs != previous.availableInputs)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.availableInputs);
			}
			if (instance.betThisRound != previous.betThisRound)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisRound);
			}
			if (instance.betThisTurn != previous.betThisTurn)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisTurn);
			}
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.leftRoundEarly);
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.sendCardDetails);
		}

		public static void Serialize(BufferStream stream, CardPlayer instance)
		{
			if (instance.userid != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.cards != null)
			{
				for (int i = 0; i < instance.cards.Count; i++)
				{
					int num = instance.cards[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.scrap != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.scrap);
			}
			if (instance.state != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
			}
			if (instance.availableInputs != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.availableInputs);
			}
			if (instance.betThisRound != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisRound);
			}
			if (instance.betThisTurn != 0)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisTurn);
			}
			if (instance.leftRoundEarly)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteBool(stream, instance.leftRoundEarly);
			}
			if (instance.sendCardDetails)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteBool(stream, instance.sendCardDetails);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class TexasHoldEm : IDisposable, IPooled, IProto<TexasHoldEm>, IProto
	{
		[NonSerialized]
		public int dealerIndex;

		[NonSerialized]
		public List<int> communityCards;

		[NonSerialized]
		public int biggestRaiseThisTurn;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(TexasHoldEm instance)
		{
			if (instance.ShouldPool)
			{
				instance.dealerIndex = 0;
				if (instance.communityCards != null)
				{
					List<int> list = instance.communityCards;
					Pool.FreeUnmanaged<int>(ref list);
					instance.communityCards = list;
				}
				instance.biggestRaiseThisTurn = 0;
				Pool.Free<TexasHoldEm>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose TexasHoldEm with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(TexasHoldEm instance)
		{
			instance.dealerIndex = dealerIndex;
			if (communityCards != null)
			{
				instance.communityCards = Pool.Get<List<int>>();
				for (int i = 0; i < communityCards.Count; i++)
				{
					int item = communityCards[i];
					instance.communityCards.Add(item);
				}
			}
			else
			{
				instance.communityCards = null;
			}
			instance.biggestRaiseThisTurn = biggestRaiseThisTurn;
		}

		public TexasHoldEm Copy()
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			CopyTo(texasHoldEm);
			return texasHoldEm;
		}

		public static TexasHoldEm Deserialize(BufferStream stream)
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			Deserialize(stream, texasHoldEm, isDelta: false);
			return texasHoldEm;
		}

		public static TexasHoldEm DeserializeLengthDelimited(BufferStream stream)
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			DeserializeLengthDelimited(stream, texasHoldEm, isDelta: false);
			return texasHoldEm;
		}

		public static TexasHoldEm DeserializeLength(BufferStream stream, int length)
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			DeserializeLength(stream, length, texasHoldEm, isDelta: false);
			return texasHoldEm;
		}

		public static TexasHoldEm Deserialize(byte[] buffer)
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, texasHoldEm, isDelta: false);
			return texasHoldEm;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, TexasHoldEm previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static TexasHoldEm Deserialize(BufferStream stream, TexasHoldEm instance, bool isDelta)
		{
			if (!isDelta && instance.communityCards == null)
			{
				instance.communityCards = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static TexasHoldEm DeserializeLengthDelimited(BufferStream stream, TexasHoldEm instance, bool isDelta)
		{
			if (!isDelta && instance.communityCards == null)
			{
				instance.communityCards = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static TexasHoldEm DeserializeLength(BufferStream stream, int length, TexasHoldEm instance, bool isDelta)
		{
			if (!isDelta && instance.communityCards == null)
			{
				instance.communityCards = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, TexasHoldEm instance, TexasHoldEm previous)
		{
			if (instance.dealerIndex != previous.dealerIndex)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.dealerIndex);
			}
			if (instance.communityCards != null)
			{
				for (int i = 0; i < instance.communityCards.Count; i++)
				{
					int num = instance.communityCards[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.biggestRaiseThisTurn != previous.biggestRaiseThisTurn)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.biggestRaiseThisTurn);
			}
		}

		public static void Serialize(BufferStream stream, TexasHoldEm instance)
		{
			if (instance.dealerIndex != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.dealerIndex);
			}
			if (instance.communityCards != null)
			{
				for (int i = 0; i < instance.communityCards.Count; i++)
				{
					int num = instance.communityCards[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.biggestRaiseThisTurn != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.biggestRaiseThisTurn);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class RoundResults : IDisposable, IPooled, IProto<RoundResults>, IProto
	{
		public class Result : IDisposable, IPooled, IProto<Result>, IProto
		{
			[NonSerialized]
			public ulong ID;

			[NonSerialized]
			public int winnings;

			[NonSerialized]
			public int resultCode;

			public bool ShouldPool = true;

			private bool _disposed;

			public static void ResetToPool(Result instance)
			{
				if (instance.ShouldPool)
				{
					instance.ID = 0uL;
					instance.winnings = 0;
					instance.resultCode = 0;
					Pool.Free<Result>(ref instance);
				}
			}

			public void ResetToPool()
			{
				ResetToPool(this);
			}

			public virtual void Dispose()
			{
				if (!ShouldPool)
				{
					throw new Exception("Trying to dispose Result with ShouldPool set to false!");
				}
				if (!_disposed)
				{
					ResetToPool();
					_disposed = true;
				}
			}

			public virtual void EnterPool()
			{
				_disposed = true;
			}

			public virtual void LeavePool()
			{
				_disposed = false;
			}

			public void CopyTo(Result instance)
			{
				instance.ID = ID;
				instance.winnings = winnings;
				instance.resultCode = resultCode;
			}

			public Result Copy()
			{
				Result result = Pool.Get<Result>();
				CopyTo(result);
				return result;
			}

			public static Result Deserialize(BufferStream stream)
			{
				Result result = Pool.Get<Result>();
				Deserialize(stream, result, isDelta: false);
				return result;
			}

			public static Result DeserializeLengthDelimited(BufferStream stream)
			{
				Result result = Pool.Get<Result>();
				DeserializeLengthDelimited(stream, result, isDelta: false);
				return result;
			}

			public static Result DeserializeLength(BufferStream stream, int length)
			{
				Result result = Pool.Get<Result>();
				DeserializeLength(stream, length, result, isDelta: false);
				return result;
			}

			public static Result Deserialize(byte[] buffer)
			{
				Result result = Pool.Get<Result>();
				using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
				Deserialize(stream, result, isDelta: false);
				return result;
			}

			public void FromProto(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void WriteToStream(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public virtual void WriteToStreamDelta(BufferStream stream, Result previous)
			{
				if (previous == null)
				{
					Serialize(stream, this);
				}
				else
				{
					SerializeDelta(stream, this, previous);
				}
			}

			public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
			{
				DeserializeLength(stream, size, this, isDelta);
			}

			public static Result Deserialize(BufferStream stream, Result instance, bool isDelta)
			{
				while (true)
				{
					int num = stream.ReadByte();
					switch (num)
					{
					case 8:
						instance.ID = ProtocolParser.ReadUInt64(stream);
						continue;
					case 16:
						instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					case 24:
						instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					case -1:
						return instance;
					}
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
			}

			public static Result DeserializeLengthDelimited(BufferStream stream, Result instance, bool isDelta)
			{
				long num = ProtocolParser.ReadUInt32(stream);
				num += stream.Position;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 8:
						instance.ID = ProtocolParser.ReadUInt64(stream);
						continue;
					case 16:
						instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					case 24:
						instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static Result DeserializeLength(BufferStream stream, int length, Result instance, bool isDelta)
			{
				long num = stream.Position + length;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 8:
						instance.ID = ProtocolParser.ReadUInt64(stream);
						continue;
					case 16:
						instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					case 24:
						instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static void SerializeDelta(BufferStream stream, Result instance, Result previous)
			{
				if (instance.ID != previous.ID)
				{
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, instance.ID);
				}
				if (instance.winnings != previous.winnings)
				{
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
				}
				if (instance.resultCode != previous.resultCode)
				{
					stream.WriteByte(24);
					ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
				}
			}

			public static void Serialize(BufferStream stream, Result instance)
			{
				if (instance.ID != 0L)
				{
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, instance.ID);
				}
				if (instance.winnings != 0)
				{
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
				}
				if (instance.resultCode != 0)
				{
					stream.WriteByte(24);
					ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
				}
			}

			public void ToProto(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public void InspectUids(UidInspector<ulong> action)
			{
			}
		}

		[NonSerialized]
		public List<Result> results;

		[NonSerialized]
		public int winningScore;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(RoundResults instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.results != null)
			{
				for (int i = 0; i < instance.results.Count; i++)
				{
					if (instance.results[i] != null)
					{
						instance.results[i].ResetToPool();
						instance.results[i] = null;
					}
				}
				List<Result> list = instance.results;
				Pool.Free<Result>(ref list, false);
				instance.results = list;
			}
			instance.winningScore = 0;
			Pool.Free<RoundResults>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose RoundResults with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(RoundResults instance)
		{
			if (results != null)
			{
				instance.results = Pool.Get<List<Result>>();
				for (int i = 0; i < results.Count; i++)
				{
					Result item = results[i].Copy();
					instance.results.Add(item);
				}
			}
			else
			{
				instance.results = null;
			}
			instance.winningScore = winningScore;
		}

		public RoundResults Copy()
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			CopyTo(roundResults);
			return roundResults;
		}

		public static RoundResults Deserialize(BufferStream stream)
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			Deserialize(stream, roundResults, isDelta: false);
			return roundResults;
		}

		public static RoundResults DeserializeLengthDelimited(BufferStream stream)
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			DeserializeLengthDelimited(stream, roundResults, isDelta: false);
			return roundResults;
		}

		public static RoundResults DeserializeLength(BufferStream stream, int length)
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			DeserializeLength(stream, length, roundResults, isDelta: false);
			return roundResults;
		}

		public static RoundResults Deserialize(byte[] buffer)
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, roundResults, isDelta: false);
			return roundResults;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, RoundResults previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static RoundResults Deserialize(BufferStream stream, RoundResults instance, bool isDelta)
		{
			if (!isDelta && instance.results == null)
			{
				instance.results = Pool.Get<List<Result>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.results.Add(Result.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static RoundResults DeserializeLengthDelimited(BufferStream stream, RoundResults instance, bool isDelta)
		{
			if (!isDelta && instance.results == null)
			{
				instance.results = Pool.Get<List<Result>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.results.Add(Result.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static RoundResults DeserializeLength(BufferStream stream, int length, RoundResults instance, bool isDelta)
		{
			if (!isDelta && instance.results == null)
			{
				instance.results = Pool.Get<List<Result>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.results.Add(Result.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, RoundResults instance, RoundResults previous)
		{
			if (instance.results != null)
			{
				for (int i = 0; i < instance.results.Count; i++)
				{
					Result result = instance.results[i];
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Result.SerializeDelta(stream, result, result);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field results (ProtoBuf.CardGame.RoundResults.Result)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.winningScore != previous.winningScore)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.winningScore);
			}
		}

		public static void Serialize(BufferStream stream, RoundResults instance)
		{
			if (instance.results != null)
			{
				for (int i = 0; i < instance.results.Count; i++)
				{
					Result instance2 = instance.results[i];
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Result.Serialize(stream, instance2);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field results (ProtoBuf.CardGame.RoundResults.Result)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.winningScore != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.winningScore);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (results != null)
			{
				for (int i = 0; i < results.Count; i++)
				{
					results[i]?.InspectUids(action);
				}
			}
		}
	}

	public class Blackjack : IDisposable, IPooled, IProto<Blackjack>, IProto
	{
		[NonSerialized]
		public List<int> dealerCards;

		[NonSerialized]
		public List<BlackjackCardPlayer> players;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Blackjack instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.dealerCards != null)
			{
				List<int> list = instance.dealerCards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.dealerCards = list;
			}
			if (instance.players != null)
			{
				for (int i = 0; i < instance.players.Count; i++)
				{
					if (instance.players[i] != null)
					{
						instance.players[i].ResetToPool();
						instance.players[i] = null;
					}
				}
				List<BlackjackCardPlayer> list2 = instance.players;
				Pool.Free<BlackjackCardPlayer>(ref list2, false);
				instance.players = list2;
			}
			Pool.Free<Blackjack>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Blackjack with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Blackjack instance)
		{
			if (dealerCards != null)
			{
				instance.dealerCards = Pool.Get<List<int>>();
				for (int i = 0; i < dealerCards.Count; i++)
				{
					int item = dealerCards[i];
					instance.dealerCards.Add(item);
				}
			}
			else
			{
				instance.dealerCards = null;
			}
			if (players != null)
			{
				instance.players = Pool.Get<List<BlackjackCardPlayer>>();
				for (int j = 0; j < players.Count; j++)
				{
					BlackjackCardPlayer item2 = players[j].Copy();
					instance.players.Add(item2);
				}
			}
			else
			{
				instance.players = null;
			}
		}

		public Blackjack Copy()
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			CopyTo(blackjack);
			return blackjack;
		}

		public static Blackjack Deserialize(BufferStream stream)
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			Deserialize(stream, blackjack, isDelta: false);
			return blackjack;
		}

		public static Blackjack DeserializeLengthDelimited(BufferStream stream)
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			DeserializeLengthDelimited(stream, blackjack, isDelta: false);
			return blackjack;
		}

		public static Blackjack DeserializeLength(BufferStream stream, int length)
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			DeserializeLength(stream, length, blackjack, isDelta: false);
			return blackjack;
		}

		public static Blackjack Deserialize(byte[] buffer)
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, blackjack, isDelta: false);
			return blackjack;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Blackjack previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Blackjack Deserialize(BufferStream stream, Blackjack instance, bool isDelta)
		{
			if (!isDelta)
			{
				if (instance.dealerCards == null)
				{
					instance.dealerCards = Pool.Get<List<int>>();
				}
				if (instance.players == null)
				{
					instance.players = Pool.Get<List<BlackjackCardPlayer>>();
				}
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Blackjack DeserializeLengthDelimited(BufferStream stream, Blackjack instance, bool isDelta)
		{
			if (!isDelta)
			{
				if (instance.dealerCards == null)
				{
					instance.dealerCards = Pool.Get<List<int>>();
				}
				if (instance.players == null)
				{
					instance.players = Pool.Get<List<BlackjackCardPlayer>>();
				}
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Blackjack DeserializeLength(BufferStream stream, int length, Blackjack instance, bool isDelta)
		{
			if (!isDelta)
			{
				if (instance.dealerCards == null)
				{
					instance.dealerCards = Pool.Get<List<int>>();
				}
				if (instance.players == null)
				{
					instance.players = Pool.Get<List<BlackjackCardPlayer>>();
				}
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Blackjack instance, Blackjack previous)
		{
			if (instance.dealerCards != null)
			{
				for (int i = 0; i < instance.dealerCards.Count; i++)
				{
					int num = instance.dealerCards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.players == null)
			{
				return;
			}
			for (int j = 0; j < instance.players.Count; j++)
			{
				BlackjackCardPlayer blackjackCardPlayer = instance.players[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				BlackjackCardPlayer.SerializeDelta(stream, blackjackCardPlayer, blackjackCardPlayer);
				int num2 = stream.Position - position;
				if (num2 > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.BlackjackCardPlayer)");
				}
				Span<byte> span = range.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
				if (num3 < 3)
				{
					span[num3 - 1] |= 128;
					while (num3 < 2)
					{
						span[num3++] = 128;
					}
					span[2] = 0;
				}
			}
		}

		public static void Serialize(BufferStream stream, Blackjack instance)
		{
			if (instance.dealerCards != null)
			{
				for (int i = 0; i < instance.dealerCards.Count; i++)
				{
					int num = instance.dealerCards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.players == null)
			{
				return;
			}
			for (int j = 0; j < instance.players.Count; j++)
			{
				BlackjackCardPlayer instance2 = instance.players[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				BlackjackCardPlayer.Serialize(stream, instance2);
				int num2 = stream.Position - position;
				if (num2 > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.BlackjackCardPlayer)");
				}
				Span<byte> span = range.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
				if (num3 < 3)
				{
					span[num3 - 1] |= 128;
					while (num3 < 2)
					{
						span[num3++] = 128;
					}
					span[2] = 0;
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (players != null)
			{
				for (int i = 0; i < players.Count; i++)
				{
					players[i]?.InspectUids(action);
				}
			}
		}
	}

	public class BlackjackCardPlayer : IDisposable, IPooled, IProto<BlackjackCardPlayer>, IProto
	{
		[NonSerialized]
		public List<int> splitCards;

		[NonSerialized]
		public int splitBetThisRound;

		[NonSerialized]
		public int insuranceBetThisRound;

		[NonSerialized]
		public bool playingSplitCards;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(BlackjackCardPlayer instance)
		{
			if (instance.ShouldPool)
			{
				if (instance.splitCards != null)
				{
					List<int> list = instance.splitCards;
					Pool.FreeUnmanaged<int>(ref list);
					instance.splitCards = list;
				}
				instance.splitBetThisRound = 0;
				instance.insuranceBetThisRound = 0;
				instance.playingSplitCards = false;
				Pool.Free<BlackjackCardPlayer>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose BlackjackCardPlayer with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(BlackjackCardPlayer instance)
		{
			if (splitCards != null)
			{
				instance.splitCards = Pool.Get<List<int>>();
				for (int i = 0; i < splitCards.Count; i++)
				{
					int item = splitCards[i];
					instance.splitCards.Add(item);
				}
			}
			else
			{
				instance.splitCards = null;
			}
			instance.splitBetThisRound = splitBetThisRound;
			instance.insuranceBetThisRound = insuranceBetThisRound;
			instance.playingSplitCards = playingSplitCards;
		}

		public BlackjackCardPlayer Copy()
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			CopyTo(blackjackCardPlayer);
			return blackjackCardPlayer;
		}

		public static BlackjackCardPlayer Deserialize(BufferStream stream)
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			Deserialize(stream, blackjackCardPlayer, isDelta: false);
			return blackjackCardPlayer;
		}

		public static BlackjackCardPlayer DeserializeLengthDelimited(BufferStream stream)
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			DeserializeLengthDelimited(stream, blackjackCardPlayer, isDelta: false);
			return blackjackCardPlayer;
		}

		public static BlackjackCardPlayer DeserializeLength(BufferStream stream, int length)
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			DeserializeLength(stream, length, blackjackCardPlayer, isDelta: false);
			return blackjackCardPlayer;
		}

		public static BlackjackCardPlayer Deserialize(byte[] buffer)
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, blackjackCardPlayer, isDelta: false);
			return blackjackCardPlayer;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, BlackjackCardPlayer previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static BlackjackCardPlayer Deserialize(BufferStream stream, BlackjackCardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.splitCards == null)
			{
				instance.splitCards = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.playingSplitCards = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static BlackjackCardPlayer DeserializeLengthDelimited(BufferStream stream, BlackjackCardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.splitCards == null)
			{
				instance.splitCards = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.playingSplitCards = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static BlackjackCardPlayer DeserializeLength(BufferStream stream, int length, BlackjackCardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.splitCards == null)
			{
				instance.splitCards = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.playingSplitCards = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, BlackjackCardPlayer instance, BlackjackCardPlayer previous)
		{
			if (instance.splitCards != null)
			{
				for (int i = 0; i < instance.splitCards.Count; i++)
				{
					int num = instance.splitCards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.splitBetThisRound != previous.splitBetThisRound)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.splitBetThisRound);
			}
			if (instance.insuranceBetThisRound != previous.insuranceBetThisRound)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.insuranceBetThisRound);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.playingSplitCards);
		}

		public static void Serialize(BufferStream stream, BlackjackCardPlayer instance)
		{
			if (instance.splitCards != null)
			{
				for (int i = 0; i < instance.splitCards.Count; i++)
				{
					int num = instance.splitCards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.splitBetThisRound != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.splitBetThisRound);
			}
			if (instance.insuranceBetThisRound != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.insuranceBetThisRound);
			}
			if (instance.playingSplitCards)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteBool(stream, instance.playingSplitCards);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class CardList : IDisposable, IPooled, IProto<CardList>, IProto
	{
		[NonSerialized]
		public List<int> cards;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(CardList instance)
		{
			if (instance.ShouldPool)
			{
				if (instance.cards != null)
				{
					List<int> list = instance.cards;
					Pool.FreeUnmanaged<int>(ref list);
					instance.cards = list;
				}
				Pool.Free<CardList>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose CardList with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(CardList instance)
		{
			if (cards != null)
			{
				instance.cards = Pool.Get<List<int>>();
				for (int i = 0; i < cards.Count; i++)
				{
					int item = cards[i];
					instance.cards.Add(item);
				}
			}
			else
			{
				instance.cards = null;
			}
		}

		public CardList Copy()
		{
			CardList cardList = Pool.Get<CardList>();
			CopyTo(cardList);
			return cardList;
		}

		public static CardList Deserialize(BufferStream stream)
		{
			CardList cardList = Pool.Get<CardList>();
			Deserialize(stream, cardList, isDelta: false);
			return cardList;
		}

		public static CardList DeserializeLengthDelimited(BufferStream stream)
		{
			CardList cardList = Pool.Get<CardList>();
			DeserializeLengthDelimited(stream, cardList, isDelta: false);
			return cardList;
		}

		public static CardList DeserializeLength(BufferStream stream, int length)
		{
			CardList cardList = Pool.Get<CardList>();
			DeserializeLength(stream, length, cardList, isDelta: false);
			return cardList;
		}

		public static CardList Deserialize(byte[] buffer)
		{
			CardList cardList = Pool.Get<CardList>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, cardList, isDelta: false);
			return cardList;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, CardList previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static CardList Deserialize(BufferStream stream, CardList instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static CardList DeserializeLengthDelimited(BufferStream stream, CardList instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static CardList DeserializeLength(BufferStream stream, int length, CardList instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, CardList instance, CardList previous)
		{
			if (instance.cards != null)
			{
				for (int i = 0; i < instance.cards.Count; i++)
				{
					int num = instance.cards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
		}

		public static void Serialize(BufferStream stream, CardList instance)
		{
			if (instance.cards != null)
			{
				for (int i = 0; i < instance.cards.Count; i++)
				{
					int num = instance.cards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<CardPlayer> players;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public int activePlayerIndex;

	[NonSerialized]
	public int pot;

	[NonSerialized]
	public int lastActionId;

	[NonSerialized]
	public ulong lastActionTarget;

	[NonSerialized]
	public int lastActionValue;

	[NonSerialized]
	public NetworkableId potRef;

	[NonSerialized]
	public TexasHoldEm texasHoldEm;

	[NonSerialized]
	public Blackjack blackjack;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CardGame instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.players != null)
		{
			for (int i = 0; i < instance.players.Count; i++)
			{
				if (instance.players[i] != null)
				{
					instance.players[i].ResetToPool();
					instance.players[i] = null;
				}
			}
			List<CardPlayer> list = instance.players;
			Pool.Free<CardPlayer>(ref list, false);
			instance.players = list;
		}
		instance.state = 0;
		instance.activePlayerIndex = 0;
		instance.pot = 0;
		instance.lastActionId = 0;
		instance.lastActionTarget = 0uL;
		instance.lastActionValue = 0;
		instance.potRef = default(NetworkableId);
		if (instance.texasHoldEm != null)
		{
			instance.texasHoldEm.ResetToPool();
			instance.texasHoldEm = null;
		}
		if (instance.blackjack != null)
		{
			instance.blackjack.ResetToPool();
			instance.blackjack = null;
		}
		Pool.Free<CardGame>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CardGame with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CardGame instance)
	{
		if (players != null)
		{
			instance.players = Pool.Get<List<CardPlayer>>();
			for (int i = 0; i < players.Count; i++)
			{
				CardPlayer item = players[i].Copy();
				instance.players.Add(item);
			}
		}
		else
		{
			instance.players = null;
		}
		instance.state = state;
		instance.activePlayerIndex = activePlayerIndex;
		instance.pot = pot;
		instance.lastActionId = lastActionId;
		instance.lastActionTarget = lastActionTarget;
		instance.lastActionValue = lastActionValue;
		instance.potRef = potRef;
		if (texasHoldEm != null)
		{
			if (instance.texasHoldEm == null)
			{
				instance.texasHoldEm = texasHoldEm.Copy();
			}
			else
			{
				texasHoldEm.CopyTo(instance.texasHoldEm);
			}
		}
		else
		{
			instance.texasHoldEm = null;
		}
		if (blackjack != null)
		{
			if (instance.blackjack == null)
			{
				instance.blackjack = blackjack.Copy();
			}
			else
			{
				blackjack.CopyTo(instance.blackjack);
			}
		}
		else
		{
			instance.blackjack = null;
		}
	}

	public CardGame Copy()
	{
		CardGame cardGame = Pool.Get<CardGame>();
		CopyTo(cardGame);
		return cardGame;
	}

	public static CardGame Deserialize(BufferStream stream)
	{
		CardGame cardGame = Pool.Get<CardGame>();
		Deserialize(stream, cardGame, isDelta: false);
		return cardGame;
	}

	public static CardGame DeserializeLengthDelimited(BufferStream stream)
	{
		CardGame cardGame = Pool.Get<CardGame>();
		DeserializeLengthDelimited(stream, cardGame, isDelta: false);
		return cardGame;
	}

	public static CardGame DeserializeLength(BufferStream stream, int length)
	{
		CardGame cardGame = Pool.Get<CardGame>();
		DeserializeLength(stream, length, cardGame, isDelta: false);
		return cardGame;
	}

	public static CardGame Deserialize(byte[] buffer)
	{
		CardGame cardGame = Pool.Get<CardGame>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cardGame, isDelta: false);
		return cardGame;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CardGame previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CardGame Deserialize(BufferStream stream, CardGame instance, bool isDelta)
	{
		if (!isDelta && instance.players == null)
		{
			instance.players = Pool.Get<List<CardPlayer>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.players.Add(CardPlayer.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.activePlayerIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.pot = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.lastActionId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.lastActionTarget = ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.lastActionValue = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 64:
				instance.potRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 74:
				if (instance.texasHoldEm == null)
				{
					instance.texasHoldEm = TexasHoldEm.DeserializeLengthDelimited(stream);
				}
				else
				{
					TexasHoldEm.DeserializeLengthDelimited(stream, instance.texasHoldEm, isDelta);
				}
				break;
			case 82:
				if (instance.blackjack == null)
				{
					instance.blackjack = Blackjack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Blackjack.DeserializeLengthDelimited(stream, instance.blackjack, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static CardGame DeserializeLengthDelimited(BufferStream stream, CardGame instance, bool isDelta)
	{
		if (!isDelta && instance.players == null)
		{
			instance.players = Pool.Get<List<CardPlayer>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.players.Add(CardPlayer.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.activePlayerIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.pot = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.lastActionId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.lastActionTarget = ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.lastActionValue = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 64:
				instance.potRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 74:
				if (instance.texasHoldEm == null)
				{
					instance.texasHoldEm = TexasHoldEm.DeserializeLengthDelimited(stream);
				}
				else
				{
					TexasHoldEm.DeserializeLengthDelimited(stream, instance.texasHoldEm, isDelta);
				}
				break;
			case 82:
				if (instance.blackjack == null)
				{
					instance.blackjack = Blackjack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Blackjack.DeserializeLengthDelimited(stream, instance.blackjack, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CardGame DeserializeLength(BufferStream stream, int length, CardGame instance, bool isDelta)
	{
		if (!isDelta && instance.players == null)
		{
			instance.players = Pool.Get<List<CardPlayer>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.players.Add(CardPlayer.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.activePlayerIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.pot = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.lastActionId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.lastActionTarget = ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.lastActionValue = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 64:
				instance.potRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 74:
				if (instance.texasHoldEm == null)
				{
					instance.texasHoldEm = TexasHoldEm.DeserializeLengthDelimited(stream);
				}
				else
				{
					TexasHoldEm.DeserializeLengthDelimited(stream, instance.texasHoldEm, isDelta);
				}
				break;
			case 82:
				if (instance.blackjack == null)
				{
					instance.blackjack = Blackjack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Blackjack.DeserializeLengthDelimited(stream, instance.blackjack, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CardGame instance, CardGame previous)
	{
		if (instance.players != null)
		{
			for (int i = 0; i < instance.players.Count; i++)
			{
				CardPlayer cardPlayer = instance.players[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				CardPlayer.SerializeDelta(stream, cardPlayer, cardPlayer);
				int num = stream.Position - position;
				if (num > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.CardPlayer)");
				}
				Span<byte> span = range.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
				if (num2 < 3)
				{
					span[num2 - 1] |= 128;
					while (num2 < 2)
					{
						span[num2++] = 128;
					}
					span[2] = 0;
				}
			}
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.activePlayerIndex != previous.activePlayerIndex)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.activePlayerIndex);
		}
		if (instance.pot != previous.pot)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.pot);
		}
		if (instance.lastActionId != previous.lastActionId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastActionId);
		}
		if (instance.lastActionTarget != previous.lastActionTarget)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.lastActionTarget);
		}
		if (instance.lastActionValue != previous.lastActionValue)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastActionValue);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.potRef.Value);
		if (instance.texasHoldEm != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(3);
			int position2 = stream.Position;
			TexasHoldEm.SerializeDelta(stream, instance.texasHoldEm, previous.texasHoldEm);
			int num3 = stream.Position - position2;
			if (num3 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field texasHoldEm (ProtoBuf.CardGame.TexasHoldEm)");
			}
			Span<byte> span2 = range2.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)num3, span2, 0);
			if (num4 < 3)
			{
				span2[num4 - 1] |= 128;
				while (num4 < 2)
				{
					span2[num4++] = 128;
				}
				span2[2] = 0;
			}
		}
		if (instance.blackjack == null)
		{
			return;
		}
		stream.WriteByte(82);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		Blackjack.SerializeDelta(stream, instance.blackjack, previous.blackjack);
		int num5 = stream.Position - position3;
		if (num5 > int.MaxValue)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field blackjack (ProtoBuf.CardGame.Blackjack)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num6 = ProtocolParser.WriteUInt32((uint)num5, span3, 0);
		if (num6 < 5)
		{
			span3[num6 - 1] |= 128;
			while (num6 < 4)
			{
				span3[num6++] = 128;
			}
			span3[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, CardGame instance)
	{
		if (instance.players != null)
		{
			for (int i = 0; i < instance.players.Count; i++)
			{
				CardPlayer instance2 = instance.players[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				CardPlayer.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.CardPlayer)");
				}
				Span<byte> span = range.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
				if (num2 < 3)
				{
					span[num2 - 1] |= 128;
					while (num2 < 2)
					{
						span[num2++] = 128;
					}
					span[2] = 0;
				}
			}
		}
		if (instance.state != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.activePlayerIndex != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.activePlayerIndex);
		}
		if (instance.pot != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.pot);
		}
		if (instance.lastActionId != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastActionId);
		}
		if (instance.lastActionTarget != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.lastActionTarget);
		}
		if (instance.lastActionValue != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastActionValue);
		}
		if (instance.potRef != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.potRef.Value);
		}
		if (instance.texasHoldEm != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(3);
			int position2 = stream.Position;
			TexasHoldEm.Serialize(stream, instance.texasHoldEm);
			int num3 = stream.Position - position2;
			if (num3 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field texasHoldEm (ProtoBuf.CardGame.TexasHoldEm)");
			}
			Span<byte> span2 = range2.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)num3, span2, 0);
			if (num4 < 3)
			{
				span2[num4 - 1] |= 128;
				while (num4 < 2)
				{
					span2[num4++] = 128;
				}
				span2[2] = 0;
			}
		}
		if (instance.blackjack == null)
		{
			return;
		}
		stream.WriteByte(82);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		Blackjack.Serialize(stream, instance.blackjack);
		int num5 = stream.Position - position3;
		if (num5 > int.MaxValue)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field blackjack (ProtoBuf.CardGame.Blackjack)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num6 = ProtocolParser.WriteUInt32((uint)num5, span3, 0);
		if (num6 < 5)
		{
			span3[num6 - 1] |= 128;
			while (num6 < 4)
			{
				span3[num6++] = 128;
			}
			span3[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (players != null)
		{
			for (int i = 0; i < players.Count; i++)
			{
				players[i]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref potRef.Value);
		texasHoldEm?.InspectUids(action);
		blackjack?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Crane : IDisposable, IPooled, IProto<Crane>, IProto
{
	[NonSerialized]
	public float yaw;

	[NonSerialized]
	public float arm1;

	[NonSerialized]
	public float arm2;

	[NonSerialized]
	public float magnet;

	[NonSerialized]
	public float time;

	[NonSerialized]
	public int treadInput;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Crane instance)
	{
		if (instance.ShouldPool)
		{
			instance.yaw = 0f;
			instance.arm1 = 0f;
			instance.arm2 = 0f;
			instance.magnet = 0f;
			instance.time = 0f;
			instance.treadInput = 0;
			Pool.Free<Crane>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Crane with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Crane instance)
	{
		instance.yaw = yaw;
		instance.arm1 = arm1;
		instance.arm2 = arm2;
		instance.magnet = magnet;
		instance.time = time;
		instance.treadInput = treadInput;
	}

	public Crane Copy()
	{
		Crane crane = Pool.Get<Crane>();
		CopyTo(crane);
		return crane;
	}

	public static Crane Deserialize(BufferStream stream)
	{
		Crane crane = Pool.Get<Crane>();
		Deserialize(stream, crane, isDelta: false);
		return crane;
	}

	public static Crane DeserializeLengthDelimited(BufferStream stream)
	{
		Crane crane = Pool.Get<Crane>();
		DeserializeLengthDelimited(stream, crane, isDelta: false);
		return crane;
	}

	public static Crane DeserializeLength(BufferStream stream, int length)
	{
		Crane crane = Pool.Get<Crane>();
		DeserializeLength(stream, length, crane, isDelta: false);
		return crane;
	}

	public static Crane Deserialize(byte[] buffer)
	{
		Crane crane = Pool.Get<Crane>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, crane, isDelta: false);
		return crane;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Crane previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Crane Deserialize(BufferStream stream, Crane instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.arm1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.arm2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.magnet = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.treadInput = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Crane DeserializeLengthDelimited(BufferStream stream, Crane instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.arm1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.arm2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.magnet = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.treadInput = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Crane DeserializeLength(BufferStream stream, int length, Crane instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.arm1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.arm2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.magnet = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.treadInput = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Crane instance, Crane previous)
	{
		if (instance.yaw != previous.yaw)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
		if (instance.arm1 != previous.arm1)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.arm1);
		}
		if (instance.arm2 != previous.arm2)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.arm2);
		}
		if (instance.magnet != previous.magnet)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.magnet);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.treadInput != previous.treadInput)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.treadInput);
		}
	}

	public static void Serialize(BufferStream stream, Crane instance)
	{
		if (instance.yaw != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
		if (instance.arm1 != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.arm1);
		}
		if (instance.arm2 != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.arm2);
		}
		if (instance.magnet != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.magnet);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.treadInput != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.treadInput);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ConnectedSpeaker : IDisposable, IPooled, IProto<ConnectedSpeaker>, IProto
{
	[NonSerialized]
	public NetworkableId connectedTo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ConnectedSpeaker instance)
	{
		if (instance.ShouldPool)
		{
			instance.connectedTo = default(NetworkableId);
			Pool.Free<ConnectedSpeaker>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ConnectedSpeaker with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ConnectedSpeaker instance)
	{
		instance.connectedTo = connectedTo;
	}

	public ConnectedSpeaker Copy()
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		CopyTo(connectedSpeaker);
		return connectedSpeaker;
	}

	public static ConnectedSpeaker Deserialize(BufferStream stream)
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		Deserialize(stream, connectedSpeaker, isDelta: false);
		return connectedSpeaker;
	}

	public static ConnectedSpeaker DeserializeLengthDelimited(BufferStream stream)
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		DeserializeLengthDelimited(stream, connectedSpeaker, isDelta: false);
		return connectedSpeaker;
	}

	public static ConnectedSpeaker DeserializeLength(BufferStream stream, int length)
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		DeserializeLength(stream, length, connectedSpeaker, isDelta: false);
		return connectedSpeaker;
	}

	public static ConnectedSpeaker Deserialize(byte[] buffer)
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, connectedSpeaker, isDelta: false);
		return connectedSpeaker;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ConnectedSpeaker previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ConnectedSpeaker Deserialize(BufferStream stream, ConnectedSpeaker instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.connectedTo = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ConnectedSpeaker DeserializeLengthDelimited(BufferStream stream, ConnectedSpeaker instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.connectedTo = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ConnectedSpeaker DeserializeLength(BufferStream stream, int length, ConnectedSpeaker instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.connectedTo = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ConnectedSpeaker instance, ConnectedSpeaker previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.connectedTo.Value);
	}

	public static void Serialize(BufferStream stream, ConnectedSpeaker instance)
	{
		if (instance.connectedTo != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.connectedTo.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref connectedTo.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VoicemailEntry : IDisposable, IPooled, IProto<VoicemailEntry>, IProto
{
	[NonSerialized]
	public uint audioId;

	[NonSerialized]
	public string userName;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VoicemailEntry instance)
	{
		if (instance.ShouldPool)
		{
			instance.audioId = 0u;
			instance.userName = string.Empty;
			instance.timestamp = 0L;
			Pool.Free<VoicemailEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VoicemailEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VoicemailEntry instance)
	{
		instance.audioId = audioId;
		instance.userName = userName;
		instance.timestamp = timestamp;
	}

	public VoicemailEntry Copy()
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		CopyTo(voicemailEntry);
		return voicemailEntry;
	}

	public static VoicemailEntry Deserialize(BufferStream stream)
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		Deserialize(stream, voicemailEntry, isDelta: false);
		return voicemailEntry;
	}

	public static VoicemailEntry DeserializeLengthDelimited(BufferStream stream)
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		DeserializeLengthDelimited(stream, voicemailEntry, isDelta: false);
		return voicemailEntry;
	}

	public static VoicemailEntry DeserializeLength(BufferStream stream, int length)
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		DeserializeLength(stream, length, voicemailEntry, isDelta: false);
		return voicemailEntry;
	}

	public static VoicemailEntry Deserialize(byte[] buffer)
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, voicemailEntry, isDelta: false);
		return voicemailEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VoicemailEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VoicemailEntry Deserialize(BufferStream stream, VoicemailEntry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.userName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VoicemailEntry DeserializeLengthDelimited(BufferStream stream, VoicemailEntry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.userName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VoicemailEntry DeserializeLength(BufferStream stream, int length, VoicemailEntry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.userName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VoicemailEntry instance, VoicemailEntry previous)
	{
		if (instance.audioId != previous.audioId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.audioId);
		}
		if (instance.userName != previous.userName)
		{
			if (instance.userName == null)
			{
				throw new ArgumentNullException("userName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.userName);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, VoicemailEntry instance)
	{
		if (instance.audioId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.audioId);
		}
		if (instance.userName == null)
		{
			throw new ArgumentNullException("userName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.userName);
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AudioEntity : IDisposable, IPooled, IProto<AudioEntity>, IProto
{
	[NonSerialized]
	public int colourMode;

	[NonSerialized]
	public int volumeRange;

	[NonSerialized]
	public int speed;

	[NonSerialized]
	public int gradient;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AudioEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.colourMode = 0;
			instance.volumeRange = 0;
			instance.speed = 0;
			instance.gradient = 0;
			Pool.Free<AudioEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AudioEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AudioEntity instance)
	{
		instance.colourMode = colourMode;
		instance.volumeRange = volumeRange;
		instance.speed = speed;
		instance.gradient = gradient;
	}

	public AudioEntity Copy()
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		CopyTo(audioEntity);
		return audioEntity;
	}

	public static AudioEntity Deserialize(BufferStream stream)
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		Deserialize(stream, audioEntity, isDelta: false);
		return audioEntity;
	}

	public static AudioEntity DeserializeLengthDelimited(BufferStream stream)
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		DeserializeLengthDelimited(stream, audioEntity, isDelta: false);
		return audioEntity;
	}

	public static AudioEntity DeserializeLength(BufferStream stream, int length)
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		DeserializeLength(stream, length, audioEntity, isDelta: false);
		return audioEntity;
	}

	public static AudioEntity Deserialize(byte[] buffer)
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, audioEntity, isDelta: false);
		return audioEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AudioEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AudioEntity Deserialize(BufferStream stream, AudioEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.colourMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.volumeRange = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.speed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.gradient = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AudioEntity DeserializeLengthDelimited(BufferStream stream, AudioEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.colourMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.volumeRange = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.speed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.gradient = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AudioEntity DeserializeLength(BufferStream stream, int length, AudioEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.colourMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.volumeRange = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.speed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.gradient = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AudioEntity instance, AudioEntity previous)
	{
		if (instance.colourMode != previous.colourMode)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourMode);
		}
		if (instance.volumeRange != previous.volumeRange)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.volumeRange);
		}
		if (instance.speed != previous.speed)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.speed);
		}
		if (instance.gradient != previous.gradient)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gradient);
		}
	}

	public static void Serialize(BufferStream stream, AudioEntity instance)
	{
		if (instance.colourMode != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourMode);
		}
		if (instance.volumeRange != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.volumeRange);
		}
		if (instance.speed != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.speed);
		}
		if (instance.gradient != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gradient);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MicrophoneStand : IDisposable, IPooled, IProto<MicrophoneStand>, IProto
{
	[NonSerialized]
	public int microphoneMode;

	[NonSerialized]
	public NetworkableId IORef;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MicrophoneStand instance)
	{
		if (instance.ShouldPool)
		{
			instance.microphoneMode = 0;
			instance.IORef = default(NetworkableId);
			Pool.Free<MicrophoneStand>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MicrophoneStand with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MicrophoneStand instance)
	{
		instance.microphoneMode = microphoneMode;
		instance.IORef = IORef;
	}

	public MicrophoneStand Copy()
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		CopyTo(microphoneStand);
		return microphoneStand;
	}

	public static MicrophoneStand Deserialize(BufferStream stream)
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		Deserialize(stream, microphoneStand, isDelta: false);
		return microphoneStand;
	}

	public static MicrophoneStand DeserializeLengthDelimited(BufferStream stream)
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		DeserializeLengthDelimited(stream, microphoneStand, isDelta: false);
		return microphoneStand;
	}

	public static MicrophoneStand DeserializeLength(BufferStream stream, int length)
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		DeserializeLength(stream, length, microphoneStand, isDelta: false);
		return microphoneStand;
	}

	public static MicrophoneStand Deserialize(byte[] buffer)
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, microphoneStand, isDelta: false);
		return microphoneStand;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MicrophoneStand previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MicrophoneStand Deserialize(BufferStream stream, MicrophoneStand instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.microphoneMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.IORef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MicrophoneStand DeserializeLengthDelimited(BufferStream stream, MicrophoneStand instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.microphoneMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.IORef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MicrophoneStand DeserializeLength(BufferStream stream, int length, MicrophoneStand instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.microphoneMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.IORef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MicrophoneStand instance, MicrophoneStand previous)
	{
		if (instance.microphoneMode != previous.microphoneMode)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.microphoneMode);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.IORef.Value);
	}

	public static void Serialize(BufferStream stream, MicrophoneStand instance)
	{
		if (instance.microphoneMode != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.microphoneMode);
		}
		if (instance.IORef != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.IORef.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref IORef.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CommandBlock : IDisposable, IPooled, IProto<CommandBlock>, IProto
{
	[NonSerialized]
	public string currentCommand;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CommandBlock instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentCommand = string.Empty;
			Pool.Free<CommandBlock>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CommandBlock with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CommandBlock instance)
	{
		instance.currentCommand = currentCommand;
	}

	public CommandBlock Copy()
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		CopyTo(commandBlock);
		return commandBlock;
	}

	public static CommandBlock Deserialize(BufferStream stream)
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		Deserialize(stream, commandBlock, isDelta: false);
		return commandBlock;
	}

	public static CommandBlock DeserializeLengthDelimited(BufferStream stream)
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		DeserializeLengthDelimited(stream, commandBlock, isDelta: false);
		return commandBlock;
	}

	public static CommandBlock DeserializeLength(BufferStream stream, int length)
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		DeserializeLength(stream, length, commandBlock, isDelta: false);
		return commandBlock;
	}

	public static CommandBlock Deserialize(byte[] buffer)
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, commandBlock, isDelta: false);
		return commandBlock;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CommandBlock previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CommandBlock Deserialize(BufferStream stream, CommandBlock instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.currentCommand = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CommandBlock DeserializeLengthDelimited(BufferStream stream, CommandBlock instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.currentCommand = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CommandBlock DeserializeLength(BufferStream stream, int length, CommandBlock instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.currentCommand = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CommandBlock instance, CommandBlock previous)
	{
		if (instance.currentCommand != previous.currentCommand)
		{
			if (instance.currentCommand == null)
			{
				throw new ArgumentNullException("currentCommand", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.currentCommand);
		}
	}

	public static void Serialize(BufferStream stream, CommandBlock instance)
	{
		if (instance.currentCommand == null)
		{
			throw new ArgumentNullException("currentCommand", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.currentCommand);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Submarine : IDisposable, IPooled, IProto<Submarine>, IProto
{
	[NonSerialized]
	public float throttle;

	[NonSerialized]
	public float upDown;

	[NonSerialized]
	public float rudder;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelAmount;

	[NonSerialized]
	public NetworkableId torpedoStorageID;

	[NonSerialized]
	public float oxygen;

	[NonSerialized]
	public NetworkableId itemStorageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Submarine instance)
	{
		if (instance.ShouldPool)
		{
			instance.throttle = 0f;
			instance.upDown = 0f;
			instance.rudder = 0f;
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelAmount = 0f;
			instance.torpedoStorageID = default(NetworkableId);
			instance.oxygen = 0f;
			instance.itemStorageID = default(NetworkableId);
			Pool.Free<Submarine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Submarine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Submarine instance)
	{
		instance.throttle = throttle;
		instance.upDown = upDown;
		instance.rudder = rudder;
		instance.fuelStorageID = fuelStorageID;
		instance.fuelAmount = fuelAmount;
		instance.torpedoStorageID = torpedoStorageID;
		instance.oxygen = oxygen;
		instance.itemStorageID = itemStorageID;
	}

	public Submarine Copy()
	{
		Submarine submarine = Pool.Get<Submarine>();
		CopyTo(submarine);
		return submarine;
	}

	public static Submarine Deserialize(BufferStream stream)
	{
		Submarine submarine = Pool.Get<Submarine>();
		Deserialize(stream, submarine, isDelta: false);
		return submarine;
	}

	public static Submarine DeserializeLengthDelimited(BufferStream stream)
	{
		Submarine submarine = Pool.Get<Submarine>();
		DeserializeLengthDelimited(stream, submarine, isDelta: false);
		return submarine;
	}

	public static Submarine DeserializeLength(BufferStream stream, int length)
	{
		Submarine submarine = Pool.Get<Submarine>();
		DeserializeLength(stream, length, submarine, isDelta: false);
		return submarine;
	}

	public static Submarine Deserialize(byte[] buffer)
	{
		Submarine submarine = Pool.Get<Submarine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, submarine, isDelta: false);
		return submarine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Submarine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Submarine Deserialize(BufferStream stream, Submarine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.throttle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.upDown = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rudder = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.fuelAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.torpedoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 61:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Submarine DeserializeLengthDelimited(BufferStream stream, Submarine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.throttle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.upDown = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rudder = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.fuelAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.torpedoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 61:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Submarine DeserializeLength(BufferStream stream, int length, Submarine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.throttle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.upDown = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rudder = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.fuelAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.torpedoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 61:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Submarine instance, Submarine previous)
	{
		if (instance.throttle != previous.throttle)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.throttle);
		}
		if (instance.upDown != previous.upDown)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.upDown);
		}
		if (instance.rudder != previous.rudder)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.rudder);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelAmount != previous.fuelAmount)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.fuelAmount);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, instance.torpedoStorageID.Value);
		if (instance.oxygen != previous.oxygen)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.oxygen);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.itemStorageID.Value);
	}

	public static void Serialize(BufferStream stream, Submarine instance)
	{
		if (instance.throttle != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.throttle);
		}
		if (instance.upDown != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.upDown);
		}
		if (instance.rudder != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.rudder);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelAmount != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.fuelAmount);
		}
		if (instance.torpedoStorageID != default(NetworkableId))
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.torpedoStorageID.Value);
		}
		if (instance.oxygen != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.oxygen);
		}
		if (instance.itemStorageID != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.itemStorageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
		action(UidType.NetworkableId, ref torpedoStorageID.Value);
		action(UidType.NetworkableId, ref itemStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SleepingBagCamper : IDisposable, IPooled, IProto<SleepingBagCamper>, IProto
{
	[NonSerialized]
	public NetworkableId seatID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SleepingBagCamper instance)
	{
		if (instance.ShouldPool)
		{
			instance.seatID = default(NetworkableId);
			Pool.Free<SleepingBagCamper>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SleepingBagCamper with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SleepingBagCamper instance)
	{
		instance.seatID = seatID;
	}

	public SleepingBagCamper Copy()
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		CopyTo(sleepingBagCamper);
		return sleepingBagCamper;
	}

	public static SleepingBagCamper Deserialize(BufferStream stream)
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		Deserialize(stream, sleepingBagCamper, isDelta: false);
		return sleepingBagCamper;
	}

	public static SleepingBagCamper DeserializeLengthDelimited(BufferStream stream)
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		DeserializeLengthDelimited(stream, sleepingBagCamper, isDelta: false);
		return sleepingBagCamper;
	}

	public static SleepingBagCamper DeserializeLength(BufferStream stream, int length)
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		DeserializeLength(stream, length, sleepingBagCamper, isDelta: false);
		return sleepingBagCamper;
	}

	public static SleepingBagCamper Deserialize(byte[] buffer)
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sleepingBagCamper, isDelta: false);
		return sleepingBagCamper;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SleepingBagCamper previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SleepingBagCamper Deserialize(BufferStream stream, SleepingBagCamper instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.seatID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SleepingBagCamper DeserializeLengthDelimited(BufferStream stream, SleepingBagCamper instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seatID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SleepingBagCamper DeserializeLength(BufferStream stream, int length, SleepingBagCamper instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seatID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SleepingBagCamper instance, SleepingBagCamper previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.seatID.Value);
	}

	public static void Serialize(BufferStream stream, SleepingBagCamper instance)
	{
		if (instance.seatID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.seatID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref seatID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CamperModule : IDisposable, IPooled, IProto<CamperModule>, IProto
{
	[NonSerialized]
	public NetworkableId bbqId;

	[NonSerialized]
	public NetworkableId lockerId;

	[NonSerialized]
	public NetworkableId storageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CamperModule instance)
	{
		if (instance.ShouldPool)
		{
			instance.bbqId = default(NetworkableId);
			instance.lockerId = default(NetworkableId);
			instance.storageID = default(NetworkableId);
			Pool.Free<CamperModule>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CamperModule with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CamperModule instance)
	{
		instance.bbqId = bbqId;
		instance.lockerId = lockerId;
		instance.storageID = storageID;
	}

	public CamperModule Copy()
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		CopyTo(camperModule);
		return camperModule;
	}

	public static CamperModule Deserialize(BufferStream stream)
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		Deserialize(stream, camperModule, isDelta: false);
		return camperModule;
	}

	public static CamperModule DeserializeLengthDelimited(BufferStream stream)
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		DeserializeLengthDelimited(stream, camperModule, isDelta: false);
		return camperModule;
	}

	public static CamperModule DeserializeLength(BufferStream stream, int length)
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		DeserializeLength(stream, length, camperModule, isDelta: false);
		return camperModule;
	}

	public static CamperModule Deserialize(byte[] buffer)
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, camperModule, isDelta: false);
		return camperModule;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CamperModule previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CamperModule Deserialize(BufferStream stream, CamperModule instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.bbqId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.lockerId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CamperModule DeserializeLengthDelimited(BufferStream stream, CamperModule instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.bbqId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.lockerId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CamperModule DeserializeLength(BufferStream stream, int length, CamperModule instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.bbqId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.lockerId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CamperModule instance, CamperModule previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.bbqId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.lockerId.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
	}

	public static void Serialize(BufferStream stream, CamperModule instance)
	{
		if (instance.bbqId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.bbqId.Value);
		}
		if (instance.lockerId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.lockerId.Value);
		}
		if (instance.storageID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref bbqId.Value);
		action(UidType.NetworkableId, ref lockerId.Value);
		action(UidType.NetworkableId, ref storageID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PaintableSign : IDisposable, IPooled, IProto<PaintableSign>, IProto
{
	[NonSerialized]
	public List<uint> crcs;

	[NonSerialized]
	public List<ulong> editHistory;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PaintableSign instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.crcs != null)
			{
				List<uint> list = instance.crcs;
				Pool.FreeUnmanaged<uint>(ref list);
				instance.crcs = list;
			}
			if (instance.editHistory != null)
			{
				List<ulong> list2 = instance.editHistory;
				Pool.FreeUnmanaged<ulong>(ref list2);
				instance.editHistory = list2;
			}
			Pool.Free<PaintableSign>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PaintableSign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PaintableSign instance)
	{
		if (crcs != null)
		{
			instance.crcs = Pool.Get<List<uint>>();
			for (int i = 0; i < crcs.Count; i++)
			{
				uint item = crcs[i];
				instance.crcs.Add(item);
			}
		}
		else
		{
			instance.crcs = null;
		}
		if (editHistory != null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
			for (int j = 0; j < editHistory.Count; j++)
			{
				ulong item2 = editHistory[j];
				instance.editHistory.Add(item2);
			}
		}
		else
		{
			instance.editHistory = null;
		}
	}

	public PaintableSign Copy()
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		CopyTo(paintableSign);
		return paintableSign;
	}

	public static PaintableSign Deserialize(BufferStream stream)
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		Deserialize(stream, paintableSign, isDelta: false);
		return paintableSign;
	}

	public static PaintableSign DeserializeLengthDelimited(BufferStream stream)
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		DeserializeLengthDelimited(stream, paintableSign, isDelta: false);
		return paintableSign;
	}

	public static PaintableSign DeserializeLength(BufferStream stream, int length)
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		DeserializeLength(stream, length, paintableSign, isDelta: false);
		return paintableSign;
	}

	public static PaintableSign Deserialize(byte[] buffer)
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, paintableSign, isDelta: false);
		return paintableSign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PaintableSign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PaintableSign Deserialize(BufferStream stream, PaintableSign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.crcs == null)
			{
				instance.crcs = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.crcs.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PaintableSign DeserializeLengthDelimited(BufferStream stream, PaintableSign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.crcs == null)
			{
				instance.crcs = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.crcs.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PaintableSign DeserializeLength(BufferStream stream, int length, PaintableSign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.crcs == null)
			{
				instance.crcs = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.crcs.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PaintableSign instance, PaintableSign previous)
	{
		if (instance.crcs != null)
		{
			for (int i = 0; i < instance.crcs.Count; i++)
			{
				uint val = instance.crcs[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.editHistory != null)
		{
			for (int j = 0; j < instance.editHistory.Count; j++)
			{
				ulong val2 = instance.editHistory[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public static void Serialize(BufferStream stream, PaintableSign instance)
	{
		if (instance.crcs != null)
		{
			for (int i = 0; i < instance.crcs.Count; i++)
			{
				uint val = instance.crcs[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.editHistory != null)
		{
			for (int j = 0; j < instance.editHistory.Count; j++)
			{
				ulong val2 = instance.editHistory[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MLRS : IDisposable, IPooled, IProto<MLRS>, IProto
{
	[NonSerialized]
	public Vector3 targetPos;

	[NonSerialized]
	public Vector3 curHitPos;

	[NonSerialized]
	public NetworkableId rocketStorageID;

	[NonSerialized]
	public NetworkableId dashboardStorageID;

	[NonSerialized]
	public uint ammoCount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MLRS instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.targetPos = default(Vector3);
			instance.curHitPos = default(Vector3);
			instance.rocketStorageID = default(NetworkableId);
			instance.dashboardStorageID = default(NetworkableId);
			instance.ammoCount = 0u;
			Pool.Free<MLRS>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MLRS with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MLRS instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.targetPos = targetPos;
		instance.curHitPos = curHitPos;
		instance.rocketStorageID = rocketStorageID;
		instance.dashboardStorageID = dashboardStorageID;
		instance.ammoCount = ammoCount;
	}

	public MLRS Copy()
	{
		MLRS mLRS = Pool.Get<MLRS>();
		CopyTo(mLRS);
		return mLRS;
	}

	public static MLRS Deserialize(BufferStream stream)
	{
		MLRS mLRS = Pool.Get<MLRS>();
		Deserialize(stream, mLRS, isDelta: false);
		return mLRS;
	}

	public static MLRS DeserializeLengthDelimited(BufferStream stream)
	{
		MLRS mLRS = Pool.Get<MLRS>();
		DeserializeLengthDelimited(stream, mLRS, isDelta: false);
		return mLRS;
	}

	public static MLRS DeserializeLength(BufferStream stream, int length)
	{
		MLRS mLRS = Pool.Get<MLRS>();
		DeserializeLength(stream, length, mLRS, isDelta: false);
		return mLRS;
	}

	public static MLRS Deserialize(byte[] buffer)
	{
		MLRS mLRS = Pool.Get<MLRS>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mLRS, isDelta: false);
		return mLRS;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MLRS previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MLRS Deserialize(BufferStream stream, MLRS instance, bool isDelta)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curHitPos, isDelta);
				continue;
			case 32:
				instance.rocketStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.dashboardStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.ammoCount = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MLRS DeserializeLengthDelimited(BufferStream stream, MLRS instance, bool isDelta)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curHitPos, isDelta);
				continue;
			case 32:
				instance.rocketStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.dashboardStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.ammoCount = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MLRS DeserializeLength(BufferStream stream, int length, MLRS instance, bool isDelta)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curHitPos, isDelta);
				continue;
			case 32:
				instance.rocketStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.dashboardStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.ammoCount = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MLRS instance, MLRS previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (instance.targetPos != previous.targetPos)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.targetPos, previous.targetPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.curHitPos != previous.curHitPos)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.curHitPos, previous.curHitPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curHitPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.rocketStorageID.Value);
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.dashboardStorageID.Value);
		if (instance.ammoCount != previous.ammoCount)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.ammoCount);
		}
	}

	public static void Serialize(BufferStream stream, MLRS instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (instance.targetPos != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.targetPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.curHitPos != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.curHitPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curHitPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rocketStorageID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.rocketStorageID.Value);
		}
		if (instance.dashboardStorageID != default(NetworkableId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.dashboardStorageID.Value);
		}
		if (instance.ammoCount != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.ammoCount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref rocketStorageID.Value);
		action(UidType.NetworkableId, ref dashboardStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Snowmobile : IDisposable, IPooled, IProto<Snowmobile>, IProto
{
	[NonSerialized]
	public float steerInput;

	[NonSerialized]
	public float driveWheelVel;

	[NonSerialized]
	public float throttleInput;

	[NonSerialized]
	public float brakeInput;

	[NonSerialized]
	public NetworkableId storageID;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelFraction;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Snowmobile instance)
	{
		if (instance.ShouldPool)
		{
			instance.steerInput = 0f;
			instance.driveWheelVel = 0f;
			instance.throttleInput = 0f;
			instance.brakeInput = 0f;
			instance.storageID = default(NetworkableId);
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelFraction = 0f;
			Pool.Free<Snowmobile>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Snowmobile with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Snowmobile instance)
	{
		instance.steerInput = steerInput;
		instance.driveWheelVel = driveWheelVel;
		instance.throttleInput = throttleInput;
		instance.brakeInput = brakeInput;
		instance.storageID = storageID;
		instance.fuelStorageID = fuelStorageID;
		instance.fuelFraction = fuelFraction;
	}

	public Snowmobile Copy()
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		CopyTo(snowmobile);
		return snowmobile;
	}

	public static Snowmobile Deserialize(BufferStream stream)
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		Deserialize(stream, snowmobile, isDelta: false);
		return snowmobile;
	}

	public static Snowmobile DeserializeLengthDelimited(BufferStream stream)
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		DeserializeLengthDelimited(stream, snowmobile, isDelta: false);
		return snowmobile;
	}

	public static Snowmobile DeserializeLength(BufferStream stream, int length)
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		DeserializeLength(stream, length, snowmobile, isDelta: false);
		return snowmobile;
	}

	public static Snowmobile Deserialize(byte[] buffer)
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, snowmobile, isDelta: false);
		return snowmobile;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Snowmobile previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Snowmobile Deserialize(BufferStream stream, Snowmobile instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Snowmobile DeserializeLengthDelimited(BufferStream stream, Snowmobile instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Snowmobile DeserializeLength(BufferStream stream, int length, Snowmobile instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Snowmobile instance, Snowmobile previous)
	{
		if (instance.steerInput != previous.steerInput)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != previous.driveWheelVel)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != previous.throttleInput)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != previous.brakeInput)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
	}

	public static void Serialize(BufferStream stream, Snowmobile instance)
	{
		if (instance.steerInput != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.storageID != default(NetworkableId))
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref storageID.Value);
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


