using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NexusFerry : IDisposable, IPooled, IProto<NexusFerry>, IProto
{
	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public string ownerZone;

	[NonSerialized]
	public List<string> schedule;

	[NonSerialized]
	public int scheduleIndex;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public bool isRetiring;

	[NonSerialized]
	public List<NetworkableId> transferredIds;

	[NonSerialized]
	public int nextScheduleIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NexusFerry instance)
	{
		if (instance.ShouldPool)
		{
			instance.timestamp = 0L;
			instance.ownerZone = string.Empty;
			if (instance.schedule != null)
			{
				List<string> list = instance.schedule;
				Pool.FreeUnmanaged<string>(ref list);
				instance.schedule = list;
			}
			instance.scheduleIndex = 0;
			instance.state = 0;
			instance.isRetiring = false;
			if (instance.transferredIds != null)
			{
				List<NetworkableId> list2 = instance.transferredIds;
				Pool.FreeUnmanaged<NetworkableId>(ref list2);
				instance.transferredIds = list2;
			}
			instance.nextScheduleIndex = 0;
			Pool.Free<NexusFerry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NexusFerry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NexusFerry instance)
	{
		instance.timestamp = timestamp;
		instance.ownerZone = ownerZone;
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<string>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				string item = schedule[i];
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
		instance.scheduleIndex = scheduleIndex;
		instance.state = state;
		instance.isRetiring = isRetiring;
		if (transferredIds != null)
		{
			instance.transferredIds = Pool.Get<List<NetworkableId>>();
			for (int j = 0; j < transferredIds.Count; j++)
			{
				NetworkableId item2 = transferredIds[j];
				instance.transferredIds.Add(item2);
			}
		}
		else
		{
			instance.transferredIds = null;
		}
		instance.nextScheduleIndex = nextScheduleIndex;
	}

	public NexusFerry Copy()
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		CopyTo(nexusFerry);
		return nexusFerry;
	}

	public static NexusFerry Deserialize(BufferStream stream)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		Deserialize(stream, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public static NexusFerry DeserializeLengthDelimited(BufferStream stream)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		DeserializeLengthDelimited(stream, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public static NexusFerry DeserializeLength(BufferStream stream, int length)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		DeserializeLength(stream, length, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public static NexusFerry Deserialize(byte[] buffer)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NexusFerry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NexusFerry Deserialize(BufferStream stream, NexusFerry instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.schedule == null)
			{
				instance.schedule = Pool.Get<List<string>>();
			}
			if (instance.transferredIds == null)
			{
				instance.transferredIds = Pool.Get<List<NetworkableId>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 32:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.transferredIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case 64:
				instance.nextScheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NexusFerry DeserializeLengthDelimited(BufferStream stream, NexusFerry instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.schedule == null)
			{
				instance.schedule = Pool.Get<List<string>>();
			}
			if (instance.transferredIds == null)
			{
				instance.transferredIds = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 32:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.transferredIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case 64:
				instance.nextScheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NexusFerry DeserializeLength(BufferStream stream, int length, NexusFerry instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.schedule == null)
			{
				instance.schedule = Pool.Get<List<string>>();
			}
			if (instance.transferredIds == null)
			{
				instance.transferredIds = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 32:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.transferredIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case 64:
				instance.nextScheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NexusFerry instance, NexusFerry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.ownerZone != null && instance.ownerZone != previous.ownerZone)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.ownerZone);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != previous.scheduleIndex)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.isRetiring);
		if (instance.transferredIds != null)
		{
			for (int j = 0; j < instance.transferredIds.Count; j++)
			{
				NetworkableId networkableId = instance.transferredIds[j];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
		if (instance.nextScheduleIndex != previous.nextScheduleIndex)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextScheduleIndex);
		}
	}

	public static void Serialize(BufferStream stream, NexusFerry instance)
	{
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.ownerZone != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.ownerZone);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.isRetiring)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.isRetiring);
		}
		if (instance.transferredIds != null)
		{
			for (int j = 0; j < instance.transferredIds.Count; j++)
			{
				NetworkableId networkableId = instance.transferredIds[j];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
		if (instance.nextScheduleIndex != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextScheduleIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < transferredIds.Count; i++)
		{
			NetworkableId value = transferredIds[i];
			action(UidType.NetworkableId, ref value.Value);
			transferredIds[i] = value;
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NexusIsland : IDisposable, IPooled, IProto<NexusIsland>, IProto
{
	[NonSerialized]
	public string zoneKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NexusIsland instance)
	{
		if (instance.ShouldPool)
		{
			instance.zoneKey = string.Empty;
			Pool.Free<NexusIsland>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NexusIsland with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NexusIsland instance)
	{
		instance.zoneKey = zoneKey;
	}

	public NexusIsland Copy()
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		CopyTo(nexusIsland);
		return nexusIsland;
	}

	public static NexusIsland Deserialize(BufferStream stream)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		Deserialize(stream, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public static NexusIsland DeserializeLengthDelimited(BufferStream stream)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		DeserializeLengthDelimited(stream, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public static NexusIsland DeserializeLength(BufferStream stream, int length)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		DeserializeLength(stream, length, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public static NexusIsland Deserialize(byte[] buffer)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NexusIsland previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NexusIsland Deserialize(BufferStream stream, NexusIsland instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.zoneKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NexusIsland DeserializeLengthDelimited(BufferStream stream, NexusIsland instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.zoneKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NexusIsland DeserializeLength(BufferStream stream, int length, NexusIsland instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.zoneKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NexusIsland instance, NexusIsland previous)
	{
		if (instance.zoneKey != null && instance.zoneKey != previous.zoneKey)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.zoneKey);
		}
	}

	public static void Serialize(BufferStream stream, NexusIsland instance)
	{
		if (instance.zoneKey != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.zoneKey);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NexusDockTerminal : IDisposable, IPooled, IProto<NexusDockTerminal>, IProto
{
	public class ScheduleEntry : IDisposable, IPooled, IProto<ScheduleEntry>, IProto
	{
		[NonSerialized]
		public int nextZoneId;

		[NonSerialized]
		public int estimate;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ScheduleEntry instance)
		{
			if (instance.ShouldPool)
			{
				instance.nextZoneId = 0;
				instance.estimate = 0;
				Pool.Free<ScheduleEntry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ScheduleEntry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ScheduleEntry instance)
		{
			instance.nextZoneId = nextZoneId;
			instance.estimate = estimate;
		}

		public ScheduleEntry Copy()
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			CopyTo(scheduleEntry);
			return scheduleEntry;
		}

		public static ScheduleEntry Deserialize(BufferStream stream)
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			Deserialize(stream, scheduleEntry, isDelta: false);
			return scheduleEntry;
		}

		public static ScheduleEntry DeserializeLengthDelimited(BufferStream stream)
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			DeserializeLengthDelimited(stream, scheduleEntry, isDelta: false);
			return scheduleEntry;
		}

		public static ScheduleEntry DeserializeLength(BufferStream stream, int length)
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			DeserializeLength(stream, length, scheduleEntry, isDelta: false);
			return scheduleEntry;
		}

		public static ScheduleEntry Deserialize(byte[] buffer)
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, scheduleEntry, isDelta: false);
			return scheduleEntry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ScheduleEntry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ScheduleEntry Deserialize(BufferStream stream, ScheduleEntry instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ScheduleEntry DeserializeLengthDelimited(BufferStream stream, ScheduleEntry instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ScheduleEntry DeserializeLength(BufferStream stream, int length, ScheduleEntry instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ScheduleEntry instance, ScheduleEntry previous)
		{
			if (instance.nextZoneId != previous.nextZoneId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.nextZoneId);
			}
			if (instance.estimate != previous.estimate)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.estimate);
			}
		}

		public static void Serialize(BufferStream stream, ScheduleEntry instance)
		{
			if (instance.nextZoneId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.nextZoneId);
			}
			if (instance.estimate != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.estimate);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<ScheduleEntry> schedule;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NexusDockTerminal instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				if (instance.schedule[i] != null)
				{
					instance.schedule[i].ResetToPool();
					instance.schedule[i] = null;
				}
			}
			List<ScheduleEntry> list = instance.schedule;
			Pool.Free<ScheduleEntry>(ref list, false);
			instance.schedule = list;
		}
		Pool.Free<NexusDockTerminal>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NexusDockTerminal with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NexusDockTerminal instance)
	{
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<ScheduleEntry>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				ScheduleEntry item = schedule[i].Copy();
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
	}

	public NexusDockTerminal Copy()
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		CopyTo(nexusDockTerminal);
		return nexusDockTerminal;
	}

	public static NexusDockTerminal Deserialize(BufferStream stream)
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		Deserialize(stream, nexusDockTerminal, isDelta: false);
		return nexusDockTerminal;
	}

	public static NexusDockTerminal DeserializeLengthDelimited(BufferStream stream)
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		DeserializeLengthDelimited(stream, nexusDockTerminal, isDelta: false);
		return nexusDockTerminal;
	}

	public static NexusDockTerminal DeserializeLength(BufferStream stream, int length)
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		DeserializeLength(stream, length, nexusDockTerminal, isDelta: false);
		return nexusDockTerminal;
	}

	public static NexusDockTerminal Deserialize(byte[] buffer)
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nexusDockTerminal, isDelta: false);
		return nexusDockTerminal;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NexusDockTerminal previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NexusDockTerminal Deserialize(BufferStream stream, NexusDockTerminal instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<ScheduleEntry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.schedule.Add(ScheduleEntry.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NexusDockTerminal DeserializeLengthDelimited(BufferStream stream, NexusDockTerminal instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<ScheduleEntry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.schedule.Add(ScheduleEntry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NexusDockTerminal DeserializeLength(BufferStream stream, int length, NexusDockTerminal instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<ScheduleEntry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.schedule.Add(ScheduleEntry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NexusDockTerminal instance, NexusDockTerminal previous)
	{
		if (instance.schedule == null)
		{
			return;
		}
		for (int i = 0; i < instance.schedule.Count; i++)
		{
			ScheduleEntry scheduleEntry = instance.schedule[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ScheduleEntry.SerializeDelta(stream, scheduleEntry, scheduleEntry);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field schedule (ProtoBuf.NexusDockTerminal.ScheduleEntry)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, NexusDockTerminal instance)
	{
		if (instance.schedule == null)
		{
			return;
		}
		for (int i = 0; i < instance.schedule.Count; i++)
		{
			ScheduleEntry instance2 = instance.schedule[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ScheduleEntry.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field schedule (ProtoBuf.NexusDockTerminal.ScheduleEntry)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (schedule != null)
		{
			for (int i = 0; i < schedule.Count; i++)
			{
				schedule[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseBoat : IDisposable, IPooled, IProto<BaseBoat>, IProto
{
	[NonSerialized]
	public float shoreDriftTimerValue;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseBoat instance)
	{
		if (instance.ShouldPool)
		{
			instance.shoreDriftTimerValue = 0f;
			Pool.Free<BaseBoat>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseBoat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseBoat instance)
	{
		instance.shoreDriftTimerValue = shoreDriftTimerValue;
	}

	public BaseBoat Copy()
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		CopyTo(baseBoat);
		return baseBoat;
	}

	public static BaseBoat Deserialize(BufferStream stream)
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		Deserialize(stream, baseBoat, isDelta: false);
		return baseBoat;
	}

	public static BaseBoat DeserializeLengthDelimited(BufferStream stream)
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		DeserializeLengthDelimited(stream, baseBoat, isDelta: false);
		return baseBoat;
	}

	public static BaseBoat DeserializeLength(BufferStream stream, int length)
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		DeserializeLength(stream, length, baseBoat, isDelta: false);
		return baseBoat;
	}

	public static BaseBoat Deserialize(byte[] buffer)
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseBoat, isDelta: false);
		return baseBoat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseBoat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseBoat Deserialize(BufferStream stream, BaseBoat instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.shoreDriftTimerValue = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseBoat DeserializeLengthDelimited(BufferStream stream, BaseBoat instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.shoreDriftTimerValue = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseBoat DeserializeLength(BufferStream stream, int length, BaseBoat instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.shoreDriftTimerValue = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseBoat instance, BaseBoat previous)
	{
		if (instance.shoreDriftTimerValue != previous.shoreDriftTimerValue)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.shoreDriftTimerValue);
		}
	}

	public static void Serialize(BufferStream stream, BaseBoat instance)
	{
		if (instance.shoreDriftTimerValue != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.shoreDriftTimerValue);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DieselEngine : IDisposable, IPooled, IProto<DieselEngine>, IProto
{
	[NonSerialized]
	public float fuelTime;

	[NonSerialized]
	public ulong startedByPlayer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DieselEngine instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelTime = 0f;
			instance.startedByPlayer = 0uL;
			Pool.Free<DieselEngine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DieselEngine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DieselEngine instance)
	{
		instance.fuelTime = fuelTime;
		instance.startedByPlayer = startedByPlayer;
	}

	public DieselEngine Copy()
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		CopyTo(dieselEngine);
		return dieselEngine;
	}

	public static DieselEngine Deserialize(BufferStream stream)
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		Deserialize(stream, dieselEngine, isDelta: false);
		return dieselEngine;
	}

	public static DieselEngine DeserializeLengthDelimited(BufferStream stream)
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		DeserializeLengthDelimited(stream, dieselEngine, isDelta: false);
		return dieselEngine;
	}

	public static DieselEngine DeserializeLength(BufferStream stream, int length)
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		DeserializeLength(stream, length, dieselEngine, isDelta: false);
		return dieselEngine;
	}

	public static DieselEngine Deserialize(byte[] buffer)
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, dieselEngine, isDelta: false);
		return dieselEngine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DieselEngine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DieselEngine Deserialize(BufferStream stream, DieselEngine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.fuelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.startedByPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DieselEngine DeserializeLengthDelimited(BufferStream stream, DieselEngine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fuelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.startedByPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DieselEngine DeserializeLength(BufferStream stream, int length, DieselEngine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fuelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.startedByPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DieselEngine instance, DieselEngine previous)
	{
		if (instance.fuelTime != previous.fuelTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fuelTime);
		}
		if (instance.startedByPlayer != previous.startedByPlayer)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.startedByPlayer);
		}
	}

	public static void Serialize(BufferStream stream, DieselEngine instance)
	{
		if (instance.fuelTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fuelTime);
		}
		if (instance.startedByPlayer != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.startedByPlayer);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class RockingChair : IDisposable, IPooled, IProto<RockingChair>, IProto
{
	[NonSerialized]
	public Vector3 initEuler;

	[NonSerialized]
	public float initY;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RockingChair instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.initEuler = default(Vector3);
			instance.initY = 0f;
			Pool.Free<RockingChair>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RockingChair with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RockingChair instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.initEuler = initEuler;
		instance.initY = initY;
	}

	public RockingChair Copy()
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		CopyTo(rockingChair);
		return rockingChair;
	}

	public static RockingChair Deserialize(BufferStream stream)
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		Deserialize(stream, rockingChair, isDelta: false);
		return rockingChair;
	}

	public static RockingChair DeserializeLengthDelimited(BufferStream stream)
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		DeserializeLengthDelimited(stream, rockingChair, isDelta: false);
		return rockingChair;
	}

	public static RockingChair DeserializeLength(BufferStream stream, int length)
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		DeserializeLength(stream, length, rockingChair, isDelta: false);
		return rockingChair;
	}

	public static RockingChair Deserialize(byte[] buffer)
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, rockingChair, isDelta: false);
		return rockingChair;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RockingChair previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RockingChair Deserialize(BufferStream stream, RockingChair instance, bool isDelta)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.initEuler, isDelta);
				continue;
			case 21:
				instance.initY = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RockingChair DeserializeLengthDelimited(BufferStream stream, RockingChair instance, bool isDelta)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.initEuler, isDelta);
				continue;
			case 21:
				instance.initY = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RockingChair DeserializeLength(BufferStream stream, int length, RockingChair instance, bool isDelta)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.initEuler, isDelta);
				continue;
			case 21:
				instance.initY = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RockingChair instance, RockingChair previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.initEuler != previous.initEuler)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.initEuler, previous.initEuler);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field initEuler (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.initY != previous.initY)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.initY);
		}
	}

	public static void Serialize(BufferStream stream, RockingChair instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.initEuler != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.initEuler);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field initEuler (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.initY != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.initY);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class HeadData : IDisposable, IPooled, IProto<HeadData>, IProto
{
	[NonSerialized]
	public uint entitySource;

	[NonSerialized]
	public string playerName;

	[NonSerialized]
	public ulong playerId;

	[NonSerialized]
	public List<int> clothing;

	[NonSerialized]
	public uint count;

	[NonSerialized]
	public int horseBreed;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(HeadData instance)
	{
		if (instance.ShouldPool)
		{
			instance.entitySource = 0u;
			instance.playerName = string.Empty;
			instance.playerId = 0uL;
			if (instance.clothing != null)
			{
				List<int> list = instance.clothing;
				Pool.FreeUnmanaged<int>(ref list);
				instance.clothing = list;
			}
			instance.count = 0u;
			instance.horseBreed = 0;
			Pool.Free<HeadData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose HeadData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(HeadData instance)
	{
		instance.entitySource = entitySource;
		instance.playerName = playerName;
		instance.playerId = playerId;
		if (clothing != null)
		{
			instance.clothing = Pool.Get<List<int>>();
			for (int i = 0; i < clothing.Count; i++)
			{
				int item = clothing[i];
				instance.clothing.Add(item);
			}
		}
		else
		{
			instance.clothing = null;
		}
		instance.count = count;
		instance.horseBreed = horseBreed;
	}

	public HeadData Copy()
	{
		HeadData headData = Pool.Get<HeadData>();
		CopyTo(headData);
		return headData;
	}

	public static HeadData Deserialize(BufferStream stream)
	{
		HeadData headData = Pool.Get<HeadData>();
		Deserialize(stream, headData, isDelta: false);
		return headData;
	}

	public static HeadData DeserializeLengthDelimited(BufferStream stream)
	{
		HeadData headData = Pool.Get<HeadData>();
		DeserializeLengthDelimited(stream, headData, isDelta: false);
		return headData;
	}

	public static HeadData DeserializeLength(BufferStream stream, int length)
	{
		HeadData headData = Pool.Get<HeadData>();
		DeserializeLength(stream, length, headData, isDelta: false);
		return headData;
	}

	public static HeadData Deserialize(byte[] buffer)
	{
		HeadData headData = Pool.Get<HeadData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, headData, isDelta: false);
		return headData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, HeadData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static HeadData Deserialize(BufferStream stream, HeadData instance, bool isDelta)
	{
		if (!isDelta && instance.clothing == null)
		{
			instance.clothing = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entitySource = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.clothing.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.count = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.horseBreed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static HeadData DeserializeLengthDelimited(BufferStream stream, HeadData instance, bool isDelta)
	{
		if (!isDelta && instance.clothing == null)
		{
			instance.clothing = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entitySource = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.clothing.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.count = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.horseBreed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static HeadData DeserializeLength(BufferStream stream, int length, HeadData instance, bool isDelta)
	{
		if (!isDelta && instance.clothing == null)
		{
			instance.clothing = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entitySource = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.clothing.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.count = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.horseBreed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, HeadData instance, HeadData previous)
	{
		if (instance.entitySource != previous.entitySource)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.entitySource);
		}
		if (instance.playerName != null && instance.playerName != previous.playerName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.playerId != previous.playerId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.clothing != null)
		{
			for (int i = 0; i < instance.clothing.Count; i++)
			{
				int num = instance.clothing[i];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.count != previous.count)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.count);
		}
		if (instance.horseBreed != previous.horseBreed)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.horseBreed);
		}
	}

	public static void Serialize(BufferStream stream, HeadData instance)
	{
		if (instance.entitySource != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.entitySource);
		}
		if (instance.playerName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.playerId != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.clothing != null)
		{
			for (int i = 0; i < instance.clothing.Count; i++)
			{
				int num = instance.clothing[i];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.count != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.count);
		}
		if (instance.horseBreed != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.horseBreed);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WantedPoster : IDisposable, IPooled, IProto<WantedPoster>, IProto
{
	[NonSerialized]
	public uint imageCrc;

	[NonSerialized]
	public string playerName;

	[NonSerialized]
	public ulong playerId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WantedPoster instance)
	{
		if (instance.ShouldPool)
		{
			instance.imageCrc = 0u;
			instance.playerName = string.Empty;
			instance.playerId = 0uL;
			Pool.Free<WantedPoster>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WantedPoster with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WantedPoster instance)
	{
		instance.imageCrc = imageCrc;
		instance.playerName = playerName;
		instance.playerId = playerId;
	}

	public WantedPoster Copy()
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		CopyTo(wantedPoster);
		return wantedPoster;
	}

	public static WantedPoster Deserialize(BufferStream stream)
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		Deserialize(stream, wantedPoster, isDelta: false);
		return wantedPoster;
	}

	public static WantedPoster DeserializeLengthDelimited(BufferStream stream)
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		DeserializeLengthDelimited(stream, wantedPoster, isDelta: false);
		return wantedPoster;
	}

	public static WantedPoster DeserializeLength(BufferStream stream, int length)
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		DeserializeLength(stream, length, wantedPoster, isDelta: false);
		return wantedPoster;
	}

	public static WantedPoster Deserialize(byte[] buffer)
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wantedPoster, isDelta: false);
		return wantedPoster;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WantedPoster previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WantedPoster Deserialize(BufferStream stream, WantedPoster instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WantedPoster DeserializeLengthDelimited(BufferStream stream, WantedPoster instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WantedPoster DeserializeLength(BufferStream stream, int length, WantedPoster instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WantedPoster instance, WantedPoster previous)
	{
		if (instance.imageCrc != previous.imageCrc)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
		if (instance.playerName != null && instance.playerName != previous.playerName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.playerId != previous.playerId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
	}

	public static void Serialize(BufferStream stream, WantedPoster instance)
	{
		if (instance.imageCrc != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
		if (instance.playerName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.playerId != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class WaypointRace : IDisposable, IPooled, IProto<WaypointRace>, IProto
{
	[NonSerialized]
	public List<Vector3> positions;

	[NonSerialized]
	public NetworkableId racingVehicle;

	[NonSerialized]
	public int currentWaypoint;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WaypointRace instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.positions != null)
			{
				List<Vector3> list = instance.positions;
				Pool.FreeUnmanaged<Vector3>(ref list);
				instance.positions = list;
			}
			instance.racingVehicle = default(NetworkableId);
			instance.currentWaypoint = 0;
			Pool.Free<WaypointRace>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WaypointRace with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WaypointRace instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (positions != null)
		{
			instance.positions = Pool.Get<List<Vector3>>();
			for (int i = 0; i < positions.Count; i++)
			{
				Vector3 item = positions[i];
				instance.positions.Add(item);
			}
		}
		else
		{
			instance.positions = null;
		}
		instance.racingVehicle = racingVehicle;
		instance.currentWaypoint = currentWaypoint;
	}

	public WaypointRace Copy()
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		CopyTo(waypointRace);
		return waypointRace;
	}

	public static WaypointRace Deserialize(BufferStream stream)
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		Deserialize(stream, waypointRace, isDelta: false);
		return waypointRace;
	}

	public static WaypointRace DeserializeLengthDelimited(BufferStream stream)
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		DeserializeLengthDelimited(stream, waypointRace, isDelta: false);
		return waypointRace;
	}

	public static WaypointRace DeserializeLength(BufferStream stream, int length)
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		DeserializeLength(stream, length, waypointRace, isDelta: false);
		return waypointRace;
	}

	public static WaypointRace Deserialize(byte[] buffer)
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, waypointRace, isDelta: false);
		return waypointRace;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WaypointRace previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WaypointRace Deserialize(BufferStream stream, WaypointRace instance, bool isDelta)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.positions == null)
		{
			instance.positions = Pool.Get<List<Vector3>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.positions.Add(instance2);
				break;
			}
			case 16:
				instance.racingVehicle = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 24:
				instance.currentWaypoint = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static WaypointRace DeserializeLengthDelimited(BufferStream stream, WaypointRace instance, bool isDelta)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.positions == null)
		{
			instance.positions = Pool.Get<List<Vector3>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.positions.Add(instance2);
				break;
			}
			case 16:
				instance.racingVehicle = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 24:
				instance.currentWaypoint = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WaypointRace DeserializeLength(BufferStream stream, int length, WaypointRace instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.positions == null)
		{
			instance.positions = Pool.Get<List<Vector3>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.positions.Add(instance2);
				break;
			}
			case 16:
				instance.racingVehicle = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 24:
				instance.currentWaypoint = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WaypointRace instance, WaypointRace previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.positions != null)
		{
			for (int i = 0; i < instance.positions.Count; i++)
			{
				Vector3 val = instance.positions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field positions (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.racingVehicle.Value);
		if (instance.currentWaypoint != previous.currentWaypoint)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentWaypoint);
		}
	}

	public static void Serialize(BufferStream stream, WaypointRace instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.positions != null)
		{
			for (int i = 0; i < instance.positions.Count; i++)
			{
				Vector3 instance2 = instance.positions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field positions (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.racingVehicle != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.racingVehicle.Value);
		}
		if (instance.currentWaypoint != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentWaypoint);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref racingVehicle.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Ragdoll : IDisposable, IPooled, IProto<Ragdoll>, IProto
{
	[NonSerialized]
	public float time;

	[NonSerialized]
	public List<int> positions;

	[NonSerialized]
	public List<int> rotations;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Ragdoll instance)
	{
		if (instance.ShouldPool)
		{
			instance.time = 0f;
			if (instance.positions != null)
			{
				List<int> list = instance.positions;
				Pool.FreeUnmanaged<int>(ref list);
				instance.positions = list;
			}
			if (instance.rotations != null)
			{
				List<int> list2 = instance.rotations;
				Pool.FreeUnmanaged<int>(ref list2);
				instance.rotations = list2;
			}
			Pool.Free<Ragdoll>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Ragdoll with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Ragdoll instance)
	{
		instance.time = time;
		if (positions != null)
		{
			instance.positions = Pool.Get<List<int>>();
			for (int i = 0; i < positions.Count; i++)
			{
				int item = positions[i];
				instance.positions.Add(item);
			}
		}
		else
		{
			instance.positions = null;
		}
		if (rotations != null)
		{
			instance.rotations = Pool.Get<List<int>>();
			for (int j = 0; j < rotations.Count; j++)
			{
				int item2 = rotations[j];
				instance.rotations.Add(item2);
			}
		}
		else
		{
			instance.rotations = null;
		}
	}

	public Ragdoll Copy()
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		CopyTo(ragdoll);
		return ragdoll;
	}

	public static Ragdoll Deserialize(BufferStream stream)
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		Deserialize(stream, ragdoll, isDelta: false);
		return ragdoll;
	}

	public static Ragdoll DeserializeLengthDelimited(BufferStream stream)
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		DeserializeLengthDelimited(stream, ragdoll, isDelta: false);
		return ragdoll;
	}

	public static Ragdoll DeserializeLength(BufferStream stream, int length)
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		DeserializeLength(stream, length, ragdoll, isDelta: false);
		return ragdoll;
	}

	public static Ragdoll Deserialize(byte[] buffer)
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ragdoll, isDelta: false);
		return ragdoll;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Ragdoll previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Ragdoll Deserialize(BufferStream stream, Ragdoll instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.positions == null)
			{
				instance.positions = Pool.Get<List<int>>();
			}
			if (instance.rotations == null)
			{
				instance.rotations = Pool.Get<List<int>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.positions.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.rotations.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Ragdoll DeserializeLengthDelimited(BufferStream stream, Ragdoll instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.positions == null)
			{
				instance.positions = Pool.Get<List<int>>();
			}
			if (instance.rotations == null)
			{
				instance.rotations = Pool.Get<List<int>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.positions.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.rotations.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Ragdoll DeserializeLength(BufferStream stream, int length, Ragdoll instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.positions == null)
			{
				instance.positions = Pool.Get<List<int>>();
			}
			if (instance.rotations == null)
			{
				instance.rotations = Pool.Get<List<int>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.positions.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.rotations.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Ragdoll instance, Ragdoll previous)
	{
		if (instance.time != previous.time)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.positions != null)
		{
			for (int i = 0; i < instance.positions.Count; i++)
			{
				int num = instance.positions[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.rotations != null)
		{
			for (int j = 0; j < instance.rotations.Count; j++)
			{
				int num2 = instance.rotations[j];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
	}

	public static void Serialize(BufferStream stream, Ragdoll instance)
	{
		if (instance.time != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.positions != null)
		{
			for (int i = 0; i < instance.positions.Count; i++)
			{
				int num = instance.positions[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.rotations != null)
		{
			for (int j = 0; j < instance.rotations.Count; j++)
			{
				int num2 = instance.rotations[j];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class LegacyShelter : IDisposable, IPooled, IProto<LegacyShelter>, IProto
{
	[NonSerialized]
	public NetworkableId doorID;

	[NonSerialized]
	public float timeSinceInteracted;

	[NonSerialized]
	public ulong ownerId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LegacyShelter instance)
	{
		if (instance.ShouldPool)
		{
			instance.doorID = default(NetworkableId);
			instance.timeSinceInteracted = 0f;
			instance.ownerId = 0uL;
			Pool.Free<LegacyShelter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LegacyShelter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LegacyShelter instance)
	{
		instance.doorID = doorID;
		instance.timeSinceInteracted = timeSinceInteracted;
		instance.ownerId = ownerId;
	}

	public LegacyShelter Copy()
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		CopyTo(legacyShelter);
		return legacyShelter;
	}

	public static LegacyShelter Deserialize(BufferStream stream)
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		Deserialize(stream, legacyShelter, isDelta: false);
		return legacyShelter;
	}

	public static LegacyShelter DeserializeLengthDelimited(BufferStream stream)
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		DeserializeLengthDelimited(stream, legacyShelter, isDelta: false);
		return legacyShelter;
	}

	public static LegacyShelter DeserializeLength(BufferStream stream, int length)
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		DeserializeLength(stream, length, legacyShelter, isDelta: false);
		return legacyShelter;
	}

	public static LegacyShelter Deserialize(byte[] buffer)
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, legacyShelter, isDelta: false);
		return legacyShelter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LegacyShelter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LegacyShelter Deserialize(BufferStream stream, LegacyShelter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeSinceInteracted = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ownerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LegacyShelter DeserializeLengthDelimited(BufferStream stream, LegacyShelter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeSinceInteracted = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ownerId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LegacyShelter DeserializeLength(BufferStream stream, int length, LegacyShelter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeSinceInteracted = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ownerId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LegacyShelter instance, LegacyShelter previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.doorID.Value);
		if (instance.timeSinceInteracted != previous.timeSinceInteracted)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeSinceInteracted);
		}
		if (instance.ownerId != previous.ownerId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.ownerId);
		}
	}

	public static void Serialize(BufferStream stream, LegacyShelter instance)
	{
		if (instance.doorID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.doorID.Value);
		}
		if (instance.timeSinceInteracted != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeSinceInteracted);
		}
		if (instance.ownerId != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.ownerId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref doorID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MetalDetectorSource : IDisposable, IPooled, IProto<MetalDetectorSource>, IProto
{
	[NonSerialized]
	public List<Vector3> spawnLocations;

	[NonSerialized]
	public float spawnRadius;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MetalDetectorSource instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.spawnLocations != null)
			{
				List<Vector3> list = instance.spawnLocations;
				Pool.FreeUnmanaged<Vector3>(ref list);
				instance.spawnLocations = list;
			}
			instance.spawnRadius = 0f;
			Pool.Free<MetalDetectorSource>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MetalDetectorSource with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MetalDetectorSource instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (spawnLocations != null)
		{
			instance.spawnLocations = Pool.Get<List<Vector3>>();
			for (int i = 0; i < spawnLocations.Count; i++)
			{
				Vector3 item = spawnLocations[i];
				instance.spawnLocations.Add(item);
			}
		}
		else
		{
			instance.spawnLocations = null;
		}
		instance.spawnRadius = spawnRadius;
	}

	public MetalDetectorSource Copy()
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		CopyTo(metalDetectorSource);
		return metalDetectorSource;
	}

	public static MetalDetectorSource Deserialize(BufferStream stream)
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		Deserialize(stream, metalDetectorSource, isDelta: false);
		return metalDetectorSource;
	}

	public static MetalDetectorSource DeserializeLengthDelimited(BufferStream stream)
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		DeserializeLengthDelimited(stream, metalDetectorSource, isDelta: false);
		return metalDetectorSource;
	}

	public static MetalDetectorSource DeserializeLength(BufferStream stream, int length)
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		DeserializeLength(stream, length, metalDetectorSource, isDelta: false);
		return metalDetectorSource;
	}

	public static MetalDetectorSource Deserialize(byte[] buffer)
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, metalDetectorSource, isDelta: false);
		return metalDetectorSource;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MetalDetectorSource previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MetalDetectorSource Deserialize(BufferStream stream, MetalDetectorSource instance, bool isDelta)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.spawnLocations == null)
		{
			instance.spawnLocations = Pool.Get<List<Vector3>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.spawnLocations.Add(instance2);
				break;
			}
			case 21:
				instance.spawnRadius = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static MetalDetectorSource DeserializeLengthDelimited(BufferStream stream, MetalDetectorSource instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.spawnLocations == null)
		{
			instance.spawnLocations = Pool.Get<List<Vector3>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.spawnLocations.Add(instance2);
				break;
			}
			case 21:
				instance.spawnRadius = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MetalDetectorSource DeserializeLength(BufferStream stream, int length, MetalDetectorSource instance, bool isDelta)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.spawnLocations == null)
		{
			instance.spawnLocations = Pool.Get<List<Vector3>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.spawnLocations.Add(instance2);
				break;
			}
			case 21:
				instance.spawnRadius = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MetalDetectorSource instance, MetalDetectorSource previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spawnLocations != null)
		{
			for (int i = 0; i < instance.spawnLocations.Count; i++)
			{
				Vector3 val = instance.spawnLocations[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spawnLocations (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.spawnRadius != previous.spawnRadius)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.spawnRadius);
		}
	}

	public static void Serialize(BufferStream stream, MetalDetectorSource instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spawnLocations != null)
		{
			for (int i = 0; i < instance.spawnLocations.Count; i++)
			{
				Vector3 instance2 = instance.spawnLocations[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spawnLocations (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.spawnRadius != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.spawnRadius);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TutorialIsland : IDisposable, IPooled, IProto<TutorialIsland>, IProto
{
	[NonSerialized]
	public NetworkableId targetPlayer;

	[NonSerialized]
	public float disconnectDuration;

	[NonSerialized]
	public int spawnLocationIndex;

	[NonSerialized]
	public float tutorialDuration;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TutorialIsland instance)
	{
		if (instance.ShouldPool)
		{
			instance.targetPlayer = default(NetworkableId);
			instance.disconnectDuration = 0f;
			instance.spawnLocationIndex = 0;
			instance.tutorialDuration = 0f;
			Pool.Free<TutorialIsland>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TutorialIsland with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TutorialIsland instance)
	{
		instance.targetPlayer = targetPlayer;
		instance.disconnectDuration = disconnectDuration;
		instance.spawnLocationIndex = spawnLocationIndex;
		instance.tutorialDuration = tutorialDuration;
	}

	public TutorialIsland Copy()
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		CopyTo(tutorialIsland);
		return tutorialIsland;
	}

	public static TutorialIsland Deserialize(BufferStream stream)
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		Deserialize(stream, tutorialIsland, isDelta: false);
		return tutorialIsland;
	}

	public static TutorialIsland DeserializeLengthDelimited(BufferStream stream)
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		DeserializeLengthDelimited(stream, tutorialIsland, isDelta: false);
		return tutorialIsland;
	}

	public static TutorialIsland DeserializeLength(BufferStream stream, int length)
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		DeserializeLength(stream, length, tutorialIsland, isDelta: false);
		return tutorialIsland;
	}

	public static TutorialIsland Deserialize(byte[] buffer)
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, tutorialIsland, isDelta: false);
		return tutorialIsland;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TutorialIsland previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TutorialIsland Deserialize(BufferStream stream, TutorialIsland instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.disconnectDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.spawnLocationIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.tutorialDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TutorialIsland DeserializeLengthDelimited(BufferStream stream, TutorialIsland instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.disconnectDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.spawnLocationIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.tutorialDuration = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TutorialIsland DeserializeLength(BufferStream stream, int length, TutorialIsland instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.disconnectDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.spawnLocationIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.tutorialDuration = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TutorialIsland instance, TutorialIsland previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetPlayer.Value);
		if (instance.disconnectDuration != previous.disconnectDuration)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.disconnectDuration);
		}
		if (instance.spawnLocationIndex != previous.spawnLocationIndex)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.spawnLocationIndex);
		}
		if (instance.tutorialDuration != previous.tutorialDuration)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.tutorialDuration);
		}
	}

	public static void Serialize(BufferStream stream, TutorialIsland instance)
	{
		if (instance.targetPlayer != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetPlayer.Value);
		}
		if (instance.disconnectDuration != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.disconnectDuration);
		}
		if (instance.spawnLocationIndex != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.spawnLocationIndex);
		}
		if (instance.tutorialDuration != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.tutorialDuration);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetPlayer.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CinematicEntity : IDisposable, IPooled, IProto<CinematicEntity>, IProto
{
	[NonSerialized]
	public NetworkableId targetPlayer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CinematicEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.targetPlayer = default(NetworkableId);
			Pool.Free<CinematicEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CinematicEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CinematicEntity instance)
	{
		instance.targetPlayer = targetPlayer;
	}

	public CinematicEntity Copy()
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		CopyTo(cinematicEntity);
		return cinematicEntity;
	}

	public static CinematicEntity Deserialize(BufferStream stream)
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		Deserialize(stream, cinematicEntity, isDelta: false);
		return cinematicEntity;
	}

	public static CinematicEntity DeserializeLengthDelimited(BufferStream stream)
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		DeserializeLengthDelimited(stream, cinematicEntity, isDelta: false);
		return cinematicEntity;
	}

	public static CinematicEntity DeserializeLength(BufferStream stream, int length)
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		DeserializeLength(stream, length, cinematicEntity, isDelta: false);
		return cinematicEntity;
	}

	public static CinematicEntity Deserialize(byte[] buffer)
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cinematicEntity, isDelta: false);
		return cinematicEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CinematicEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CinematicEntity Deserialize(BufferStream stream, CinematicEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CinematicEntity DeserializeLengthDelimited(BufferStream stream, CinematicEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CinematicEntity DeserializeLength(BufferStream stream, int length, CinematicEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CinematicEntity instance, CinematicEntity previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetPlayer.Value);
	}

	public static void Serialize(BufferStream stream, CinematicEntity instance)
	{
		if (instance.targetPlayer != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetPlayer.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetPlayer.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class HarborCrane : IDisposable, IPooled, IProto<HarborCrane>, IProto
{
	public class QueuedMove : IDisposable, IPooled, IProto<QueuedMove>, IProto
	{
		[NonSerialized]
		public NetworkableId targetEntity;

		[NonSerialized]
		public Vector3 targetWorldPosition;

		[NonSerialized]
		public Vector4 targetWorldRotation;

		[NonSerialized]
		public bool hasTarget;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(QueuedMove instance)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.targetEntity = default(NetworkableId);
				instance.targetWorldPosition = default(Vector3);
				instance.targetWorldRotation = default(Vector4);
				instance.hasTarget = false;
				Pool.Free<QueuedMove>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose QueuedMove with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(QueuedMove instance)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			instance.targetEntity = targetEntity;
			instance.targetWorldPosition = targetWorldPosition;
			instance.targetWorldRotation = targetWorldRotation;
			instance.hasTarget = hasTarget;
		}

		public QueuedMove Copy()
		{
			QueuedMove queuedMove = Pool.Get<QueuedMove>();
			CopyTo(queuedMove);
			return queuedMove;
		}

		public static QueuedMove Deserialize(BufferStream stream)
		{
			QueuedMove queuedMove = Pool.Get<QueuedMove>();
			Deserialize(stream, queuedMove, isDelta: false);
			return queuedMove;
		}

		public static QueuedMove DeserializeLengthDelimited(BufferStream stream)
		{
			QueuedMove queuedMove = Pool.Get<QueuedMove>();
			DeserializeLengthDelimited(stream, queuedMove, isDelta: false);
			return queuedMove;
		}

		public static QueuedMove DeserializeLength(BufferStream stream, int length)
		{
			QueuedMove queuedMove = Pool.Get<QueuedMove>();
			DeserializeLength(stream, length, queuedMove, isDelta: false);
			return queuedMove;
		}

		public static QueuedMove Deserialize(byte[] buffer)
		{
			QueuedMove queuedMove = Pool.Get<QueuedMove>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, queuedMove, isDelta: false);
			return queuedMove;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, QueuedMove previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static QueuedMove Deserialize(BufferStream stream, QueuedMove instance, bool isDelta)
		{
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
					continue;
				case 26:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
					continue;
				case 32:
					instance.hasTarget = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static QueuedMove DeserializeLengthDelimited(BufferStream stream, QueuedMove instance, bool isDelta)
		{
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
					continue;
				case 26:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
					continue;
				case 32:
					instance.hasTarget = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static QueuedMove DeserializeLength(BufferStream stream, int length, QueuedMove instance, bool isDelta)
		{
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
					continue;
				case 26:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
					continue;
				case 32:
					instance.hasTarget = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, QueuedMove instance, QueuedMove previous)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetEntity.Value);
			if (instance.targetWorldPosition != previous.targetWorldPosition)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.targetWorldPosition, previous.targetWorldPosition);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldPosition (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.targetWorldRotation != previous.targetWorldRotation)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.targetWorldRotation, previous.targetWorldRotation);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldRotation (UnityEngine.Vector4)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.hasTarget);
		}

		public static void Serialize(BufferStream stream, QueuedMove instance)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			if (instance.targetEntity != default(NetworkableId))
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.targetEntity.Value);
			}
			if (instance.targetWorldPosition != default(Vector3))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance.targetWorldPosition);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldPosition (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.targetWorldRotation != default(Vector4))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.targetWorldRotation);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetWorldRotation (UnityEngine.Vector4)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.hasTarget)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteBool(stream, instance.hasTarget);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref targetEntity.Value);
		}
	}

	[NonSerialized]
	public float time;

	[NonSerialized]
	public float yaw;

	[NonSerialized]
	public float depth;

	[NonSerialized]
	public float height;

	[NonSerialized]
	public QueuedMove currentMove;

	[NonSerialized]
	public int currentPickupState;

	[NonSerialized]
	public Vector3 startForward;

	[NonSerialized]
	public float maxMoveHeight;

	[NonSerialized]
	public NetworkableId toParent;

	[NonSerialized]
	public List<QueuedMove> queuedMoves;

	[NonSerialized]
	public float moveDelay;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(HarborCrane instance)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.time = 0f;
		instance.yaw = 0f;
		instance.depth = 0f;
		instance.height = 0f;
		if (instance.currentMove != null)
		{
			instance.currentMove.ResetToPool();
			instance.currentMove = null;
		}
		instance.currentPickupState = 0;
		instance.startForward = default(Vector3);
		instance.maxMoveHeight = 0f;
		instance.toParent = default(NetworkableId);
		if (instance.queuedMoves != null)
		{
			for (int i = 0; i < instance.queuedMoves.Count; i++)
			{
				if (instance.queuedMoves[i] != null)
				{
					instance.queuedMoves[i].ResetToPool();
					instance.queuedMoves[i] = null;
				}
			}
			List<QueuedMove> list = instance.queuedMoves;
			Pool.Free<QueuedMove>(ref list, false);
			instance.queuedMoves = list;
		}
		instance.moveDelay = 0f;
		Pool.Free<HarborCrane>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose HarborCrane with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(HarborCrane instance)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		instance.time = time;
		instance.yaw = yaw;
		instance.depth = depth;
		instance.height = height;
		if (currentMove != null)
		{
			if (instance.currentMove == null)
			{
				instance.currentMove = currentMove.Copy();
			}
			else
			{
				currentMove.CopyTo(instance.currentMove);
			}
		}
		else
		{
			instance.currentMove = null;
		}
		instance.currentPickupState = currentPickupState;
		instance.startForward = startForward;
		instance.maxMoveHeight = maxMoveHeight;
		instance.toParent = toParent;
		if (queuedMoves != null)
		{
			instance.queuedMoves = Pool.Get<List<QueuedMove>>();
			for (int i = 0; i < queuedMoves.Count; i++)
			{
				QueuedMove item = queuedMoves[i].Copy();
				instance.queuedMoves.Add(item);
			}
		}
		else
		{
			instance.queuedMoves = null;
		}
		instance.moveDelay = moveDelay;
	}

	public HarborCrane Copy()
	{
		HarborCrane harborCrane = Pool.Get<HarborCrane>();
		CopyTo(harborCrane);
		return harborCrane;
	}

	public static HarborCrane Deserialize(BufferStream stream)
	{
		HarborCrane harborCrane = Pool.Get<HarborCrane>();
		Deserialize(stream, harborCrane, isDelta: false);
		return harborCrane;
	}

	public static HarborCrane DeserializeLengthDelimited(BufferStream stream)
	{
		HarborCrane harborCrane = Pool.Get<HarborCrane>();
		DeserializeLengthDelimited(stream, harborCrane, isDelta: false);
		return harborCrane;
	}

	public static HarborCrane DeserializeLength(BufferStream stream, int length)
	{
		HarborCrane harborCrane = Pool.Get<HarborCrane>();
		DeserializeLength(stream, length, harborCrane, isDelta: false);
		return harborCrane;
	}

	public static HarborCrane Deserialize(byte[] buffer)
	{
		HarborCrane harborCrane = Pool.Get<HarborCrane>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, harborCrane, isDelta: false);
		return harborCrane;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, HarborCrane previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static HarborCrane Deserialize(BufferStream stream, HarborCrane instance, bool isDelta)
	{
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.queuedMoves == null)
		{
			instance.queuedMoves = Pool.Get<List<QueuedMove>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				break;
			case 21:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				break;
			case 29:
				instance.depth = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.height = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.currentMove == null)
				{
					instance.currentMove = QueuedMove.DeserializeLengthDelimited(stream);
				}
				else
				{
					QueuedMove.DeserializeLengthDelimited(stream, instance.currentMove, isDelta);
				}
				break;
			case 48:
				instance.currentPickupState = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startForward, isDelta);
				break;
			case 69:
				instance.maxMoveHeight = ProtocolParser.ReadSingle(stream);
				break;
			case 72:
				instance.toParent = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 90:
				instance.queuedMoves.Add(QueuedMove.DeserializeLengthDelimited(stream));
				break;
			case 101:
				instance.moveDelay = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static HarborCrane DeserializeLengthDelimited(BufferStream stream, HarborCrane instance, bool isDelta)
	{
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.queuedMoves == null)
		{
			instance.queuedMoves = Pool.Get<List<QueuedMove>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				break;
			case 21:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				break;
			case 29:
				instance.depth = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.height = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.currentMove == null)
				{
					instance.currentMove = QueuedMove.DeserializeLengthDelimited(stream);
				}
				else
				{
					QueuedMove.DeserializeLengthDelimited(stream, instance.currentMove, isDelta);
				}
				break;
			case 48:
				instance.currentPickupState = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startForward, isDelta);
				break;
			case 69:
				instance.maxMoveHeight = ProtocolParser.ReadSingle(stream);
				break;
			case 72:
				instance.toParent = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 90:
				instance.queuedMoves.Add(QueuedMove.DeserializeLengthDelimited(stream));
				break;
			case 101:
				instance.moveDelay = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static HarborCrane DeserializeLength(BufferStream stream, int length, HarborCrane instance, bool isDelta)
	{
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.queuedMoves == null)
		{
			instance.queuedMoves = Pool.Get<List<QueuedMove>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				break;
			case 21:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				break;
			case 29:
				instance.depth = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.height = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.currentMove == null)
				{
					instance.currentMove = QueuedMove.DeserializeLengthDelimited(stream);
				}
				else
				{
					QueuedMove.DeserializeLengthDelimited(stream, instance.currentMove, isDelta);
				}
				break;
			case 48:
				instance.currentPickupState = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startForward, isDelta);
				break;
			case 69:
				instance.maxMoveHeight = ProtocolParser.ReadSingle(stream);
				break;
			case 72:
				instance.toParent = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 90:
				instance.queuedMoves.Add(QueuedMove.DeserializeLengthDelimited(stream));
				break;
			case 101:
				instance.moveDelay = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, HarborCrane instance, HarborCrane previous)
	{
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		if (instance.time != previous.time)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.yaw != previous.yaw)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
		if (instance.depth != previous.depth)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.depth);
		}
		if (instance.height != previous.height)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.height);
		}
		if (instance.currentMove != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			QueuedMove.SerializeDelta(stream, instance.currentMove, previous.currentMove);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field currentMove (ProtoBuf.HarborCrane.QueuedMove)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.currentPickupState != previous.currentPickupState)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentPickupState);
		}
		if (instance.startForward != previous.startForward)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.startForward, previous.startForward);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startForward (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.maxMoveHeight != previous.maxMoveHeight)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.maxMoveHeight);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteUInt64(stream, instance.toParent.Value);
		if (instance.queuedMoves != null)
		{
			for (int i = 0; i < instance.queuedMoves.Count; i++)
			{
				QueuedMove queuedMove = instance.queuedMoves[i];
				stream.WriteByte(90);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				QueuedMove.SerializeDelta(stream, queuedMove, queuedMove);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field queuedMoves (ProtoBuf.HarborCrane.QueuedMove)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.moveDelay != previous.moveDelay)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.moveDelay);
		}
	}

	public static void Serialize(BufferStream stream, HarborCrane instance)
	{
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		if (instance.time != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.yaw != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
		if (instance.depth != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.depth);
		}
		if (instance.height != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.height);
		}
		if (instance.currentMove != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			QueuedMove.Serialize(stream, instance.currentMove);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field currentMove (ProtoBuf.HarborCrane.QueuedMove)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.currentPickupState != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentPickupState);
		}
		if (instance.startForward != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.startForward);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startForward (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.maxMoveHeight != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.maxMoveHeight);
		}
		if (instance.toParent != default(NetworkableId))
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, instance.toParent.Value);
		}
		if (instance.queuedMoves != null)
		{
			for (int i = 0; i < instance.queuedMoves.Count; i++)
			{
				QueuedMove instance2 = instance.queuedMoves[i];
				stream.WriteByte(90);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				QueuedMove.Serialize(stream, instance2);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field queuedMoves (ProtoBuf.HarborCrane.QueuedMove)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.moveDelay != 0f)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.moveDelay);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		currentMove?.InspectUids(action);
		action(UidType.NetworkableId, ref toParent.Value);
		if (queuedMoves != null)
		{
			for (int i = 0; i < queuedMoves.Count; i++)
			{
				queuedMoves[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CargoShip : IDisposable, IPooled, IProto<CargoShip>, IProto
{
	[NonSerialized]
	public int currentHarborApproachNode;

	[NonSerialized]
	public bool isDoingHarborApproach;

	[NonSerialized]
	public bool shouldLookAhead;

	[NonSerialized]
	public bool isEgressing;

	[NonSerialized]
	public uint layout;

	[NonSerialized]
	public List<ulong> playerIds;

	[NonSerialized]
	public int dockCount;

	[NonSerialized]
	public float lifetime;

	[NonSerialized]
	public int harborIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CargoShip instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentHarborApproachNode = 0;
			instance.isDoingHarborApproach = false;
			instance.shouldLookAhead = false;
			instance.isEgressing = false;
			instance.layout = 0u;
			if (instance.playerIds != null)
			{
				List<ulong> list = instance.playerIds;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.playerIds = list;
			}
			instance.dockCount = 0;
			instance.lifetime = 0f;
			instance.harborIndex = 0;
			Pool.Free<CargoShip>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CargoShip with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CargoShip instance)
	{
		instance.currentHarborApproachNode = currentHarborApproachNode;
		instance.isDoingHarborApproach = isDoingHarborApproach;
		instance.shouldLookAhead = shouldLookAhead;
		instance.isEgressing = isEgressing;
		instance.layout = layout;
		if (playerIds != null)
		{
			instance.playerIds = Pool.Get<List<ulong>>();
			for (int i = 0; i < playerIds.Count; i++)
			{
				ulong item = playerIds[i];
				instance.playerIds.Add(item);
			}
		}
		else
		{
			instance.playerIds = null;
		}
		instance.dockCount = dockCount;
		instance.lifetime = lifetime;
		instance.harborIndex = harborIndex;
	}

	public CargoShip Copy()
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		CopyTo(cargoShip);
		return cargoShip;
	}

	public static CargoShip Deserialize(BufferStream stream)
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		Deserialize(stream, cargoShip, isDelta: false);
		return cargoShip;
	}

	public static CargoShip DeserializeLengthDelimited(BufferStream stream)
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		DeserializeLengthDelimited(stream, cargoShip, isDelta: false);
		return cargoShip;
	}

	public static CargoShip DeserializeLength(BufferStream stream, int length)
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		DeserializeLength(stream, length, cargoShip, isDelta: false);
		return cargoShip;
	}

	public static CargoShip Deserialize(byte[] buffer)
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cargoShip, isDelta: false);
		return cargoShip;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CargoShip previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CargoShip Deserialize(BufferStream stream, CargoShip instance, bool isDelta)
	{
		if (!isDelta && instance.playerIds == null)
		{
			instance.playerIds = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.currentHarborApproachNode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isDoingHarborApproach = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.shouldLookAhead = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.isEgressing = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.layout = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.playerIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.dockCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.harborIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CargoShip DeserializeLengthDelimited(BufferStream stream, CargoShip instance, bool isDelta)
	{
		if (!isDelta && instance.playerIds == null)
		{
			instance.playerIds = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentHarborApproachNode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isDoingHarborApproach = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.shouldLookAhead = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.isEgressing = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.layout = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.playerIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.dockCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.harborIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CargoShip DeserializeLength(BufferStream stream, int length, CargoShip instance, bool isDelta)
	{
		if (!isDelta && instance.playerIds == null)
		{
			instance.playerIds = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentHarborApproachNode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isDoingHarborApproach = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.shouldLookAhead = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.isEgressing = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.layout = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.playerIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.dockCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.harborIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CargoShip instance, CargoShip previous)
	{
		if (instance.currentHarborApproachNode != previous.currentHarborApproachNode)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentHarborApproachNode);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.isDoingHarborApproach);
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.shouldLookAhead);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.isEgressing);
		if (instance.layout != previous.layout)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.layout);
		}
		if (instance.playerIds != null)
		{
			for (int i = 0; i < instance.playerIds.Count; i++)
			{
				ulong val = instance.playerIds[i];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.dockCount != previous.dockCount)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dockCount);
		}
		if (instance.lifetime != previous.lifetime)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lifetime);
		}
		if (instance.harborIndex != previous.harborIndex)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.harborIndex);
		}
	}

	public static void Serialize(BufferStream stream, CargoShip instance)
	{
		if (instance.currentHarborApproachNode != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentHarborApproachNode);
		}
		if (instance.isDoingHarborApproach)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.isDoingHarborApproach);
		}
		if (instance.shouldLookAhead)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.shouldLookAhead);
		}
		if (instance.isEgressing)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isEgressing);
		}
		if (instance.layout != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.layout);
		}
		if (instance.playerIds != null)
		{
			for (int i = 0; i < instance.playerIds.Count; i++)
			{
				ulong val = instance.playerIds[i];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.dockCount != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dockCount);
		}
		if (instance.lifetime != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lifetime);
		}
		if (instance.harborIndex != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.harborIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CargoShipContainer : IDisposable, IPooled, IProto<CargoShipContainer>, IProto
{
	[NonSerialized]
	public int dressingVariant;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CargoShipContainer instance)
	{
		if (instance.ShouldPool)
		{
			instance.dressingVariant = 0;
			Pool.Free<CargoShipContainer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CargoShipContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CargoShipContainer instance)
	{
		instance.dressingVariant = dressingVariant;
	}

	public CargoShipContainer Copy()
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		CopyTo(cargoShipContainer);
		return cargoShipContainer;
	}

	public static CargoShipContainer Deserialize(BufferStream stream)
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		Deserialize(stream, cargoShipContainer, isDelta: false);
		return cargoShipContainer;
	}

	public static CargoShipContainer DeserializeLengthDelimited(BufferStream stream)
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		DeserializeLengthDelimited(stream, cargoShipContainer, isDelta: false);
		return cargoShipContainer;
	}

	public static CargoShipContainer DeserializeLength(BufferStream stream, int length)
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		DeserializeLength(stream, length, cargoShipContainer, isDelta: false);
		return cargoShipContainer;
	}

	public static CargoShipContainer Deserialize(byte[] buffer)
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cargoShipContainer, isDelta: false);
		return cargoShipContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CargoShipContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CargoShipContainer Deserialize(BufferStream stream, CargoShipContainer instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.dressingVariant = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CargoShipContainer DeserializeLengthDelimited(BufferStream stream, CargoShipContainer instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dressingVariant = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CargoShipContainer DeserializeLength(BufferStream stream, int length, CargoShipContainer instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dressingVariant = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CargoShipContainer instance, CargoShipContainer previous)
	{
		if (instance.dressingVariant != previous.dressingVariant)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dressingVariant);
		}
	}

	public static void Serialize(BufferStream stream, CargoShipContainer instance)
	{
		if (instance.dressingVariant != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dressingVariant);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionMapMarker : IDisposable, IPooled, IProto<MissionMapMarker>, IProto
{
	[NonSerialized]
	public List<uint> missionIds;

	[NonSerialized]
	public string providerToken;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionMapMarker instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.missionIds != null)
			{
				List<uint> list = instance.missionIds;
				Pool.FreeUnmanaged<uint>(ref list);
				instance.missionIds = list;
			}
			instance.providerToken = string.Empty;
			Pool.Free<MissionMapMarker>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionMapMarker with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionMapMarker instance)
	{
		if (missionIds != null)
		{
			instance.missionIds = Pool.Get<List<uint>>();
			for (int i = 0; i < missionIds.Count; i++)
			{
				uint item = missionIds[i];
				instance.missionIds.Add(item);
			}
		}
		else
		{
			instance.missionIds = null;
		}
		instance.providerToken = providerToken;
	}

	public MissionMapMarker Copy()
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		CopyTo(missionMapMarker);
		return missionMapMarker;
	}

	public static MissionMapMarker Deserialize(BufferStream stream)
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		Deserialize(stream, missionMapMarker, isDelta: false);
		return missionMapMarker;
	}

	public static MissionMapMarker DeserializeLengthDelimited(BufferStream stream)
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		DeserializeLengthDelimited(stream, missionMapMarker, isDelta: false);
		return missionMapMarker;
	}

	public static MissionMapMarker DeserializeLength(BufferStream stream, int length)
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		DeserializeLength(stream, length, missionMapMarker, isDelta: false);
		return missionMapMarker;
	}

	public static MissionMapMarker Deserialize(byte[] buffer)
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionMapMarker, isDelta: false);
		return missionMapMarker;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionMapMarker previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionMapMarker Deserialize(BufferStream stream, MissionMapMarker instance, bool isDelta)
	{
		if (!isDelta && instance.missionIds == null)
		{
			instance.missionIds = Pool.Get<List<uint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.missionIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 18:
				instance.providerToken = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionMapMarker DeserializeLengthDelimited(BufferStream stream, MissionMapMarker instance, bool isDelta)
	{
		if (!isDelta && instance.missionIds == null)
		{
			instance.missionIds = Pool.Get<List<uint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.missionIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 18:
				instance.providerToken = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionMapMarker DeserializeLength(BufferStream stream, int length, MissionMapMarker instance, bool isDelta)
	{
		if (!isDelta && instance.missionIds == null)
		{
			instance.missionIds = Pool.Get<List<uint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.missionIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 18:
				instance.providerToken = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionMapMarker instance, MissionMapMarker previous)
	{
		if (instance.missionIds != null)
		{
			for (int i = 0; i < instance.missionIds.Count; i++)
			{
				uint val = instance.missionIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.providerToken != null && instance.providerToken != previous.providerToken)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.providerToken);
		}
	}

	public static void Serialize(BufferStream stream, MissionMapMarker instance)
	{
		if (instance.missionIds != null)
		{
			for (int i = 0; i < instance.missionIds.Count; i++)
			{
				uint val = instance.missionIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.providerToken != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.providerToken);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Bike : IDisposable, IPooled, IProto<Bike>, IProto
{
	[NonSerialized]
	public float steerInput;

	[NonSerialized]
	public float driveWheelVel;

	[NonSerialized]
	public float throttleInput;

	[NonSerialized]
	public float brakeInput;

	[NonSerialized]
	public NetworkableId storageID;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelFraction;

	[NonSerialized]
	public float sidecarAngle;

	[NonSerialized]
	public float time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Bike instance)
	{
		if (instance.ShouldPool)
		{
			instance.steerInput = 0f;
			instance.driveWheelVel = 0f;
			instance.throttleInput = 0f;
			instance.brakeInput = 0f;
			instance.storageID = default(NetworkableId);
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelFraction = 0f;
			instance.sidecarAngle = 0f;
			instance.time = 0f;
			Pool.Free<Bike>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Bike with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Bike instance)
	{
		instance.steerInput = steerInput;
		instance.driveWheelVel = driveWheelVel;
		instance.throttleInput = throttleInput;
		instance.brakeInput = brakeInput;
		instance.storageID = storageID;
		instance.fuelStorageID = fuelStorageID;
		instance.fuelFraction = fuelFraction;
		instance.sidecarAngle = sidecarAngle;
		instance.time = time;
	}

	public Bike Copy()
	{
		Bike bike = Pool.Get<Bike>();
		CopyTo(bike);
		return bike;
	}

	public static Bike Deserialize(BufferStream stream)
	{
		Bike bike = Pool.Get<Bike>();
		Deserialize(stream, bike, isDelta: false);
		return bike;
	}

	public static Bike DeserializeLengthDelimited(BufferStream stream)
	{
		Bike bike = Pool.Get<Bike>();
		DeserializeLengthDelimited(stream, bike, isDelta: false);
		return bike;
	}

	public static Bike DeserializeLength(BufferStream stream, int length)
	{
		Bike bike = Pool.Get<Bike>();
		DeserializeLength(stream, length, bike, isDelta: false);
		return bike;
	}

	public static Bike Deserialize(byte[] buffer)
	{
		Bike bike = Pool.Get<Bike>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, bike, isDelta: false);
		return bike;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Bike previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Bike Deserialize(BufferStream stream, Bike instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sidecarAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Bike DeserializeLengthDelimited(BufferStream stream, Bike instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sidecarAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Bike DeserializeLength(BufferStream stream, int length, Bike instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sidecarAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Bike instance, Bike previous)
	{
		if (instance.steerInput != previous.steerInput)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != previous.driveWheelVel)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != previous.throttleInput)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != previous.brakeInput)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.sidecarAngle != previous.sidecarAngle)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.sidecarAngle);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public static void Serialize(BufferStream stream, Bike instance)
	{
		if (instance.steerInput != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.storageID != default(NetworkableId))
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.sidecarAngle != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.sidecarAngle);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref storageID.Value);
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TravellingVendor : IDisposable, IPooled, IProto<TravellingVendor>, IProto
{
	[NonSerialized]
	public float steeringAngle;

	[NonSerialized]
	public Vector3 velocity;

	[NonSerialized]
	public int wheelFlags;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TravellingVendor instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.steeringAngle = 0f;
			instance.velocity = default(Vector3);
			instance.wheelFlags = 0;
			Pool.Free<TravellingVendor>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TravellingVendor with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TravellingVendor instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.steeringAngle = steeringAngle;
		instance.velocity = velocity;
		instance.wheelFlags = wheelFlags;
	}

	public TravellingVendor Copy()
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		CopyTo(travellingVendor);
		return travellingVendor;
	}

	public static TravellingVendor Deserialize(BufferStream stream)
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		Deserialize(stream, travellingVendor, isDelta: false);
		return travellingVendor;
	}

	public static TravellingVendor DeserializeLengthDelimited(BufferStream stream)
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		DeserializeLengthDelimited(stream, travellingVendor, isDelta: false);
		return travellingVendor;
	}

	public static TravellingVendor DeserializeLength(BufferStream stream, int length)
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		DeserializeLength(stream, length, travellingVendor, isDelta: false);
		return travellingVendor;
	}

	public static TravellingVendor Deserialize(byte[] buffer)
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, travellingVendor, isDelta: false);
		return travellingVendor;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TravellingVendor previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TravellingVendor Deserialize(BufferStream stream, TravellingVendor instance, bool isDelta)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.steeringAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.velocity, isDelta);
				continue;
			case 24:
				instance.wheelFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TravellingVendor DeserializeLengthDelimited(BufferStream stream, TravellingVendor instance, bool isDelta)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steeringAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.velocity, isDelta);
				continue;
			case 24:
				instance.wheelFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TravellingVendor DeserializeLength(BufferStream stream, int length, TravellingVendor instance, bool isDelta)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steeringAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.velocity, isDelta);
				continue;
			case 24:
				instance.wheelFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TravellingVendor instance, TravellingVendor previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.steeringAngle != previous.steeringAngle)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steeringAngle);
		}
		if (instance.velocity != previous.velocity)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.velocity, previous.velocity);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field velocity (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.wheelFlags != previous.wheelFlags)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wheelFlags);
		}
	}

	public static void Serialize(BufferStream stream, TravellingVendor instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (instance.steeringAngle != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steeringAngle);
		}
		if (instance.velocity != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.velocity);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field velocity (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.wheelFlags != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wheelFlags);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingDynamicPricing : IDisposable, IPooled, IProto<VendingDynamicPricing>, IProto
{
	[NonSerialized]
	public List<SalesData> allSalesData;

	[NonSerialized]
	public float timeToNextSalesUpdate;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingDynamicPricing instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.allSalesData != null)
		{
			for (int i = 0; i < instance.allSalesData.Count; i++)
			{
				if (instance.allSalesData[i] != null)
				{
					instance.allSalesData[i].ResetToPool();
					instance.allSalesData[i] = null;
				}
			}
			List<SalesData> list = instance.allSalesData;
			Pool.Free<SalesData>(ref list, false);
			instance.allSalesData = list;
		}
		instance.timeToNextSalesUpdate = 0f;
		Pool.Free<VendingDynamicPricing>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingDynamicPricing with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingDynamicPricing instance)
	{
		if (allSalesData != null)
		{
			instance.allSalesData = Pool.Get<List<SalesData>>();
			for (int i = 0; i < allSalesData.Count; i++)
			{
				SalesData item = allSalesData[i].Copy();
				instance.allSalesData.Add(item);
			}
		}
		else
		{
			instance.allSalesData = null;
		}
		instance.timeToNextSalesUpdate = timeToNextSalesUpdate;
	}

	public VendingDynamicPricing Copy()
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		CopyTo(vendingDynamicPricing);
		return vendingDynamicPricing;
	}

	public static VendingDynamicPricing Deserialize(BufferStream stream)
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		Deserialize(stream, vendingDynamicPricing, isDelta: false);
		return vendingDynamicPricing;
	}

	public static VendingDynamicPricing DeserializeLengthDelimited(BufferStream stream)
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		DeserializeLengthDelimited(stream, vendingDynamicPricing, isDelta: false);
		return vendingDynamicPricing;
	}

	public static VendingDynamicPricing DeserializeLength(BufferStream stream, int length)
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		DeserializeLength(stream, length, vendingDynamicPricing, isDelta: false);
		return vendingDynamicPricing;
	}

	public static VendingDynamicPricing Deserialize(byte[] buffer)
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingDynamicPricing, isDelta: false);
		return vendingDynamicPricing;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingDynamicPricing previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingDynamicPricing Deserialize(BufferStream stream, VendingDynamicPricing instance, bool isDelta)
	{
		if (!isDelta && instance.allSalesData == null)
		{
			instance.allSalesData = Pool.Get<List<SalesData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.allSalesData.Add(SalesData.DeserializeLengthDelimited(stream));
				continue;
			case 29:
				instance.timeToNextSalesUpdate = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingDynamicPricing DeserializeLengthDelimited(BufferStream stream, VendingDynamicPricing instance, bool isDelta)
	{
		if (!isDelta && instance.allSalesData == null)
		{
			instance.allSalesData = Pool.Get<List<SalesData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.allSalesData.Add(SalesData.DeserializeLengthDelimited(stream));
				continue;
			case 29:
				instance.timeToNextSalesUpdate = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingDynamicPricing DeserializeLength(BufferStream stream, int length, VendingDynamicPricing instance, bool isDelta)
	{
		if (!isDelta && instance.allSalesData == null)
		{
			instance.allSalesData = Pool.Get<List<SalesData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.allSalesData.Add(SalesData.DeserializeLengthDelimited(stream));
				continue;
			case 29:
				instance.timeToNextSalesUpdate = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingDynamicPricing instance, VendingDynamicPricing previous)
	{
		if (instance.allSalesData != null)
		{
			for (int i = 0; i < instance.allSalesData.Count; i++)
			{
				SalesData salesData = instance.allSalesData[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				SalesData.SerializeDelta(stream, salesData, salesData);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field allSalesData (ProtoBuf.SalesData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.timeToNextSalesUpdate != previous.timeToNextSalesUpdate)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.timeToNextSalesUpdate);
		}
	}

	public static void Serialize(BufferStream stream, VendingDynamicPricing instance)
	{
		if (instance.allSalesData != null)
		{
			for (int i = 0; i < instance.allSalesData.Count; i++)
			{
				SalesData instance2 = instance.allSalesData[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				SalesData.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field allSalesData (ProtoBuf.SalesData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.timeToNextSalesUpdate != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.timeToNextSalesUpdate);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (allSalesData != null)
		{
			for (int i = 0; i < allSalesData.Count; i++)
			{
				allSalesData[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SalesData : IDisposable, IPooled, IProto<SalesData>, IProto
{
	[NonSerialized]
	public ulong totalSales;

	[NonSerialized]
	public ulong totalIntervals;

	[NonSerialized]
	public ulong soldThisInterval;

	[NonSerialized]
	public float currentMultiplier;

	[NonSerialized]
	public bool isForReceivedQuantity;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SalesData instance)
	{
		if (instance.ShouldPool)
		{
			instance.totalSales = 0uL;
			instance.totalIntervals = 0uL;
			instance.soldThisInterval = 0uL;
			instance.currentMultiplier = 0f;
			instance.isForReceivedQuantity = false;
			Pool.Free<SalesData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SalesData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SalesData instance)
	{
		instance.totalSales = totalSales;
		instance.totalIntervals = totalIntervals;
		instance.soldThisInterval = soldThisInterval;
		instance.currentMultiplier = currentMultiplier;
		instance.isForReceivedQuantity = isForReceivedQuantity;
	}

	public SalesData Copy()
	{
		SalesData salesData = Pool.Get<SalesData>();
		CopyTo(salesData);
		return salesData;
	}

	public static SalesData Deserialize(BufferStream stream)
	{
		SalesData salesData = Pool.Get<SalesData>();
		Deserialize(stream, salesData, isDelta: false);
		return salesData;
	}

	public static SalesData DeserializeLengthDelimited(BufferStream stream)
	{
		SalesData salesData = Pool.Get<SalesData>();
		DeserializeLengthDelimited(stream, salesData, isDelta: false);
		return salesData;
	}

	public static SalesData DeserializeLength(BufferStream stream, int length)
	{
		SalesData salesData = Pool.Get<SalesData>();
		DeserializeLength(stream, length, salesData, isDelta: false);
		return salesData;
	}

	public static SalesData Deserialize(byte[] buffer)
	{
		SalesData salesData = Pool.Get<SalesData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, salesData, isDelta: false);
		return salesData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SalesData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SalesData Deserialize(BufferStream stream, SalesData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 24:
				instance.totalSales = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.totalIntervals = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.soldThisInterval = ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.currentMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.isForReceivedQuantity = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SalesData DeserializeLengthDelimited(BufferStream stream, SalesData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.totalSales = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.totalIntervals = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.soldThisInterval = ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.currentMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.isForReceivedQuantity = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SalesData DeserializeLength(BufferStream stream, int length, SalesData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.totalSales = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.totalIntervals = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.soldThisInterval = ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.currentMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.isForReceivedQuantity = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SalesData instance, SalesData previous)
	{
		if (instance.totalSales != previous.totalSales)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.totalSales);
		}
		if (instance.totalIntervals != previous.totalIntervals)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.totalIntervals);
		}
		if (instance.soldThisInterval != previous.soldThisInterval)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.soldThisInterval);
		}
		if (instance.currentMultiplier != previous.currentMultiplier)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.currentMultiplier);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.isForReceivedQuantity);
	}

	public static void Serialize(BufferStream stream, SalesData instance)
	{
		if (instance.totalSales != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.totalSales);
		}
		if (instance.totalIntervals != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.totalIntervals);
		}
		if (instance.soldThisInterval != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.soldThisInterval);
		}
		if (instance.currentMultiplier != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.currentMultiplier);
		}
		if (instance.isForReceivedQuantity)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.isForReceivedQuantity);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TinCanAlarm : IDisposable, IPooled, IProto<TinCanAlarm>, IProto
{
	[NonSerialized]
	public Vector3 endPoint;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TinCanAlarm instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.endPoint = default(Vector3);
			Pool.Free<TinCanAlarm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TinCanAlarm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TinCanAlarm instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.endPoint = endPoint;
	}

	public TinCanAlarm Copy()
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		CopyTo(tinCanAlarm);
		return tinCanAlarm;
	}

	public static TinCanAlarm Deserialize(BufferStream stream)
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		Deserialize(stream, tinCanAlarm, isDelta: false);
		return tinCanAlarm;
	}

	public static TinCanAlarm DeserializeLengthDelimited(BufferStream stream)
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		DeserializeLengthDelimited(stream, tinCanAlarm, isDelta: false);
		return tinCanAlarm;
	}

	public static TinCanAlarm DeserializeLength(BufferStream stream, int length)
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		DeserializeLength(stream, length, tinCanAlarm, isDelta: false);
		return tinCanAlarm;
	}

	public static TinCanAlarm Deserialize(byte[] buffer)
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, tinCanAlarm, isDelta: false);
		return tinCanAlarm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TinCanAlarm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TinCanAlarm Deserialize(BufferStream stream, TinCanAlarm instance, bool isDelta)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPoint, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TinCanAlarm DeserializeLengthDelimited(BufferStream stream, TinCanAlarm instance, bool isDelta)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPoint, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TinCanAlarm DeserializeLength(BufferStream stream, int length, TinCanAlarm instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPoint, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TinCanAlarm instance, TinCanAlarm previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.endPoint != previous.endPoint)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.endPoint, previous.endPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field endPoint (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, TinCanAlarm instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.endPoint != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.endPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field endPoint (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DigitalClock : IDisposable, IPooled, IProto<DigitalClock>, IProto
{
	[NonSerialized]
	public List<DigitalClockAlarm> alarms;

	[NonSerialized]
	public bool muted;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DigitalClock instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				if (instance.alarms[i] != null)
				{
					instance.alarms[i].ResetToPool();
					instance.alarms[i] = null;
				}
			}
			List<DigitalClockAlarm> list = instance.alarms;
			Pool.Free<DigitalClockAlarm>(ref list, false);
			instance.alarms = list;
		}
		instance.muted = false;
		Pool.Free<DigitalClock>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DigitalClock with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DigitalClock instance)
	{
		if (alarms != null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
			for (int i = 0; i < alarms.Count; i++)
			{
				DigitalClockAlarm item = alarms[i].Copy();
				instance.alarms.Add(item);
			}
		}
		else
		{
			instance.alarms = null;
		}
		instance.muted = muted;
	}

	public DigitalClock Copy()
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		CopyTo(digitalClock);
		return digitalClock;
	}

	public static DigitalClock Deserialize(BufferStream stream)
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		Deserialize(stream, digitalClock, isDelta: false);
		return digitalClock;
	}

	public static DigitalClock DeserializeLengthDelimited(BufferStream stream)
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		DeserializeLengthDelimited(stream, digitalClock, isDelta: false);
		return digitalClock;
	}

	public static DigitalClock DeserializeLength(BufferStream stream, int length)
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		DeserializeLength(stream, length, digitalClock, isDelta: false);
		return digitalClock;
	}

	public static DigitalClock Deserialize(byte[] buffer)
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, digitalClock, isDelta: false);
		return digitalClock;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DigitalClock previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DigitalClock Deserialize(BufferStream stream, DigitalClock instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DigitalClock DeserializeLengthDelimited(BufferStream stream, DigitalClock instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DigitalClock DeserializeLength(BufferStream stream, int length, DigitalClock instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DigitalClock instance, DigitalClock previous)
	{
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				DigitalClockAlarm digitalClockAlarm = instance.alarms[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				DigitalClockAlarm.SerializeDelta(stream, digitalClockAlarm, digitalClockAlarm);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field alarms (ProtoBuf.DigitalClockAlarm)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.muted);
	}

	public static void Serialize(BufferStream stream, DigitalClock instance)
	{
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				DigitalClockAlarm instance2 = instance.alarms[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				DigitalClockAlarm.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field alarms (ProtoBuf.DigitalClockAlarm)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.muted)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.muted);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (alarms != null)
		{
			for (int i = 0; i < alarms.Count; i++)
			{
				alarms[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ElevatorLift : IDisposable, IPooled, IProto<ElevatorLift>, IProto
{
	[NonSerialized]
	public NetworkableId owner;

	[NonSerialized]
	public float topElevatorHeight;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ElevatorLift instance)
	{
		if (instance.ShouldPool)
		{
			instance.owner = default(NetworkableId);
			instance.topElevatorHeight = 0f;
			Pool.Free<ElevatorLift>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ElevatorLift with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ElevatorLift instance)
	{
		instance.owner = owner;
		instance.topElevatorHeight = topElevatorHeight;
	}

	public ElevatorLift Copy()
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		CopyTo(elevatorLift);
		return elevatorLift;
	}

	public static ElevatorLift Deserialize(BufferStream stream)
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		Deserialize(stream, elevatorLift, isDelta: false);
		return elevatorLift;
	}

	public static ElevatorLift DeserializeLengthDelimited(BufferStream stream)
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		DeserializeLengthDelimited(stream, elevatorLift, isDelta: false);
		return elevatorLift;
	}

	public static ElevatorLift DeserializeLength(BufferStream stream, int length)
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		DeserializeLength(stream, length, elevatorLift, isDelta: false);
		return elevatorLift;
	}

	public static ElevatorLift Deserialize(byte[] buffer)
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, elevatorLift, isDelta: false);
		return elevatorLift;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ElevatorLift previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ElevatorLift Deserialize(BufferStream stream, ElevatorLift instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.owner = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.topElevatorHeight = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ElevatorLift DeserializeLengthDelimited(BufferStream stream, ElevatorLift instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.owner = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.topElevatorHeight = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ElevatorLift DeserializeLength(BufferStream stream, int length, ElevatorLift instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.owner = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.topElevatorHeight = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ElevatorLift instance, ElevatorLift previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.owner.Value);
		if (instance.topElevatorHeight != previous.topElevatorHeight)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.topElevatorHeight);
		}
	}

	public static void Serialize(BufferStream stream, ElevatorLift instance)
	{
		if (instance.owner != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.owner.Value);
		}
		if (instance.topElevatorHeight != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.topElevatorHeight);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref owner.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DiverPropulsionVehicle : IDisposable, IPooled, IProto<DiverPropulsionVehicle>, IProto
{
	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public int fuelAmount;

	[NonSerialized]
	public int fuelTicks;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DiverPropulsionVehicle instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelAmount = 0;
			instance.fuelTicks = 0;
			Pool.Free<DiverPropulsionVehicle>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DiverPropulsionVehicle with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DiverPropulsionVehicle instance)
	{
		instance.fuelStorageID = fuelStorageID;
		instance.fuelAmount = fuelAmount;
		instance.fuelTicks = fuelTicks;
	}

	public DiverPropulsionVehicle Copy()
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		CopyTo(diverPropulsionVehicle);
		return diverPropulsionVehicle;
	}

	public static DiverPropulsionVehicle Deserialize(BufferStream stream)
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		Deserialize(stream, diverPropulsionVehicle, isDelta: false);
		return diverPropulsionVehicle;
	}

	public static DiverPropulsionVehicle DeserializeLengthDelimited(BufferStream stream)
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		DeserializeLengthDelimited(stream, diverPropulsionVehicle, isDelta: false);
		return diverPropulsionVehicle;
	}

	public static DiverPropulsionVehicle DeserializeLength(BufferStream stream, int length)
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		DeserializeLength(stream, length, diverPropulsionVehicle, isDelta: false);
		return diverPropulsionVehicle;
	}

	public static DiverPropulsionVehicle Deserialize(byte[] buffer)
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, diverPropulsionVehicle, isDelta: false);
		return diverPropulsionVehicle;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DiverPropulsionVehicle previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DiverPropulsionVehicle Deserialize(BufferStream stream, DiverPropulsionVehicle instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.fuelTicks = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DiverPropulsionVehicle DeserializeLengthDelimited(BufferStream stream, DiverPropulsionVehicle instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.fuelTicks = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DiverPropulsionVehicle DeserializeLength(BufferStream stream, int length, DiverPropulsionVehicle instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.fuelTicks = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DiverPropulsionVehicle instance, DiverPropulsionVehicle previous)
	{
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelAmount != previous.fuelAmount)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.fuelAmount);
		}
		if (instance.fuelTicks != previous.fuelTicks)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.fuelTicks);
		}
	}

	public static void Serialize(BufferStream stream, DiverPropulsionVehicle instance)
	{
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelAmount != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.fuelAmount);
		}
		if (instance.fuelTicks != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.fuelTicks);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NPCVendingMachine : IDisposable, IPooled, IProto<NPCVendingMachine>, IProto
{
	[NonSerialized]
	public NetworkableId attachedNpc;

	[NonSerialized]
	public float nextRefresh;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NPCVendingMachine instance)
	{
		if (instance.ShouldPool)
		{
			instance.attachedNpc = default(NetworkableId);
			instance.nextRefresh = 0f;
			Pool.Free<NPCVendingMachine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NPCVendingMachine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NPCVendingMachine instance)
	{
		instance.attachedNpc = attachedNpc;
		instance.nextRefresh = nextRefresh;
	}

	public NPCVendingMachine Copy()
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		CopyTo(nPCVendingMachine);
		return nPCVendingMachine;
	}

	public static NPCVendingMachine Deserialize(BufferStream stream)
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		Deserialize(stream, nPCVendingMachine, isDelta: false);
		return nPCVendingMachine;
	}

	public static NPCVendingMachine DeserializeLengthDelimited(BufferStream stream)
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		DeserializeLengthDelimited(stream, nPCVendingMachine, isDelta: false);
		return nPCVendingMachine;
	}

	public static NPCVendingMachine DeserializeLength(BufferStream stream, int length)
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		DeserializeLength(stream, length, nPCVendingMachine, isDelta: false);
		return nPCVendingMachine;
	}

	public static NPCVendingMachine Deserialize(byte[] buffer)
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nPCVendingMachine, isDelta: false);
		return nPCVendingMachine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NPCVendingMachine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NPCVendingMachine Deserialize(BufferStream stream, NPCVendingMachine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.attachedNpc = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.nextRefresh = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NPCVendingMachine DeserializeLengthDelimited(BufferStream stream, NPCVendingMachine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.attachedNpc = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.nextRefresh = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NPCVendingMachine DeserializeLength(BufferStream stream, int length, NPCVendingMachine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.attachedNpc = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.nextRefresh = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NPCVendingMachine instance, NPCVendingMachine previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.attachedNpc.Value);
		if (instance.nextRefresh != previous.nextRefresh)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.nextRefresh);
		}
	}

	public static void Serialize(BufferStream stream, NPCVendingMachine instance)
	{
		if (instance.attachedNpc != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.attachedNpc.Value);
		}
		if (instance.nextRefresh != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.nextRefresh);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref attachedNpc.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Mailbox : IDisposable, IPooled, IProto<Mailbox>, IProto
{
	[NonSerialized]
	public ItemContainer inventory;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Mailbox instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.inventory != null)
			{
				instance.inventory.ResetToPool();
				instance.inventory = null;
			}
			Pool.Free<Mailbox>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Mailbox with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Mailbox instance)
	{
		if (inventory != null)
		{
			if (instance.inventory == null)
			{
				instance.inventory = inventory.Copy();
			}
			else
			{
				inventory.CopyTo(instance.inventory);
			}
		}
		else
		{
			instance.inventory = null;
		}
	}

	public Mailbox Copy()
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		CopyTo(mailbox);
		return mailbox;
	}

	public static Mailbox Deserialize(BufferStream stream)
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		Deserialize(stream, mailbox, isDelta: false);
		return mailbox;
	}

	public static Mailbox DeserializeLengthDelimited(BufferStream stream)
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		DeserializeLengthDelimited(stream, mailbox, isDelta: false);
		return mailbox;
	}

	public static Mailbox DeserializeLength(BufferStream stream, int length)
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		DeserializeLength(stream, length, mailbox, isDelta: false);
		return mailbox;
	}

	public static Mailbox Deserialize(byte[] buffer)
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mailbox, isDelta: false);
		return mailbox;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Mailbox previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Mailbox Deserialize(BufferStream stream, Mailbox instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.inventory == null)
				{
					instance.inventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Mailbox DeserializeLengthDelimited(BufferStream stream, Mailbox instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.inventory == null)
				{
					instance.inventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Mailbox DeserializeLength(BufferStream stream, int length, Mailbox instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.inventory == null)
				{
					instance.inventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Mailbox instance, Mailbox previous)
	{
		if (instance.inventory == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.inventory, previous.inventory);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Mailbox instance)
	{
		if (instance.inventory == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.Serialize(stream, instance.inventory);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		inventory?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class GunWeaponMod : IDisposable, IPooled, IProto<GunWeaponMod>, IProto
{
	[NonSerialized]
	public int zoomLevel;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(GunWeaponMod instance)
	{
		if (instance.ShouldPool)
		{
			instance.zoomLevel = 0;
			Pool.Free<GunWeaponMod>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose GunWeaponMod with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(GunWeaponMod instance)
	{
		instance.zoomLevel = zoomLevel;
	}

	public GunWeaponMod Copy()
	{
		GunWeaponMod gunWeaponMod = Pool.Get<GunWeaponMod>();
		CopyTo(gunWeaponMod);
		return gunWeaponMod;
	}

	public static GunWeaponMod Deserialize(BufferStream stream)
	{
		GunWeaponMod gunWeaponMod = Pool.Get<GunWeaponMod>();
		Deserialize(stream, gunWeaponMod, isDelta: false);
		return gunWeaponMod;
	}

	public static GunWeaponMod DeserializeLengthDelimited(BufferStream stream)
	{
		GunWeaponMod gunWeaponMod = Pool.Get<GunWeaponMod>();
		DeserializeLengthDelimited(stream, gunWeaponMod, isDelta: false);
		return gunWeaponMod;
	}

	public static GunWeaponMod DeserializeLength(BufferStream stream, int length)
	{
		GunWeaponMod gunWeaponMod = Pool.Get<GunWeaponMod>();
		DeserializeLength(stream, length, gunWeaponMod, isDelta: false);
		return gunWeaponMod;
	}

	public static GunWeaponMod Deserialize(byte[] buffer)
	{
		GunWeaponMod gunWeaponMod = Pool.Get<GunWeaponMod>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, gunWeaponMod, isDelta: false);
		return gunWeaponMod;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, GunWeaponMod previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static GunWeaponMod Deserialize(BufferStream stream, GunWeaponMod instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.zoomLevel = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static GunWeaponMod DeserializeLengthDelimited(BufferStream stream, GunWeaponMod instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.zoomLevel = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static GunWeaponMod DeserializeLength(BufferStream stream, int length, GunWeaponMod instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.zoomLevel = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, GunWeaponMod instance, GunWeaponMod previous)
	{
		if (instance.zoomLevel != previous.zoomLevel)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.zoomLevel);
		}
	}

	public static void Serialize(BufferStream stream, GunWeaponMod instance)
	{
		if (instance.zoomLevel != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.zoomLevel);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseSculpture : IDisposable, IPooled, IProto<BaseSculpture>, IProto
{
	[NonSerialized]
	public uint crc;

	[NonSerialized]
	public int colourSelection;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseSculpture instance)
	{
		if (instance.ShouldPool)
		{
			instance.crc = 0u;
			instance.colourSelection = 0;
			Pool.Free<BaseSculpture>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseSculpture with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseSculpture instance)
	{
		instance.crc = crc;
		instance.colourSelection = colourSelection;
	}

	public BaseSculpture Copy()
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		CopyTo(baseSculpture);
		return baseSculpture;
	}

	public static BaseSculpture Deserialize(BufferStream stream)
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		Deserialize(stream, baseSculpture, isDelta: false);
		return baseSculpture;
	}

	public static BaseSculpture DeserializeLengthDelimited(BufferStream stream)
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		DeserializeLengthDelimited(stream, baseSculpture, isDelta: false);
		return baseSculpture;
	}

	public static BaseSculpture DeserializeLength(BufferStream stream, int length)
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		DeserializeLength(stream, length, baseSculpture, isDelta: false);
		return baseSculpture;
	}

	public static BaseSculpture Deserialize(byte[] buffer)
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseSculpture, isDelta: false);
		return baseSculpture;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseSculpture previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseSculpture Deserialize(BufferStream stream, BaseSculpture instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.colourSelection = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseSculpture DeserializeLengthDelimited(BufferStream stream, BaseSculpture instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.colourSelection = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseSculpture DeserializeLength(BufferStream stream, int length, BaseSculpture instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.colourSelection = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseSculpture instance, BaseSculpture previous)
	{
		if (instance.crc != previous.crc)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
		if (instance.colourSelection != previous.colourSelection)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourSelection);
		}
	}

	public static void Serialize(BufferStream stream, BaseSculpture instance)
	{
		if (instance.crc != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
		if (instance.colourSelection != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourSelection);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Catapult : IDisposable, IPooled, IProto<Catapult>, IProto
{
	[NonSerialized]
	public NetworkableId ammoStorageID;

	[NonSerialized]
	public float reloadProgress;

	[NonSerialized]
	public int ammoType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Catapult instance)
	{
		if (instance.ShouldPool)
		{
			instance.ammoStorageID = default(NetworkableId);
			instance.reloadProgress = 0f;
			instance.ammoType = 0;
			Pool.Free<Catapult>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Catapult with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Catapult instance)
	{
		instance.ammoStorageID = ammoStorageID;
		instance.reloadProgress = reloadProgress;
		instance.ammoType = ammoType;
	}

	public Catapult Copy()
	{
		Catapult catapult = Pool.Get<Catapult>();
		CopyTo(catapult);
		return catapult;
	}

	public static Catapult Deserialize(BufferStream stream)
	{
		Catapult catapult = Pool.Get<Catapult>();
		Deserialize(stream, catapult, isDelta: false);
		return catapult;
	}

	public static Catapult DeserializeLengthDelimited(BufferStream stream)
	{
		Catapult catapult = Pool.Get<Catapult>();
		DeserializeLengthDelimited(stream, catapult, isDelta: false);
		return catapult;
	}

	public static Catapult DeserializeLength(BufferStream stream, int length)
	{
		Catapult catapult = Pool.Get<Catapult>();
		DeserializeLength(stream, length, catapult, isDelta: false);
		return catapult;
	}

	public static Catapult Deserialize(byte[] buffer)
	{
		Catapult catapult = Pool.Get<Catapult>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, catapult, isDelta: false);
		return catapult;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Catapult previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Catapult Deserialize(BufferStream stream, Catapult instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.ammoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Catapult DeserializeLengthDelimited(BufferStream stream, Catapult instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Catapult DeserializeLength(BufferStream stream, int length, Catapult instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Catapult instance, Catapult previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.ammoStorageID.Value);
		if (instance.reloadProgress != previous.reloadProgress)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.reloadProgress);
		}
		if (instance.ammoType != previous.ammoType)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
	}

	public static void Serialize(BufferStream stream, Catapult instance)
	{
		if (instance.ammoStorageID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.ammoStorageID.Value);
		}
		if (instance.reloadProgress != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.reloadProgress);
		}
		if (instance.ammoType != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref ammoStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SiegeTower : IDisposable, IPooled, IProto<SiegeTower>, IProto
{
	[NonSerialized]
	public NetworkableId doorID;

	[NonSerialized]
	public NetworkableId drawBridgeID;

	[NonSerialized]
	public NetworkableId drawBridge2ID;

	[NonSerialized]
	public NetworkableId drawBridge3ID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SiegeTower instance)
	{
		if (instance.ShouldPool)
		{
			instance.doorID = default(NetworkableId);
			instance.drawBridgeID = default(NetworkableId);
			instance.drawBridge2ID = default(NetworkableId);
			instance.drawBridge3ID = default(NetworkableId);
			Pool.Free<SiegeTower>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SiegeTower with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SiegeTower instance)
	{
		instance.doorID = doorID;
		instance.drawBridgeID = drawBridgeID;
		instance.drawBridge2ID = drawBridge2ID;
		instance.drawBridge3ID = drawBridge3ID;
	}

	public SiegeTower Copy()
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		CopyTo(siegeTower);
		return siegeTower;
	}

	public static SiegeTower Deserialize(BufferStream stream)
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		Deserialize(stream, siegeTower, isDelta: false);
		return siegeTower;
	}

	public static SiegeTower DeserializeLengthDelimited(BufferStream stream)
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		DeserializeLengthDelimited(stream, siegeTower, isDelta: false);
		return siegeTower;
	}

	public static SiegeTower DeserializeLength(BufferStream stream, int length)
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		DeserializeLength(stream, length, siegeTower, isDelta: false);
		return siegeTower;
	}

	public static SiegeTower Deserialize(byte[] buffer)
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, siegeTower, isDelta: false);
		return siegeTower;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SiegeTower previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SiegeTower Deserialize(BufferStream stream, SiegeTower instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.drawBridgeID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.drawBridge2ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.drawBridge3ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SiegeTower DeserializeLengthDelimited(BufferStream stream, SiegeTower instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.drawBridgeID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.drawBridge2ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.drawBridge3ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SiegeTower DeserializeLength(BufferStream stream, int length, SiegeTower instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.drawBridgeID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.drawBridge2ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.drawBridge3ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SiegeTower instance, SiegeTower previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.doorID.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.drawBridgeID.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.drawBridge2ID.Value);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.drawBridge3ID.Value);
	}

	public static void Serialize(BufferStream stream, SiegeTower instance)
	{
		if (instance.doorID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.doorID.Value);
		}
		if (instance.drawBridgeID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.drawBridgeID.Value);
		}
		if (instance.drawBridge2ID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.drawBridge2ID.Value);
		}
		if (instance.drawBridge3ID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.drawBridge3ID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref doorID.Value);
		action(UidType.NetworkableId, ref drawBridgeID.Value);
		action(UidType.NetworkableId, ref drawBridge2ID.Value);
		action(UidType.NetworkableId, ref drawBridge3ID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Ballista : IDisposable, IPooled, IProto<Ballista>, IProto
{
	[NonSerialized]
	public NetworkableId gunID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Ballista instance)
	{
		if (instance.ShouldPool)
		{
			instance.gunID = default(NetworkableId);
			Pool.Free<Ballista>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Ballista with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Ballista instance)
	{
		instance.gunID = gunID;
	}

	public Ballista Copy()
	{
		Ballista ballista = Pool.Get<Ballista>();
		CopyTo(ballista);
		return ballista;
	}

	public static Ballista Deserialize(BufferStream stream)
	{
		Ballista ballista = Pool.Get<Ballista>();
		Deserialize(stream, ballista, isDelta: false);
		return ballista;
	}

	public static Ballista DeserializeLengthDelimited(BufferStream stream)
	{
		Ballista ballista = Pool.Get<Ballista>();
		DeserializeLengthDelimited(stream, ballista, isDelta: false);
		return ballista;
	}

	public static Ballista DeserializeLength(BufferStream stream, int length)
	{
		Ballista ballista = Pool.Get<Ballista>();
		DeserializeLength(stream, length, ballista, isDelta: false);
		return ballista;
	}

	public static Ballista Deserialize(byte[] buffer)
	{
		Ballista ballista = Pool.Get<Ballista>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ballista, isDelta: false);
		return ballista;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Ballista previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Ballista Deserialize(BufferStream stream, Ballista instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.gunID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Ballista DeserializeLengthDelimited(BufferStream stream, Ballista instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.gunID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Ballista DeserializeLength(BufferStream stream, int length, Ballista instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.gunID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Ballista instance, Ballista previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.gunID.Value);
	}

	public static void Serialize(BufferStream stream, Ballista instance)
	{
		if (instance.gunID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.gunID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref gunID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class BallistaGun : IDisposable, IPooled, IProto<BallistaGun>, IProto
{
	[NonSerialized]
	public Magazine magazine;

	[NonSerialized]
	public float reloadProgress;

	[NonSerialized]
	public Vector3 aimDir;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BallistaGun instance)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			if (instance.magazine != null)
			{
				instance.magazine.ResetToPool();
				instance.magazine = null;
			}
			instance.reloadProgress = 0f;
			instance.aimDir = default(Vector3);
			Pool.Free<BallistaGun>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BallistaGun with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BallistaGun instance)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (magazine != null)
		{
			if (instance.magazine == null)
			{
				instance.magazine = magazine.Copy();
			}
			else
			{
				magazine.CopyTo(instance.magazine);
			}
		}
		else
		{
			instance.magazine = null;
		}
		instance.reloadProgress = reloadProgress;
		instance.aimDir = aimDir;
	}

	public BallistaGun Copy()
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		CopyTo(ballistaGun);
		return ballistaGun;
	}

	public static BallistaGun Deserialize(BufferStream stream)
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		Deserialize(stream, ballistaGun, isDelta: false);
		return ballistaGun;
	}

	public static BallistaGun DeserializeLengthDelimited(BufferStream stream)
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		DeserializeLengthDelimited(stream, ballistaGun, isDelta: false);
		return ballistaGun;
	}

	public static BallistaGun DeserializeLength(BufferStream stream, int length)
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		DeserializeLength(stream, length, ballistaGun, isDelta: false);
		return ballistaGun;
	}

	public static BallistaGun Deserialize(byte[] buffer)
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ballistaGun, isDelta: false);
		return ballistaGun;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BallistaGun previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BallistaGun Deserialize(BufferStream stream, BallistaGun instance, bool isDelta)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.magazine == null)
				{
					instance.magazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.magazine, isDelta);
				}
				break;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				break;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static BallistaGun DeserializeLengthDelimited(BufferStream stream, BallistaGun instance, bool isDelta)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.magazine == null)
				{
					instance.magazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.magazine, isDelta);
				}
				break;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				break;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BallistaGun DeserializeLength(BufferStream stream, int length, BallistaGun instance, bool isDelta)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.magazine == null)
				{
					instance.magazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.magazine, isDelta);
				}
				break;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				break;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BallistaGun instance, BallistaGun previous)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (instance.magazine != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Magazine.SerializeDelta(stream, instance.magazine, previous.magazine);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field magazine (ProtoBuf.Magazine)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.reloadProgress != previous.reloadProgress)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.reloadProgress);
		}
		if (instance.aimDir != previous.aimDir)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aimDir, previous.aimDir);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, BallistaGun instance)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.magazine != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Magazine.Serialize(stream, instance.magazine);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field magazine (ProtoBuf.Magazine)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.reloadProgress != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.reloadProgress);
		}
		if (instance.aimDir != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aimDir);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		magazine?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BatteringRam : IDisposable, IPooled, IProto<BatteringRam>, IProto
{
	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public NetworkableId headID;

	[NonSerialized]
	public float steerInput;

	[NonSerialized]
	public float driveWheelVel;

	[NonSerialized]
	public float throttleInput;

	[NonSerialized]
	public float brakeInput;

	[NonSerialized]
	public float fuelFraction;

	[NonSerialized]
	public float doorAngle;

	[NonSerialized]
	public float time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BatteringRam instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelStorageID = default(NetworkableId);
			instance.headID = default(NetworkableId);
			instance.steerInput = 0f;
			instance.driveWheelVel = 0f;
			instance.throttleInput = 0f;
			instance.brakeInput = 0f;
			instance.fuelFraction = 0f;
			instance.doorAngle = 0f;
			instance.time = 0f;
			Pool.Free<BatteringRam>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BatteringRam with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BatteringRam instance)
	{
		instance.fuelStorageID = fuelStorageID;
		instance.headID = headID;
		instance.steerInput = steerInput;
		instance.driveWheelVel = driveWheelVel;
		instance.throttleInput = throttleInput;
		instance.brakeInput = brakeInput;
		instance.fuelFraction = fuelFraction;
		instance.doorAngle = doorAngle;
		instance.time = time;
	}

	public BatteringRam Copy()
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		CopyTo(batteringRam);
		return batteringRam;
	}

	public static BatteringRam Deserialize(BufferStream stream)
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		Deserialize(stream, batteringRam, isDelta: false);
		return batteringRam;
	}

	public static BatteringRam DeserializeLengthDelimited(BufferStream stream)
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		DeserializeLengthDelimited(stream, batteringRam, isDelta: false);
		return batteringRam;
	}

	public static BatteringRam DeserializeLength(BufferStream stream, int length)
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		DeserializeLength(stream, length, batteringRam, isDelta: false);
		return batteringRam;
	}

	public static BatteringRam Deserialize(byte[] buffer)
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, batteringRam, isDelta: false);
		return batteringRam;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BatteringRam previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BatteringRam Deserialize(BufferStream stream, BatteringRam instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.headID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 29:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.doorAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BatteringRam DeserializeLengthDelimited(BufferStream stream, BatteringRam instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.headID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 29:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.doorAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BatteringRam DeserializeLength(BufferStream stream, int length, BatteringRam instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.headID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 29:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.doorAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BatteringRam instance, BatteringRam previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.headID.Value);
		if (instance.steerInput != previous.steerInput)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != previous.driveWheelVel)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != previous.throttleInput)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != previous.brakeInput)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.doorAngle != previous.doorAngle)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.doorAngle);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public static void Serialize(BufferStream stream, BatteringRam instance)
	{
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.headID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.headID.Value);
		}
		if (instance.steerInput != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.doorAngle != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.doorAngle);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
		action(UidType.NetworkableId, ref headID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TemporaryRagdoll : IDisposable, IPooled, IProto<TemporaryRagdoll>, IProto
{
	[NonSerialized]
	public NetworkableId parentID;

	[NonSerialized]
	public int mountPose;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TemporaryRagdoll instance)
	{
		if (instance.ShouldPool)
		{
			instance.parentID = default(NetworkableId);
			instance.mountPose = 0;
			Pool.Free<TemporaryRagdoll>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TemporaryRagdoll with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TemporaryRagdoll instance)
	{
		instance.parentID = parentID;
		instance.mountPose = mountPose;
	}

	public TemporaryRagdoll Copy()
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		CopyTo(temporaryRagdoll);
		return temporaryRagdoll;
	}

	public static TemporaryRagdoll Deserialize(BufferStream stream)
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		Deserialize(stream, temporaryRagdoll, isDelta: false);
		return temporaryRagdoll;
	}

	public static TemporaryRagdoll DeserializeLengthDelimited(BufferStream stream)
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		DeserializeLengthDelimited(stream, temporaryRagdoll, isDelta: false);
		return temporaryRagdoll;
	}

	public static TemporaryRagdoll DeserializeLength(BufferStream stream, int length)
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		DeserializeLength(stream, length, temporaryRagdoll, isDelta: false);
		return temporaryRagdoll;
	}

	public static TemporaryRagdoll Deserialize(byte[] buffer)
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, temporaryRagdoll, isDelta: false);
		return temporaryRagdoll;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TemporaryRagdoll previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TemporaryRagdoll Deserialize(BufferStream stream, TemporaryRagdoll instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.mountPose = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TemporaryRagdoll DeserializeLengthDelimited(BufferStream stream, TemporaryRagdoll instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.mountPose = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TemporaryRagdoll DeserializeLength(BufferStream stream, int length, TemporaryRagdoll instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.mountPose = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TemporaryRagdoll instance, TemporaryRagdoll previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		if (instance.mountPose != previous.mountPose)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.mountPose);
		}
	}

	public static void Serialize(BufferStream stream, TemporaryRagdoll instance)
	{
		if (instance.parentID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		}
		if (instance.mountPose != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.mountPose);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref parentID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ConstructableEntity : IDisposable, IPooled, IProto<ConstructableEntity>, IProto
{
	[NonSerialized]
	public List<int> addedResources;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ConstructableEntity instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.addedResources != null)
			{
				List<int> list = instance.addedResources;
				Pool.FreeUnmanaged<int>(ref list);
				instance.addedResources = list;
			}
			Pool.Free<ConstructableEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ConstructableEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ConstructableEntity instance)
	{
		if (addedResources != null)
		{
			instance.addedResources = Pool.Get<List<int>>();
			for (int i = 0; i < addedResources.Count; i++)
			{
				int item = addedResources[i];
				instance.addedResources.Add(item);
			}
		}
		else
		{
			instance.addedResources = null;
		}
	}

	public ConstructableEntity Copy()
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		CopyTo(constructableEntity);
		return constructableEntity;
	}

	public static ConstructableEntity Deserialize(BufferStream stream)
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		Deserialize(stream, constructableEntity, isDelta: false);
		return constructableEntity;
	}

	public static ConstructableEntity DeserializeLengthDelimited(BufferStream stream)
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		DeserializeLengthDelimited(stream, constructableEntity, isDelta: false);
		return constructableEntity;
	}

	public static ConstructableEntity DeserializeLength(BufferStream stream, int length)
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		DeserializeLength(stream, length, constructableEntity, isDelta: false);
		return constructableEntity;
	}

	public static ConstructableEntity Deserialize(byte[] buffer)
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, constructableEntity, isDelta: false);
		return constructableEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ConstructableEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ConstructableEntity Deserialize(BufferStream stream, ConstructableEntity instance, bool isDelta)
	{
		if (!isDelta && instance.addedResources == null)
		{
			instance.addedResources = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.addedResources.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ConstructableEntity DeserializeLengthDelimited(BufferStream stream, ConstructableEntity instance, bool isDelta)
	{
		if (!isDelta && instance.addedResources == null)
		{
			instance.addedResources = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.addedResources.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ConstructableEntity DeserializeLength(BufferStream stream, int length, ConstructableEntity instance, bool isDelta)
	{
		if (!isDelta && instance.addedResources == null)
		{
			instance.addedResources = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.addedResources.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ConstructableEntity instance, ConstructableEntity previous)
	{
		if (instance.addedResources != null)
		{
			for (int i = 0; i < instance.addedResources.Count; i++)
			{
				int num = instance.addedResources[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public static void Serialize(BufferStream stream, ConstructableEntity instance)
	{
		if (instance.addedResources != null)
		{
			for (int i = 0; i < instance.addedResources.Count; i++)
			{
				int num = instance.addedResources[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ChickenStatus : IDisposable, IPooled, IProto<ChickenStatus>, IProto
{
	[NonSerialized]
	public NetworkableId spawnedChicken;

	[NonSerialized]
	public float timeUntilHatch;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ChickenStatus instance)
	{
		if (instance.ShouldPool)
		{
			instance.spawnedChicken = default(NetworkableId);
			instance.timeUntilHatch = 0f;
			Pool.Free<ChickenStatus>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ChickenStatus with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ChickenStatus instance)
	{
		instance.spawnedChicken = spawnedChicken;
		instance.timeUntilHatch = timeUntilHatch;
	}

	public ChickenStatus Copy()
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		CopyTo(chickenStatus);
		return chickenStatus;
	}

	public static ChickenStatus Deserialize(BufferStream stream)
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		Deserialize(stream, chickenStatus, isDelta: false);
		return chickenStatus;
	}

	public static ChickenStatus DeserializeLengthDelimited(BufferStream stream)
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		DeserializeLengthDelimited(stream, chickenStatus, isDelta: false);
		return chickenStatus;
	}

	public static ChickenStatus DeserializeLength(BufferStream stream, int length)
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		DeserializeLength(stream, length, chickenStatus, isDelta: false);
		return chickenStatus;
	}

	public static ChickenStatus Deserialize(byte[] buffer)
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, chickenStatus, isDelta: false);
		return chickenStatus;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ChickenStatus previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ChickenStatus Deserialize(BufferStream stream, ChickenStatus instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.spawnedChicken = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeUntilHatch = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ChickenStatus DeserializeLengthDelimited(BufferStream stream, ChickenStatus instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.spawnedChicken = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeUntilHatch = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ChickenStatus DeserializeLength(BufferStream stream, int length, ChickenStatus instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.spawnedChicken = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeUntilHatch = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ChickenStatus instance, ChickenStatus previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.spawnedChicken.Value);
		if (instance.timeUntilHatch != previous.timeUntilHatch)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeUntilHatch);
		}
	}

	public static void Serialize(BufferStream stream, ChickenStatus instance)
	{
		if (instance.spawnedChicken != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.spawnedChicken.Value);
		}
		if (instance.timeUntilHatch != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeUntilHatch);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref spawnedChicken.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ChickenCoop : IDisposable, IPooled, IProto<ChickenCoop>, IProto
{
	[NonSerialized]
	public List<ChickenStatus> chickens;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ChickenCoop instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.chickens != null)
		{
			for (int i = 0; i < instance.chickens.Count; i++)
			{
				if (instance.chickens[i] != null)
				{
					instance.chickens[i].ResetToPool();
					instance.chickens[i] = null;
				}
			}
			List<ChickenStatus> list = instance.chickens;
			Pool.Free<ChickenStatus>(ref list, false);
			instance.chickens = list;
		}
		Pool.Free<ChickenCoop>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ChickenCoop with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ChickenCoop instance)
	{
		if (chickens != null)
		{
			instance.chickens = Pool.Get<List<ChickenStatus>>();
			for (int i = 0; i < chickens.Count; i++)
			{
				ChickenStatus item = chickens[i].Copy();
				instance.chickens.Add(item);
			}
		}
		else
		{
			instance.chickens = null;
		}
	}

	public ChickenCoop Copy()
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		CopyTo(chickenCoop);
		return chickenCoop;
	}

	public static ChickenCoop Deserialize(BufferStream stream)
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		Deserialize(stream, chickenCoop, isDelta: false);
		return chickenCoop;
	}

	public static ChickenCoop DeserializeLengthDelimited(BufferStream stream)
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		DeserializeLengthDelimited(stream, chickenCoop, isDelta: false);
		return chickenCoop;
	}

	public static ChickenCoop DeserializeLength(BufferStream stream, int length)
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		DeserializeLength(stream, length, chickenCoop, isDelta: false);
		return chickenCoop;
	}

	public static ChickenCoop Deserialize(byte[] buffer)
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, chickenCoop, isDelta: false);
		return chickenCoop;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ChickenCoop previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ChickenCoop Deserialize(BufferStream stream, ChickenCoop instance, bool isDelta)
	{
		if (!isDelta && instance.chickens == null)
		{
			instance.chickens = Pool.Get<List<ChickenStatus>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.chickens.Add(ChickenStatus.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ChickenCoop DeserializeLengthDelimited(BufferStream stream, ChickenCoop instance, bool isDelta)
	{
		if (!isDelta && instance.chickens == null)
		{
			instance.chickens = Pool.Get<List<ChickenStatus>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.chickens.Add(ChickenStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ChickenCoop DeserializeLength(BufferStream stream, int length, ChickenCoop instance, bool isDelta)
	{
		if (!isDelta && instance.chickens == null)
		{
			instance.chickens = Pool.Get<List<ChickenStatus>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.chickens.Add(ChickenStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ChickenCoop instance, ChickenCoop previous)
	{
		if (instance.chickens == null)
		{
			return;
		}
		for (int i = 0; i < instance.chickens.Count; i++)
		{
			ChickenStatus chickenStatus = instance.chickens[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ChickenStatus.SerializeDelta(stream, chickenStatus, chickenStatus);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field chickens (ProtoBuf.ChickenStatus)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ChickenCoop instance)
	{
		if (instance.chickens == null)
		{
			return;
		}
		for (int i = 0; i < instance.chickens.Count; i++)
		{
			ChickenStatus instance2 = instance.chickens[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ChickenStatus.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field chickens (ProtoBuf.ChickenStatus)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (chickens != null)
		{
			for (int i = 0; i < chickens.Count; i++)
			{
				chickens[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class FarmableAnimal : IDisposable, IPooled, IProto<FarmableAnimal>, IProto
{
	[NonSerialized]
	public float hunger;

	[NonSerialized]
	public float thirst;

	[NonSerialized]
	public float love;

	[NonSerialized]
	public float sunlight;

	[NonSerialized]
	public string animalName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FarmableAnimal instance)
	{
		if (instance.ShouldPool)
		{
			instance.hunger = 0f;
			instance.thirst = 0f;
			instance.love = 0f;
			instance.sunlight = 0f;
			instance.animalName = string.Empty;
			Pool.Free<FarmableAnimal>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FarmableAnimal with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FarmableAnimal instance)
	{
		instance.hunger = hunger;
		instance.thirst = thirst;
		instance.love = love;
		instance.sunlight = sunlight;
		instance.animalName = animalName;
	}

	public FarmableAnimal Copy()
	{
		FarmableAnimal farmableAnimal = Pool.Get<FarmableAnimal>();
		CopyTo(farmableAnimal);
		return farmableAnimal;
	}

	public static FarmableAnimal Deserialize(BufferStream stream)
	{
		FarmableAnimal farmableAnimal = Pool.Get<FarmableAnimal>();
		Deserialize(stream, farmableAnimal, isDelta: false);
		return farmableAnimal;
	}

	public static FarmableAnimal DeserializeLengthDelimited(BufferStream stream)
	{
		FarmableAnimal farmableAnimal = Pool.Get<FarmableAnimal>();
		DeserializeLengthDelimited(stream, farmableAnimal, isDelta: false);
		return farmableAnimal;
	}

	public static FarmableAnimal DeserializeLength(BufferStream stream, int length)
	{
		FarmableAnimal farmableAnimal = Pool.Get<FarmableAnimal>();
		DeserializeLength(stream, length, farmableAnimal, isDelta: false);
		return farmableAnimal;
	}

	public static FarmableAnimal Deserialize(byte[] buffer)
	{
		FarmableAnimal farmableAnimal = Pool.Get<FarmableAnimal>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, farmableAnimal, isDelta: false);
		return farmableAnimal;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FarmableAnimal previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FarmableAnimal Deserialize(BufferStream stream, FarmableAnimal instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.hunger = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.thirst = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.love = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunlight = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.animalName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FarmableAnimal DeserializeLengthDelimited(BufferStream stream, FarmableAnimal instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.hunger = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.thirst = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.love = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunlight = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.animalName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FarmableAnimal DeserializeLength(BufferStream stream, int length, FarmableAnimal instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.hunger = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.thirst = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.love = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunlight = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.animalName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FarmableAnimal instance, FarmableAnimal previous)
	{
		if (instance.hunger != previous.hunger)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.hunger);
		}
		if (instance.thirst != previous.thirst)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.thirst);
		}
		if (instance.love != previous.love)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.love);
		}
		if (instance.sunlight != previous.sunlight)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.sunlight);
		}
		if (instance.animalName != null && instance.animalName != previous.animalName)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.animalName);
		}
	}

	public static void Serialize(BufferStream stream, FarmableAnimal instance)
	{
		if (instance.hunger != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.hunger);
		}
		if (instance.thirst != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.thirst);
		}
		if (instance.love != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.love);
		}
		if (instance.sunlight != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.sunlight);
		}
		if (instance.animalName != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.animalName);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Beehive : IDisposable, IPooled, IProto<Beehive>, IProto
{
	[NonSerialized]
	public float currentProgress;

	[NonSerialized]
	public float temperature;

	[NonSerialized]
	public bool inside;

	[NonSerialized]
	public float humidity;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Beehive instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentProgress = 0f;
			instance.temperature = 0f;
			instance.inside = false;
			instance.humidity = 0f;
			Pool.Free<Beehive>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Beehive with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Beehive instance)
	{
		instance.currentProgress = currentProgress;
		instance.temperature = temperature;
		instance.inside = inside;
		instance.humidity = humidity;
	}

	public Beehive Copy()
	{
		Beehive beehive = Pool.Get<Beehive>();
		CopyTo(beehive);
		return beehive;
	}

	public static Beehive Deserialize(BufferStream stream)
	{
		Beehive beehive = Pool.Get<Beehive>();
		Deserialize(stream, beehive, isDelta: false);
		return beehive;
	}

	public static Beehive DeserializeLengthDelimited(BufferStream stream)
	{
		Beehive beehive = Pool.Get<Beehive>();
		DeserializeLengthDelimited(stream, beehive, isDelta: false);
		return beehive;
	}

	public static Beehive DeserializeLength(BufferStream stream, int length)
	{
		Beehive beehive = Pool.Get<Beehive>();
		DeserializeLength(stream, length, beehive, isDelta: false);
		return beehive;
	}

	public static Beehive Deserialize(byte[] buffer)
	{
		Beehive beehive = Pool.Get<Beehive>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, beehive, isDelta: false);
		return beehive;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Beehive previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Beehive Deserialize(BufferStream stream, Beehive instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.currentProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.inside = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.humidity = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Beehive DeserializeLengthDelimited(BufferStream stream, Beehive instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.currentProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.inside = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.humidity = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Beehive DeserializeLength(BufferStream stream, int length, Beehive instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.currentProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.inside = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.humidity = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Beehive instance, Beehive previous)
	{
		if (instance.currentProgress != previous.currentProgress)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.currentProgress);
		}
		if (instance.temperature != previous.temperature)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.inside);
		if (instance.humidity != previous.humidity)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.humidity);
		}
	}

	public static void Serialize(BufferStream stream, Beehive instance)
	{
		if (instance.currentProgress != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.currentProgress);
		}
		if (instance.temperature != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.inside)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.inside);
		}
		if (instance.humidity != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.humidity);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BeeMasterSwarm : IDisposable, IPooled, IProto<BeeMasterSwarm>, IProto
{
	[NonSerialized]
	public float population;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BeeMasterSwarm instance)
	{
		if (instance.ShouldPool)
		{
			instance.population = 0f;
			Pool.Free<BeeMasterSwarm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BeeMasterSwarm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BeeMasterSwarm instance)
	{
		instance.population = population;
	}

	public BeeMasterSwarm Copy()
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		CopyTo(beeMasterSwarm);
		return beeMasterSwarm;
	}

	public static BeeMasterSwarm Deserialize(BufferStream stream)
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		Deserialize(stream, beeMasterSwarm, isDelta: false);
		return beeMasterSwarm;
	}

	public static BeeMasterSwarm DeserializeLengthDelimited(BufferStream stream)
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		DeserializeLengthDelimited(stream, beeMasterSwarm, isDelta: false);
		return beeMasterSwarm;
	}

	public static BeeMasterSwarm DeserializeLength(BufferStream stream, int length)
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		DeserializeLength(stream, length, beeMasterSwarm, isDelta: false);
		return beeMasterSwarm;
	}

	public static BeeMasterSwarm Deserialize(byte[] buffer)
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, beeMasterSwarm, isDelta: false);
		return beeMasterSwarm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BeeMasterSwarm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BeeMasterSwarm Deserialize(BufferStream stream, BeeMasterSwarm instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.population = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BeeMasterSwarm DeserializeLengthDelimited(BufferStream stream, BeeMasterSwarm instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.population = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BeeMasterSwarm DeserializeLength(BufferStream stream, int length, BeeMasterSwarm instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.population = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BeeMasterSwarm instance, BeeMasterSwarm previous)
	{
		if (instance.population != previous.population)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.population);
		}
	}

	public static void Serialize(BufferStream stream, BeeMasterSwarm instance)
	{
		if (instance.population != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.population);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ContainerCorpseData : IDisposable, IPooled, IProto<ContainerCorpseData>, IProto
{
	[NonSerialized]
	public ulong lockOwnerId;

	[NonSerialized]
	public CodeLock codeLock;

	[NonSerialized]
	public KeyLock keyLock;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ContainerCorpseData instance)
	{
		if (instance.ShouldPool)
		{
			instance.lockOwnerId = 0uL;
			if (instance.codeLock != null)
			{
				instance.codeLock.ResetToPool();
				instance.codeLock = null;
			}
			if (instance.keyLock != null)
			{
				instance.keyLock.ResetToPool();
				instance.keyLock = null;
			}
			Pool.Free<ContainerCorpseData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ContainerCorpseData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ContainerCorpseData instance)
	{
		instance.lockOwnerId = lockOwnerId;
		if (codeLock != null)
		{
			if (instance.codeLock == null)
			{
				instance.codeLock = codeLock.Copy();
			}
			else
			{
				codeLock.CopyTo(instance.codeLock);
			}
		}
		else
		{
			instance.codeLock = null;
		}
		if (keyLock != null)
		{
			if (instance.keyLock == null)
			{
				instance.keyLock = keyLock.Copy();
			}
			else
			{
				keyLock.CopyTo(instance.keyLock);
			}
		}
		else
		{
			instance.keyLock = null;
		}
	}

	public ContainerCorpseData Copy()
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		CopyTo(containerCorpseData);
		return containerCorpseData;
	}

	public static ContainerCorpseData Deserialize(BufferStream stream)
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		Deserialize(stream, containerCorpseData, isDelta: false);
		return containerCorpseData;
	}

	public static ContainerCorpseData DeserializeLengthDelimited(BufferStream stream)
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		DeserializeLengthDelimited(stream, containerCorpseData, isDelta: false);
		return containerCorpseData;
	}

	public static ContainerCorpseData DeserializeLength(BufferStream stream, int length)
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		DeserializeLength(stream, length, containerCorpseData, isDelta: false);
		return containerCorpseData;
	}

	public static ContainerCorpseData Deserialize(byte[] buffer)
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, containerCorpseData, isDelta: false);
		return containerCorpseData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ContainerCorpseData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ContainerCorpseData Deserialize(BufferStream stream, ContainerCorpseData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lockOwnerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.codeLock == null)
				{
					instance.codeLock = CodeLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					CodeLock.DeserializeLengthDelimited(stream, instance.codeLock, isDelta);
				}
				break;
			case 26:
				if (instance.keyLock == null)
				{
					instance.keyLock = KeyLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					KeyLock.DeserializeLengthDelimited(stream, instance.keyLock, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static ContainerCorpseData DeserializeLengthDelimited(BufferStream stream, ContainerCorpseData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lockOwnerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.codeLock == null)
				{
					instance.codeLock = CodeLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					CodeLock.DeserializeLengthDelimited(stream, instance.codeLock, isDelta);
				}
				break;
			case 26:
				if (instance.keyLock == null)
				{
					instance.keyLock = KeyLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					KeyLock.DeserializeLengthDelimited(stream, instance.keyLock, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ContainerCorpseData DeserializeLength(BufferStream stream, int length, ContainerCorpseData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lockOwnerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.codeLock == null)
				{
					instance.codeLock = CodeLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					CodeLock.DeserializeLengthDelimited(stream, instance.codeLock, isDelta);
				}
				break;
			case 26:
				if (instance.keyLock == null)
				{
					instance.keyLock = KeyLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					KeyLock.DeserializeLengthDelimited(stream, instance.keyLock, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ContainerCorpseData instance, ContainerCorpseData previous)
	{
		if (instance.lockOwnerId != previous.lockOwnerId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lockOwnerId);
		}
		if (instance.codeLock != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CodeLock.SerializeDelta(stream, instance.codeLock, previous.codeLock);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.keyLock != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			KeyLock.SerializeDelta(stream, instance.keyLock, previous.keyLock);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyLock (ProtoBuf.KeyLock)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, ContainerCorpseData instance)
	{
		if (instance.lockOwnerId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lockOwnerId);
		}
		if (instance.codeLock != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CodeLock.Serialize(stream, instance.codeLock);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.keyLock != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			KeyLock.Serialize(stream, instance.keyLock);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyLock (ProtoBuf.KeyLock)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		codeLock?.InspectUids(action);
		keyLock?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class VineMountable : IDisposable, IPooled, IProto<VineMountable>, IProto
{
	[NonSerialized]
	public Vector3 anchorPoint;

	[NonSerialized]
	public VineDestination originPoint;

	[NonSerialized]
	public List<VineDestination> destinations;

	[NonSerialized]
	public VineDestination currentLocation;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VineMountable instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.anchorPoint = default(Vector3);
		if (instance.originPoint != null)
		{
			instance.originPoint.ResetToPool();
			instance.originPoint = null;
		}
		if (instance.destinations != null)
		{
			for (int i = 0; i < instance.destinations.Count; i++)
			{
				if (instance.destinations[i] != null)
				{
					instance.destinations[i].ResetToPool();
					instance.destinations[i] = null;
				}
			}
			List<VineDestination> list = instance.destinations;
			Pool.Free<VineDestination>(ref list, false);
			instance.destinations = list;
		}
		if (instance.currentLocation != null)
		{
			instance.currentLocation.ResetToPool();
			instance.currentLocation = null;
		}
		Pool.Free<VineMountable>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VineMountable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VineMountable instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.anchorPoint = anchorPoint;
		if (originPoint != null)
		{
			if (instance.originPoint == null)
			{
				instance.originPoint = originPoint.Copy();
			}
			else
			{
				originPoint.CopyTo(instance.originPoint);
			}
		}
		else
		{
			instance.originPoint = null;
		}
		if (destinations != null)
		{
			instance.destinations = Pool.Get<List<VineDestination>>();
			for (int i = 0; i < destinations.Count; i++)
			{
				VineDestination item = destinations[i].Copy();
				instance.destinations.Add(item);
			}
		}
		else
		{
			instance.destinations = null;
		}
		if (currentLocation != null)
		{
			if (instance.currentLocation == null)
			{
				instance.currentLocation = currentLocation.Copy();
			}
			else
			{
				currentLocation.CopyTo(instance.currentLocation);
			}
		}
		else
		{
			instance.currentLocation = null;
		}
	}

	public VineMountable Copy()
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		CopyTo(vineMountable);
		return vineMountable;
	}

	public static VineMountable Deserialize(BufferStream stream)
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		Deserialize(stream, vineMountable, isDelta: false);
		return vineMountable;
	}

	public static VineMountable DeserializeLengthDelimited(BufferStream stream)
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		DeserializeLengthDelimited(stream, vineMountable, isDelta: false);
		return vineMountable;
	}

	public static VineMountable DeserializeLength(BufferStream stream, int length)
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		DeserializeLength(stream, length, vineMountable, isDelta: false);
		return vineMountable;
	}

	public static VineMountable Deserialize(byte[] buffer)
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vineMountable, isDelta: false);
		return vineMountable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VineMountable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VineMountable Deserialize(BufferStream stream, VineMountable instance, bool isDelta)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.destinations == null)
		{
			instance.destinations = Pool.Get<List<VineDestination>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.anchorPoint, isDelta);
				break;
			case 18:
				if (instance.originPoint == null)
				{
					instance.originPoint = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.originPoint, isDelta);
				}
				break;
			case 26:
				instance.destinations.Add(VineDestination.DeserializeLengthDelimited(stream));
				break;
			case 34:
				if (instance.currentLocation == null)
				{
					instance.currentLocation = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.currentLocation, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static VineMountable DeserializeLengthDelimited(BufferStream stream, VineMountable instance, bool isDelta)
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.destinations == null)
		{
			instance.destinations = Pool.Get<List<VineDestination>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.anchorPoint, isDelta);
				break;
			case 18:
				if (instance.originPoint == null)
				{
					instance.originPoint = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.originPoint, isDelta);
				}
				break;
			case 26:
				instance.destinations.Add(VineDestination.DeserializeLengthDelimited(stream));
				break;
			case 34:
				if (instance.currentLocation == null)
				{
					instance.currentLocation = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.currentLocation, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VineMountable DeserializeLength(BufferStream stream, int length, VineMountable instance, bool isDelta)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.destinations == null)
		{
			instance.destinations = Pool.Get<List<VineDestination>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.anchorPoint, isDelta);
				break;
			case 18:
				if (instance.originPoint == null)
				{
					instance.originPoint = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.originPoint, isDelta);
				}
				break;
			case 26:
				instance.destinations.Add(VineDestination.DeserializeLengthDelimited(stream));
				break;
			case 34:
				if (instance.currentLocation == null)
				{
					instance.currentLocation = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.currentLocation, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VineMountable instance, VineMountable previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.anchorPoint != previous.anchorPoint)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.anchorPoint, previous.anchorPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field anchorPoint (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.originPoint != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			VineDestination.SerializeDelta(stream, instance.originPoint, previous.originPoint);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPoint (ProtoBuf.VineDestination)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.destinations != null)
		{
			for (int i = 0; i < instance.destinations.Count; i++)
			{
				VineDestination vineDestination = instance.destinations[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				VineDestination.SerializeDelta(stream, vineDestination, vineDestination);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destinations (ProtoBuf.VineDestination)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.currentLocation != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			VineDestination.SerializeDelta(stream, instance.currentLocation, previous.currentLocation);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field currentLocation (ProtoBuf.VineDestination)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
	}

	public static void Serialize(BufferStream stream, VineMountable instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.anchorPoint != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.anchorPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field anchorPoint (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.originPoint != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			VineDestination.Serialize(stream, instance.originPoint);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPoint (ProtoBuf.VineDestination)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.destinations != null)
		{
			for (int i = 0; i < instance.destinations.Count; i++)
			{
				VineDestination instance2 = instance.destinations[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				VineDestination.Serialize(stream, instance2);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destinations (ProtoBuf.VineDestination)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.currentLocation != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			VineDestination.Serialize(stream, instance.currentLocation);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field currentLocation (ProtoBuf.VineDestination)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		originPoint?.InspectUids(action);
		if (destinations != null)
		{
			for (int i = 0; i < destinations.Count; i++)
			{
				destinations[i]?.InspectUids(action);
			}
		}
		currentLocation?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TreeRespawn : IDisposable, IPooled, IProto<TreeRespawn>, IProto
{
	[NonSerialized]
	public float timeToRespawn;

	[NonSerialized]
	public int treeIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TreeRespawn instance)
	{
		if (instance.ShouldPool)
		{
			instance.timeToRespawn = 0f;
			instance.treeIndex = 0;
			Pool.Free<TreeRespawn>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TreeRespawn with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TreeRespawn instance)
	{
		instance.timeToRespawn = timeToRespawn;
		instance.treeIndex = treeIndex;
	}

	public TreeRespawn Copy()
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		CopyTo(treeRespawn);
		return treeRespawn;
	}

	public static TreeRespawn Deserialize(BufferStream stream)
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		Deserialize(stream, treeRespawn, isDelta: false);
		return treeRespawn;
	}

	public static TreeRespawn DeserializeLengthDelimited(BufferStream stream)
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		DeserializeLengthDelimited(stream, treeRespawn, isDelta: false);
		return treeRespawn;
	}

	public static TreeRespawn DeserializeLength(BufferStream stream, int length)
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		DeserializeLength(stream, length, treeRespawn, isDelta: false);
		return treeRespawn;
	}

	public static TreeRespawn Deserialize(byte[] buffer)
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, treeRespawn, isDelta: false);
		return treeRespawn;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TreeRespawn previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TreeRespawn Deserialize(BufferStream stream, TreeRespawn instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.timeToRespawn = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.treeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TreeRespawn DeserializeLengthDelimited(BufferStream stream, TreeRespawn instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.timeToRespawn = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.treeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TreeRespawn DeserializeLength(BufferStream stream, int length, TreeRespawn instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.timeToRespawn = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.treeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TreeRespawn instance, TreeRespawn previous)
	{
		if (instance.timeToRespawn != previous.timeToRespawn)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.timeToRespawn);
		}
		if (instance.treeIndex != previous.treeIndex)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.treeIndex);
		}
	}

	public static void Serialize(BufferStream stream, TreeRespawn instance)
	{
		if (instance.timeToRespawn != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.timeToRespawn);
		}
		if (instance.treeIndex != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.treeIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VineTree : IDisposable, IPooled, IProto<VineTree>, IProto
{
	[NonSerialized]
	public List<NetworkableId> spawnedVines;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VineTree instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.spawnedVines != null)
			{
				List<NetworkableId> list = instance.spawnedVines;
				Pool.FreeUnmanaged<NetworkableId>(ref list);
				instance.spawnedVines = list;
			}
			Pool.Free<VineTree>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VineTree with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VineTree instance)
	{
		if (spawnedVines != null)
		{
			instance.spawnedVines = Pool.Get<List<NetworkableId>>();
			for (int i = 0; i < spawnedVines.Count; i++)
			{
				NetworkableId item = spawnedVines[i];
				instance.spawnedVines.Add(item);
			}
		}
		else
		{
			instance.spawnedVines = null;
		}
	}

	public VineTree Copy()
	{
		VineTree vineTree = Pool.Get<VineTree>();
		CopyTo(vineTree);
		return vineTree;
	}

	public static VineTree Deserialize(BufferStream stream)
	{
		VineTree vineTree = Pool.Get<VineTree>();
		Deserialize(stream, vineTree, isDelta: false);
		return vineTree;
	}

	public static VineTree DeserializeLengthDelimited(BufferStream stream)
	{
		VineTree vineTree = Pool.Get<VineTree>();
		DeserializeLengthDelimited(stream, vineTree, isDelta: false);
		return vineTree;
	}

	public static VineTree DeserializeLength(BufferStream stream, int length)
	{
		VineTree vineTree = Pool.Get<VineTree>();
		DeserializeLength(stream, length, vineTree, isDelta: false);
		return vineTree;
	}

	public static VineTree Deserialize(byte[] buffer)
	{
		VineTree vineTree = Pool.Get<VineTree>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vineTree, isDelta: false);
		return vineTree;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VineTree previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VineTree Deserialize(BufferStream stream, VineTree instance, bool isDelta)
	{
		if (!isDelta && instance.spawnedVines == null)
		{
			instance.spawnedVines = Pool.Get<List<NetworkableId>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.spawnedVines.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VineTree DeserializeLengthDelimited(BufferStream stream, VineTree instance, bool isDelta)
	{
		if (!isDelta && instance.spawnedVines == null)
		{
			instance.spawnedVines = Pool.Get<List<NetworkableId>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.spawnedVines.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VineTree DeserializeLength(BufferStream stream, int length, VineTree instance, bool isDelta)
	{
		if (!isDelta && instance.spawnedVines == null)
		{
			instance.spawnedVines = Pool.Get<List<NetworkableId>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.spawnedVines.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VineTree instance, VineTree previous)
	{
		if (instance.spawnedVines != null)
		{
			for (int i = 0; i < instance.spawnedVines.Count; i++)
			{
				NetworkableId networkableId = instance.spawnedVines[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public static void Serialize(BufferStream stream, VineTree instance)
	{
		if (instance.spawnedVines != null)
		{
			for (int i = 0; i < instance.spawnedVines.Count; i++)
			{
				NetworkableId networkableId = instance.spawnedVines[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < spawnedVines.Count; i++)
		{
			NetworkableId value = spawnedVines[i];
			action(UidType.NetworkableId, ref value.Value);
			spawnedVines[i] = value;
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VineDestination : IDisposable, IPooled, IProto<VineDestination>, IProto
{
	[NonSerialized]
	public NetworkableId targetTree;

	[NonSerialized]
	public int index;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VineDestination instance)
	{
		if (instance.ShouldPool)
		{
			instance.targetTree = default(NetworkableId);
			instance.index = 0;
			Pool.Free<VineDestination>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VineDestination with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VineDestination instance)
	{
		instance.targetTree = targetTree;
		instance.index = index;
	}

	public VineDestination Copy()
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		CopyTo(vineDestination);
		return vineDestination;
	}

	public static VineDestination Deserialize(BufferStream stream)
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		Deserialize(stream, vineDestination, isDelta: false);
		return vineDestination;
	}

	public static VineDestination DeserializeLengthDelimited(BufferStream stream)
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		DeserializeLengthDelimited(stream, vineDestination, isDelta: false);
		return vineDestination;
	}

	public static VineDestination DeserializeLength(BufferStream stream, int length)
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		DeserializeLength(stream, length, vineDestination, isDelta: false);
		return vineDestination;
	}

	public static VineDestination Deserialize(byte[] buffer)
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vineDestination, isDelta: false);
		return vineDestination;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VineDestination previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VineDestination Deserialize(BufferStream stream, VineDestination instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetTree = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VineDestination DeserializeLengthDelimited(BufferStream stream, VineDestination instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetTree = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VineDestination DeserializeLength(BufferStream stream, int length, VineDestination instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetTree = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VineDestination instance, VineDestination previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetTree.Value);
		if (instance.index != previous.index)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
	}

	public static void Serialize(BufferStream stream, VineDestination instance)
	{
		if (instance.targetTree != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetTree.Value);
		}
		if (instance.index != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetTree.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class StaticRespawnAreaData : IDisposable, IPooled, IProto<StaticRespawnAreaData>, IProto
{
	[NonSerialized]
	public List<ulong> authorizedUsers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(StaticRespawnAreaData instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.authorizedUsers != null)
			{
				List<ulong> list = instance.authorizedUsers;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.authorizedUsers = list;
			}
			Pool.Free<StaticRespawnAreaData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose StaticRespawnAreaData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(StaticRespawnAreaData instance)
	{
		if (authorizedUsers != null)
		{
			instance.authorizedUsers = Pool.Get<List<ulong>>();
			for (int i = 0; i < authorizedUsers.Count; i++)
			{
				ulong item = authorizedUsers[i];
				instance.authorizedUsers.Add(item);
			}
		}
		else
		{
			instance.authorizedUsers = null;
		}
	}

	public StaticRespawnAreaData Copy()
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		CopyTo(staticRespawnAreaData);
		return staticRespawnAreaData;
	}

	public static StaticRespawnAreaData Deserialize(BufferStream stream)
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		Deserialize(stream, staticRespawnAreaData, isDelta: false);
		return staticRespawnAreaData;
	}

	public static StaticRespawnAreaData DeserializeLengthDelimited(BufferStream stream)
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		DeserializeLengthDelimited(stream, staticRespawnAreaData, isDelta: false);
		return staticRespawnAreaData;
	}

	public static StaticRespawnAreaData DeserializeLength(BufferStream stream, int length)
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		DeserializeLength(stream, length, staticRespawnAreaData, isDelta: false);
		return staticRespawnAreaData;
	}

	public static StaticRespawnAreaData Deserialize(byte[] buffer)
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, staticRespawnAreaData, isDelta: false);
		return staticRespawnAreaData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, StaticRespawnAreaData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static StaticRespawnAreaData Deserialize(BufferStream stream, StaticRespawnAreaData instance, bool isDelta)
	{
		if (!isDelta && instance.authorizedUsers == null)
		{
			instance.authorizedUsers = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.authorizedUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static StaticRespawnAreaData DeserializeLengthDelimited(BufferStream stream, StaticRespawnAreaData instance, bool isDelta)
	{
		if (!isDelta && instance.authorizedUsers == null)
		{
			instance.authorizedUsers = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.authorizedUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static StaticRespawnAreaData DeserializeLength(BufferStream stream, int length, StaticRespawnAreaData instance, bool isDelta)
	{
		if (!isDelta && instance.authorizedUsers == null)
		{
			instance.authorizedUsers = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.authorizedUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, StaticRespawnAreaData instance, StaticRespawnAreaData previous)
	{
		if (instance.authorizedUsers != null)
		{
			for (int i = 0; i < instance.authorizedUsers.Count; i++)
			{
				ulong val = instance.authorizedUsers[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, StaticRespawnAreaData instance)
	{
		if (instance.authorizedUsers != null)
		{
			for (int i = 0; i < instance.authorizedUsers.Count; i++)
			{
				ulong val = instance.authorizedUsers[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Mannequin : IDisposable, IPooled, IProto<Mannequin>, IProto
{
	public class ClothingItem : IDisposable, IPooled, IProto<ClothingItem>, IProto
	{
		[NonSerialized]
		public int itemId;

		[NonSerialized]
		public ulong skin;

		[NonSerialized]
		public ItemId uid;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ClothingItem instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemId = 0;
				instance.skin = 0uL;
				instance.uid = default(ItemId);
				Pool.Free<ClothingItem>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ClothingItem with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ClothingItem instance)
		{
			instance.itemId = itemId;
			instance.skin = skin;
			instance.uid = uid;
		}

		public ClothingItem Copy()
		{
			ClothingItem clothingItem = Pool.Get<ClothingItem>();
			CopyTo(clothingItem);
			return clothingItem;
		}

		public static ClothingItem Deserialize(BufferStream stream)
		{
			ClothingItem clothingItem = Pool.Get<ClothingItem>();
			Deserialize(stream, clothingItem, isDelta: false);
			return clothingItem;
		}

		public static ClothingItem DeserializeLengthDelimited(BufferStream stream)
		{
			ClothingItem clothingItem = Pool.Get<ClothingItem>();
			DeserializeLengthDelimited(stream, clothingItem, isDelta: false);
			return clothingItem;
		}

		public static ClothingItem DeserializeLength(BufferStream stream, int length)
		{
			ClothingItem clothingItem = Pool.Get<ClothingItem>();
			DeserializeLength(stream, length, clothingItem, isDelta: false);
			return clothingItem;
		}

		public static ClothingItem Deserialize(byte[] buffer)
		{
			ClothingItem clothingItem = Pool.Get<ClothingItem>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, clothingItem, isDelta: false);
			return clothingItem;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ClothingItem previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ClothingItem Deserialize(BufferStream stream, ClothingItem instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.skin = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.uid = new ItemId(ProtocolParser.ReadUInt64(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ClothingItem DeserializeLengthDelimited(BufferStream stream, ClothingItem instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.skin = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.uid = new ItemId(ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ClothingItem DeserializeLength(BufferStream stream, int length, ClothingItem instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.skin = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.uid = new ItemId(ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ClothingItem instance, ClothingItem previous)
		{
			if (instance.itemId != previous.itemId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.skin != previous.skin)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.skin);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		}

		public static void Serialize(BufferStream stream, ClothingItem instance)
		{
			if (instance.itemId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.skin != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.skin);
			}
			if (instance.uid != default(ItemId))
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.uid.Value);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.ItemId, ref uid.Value);
		}
	}

	[NonSerialized]
	public List<ClothingItem> clothingItems;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Mannequin instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.clothingItems != null)
		{
			for (int i = 0; i < instance.clothingItems.Count; i++)
			{
				if (instance.clothingItems[i] != null)
				{
					instance.clothingItems[i].ResetToPool();
					instance.clothingItems[i] = null;
				}
			}
			List<ClothingItem> list = instance.clothingItems;
			Pool.Free<ClothingItem>(ref list, false);
			instance.clothingItems = list;
		}
		Pool.Free<Mannequin>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Mannequin with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Mannequin instance)
	{
		if (clothingItems != null)
		{
			instance.clothingItems = Pool.Get<List<ClothingItem>>();
			for (int i = 0; i < clothingItems.Count; i++)
			{
				ClothingItem item = clothingItems[i].Copy();
				instance.clothingItems.Add(item);
			}
		}
		else
		{
			instance.clothingItems = null;
		}
	}

	public Mannequin Copy()
	{
		Mannequin mannequin = Pool.Get<Mannequin>();
		CopyTo(mannequin);
		return mannequin;
	}

	public static Mannequin Deserialize(BufferStream stream)
	{
		Mannequin mannequin = Pool.Get<Mannequin>();
		Deserialize(stream, mannequin, isDelta: false);
		return mannequin;
	}

	public static Mannequin DeserializeLengthDelimited(BufferStream stream)
	{
		Mannequin mannequin = Pool.Get<Mannequin>();
		DeserializeLengthDelimited(stream, mannequin, isDelta: false);
		return mannequin;
	}

	public static Mannequin DeserializeLength(BufferStream stream, int length)
	{
		Mannequin mannequin = Pool.Get<Mannequin>();
		DeserializeLength(stream, length, mannequin, isDelta: false);
		return mannequin;
	}

	public static Mannequin Deserialize(byte[] buffer)
	{
		Mannequin mannequin = Pool.Get<Mannequin>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mannequin, isDelta: false);
		return mannequin;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Mannequin previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Mannequin Deserialize(BufferStream stream, Mannequin instance, bool isDelta)
	{
		if (!isDelta && instance.clothingItems == null)
		{
			instance.clothingItems = Pool.Get<List<ClothingItem>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.clothingItems.Add(ClothingItem.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Mannequin DeserializeLengthDelimited(BufferStream stream, Mannequin instance, bool isDelta)
	{
		if (!isDelta && instance.clothingItems == null)
		{
			instance.clothingItems = Pool.Get<List<ClothingItem>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.clothingItems.Add(ClothingItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Mannequin DeserializeLength(BufferStream stream, int length, Mannequin instance, bool isDelta)
	{
		if (!isDelta && instance.clothingItems == null)
		{
			instance.clothingItems = Pool.Get<List<ClothingItem>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.clothingItems.Add(ClothingItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Mannequin instance, Mannequin previous)
	{
		if (instance.clothingItems == null)
		{
			return;
		}
		for (int i = 0; i < instance.clothingItems.Count; i++)
		{
			ClothingItem clothingItem = instance.clothingItems[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ClothingItem.SerializeDelta(stream, clothingItem, clothingItem);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field clothingItems (ProtoBuf.Mannequin.ClothingItem)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, Mannequin instance)
	{
		if (instance.clothingItems == null)
		{
			return;
		}
		for (int i = 0; i < instance.clothingItems.Count; i++)
		{
			ClothingItem instance2 = instance.clothingItems[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ClothingItem.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field clothingItems (ProtoBuf.Mannequin.ClothingItem)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (clothingItems != null)
		{
			for (int i = 0; i < clothingItems.Count; i++)
			{
				clothingItems[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseMelee : IDisposable, IPooled, IProto<BaseMelee>, IProto
{
	[NonSerialized]
	public bool canThrowAsProjectile;

	[NonSerialized]
	public bool onlyThrowAsProjectile;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseMelee instance)
	{
		if (instance.ShouldPool)
		{
			instance.canThrowAsProjectile = false;
			instance.onlyThrowAsProjectile = false;
			Pool.Free<BaseMelee>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseMelee with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseMelee instance)
	{
		instance.canThrowAsProjectile = canThrowAsProjectile;
		instance.onlyThrowAsProjectile = onlyThrowAsProjectile;
	}

	public BaseMelee Copy()
	{
		BaseMelee baseMelee = Pool.Get<BaseMelee>();
		CopyTo(baseMelee);
		return baseMelee;
	}

	public static BaseMelee Deserialize(BufferStream stream)
	{
		BaseMelee baseMelee = Pool.Get<BaseMelee>();
		Deserialize(stream, baseMelee, isDelta: false);
		return baseMelee;
	}

	public static BaseMelee DeserializeLengthDelimited(BufferStream stream)
	{
		BaseMelee baseMelee = Pool.Get<BaseMelee>();
		DeserializeLengthDelimited(stream, baseMelee, isDelta: false);
		return baseMelee;
	}

	public static BaseMelee DeserializeLength(BufferStream stream, int length)
	{
		BaseMelee baseMelee = Pool.Get<BaseMelee>();
		DeserializeLength(stream, length, baseMelee, isDelta: false);
		return baseMelee;
	}

	public static BaseMelee Deserialize(byte[] buffer)
	{
		BaseMelee baseMelee = Pool.Get<BaseMelee>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseMelee, isDelta: false);
		return baseMelee;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseMelee previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseMelee Deserialize(BufferStream stream, BaseMelee instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.canThrowAsProjectile = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.onlyThrowAsProjectile = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseMelee DeserializeLengthDelimited(BufferStream stream, BaseMelee instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.canThrowAsProjectile = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.onlyThrowAsProjectile = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseMelee DeserializeLength(BufferStream stream, int length, BaseMelee instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.canThrowAsProjectile = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.onlyThrowAsProjectile = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseMelee instance, BaseMelee previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.canThrowAsProjectile);
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.onlyThrowAsProjectile);
	}

	public static void Serialize(BufferStream stream, BaseMelee instance)
	{
		if (instance.canThrowAsProjectile)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.canThrowAsProjectile);
		}
		if (instance.onlyThrowAsProjectile)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.onlyThrowAsProjectile);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Door : IDisposable, IPooled, IProto<Door>, IProto
{
	[NonSerialized]
	public bool canNpcOpen;

	[NonSerialized]
	public bool canHandOpen;

	[NonSerialized]
	public bool isSecurityDoor;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Door instance)
	{
		if (instance.ShouldPool)
		{
			instance.canNpcOpen = false;
			instance.canHandOpen = false;
			instance.isSecurityDoor = false;
			Pool.Free<Door>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Door with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Door instance)
	{
		instance.canNpcOpen = canNpcOpen;
		instance.canHandOpen = canHandOpen;
		instance.isSecurityDoor = isSecurityDoor;
	}

	public Door Copy()
	{
		Door door = Pool.Get<Door>();
		CopyTo(door);
		return door;
	}

	public static Door Deserialize(BufferStream stream)
	{
		Door door = Pool.Get<Door>();
		Deserialize(stream, door, isDelta: false);
		return door;
	}

	public static Door DeserializeLengthDelimited(BufferStream stream)
	{
		Door door = Pool.Get<Door>();
		DeserializeLengthDelimited(stream, door, isDelta: false);
		return door;
	}

	public static Door DeserializeLength(BufferStream stream, int length)
	{
		Door door = Pool.Get<Door>();
		DeserializeLength(stream, length, door, isDelta: false);
		return door;
	}

	public static Door Deserialize(byte[] buffer)
	{
		Door door = Pool.Get<Door>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, door, isDelta: false);
		return door;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Door previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Door Deserialize(BufferStream stream, Door instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.canNpcOpen = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.canHandOpen = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.isSecurityDoor = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Door DeserializeLengthDelimited(BufferStream stream, Door instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.canNpcOpen = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.canHandOpen = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.isSecurityDoor = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Door DeserializeLength(BufferStream stream, int length, Door instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.canNpcOpen = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.canHandOpen = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.isSecurityDoor = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Door instance, Door previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.canNpcOpen);
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.canHandOpen);
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.isSecurityDoor);
	}

	public static void Serialize(BufferStream stream, Door instance)
	{
		if (instance.canNpcOpen)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.canNpcOpen);
		}
		if (instance.canHandOpen)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.canHandOpen);
		}
		if (instance.isSecurityDoor)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.isSecurityDoor);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerNameID : IDisposable, IPooled, IProto<PlayerNameID>, IProto
{
	[NonSerialized]
	public string username;

	[NonSerialized]
	public ulong userid;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerNameID instance)
	{
		if (instance.ShouldPool)
		{
			instance.username = string.Empty;
			instance.userid = 0uL;
			Pool.Free<PlayerNameID>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerNameID with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerNameID instance)
	{
		instance.username = username;
		instance.userid = userid;
	}

	public PlayerNameID Copy()
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		CopyTo(playerNameID);
		return playerNameID;
	}

	public static PlayerNameID Deserialize(BufferStream stream)
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		Deserialize(stream, playerNameID, isDelta: false);
		return playerNameID;
	}

	public static PlayerNameID DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		DeserializeLengthDelimited(stream, playerNameID, isDelta: false);
		return playerNameID;
	}

	public static PlayerNameID DeserializeLength(BufferStream stream, int length)
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		DeserializeLength(stream, length, playerNameID, isDelta: false);
		return playerNameID;
	}

	public static PlayerNameID Deserialize(byte[] buffer)
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerNameID, isDelta: false);
		return playerNameID;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerNameID previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerNameID Deserialize(BufferStream stream, PlayerNameID instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerNameID DeserializeLengthDelimited(BufferStream stream, PlayerNameID instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerNameID DeserializeLength(BufferStream stream, int length, PlayerNameID instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerNameID instance, PlayerNameID previous)
	{
		if (instance.username != previous.username)
		{
			if (instance.username == null)
			{
				throw new ArgumentNullException("username", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.username);
		}
		if (instance.userid != previous.userid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
	}

	public static void Serialize(BufferStream stream, PlayerNameID instance)
	{
		if (instance.username == null)
		{
			throw new ArgumentNullException("username", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.username);
		if (instance.userid != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class DemoHeader : IDisposable, IPooled, IProto<DemoHeader>, IProto
{
	[NonSerialized]
	public uint version;

	[NonSerialized]
	public string level;

	[NonSerialized]
	public uint levelSeed;

	[NonSerialized]
	public uint levelSize;

	[NonSerialized]
	public string checksum;

	[NonSerialized]
	public ulong localclient;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 rotation;

	[NonSerialized]
	public string levelUrl;

	[NonSerialized]
	public long recordedTime;

	[NonSerialized]
	public long length;

	[NonSerialized]
	public List<FileStorageCacheData> fileStorage;

	[NonSerialized]
	public bool nexus;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoHeader instance)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.version = 0u;
		instance.level = string.Empty;
		instance.levelSeed = 0u;
		instance.levelSize = 0u;
		instance.checksum = string.Empty;
		instance.localclient = 0uL;
		instance.position = default(Vector3);
		instance.rotation = default(Vector3);
		instance.levelUrl = string.Empty;
		instance.recordedTime = 0L;
		instance.length = 0L;
		if (instance.fileStorage != null)
		{
			for (int i = 0; i < instance.fileStorage.Count; i++)
			{
				if (instance.fileStorage[i] != null)
				{
					instance.fileStorage[i].ResetToPool();
					instance.fileStorage[i] = null;
				}
			}
			List<FileStorageCacheData> list = instance.fileStorage;
			Pool.Free<FileStorageCacheData>(ref list, false);
			instance.fileStorage = list;
		}
		instance.nexus = false;
		Pool.Free<DemoHeader>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoHeader with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoHeader instance)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.version = version;
		instance.level = level;
		instance.levelSeed = levelSeed;
		instance.levelSize = levelSize;
		instance.checksum = checksum;
		instance.localclient = localclient;
		instance.position = position;
		instance.rotation = rotation;
		instance.levelUrl = levelUrl;
		instance.recordedTime = recordedTime;
		instance.length = length;
		if (fileStorage != null)
		{
			instance.fileStorage = Pool.Get<List<FileStorageCacheData>>();
			for (int i = 0; i < fileStorage.Count; i++)
			{
				FileStorageCacheData item = fileStorage[i].Copy();
				instance.fileStorage.Add(item);
			}
		}
		else
		{
			instance.fileStorage = null;
		}
		instance.nexus = nexus;
	}

	public DemoHeader Copy()
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		CopyTo(demoHeader);
		return demoHeader;
	}

	public static DemoHeader Deserialize(BufferStream stream)
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		Deserialize(stream, demoHeader, isDelta: false);
		return demoHeader;
	}

	public static DemoHeader DeserializeLengthDelimited(BufferStream stream)
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		DeserializeLengthDelimited(stream, demoHeader, isDelta: false);
		return demoHeader;
	}

	public static DemoHeader DeserializeLength(BufferStream stream, int length)
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		DeserializeLength(stream, length, demoHeader, isDelta: false);
		return demoHeader;
	}

	public static DemoHeader Deserialize(byte[] buffer)
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoHeader, isDelta: false);
		return demoHeader;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoHeader previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoHeader Deserialize(BufferStream stream, DemoHeader instance, bool isDelta)
	{
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.fileStorage == null)
		{
			instance.fileStorage = Pool.Get<List<FileStorageCacheData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.version = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.localclient = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 74:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.recordedTime = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.length = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 98:
				instance.fileStorage.Add(FileStorageCacheData.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.nexus = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoHeader DeserializeLengthDelimited(BufferStream stream, DemoHeader instance, bool isDelta)
	{
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.fileStorage == null)
		{
			instance.fileStorage = Pool.Get<List<FileStorageCacheData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.version = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.localclient = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 74:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.recordedTime = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.length = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 98:
				instance.fileStorage.Add(FileStorageCacheData.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.nexus = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoHeader DeserializeLength(BufferStream stream, int length, DemoHeader instance, bool isDelta)
	{
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.fileStorage == null)
		{
			instance.fileStorage = Pool.Get<List<FileStorageCacheData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.version = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.localclient = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 74:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.recordedTime = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.length = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 98:
				instance.fileStorage.Add(FileStorageCacheData.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.nexus = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoHeader instance, DemoHeader previous)
	{
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		if (instance.version != previous.version)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.version);
		}
		if (instance.level != previous.level)
		{
			if (instance.level == null)
			{
				throw new ArgumentNullException("level", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.level);
		}
		if (instance.levelSeed != previous.levelSeed)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.levelSeed);
		}
		if (instance.levelSize != previous.levelSize)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.levelSize);
		}
		if (instance.checksum != null && instance.checksum != previous.checksum)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.checksum);
		}
		if (instance.localclient != previous.localclient)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.localclient);
		}
		if (instance.position != previous.position)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rotation, previous.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.levelUrl != previous.levelUrl)
		{
			if (instance.levelUrl == null)
			{
				throw new ArgumentNullException("levelUrl", "Required by proto specification.");
			}
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.levelUrl);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.recordedTime);
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.length);
		if (instance.fileStorage != null)
		{
			for (int i = 0; i < instance.fileStorage.Count; i++)
			{
				FileStorageCacheData fileStorageCacheData = instance.fileStorage[i];
				stream.WriteByte(98);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int num5 = stream.Position;
				FileStorageCacheData.SerializeDelta(stream, fileStorageCacheData, fileStorageCacheData);
				int val = stream.Position - num5;
				Span<byte> span3 = range3.GetSpan();
				int num6 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num6 < 5)
				{
					span3[num6 - 1] |= 128;
					while (num6 < 4)
					{
						span3[num6++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		stream.WriteByte(104);
		ProtocolParser.WriteBool(stream, instance.nexus);
	}

	public static void Serialize(BufferStream stream, DemoHeader instance)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if (instance.version != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.version);
		}
		if (instance.level == null)
		{
			throw new ArgumentNullException("level", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.level);
		if (instance.levelSeed != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.levelSeed);
		}
		if (instance.levelSize != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.levelSize);
		}
		if (instance.checksum != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.checksum);
		}
		if (instance.localclient != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.localclient);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.levelUrl == null)
		{
			throw new ArgumentNullException("levelUrl", "Required by proto specification.");
		}
		stream.WriteByte(74);
		ProtocolParser.WriteString(stream, instance.levelUrl);
		if (instance.recordedTime != 0L)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.recordedTime);
		}
		if (instance.length != 0L)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.length);
		}
		if (instance.fileStorage != null)
		{
			for (int i = 0; i < instance.fileStorage.Count; i++)
			{
				FileStorageCacheData instance2 = instance.fileStorage[i];
				stream.WriteByte(98);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int num5 = stream.Position;
				FileStorageCacheData.Serialize(stream, instance2);
				int val = stream.Position - num5;
				Span<byte> span3 = range3.GetSpan();
				int num6 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num6 < 5)
				{
					span3[num6 - 1] |= 128;
					while (num6 < 4)
					{
						span3[num6++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.nexus)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteBool(stream, instance.nexus);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (fileStorage != null)
		{
			for (int i = 0; i < fileStorage.Count; i++)
			{
				fileStorage[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class FileStorageCacheData : IDisposable, IPooled, IProto<FileStorageCacheData>, IProto
{
	[NonSerialized]
	public byte[] data;

	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public uint numId;

	[NonSerialized]
	public uint crc;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FileStorageCacheData instance)
	{
		if (instance.ShouldPool)
		{
			instance.data = null;
			instance.entityId = default(NetworkableId);
			instance.numId = 0u;
			instance.crc = 0u;
			Pool.Free<FileStorageCacheData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FileStorageCacheData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FileStorageCacheData instance)
	{
		if (data == null)
		{
			instance.data = null;
		}
		else
		{
			instance.data = new byte[data.Length];
			Array.Copy(data, instance.data, instance.data.Length);
		}
		instance.entityId = entityId;
		instance.numId = numId;
		instance.crc = crc;
	}

	public FileStorageCacheData Copy()
	{
		FileStorageCacheData fileStorageCacheData = Pool.Get<FileStorageCacheData>();
		CopyTo(fileStorageCacheData);
		return fileStorageCacheData;
	}

	public static FileStorageCacheData Deserialize(BufferStream stream)
	{
		FileStorageCacheData fileStorageCacheData = Pool.Get<FileStorageCacheData>();
		Deserialize(stream, fileStorageCacheData, isDelta: false);
		return fileStorageCacheData;
	}

	public static FileStorageCacheData DeserializeLengthDelimited(BufferStream stream)
	{
		FileStorageCacheData fileStorageCacheData = Pool.Get<FileStorageCacheData>();
		DeserializeLengthDelimited(stream, fileStorageCacheData, isDelta: false);
		return fileStorageCacheData;
	}

	public static FileStorageCacheData DeserializeLength(BufferStream stream, int length)
	{
		FileStorageCacheData fileStorageCacheData = Pool.Get<FileStorageCacheData>();
		DeserializeLength(stream, length, fileStorageCacheData, isDelta: false);
		return fileStorageCacheData;
	}

	public static FileStorageCacheData Deserialize(byte[] buffer)
	{
		FileStorageCacheData fileStorageCacheData = Pool.Get<FileStorageCacheData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, fileStorageCacheData, isDelta: false);
		return fileStorageCacheData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FileStorageCacheData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FileStorageCacheData Deserialize(BufferStream stream, FileStorageCacheData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case 16:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.numId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FileStorageCacheData DeserializeLengthDelimited(BufferStream stream, FileStorageCacheData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case 16:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.numId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FileStorageCacheData DeserializeLength(BufferStream stream, int length, FileStorageCacheData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case 16:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.numId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FileStorageCacheData instance, FileStorageCacheData previous)
	{
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteBytes(stream, instance.data);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		if (instance.numId != previous.numId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.numId);
		}
		if (instance.crc != previous.crc)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
	}

	public static void Serialize(BufferStream stream, FileStorageCacheData instance)
	{
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteBytes(stream, instance.data);
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.numId != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.numId);
		}
		if (instance.crc != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShot : IDisposable, IPooled, IProto<DemoShot>, IProto
{
	[NonSerialized]
	public string shotName;

	[NonSerialized]
	public string demoName;

	[NonSerialized]
	public float shotStart;

	[NonSerialized]
	public float shotLength;

	[NonSerialized]
	public DemoShotVectorTrack camPos;

	[NonSerialized]
	public DemoShotQuaternionTrack camRot;

	[NonSerialized]
	public DemoShotFloatTrack camFov;

	[NonSerialized]
	public DemoShotFloatTrack camDofDist;

	[NonSerialized]
	public DemoShotFloatTrack camDofFocalSize;

	[NonSerialized]
	public DemoShotFloatTrack camDofAperture;

	[NonSerialized]
	public DemoShotParentTrack camParent;

	[NonSerialized]
	public string folderName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShot instance)
	{
		if (instance.ShouldPool)
		{
			instance.shotName = string.Empty;
			instance.demoName = string.Empty;
			instance.shotStart = 0f;
			instance.shotLength = 0f;
			if (instance.camPos != null)
			{
				instance.camPos.ResetToPool();
				instance.camPos = null;
			}
			if (instance.camRot != null)
			{
				instance.camRot.ResetToPool();
				instance.camRot = null;
			}
			if (instance.camFov != null)
			{
				instance.camFov.ResetToPool();
				instance.camFov = null;
			}
			if (instance.camDofDist != null)
			{
				instance.camDofDist.ResetToPool();
				instance.camDofDist = null;
			}
			if (instance.camDofFocalSize != null)
			{
				instance.camDofFocalSize.ResetToPool();
				instance.camDofFocalSize = null;
			}
			if (instance.camDofAperture != null)
			{
				instance.camDofAperture.ResetToPool();
				instance.camDofAperture = null;
			}
			if (instance.camParent != null)
			{
				instance.camParent.ResetToPool();
				instance.camParent = null;
			}
			instance.folderName = string.Empty;
			Pool.Free<DemoShot>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShot with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShot instance)
	{
		instance.shotName = shotName;
		instance.demoName = demoName;
		instance.shotStart = shotStart;
		instance.shotLength = shotLength;
		if (camPos != null)
		{
			if (instance.camPos == null)
			{
				instance.camPos = camPos.Copy();
			}
			else
			{
				camPos.CopyTo(instance.camPos);
			}
		}
		else
		{
			instance.camPos = null;
		}
		if (camRot != null)
		{
			if (instance.camRot == null)
			{
				instance.camRot = camRot.Copy();
			}
			else
			{
				camRot.CopyTo(instance.camRot);
			}
		}
		else
		{
			instance.camRot = null;
		}
		if (camFov != null)
		{
			if (instance.camFov == null)
			{
				instance.camFov = camFov.Copy();
			}
			else
			{
				camFov.CopyTo(instance.camFov);
			}
		}
		else
		{
			instance.camFov = null;
		}
		if (camDofDist != null)
		{
			if (instance.camDofDist == null)
			{
				instance.camDofDist = camDofDist.Copy();
			}
			else
			{
				camDofDist.CopyTo(instance.camDofDist);
			}
		}
		else
		{
			instance.camDofDist = null;
		}
		if (camDofFocalSize != null)
		{
			if (instance.camDofFocalSize == null)
			{
				instance.camDofFocalSize = camDofFocalSize.Copy();
			}
			else
			{
				camDofFocalSize.CopyTo(instance.camDofFocalSize);
			}
		}
		else
		{
			instance.camDofFocalSize = null;
		}
		if (camDofAperture != null)
		{
			if (instance.camDofAperture == null)
			{
				instance.camDofAperture = camDofAperture.Copy();
			}
			else
			{
				camDofAperture.CopyTo(instance.camDofAperture);
			}
		}
		else
		{
			instance.camDofAperture = null;
		}
		if (camParent != null)
		{
			if (instance.camParent == null)
			{
				instance.camParent = camParent.Copy();
			}
			else
			{
				camParent.CopyTo(instance.camParent);
			}
		}
		else
		{
			instance.camParent = null;
		}
		instance.folderName = folderName;
	}

	public DemoShot Copy()
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		CopyTo(demoShot);
		return demoShot;
	}

	public static DemoShot Deserialize(BufferStream stream)
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		Deserialize(stream, demoShot, isDelta: false);
		return demoShot;
	}

	public static DemoShot DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		DeserializeLengthDelimited(stream, demoShot, isDelta: false);
		return demoShot;
	}

	public static DemoShot DeserializeLength(BufferStream stream, int length)
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		DeserializeLength(stream, length, demoShot, isDelta: false);
		return demoShot;
	}

	public static DemoShot Deserialize(byte[] buffer)
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShot, isDelta: false);
		return demoShot;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShot previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShot Deserialize(BufferStream stream, DemoShot instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.shotName = ProtocolParser.ReadString(stream);
				break;
			case 18:
				instance.demoName = ProtocolParser.ReadString(stream);
				break;
			case 29:
				instance.shotStart = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.shotLength = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.camPos == null)
				{
					instance.camPos = DemoShotVectorTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotVectorTrack.DeserializeLengthDelimited(stream, instance.camPos, isDelta);
				}
				break;
			case 50:
				if (instance.camRot == null)
				{
					instance.camRot = DemoShotQuaternionTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotQuaternionTrack.DeserializeLengthDelimited(stream, instance.camRot, isDelta);
				}
				break;
			case 58:
				if (instance.camFov == null)
				{
					instance.camFov = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camFov, isDelta);
				}
				break;
			case 74:
				if (instance.camDofDist == null)
				{
					instance.camDofDist = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofDist, isDelta);
				}
				break;
			case 82:
				if (instance.camDofFocalSize == null)
				{
					instance.camDofFocalSize = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofFocalSize, isDelta);
				}
				break;
			case 90:
				if (instance.camDofAperture == null)
				{
					instance.camDofAperture = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofAperture, isDelta);
				}
				break;
			case 98:
				if (instance.camParent == null)
				{
					instance.camParent = DemoShotParentTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotParentTrack.DeserializeLengthDelimited(stream, instance.camParent, isDelta);
				}
				break;
			case 66:
				instance.folderName = ProtocolParser.ReadString(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static DemoShot DeserializeLengthDelimited(BufferStream stream, DemoShot instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shotName = ProtocolParser.ReadString(stream);
				break;
			case 18:
				instance.demoName = ProtocolParser.ReadString(stream);
				break;
			case 29:
				instance.shotStart = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.shotLength = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.camPos == null)
				{
					instance.camPos = DemoShotVectorTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotVectorTrack.DeserializeLengthDelimited(stream, instance.camPos, isDelta);
				}
				break;
			case 50:
				if (instance.camRot == null)
				{
					instance.camRot = DemoShotQuaternionTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotQuaternionTrack.DeserializeLengthDelimited(stream, instance.camRot, isDelta);
				}
				break;
			case 58:
				if (instance.camFov == null)
				{
					instance.camFov = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camFov, isDelta);
				}
				break;
			case 74:
				if (instance.camDofDist == null)
				{
					instance.camDofDist = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofDist, isDelta);
				}
				break;
			case 82:
				if (instance.camDofFocalSize == null)
				{
					instance.camDofFocalSize = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofFocalSize, isDelta);
				}
				break;
			case 90:
				if (instance.camDofAperture == null)
				{
					instance.camDofAperture = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofAperture, isDelta);
				}
				break;
			case 98:
				if (instance.camParent == null)
				{
					instance.camParent = DemoShotParentTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotParentTrack.DeserializeLengthDelimited(stream, instance.camParent, isDelta);
				}
				break;
			case 66:
				instance.folderName = ProtocolParser.ReadString(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShot DeserializeLength(BufferStream stream, int length, DemoShot instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shotName = ProtocolParser.ReadString(stream);
				break;
			case 18:
				instance.demoName = ProtocolParser.ReadString(stream);
				break;
			case 29:
				instance.shotStart = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.shotLength = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.camPos == null)
				{
					instance.camPos = DemoShotVectorTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotVectorTrack.DeserializeLengthDelimited(stream, instance.camPos, isDelta);
				}
				break;
			case 50:
				if (instance.camRot == null)
				{
					instance.camRot = DemoShotQuaternionTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotQuaternionTrack.DeserializeLengthDelimited(stream, instance.camRot, isDelta);
				}
				break;
			case 58:
				if (instance.camFov == null)
				{
					instance.camFov = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camFov, isDelta);
				}
				break;
			case 74:
				if (instance.camDofDist == null)
				{
					instance.camDofDist = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofDist, isDelta);
				}
				break;
			case 82:
				if (instance.camDofFocalSize == null)
				{
					instance.camDofFocalSize = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofFocalSize, isDelta);
				}
				break;
			case 90:
				if (instance.camDofAperture == null)
				{
					instance.camDofAperture = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofAperture, isDelta);
				}
				break;
			case 98:
				if (instance.camParent == null)
				{
					instance.camParent = DemoShotParentTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotParentTrack.DeserializeLengthDelimited(stream, instance.camParent, isDelta);
				}
				break;
			case 66:
				instance.folderName = ProtocolParser.ReadString(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShot instance, DemoShot previous)
	{
		if (instance.shotName != previous.shotName)
		{
			if (instance.shotName == null)
			{
				throw new ArgumentNullException("shotName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.shotName);
		}
		if (instance.demoName != previous.demoName)
		{
			if (instance.demoName == null)
			{
				throw new ArgumentNullException("demoName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.demoName);
		}
		if (instance.shotStart != previous.shotStart)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.shotStart);
		}
		if (instance.shotLength != previous.shotLength)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.shotLength);
		}
		if (instance.camPos == null)
		{
			throw new ArgumentNullException("camPos", "Required by proto specification.");
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		DemoShotVectorTrack.SerializeDelta(stream, instance.camPos, previous.camPos);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camPos (ProtoBuf.DemoShotVectorTrack)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
		if (instance.camRot == null)
		{
			throw new ArgumentNullException("camRot", "Required by proto specification.");
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range2 = stream.GetRange(3);
		int position2 = stream.Position;
		DemoShotQuaternionTrack.SerializeDelta(stream, instance.camRot, previous.camRot);
		int num3 = stream.Position - position2;
		if (num3 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camRot (ProtoBuf.DemoShotQuaternionTrack)");
		}
		Span<byte> span2 = range2.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)num3, span2, 0);
		if (num4 < 3)
		{
			span2[num4 - 1] |= 128;
			while (num4 < 2)
			{
				span2[num4++] = 128;
			}
			span2[2] = 0;
		}
		if (instance.camFov == null)
		{
			throw new ArgumentNullException("camFov", "Required by proto specification.");
		}
		stream.WriteByte(58);
		BufferStream.RangeHandle range3 = stream.GetRange(3);
		int position3 = stream.Position;
		DemoShotFloatTrack.SerializeDelta(stream, instance.camFov, previous.camFov);
		int num5 = stream.Position - position3;
		if (num5 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camFov (ProtoBuf.DemoShotFloatTrack)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num6 = ProtocolParser.WriteUInt32((uint)num5, span3, 0);
		if (num6 < 3)
		{
			span3[num6 - 1] |= 128;
			while (num6 < 2)
			{
				span3[num6++] = 128;
			}
			span3[2] = 0;
		}
		if (instance.camDofDist != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range4 = stream.GetRange(3);
			int position4 = stream.Position;
			DemoShotFloatTrack.SerializeDelta(stream, instance.camDofDist, previous.camDofDist);
			int num7 = stream.Position - position4;
			if (num7 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofDist (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span4 = range4.GetSpan();
			int num8 = ProtocolParser.WriteUInt32((uint)num7, span4, 0);
			if (num8 < 3)
			{
				span4[num8 - 1] |= 128;
				while (num8 < 2)
				{
					span4[num8++] = 128;
				}
				span4[2] = 0;
			}
		}
		if (instance.camDofFocalSize != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range5 = stream.GetRange(3);
			int position5 = stream.Position;
			DemoShotFloatTrack.SerializeDelta(stream, instance.camDofFocalSize, previous.camDofFocalSize);
			int num9 = stream.Position - position5;
			if (num9 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofFocalSize (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span5 = range5.GetSpan();
			int num10 = ProtocolParser.WriteUInt32((uint)num9, span5, 0);
			if (num10 < 3)
			{
				span5[num10 - 1] |= 128;
				while (num10 < 2)
				{
					span5[num10++] = 128;
				}
				span5[2] = 0;
			}
		}
		if (instance.camDofAperture != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range6 = stream.GetRange(3);
			int position6 = stream.Position;
			DemoShotFloatTrack.SerializeDelta(stream, instance.camDofAperture, previous.camDofAperture);
			int num11 = stream.Position - position6;
			if (num11 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofAperture (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span6 = range6.GetSpan();
			int num12 = ProtocolParser.WriteUInt32((uint)num11, span6, 0);
			if (num12 < 3)
			{
				span6[num12 - 1] |= 128;
				while (num12 < 2)
				{
					span6[num12++] = 128;
				}
				span6[2] = 0;
			}
		}
		if (instance.camParent != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range7 = stream.GetRange(5);
			int position7 = stream.Position;
			DemoShotParentTrack.SerializeDelta(stream, instance.camParent, previous.camParent);
			int val = stream.Position - position7;
			Span<byte> span7 = range7.GetSpan();
			int num13 = ProtocolParser.WriteUInt32((uint)val, span7, 0);
			if (num13 < 5)
			{
				span7[num13 - 1] |= 128;
				while (num13 < 4)
				{
					span7[num13++] = 128;
				}
				span7[4] = 0;
			}
		}
		if (instance.folderName != null && instance.folderName != previous.folderName)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.folderName);
		}
	}

	public static void Serialize(BufferStream stream, DemoShot instance)
	{
		if (instance.shotName == null)
		{
			throw new ArgumentNullException("shotName", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.shotName);
		if (instance.demoName == null)
		{
			throw new ArgumentNullException("demoName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.demoName);
		if (instance.shotStart != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.shotStart);
		}
		if (instance.shotLength != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.shotLength);
		}
		if (instance.camPos == null)
		{
			throw new ArgumentNullException("camPos", "Required by proto specification.");
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		DemoShotVectorTrack.Serialize(stream, instance.camPos);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camPos (ProtoBuf.DemoShotVectorTrack)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
		if (instance.camRot == null)
		{
			throw new ArgumentNullException("camRot", "Required by proto specification.");
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range2 = stream.GetRange(3);
		int position2 = stream.Position;
		DemoShotQuaternionTrack.Serialize(stream, instance.camRot);
		int num3 = stream.Position - position2;
		if (num3 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camRot (ProtoBuf.DemoShotQuaternionTrack)");
		}
		Span<byte> span2 = range2.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)num3, span2, 0);
		if (num4 < 3)
		{
			span2[num4 - 1] |= 128;
			while (num4 < 2)
			{
				span2[num4++] = 128;
			}
			span2[2] = 0;
		}
		if (instance.camFov == null)
		{
			throw new ArgumentNullException("camFov", "Required by proto specification.");
		}
		stream.WriteByte(58);
		BufferStream.RangeHandle range3 = stream.GetRange(3);
		int position3 = stream.Position;
		DemoShotFloatTrack.Serialize(stream, instance.camFov);
		int num5 = stream.Position - position3;
		if (num5 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camFov (ProtoBuf.DemoShotFloatTrack)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num6 = ProtocolParser.WriteUInt32((uint)num5, span3, 0);
		if (num6 < 3)
		{
			span3[num6 - 1] |= 128;
			while (num6 < 2)
			{
				span3[num6++] = 128;
			}
			span3[2] = 0;
		}
		if (instance.camDofDist != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range4 = stream.GetRange(3);
			int position4 = stream.Position;
			DemoShotFloatTrack.Serialize(stream, instance.camDofDist);
			int num7 = stream.Position - position4;
			if (num7 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofDist (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span4 = range4.GetSpan();
			int num8 = ProtocolParser.WriteUInt32((uint)num7, span4, 0);
			if (num8 < 3)
			{
				span4[num8 - 1] |= 128;
				while (num8 < 2)
				{
					span4[num8++] = 128;
				}
				span4[2] = 0;
			}
		}
		if (instance.camDofFocalSize != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range5 = stream.GetRange(3);
			int position5 = stream.Position;
			DemoShotFloatTrack.Serialize(stream, instance.camDofFocalSize);
			int num9 = stream.Position - position5;
			if (num9 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofFocalSize (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span5 = range5.GetSpan();
			int num10 = ProtocolParser.WriteUInt32((uint)num9, span5, 0);
			if (num10 < 3)
			{
				span5[num10 - 1] |= 128;
				while (num10 < 2)
				{
					span5[num10++] = 128;
				}
				span5[2] = 0;
			}
		}
		if (instance.camDofAperture != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range6 = stream.GetRange(3);
			int position6 = stream.Position;
			DemoShotFloatTrack.Serialize(stream, instance.camDofAperture);
			int num11 = stream.Position - position6;
			if (num11 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofAperture (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span6 = range6.GetSpan();
			int num12 = ProtocolParser.WriteUInt32((uint)num11, span6, 0);
			if (num12 < 3)
			{
				span6[num12 - 1] |= 128;
				while (num12 < 2)
				{
					span6[num12++] = 128;
				}
				span6[2] = 0;
			}
		}
		if (instance.camParent != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range7 = stream.GetRange(5);
			int position7 = stream.Position;
			DemoShotParentTrack.Serialize(stream, instance.camParent);
			int val = stream.Position - position7;
			Span<byte> span7 = range7.GetSpan();
			int num13 = ProtocolParser.WriteUInt32((uint)val, span7, 0);
			if (num13 < 5)
			{
				span7[num13 - 1] |= 128;
				while (num13 < 4)
				{
					span7[num13++] = 128;
				}
				span7[4] = 0;
			}
		}
		if (instance.folderName != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.folderName);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		camPos?.InspectUids(action);
		camRot?.InspectUids(action);
		camFov?.InspectUids(action);
		camDofDist?.InspectUids(action);
		camDofFocalSize?.InspectUids(action);
		camDofAperture?.InspectUids(action);
		camParent?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShotVectorTrack : IDisposable, IPooled, IProto<DemoShotVectorTrack>, IProto
{
	[NonSerialized]
	public long trackType;

	[NonSerialized]
	public List<DemoShotVectorKeyframe> keyframes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShotVectorTrack instance)
	{
		if (instance.ShouldPool)
		{
			instance.trackType = 0L;
			if (instance.keyframes != null)
			{
				List<DemoShotVectorKeyframe> list = instance.keyframes;
				Pool.FreeUnmanaged<DemoShotVectorKeyframe>(ref list);
				instance.keyframes = list;
			}
			Pool.Free<DemoShotVectorTrack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShotVectorTrack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShotVectorTrack instance)
	{
		instance.trackType = trackType;
		if (keyframes != null)
		{
			instance.keyframes = Pool.Get<List<DemoShotVectorKeyframe>>();
			for (int i = 0; i < keyframes.Count; i++)
			{
				DemoShotVectorKeyframe item = keyframes[i];
				instance.keyframes.Add(item);
			}
		}
		else
		{
			instance.keyframes = null;
		}
	}

	public DemoShotVectorTrack Copy()
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		CopyTo(demoShotVectorTrack);
		return demoShotVectorTrack;
	}

	public static DemoShotVectorTrack Deserialize(BufferStream stream)
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		Deserialize(stream, demoShotVectorTrack, isDelta: false);
		return demoShotVectorTrack;
	}

	public static DemoShotVectorTrack DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		DeserializeLengthDelimited(stream, demoShotVectorTrack, isDelta: false);
		return demoShotVectorTrack;
	}

	public static DemoShotVectorTrack DeserializeLength(BufferStream stream, int length)
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		DeserializeLength(stream, length, demoShotVectorTrack, isDelta: false);
		return demoShotVectorTrack;
	}

	public static DemoShotVectorTrack Deserialize(byte[] buffer)
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShotVectorTrack, isDelta: false);
		return demoShotVectorTrack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShotVectorTrack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShotVectorTrack Deserialize(BufferStream stream, DemoShotVectorTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotVectorKeyframe>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotVectorKeyframe instance2 = default(DemoShotVectorKeyframe);
				DemoShotVectorKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static DemoShotVectorTrack DeserializeLengthDelimited(BufferStream stream, DemoShotVectorTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotVectorKeyframe>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotVectorKeyframe instance2 = default(DemoShotVectorKeyframe);
				DemoShotVectorKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotVectorTrack DeserializeLength(BufferStream stream, int length, DemoShotVectorTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotVectorKeyframe>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotVectorKeyframe instance2 = default(DemoShotVectorKeyframe);
				DemoShotVectorKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotVectorTrack instance, DemoShotVectorTrack previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotVectorKeyframe demoShotVectorKeyframe = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotVectorKeyframe.SerializeDelta(stream, demoShotVectorKeyframe, demoShotVectorKeyframe);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotVectorKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotVectorTrack instance)
	{
		if (instance.trackType != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotVectorKeyframe instance2 = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotVectorKeyframe.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotVectorKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (keyframes != null)
		{
			for (int i = 0; i < keyframes.Count; i++)
			{
				keyframes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public struct DemoShotVectorKeyframe : IProto<DemoShotVectorKeyframe>, IProto
{
	[NonSerialized]
	public float keyframeTime;

	[NonSerialized]
	public Vector3 keyFrameValue;

	public static void ResetToPool(DemoShotVectorKeyframe instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.keyframeTime = 0f;
		instance.keyFrameValue = default(Vector3);
	}

	public void CopyTo(DemoShotVectorKeyframe instance)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		instance.keyframeTime = keyframeTime;
		instance.keyFrameValue = keyFrameValue;
	}

	public DemoShotVectorKeyframe Copy()
	{
		DemoShotVectorKeyframe demoShotVectorKeyframe = default(DemoShotVectorKeyframe);
		CopyTo(demoShotVectorKeyframe);
		return demoShotVectorKeyframe;
	}

	public static DemoShotVectorKeyframe Deserialize(BufferStream stream)
	{
		DemoShotVectorKeyframe instance = default(DemoShotVectorKeyframe);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotVectorKeyframe DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotVectorKeyframe instance = default(DemoShotVectorKeyframe);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotVectorKeyframe DeserializeLength(BufferStream stream, int length)
	{
		DemoShotVectorKeyframe instance = default(DemoShotVectorKeyframe);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotVectorKeyframe Deserialize(byte[] buffer)
	{
		DemoShotVectorKeyframe instance = default(DemoShotVectorKeyframe);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, DemoShotVectorKeyframe previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static DemoShotVectorKeyframe Deserialize(BufferStream stream, ref DemoShotVectorKeyframe instance, bool isDelta)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.keyFrameValue, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoShotVectorKeyframe DeserializeLengthDelimited(BufferStream stream, ref DemoShotVectorKeyframe instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.keyFrameValue, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotVectorKeyframe DeserializeLength(BufferStream stream, int length, ref DemoShotVectorKeyframe instance, bool isDelta)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.keyFrameValue, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotVectorKeyframe instance, DemoShotVectorKeyframe previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.keyframeTime != previous.keyframeTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValue != previous.keyFrameValue)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.keyFrameValue, previous.keyFrameValue);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyFrameValue (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotVectorKeyframe instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (instance.keyframeTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValue != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.keyFrameValue);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyFrameValue (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShotFloatTrack : IDisposable, IPooled, IProto<DemoShotFloatTrack>, IProto
{
	[NonSerialized]
	public long trackType;

	[NonSerialized]
	public List<DemoShotFloatKeyframe> keyframes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShotFloatTrack instance)
	{
		if (instance.ShouldPool)
		{
			instance.trackType = 0L;
			if (instance.keyframes != null)
			{
				List<DemoShotFloatKeyframe> list = instance.keyframes;
				Pool.FreeUnmanaged<DemoShotFloatKeyframe>(ref list);
				instance.keyframes = list;
			}
			Pool.Free<DemoShotFloatTrack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShotFloatTrack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShotFloatTrack instance)
	{
		instance.trackType = trackType;
		if (keyframes != null)
		{
			instance.keyframes = Pool.Get<List<DemoShotFloatKeyframe>>();
			for (int i = 0; i < keyframes.Count; i++)
			{
				DemoShotFloatKeyframe item = keyframes[i];
				instance.keyframes.Add(item);
			}
		}
		else
		{
			instance.keyframes = null;
		}
	}

	public DemoShotFloatTrack Copy()
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		CopyTo(demoShotFloatTrack);
		return demoShotFloatTrack;
	}

	public static DemoShotFloatTrack Deserialize(BufferStream stream)
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		Deserialize(stream, demoShotFloatTrack, isDelta: false);
		return demoShotFloatTrack;
	}

	public static DemoShotFloatTrack DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		DeserializeLengthDelimited(stream, demoShotFloatTrack, isDelta: false);
		return demoShotFloatTrack;
	}

	public static DemoShotFloatTrack DeserializeLength(BufferStream stream, int length)
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		DeserializeLength(stream, length, demoShotFloatTrack, isDelta: false);
		return demoShotFloatTrack;
	}

	public static DemoShotFloatTrack Deserialize(byte[] buffer)
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShotFloatTrack, isDelta: false);
		return demoShotFloatTrack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShotFloatTrack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShotFloatTrack Deserialize(BufferStream stream, DemoShotFloatTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotFloatKeyframe>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotFloatKeyframe instance2 = default(DemoShotFloatKeyframe);
				DemoShotFloatKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static DemoShotFloatTrack DeserializeLengthDelimited(BufferStream stream, DemoShotFloatTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotFloatKeyframe>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotFloatKeyframe instance2 = default(DemoShotFloatKeyframe);
				DemoShotFloatKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotFloatTrack DeserializeLength(BufferStream stream, int length, DemoShotFloatTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotFloatKeyframe>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotFloatKeyframe instance2 = default(DemoShotFloatKeyframe);
				DemoShotFloatKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotFloatTrack instance, DemoShotFloatTrack previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotFloatKeyframe demoShotFloatKeyframe = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotFloatKeyframe.SerializeDelta(stream, demoShotFloatKeyframe, demoShotFloatKeyframe);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotFloatKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotFloatTrack instance)
	{
		if (instance.trackType != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotFloatKeyframe instance2 = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotFloatKeyframe.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotFloatKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (keyframes != null)
		{
			for (int i = 0; i < keyframes.Count; i++)
			{
				keyframes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public struct DemoShotFloatKeyframe : IProto<DemoShotFloatKeyframe>, IProto
{
	[NonSerialized]
	public float keyframeTime;

	[NonSerialized]
	public float keyFrameValue;

	public static void ResetToPool(DemoShotFloatKeyframe instance)
	{
		instance.keyframeTime = 0f;
		instance.keyFrameValue = 0f;
	}

	public void CopyTo(DemoShotFloatKeyframe instance)
	{
		instance.keyframeTime = keyframeTime;
		instance.keyFrameValue = keyFrameValue;
	}

	public DemoShotFloatKeyframe Copy()
	{
		DemoShotFloatKeyframe demoShotFloatKeyframe = default(DemoShotFloatKeyframe);
		CopyTo(demoShotFloatKeyframe);
		return demoShotFloatKeyframe;
	}

	public static DemoShotFloatKeyframe Deserialize(BufferStream stream)
	{
		DemoShotFloatKeyframe instance = default(DemoShotFloatKeyframe);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotFloatKeyframe DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotFloatKeyframe instance = default(DemoShotFloatKeyframe);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotFloatKeyframe DeserializeLength(BufferStream stream, int length)
	{
		DemoShotFloatKeyframe instance = default(DemoShotFloatKeyframe);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotFloatKeyframe Deserialize(byte[] buffer)
	{
		DemoShotFloatKeyframe instance = default(DemoShotFloatKeyframe);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, DemoShotFloatKeyframe previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static DemoShotFloatKeyframe Deserialize(BufferStream stream, ref DemoShotFloatKeyframe instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValue = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoShotFloatKeyframe DeserializeLengthDelimited(BufferStream stream, ref DemoShotFloatKeyframe instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValue = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotFloatKeyframe DeserializeLength(BufferStream stream, int length, ref DemoShotFloatKeyframe instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValue = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotFloatKeyframe instance, DemoShotFloatKeyframe previous)
	{
		if (instance.keyframeTime != previous.keyframeTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValue != previous.keyFrameValue)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValue);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotFloatKeyframe instance)
	{
		if (instance.keyframeTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValue != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValue);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShotQuaternionTrack : IDisposable, IPooled, IProto<DemoShotQuaternionTrack>, IProto
{
	[NonSerialized]
	public long trackType;

	[NonSerialized]
	public List<DemoShotQuaternionKeyframe> keyframes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShotQuaternionTrack instance)
	{
		if (instance.ShouldPool)
		{
			instance.trackType = 0L;
			if (instance.keyframes != null)
			{
				List<DemoShotQuaternionKeyframe> list = instance.keyframes;
				Pool.FreeUnmanaged<DemoShotQuaternionKeyframe>(ref list);
				instance.keyframes = list;
			}
			Pool.Free<DemoShotQuaternionTrack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShotQuaternionTrack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShotQuaternionTrack instance)
	{
		instance.trackType = trackType;
		if (keyframes != null)
		{
			instance.keyframes = Pool.Get<List<DemoShotQuaternionKeyframe>>();
			for (int i = 0; i < keyframes.Count; i++)
			{
				DemoShotQuaternionKeyframe item = keyframes[i];
				instance.keyframes.Add(item);
			}
		}
		else
		{
			instance.keyframes = null;
		}
	}

	public DemoShotQuaternionTrack Copy()
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		CopyTo(demoShotQuaternionTrack);
		return demoShotQuaternionTrack;
	}

	public static DemoShotQuaternionTrack Deserialize(BufferStream stream)
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		Deserialize(stream, demoShotQuaternionTrack, isDelta: false);
		return demoShotQuaternionTrack;
	}

	public static DemoShotQuaternionTrack DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		DeserializeLengthDelimited(stream, demoShotQuaternionTrack, isDelta: false);
		return demoShotQuaternionTrack;
	}

	public static DemoShotQuaternionTrack DeserializeLength(BufferStream stream, int length)
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		DeserializeLength(stream, length, demoShotQuaternionTrack, isDelta: false);
		return demoShotQuaternionTrack;
	}

	public static DemoShotQuaternionTrack Deserialize(byte[] buffer)
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShotQuaternionTrack, isDelta: false);
		return demoShotQuaternionTrack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShotQuaternionTrack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShotQuaternionTrack Deserialize(BufferStream stream, DemoShotQuaternionTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotQuaternionKeyframe>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotQuaternionKeyframe instance2 = default(DemoShotQuaternionKeyframe);
				DemoShotQuaternionKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static DemoShotQuaternionTrack DeserializeLengthDelimited(BufferStream stream, DemoShotQuaternionTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotQuaternionKeyframe>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotQuaternionKeyframe instance2 = default(DemoShotQuaternionKeyframe);
				DemoShotQuaternionKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotQuaternionTrack DeserializeLength(BufferStream stream, int length, DemoShotQuaternionTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotQuaternionKeyframe>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotQuaternionKeyframe instance2 = default(DemoShotQuaternionKeyframe);
				DemoShotQuaternionKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotQuaternionTrack instance, DemoShotQuaternionTrack previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotQuaternionKeyframe demoShotQuaternionKeyframe = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotQuaternionKeyframe.SerializeDelta(stream, demoShotQuaternionKeyframe, demoShotQuaternionKeyframe);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotQuaternionKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotQuaternionTrack instance)
	{
		if (instance.trackType != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotQuaternionKeyframe instance2 = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotQuaternionKeyframe.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotQuaternionKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (keyframes != null)
		{
			for (int i = 0; i < keyframes.Count; i++)
			{
				keyframes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public struct DemoShotQuaternionKeyframe : IProto<DemoShotQuaternionKeyframe>, IProto
{
	[NonSerialized]
	public float keyframeTime;

	[NonSerialized]
	public float keyFrameValueX;

	[NonSerialized]
	public float keyFrameValueY;

	[NonSerialized]
	public float keyFrameValueZ;

	[NonSerialized]
	public float keyFrameValueW;

	public static void ResetToPool(DemoShotQuaternionKeyframe instance)
	{
		instance.keyframeTime = 0f;
		instance.keyFrameValueX = 0f;
		instance.keyFrameValueY = 0f;
		instance.keyFrameValueZ = 0f;
		instance.keyFrameValueW = 0f;
	}

	public void CopyTo(DemoShotQuaternionKeyframe instance)
	{
		instance.keyframeTime = keyframeTime;
		instance.keyFrameValueX = keyFrameValueX;
		instance.keyFrameValueY = keyFrameValueY;
		instance.keyFrameValueZ = keyFrameValueZ;
		instance.keyFrameValueW = keyFrameValueW;
	}

	public DemoShotQuaternionKeyframe Copy()
	{
		DemoShotQuaternionKeyframe demoShotQuaternionKeyframe = default(DemoShotQuaternionKeyframe);
		CopyTo(demoShotQuaternionKeyframe);
		return demoShotQuaternionKeyframe;
	}

	public static DemoShotQuaternionKeyframe Deserialize(BufferStream stream)
	{
		DemoShotQuaternionKeyframe instance = default(DemoShotQuaternionKeyframe);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotQuaternionKeyframe DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotQuaternionKeyframe instance = default(DemoShotQuaternionKeyframe);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotQuaternionKeyframe DeserializeLength(BufferStream stream, int length)
	{
		DemoShotQuaternionKeyframe instance = default(DemoShotQuaternionKeyframe);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotQuaternionKeyframe Deserialize(byte[] buffer)
	{
		DemoShotQuaternionKeyframe instance = default(DemoShotQuaternionKeyframe);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, DemoShotQuaternionKeyframe previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static DemoShotQuaternionKeyframe Deserialize(BufferStream stream, ref DemoShotQuaternionKeyframe instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValueX = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.keyFrameValueY = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.keyFrameValueZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.keyFrameValueW = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoShotQuaternionKeyframe DeserializeLengthDelimited(BufferStream stream, ref DemoShotQuaternionKeyframe instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValueX = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.keyFrameValueY = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.keyFrameValueZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.keyFrameValueW = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotQuaternionKeyframe DeserializeLength(BufferStream stream, int length, ref DemoShotQuaternionKeyframe instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValueX = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.keyFrameValueY = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.keyFrameValueZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.keyFrameValueW = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotQuaternionKeyframe instance, DemoShotQuaternionKeyframe previous)
	{
		if (instance.keyframeTime != previous.keyframeTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValueX != previous.keyFrameValueX)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueX);
		}
		if (instance.keyFrameValueY != previous.keyFrameValueY)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueY);
		}
		if (instance.keyFrameValueZ != previous.keyFrameValueZ)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueZ);
		}
		if (instance.keyFrameValueW != previous.keyFrameValueW)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueW);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotQuaternionKeyframe instance)
	{
		if (instance.keyframeTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValueX != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueX);
		}
		if (instance.keyFrameValueY != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueY);
		}
		if (instance.keyFrameValueZ != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueZ);
		}
		if (instance.keyFrameValueW != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueW);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShotParentTrack : IDisposable, IPooled, IProto<DemoShotParentTrack>, IProto
{
	[NonSerialized]
	public ulong parentId;

	[NonSerialized]
	public List<DemoShotParentKeyframe> keyframes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShotParentTrack instance)
	{
		if (instance.ShouldPool)
		{
			instance.parentId = 0uL;
			if (instance.keyframes != null)
			{
				List<DemoShotParentKeyframe> list = instance.keyframes;
				Pool.FreeUnmanaged<DemoShotParentKeyframe>(ref list);
				instance.keyframes = list;
			}
			Pool.Free<DemoShotParentTrack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShotParentTrack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShotParentTrack instance)
	{
		instance.parentId = parentId;
		if (keyframes != null)
		{
			instance.keyframes = Pool.Get<List<DemoShotParentKeyframe>>();
			for (int i = 0; i < keyframes.Count; i++)
			{
				DemoShotParentKeyframe item = keyframes[i];
				instance.keyframes.Add(item);
			}
		}
		else
		{
			instance.keyframes = null;
		}
	}

	public DemoShotParentTrack Copy()
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		CopyTo(demoShotParentTrack);
		return demoShotParentTrack;
	}

	public static DemoShotParentTrack Deserialize(BufferStream stream)
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		Deserialize(stream, demoShotParentTrack, isDelta: false);
		return demoShotParentTrack;
	}

	public static DemoShotParentTrack DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		DeserializeLengthDelimited(stream, demoShotParentTrack, isDelta: false);
		return demoShotParentTrack;
	}

	public static DemoShotParentTrack DeserializeLength(BufferStream stream, int length)
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		DeserializeLength(stream, length, demoShotParentTrack, isDelta: false);
		return demoShotParentTrack;
	}

	public static DemoShotParentTrack Deserialize(byte[] buffer)
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShotParentTrack, isDelta: false);
		return demoShotParentTrack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShotParentTrack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShotParentTrack Deserialize(BufferStream stream, DemoShotParentTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotParentKeyframe>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotParentKeyframe instance2 = default(DemoShotParentKeyframe);
				DemoShotParentKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static DemoShotParentTrack DeserializeLengthDelimited(BufferStream stream, DemoShotParentTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotParentKeyframe>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotParentKeyframe instance2 = default(DemoShotParentKeyframe);
				DemoShotParentKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotParentTrack DeserializeLength(BufferStream stream, int length, DemoShotParentTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotParentKeyframe>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotParentKeyframe instance2 = default(DemoShotParentKeyframe);
				DemoShotParentKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotParentTrack instance, DemoShotParentTrack previous)
	{
		if (instance.parentId != previous.parentId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentId);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotParentKeyframe demoShotParentKeyframe = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			DemoShotParentKeyframe.SerializeDelta(stream, demoShotParentKeyframe, demoShotParentKeyframe);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, DemoShotParentTrack instance)
	{
		if (instance.parentId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentId);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotParentKeyframe instance2 = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			DemoShotParentKeyframe.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (keyframes != null)
		{
			for (int i = 0; i < keyframes.Count; i++)
			{
				keyframes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public struct DemoShotParentKeyframe : IProto<DemoShotParentKeyframe>, IProto
{
	[NonSerialized]
	public float keyframeTime;

	[NonSerialized]
	public NetworkableId keyFrameParentId;

	[NonSerialized]
	public string keyFrameParentName;

	public static void ResetToPool(DemoShotParentKeyframe instance)
	{
		instance.keyframeTime = 0f;
		instance.keyFrameParentId = default(NetworkableId);
		instance.keyFrameParentName = string.Empty;
	}

	public void CopyTo(DemoShotParentKeyframe instance)
	{
		instance.keyframeTime = keyframeTime;
		instance.keyFrameParentId = keyFrameParentId;
		instance.keyFrameParentName = keyFrameParentName;
	}

	public DemoShotParentKeyframe Copy()
	{
		DemoShotParentKeyframe demoShotParentKeyframe = default(DemoShotParentKeyframe);
		CopyTo(demoShotParentKeyframe);
		return demoShotParentKeyframe;
	}

	public static DemoShotParentKeyframe Deserialize(BufferStream stream)
	{
		DemoShotParentKeyframe instance = default(DemoShotParentKeyframe);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotParentKeyframe DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotParentKeyframe instance = default(DemoShotParentKeyframe);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotParentKeyframe DeserializeLength(BufferStream stream, int length)
	{
		DemoShotParentKeyframe instance = default(DemoShotParentKeyframe);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotParentKeyframe Deserialize(byte[] buffer)
	{
		DemoShotParentKeyframe instance = default(DemoShotParentKeyframe);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, DemoShotParentKeyframe previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static DemoShotParentKeyframe Deserialize(BufferStream stream, ref DemoShotParentKeyframe instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.keyFrameParentId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.keyFrameParentName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoShotParentKeyframe DeserializeLengthDelimited(BufferStream stream, ref DemoShotParentKeyframe instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.keyFrameParentId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.keyFrameParentName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotParentKeyframe DeserializeLength(BufferStream stream, int length, ref DemoShotParentKeyframe instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.keyFrameParentId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.keyFrameParentName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotParentKeyframe instance, DemoShotParentKeyframe previous)
	{
		if (instance.keyframeTime != previous.keyframeTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.keyFrameParentId.Value);
		if (instance.keyFrameParentName != previous.keyFrameParentName)
		{
			if (instance.keyFrameParentName == null)
			{
				throw new ArgumentNullException("keyFrameParentName", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.keyFrameParentName);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotParentKeyframe instance)
	{
		if (instance.keyframeTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameParentId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.keyFrameParentId.Value);
		}
		if (instance.keyFrameParentName == null)
		{
			throw new ArgumentNullException("keyFrameParentName", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.keyFrameParentName);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref keyFrameParentId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CopyPasteEntityInfo : IDisposable, IPooled, IProto<CopyPasteEntityInfo>, IProto
{
	[NonSerialized]
	public List<Entity> entities;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CopyPasteEntityInfo instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				if (instance.entities[i] != null)
				{
					instance.entities[i].ResetToPool();
					instance.entities[i] = null;
				}
			}
			List<Entity> list = instance.entities;
			Pool.Free<Entity>(ref list, false);
			instance.entities = list;
		}
		Pool.Free<CopyPasteEntityInfo>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CopyPasteEntityInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CopyPasteEntityInfo instance)
	{
		if (entities != null)
		{
			instance.entities = Pool.Get<List<Entity>>();
			for (int i = 0; i < entities.Count; i++)
			{
				Entity item = entities[i].Copy();
				instance.entities.Add(item);
			}
		}
		else
		{
			instance.entities = null;
		}
	}

	public CopyPasteEntityInfo Copy()
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		CopyTo(copyPasteEntityInfo);
		return copyPasteEntityInfo;
	}

	public static CopyPasteEntityInfo Deserialize(BufferStream stream)
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		Deserialize(stream, copyPasteEntityInfo, isDelta: false);
		return copyPasteEntityInfo;
	}

	public static CopyPasteEntityInfo DeserializeLengthDelimited(BufferStream stream)
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		DeserializeLengthDelimited(stream, copyPasteEntityInfo, isDelta: false);
		return copyPasteEntityInfo;
	}

	public static CopyPasteEntityInfo DeserializeLength(BufferStream stream, int length)
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		DeserializeLength(stream, length, copyPasteEntityInfo, isDelta: false);
		return copyPasteEntityInfo;
	}

	public static CopyPasteEntityInfo Deserialize(byte[] buffer)
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, copyPasteEntityInfo, isDelta: false);
		return copyPasteEntityInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CopyPasteEntityInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CopyPasteEntityInfo Deserialize(BufferStream stream, CopyPasteEntityInfo instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<Entity>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CopyPasteEntityInfo DeserializeLengthDelimited(BufferStream stream, CopyPasteEntityInfo instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<Entity>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CopyPasteEntityInfo DeserializeLength(BufferStream stream, int length, CopyPasteEntityInfo instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<Entity>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CopyPasteEntityInfo instance, CopyPasteEntityInfo previous)
	{
		if (instance.entities == null)
		{
			return;
		}
		for (int i = 0; i < instance.entities.Count; i++)
		{
			Entity entity = instance.entities[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entity.SerializeDelta(stream, entity, entity);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, CopyPasteEntityInfo instance)
	{
		if (instance.entities == null)
		{
			return;
		}
		for (int i = 0; i < instance.entities.Count; i++)
		{
			Entity instance2 = instance.entities[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entity.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entities != null)
		{
			for (int i = 0; i < entities.Count; i++)
			{
				entities[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PasteRequest : IDisposable, IPooled, IProto<PasteRequest>, IProto
{
	[NonSerialized]
	public CopyPasteEntityInfo pasteData;

	[NonSerialized]
	public Vector3 origin;

	[NonSerialized]
	public Vector3 playerRotation;

	[NonSerialized]
	public Vector3 heightOffset;

	[NonSerialized]
	public bool resources;

	[NonSerialized]
	public bool npcs;

	[NonSerialized]
	public bool vehicles;

	[NonSerialized]
	public bool deployables;

	[NonSerialized]
	public bool foundationsOnly;

	[NonSerialized]
	public bool buildingBlocksOnly;

	[NonSerialized]
	public bool snapToTerrain;

	[NonSerialized]
	public bool players;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PasteRequest instance)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			if (instance.pasteData != null)
			{
				instance.pasteData.ResetToPool();
				instance.pasteData = null;
			}
			instance.origin = default(Vector3);
			instance.playerRotation = default(Vector3);
			instance.heightOffset = default(Vector3);
			instance.resources = false;
			instance.npcs = false;
			instance.vehicles = false;
			instance.deployables = false;
			instance.foundationsOnly = false;
			instance.buildingBlocksOnly = false;
			instance.snapToTerrain = false;
			instance.players = false;
			Pool.Free<PasteRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PasteRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PasteRequest instance)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (pasteData != null)
		{
			if (instance.pasteData == null)
			{
				instance.pasteData = pasteData.Copy();
			}
			else
			{
				pasteData.CopyTo(instance.pasteData);
			}
		}
		else
		{
			instance.pasteData = null;
		}
		instance.origin = origin;
		instance.playerRotation = playerRotation;
		instance.heightOffset = heightOffset;
		instance.resources = resources;
		instance.npcs = npcs;
		instance.vehicles = vehicles;
		instance.deployables = deployables;
		instance.foundationsOnly = foundationsOnly;
		instance.buildingBlocksOnly = buildingBlocksOnly;
		instance.snapToTerrain = snapToTerrain;
		instance.players = players;
	}

	public PasteRequest Copy()
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		CopyTo(pasteRequest);
		return pasteRequest;
	}

	public static PasteRequest Deserialize(BufferStream stream)
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		Deserialize(stream, pasteRequest, isDelta: false);
		return pasteRequest;
	}

	public static PasteRequest DeserializeLengthDelimited(BufferStream stream)
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		DeserializeLengthDelimited(stream, pasteRequest, isDelta: false);
		return pasteRequest;
	}

	public static PasteRequest DeserializeLength(BufferStream stream, int length)
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		DeserializeLength(stream, length, pasteRequest, isDelta: false);
		return pasteRequest;
	}

	public static PasteRequest Deserialize(byte[] buffer)
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pasteRequest, isDelta: false);
		return pasteRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PasteRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PasteRequest Deserialize(BufferStream stream, PasteRequest instance, bool isDelta)
	{
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.pasteData == null)
				{
					instance.pasteData = CopyPasteEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					CopyPasteEntityInfo.DeserializeLengthDelimited(stream, instance.pasteData, isDelta);
				}
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerRotation, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heightOffset, isDelta);
				continue;
			case 80:
				instance.resources = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.npcs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.vehicles = ProtocolParser.ReadBool(stream);
				continue;
			case 104:
				instance.deployables = ProtocolParser.ReadBool(stream);
				continue;
			case 112:
				instance.foundationsOnly = ProtocolParser.ReadBool(stream);
				continue;
			case 120:
				instance.buildingBlocksOnly = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.snapToTerrain = ProtocolParser.ReadBool(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.players = ProtocolParser.ReadBool(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static PasteRequest DeserializeLengthDelimited(BufferStream stream, PasteRequest instance, bool isDelta)
	{
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.pasteData == null)
				{
					instance.pasteData = CopyPasteEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					CopyPasteEntityInfo.DeserializeLengthDelimited(stream, instance.pasteData, isDelta);
				}
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerRotation, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heightOffset, isDelta);
				continue;
			case 80:
				instance.resources = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.npcs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.vehicles = ProtocolParser.ReadBool(stream);
				continue;
			case 104:
				instance.deployables = ProtocolParser.ReadBool(stream);
				continue;
			case 112:
				instance.foundationsOnly = ProtocolParser.ReadBool(stream);
				continue;
			case 120:
				instance.buildingBlocksOnly = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.snapToTerrain = ProtocolParser.ReadBool(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.players = ProtocolParser.ReadBool(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PasteRequest DeserializeLength(BufferStream stream, int length, PasteRequest instance, bool isDelta)
	{
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.pasteData == null)
				{
					instance.pasteData = CopyPasteEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					CopyPasteEntityInfo.DeserializeLengthDelimited(stream, instance.pasteData, isDelta);
				}
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerRotation, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heightOffset, isDelta);
				continue;
			case 80:
				instance.resources = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.npcs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.vehicles = ProtocolParser.ReadBool(stream);
				continue;
			case 104:
				instance.deployables = ProtocolParser.ReadBool(stream);
				continue;
			case 112:
				instance.foundationsOnly = ProtocolParser.ReadBool(stream);
				continue;
			case 120:
				instance.buildingBlocksOnly = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.snapToTerrain = ProtocolParser.ReadBool(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.players = ProtocolParser.ReadBool(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PasteRequest instance, PasteRequest previous)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pasteData != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CopyPasteEntityInfo.SerializeDelta(stream, instance.pasteData, previous.pasteData);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.origin != previous.origin)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.origin, previous.origin);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.playerRotation != previous.playerRotation)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.playerRotation, previous.playerRotation);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerRotation (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.heightOffset != previous.heightOffset)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.heightOffset, previous.heightOffset);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heightOffset (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteBool(stream, instance.resources);
		stream.WriteByte(88);
		ProtocolParser.WriteBool(stream, instance.npcs);
		stream.WriteByte(96);
		ProtocolParser.WriteBool(stream, instance.vehicles);
		stream.WriteByte(104);
		ProtocolParser.WriteBool(stream, instance.deployables);
		stream.WriteByte(112);
		ProtocolParser.WriteBool(stream, instance.foundationsOnly);
		stream.WriteByte(120);
		ProtocolParser.WriteBool(stream, instance.buildingBlocksOnly);
		stream.WriteByte(128);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.snapToTerrain);
		stream.WriteByte(136);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.players);
	}

	public static void Serialize(BufferStream stream, PasteRequest instance)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pasteData != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CopyPasteEntityInfo.Serialize(stream, instance.pasteData);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.origin != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.origin);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.playerRotation != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.playerRotation);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerRotation (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.heightOffset != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.heightOffset);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heightOffset (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.resources)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteBool(stream, instance.resources);
		}
		if (instance.npcs)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteBool(stream, instance.npcs);
		}
		if (instance.vehicles)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.vehicles);
		}
		if (instance.deployables)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteBool(stream, instance.deployables);
		}
		if (instance.foundationsOnly)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteBool(stream, instance.foundationsOnly);
		}
		if (instance.buildingBlocksOnly)
		{
			stream.WriteByte(120);
			ProtocolParser.WriteBool(stream, instance.buildingBlocksOnly);
		}
		if (instance.snapToTerrain)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.snapToTerrain);
		}
		if (instance.players)
		{
			stream.WriteByte(136);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.players);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		pasteData?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ItemContainer : IDisposable, IPooled, IProto<ItemContainer>, IProto
{
	[NonSerialized]
	public ItemContainerId UID;

	[NonSerialized]
	public int slots;

	[NonSerialized]
	public float temperature;

	[NonSerialized]
	public int flags;

	[NonSerialized]
	public int allowedContents;

	[NonSerialized]
	public int maxStackSize;

	[NonSerialized]
	public List<int> allowedItems;

	[NonSerialized]
	public List<int> availableSlots;

	[NonSerialized]
	public int volume;

	[NonSerialized]
	public List<Item> contents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemContainer instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.UID = default(ItemContainerId);
		instance.slots = 0;
		instance.temperature = 0f;
		instance.flags = 0;
		instance.allowedContents = 0;
		instance.maxStackSize = 0;
		if (instance.allowedItems != null)
		{
			List<int> list = instance.allowedItems;
			Pool.FreeUnmanaged<int>(ref list);
			instance.allowedItems = list;
		}
		if (instance.availableSlots != null)
		{
			List<int> list2 = instance.availableSlots;
			Pool.FreeUnmanaged<int>(ref list2);
			instance.availableSlots = list2;
		}
		instance.volume = 0;
		if (instance.contents != null)
		{
			for (int i = 0; i < instance.contents.Count; i++)
			{
				if (instance.contents[i] != null)
				{
					instance.contents[i].ResetToPool();
					instance.contents[i] = null;
				}
			}
			List<Item> list3 = instance.contents;
			Pool.Free<Item>(ref list3, false);
			instance.contents = list3;
		}
		Pool.Free<ItemContainer>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemContainer instance)
	{
		instance.UID = UID;
		instance.slots = slots;
		instance.temperature = temperature;
		instance.flags = flags;
		instance.allowedContents = allowedContents;
		instance.maxStackSize = maxStackSize;
		if (allowedItems != null)
		{
			instance.allowedItems = Pool.Get<List<int>>();
			for (int i = 0; i < allowedItems.Count; i++)
			{
				int item = allowedItems[i];
				instance.allowedItems.Add(item);
			}
		}
		else
		{
			instance.allowedItems = null;
		}
		if (availableSlots != null)
		{
			instance.availableSlots = Pool.Get<List<int>>();
			for (int j = 0; j < availableSlots.Count; j++)
			{
				int item2 = availableSlots[j];
				instance.availableSlots.Add(item2);
			}
		}
		else
		{
			instance.availableSlots = null;
		}
		instance.volume = volume;
		if (contents != null)
		{
			instance.contents = Pool.Get<List<Item>>();
			for (int k = 0; k < contents.Count; k++)
			{
				Item item3 = contents[k].Copy();
				instance.contents.Add(item3);
			}
		}
		else
		{
			instance.contents = null;
		}
	}

	public ItemContainer Copy()
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		CopyTo(itemContainer);
		return itemContainer;
	}

	public static ItemContainer Deserialize(BufferStream stream)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		Deserialize(stream, itemContainer, isDelta: false);
		return itemContainer;
	}

	public static ItemContainer DeserializeLengthDelimited(BufferStream stream)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		DeserializeLengthDelimited(stream, itemContainer, isDelta: false);
		return itemContainer;
	}

	public static ItemContainer DeserializeLength(BufferStream stream, int length)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		DeserializeLength(stream, length, itemContainer, isDelta: false);
		return itemContainer;
	}

	public static ItemContainer Deserialize(byte[] buffer)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemContainer, isDelta: false);
		return itemContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemContainer Deserialize(BufferStream stream, ItemContainer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.allowedItems == null)
			{
				instance.allowedItems = Pool.Get<List<int>>();
			}
			if (instance.availableSlots == null)
			{
				instance.availableSlots = Pool.Get<List<int>>();
			}
			if (instance.contents == null)
			{
				instance.contents = Pool.Get<List<Item>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.UID = new ItemContainerId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.slots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.allowedContents = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.maxStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.allowedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.availableSlots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 72:
				instance.volume = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.contents.Add(Item.DeserializeLengthDelimited(stream));
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static ItemContainer DeserializeLengthDelimited(BufferStream stream, ItemContainer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.allowedItems == null)
			{
				instance.allowedItems = Pool.Get<List<int>>();
			}
			if (instance.availableSlots == null)
			{
				instance.availableSlots = Pool.Get<List<int>>();
			}
			if (instance.contents == null)
			{
				instance.contents = Pool.Get<List<Item>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.UID = new ItemContainerId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.slots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.allowedContents = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.maxStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.allowedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.availableSlots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 72:
				instance.volume = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.contents.Add(Item.DeserializeLengthDelimited(stream));
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemContainer DeserializeLength(BufferStream stream, int length, ItemContainer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.allowedItems == null)
			{
				instance.allowedItems = Pool.Get<List<int>>();
			}
			if (instance.availableSlots == null)
			{
				instance.availableSlots = Pool.Get<List<int>>();
			}
			if (instance.contents == null)
			{
				instance.contents = Pool.Get<List<Item>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.UID = new ItemContainerId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.slots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.allowedContents = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.maxStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.allowedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.availableSlots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 72:
				instance.volume = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.contents.Add(Item.DeserializeLengthDelimited(stream));
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemContainer instance, ItemContainer previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.UID.Value);
		if (instance.slots != previous.slots)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slots);
		}
		if (instance.temperature != previous.temperature)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.flags != previous.flags)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.allowedContents != previous.allowedContents)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.allowedContents);
		}
		if (instance.maxStackSize != previous.maxStackSize)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxStackSize);
		}
		if (instance.allowedItems != null)
		{
			for (int i = 0; i < instance.allowedItems.Count; i++)
			{
				int num = instance.allowedItems[i];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.availableSlots != null)
		{
			for (int j = 0; j < instance.availableSlots.Count; j++)
			{
				int num2 = instance.availableSlots[j];
				stream.WriteByte(64);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
		if (instance.volume != previous.volume)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.volume);
		}
		if (instance.contents == null)
		{
			return;
		}
		for (int k = 0; k < instance.contents.Count; k++)
		{
			Item item = instance.contents[k];
			stream.WriteByte(162);
			stream.WriteByte(6);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Item.SerializeDelta(stream, item, item);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num3 < 5)
			{
				span[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span[num3++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ItemContainer instance)
	{
		if (instance.UID != default(ItemContainerId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.UID.Value);
		}
		if (instance.slots != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slots);
		}
		if (instance.temperature != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.flags != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.allowedContents != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.allowedContents);
		}
		if (instance.maxStackSize != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxStackSize);
		}
		if (instance.allowedItems != null)
		{
			for (int i = 0; i < instance.allowedItems.Count; i++)
			{
				int num = instance.allowedItems[i];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.availableSlots != null)
		{
			for (int j = 0; j < instance.availableSlots.Count; j++)
			{
				int num2 = instance.availableSlots[j];
				stream.WriteByte(64);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
		if (instance.volume != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.volume);
		}
		if (instance.contents == null)
		{
			return;
		}
		for (int k = 0; k < instance.contents.Count; k++)
		{
			Item instance2 = instance.contents[k];
			stream.WriteByte(162);
			stream.WriteByte(6);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Item.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num3 < 5)
			{
				span[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span[num3++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.ItemContainerId, ref UID.Value);
		if (contents != null)
		{
			for (int i = 0; i < contents.Count; i++)
			{
				contents[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Item : IDisposable, IPooled, IProto<Item>, IProto
{
	public class InstanceData : IDisposable, IPooled, IProto<InstanceData>, IProto
	{
		[NonSerialized]
		public int dataInt;

		[NonSerialized]
		public int blueprintTarget;

		[NonSerialized]
		public int blueprintAmount;

		[NonSerialized]
		public NetworkableId subEntity;

		[NonSerialized]
		public float dataFloat;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(InstanceData instance)
		{
			if (instance.ShouldPool)
			{
				instance.dataInt = 0;
				instance.blueprintTarget = 0;
				instance.blueprintAmount = 0;
				instance.subEntity = default(NetworkableId);
				instance.dataFloat = 0f;
				Pool.Free<InstanceData>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose InstanceData with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(InstanceData instance)
		{
			instance.dataInt = dataInt;
			instance.blueprintTarget = blueprintTarget;
			instance.blueprintAmount = blueprintAmount;
			instance.subEntity = subEntity;
			instance.dataFloat = dataFloat;
		}

		public InstanceData Copy()
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			CopyTo(instanceData);
			return instanceData;
		}

		public static InstanceData Deserialize(BufferStream stream)
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			Deserialize(stream, instanceData, isDelta: false);
			return instanceData;
		}

		public static InstanceData DeserializeLengthDelimited(BufferStream stream)
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			DeserializeLengthDelimited(stream, instanceData, isDelta: false);
			return instanceData;
		}

		public static InstanceData DeserializeLength(BufferStream stream, int length)
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			DeserializeLength(stream, length, instanceData, isDelta: false);
			return instanceData;
		}

		public static InstanceData Deserialize(byte[] buffer)
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, instanceData, isDelta: false);
			return instanceData;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, InstanceData previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static InstanceData Deserialize(BufferStream stream, InstanceData instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 45:
					instance.dataFloat = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static InstanceData DeserializeLengthDelimited(BufferStream stream, InstanceData instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 45:
					instance.dataFloat = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static InstanceData DeserializeLength(BufferStream stream, int length, InstanceData instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 45:
					instance.dataFloat = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, InstanceData instance, InstanceData previous)
		{
			if (instance.dataInt != previous.dataInt)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.dataInt);
			}
			if (instance.blueprintTarget != previous.blueprintTarget)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintTarget);
			}
			if (instance.blueprintAmount != previous.blueprintAmount)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintAmount);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.subEntity.Value);
			if (instance.dataFloat != previous.dataFloat)
			{
				stream.WriteByte(45);
				ProtocolParser.WriteSingle(stream, instance.dataFloat);
			}
		}

		public static void Serialize(BufferStream stream, InstanceData instance)
		{
			if (instance.dataInt != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.dataInt);
			}
			if (instance.blueprintTarget != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintTarget);
			}
			if (instance.blueprintAmount != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintAmount);
			}
			if (instance.subEntity != default(NetworkableId))
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, instance.subEntity.Value);
			}
			if (instance.dataFloat != 0f)
			{
				stream.WriteByte(45);
				ProtocolParser.WriteSingle(stream, instance.dataFloat);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref subEntity.Value);
		}
	}

	public class ConditionData : IDisposable, IPooled, IProto<ConditionData>, IProto
	{
		[NonSerialized]
		public float condition;

		[NonSerialized]
		public float maxCondition;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ConditionData instance)
		{
			if (instance.ShouldPool)
			{
				instance.condition = 0f;
				instance.maxCondition = 0f;
				Pool.Free<ConditionData>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ConditionData with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ConditionData instance)
		{
			instance.condition = condition;
			instance.maxCondition = maxCondition;
		}

		public ConditionData Copy()
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			CopyTo(conditionData);
			return conditionData;
		}

		public static ConditionData Deserialize(BufferStream stream)
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			Deserialize(stream, conditionData, isDelta: false);
			return conditionData;
		}

		public static ConditionData DeserializeLengthDelimited(BufferStream stream)
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			DeserializeLengthDelimited(stream, conditionData, isDelta: false);
			return conditionData;
		}

		public static ConditionData DeserializeLength(BufferStream stream, int length)
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			DeserializeLength(stream, length, conditionData, isDelta: false);
			return conditionData;
		}

		public static ConditionData Deserialize(byte[] buffer)
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, conditionData, isDelta: false);
			return conditionData;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ConditionData previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ConditionData Deserialize(BufferStream stream, ConditionData instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 13:
					instance.condition = ProtocolParser.ReadSingle(stream);
					continue;
				case 21:
					instance.maxCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ConditionData DeserializeLengthDelimited(BufferStream stream, ConditionData instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 13:
					instance.condition = ProtocolParser.ReadSingle(stream);
					continue;
				case 21:
					instance.maxCondition = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ConditionData DeserializeLength(BufferStream stream, int length, ConditionData instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 13:
					instance.condition = ProtocolParser.ReadSingle(stream);
					continue;
				case 21:
					instance.maxCondition = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ConditionData instance, ConditionData previous)
		{
			if (instance.condition != previous.condition)
			{
				stream.WriteByte(13);
				ProtocolParser.WriteSingle(stream, instance.condition);
			}
			if (instance.maxCondition != previous.maxCondition)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.maxCondition);
			}
		}

		public static void Serialize(BufferStream stream, ConditionData instance)
		{
			if (instance.condition != 0f)
			{
				stream.WriteByte(13);
				ProtocolParser.WriteSingle(stream, instance.condition);
			}
			if (instance.maxCondition != 0f)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.maxCondition);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public ItemId UID;

	[NonSerialized]
	public int itemid;

	[NonSerialized]
	public int slot;

	[NonSerialized]
	public int amount;

	[NonSerialized]
	public int flags;

	[NonSerialized]
	public float removetime;

	[NonSerialized]
	public float locktime;

	[NonSerialized]
	public NetworkableId worldEntity;

	[NonSerialized]
	public InstanceData instanceData;

	[NonSerialized]
	public NetworkableId heldEntity;

	[NonSerialized]
	public ConditionData conditionData;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public string text;

	[NonSerialized]
	public ulong skinid;

	[NonSerialized]
	public float cooktime;

	[NonSerialized]
	public string streamerName;

	[NonSerialized]
	public int ammoCount;

	[NonSerialized]
	public List<ItemOwnershipAmount> ownership;

	[NonSerialized]
	public uint iconImageId;

	[NonSerialized]
	public ItemContainer contents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Item instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.UID = default(ItemId);
		instance.itemid = 0;
		instance.slot = 0;
		instance.amount = 0;
		instance.flags = 0;
		instance.removetime = 0f;
		instance.locktime = 0f;
		instance.worldEntity = default(NetworkableId);
		if (instance.instanceData != null)
		{
			instance.instanceData.ResetToPool();
			instance.instanceData = null;
		}
		instance.heldEntity = default(NetworkableId);
		if (instance.conditionData != null)
		{
			instance.conditionData.ResetToPool();
			instance.conditionData = null;
		}
		instance.name = string.Empty;
		instance.text = string.Empty;
		instance.skinid = 0uL;
		instance.cooktime = 0f;
		instance.streamerName = string.Empty;
		instance.ammoCount = 0;
		if (instance.ownership != null)
		{
			for (int i = 0; i < instance.ownership.Count; i++)
			{
				if (instance.ownership[i] != null)
				{
					instance.ownership[i].ResetToPool();
					instance.ownership[i] = null;
				}
			}
			List<ItemOwnershipAmount> list = instance.ownership;
			Pool.Free<ItemOwnershipAmount>(ref list, false);
			instance.ownership = list;
		}
		instance.iconImageId = 0u;
		if (instance.contents != null)
		{
			instance.contents.ResetToPool();
			instance.contents = null;
		}
		Pool.Free<Item>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Item with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Item instance)
	{
		instance.UID = UID;
		instance.itemid = itemid;
		instance.slot = slot;
		instance.amount = amount;
		instance.flags = flags;
		instance.removetime = removetime;
		instance.locktime = locktime;
		instance.worldEntity = worldEntity;
		if (instanceData != null)
		{
			if (instance.instanceData == null)
			{
				instance.instanceData = instanceData.Copy();
			}
			else
			{
				instanceData.CopyTo(instance.instanceData);
			}
		}
		else
		{
			instance.instanceData = null;
		}
		instance.heldEntity = heldEntity;
		if (conditionData != null)
		{
			if (instance.conditionData == null)
			{
				instance.conditionData = conditionData.Copy();
			}
			else
			{
				conditionData.CopyTo(instance.conditionData);
			}
		}
		else
		{
			instance.conditionData = null;
		}
		instance.name = name;
		instance.text = text;
		instance.skinid = skinid;
		instance.cooktime = cooktime;
		instance.streamerName = streamerName;
		instance.ammoCount = ammoCount;
		if (ownership != null)
		{
			instance.ownership = Pool.Get<List<ItemOwnershipAmount>>();
			for (int i = 0; i < ownership.Count; i++)
			{
				ItemOwnershipAmount item = ownership[i].Copy();
				instance.ownership.Add(item);
			}
		}
		else
		{
			instance.ownership = null;
		}
		instance.iconImageId = iconImageId;
		if (contents != null)
		{
			if (instance.contents == null)
			{
				instance.contents = contents.Copy();
			}
			else
			{
				contents.CopyTo(instance.contents);
			}
		}
		else
		{
			instance.contents = null;
		}
	}

	public Item Copy()
	{
		Item item = Pool.Get<Item>();
		CopyTo(item);
		return item;
	}

	public static Item Deserialize(BufferStream stream)
	{
		Item item = Pool.Get<Item>();
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLengthDelimited(BufferStream stream)
	{
		Item item = Pool.Get<Item>();
		DeserializeLengthDelimited(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLength(BufferStream stream, int length)
	{
		Item item = Pool.Get<Item>();
		DeserializeLength(stream, length, item, isDelta: false);
		return item;
	}

	public static Item Deserialize(byte[] buffer)
	{
		Item item = Pool.Get<Item>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Item previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Item Deserialize(BufferStream stream, Item instance, bool isDelta)
	{
		if (!isDelta && instance.ownership == null)
		{
			instance.ownership = Pool.Get<List<ItemOwnershipAmount>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.UID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.itemid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.removetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.locktime = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.worldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 74:
				if (instance.instanceData == null)
				{
					instance.instanceData = InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				continue;
			case 80:
				instance.heldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 90:
				if (instance.conditionData == null)
				{
					instance.conditionData = ConditionData.DeserializeLengthDelimited(stream);
				}
				else
				{
					ConditionData.DeserializeLengthDelimited(stream, instance.conditionData, isDelta);
				}
				continue;
			case 114:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 122:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.skinid = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.cooktime = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.streamerName = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.ownership.Add(ItemOwnershipAmount.DeserializeLengthDelimited(stream));
				}
				break;
			case 21u:
				if (key.WireType == Wire.Varint)
				{
					instance.iconImageId = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.contents == null)
					{
						instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static Item DeserializeLengthDelimited(BufferStream stream, Item instance, bool isDelta)
	{
		if (!isDelta && instance.ownership == null)
		{
			instance.ownership = Pool.Get<List<ItemOwnershipAmount>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.UID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.itemid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.removetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.locktime = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.worldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 74:
				if (instance.instanceData == null)
				{
					instance.instanceData = InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				continue;
			case 80:
				instance.heldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 90:
				if (instance.conditionData == null)
				{
					instance.conditionData = ConditionData.DeserializeLengthDelimited(stream);
				}
				else
				{
					ConditionData.DeserializeLengthDelimited(stream, instance.conditionData, isDelta);
				}
				continue;
			case 114:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 122:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.skinid = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.cooktime = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.streamerName = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.ownership.Add(ItemOwnershipAmount.DeserializeLengthDelimited(stream));
				}
				break;
			case 21u:
				if (key.WireType == Wire.Varint)
				{
					instance.iconImageId = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.contents == null)
					{
						instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Item DeserializeLength(BufferStream stream, int length, Item instance, bool isDelta)
	{
		if (!isDelta && instance.ownership == null)
		{
			instance.ownership = Pool.Get<List<ItemOwnershipAmount>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.UID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.itemid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.removetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.locktime = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.worldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 74:
				if (instance.instanceData == null)
				{
					instance.instanceData = InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				continue;
			case 80:
				instance.heldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 90:
				if (instance.conditionData == null)
				{
					instance.conditionData = ConditionData.DeserializeLengthDelimited(stream);
				}
				else
				{
					ConditionData.DeserializeLengthDelimited(stream, instance.conditionData, isDelta);
				}
				continue;
			case 114:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 122:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.skinid = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.cooktime = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.streamerName = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.ownership.Add(ItemOwnershipAmount.DeserializeLengthDelimited(stream));
				}
				break;
			case 21u:
				if (key.WireType == Wire.Varint)
				{
					instance.iconImageId = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.contents == null)
					{
						instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Item instance, Item previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.UID.Value);
		if (instance.itemid != previous.itemid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemid);
		}
		if (instance.slot != previous.slot)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slot);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.flags != previous.flags)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.removetime != previous.removetime)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.removetime);
		}
		if (instance.locktime != previous.locktime)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.locktime);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.worldEntity.Value);
		if (instance.instanceData != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			InstanceData.SerializeDelta(stream, instance.instanceData, previous.instanceData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteUInt64(stream, instance.heldEntity.Value);
		if (instance.conditionData != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			ConditionData.SerializeDelta(stream, instance.conditionData, previous.conditionData);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field conditionData (ProtoBuf.Item.ConditionData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(114);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.text != null && instance.text != previous.text)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.text);
		}
		if (instance.skinid != previous.skinid)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.skinid);
		}
		if (instance.cooktime != previous.cooktime)
		{
			stream.WriteByte(141);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.cooktime);
		}
		if (instance.streamerName != null && instance.streamerName != previous.streamerName)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
		if (instance.ammoCount != previous.ammoCount)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
		}
		if (instance.ownership != null)
		{
			for (int i = 0; i < instance.ownership.Count; i++)
			{
				ItemOwnershipAmount itemOwnershipAmount = instance.ownership[i];
				stream.WriteByte(162);
				stream.WriteByte(1);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				ItemOwnershipAmount.SerializeDelta(stream, itemOwnershipAmount, itemOwnershipAmount);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.iconImageId != previous.iconImageId)
		{
			stream.WriteByte(168);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.iconImageId);
		}
		if (instance.contents == null)
		{
			return;
		}
		stream.WriteByte(162);
		stream.WriteByte(6);
		BufferStream.RangeHandle range4 = stream.GetRange(5);
		int position4 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.contents, previous.contents);
		int val2 = stream.Position - position4;
		Span<byte> span4 = range4.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
		if (num4 < 5)
		{
			span4[num4 - 1] |= 128;
			while (num4 < 4)
			{
				span4[num4++] = 128;
			}
			span4[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Item instance)
	{
		if (instance.UID != default(ItemId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.UID.Value);
		}
		if (instance.itemid != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemid);
		}
		if (instance.slot != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slot);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.flags != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.removetime != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.removetime);
		}
		if (instance.locktime != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.locktime);
		}
		if (instance.worldEntity != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.worldEntity.Value);
		}
		if (instance.instanceData != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			InstanceData.Serialize(stream, instance.instanceData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.heldEntity != default(NetworkableId))
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, instance.heldEntity.Value);
		}
		if (instance.conditionData != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			ConditionData.Serialize(stream, instance.conditionData);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field conditionData (ProtoBuf.Item.ConditionData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.name != null)
		{
			stream.WriteByte(114);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.text != null)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.text);
		}
		if (instance.skinid != 0L)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.skinid);
		}
		if (instance.cooktime != 0f)
		{
			stream.WriteByte(141);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.cooktime);
		}
		if (instance.streamerName != null)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
		if (instance.ammoCount != 0)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
		}
		if (instance.ownership != null)
		{
			for (int i = 0; i < instance.ownership.Count; i++)
			{
				ItemOwnershipAmount instance2 = instance.ownership[i];
				stream.WriteByte(162);
				stream.WriteByte(1);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				ItemOwnershipAmount.Serialize(stream, instance2);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.iconImageId != 0)
		{
			stream.WriteByte(168);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.iconImageId);
		}
		if (instance.contents == null)
		{
			return;
		}
		stream.WriteByte(162);
		stream.WriteByte(6);
		BufferStream.RangeHandle range4 = stream.GetRange(5);
		int position4 = stream.Position;
		ItemContainer.Serialize(stream, instance.contents);
		int val2 = stream.Position - position4;
		Span<byte> span4 = range4.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
		if (num4 < 5)
		{
			span4[num4 - 1] |= 128;
			while (num4 < 4)
			{
				span4[num4++] = 128;
			}
			span4[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.ItemId, ref UID.Value);
		action(UidType.NetworkableId, ref worldEntity.Value);
		instanceData?.InspectUids(action);
		action(UidType.NetworkableId, ref heldEntity.Value);
		conditionData?.InspectUids(action);
		if (ownership != null)
		{
			for (int i = 0; i < ownership.Count; i++)
			{
				ownership[i]?.InspectUids(action);
			}
		}
		contents?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ItemOwnershipAmount : IDisposable, IPooled, IProto<ItemOwnershipAmount>, IProto
{
	[NonSerialized]
	public string username;

	[NonSerialized]
	public string reason;

	[NonSerialized]
	public int amount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemOwnershipAmount instance)
	{
		if (instance.ShouldPool)
		{
			instance.username = string.Empty;
			instance.reason = string.Empty;
			instance.amount = 0;
			Pool.Free<ItemOwnershipAmount>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemOwnershipAmount with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemOwnershipAmount instance)
	{
		instance.username = username;
		instance.reason = reason;
		instance.amount = amount;
	}

	public ItemOwnershipAmount Copy()
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		CopyTo(itemOwnershipAmount);
		return itemOwnershipAmount;
	}

	public static ItemOwnershipAmount Deserialize(BufferStream stream)
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		Deserialize(stream, itemOwnershipAmount, isDelta: false);
		return itemOwnershipAmount;
	}

	public static ItemOwnershipAmount DeserializeLengthDelimited(BufferStream stream)
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		DeserializeLengthDelimited(stream, itemOwnershipAmount, isDelta: false);
		return itemOwnershipAmount;
	}

	public static ItemOwnershipAmount DeserializeLength(BufferStream stream, int length)
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		DeserializeLength(stream, length, itemOwnershipAmount, isDelta: false);
		return itemOwnershipAmount;
	}

	public static ItemOwnershipAmount Deserialize(byte[] buffer)
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemOwnershipAmount, isDelta: false);
		return itemOwnershipAmount;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemOwnershipAmount previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemOwnershipAmount Deserialize(BufferStream stream, ItemOwnershipAmount instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 26:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 10:
				instance.reason = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemOwnershipAmount DeserializeLengthDelimited(BufferStream stream, ItemOwnershipAmount instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 26:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 10:
				instance.reason = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemOwnershipAmount DeserializeLength(BufferStream stream, int length, ItemOwnershipAmount instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 26:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 10:
				instance.reason = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemOwnershipAmount instance, ItemOwnershipAmount previous)
	{
		if (instance.username != null && instance.username != previous.username)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.username);
		}
		if (instance.reason != null && instance.reason != previous.reason)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.reason);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
	}

	public static void Serialize(BufferStream stream, ItemOwnershipAmount instance)
	{
		if (instance.username != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.username);
		}
		if (instance.reason != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.reason);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Approval : IDisposable, IPooled, IProto<Approval>, IProto
{
	[NonSerialized]
	public string level;

	[NonSerialized]
	public string hostname;

	[NonSerialized]
	public bool modded;

	[NonSerialized]
	public bool official;

	[NonSerialized]
	public ulong steamid;

	[NonSerialized]
	public uint ipaddress;

	[NonSerialized]
	public int port;

	[NonSerialized]
	public uint levelSeed;

	[NonSerialized]
	public uint levelSize;

	[NonSerialized]
	public string checksum;

	[NonSerialized]
	public uint encryption;

	[NonSerialized]
	public string levelUrl;

	[NonSerialized]
	public bool levelTransfer;

	[NonSerialized]
	public string version;

	[NonSerialized]
	public string levelConfig;

	[NonSerialized]
	public bool nexus;

	[NonSerialized]
	public string nexusEndpoint;

	[NonSerialized]
	public int nexusId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Approval instance)
	{
		if (instance.ShouldPool)
		{
			instance.level = string.Empty;
			instance.hostname = string.Empty;
			instance.modded = false;
			instance.official = false;
			instance.steamid = 0uL;
			instance.ipaddress = 0u;
			instance.port = 0;
			instance.levelSeed = 0u;
			instance.levelSize = 0u;
			instance.checksum = string.Empty;
			instance.encryption = 0u;
			instance.levelUrl = string.Empty;
			instance.levelTransfer = false;
			instance.version = string.Empty;
			instance.levelConfig = string.Empty;
			instance.nexus = false;
			instance.nexusEndpoint = string.Empty;
			instance.nexusId = 0;
			Pool.Free<Approval>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Approval with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Approval instance)
	{
		instance.level = level;
		instance.hostname = hostname;
		instance.modded = modded;
		instance.official = official;
		instance.steamid = steamid;
		instance.ipaddress = ipaddress;
		instance.port = port;
		instance.levelSeed = levelSeed;
		instance.levelSize = levelSize;
		instance.checksum = checksum;
		instance.encryption = encryption;
		instance.levelUrl = levelUrl;
		instance.levelTransfer = levelTransfer;
		instance.version = version;
		instance.levelConfig = levelConfig;
		instance.nexus = nexus;
		instance.nexusEndpoint = nexusEndpoint;
		instance.nexusId = nexusId;
	}

	public Approval Copy()
	{
		Approval approval = Pool.Get<Approval>();
		CopyTo(approval);
		return approval;
	}

	public static Approval Deserialize(BufferStream stream)
	{
		Approval approval = Pool.Get<Approval>();
		Deserialize(stream, approval, isDelta: false);
		return approval;
	}

	public static Approval DeserializeLengthDelimited(BufferStream stream)
	{
		Approval approval = Pool.Get<Approval>();
		DeserializeLengthDelimited(stream, approval, isDelta: false);
		return approval;
	}

	public static Approval DeserializeLength(BufferStream stream, int length)
	{
		Approval approval = Pool.Get<Approval>();
		DeserializeLength(stream, length, approval, isDelta: false);
		return approval;
	}

	public static Approval Deserialize(byte[] buffer)
	{
		Approval approval = Pool.Get<Approval>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, approval, isDelta: false);
		return approval;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Approval previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Approval Deserialize(BufferStream stream, Approval instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.hostname = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.modded = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.official = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.ipaddress = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.port = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 90:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.encryption = ProtocolParser.ReadUInt32(stream);
				continue;
			case 106:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.levelTransfer = ProtocolParser.ReadBool(stream);
				continue;
			case 122:
				instance.version = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.levelConfig = ProtocolParser.ReadString(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexus = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.nexusEndpoint = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static Approval DeserializeLengthDelimited(BufferStream stream, Approval instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.hostname = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.modded = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.official = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.ipaddress = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.port = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 90:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.encryption = ProtocolParser.ReadUInt32(stream);
				continue;
			case 106:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.levelTransfer = ProtocolParser.ReadBool(stream);
				continue;
			case 122:
				instance.version = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.levelConfig = ProtocolParser.ReadString(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexus = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.nexusEndpoint = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Approval DeserializeLength(BufferStream stream, int length, Approval instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.hostname = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.modded = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.official = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.ipaddress = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.port = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 90:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.encryption = ProtocolParser.ReadUInt32(stream);
				continue;
			case 106:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.levelTransfer = ProtocolParser.ReadBool(stream);
				continue;
			case 122:
				instance.version = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.levelConfig = ProtocolParser.ReadString(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexus = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.nexusEndpoint = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Approval instance, Approval previous)
	{
		if (instance.level != previous.level)
		{
			if (instance.level == null)
			{
				throw new ArgumentNullException("level", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.level);
		}
		if (instance.hostname != null && instance.hostname != previous.hostname)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.hostname);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.modded);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.official);
		if (instance.steamid != previous.steamid)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.steamid);
		}
		if (instance.ipaddress != previous.ipaddress)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.ipaddress);
		}
		if (instance.port != previous.port)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.port);
		}
		if (instance.levelSeed != previous.levelSeed)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.levelSeed);
		}
		if (instance.levelSize != previous.levelSize)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.levelSize);
		}
		if (instance.checksum != null && instance.checksum != previous.checksum)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.checksum);
		}
		if (instance.encryption != previous.encryption)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.encryption);
		}
		if (instance.levelUrl != null && instance.levelUrl != previous.levelUrl)
		{
			stream.WriteByte(106);
			ProtocolParser.WriteString(stream, instance.levelUrl);
		}
		stream.WriteByte(112);
		ProtocolParser.WriteBool(stream, instance.levelTransfer);
		if (instance.version != null && instance.version != previous.version)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.version);
		}
		if (instance.levelConfig != null && instance.levelConfig != previous.levelConfig)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.levelConfig);
		}
		stream.WriteByte(136);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.nexus);
		if (instance.nexusEndpoint != null && instance.nexusEndpoint != previous.nexusEndpoint)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.nexusEndpoint);
		}
		if (instance.nexusId != previous.nexusId)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nexusId);
		}
	}

	public static void Serialize(BufferStream stream, Approval instance)
	{
		if (instance.level == null)
		{
			throw new ArgumentNullException("level", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.level);
		if (instance.hostname != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.hostname);
		}
		if (instance.modded)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.modded);
		}
		if (instance.official)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.official);
		}
		if (instance.steamid != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.steamid);
		}
		if (instance.ipaddress != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.ipaddress);
		}
		if (instance.port != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.port);
		}
		if (instance.levelSeed != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.levelSeed);
		}
		if (instance.levelSize != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.levelSize);
		}
		if (instance.checksum != null)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.checksum);
		}
		if (instance.encryption != 0)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.encryption);
		}
		if (instance.levelUrl != null)
		{
			stream.WriteByte(106);
			ProtocolParser.WriteString(stream, instance.levelUrl);
		}
		if (instance.levelTransfer)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteBool(stream, instance.levelTransfer);
		}
		if (instance.version != null)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.version);
		}
		if (instance.levelConfig != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.levelConfig);
		}
		if (instance.nexus)
		{
			stream.WriteByte(136);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.nexus);
		}
		if (instance.nexusEndpoint != null)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.nexusEndpoint);
		}
		if (instance.nexusId != 0)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nexusId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class UpdateItemContainer : IDisposable, IPooled, IProto<UpdateItemContainer>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public List<ItemContainer> container;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(UpdateItemContainer instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.type = 0;
		if (instance.container != null)
		{
			for (int i = 0; i < instance.container.Count; i++)
			{
				if (instance.container[i] != null)
				{
					instance.container[i].ResetToPool();
					instance.container[i] = null;
				}
			}
			List<ItemContainer> list = instance.container;
			Pool.Free<ItemContainer>(ref list, false);
			instance.container = list;
		}
		Pool.Free<UpdateItemContainer>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose UpdateItemContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(UpdateItemContainer instance)
	{
		instance.type = type;
		if (container != null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
			for (int i = 0; i < container.Count; i++)
			{
				ItemContainer item = container[i].Copy();
				instance.container.Add(item);
			}
		}
		else
		{
			instance.container = null;
		}
	}

	public UpdateItemContainer Copy()
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		CopyTo(updateItemContainer);
		return updateItemContainer;
	}

	public static UpdateItemContainer Deserialize(BufferStream stream)
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		Deserialize(stream, updateItemContainer, isDelta: false);
		return updateItemContainer;
	}

	public static UpdateItemContainer DeserializeLengthDelimited(BufferStream stream)
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		DeserializeLengthDelimited(stream, updateItemContainer, isDelta: false);
		return updateItemContainer;
	}

	public static UpdateItemContainer DeserializeLength(BufferStream stream, int length)
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		DeserializeLength(stream, length, updateItemContainer, isDelta: false);
		return updateItemContainer;
	}

	public static UpdateItemContainer Deserialize(byte[] buffer)
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, updateItemContainer, isDelta: false);
		return updateItemContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, UpdateItemContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static UpdateItemContainer Deserialize(BufferStream stream, UpdateItemContainer instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static UpdateItemContainer DeserializeLengthDelimited(BufferStream stream, UpdateItemContainer instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static UpdateItemContainer DeserializeLength(BufferStream stream, int length, UpdateItemContainer instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, UpdateItemContainer instance, UpdateItemContainer previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.container == null)
		{
			return;
		}
		for (int i = 0; i < instance.container.Count; i++)
		{
			ItemContainer itemContainer = instance.container[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, itemContainer, itemContainer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, UpdateItemContainer instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.container == null)
		{
			return;
		}
		for (int i = 0; i < instance.container.Count; i++)
		{
			ItemContainer instance2 = instance.container[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (container != null)
		{
			for (int i = 0; i < container.Count; i++)
			{
				container[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerUpdateLoot : IDisposable, IPooled, IProto<PlayerUpdateLoot>, IProto
{
	[NonSerialized]
	public ItemId itemID;

	[NonSerialized]
	public NetworkableId entityID;

	[NonSerialized]
	public List<ItemContainer> containers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerUpdateLoot instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.itemID = default(ItemId);
		instance.entityID = default(NetworkableId);
		if (instance.containers != null)
		{
			for (int i = 0; i < instance.containers.Count; i++)
			{
				if (instance.containers[i] != null)
				{
					instance.containers[i].ResetToPool();
					instance.containers[i] = null;
				}
			}
			List<ItemContainer> list = instance.containers;
			Pool.Free<ItemContainer>(ref list, false);
			instance.containers = list;
		}
		Pool.Free<PlayerUpdateLoot>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerUpdateLoot with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerUpdateLoot instance)
	{
		instance.itemID = itemID;
		instance.entityID = entityID;
		if (containers != null)
		{
			instance.containers = Pool.Get<List<ItemContainer>>();
			for (int i = 0; i < containers.Count; i++)
			{
				ItemContainer item = containers[i].Copy();
				instance.containers.Add(item);
			}
		}
		else
		{
			instance.containers = null;
		}
	}

	public PlayerUpdateLoot Copy()
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		CopyTo(playerUpdateLoot);
		return playerUpdateLoot;
	}

	public static PlayerUpdateLoot Deserialize(BufferStream stream)
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		Deserialize(stream, playerUpdateLoot, isDelta: false);
		return playerUpdateLoot;
	}

	public static PlayerUpdateLoot DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		DeserializeLengthDelimited(stream, playerUpdateLoot, isDelta: false);
		return playerUpdateLoot;
	}

	public static PlayerUpdateLoot DeserializeLength(BufferStream stream, int length)
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		DeserializeLength(stream, length, playerUpdateLoot, isDelta: false);
		return playerUpdateLoot;
	}

	public static PlayerUpdateLoot Deserialize(byte[] buffer)
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerUpdateLoot, isDelta: false);
		return playerUpdateLoot;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerUpdateLoot previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerUpdateLoot Deserialize(BufferStream stream, PlayerUpdateLoot instance, bool isDelta)
	{
		if (!isDelta && instance.containers == null)
		{
			instance.containers = Pool.Get<List<ItemContainer>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.containers.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerUpdateLoot DeserializeLengthDelimited(BufferStream stream, PlayerUpdateLoot instance, bool isDelta)
	{
		if (!isDelta && instance.containers == null)
		{
			instance.containers = Pool.Get<List<ItemContainer>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.containers.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerUpdateLoot DeserializeLength(BufferStream stream, int length, PlayerUpdateLoot instance, bool isDelta)
	{
		if (!isDelta && instance.containers == null)
		{
			instance.containers = Pool.Get<List<ItemContainer>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.containers.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerUpdateLoot instance, PlayerUpdateLoot previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.itemID.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
		if (instance.containers == null)
		{
			return;
		}
		for (int i = 0; i < instance.containers.Count; i++)
		{
			ItemContainer itemContainer = instance.containers[i];
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, itemContainer, itemContainer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, PlayerUpdateLoot instance)
	{
		if (instance.itemID != default(ItemId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.itemID.Value);
		}
		if (instance.entityID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
		}
		if (instance.containers == null)
		{
			return;
		}
		for (int i = 0; i < instance.containers.Count; i++)
		{
			ItemContainer instance2 = instance.containers[i];
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.ItemId, ref itemID.Value);
		action(UidType.NetworkableId, ref entityID.Value);
		if (containers != null)
		{
			for (int i = 0; i < containers.Count; i++)
			{
				containers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class UpdateItem : IDisposable, IPooled, IProto<UpdateItem>, IProto
{
	[NonSerialized]
	public Item item;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(UpdateItem instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.item != null)
			{
				instance.item.ResetToPool();
				instance.item = null;
			}
			Pool.Free<UpdateItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose UpdateItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(UpdateItem instance)
	{
		if (item != null)
		{
			if (instance.item == null)
			{
				instance.item = item.Copy();
			}
			else
			{
				item.CopyTo(instance.item);
			}
		}
		else
		{
			instance.item = null;
		}
	}

	public UpdateItem Copy()
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		CopyTo(updateItem);
		return updateItem;
	}

	public static UpdateItem Deserialize(BufferStream stream)
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		Deserialize(stream, updateItem, isDelta: false);
		return updateItem;
	}

	public static UpdateItem DeserializeLengthDelimited(BufferStream stream)
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		DeserializeLengthDelimited(stream, updateItem, isDelta: false);
		return updateItem;
	}

	public static UpdateItem DeserializeLength(BufferStream stream, int length)
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		DeserializeLength(stream, length, updateItem, isDelta: false);
		return updateItem;
	}

	public static UpdateItem Deserialize(byte[] buffer)
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, updateItem, isDelta: false);
		return updateItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, UpdateItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static UpdateItem Deserialize(BufferStream stream, UpdateItem instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.item == null)
				{
					instance.item = Item.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.DeserializeLengthDelimited(stream, instance.item, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static UpdateItem DeserializeLengthDelimited(BufferStream stream, UpdateItem instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.item == null)
				{
					instance.item = Item.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.DeserializeLengthDelimited(stream, instance.item, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static UpdateItem DeserializeLength(BufferStream stream, int length, UpdateItem instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.item == null)
				{
					instance.item = Item.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.DeserializeLengthDelimited(stream, instance.item, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, UpdateItem instance, UpdateItem previous)
	{
		if (instance.item == null)
		{
			throw new ArgumentNullException("item", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		Item.SerializeDelta(stream, instance.item, previous.item);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, UpdateItem instance)
	{
		if (instance.item == null)
		{
			throw new ArgumentNullException("item", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		Item.Serialize(stream, instance.item);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		item?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TakeDamage : IDisposable, IPooled, IProto<TakeDamage>, IProto
{
	[NonSerialized]
	public float amount;

	[NonSerialized]
	public Vector3 direction;

	[NonSerialized]
	public int type;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TakeDamage instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.amount = 0f;
			instance.direction = default(Vector3);
			instance.type = 0;
			Pool.Free<TakeDamage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TakeDamage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TakeDamage instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.amount = amount;
		instance.direction = direction;
		instance.type = type;
	}

	public TakeDamage Copy()
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		CopyTo(takeDamage);
		return takeDamage;
	}

	public static TakeDamage Deserialize(BufferStream stream)
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		Deserialize(stream, takeDamage, isDelta: false);
		return takeDamage;
	}

	public static TakeDamage DeserializeLengthDelimited(BufferStream stream)
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		DeserializeLengthDelimited(stream, takeDamage, isDelta: false);
		return takeDamage;
	}

	public static TakeDamage DeserializeLength(BufferStream stream, int length)
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		DeserializeLength(stream, length, takeDamage, isDelta: false);
		return takeDamage;
	}

	public static TakeDamage Deserialize(byte[] buffer)
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, takeDamage, isDelta: false);
		return takeDamage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TakeDamage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TakeDamage Deserialize(BufferStream stream, TakeDamage instance, bool isDelta)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.amount = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.direction, isDelta);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TakeDamage DeserializeLengthDelimited(BufferStream stream, TakeDamage instance, bool isDelta)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.amount = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.direction, isDelta);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TakeDamage DeserializeLength(BufferStream stream, int length, TakeDamage instance, bool isDelta)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.amount = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.direction, isDelta);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TakeDamage instance, TakeDamage previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.amount);
		}
		if (instance.direction != previous.direction)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.direction, previous.direction);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field direction (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.type != previous.type)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
	}

	public static void Serialize(BufferStream stream, TakeDamage instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (instance.amount != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.amount);
		}
		if (instance.direction != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.direction);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field direction (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class EntityList : IDisposable, IPooled, IProto<EntityList>, IProto
{
	[NonSerialized]
	public List<Entity> entity;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EntityList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entity != null)
		{
			for (int i = 0; i < instance.entity.Count; i++)
			{
				if (instance.entity[i] != null)
				{
					instance.entity[i].ResetToPool();
					instance.entity[i] = null;
				}
			}
			List<Entity> list = instance.entity;
			Pool.Free<Entity>(ref list, false);
			instance.entity = list;
		}
		Pool.Free<EntityList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EntityList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EntityList instance)
	{
		if (entity != null)
		{
			instance.entity = Pool.Get<List<Entity>>();
			for (int i = 0; i < entity.Count; i++)
			{
				Entity item = entity[i].Copy();
				instance.entity.Add(item);
			}
		}
		else
		{
			instance.entity = null;
		}
	}

	public EntityList Copy()
	{
		EntityList entityList = Pool.Get<EntityList>();
		CopyTo(entityList);
		return entityList;
	}

	public static EntityList Deserialize(BufferStream stream)
	{
		EntityList entityList = Pool.Get<EntityList>();
		Deserialize(stream, entityList, isDelta: false);
		return entityList;
	}

	public static EntityList DeserializeLengthDelimited(BufferStream stream)
	{
		EntityList entityList = Pool.Get<EntityList>();
		DeserializeLengthDelimited(stream, entityList, isDelta: false);
		return entityList;
	}

	public static EntityList DeserializeLength(BufferStream stream, int length)
	{
		EntityList entityList = Pool.Get<EntityList>();
		DeserializeLength(stream, length, entityList, isDelta: false);
		return entityList;
	}

	public static EntityList Deserialize(byte[] buffer)
	{
		EntityList entityList = Pool.Get<EntityList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entityList, isDelta: false);
		return entityList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EntityList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EntityList Deserialize(BufferStream stream, EntityList instance, bool isDelta)
	{
		if (!isDelta && instance.entity == null)
		{
			instance.entity = Pool.Get<List<Entity>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entity.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EntityList DeserializeLengthDelimited(BufferStream stream, EntityList instance, bool isDelta)
	{
		if (!isDelta && instance.entity == null)
		{
			instance.entity = Pool.Get<List<Entity>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entity.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EntityList DeserializeLength(BufferStream stream, int length, EntityList instance, bool isDelta)
	{
		if (!isDelta && instance.entity == null)
		{
			instance.entity = Pool.Get<List<Entity>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entity.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EntityList instance, EntityList previous)
	{
		if (instance.entity == null)
		{
			return;
		}
		for (int i = 0; i < instance.entity.Count; i++)
		{
			Entity entity = instance.entity[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entity.SerializeDelta(stream, entity, entity);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, EntityList instance)
	{
		if (instance.entity == null)
		{
			return;
		}
		for (int i = 0; i < instance.entity.Count; i++)
		{
			Entity instance2 = instance.entity[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entity.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entity != null)
		{
			for (int i = 0; i < entity.Count; i++)
			{
				entity[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class CreateBuilding : IDisposable, IPooled, IProto<CreateBuilding>, IProto
{
	[NonSerialized]
	public NetworkableId entity;

	[NonSerialized]
	public uint socket;

	[NonSerialized]
	public bool onterrain;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 normal;

	[NonSerialized]
	public Ray ray;

	[NonSerialized]
	public uint blockID;

	[NonSerialized]
	public Vector3 rotation;

	[NonSerialized]
	public bool isHoldingShift;

	[NonSerialized]
	public int setToGrade;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CreateBuilding instance)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.entity = default(NetworkableId);
			instance.socket = 0u;
			instance.onterrain = false;
			instance.position = default(Vector3);
			instance.normal = default(Vector3);
			instance.ray = default(Ray);
			instance.blockID = 0u;
			instance.rotation = default(Vector3);
			instance.isHoldingShift = false;
			instance.setToGrade = 0;
			Pool.Free<CreateBuilding>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CreateBuilding with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CreateBuilding instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.entity = entity;
		instance.socket = socket;
		instance.onterrain = onterrain;
		instance.position = position;
		instance.normal = normal;
		instance.ray = ray;
		instance.blockID = blockID;
		instance.rotation = rotation;
		instance.isHoldingShift = isHoldingShift;
		instance.setToGrade = setToGrade;
	}

	public CreateBuilding Copy()
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		CopyTo(createBuilding);
		return createBuilding;
	}

	public static CreateBuilding Deserialize(BufferStream stream)
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		Deserialize(stream, createBuilding, isDelta: false);
		return createBuilding;
	}

	public static CreateBuilding DeserializeLengthDelimited(BufferStream stream)
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		DeserializeLengthDelimited(stream, createBuilding, isDelta: false);
		return createBuilding;
	}

	public static CreateBuilding DeserializeLength(BufferStream stream, int length)
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		DeserializeLength(stream, length, createBuilding, isDelta: false);
		return createBuilding;
	}

	public static CreateBuilding Deserialize(byte[] buffer)
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, createBuilding, isDelta: false);
		return createBuilding;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CreateBuilding previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CreateBuilding Deserialize(BufferStream stream, CreateBuilding instance, bool isDelta)
	{
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.socket = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.onterrain = ProtocolParser.ReadBool(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 50:
				RaySerialized.DeserializeLengthDelimited(stream, ref instance.ray, isDelta);
				continue;
			case 56:
				instance.blockID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 72:
				instance.isHoldingShift = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.setToGrade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CreateBuilding DeserializeLengthDelimited(BufferStream stream, CreateBuilding instance, bool isDelta)
	{
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.socket = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.onterrain = ProtocolParser.ReadBool(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 50:
				RaySerialized.DeserializeLengthDelimited(stream, ref instance.ray, isDelta);
				continue;
			case 56:
				instance.blockID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 72:
				instance.isHoldingShift = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.setToGrade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CreateBuilding DeserializeLength(BufferStream stream, int length, CreateBuilding instance, bool isDelta)
	{
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.socket = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.onterrain = ProtocolParser.ReadBool(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 50:
				RaySerialized.DeserializeLengthDelimited(stream, ref instance.ray, isDelta);
				continue;
			case 56:
				instance.blockID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 72:
				instance.isHoldingShift = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.setToGrade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CreateBuilding instance, CreateBuilding previous)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entity.Value);
		if (instance.socket != previous.socket)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.socket);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.onterrain);
		if (instance.position != previous.position)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.normal != previous.normal)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range3 = stream.GetRange(1);
		int num5 = stream.Position;
		RaySerialized.SerializeDelta(stream, instance.ray, previous.ray);
		int num6 = stream.Position - num5;
		if (num6 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ray (UnityEngine.Ray)");
		}
		Span<byte> span3 = range3.GetSpan();
		ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		if (instance.blockID != previous.blockID)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.blockID);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rotation, previous.rotation);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.isHoldingShift);
		if (instance.setToGrade != previous.setToGrade)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.setToGrade);
		}
	}

	public static void Serialize(BufferStream stream, CreateBuilding instance)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entity != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entity.Value);
		}
		if (instance.socket != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.socket);
		}
		if (instance.onterrain)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.onterrain);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.normal != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.normal);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (((Ray)(ref instance.ray)).origin != default(Vector3) && ((Ray)(ref instance.ray)).direction != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			RaySerialized.Serialize(stream, instance.ray);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ray (UnityEngine.Ray)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.blockID != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.blockID);
		}
		if (instance.rotation != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rotation);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		if (instance.isHoldingShift)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.isHoldingShift);
		}
		if (instance.setToGrade != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.setToGrade);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Attack : IDisposable, IPooled, IProto<Attack>, IProto
{
	[NonSerialized]
	public Vector3 pointStart;

	[NonSerialized]
	public Vector3 pointEnd;

	[NonSerialized]
	public NetworkableId hitID;

	[NonSerialized]
	public uint hitBone;

	[NonSerialized]
	public Vector3 hitNormalLocal;

	[NonSerialized]
	public Vector3 hitPositionLocal;

	[NonSerialized]
	public Vector3 hitNormalWorld;

	[NonSerialized]
	public Vector3 hitPositionWorld;

	[NonSerialized]
	public uint hitPartID;

	[NonSerialized]
	public uint hitMaterialID;

	[NonSerialized]
	public NetworkableId srcParentID;

	[NonSerialized]
	public NetworkableId dstParentID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Attack instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.pointStart = default(Vector3);
			instance.pointEnd = default(Vector3);
			instance.hitID = default(NetworkableId);
			instance.hitBone = 0u;
			instance.hitNormalLocal = default(Vector3);
			instance.hitPositionLocal = default(Vector3);
			instance.hitNormalWorld = default(Vector3);
			instance.hitPositionWorld = default(Vector3);
			instance.hitPartID = 0u;
			instance.hitMaterialID = 0u;
			instance.srcParentID = default(NetworkableId);
			instance.dstParentID = default(NetworkableId);
			Pool.Free<Attack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Attack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Attack instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.pointStart = pointStart;
		instance.pointEnd = pointEnd;
		instance.hitID = hitID;
		instance.hitBone = hitBone;
		instance.hitNormalLocal = hitNormalLocal;
		instance.hitPositionLocal = hitPositionLocal;
		instance.hitNormalWorld = hitNormalWorld;
		instance.hitPositionWorld = hitPositionWorld;
		instance.hitPartID = hitPartID;
		instance.hitMaterialID = hitMaterialID;
		instance.srcParentID = srcParentID;
		instance.dstParentID = dstParentID;
	}

	public Attack Copy()
	{
		Attack attack = Pool.Get<Attack>();
		CopyTo(attack);
		return attack;
	}

	public static Attack Deserialize(BufferStream stream)
	{
		Attack attack = Pool.Get<Attack>();
		Deserialize(stream, attack, isDelta: false);
		return attack;
	}

	public static Attack DeserializeLengthDelimited(BufferStream stream)
	{
		Attack attack = Pool.Get<Attack>();
		DeserializeLengthDelimited(stream, attack, isDelta: false);
		return attack;
	}

	public static Attack DeserializeLength(BufferStream stream, int length)
	{
		Attack attack = Pool.Get<Attack>();
		DeserializeLength(stream, length, attack, isDelta: false);
		return attack;
	}

	public static Attack Deserialize(byte[] buffer)
	{
		Attack attack = Pool.Get<Attack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, attack, isDelta: false);
		return attack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Attack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Attack Deserialize(BufferStream stream, Attack instance, bool isDelta)
	{
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointStart, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointEnd, isDelta);
				continue;
			case 24:
				instance.hitID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.hitBone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalLocal, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionLocal, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalWorld, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionWorld, isDelta);
				continue;
			case 72:
				instance.hitPartID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.hitMaterialID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.srcParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.dstParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Attack DeserializeLengthDelimited(BufferStream stream, Attack instance, bool isDelta)
	{
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointStart, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointEnd, isDelta);
				continue;
			case 24:
				instance.hitID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.hitBone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalLocal, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionLocal, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalWorld, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionWorld, isDelta);
				continue;
			case 72:
				instance.hitPartID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.hitMaterialID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.srcParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.dstParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Attack DeserializeLength(BufferStream stream, int length, Attack instance, bool isDelta)
	{
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointStart, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointEnd, isDelta);
				continue;
			case 24:
				instance.hitID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.hitBone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalLocal, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionLocal, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalWorld, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionWorld, isDelta);
				continue;
			case 72:
				instance.hitPartID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.hitMaterialID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.srcParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.dstParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Attack instance, Attack previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pointStart != previous.pointStart)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.pointStart, previous.pointStart);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pointStart (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.pointEnd != previous.pointEnd)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.pointEnd, previous.pointEnd);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pointEnd (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.hitID.Value);
		if (instance.hitBone != previous.hitBone)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.hitBone);
		}
		if (instance.hitNormalLocal != previous.hitNormalLocal)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitNormalLocal, previous.hitNormalLocal);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormalLocal (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.hitPositionLocal != previous.hitPositionLocal)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitPositionLocal, previous.hitPositionLocal);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPositionLocal (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.hitNormalWorld != previous.hitNormalWorld)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitNormalWorld, previous.hitNormalWorld);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormalWorld (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.hitPositionWorld != previous.hitPositionWorld)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitPositionWorld, previous.hitPositionWorld);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPositionWorld (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.hitPartID != previous.hitPartID)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.hitPartID);
		}
		if (instance.hitMaterialID != previous.hitMaterialID)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.hitMaterialID);
		}
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, instance.srcParentID.Value);
		stream.WriteByte(96);
		ProtocolParser.WriteUInt64(stream, instance.dstParentID.Value);
	}

	public static void Serialize(BufferStream stream, Attack instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pointStart != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.pointStart);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pointStart (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.pointEnd != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.pointEnd);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pointEnd (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.hitID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.hitID.Value);
		}
		if (instance.hitBone != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.hitBone);
		}
		if (instance.hitNormalLocal != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitNormalLocal);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormalLocal (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.hitPositionLocal != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitPositionLocal);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPositionLocal (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.hitNormalWorld != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitNormalWorld);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormalWorld (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.hitPositionWorld != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitPositionWorld);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPositionWorld (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.hitPartID != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.hitPartID);
		}
		if (instance.hitMaterialID != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.hitMaterialID);
		}
		if (instance.srcParentID != default(NetworkableId))
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, instance.srcParentID.Value);
		}
		if (instance.dstParentID != default(NetworkableId))
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt64(stream, instance.dstParentID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref hitID.Value);
		action(UidType.NetworkableId, ref srcParentID.Value);
		action(UidType.NetworkableId, ref dstParentID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerAttack : IDisposable, IPooled, IProto<PlayerAttack>, IProto
{
	[NonSerialized]
	public Attack attack;

	[NonSerialized]
	public int projectileID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerAttack instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.attack != null)
			{
				instance.attack.ResetToPool();
				instance.attack = null;
			}
			instance.projectileID = 0;
			Pool.Free<PlayerAttack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerAttack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerAttack instance)
	{
		if (attack != null)
		{
			if (instance.attack == null)
			{
				instance.attack = attack.Copy();
			}
			else
			{
				attack.CopyTo(instance.attack);
			}
		}
		else
		{
			instance.attack = null;
		}
		instance.projectileID = projectileID;
	}

	public PlayerAttack Copy()
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		CopyTo(playerAttack);
		return playerAttack;
	}

	public static PlayerAttack Deserialize(BufferStream stream)
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		Deserialize(stream, playerAttack, isDelta: false);
		return playerAttack;
	}

	public static PlayerAttack DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		DeserializeLengthDelimited(stream, playerAttack, isDelta: false);
		return playerAttack;
	}

	public static PlayerAttack DeserializeLength(BufferStream stream, int length)
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		DeserializeLength(stream, length, playerAttack, isDelta: false);
		return playerAttack;
	}

	public static PlayerAttack Deserialize(byte[] buffer)
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerAttack, isDelta: false);
		return playerAttack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerAttack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerAttack Deserialize(BufferStream stream, PlayerAttack instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.attack == null)
				{
					instance.attack = Attack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Attack.DeserializeLengthDelimited(stream, instance.attack, isDelta);
				}
				break;
			case 16:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static PlayerAttack DeserializeLengthDelimited(BufferStream stream, PlayerAttack instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.attack == null)
				{
					instance.attack = Attack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Attack.DeserializeLengthDelimited(stream, instance.attack, isDelta);
				}
				break;
			case 16:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerAttack DeserializeLength(BufferStream stream, int length, PlayerAttack instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.attack == null)
				{
					instance.attack = Attack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Attack.DeserializeLengthDelimited(stream, instance.attack, isDelta);
				}
				break;
			case 16:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerAttack instance, PlayerAttack previous)
	{
		if (instance.attack == null)
		{
			throw new ArgumentNullException("attack", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(2);
		int position = stream.Position;
		Attack.SerializeDelta(stream, instance.attack, previous.attack);
		int num = stream.Position - position;
		if (num > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field attack (ProtoBuf.Attack)");
		}
		Span<byte> span = range.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
		{
			span[0] |= 128;
			span[1] = 0;
		}
		if (instance.projectileID != previous.projectileID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
	}

	public static void Serialize(BufferStream stream, PlayerAttack instance)
	{
		if (instance.attack == null)
		{
			throw new ArgumentNullException("attack", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(2);
		int position = stream.Position;
		Attack.Serialize(stream, instance.attack);
		int num = stream.Position - position;
		if (num > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field attack (ProtoBuf.Attack)");
		}
		Span<byte> span = range.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
		{
			span[0] |= 128;
			span[1] = 0;
		}
		if (instance.projectileID != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		attack?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerProjectileAttack : IDisposable, IPooled, IProto<PlayerProjectileAttack>, IProto
{
	[NonSerialized]
	public PlayerAttack playerAttack;

	[NonSerialized]
	public Vector3 hitVelocity;

	[NonSerialized]
	public float hitDistance;

	[NonSerialized]
	public float travelTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerProjectileAttack instance)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			if (instance.playerAttack != null)
			{
				instance.playerAttack.ResetToPool();
				instance.playerAttack = null;
			}
			instance.hitVelocity = default(Vector3);
			instance.hitDistance = 0f;
			instance.travelTime = 0f;
			Pool.Free<PlayerProjectileAttack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerProjectileAttack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerProjectileAttack instance)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (playerAttack != null)
		{
			if (instance.playerAttack == null)
			{
				instance.playerAttack = playerAttack.Copy();
			}
			else
			{
				playerAttack.CopyTo(instance.playerAttack);
			}
		}
		else
		{
			instance.playerAttack = null;
		}
		instance.hitVelocity = hitVelocity;
		instance.hitDistance = hitDistance;
		instance.travelTime = travelTime;
	}

	public PlayerProjectileAttack Copy()
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		CopyTo(playerProjectileAttack);
		return playerProjectileAttack;
	}

	public static PlayerProjectileAttack Deserialize(BufferStream stream)
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		Deserialize(stream, playerProjectileAttack, isDelta: false);
		return playerProjectileAttack;
	}

	public static PlayerProjectileAttack DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		DeserializeLengthDelimited(stream, playerProjectileAttack, isDelta: false);
		return playerProjectileAttack;
	}

	public static PlayerProjectileAttack DeserializeLength(BufferStream stream, int length)
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		DeserializeLength(stream, length, playerProjectileAttack, isDelta: false);
		return playerProjectileAttack;
	}

	public static PlayerProjectileAttack Deserialize(byte[] buffer)
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerProjectileAttack, isDelta: false);
		return playerProjectileAttack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerProjectileAttack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerProjectileAttack Deserialize(BufferStream stream, PlayerProjectileAttack instance, bool isDelta)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.playerAttack == null)
				{
					instance.playerAttack = PlayerAttack.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerAttack.DeserializeLengthDelimited(stream, instance.playerAttack, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitVelocity, isDelta);
				break;
			case 29:
				instance.hitDistance = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static PlayerProjectileAttack DeserializeLengthDelimited(BufferStream stream, PlayerProjectileAttack instance, bool isDelta)
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.playerAttack == null)
				{
					instance.playerAttack = PlayerAttack.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerAttack.DeserializeLengthDelimited(stream, instance.playerAttack, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitVelocity, isDelta);
				break;
			case 29:
				instance.hitDistance = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerProjectileAttack DeserializeLength(BufferStream stream, int length, PlayerProjectileAttack instance, bool isDelta)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.playerAttack == null)
				{
					instance.playerAttack = PlayerAttack.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerAttack.DeserializeLengthDelimited(stream, instance.playerAttack, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitVelocity, isDelta);
				break;
			case 29:
				instance.hitDistance = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerProjectileAttack instance, PlayerProjectileAttack previous)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		if (instance.playerAttack == null)
		{
			throw new ArgumentNullException("playerAttack", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(2);
		int position = stream.Position;
		PlayerAttack.SerializeDelta(stream, instance.playerAttack, previous.playerAttack);
		int num = stream.Position - position;
		if (num > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerAttack (ProtoBuf.PlayerAttack)");
		}
		Span<byte> span = range.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
		{
			span[0] |= 128;
			span[1] = 0;
		}
		if (instance.hitVelocity != previous.hitVelocity)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitVelocity, previous.hitVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.hitDistance != previous.hitDistance)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.hitDistance);
		}
		if (instance.travelTime != previous.travelTime)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public static void Serialize(BufferStream stream, PlayerProjectileAttack instance)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.playerAttack == null)
		{
			throw new ArgumentNullException("playerAttack", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(2);
		int position = stream.Position;
		PlayerAttack.Serialize(stream, instance.playerAttack);
		int num = stream.Position - position;
		if (num > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerAttack (ProtoBuf.PlayerAttack)");
		}
		Span<byte> span = range.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
		{
			span[0] |= 128;
			span[1] = 0;
		}
		if (instance.hitVelocity != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.hitDistance != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.hitDistance);
		}
		if (instance.travelTime != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		playerAttack?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerProjectileRicochet : IDisposable, IPooled, IProto<PlayerProjectileRicochet>, IProto
{
	[NonSerialized]
	public int projectileID;

	[NonSerialized]
	public Vector3 hitPosition;

	[NonSerialized]
	public Vector3 inVelocity;

	[NonSerialized]
	public Vector3 outVelocity;

	[NonSerialized]
	public Vector3 hitNormal;

	[NonSerialized]
	public float travelTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerProjectileRicochet instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.projectileID = 0;
			instance.hitPosition = default(Vector3);
			instance.inVelocity = default(Vector3);
			instance.outVelocity = default(Vector3);
			instance.hitNormal = default(Vector3);
			instance.travelTime = 0f;
			Pool.Free<PlayerProjectileRicochet>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerProjectileRicochet with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerProjectileRicochet instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.projectileID = projectileID;
		instance.hitPosition = hitPosition;
		instance.inVelocity = inVelocity;
		instance.outVelocity = outVelocity;
		instance.hitNormal = hitNormal;
		instance.travelTime = travelTime;
	}

	public PlayerProjectileRicochet Copy()
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		CopyTo(playerProjectileRicochet);
		return playerProjectileRicochet;
	}

	public static PlayerProjectileRicochet Deserialize(BufferStream stream)
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		Deserialize(stream, playerProjectileRicochet, isDelta: false);
		return playerProjectileRicochet;
	}

	public static PlayerProjectileRicochet DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		DeserializeLengthDelimited(stream, playerProjectileRicochet, isDelta: false);
		return playerProjectileRicochet;
	}

	public static PlayerProjectileRicochet DeserializeLength(BufferStream stream, int length)
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		DeserializeLength(stream, length, playerProjectileRicochet, isDelta: false);
		return playerProjectileRicochet;
	}

	public static PlayerProjectileRicochet Deserialize(byte[] buffer)
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerProjectileRicochet, isDelta: false);
		return playerProjectileRicochet;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerProjectileRicochet previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerProjectileRicochet Deserialize(BufferStream stream, PlayerProjectileRicochet instance, bool isDelta)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inVelocity, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.outVelocity, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormal, isDelta);
				continue;
			case 53:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerProjectileRicochet DeserializeLengthDelimited(BufferStream stream, PlayerProjectileRicochet instance, bool isDelta)
	{
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inVelocity, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.outVelocity, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormal, isDelta);
				continue;
			case 53:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerProjectileRicochet DeserializeLength(BufferStream stream, int length, PlayerProjectileRicochet instance, bool isDelta)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inVelocity, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.outVelocity, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormal, isDelta);
				continue;
			case 53:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerProjectileRicochet instance, PlayerProjectileRicochet previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != previous.projectileID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.hitPosition != previous.hitPosition)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitPosition, previous.hitPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.inVelocity != previous.inVelocity)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.inVelocity, previous.inVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.outVelocity != previous.outVelocity)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.outVelocity, previous.outVelocity);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field outVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.hitNormal != previous.hitNormal)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitNormal, previous.hitNormal);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormal (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.travelTime != previous.travelTime)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public static void Serialize(BufferStream stream, PlayerProjectileRicochet instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.hitPosition != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.inVelocity != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.inVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.outVelocity != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.outVelocity);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field outVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.hitNormal != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitNormal);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormal (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.travelTime != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerProjectileUpdate : IDisposable, IPooled, IProto<PlayerProjectileUpdate>, IProto
{
	[NonSerialized]
	public int projectileID;

	[NonSerialized]
	public Vector3 curPosition;

	[NonSerialized]
	public Vector3 curVelocity;

	[NonSerialized]
	public float travelTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerProjectileUpdate instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.projectileID = 0;
			instance.curPosition = default(Vector3);
			instance.curVelocity = default(Vector3);
			instance.travelTime = 0f;
			Pool.Free<PlayerProjectileUpdate>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerProjectileUpdate with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerProjectileUpdate instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.projectileID = projectileID;
		instance.curPosition = curPosition;
		instance.curVelocity = curVelocity;
		instance.travelTime = travelTime;
	}

	public PlayerProjectileUpdate Copy()
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		CopyTo(playerProjectileUpdate);
		return playerProjectileUpdate;
	}

	public static PlayerProjectileUpdate Deserialize(BufferStream stream)
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		Deserialize(stream, playerProjectileUpdate, isDelta: false);
		return playerProjectileUpdate;
	}

	public static PlayerProjectileUpdate DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		DeserializeLengthDelimited(stream, playerProjectileUpdate, isDelta: false);
		return playerProjectileUpdate;
	}

	public static PlayerProjectileUpdate DeserializeLength(BufferStream stream, int length)
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		DeserializeLength(stream, length, playerProjectileUpdate, isDelta: false);
		return playerProjectileUpdate;
	}

	public static PlayerProjectileUpdate Deserialize(byte[] buffer)
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerProjectileUpdate, isDelta: false);
		return playerProjectileUpdate;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerProjectileUpdate previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerProjectileUpdate Deserialize(BufferStream stream, PlayerProjectileUpdate instance, bool isDelta)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curVelocity, isDelta);
				continue;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerProjectileUpdate DeserializeLengthDelimited(BufferStream stream, PlayerProjectileUpdate instance, bool isDelta)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curVelocity, isDelta);
				continue;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerProjectileUpdate DeserializeLength(BufferStream stream, int length, PlayerProjectileUpdate instance, bool isDelta)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curVelocity, isDelta);
				continue;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerProjectileUpdate instance, PlayerProjectileUpdate previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != previous.projectileID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.curPosition != previous.curPosition)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.curPosition, previous.curPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.curVelocity != previous.curVelocity)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.curVelocity, previous.curVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.travelTime != previous.travelTime)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public static void Serialize(BufferStream stream, PlayerProjectileUpdate instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.curPosition != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.curPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.curVelocity != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.curVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.travelTime != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ProjectileShoot : IDisposable, IPooled, IProto<ProjectileShoot>, IProto
{
	public class Projectile : IDisposable, IPooled, IProto<Projectile>, IProto
	{
		[NonSerialized]
		public int projectileID;

		[NonSerialized]
		public Vector3 startPos;

		[NonSerialized]
		public Vector3 startVel;

		[NonSerialized]
		public int seed;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Projectile instance)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.projectileID = 0;
				instance.startPos = default(Vector3);
				instance.startVel = default(Vector3);
				instance.seed = 0;
				Pool.Free<Projectile>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Projectile with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Projectile instance)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			instance.projectileID = projectileID;
			instance.startPos = startPos;
			instance.startVel = startVel;
			instance.seed = seed;
		}

		public Projectile Copy()
		{
			Projectile projectile = Pool.Get<Projectile>();
			CopyTo(projectile);
			return projectile;
		}

		public static Projectile Deserialize(BufferStream stream)
		{
			Projectile projectile = Pool.Get<Projectile>();
			Deserialize(stream, projectile, isDelta: false);
			return projectile;
		}

		public static Projectile DeserializeLengthDelimited(BufferStream stream)
		{
			Projectile projectile = Pool.Get<Projectile>();
			DeserializeLengthDelimited(stream, projectile, isDelta: false);
			return projectile;
		}

		public static Projectile DeserializeLength(BufferStream stream, int length)
		{
			Projectile projectile = Pool.Get<Projectile>();
			DeserializeLength(stream, length, projectile, isDelta: false);
			return projectile;
		}

		public static Projectile Deserialize(byte[] buffer)
		{
			Projectile projectile = Pool.Get<Projectile>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, projectile, isDelta: false);
			return projectile;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Projectile previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Projectile Deserialize(BufferStream stream, Projectile instance, bool isDelta)
		{
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
					continue;
				case 32:
					instance.seed = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Projectile DeserializeLengthDelimited(BufferStream stream, Projectile instance, bool isDelta)
		{
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
					continue;
				case 32:
					instance.seed = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Projectile DeserializeLength(BufferStream stream, int length, Projectile instance, bool isDelta)
		{
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
					continue;
				case 32:
					instance.seed = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Projectile instance, Projectile previous)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			if (instance.projectileID != previous.projectileID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
			}
			if (instance.startPos != previous.startPos)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.startPos, previous.startPos);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.startVel != previous.startVel)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.startVel, previous.startVel);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startVel (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.seed != previous.seed)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.seed);
			}
		}

		public static void Serialize(BufferStream stream, Projectile instance)
		{
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			if (instance.projectileID != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
			}
			if (instance.startPos != default(Vector3))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance.startPos);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.startVel != default(Vector3))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.startVel);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startVel (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.seed != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.seed);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public int ammoType;

	[NonSerialized]
	public List<Projectile> projectiles;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ProjectileShoot instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.ammoType = 0;
		if (instance.projectiles != null)
		{
			for (int i = 0; i < instance.projectiles.Count; i++)
			{
				if (instance.projectiles[i] != null)
				{
					instance.projectiles[i].ResetToPool();
					instance.projectiles[i] = null;
				}
			}
			List<Projectile> list = instance.projectiles;
			Pool.Free<Projectile>(ref list, false);
			instance.projectiles = list;
		}
		Pool.Free<ProjectileShoot>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ProjectileShoot with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ProjectileShoot instance)
	{
		instance.ammoType = ammoType;
		if (projectiles != null)
		{
			instance.projectiles = Pool.Get<List<Projectile>>();
			for (int i = 0; i < projectiles.Count; i++)
			{
				Projectile item = projectiles[i].Copy();
				instance.projectiles.Add(item);
			}
		}
		else
		{
			instance.projectiles = null;
		}
	}

	public ProjectileShoot Copy()
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		CopyTo(projectileShoot);
		return projectileShoot;
	}

	public static ProjectileShoot Deserialize(BufferStream stream)
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		Deserialize(stream, projectileShoot, isDelta: false);
		return projectileShoot;
	}

	public static ProjectileShoot DeserializeLengthDelimited(BufferStream stream)
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		DeserializeLengthDelimited(stream, projectileShoot, isDelta: false);
		return projectileShoot;
	}

	public static ProjectileShoot DeserializeLength(BufferStream stream, int length)
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		DeserializeLength(stream, length, projectileShoot, isDelta: false);
		return projectileShoot;
	}

	public static ProjectileShoot Deserialize(byte[] buffer)
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, projectileShoot, isDelta: false);
		return projectileShoot;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ProjectileShoot previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ProjectileShoot Deserialize(BufferStream stream, ProjectileShoot instance, bool isDelta)
	{
		if (!isDelta && instance.projectiles == null)
		{
			instance.projectiles = Pool.Get<List<Projectile>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.projectiles.Add(Projectile.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ProjectileShoot DeserializeLengthDelimited(BufferStream stream, ProjectileShoot instance, bool isDelta)
	{
		if (!isDelta && instance.projectiles == null)
		{
			instance.projectiles = Pool.Get<List<Projectile>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.projectiles.Add(Projectile.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ProjectileShoot DeserializeLength(BufferStream stream, int length, ProjectileShoot instance, bool isDelta)
	{
		if (!isDelta && instance.projectiles == null)
		{
			instance.projectiles = Pool.Get<List<Projectile>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.projectiles.Add(Projectile.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ProjectileShoot instance, ProjectileShoot previous)
	{
		if (instance.ammoType != previous.ammoType)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
		if (instance.projectiles == null)
		{
			return;
		}
		for (int i = 0; i < instance.projectiles.Count; i++)
		{
			Projectile projectile = instance.projectiles[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Projectile.SerializeDelta(stream, projectile, projectile);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field projectiles (ProtoBuf.ProjectileShoot.Projectile)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ProjectileShoot instance)
	{
		if (instance.ammoType != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
		if (instance.projectiles == null)
		{
			return;
		}
		for (int i = 0; i < instance.projectiles.Count; i++)
		{
			Projectile instance2 = instance.projectiles[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Projectile.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field projectiles (ProtoBuf.ProjectileShoot.Projectile)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (projectiles != null)
		{
			for (int i = 0; i < projectiles.Count; i++)
			{
				projectiles[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ModuleMessage : IDisposable, IPooled, IProto<ModuleMessage>, IProto
{
	[NonSerialized]
	public uint itemid;

	[NonSerialized]
	public int moduleid;

	[NonSerialized]
	public int type;

	[NonSerialized]
	public byte[] data;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ModuleMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemid = 0u;
			instance.moduleid = 0;
			instance.type = 0;
			instance.data = null;
			Pool.Free<ModuleMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ModuleMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ModuleMessage instance)
	{
		instance.itemid = itemid;
		instance.moduleid = moduleid;
		instance.type = type;
		if (data == null)
		{
			instance.data = null;
			return;
		}
		instance.data = new byte[data.Length];
		Array.Copy(data, instance.data, instance.data.Length);
	}

	public ModuleMessage Copy()
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		CopyTo(moduleMessage);
		return moduleMessage;
	}

	public static ModuleMessage Deserialize(BufferStream stream)
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		Deserialize(stream, moduleMessage, isDelta: false);
		return moduleMessage;
	}

	public static ModuleMessage DeserializeLengthDelimited(BufferStream stream)
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		DeserializeLengthDelimited(stream, moduleMessage, isDelta: false);
		return moduleMessage;
	}

	public static ModuleMessage DeserializeLength(BufferStream stream, int length)
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		DeserializeLength(stream, length, moduleMessage, isDelta: false);
		return moduleMessage;
	}

	public static ModuleMessage Deserialize(byte[] buffer)
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, moduleMessage, isDelta: false);
		return moduleMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ModuleMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ModuleMessage Deserialize(BufferStream stream, ModuleMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.moduleid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ModuleMessage DeserializeLengthDelimited(BufferStream stream, ModuleMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.moduleid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ModuleMessage DeserializeLength(BufferStream stream, int length, ModuleMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.moduleid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ModuleMessage instance, ModuleMessage previous)
	{
		if (instance.itemid != previous.itemid)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.itemid);
		}
		if (instance.moduleid != previous.moduleid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.moduleid);
		}
		if (instance.type != previous.type)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.data != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteBytes(stream, instance.data);
		}
	}

	public static void Serialize(BufferStream stream, ModuleMessage instance)
	{
		if (instance.itemid != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.itemid);
		}
		if (instance.moduleid != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.moduleid);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.data != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteBytes(stream, instance.data);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class RespawnInformation : IDisposable, IPooled, IProto<RespawnInformation>, IProto
{
	public class SpawnOptions : IDisposable, IPooled, IProto<SpawnOptions>, IProto
	{
		public enum RespawnType
		{
			SleepingBag = 1,
			Bed,
			BeachTowel,
			Camper,
			Static
		}

		public enum RespawnState
		{
			OK = 1,
			Occupied,
			Underwater,
			InNoRespawnZone
		}

		[NonSerialized]
		public RespawnType type;

		[NonSerialized]
		public NetworkableId id;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public float unlockSeconds;

		[NonSerialized]
		public Vector3 worldPosition;

		[NonSerialized]
		public RespawnState respawnState;

		[NonSerialized]
		public bool mobile;

		[NonSerialized]
		public string nexusZone;

		[NonSerialized]
		public bool corpse;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SpawnOptions instance)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.type = (RespawnType)0;
				instance.id = default(NetworkableId);
				instance.name = string.Empty;
				instance.unlockSeconds = 0f;
				instance.worldPosition = default(Vector3);
				instance.respawnState = (RespawnState)0;
				instance.mobile = false;
				instance.nexusZone = string.Empty;
				instance.corpse = false;
				Pool.Free<SpawnOptions>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SpawnOptions with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SpawnOptions instance)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			instance.type = type;
			instance.id = id;
			instance.name = name;
			instance.unlockSeconds = unlockSeconds;
			instance.worldPosition = worldPosition;
			instance.respawnState = respawnState;
			instance.mobile = mobile;
			instance.nexusZone = nexusZone;
			instance.corpse = corpse;
		}

		public SpawnOptions Copy()
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			CopyTo(spawnOptions);
			return spawnOptions;
		}

		public static SpawnOptions Deserialize(BufferStream stream)
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			Deserialize(stream, spawnOptions, isDelta: false);
			return spawnOptions;
		}

		public static SpawnOptions DeserializeLengthDelimited(BufferStream stream)
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			DeserializeLengthDelimited(stream, spawnOptions, isDelta: false);
			return spawnOptions;
		}

		public static SpawnOptions DeserializeLength(BufferStream stream, int length)
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			DeserializeLength(stream, length, spawnOptions, isDelta: false);
			return spawnOptions;
		}

		public static SpawnOptions Deserialize(byte[] buffer)
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, spawnOptions, isDelta: false);
			return spawnOptions;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SpawnOptions previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SpawnOptions Deserialize(BufferStream stream, SpawnOptions instance, bool isDelta)
		{
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				instance.respawnState = RespawnState.OK;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 37:
					instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
					continue;
				case 48:
					instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.mobile = ProtocolParser.ReadBool(stream);
					continue;
				case 66:
					instance.nexusZone = ProtocolParser.ReadString(stream);
					continue;
				case 72:
					instance.corpse = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static SpawnOptions DeserializeLengthDelimited(BufferStream stream, SpawnOptions instance, bool isDelta)
		{
			//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				instance.respawnState = RespawnState.OK;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 37:
					instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
					continue;
				case 48:
					instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.mobile = ProtocolParser.ReadBool(stream);
					continue;
				case 66:
					instance.nexusZone = ProtocolParser.ReadString(stream);
					continue;
				case 72:
					instance.corpse = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SpawnOptions DeserializeLength(BufferStream stream, int length, SpawnOptions instance, bool isDelta)
		{
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				instance.respawnState = RespawnState.OK;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 37:
					instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
					continue;
				case 48:
					instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.mobile = ProtocolParser.ReadBool(stream);
					continue;
				case 66:
					instance.nexusZone = ProtocolParser.ReadString(stream);
					continue;
				case 72:
					instance.corpse = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SpawnOptions instance, SpawnOptions previous)
		{
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.id.Value);
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.unlockSeconds != previous.unlockSeconds)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
			}
			if (instance.worldPosition != previous.worldPosition)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.worldPosition, previous.worldPosition);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.mobile);
			if (instance.nexusZone != null && instance.nexusZone != previous.nexusZone)
			{
				stream.WriteByte(66);
				ProtocolParser.WriteString(stream, instance.nexusZone);
			}
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.corpse);
		}

		public static void Serialize(BufferStream stream, SpawnOptions instance)
		{
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			if (instance.id != default(NetworkableId))
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.id.Value);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.unlockSeconds != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
			}
			if (instance.worldPosition != default(Vector3))
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance.worldPosition);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
			if (instance.mobile)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.mobile);
			}
			if (instance.nexusZone != null)
			{
				stream.WriteByte(66);
				ProtocolParser.WriteString(stream, instance.nexusZone);
			}
			if (instance.corpse)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteBool(stream, instance.corpse);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref id.Value);
		}
	}

	[NonSerialized]
	public List<SpawnOptions> spawnOptions;

	[NonSerialized]
	public PlayerLifeStory previousLife;

	[NonSerialized]
	public bool fadeIn;

	[NonSerialized]
	public bool loading;

	[NonSerialized]
	public List<Vector3> shelterPositions;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RespawnInformation instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.spawnOptions != null)
		{
			for (int i = 0; i < instance.spawnOptions.Count; i++)
			{
				if (instance.spawnOptions[i] != null)
				{
					instance.spawnOptions[i].ResetToPool();
					instance.spawnOptions[i] = null;
				}
			}
			List<SpawnOptions> list = instance.spawnOptions;
			Pool.Free<SpawnOptions>(ref list, false);
			instance.spawnOptions = list;
		}
		if (instance.previousLife != null)
		{
			instance.previousLife.ResetToPool();
			instance.previousLife = null;
		}
		instance.fadeIn = false;
		instance.loading = false;
		if (instance.shelterPositions != null)
		{
			List<Vector3> list2 = instance.shelterPositions;
			Pool.FreeUnmanaged<Vector3>(ref list2);
			instance.shelterPositions = list2;
		}
		Pool.Free<RespawnInformation>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RespawnInformation with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RespawnInformation instance)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		if (spawnOptions != null)
		{
			instance.spawnOptions = Pool.Get<List<SpawnOptions>>();
			for (int i = 0; i < spawnOptions.Count; i++)
			{
				SpawnOptions item = spawnOptions[i].Copy();
				instance.spawnOptions.Add(item);
			}
		}
		else
		{
			instance.spawnOptions = null;
		}
		if (previousLife != null)
		{
			if (instance.previousLife == null)
			{
				instance.previousLife = previousLife.Copy();
			}
			else
			{
				previousLife.CopyTo(instance.previousLife);
			}
		}
		else
		{
			instance.previousLife = null;
		}
		instance.fadeIn = fadeIn;
		instance.loading = loading;
		if (shelterPositions != null)
		{
			instance.shelterPositions = Pool.Get<List<Vector3>>();
			for (int j = 0; j < shelterPositions.Count; j++)
			{
				Vector3 item2 = shelterPositions[j];
				instance.shelterPositions.Add(item2);
			}
		}
		else
		{
			instance.shelterPositions = null;
		}
	}

	public RespawnInformation Copy()
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		CopyTo(respawnInformation);
		return respawnInformation;
	}

	public static RespawnInformation Deserialize(BufferStream stream)
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		Deserialize(stream, respawnInformation, isDelta: false);
		return respawnInformation;
	}

	public static RespawnInformation DeserializeLengthDelimited(BufferStream stream)
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		DeserializeLengthDelimited(stream, respawnInformation, isDelta: false);
		return respawnInformation;
	}

	public static RespawnInformation DeserializeLength(BufferStream stream, int length)
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		DeserializeLength(stream, length, respawnInformation, isDelta: false);
		return respawnInformation;
	}

	public static RespawnInformation Deserialize(byte[] buffer)
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, respawnInformation, isDelta: false);
		return respawnInformation;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RespawnInformation previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RespawnInformation Deserialize(BufferStream stream, RespawnInformation instance, bool isDelta)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = Pool.Get<List<SpawnOptions>>();
			}
			if (instance.shelterPositions == null)
			{
				instance.shelterPositions = Pool.Get<List<Vector3>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.spawnOptions.Add(SpawnOptions.DeserializeLengthDelimited(stream));
				break;
			case 18:
				if (instance.previousLife == null)
				{
					instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
				}
				break;
			case 24:
				instance.fadeIn = ProtocolParser.ReadBool(stream);
				break;
			case 32:
				instance.loading = ProtocolParser.ReadBool(stream);
				break;
			case 42:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.shelterPositions.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static RespawnInformation DeserializeLengthDelimited(BufferStream stream, RespawnInformation instance, bool isDelta)
	{
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = Pool.Get<List<SpawnOptions>>();
			}
			if (instance.shelterPositions == null)
			{
				instance.shelterPositions = Pool.Get<List<Vector3>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.spawnOptions.Add(SpawnOptions.DeserializeLengthDelimited(stream));
				break;
			case 18:
				if (instance.previousLife == null)
				{
					instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
				}
				break;
			case 24:
				instance.fadeIn = ProtocolParser.ReadBool(stream);
				break;
			case 32:
				instance.loading = ProtocolParser.ReadBool(stream);
				break;
			case 42:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.shelterPositions.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RespawnInformation DeserializeLength(BufferStream stream, int length, RespawnInformation instance, bool isDelta)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = Pool.Get<List<SpawnOptions>>();
			}
			if (instance.shelterPositions == null)
			{
				instance.shelterPositions = Pool.Get<List<Vector3>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.spawnOptions.Add(SpawnOptions.DeserializeLengthDelimited(stream));
				break;
			case 18:
				if (instance.previousLife == null)
				{
					instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
				}
				break;
			case 24:
				instance.fadeIn = ProtocolParser.ReadBool(stream);
				break;
			case 32:
				instance.loading = ProtocolParser.ReadBool(stream);
				break;
			case 42:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.shelterPositions.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RespawnInformation instance, RespawnInformation previous)
	{
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spawnOptions != null)
		{
			for (int i = 0; i < instance.spawnOptions.Count; i++)
			{
				SpawnOptions spawnOptions = instance.spawnOptions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				SpawnOptions.SerializeDelta(stream, spawnOptions, spawnOptions);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.previousLife != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerLifeStory.SerializeDelta(stream, instance.previousLife, previous.previousLife);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.fadeIn);
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.loading);
		if (instance.shelterPositions == null)
		{
			return;
		}
		for (int j = 0; j < instance.shelterPositions.Count; j++)
		{
			Vector3 val3 = instance.shelterPositions[j];
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, val3, val3);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field shelterPositions (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public static void Serialize(BufferStream stream, RespawnInformation instance)
	{
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spawnOptions != null)
		{
			for (int i = 0; i < instance.spawnOptions.Count; i++)
			{
				SpawnOptions instance2 = instance.spawnOptions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				SpawnOptions.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.previousLife != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerLifeStory.Serialize(stream, instance.previousLife);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.fadeIn)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.fadeIn);
		}
		if (instance.loading)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.loading);
		}
		if (instance.shelterPositions == null)
		{
			return;
		}
		for (int j = 0; j < instance.shelterPositions.Count; j++)
		{
			Vector3 instance3 = instance.shelterPositions[j];
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance3);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field shelterPositions (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (spawnOptions != null)
		{
			for (int i = 0; i < spawnOptions.Count; i++)
			{
				spawnOptions[i]?.InspectUids(action);
			}
		}
		previousLife?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClientReady : IDisposable, IPooled, IProto<ClientReady>, IProto
{
	public class ClientInfo : IDisposable, IPooled, IProto<ClientInfo>, IProto
	{
		[NonSerialized]
		public string name;

		[NonSerialized]
		public string value;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ClientInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.name = string.Empty;
				instance.value = string.Empty;
				Pool.Free<ClientInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ClientInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ClientInfo instance)
		{
			instance.name = name;
			instance.value = value;
		}

		public ClientInfo Copy()
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			CopyTo(clientInfo);
			return clientInfo;
		}

		public static ClientInfo Deserialize(BufferStream stream)
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			Deserialize(stream, clientInfo, isDelta: false);
			return clientInfo;
		}

		public static ClientInfo DeserializeLengthDelimited(BufferStream stream)
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			DeserializeLengthDelimited(stream, clientInfo, isDelta: false);
			return clientInfo;
		}

		public static ClientInfo DeserializeLength(BufferStream stream, int length)
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			DeserializeLength(stream, length, clientInfo, isDelta: false);
			return clientInfo;
		}

		public static ClientInfo Deserialize(byte[] buffer)
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, clientInfo, isDelta: false);
			return clientInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ClientInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ClientInfo Deserialize(BufferStream stream, ClientInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.value = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ClientInfo DeserializeLengthDelimited(BufferStream stream, ClientInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.value = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ClientInfo DeserializeLength(BufferStream stream, int length, ClientInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.value = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ClientInfo instance, ClientInfo previous)
		{
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.value != previous.value)
			{
				if (instance.value == null)
				{
					throw new ArgumentNullException("value", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.value);
			}
		}

		public static void Serialize(BufferStream stream, ClientInfo instance)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.value == null)
			{
				throw new ArgumentNullException("value", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.value);
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<ClientInfo> clientInfo;

	[NonSerialized]
	public bool globalNetworking;

	[NonSerialized]
	public PartyData party;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClientReady instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.clientInfo != null)
		{
			for (int i = 0; i < instance.clientInfo.Count; i++)
			{
				if (instance.clientInfo[i] != null)
				{
					instance.clientInfo[i].ResetToPool();
					instance.clientInfo[i] = null;
				}
			}
			List<ClientInfo> list = instance.clientInfo;
			Pool.Free<ClientInfo>(ref list, false);
			instance.clientInfo = list;
		}
		instance.globalNetworking = false;
		if (instance.party != null)
		{
			instance.party.ResetToPool();
			instance.party = null;
		}
		Pool.Free<ClientReady>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClientReady with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClientReady instance)
	{
		if (clientInfo != null)
		{
			instance.clientInfo = Pool.Get<List<ClientInfo>>();
			for (int i = 0; i < clientInfo.Count; i++)
			{
				ClientInfo item = clientInfo[i].Copy();
				instance.clientInfo.Add(item);
			}
		}
		else
		{
			instance.clientInfo = null;
		}
		instance.globalNetworking = globalNetworking;
		if (party != null)
		{
			if (instance.party == null)
			{
				instance.party = party.Copy();
			}
			else
			{
				party.CopyTo(instance.party);
			}
		}
		else
		{
			instance.party = null;
		}
	}

	public ClientReady Copy()
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		CopyTo(clientReady);
		return clientReady;
	}

	public static ClientReady Deserialize(BufferStream stream)
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		Deserialize(stream, clientReady, isDelta: false);
		return clientReady;
	}

	public static ClientReady DeserializeLengthDelimited(BufferStream stream)
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		DeserializeLengthDelimited(stream, clientReady, isDelta: false);
		return clientReady;
	}

	public static ClientReady DeserializeLength(BufferStream stream, int length)
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		DeserializeLength(stream, length, clientReady, isDelta: false);
		return clientReady;
	}

	public static ClientReady Deserialize(byte[] buffer)
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clientReady, isDelta: false);
		return clientReady;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClientReady previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClientReady Deserialize(BufferStream stream, ClientReady instance, bool isDelta)
	{
		if (!isDelta && instance.clientInfo == null)
		{
			instance.clientInfo = Pool.Get<List<ClientInfo>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.clientInfo.Add(ClientInfo.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.globalNetworking = ProtocolParser.ReadBool(stream);
				break;
			case 26:
				if (instance.party == null)
				{
					instance.party = PartyData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PartyData.DeserializeLengthDelimited(stream, instance.party, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static ClientReady DeserializeLengthDelimited(BufferStream stream, ClientReady instance, bool isDelta)
	{
		if (!isDelta && instance.clientInfo == null)
		{
			instance.clientInfo = Pool.Get<List<ClientInfo>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.clientInfo.Add(ClientInfo.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.globalNetworking = ProtocolParser.ReadBool(stream);
				break;
			case 26:
				if (instance.party == null)
				{
					instance.party = PartyData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PartyData.DeserializeLengthDelimited(stream, instance.party, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClientReady DeserializeLength(BufferStream stream, int length, ClientReady instance, bool isDelta)
	{
		if (!isDelta && instance.clientInfo == null)
		{
			instance.clientInfo = Pool.Get<List<ClientInfo>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.clientInfo.Add(ClientInfo.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.globalNetworking = ProtocolParser.ReadBool(stream);
				break;
			case 26:
				if (instance.party == null)
				{
					instance.party = PartyData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PartyData.DeserializeLengthDelimited(stream, instance.party, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClientReady instance, ClientReady previous)
	{
		if (instance.clientInfo != null)
		{
			for (int i = 0; i < instance.clientInfo.Count; i++)
			{
				ClientInfo clientInfo = instance.clientInfo[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ClientInfo.SerializeDelta(stream, clientInfo, clientInfo);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.globalNetworking);
		if (instance.party == null)
		{
			return;
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		PartyData.SerializeDelta(stream, instance.party, previous.party);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, ClientReady instance)
	{
		if (instance.clientInfo != null)
		{
			for (int i = 0; i < instance.clientInfo.Count; i++)
			{
				ClientInfo instance2 = instance.clientInfo[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ClientInfo.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.globalNetworking)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.globalNetworking);
		}
		if (instance.party == null)
		{
			return;
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		PartyData.Serialize(stream, instance.party);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (clientInfo != null)
		{
			for (int i = 0; i < clientInfo.Count; i++)
			{
				clientInfo[i]?.InspectUids(action);
			}
		}
		party?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Tree : IDisposable, IPooled, IProto<Tree>, IProto
{
	[NonSerialized]
	public NetworkableId netId;

	[NonSerialized]
	public uint prefabId;

	[NonSerialized]
	public Half3 position;

	[NonSerialized]
	public float scale;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Tree instance)
	{
		if (instance.ShouldPool)
		{
			instance.netId = default(NetworkableId);
			instance.prefabId = 0u;
			instance.position = default(Half3);
			instance.scale = 0f;
			Pool.Free<Tree>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Tree with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Tree instance)
	{
		instance.netId = netId;
		instance.prefabId = prefabId;
		instance.position = position;
		instance.scale = scale;
	}

	public Tree Copy()
	{
		Tree tree = Pool.Get<Tree>();
		CopyTo(tree);
		return tree;
	}

	public static Tree Deserialize(BufferStream stream)
	{
		Tree tree = Pool.Get<Tree>();
		Deserialize(stream, tree, isDelta: false);
		return tree;
	}

	public static Tree DeserializeLengthDelimited(BufferStream stream)
	{
		Tree tree = Pool.Get<Tree>();
		DeserializeLengthDelimited(stream, tree, isDelta: false);
		return tree;
	}

	public static Tree DeserializeLength(BufferStream stream, int length)
	{
		Tree tree = Pool.Get<Tree>();
		DeserializeLength(stream, length, tree, isDelta: false);
		return tree;
	}

	public static Tree Deserialize(byte[] buffer)
	{
		Tree tree = Pool.Get<Tree>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, tree, isDelta: false);
		return tree;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Tree previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Tree Deserialize(BufferStream stream, Tree instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.netId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				Half3.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 37:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Tree DeserializeLengthDelimited(BufferStream stream, Tree instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.netId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				Half3.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 37:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Tree DeserializeLength(BufferStream stream, int length, Tree instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.netId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				Half3.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 37:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Tree instance, Tree previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.netId.Value);
		if (instance.prefabId != previous.prefabId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.prefabId);
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int num = stream.Position;
		Half3.SerializeDelta(stream, instance.position, previous.position);
		int num2 = stream.Position - num;
		if (num2 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (ProtoBuf.Half3)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num2, span, 0);
		if (instance.scale != previous.scale)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.scale);
		}
	}

	public static void Serialize(BufferStream stream, Tree instance)
	{
		if (instance.netId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.netId.Value);
		}
		if (instance.prefabId != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.prefabId);
		}
		if (instance.position != default(Half3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Half3.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (ProtoBuf.Half3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.scale != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.scale);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref netId.Value);
		position.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TreeList : IDisposable, IPooled, IProto<TreeList>, IProto
{
	[NonSerialized]
	public List<Tree> trees;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TreeList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.trees != null)
		{
			for (int i = 0; i < instance.trees.Count; i++)
			{
				if (instance.trees[i] != null)
				{
					instance.trees[i].ResetToPool();
					instance.trees[i] = null;
				}
			}
			List<Tree> list = instance.trees;
			Pool.Free<Tree>(ref list, false);
			instance.trees = list;
		}
		Pool.Free<TreeList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TreeList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TreeList instance)
	{
		if (trees != null)
		{
			instance.trees = Pool.Get<List<Tree>>();
			for (int i = 0; i < trees.Count; i++)
			{
				Tree item = trees[i].Copy();
				instance.trees.Add(item);
			}
		}
		else
		{
			instance.trees = null;
		}
	}

	public TreeList Copy()
	{
		TreeList treeList = Pool.Get<TreeList>();
		CopyTo(treeList);
		return treeList;
	}

	public static TreeList Deserialize(BufferStream stream)
	{
		TreeList treeList = Pool.Get<TreeList>();
		Deserialize(stream, treeList, isDelta: false);
		return treeList;
	}

	public static TreeList DeserializeLengthDelimited(BufferStream stream)
	{
		TreeList treeList = Pool.Get<TreeList>();
		DeserializeLengthDelimited(stream, treeList, isDelta: false);
		return treeList;
	}

	public static TreeList DeserializeLength(BufferStream stream, int length)
	{
		TreeList treeList = Pool.Get<TreeList>();
		DeserializeLength(stream, length, treeList, isDelta: false);
		return treeList;
	}

	public static TreeList Deserialize(byte[] buffer)
	{
		TreeList treeList = Pool.Get<TreeList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, treeList, isDelta: false);
		return treeList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TreeList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TreeList Deserialize(BufferStream stream, TreeList instance, bool isDelta)
	{
		if (!isDelta && instance.trees == null)
		{
			instance.trees = Pool.Get<List<Tree>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.trees.Add(Tree.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TreeList DeserializeLengthDelimited(BufferStream stream, TreeList instance, bool isDelta)
	{
		if (!isDelta && instance.trees == null)
		{
			instance.trees = Pool.Get<List<Tree>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.trees.Add(Tree.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TreeList DeserializeLength(BufferStream stream, int length, TreeList instance, bool isDelta)
	{
		if (!isDelta && instance.trees == null)
		{
			instance.trees = Pool.Get<List<Tree>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.trees.Add(Tree.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TreeList instance, TreeList previous)
	{
		if (instance.trees == null)
		{
			return;
		}
		for (int i = 0; i < instance.trees.Count; i++)
		{
			Tree tree = instance.trees[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Tree.SerializeDelta(stream, tree, tree);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field trees (ProtoBuf.Tree)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, TreeList instance)
	{
		if (instance.trees == null)
		{
			return;
		}
		for (int i = 0; i < instance.trees.Count; i++)
		{
			Tree instance2 = instance.trees[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Tree.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field trees (ProtoBuf.Tree)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (trees != null)
		{
			for (int i = 0; i < trees.Count; i++)
			{
				trees[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WorldMessage : IDisposable, IPooled, IProto<WorldMessage>, IProto
{
	public enum MessageType
	{
		Request = 1,
		Receive,
		Done
	}

	[NonSerialized]
	public MessageType status;

	[NonSerialized]
	public List<PrefabData> prefabs;

	[NonSerialized]
	public List<PathData> paths;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WorldMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.status = (MessageType)0;
		if (instance.prefabs != null)
		{
			for (int i = 0; i < instance.prefabs.Count; i++)
			{
				if (instance.prefabs[i] != null)
				{
					instance.prefabs[i].ResetToPool();
					instance.prefabs[i] = null;
				}
			}
			List<PrefabData> list = instance.prefabs;
			Pool.Free<PrefabData>(ref list, false);
			instance.prefabs = list;
		}
		if (instance.paths != null)
		{
			for (int j = 0; j < instance.paths.Count; j++)
			{
				if (instance.paths[j] != null)
				{
					instance.paths[j].ResetToPool();
					instance.paths[j] = null;
				}
			}
			List<PathData> list2 = instance.paths;
			Pool.Free<PathData>(ref list2, false);
			instance.paths = list2;
		}
		Pool.Free<WorldMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WorldMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WorldMessage instance)
	{
		instance.status = status;
		if (prefabs != null)
		{
			instance.prefabs = Pool.Get<List<PrefabData>>();
			for (int i = 0; i < prefabs.Count; i++)
			{
				PrefabData item = prefabs[i].Copy();
				instance.prefabs.Add(item);
			}
		}
		else
		{
			instance.prefabs = null;
		}
		if (paths != null)
		{
			instance.paths = Pool.Get<List<PathData>>();
			for (int j = 0; j < paths.Count; j++)
			{
				PathData item2 = paths[j].Copy();
				instance.paths.Add(item2);
			}
		}
		else
		{
			instance.paths = null;
		}
	}

	public WorldMessage Copy()
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		CopyTo(worldMessage);
		return worldMessage;
	}

	public static WorldMessage Deserialize(BufferStream stream)
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		Deserialize(stream, worldMessage, isDelta: false);
		return worldMessage;
	}

	public static WorldMessage DeserializeLengthDelimited(BufferStream stream)
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		DeserializeLengthDelimited(stream, worldMessage, isDelta: false);
		return worldMessage;
	}

	public static WorldMessage DeserializeLength(BufferStream stream, int length)
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		DeserializeLength(stream, length, worldMessage, isDelta: false);
		return worldMessage;
	}

	public static WorldMessage Deserialize(byte[] buffer)
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, worldMessage, isDelta: false);
		return worldMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WorldMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WorldMessage Deserialize(BufferStream stream, WorldMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.status = (MessageType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WorldMessage DeserializeLengthDelimited(BufferStream stream, WorldMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.status = (MessageType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WorldMessage DeserializeLength(BufferStream stream, int length, WorldMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.status = (MessageType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WorldMessage instance, WorldMessage previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.status);
		if (instance.prefabs != null)
		{
			for (int i = 0; i < instance.prefabs.Count; i++)
			{
				PrefabData prefabData = instance.prefabs[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PrefabData.SerializeDelta(stream, prefabData, prefabData);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.paths == null)
		{
			return;
		}
		for (int j = 0; j < instance.paths.Count; j++)
		{
			PathData pathData = instance.paths[j];
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PathData.SerializeDelta(stream, pathData, pathData);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, WorldMessage instance)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.status);
		if (instance.prefabs != null)
		{
			for (int i = 0; i < instance.prefabs.Count; i++)
			{
				PrefabData instance2 = instance.prefabs[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PrefabData.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.paths == null)
		{
			return;
		}
		for (int j = 0; j < instance.paths.Count; j++)
		{
			PathData instance3 = instance.paths[j];
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PathData.Serialize(stream, instance3);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (prefabs != null)
		{
			for (int i = 0; i < prefabs.Count; i++)
			{
				prefabs[i]?.InspectUids(action);
			}
		}
		if (paths != null)
		{
			for (int j = 0; j < paths.Count; j++)
			{
				paths[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ArcadeGame : IDisposable, IPooled, IProto<ArcadeGame>, IProto
{
	public class arcadeEnt : IDisposable, IPooled, IProto<arcadeEnt>, IProto
	{
		[NonSerialized]
		public uint id;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public uint spriteID;

		[NonSerialized]
		public uint soundID;

		[NonSerialized]
		public bool visible;

		[NonSerialized]
		public Vector3 position;

		[NonSerialized]
		public Vector3 heading;

		[NonSerialized]
		public bool enabled;

		[NonSerialized]
		public Vector3 scale;

		[NonSerialized]
		public Vector3 colliderScale;

		[NonSerialized]
		public float alpha;

		[NonSerialized]
		public uint prefabID;

		[NonSerialized]
		public uint parentID;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(arcadeEnt instance)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.id = 0u;
				instance.name = string.Empty;
				instance.spriteID = 0u;
				instance.soundID = 0u;
				instance.visible = false;
				instance.position = default(Vector3);
				instance.heading = default(Vector3);
				instance.enabled = false;
				instance.scale = default(Vector3);
				instance.colliderScale = default(Vector3);
				instance.alpha = 0f;
				instance.prefabID = 0u;
				instance.parentID = 0u;
				Pool.Free<arcadeEnt>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose arcadeEnt with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(arcadeEnt instance)
		{
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			instance.id = id;
			instance.name = name;
			instance.spriteID = spriteID;
			instance.soundID = soundID;
			instance.visible = visible;
			instance.position = position;
			instance.heading = heading;
			instance.enabled = enabled;
			instance.scale = scale;
			instance.colliderScale = colliderScale;
			instance.alpha = alpha;
			instance.prefabID = prefabID;
			instance.parentID = parentID;
		}

		public arcadeEnt Copy()
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			CopyTo(arcadeEnt);
			return arcadeEnt;
		}

		public static arcadeEnt Deserialize(BufferStream stream)
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			Deserialize(stream, arcadeEnt, isDelta: false);
			return arcadeEnt;
		}

		public static arcadeEnt DeserializeLengthDelimited(BufferStream stream)
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			DeserializeLengthDelimited(stream, arcadeEnt, isDelta: false);
			return arcadeEnt;
		}

		public static arcadeEnt DeserializeLength(BufferStream stream, int length)
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			DeserializeLength(stream, length, arcadeEnt, isDelta: false);
			return arcadeEnt;
		}

		public static arcadeEnt Deserialize(byte[] buffer)
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, arcadeEnt, isDelta: false);
			return arcadeEnt;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, arcadeEnt previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static arcadeEnt Deserialize(BufferStream stream, arcadeEnt instance, bool isDelta)
		{
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0151: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.id = ProtocolParser.ReadUInt32(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.spriteID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 32:
					instance.soundID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 40:
					instance.visible = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 58:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
					continue;
				case 64:
					instance.enabled = ProtocolParser.ReadBool(stream);
					continue;
				case 74:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
					continue;
				case 82:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
					continue;
				case 93:
					instance.alpha = ProtocolParser.ReadSingle(stream);
					continue;
				case 96:
					instance.prefabID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 104:
					instance.parentID = ProtocolParser.ReadUInt32(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static arcadeEnt DeserializeLengthDelimited(BufferStream stream, arcadeEnt instance, bool isDelta)
		{
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0182: Unknown result type (might be due to invalid IL or missing references)
			//IL_016f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.id = ProtocolParser.ReadUInt32(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.spriteID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 32:
					instance.soundID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 40:
					instance.visible = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 58:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
					continue;
				case 64:
					instance.enabled = ProtocolParser.ReadBool(stream);
					continue;
				case 74:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
					continue;
				case 82:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
					continue;
				case 93:
					instance.alpha = ProtocolParser.ReadSingle(stream);
					continue;
				case 96:
					instance.prefabID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 104:
					instance.parentID = ProtocolParser.ReadUInt32(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static arcadeEnt DeserializeLength(BufferStream stream, int length, arcadeEnt instance, bool isDelta)
		{
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_017a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0167: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.id = ProtocolParser.ReadUInt32(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.spriteID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 32:
					instance.soundID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 40:
					instance.visible = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 58:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
					continue;
				case 64:
					instance.enabled = ProtocolParser.ReadBool(stream);
					continue;
				case 74:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
					continue;
				case 82:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
					continue;
				case 93:
					instance.alpha = ProtocolParser.ReadSingle(stream);
					continue;
				case 96:
					instance.prefabID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 104:
					instance.parentID = ProtocolParser.ReadUInt32(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, arcadeEnt instance, arcadeEnt previous)
		{
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0202: Unknown result type (might be due to invalid IL or missing references)
			//IL_0208: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_022f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0235: Unknown result type (might be due to invalid IL or missing references)
			if (instance.id != previous.id)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, instance.id);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.spriteID != previous.spriteID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt32(stream, instance.spriteID);
			}
			if (instance.soundID != previous.soundID)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, instance.soundID);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.visible);
			if (instance.position != previous.position)
			{
				stream.WriteByte(50);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.heading != previous.heading)
			{
				stream.WriteByte(58);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.heading, previous.heading);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heading (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.enabled);
			if (instance.scale != previous.scale)
			{
				stream.WriteByte(74);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int num5 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.scale, previous.scale);
				int num6 = stream.Position - num5;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span3, 0);
			}
			if (instance.colliderScale != previous.colliderScale)
			{
				stream.WriteByte(82);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int num7 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.colliderScale, previous.colliderScale);
				int num8 = stream.Position - num7;
				if (num8 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colliderScale (UnityEngine.Vector3)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num8, span4, 0);
			}
			if (instance.alpha != previous.alpha)
			{
				stream.WriteByte(93);
				ProtocolParser.WriteSingle(stream, instance.alpha);
			}
			if (instance.prefabID != previous.prefabID)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteUInt32(stream, instance.prefabID);
			}
			if (instance.parentID != previous.parentID)
			{
				stream.WriteByte(104);
				ProtocolParser.WriteUInt32(stream, instance.parentID);
			}
		}

		public static void Serialize(BufferStream stream, arcadeEnt instance)
		{
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018c: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01af: Unknown result type (might be due to invalid IL or missing references)
			//IL_0215: Unknown result type (might be due to invalid IL or missing references)
			if (instance.id != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, instance.id);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.spriteID != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt32(stream, instance.spriteID);
			}
			if (instance.soundID != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, instance.soundID);
			}
			if (instance.visible)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.visible);
			}
			if (instance.position != default(Vector3))
			{
				stream.WriteByte(50);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.Serialize(stream, instance.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.heading != default(Vector3))
			{
				stream.WriteByte(58);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.heading);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heading (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
			if (instance.enabled)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteBool(stream, instance.enabled);
			}
			if (instance.scale != default(Vector3))
			{
				stream.WriteByte(74);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int num5 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.scale);
				int num6 = stream.Position - num5;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span3, 0);
			}
			if (instance.colliderScale != default(Vector3))
			{
				stream.WriteByte(82);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int num7 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.colliderScale);
				int num8 = stream.Position - num7;
				if (num8 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colliderScale (UnityEngine.Vector3)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num8, span4, 0);
			}
			if (instance.alpha != 0f)
			{
				stream.WriteByte(93);
				ProtocolParser.WriteSingle(stream, instance.alpha);
			}
			if (instance.prefabID != 0)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteUInt32(stream, instance.prefabID);
			}
			if (instance.parentID != 0)
			{
				stream.WriteByte(104);
				ProtocolParser.WriteUInt32(stream, instance.parentID);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<arcadeEnt> arcadeEnts;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ArcadeGame instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.arcadeEnts != null)
		{
			for (int i = 0; i < instance.arcadeEnts.Count; i++)
			{
				if (instance.arcadeEnts[i] != null)
				{
					instance.arcadeEnts[i].ResetToPool();
					instance.arcadeEnts[i] = null;
				}
			}
			List<arcadeEnt> list = instance.arcadeEnts;
			Pool.Free<arcadeEnt>(ref list, false);
			instance.arcadeEnts = list;
		}
		Pool.Free<ArcadeGame>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ArcadeGame with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ArcadeGame instance)
	{
		if (arcadeEnts != null)
		{
			instance.arcadeEnts = Pool.Get<List<arcadeEnt>>();
			for (int i = 0; i < arcadeEnts.Count; i++)
			{
				arcadeEnt item = arcadeEnts[i].Copy();
				instance.arcadeEnts.Add(item);
			}
		}
		else
		{
			instance.arcadeEnts = null;
		}
	}

	public ArcadeGame Copy()
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		CopyTo(arcadeGame);
		return arcadeGame;
	}

	public static ArcadeGame Deserialize(BufferStream stream)
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		Deserialize(stream, arcadeGame, isDelta: false);
		return arcadeGame;
	}

	public static ArcadeGame DeserializeLengthDelimited(BufferStream stream)
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		DeserializeLengthDelimited(stream, arcadeGame, isDelta: false);
		return arcadeGame;
	}

	public static ArcadeGame DeserializeLength(BufferStream stream, int length)
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		DeserializeLength(stream, length, arcadeGame, isDelta: false);
		return arcadeGame;
	}

	public static ArcadeGame Deserialize(byte[] buffer)
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, arcadeGame, isDelta: false);
		return arcadeGame;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ArcadeGame previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ArcadeGame Deserialize(BufferStream stream, ArcadeGame instance, bool isDelta)
	{
		if (!isDelta && instance.arcadeEnts == null)
		{
			instance.arcadeEnts = Pool.Get<List<arcadeEnt>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.arcadeEnts.Add(arcadeEnt.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ArcadeGame DeserializeLengthDelimited(BufferStream stream, ArcadeGame instance, bool isDelta)
	{
		if (!isDelta && instance.arcadeEnts == null)
		{
			instance.arcadeEnts = Pool.Get<List<arcadeEnt>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.arcadeEnts.Add(arcadeEnt.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ArcadeGame DeserializeLength(BufferStream stream, int length, ArcadeGame instance, bool isDelta)
	{
		if (!isDelta && instance.arcadeEnts == null)
		{
			instance.arcadeEnts = Pool.Get<List<arcadeEnt>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.arcadeEnts.Add(arcadeEnt.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ArcadeGame instance, ArcadeGame previous)
	{
		if (instance.arcadeEnts == null)
		{
			return;
		}
		for (int i = 0; i < instance.arcadeEnts.Count; i++)
		{
			arcadeEnt arcadeEnt = instance.arcadeEnts[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			arcadeEnt.SerializeDelta(stream, arcadeEnt, arcadeEnt);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ArcadeGame instance)
	{
		if (instance.arcadeEnts == null)
		{
			return;
		}
		for (int i = 0; i < instance.arcadeEnts.Count; i++)
		{
			arcadeEnt instance2 = instance.arcadeEnts[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			arcadeEnt.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (arcadeEnts != null)
		{
			for (int i = 0; i < arcadeEnts.Count; i++)
			{
				arcadeEnts[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PhoneDirectory : IDisposable, IPooled, IProto<PhoneDirectory>, IProto
{
	public class DirectoryEntry : IDisposable, IPooled, IProto<DirectoryEntry>, IProto
	{
		[NonSerialized]
		public int phoneNumber;

		[NonSerialized]
		public string phoneName;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(DirectoryEntry instance)
		{
			if (instance.ShouldPool)
			{
				instance.phoneNumber = 0;
				instance.phoneName = string.Empty;
				Pool.Free<DirectoryEntry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose DirectoryEntry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(DirectoryEntry instance)
		{
			instance.phoneNumber = phoneNumber;
			instance.phoneName = phoneName;
		}

		public DirectoryEntry Copy()
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			CopyTo(directoryEntry);
			return directoryEntry;
		}

		public static DirectoryEntry Deserialize(BufferStream stream)
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			Deserialize(stream, directoryEntry, isDelta: false);
			return directoryEntry;
		}

		public static DirectoryEntry DeserializeLengthDelimited(BufferStream stream)
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			DeserializeLengthDelimited(stream, directoryEntry, isDelta: false);
			return directoryEntry;
		}

		public static DirectoryEntry DeserializeLength(BufferStream stream, int length)
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			DeserializeLength(stream, length, directoryEntry, isDelta: false);
			return directoryEntry;
		}

		public static DirectoryEntry Deserialize(byte[] buffer)
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, directoryEntry, isDelta: false);
			return directoryEntry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, DirectoryEntry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static DirectoryEntry Deserialize(BufferStream stream, DirectoryEntry instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.phoneName = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static DirectoryEntry DeserializeLengthDelimited(BufferStream stream, DirectoryEntry instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.phoneName = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static DirectoryEntry DeserializeLength(BufferStream stream, int length, DirectoryEntry instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.phoneName = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, DirectoryEntry instance, DirectoryEntry previous)
		{
			if (instance.phoneNumber != previous.phoneNumber)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
			}
			if (instance.phoneName != previous.phoneName)
			{
				if (instance.phoneName == null)
				{
					throw new ArgumentNullException("phoneName", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.phoneName);
			}
		}

		public static void Serialize(BufferStream stream, DirectoryEntry instance)
		{
			if (instance.phoneNumber != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
			}
			if (instance.phoneName == null)
			{
				throw new ArgumentNullException("phoneName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<DirectoryEntry> entries;

	[NonSerialized]
	public bool atEnd;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PhoneDirectory instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entries != null)
		{
			for (int i = 0; i < instance.entries.Count; i++)
			{
				if (instance.entries[i] != null)
				{
					instance.entries[i].ResetToPool();
					instance.entries[i] = null;
				}
			}
			List<DirectoryEntry> list = instance.entries;
			Pool.Free<DirectoryEntry>(ref list, false);
			instance.entries = list;
		}
		instance.atEnd = false;
		Pool.Free<PhoneDirectory>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PhoneDirectory with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PhoneDirectory instance)
	{
		if (entries != null)
		{
			instance.entries = Pool.Get<List<DirectoryEntry>>();
			for (int i = 0; i < entries.Count; i++)
			{
				DirectoryEntry item = entries[i].Copy();
				instance.entries.Add(item);
			}
		}
		else
		{
			instance.entries = null;
		}
		instance.atEnd = atEnd;
	}

	public PhoneDirectory Copy()
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		CopyTo(phoneDirectory);
		return phoneDirectory;
	}

	public static PhoneDirectory Deserialize(BufferStream stream)
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		Deserialize(stream, phoneDirectory, isDelta: false);
		return phoneDirectory;
	}

	public static PhoneDirectory DeserializeLengthDelimited(BufferStream stream)
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		DeserializeLengthDelimited(stream, phoneDirectory, isDelta: false);
		return phoneDirectory;
	}

	public static PhoneDirectory DeserializeLength(BufferStream stream, int length)
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		DeserializeLength(stream, length, phoneDirectory, isDelta: false);
		return phoneDirectory;
	}

	public static PhoneDirectory Deserialize(byte[] buffer)
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, phoneDirectory, isDelta: false);
		return phoneDirectory;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PhoneDirectory previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PhoneDirectory Deserialize(BufferStream stream, PhoneDirectory instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<DirectoryEntry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entries.Add(DirectoryEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.atEnd = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PhoneDirectory DeserializeLengthDelimited(BufferStream stream, PhoneDirectory instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<DirectoryEntry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entries.Add(DirectoryEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.atEnd = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PhoneDirectory DeserializeLength(BufferStream stream, int length, PhoneDirectory instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<DirectoryEntry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entries.Add(DirectoryEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.atEnd = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PhoneDirectory instance, PhoneDirectory previous)
	{
		if (instance.entries != null)
		{
			for (int i = 0; i < instance.entries.Count; i++)
			{
				DirectoryEntry directoryEntry = instance.entries[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				DirectoryEntry.SerializeDelta(stream, directoryEntry, directoryEntry);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.atEnd);
	}

	public static void Serialize(BufferStream stream, PhoneDirectory instance)
	{
		if (instance.entries != null)
		{
			for (int i = 0; i < instance.entries.Count; i++)
			{
				DirectoryEntry instance2 = instance.entries[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				DirectoryEntry.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.atEnd)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.atEnd);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entries != null)
		{
			for (int i = 0; i < entries.Count; i++)
			{
				entries[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class EntityIdList : IDisposable, IPooled, IProto<EntityIdList>, IProto
{
	[NonSerialized]
	public List<NetworkableId> entityIds;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EntityIdList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.entityIds != null)
			{
				List<NetworkableId> list = instance.entityIds;
				Pool.FreeUnmanaged<NetworkableId>(ref list);
				instance.entityIds = list;
			}
			Pool.Free<EntityIdList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EntityIdList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EntityIdList instance)
	{
		if (entityIds != null)
		{
			instance.entityIds = Pool.Get<List<NetworkableId>>();
			for (int i = 0; i < entityIds.Count; i++)
			{
				NetworkableId item = entityIds[i];
				instance.entityIds.Add(item);
			}
		}
		else
		{
			instance.entityIds = null;
		}
	}

	public EntityIdList Copy()
	{
		EntityIdList entityIdList = Pool.Get<EntityIdList>();
		CopyTo(entityIdList);
		return entityIdList;
	}

	public static EntityIdList Deserialize(BufferStream stream)
	{
		EntityIdList entityIdList = Pool.Get<EntityIdList>();
		Deserialize(stream, entityIdList, isDelta: false);
		return entityIdList;
	}

	public static EntityIdList DeserializeLengthDelimited(BufferStream stream)
	{
		EntityIdList entityIdList = Pool.Get<EntityIdList>();
		DeserializeLengthDelimited(stream, entityIdList, isDelta: false);
		return entityIdList;
	}

	public static EntityIdList DeserializeLength(BufferStream stream, int length)
	{
		EntityIdList entityIdList = Pool.Get<EntityIdList>();
		DeserializeLength(stream, length, entityIdList, isDelta: false);
		return entityIdList;
	}

	public static EntityIdList Deserialize(byte[] buffer)
	{
		EntityIdList entityIdList = Pool.Get<EntityIdList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entityIdList, isDelta: false);
		return entityIdList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EntityIdList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EntityIdList Deserialize(BufferStream stream, EntityIdList instance, bool isDelta)
	{
		if (!isDelta && instance.entityIds == null)
		{
			instance.entityIds = Pool.Get<List<NetworkableId>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EntityIdList DeserializeLengthDelimited(BufferStream stream, EntityIdList instance, bool isDelta)
	{
		if (!isDelta && instance.entityIds == null)
		{
			instance.entityIds = Pool.Get<List<NetworkableId>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EntityIdList DeserializeLength(BufferStream stream, int length, EntityIdList instance, bool isDelta)
	{
		if (!isDelta && instance.entityIds == null)
		{
			instance.entityIds = Pool.Get<List<NetworkableId>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EntityIdList instance, EntityIdList previous)
	{
		if (instance.entityIds != null)
		{
			for (int i = 0; i < instance.entityIds.Count; i++)
			{
				NetworkableId networkableId = instance.entityIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public static void Serialize(BufferStream stream, EntityIdList instance)
	{
		if (instance.entityIds != null)
		{
			for (int i = 0; i < instance.entityIds.Count; i++)
			{
				NetworkableId networkableId = instance.entityIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < entityIds.Count; i++)
		{
			NetworkableId value = entityIds[i];
			action(UidType.NetworkableId, ref value.Value);
			entityIds[i] = value;
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class RadioList : IDisposable, IPooled, IProto<RadioList>, IProto
{
	[NonSerialized]
	public List<string> stationUrls;

	[NonSerialized]
	public List<string> stationNames;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RadioList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.stationUrls != null)
			{
				List<string> list = instance.stationUrls;
				Pool.FreeUnmanaged<string>(ref list);
				instance.stationUrls = list;
			}
			if (instance.stationNames != null)
			{
				List<string> list2 = instance.stationNames;
				Pool.FreeUnmanaged<string>(ref list2);
				instance.stationNames = list2;
			}
			Pool.Free<RadioList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RadioList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RadioList instance)
	{
		if (stationUrls != null)
		{
			instance.stationUrls = Pool.Get<List<string>>();
			for (int i = 0; i < stationUrls.Count; i++)
			{
				string item = stationUrls[i];
				instance.stationUrls.Add(item);
			}
		}
		else
		{
			instance.stationUrls = null;
		}
		if (stationNames != null)
		{
			instance.stationNames = Pool.Get<List<string>>();
			for (int j = 0; j < stationNames.Count; j++)
			{
				string item2 = stationNames[j];
				instance.stationNames.Add(item2);
			}
		}
		else
		{
			instance.stationNames = null;
		}
	}

	public RadioList Copy()
	{
		RadioList radioList = Pool.Get<RadioList>();
		CopyTo(radioList);
		return radioList;
	}

	public static RadioList Deserialize(BufferStream stream)
	{
		RadioList radioList = Pool.Get<RadioList>();
		Deserialize(stream, radioList, isDelta: false);
		return radioList;
	}

	public static RadioList DeserializeLengthDelimited(BufferStream stream)
	{
		RadioList radioList = Pool.Get<RadioList>();
		DeserializeLengthDelimited(stream, radioList, isDelta: false);
		return radioList;
	}

	public static RadioList DeserializeLength(BufferStream stream, int length)
	{
		RadioList radioList = Pool.Get<RadioList>();
		DeserializeLength(stream, length, radioList, isDelta: false);
		return radioList;
	}

	public static RadioList Deserialize(byte[] buffer)
	{
		RadioList radioList = Pool.Get<RadioList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, radioList, isDelta: false);
		return radioList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RadioList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RadioList Deserialize(BufferStream stream, RadioList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.stationUrls == null)
			{
				instance.stationUrls = Pool.Get<List<string>>();
			}
			if (instance.stationNames == null)
			{
				instance.stationNames = Pool.Get<List<string>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.stationUrls.Add(ProtocolParser.ReadString(stream));
				continue;
			case 18:
				instance.stationNames.Add(ProtocolParser.ReadString(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RadioList DeserializeLengthDelimited(BufferStream stream, RadioList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.stationUrls == null)
			{
				instance.stationUrls = Pool.Get<List<string>>();
			}
			if (instance.stationNames == null)
			{
				instance.stationNames = Pool.Get<List<string>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.stationUrls.Add(ProtocolParser.ReadString(stream));
				continue;
			case 18:
				instance.stationNames.Add(ProtocolParser.ReadString(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RadioList DeserializeLength(BufferStream stream, int length, RadioList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.stationUrls == null)
			{
				instance.stationUrls = Pool.Get<List<string>>();
			}
			if (instance.stationNames == null)
			{
				instance.stationNames = Pool.Get<List<string>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.stationUrls.Add(ProtocolParser.ReadString(stream));
				continue;
			case 18:
				instance.stationNames.Add(ProtocolParser.ReadString(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RadioList instance, RadioList previous)
	{
		if (instance.stationUrls != null)
		{
			for (int i = 0; i < instance.stationUrls.Count; i++)
			{
				string val = instance.stationUrls[i];
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.stationNames != null)
		{
			for (int j = 0; j < instance.stationNames.Count; j++)
			{
				string val2 = instance.stationNames[j];
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, val2);
			}
		}
	}

	public static void Serialize(BufferStream stream, RadioList instance)
	{
		if (instance.stationUrls != null)
		{
			for (int i = 0; i < instance.stationUrls.Count; i++)
			{
				string val = instance.stationUrls[i];
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.stationNames != null)
		{
			for (int j = 0; j < instance.stationNames.Count; j++)
			{
				string val2 = instance.stationNames[j];
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, val2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ItemAmountList : IDisposable, IPooled, IProto<ItemAmountList>, IProto
{
	[NonSerialized]
	public List<int> itemID;

	[NonSerialized]
	public List<float> amount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemAmountList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.itemID != null)
			{
				List<int> list = instance.itemID;
				Pool.FreeUnmanaged<int>(ref list);
				instance.itemID = list;
			}
			if (instance.amount != null)
			{
				List<float> list2 = instance.amount;
				Pool.FreeUnmanaged<float>(ref list2);
				instance.amount = list2;
			}
			Pool.Free<ItemAmountList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemAmountList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemAmountList instance)
	{
		if (itemID != null)
		{
			instance.itemID = Pool.Get<List<int>>();
			for (int i = 0; i < itemID.Count; i++)
			{
				int item = itemID[i];
				instance.itemID.Add(item);
			}
		}
		else
		{
			instance.itemID = null;
		}
		if (amount != null)
		{
			instance.amount = Pool.Get<List<float>>();
			for (int j = 0; j < amount.Count; j++)
			{
				float item2 = amount[j];
				instance.amount.Add(item2);
			}
		}
		else
		{
			instance.amount = null;
		}
	}

	public ItemAmountList Copy()
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		CopyTo(itemAmountList);
		return itemAmountList;
	}

	public static ItemAmountList Deserialize(BufferStream stream)
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		Deserialize(stream, itemAmountList, isDelta: false);
		return itemAmountList;
	}

	public static ItemAmountList DeserializeLengthDelimited(BufferStream stream)
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		DeserializeLengthDelimited(stream, itemAmountList, isDelta: false);
		return itemAmountList;
	}

	public static ItemAmountList DeserializeLength(BufferStream stream, int length)
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		DeserializeLength(stream, length, itemAmountList, isDelta: false);
		return itemAmountList;
	}

	public static ItemAmountList Deserialize(byte[] buffer)
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemAmountList, isDelta: false);
		return itemAmountList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemAmountList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemAmountList Deserialize(BufferStream stream, ItemAmountList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.itemID == null)
			{
				instance.itemID = Pool.Get<List<int>>();
			}
			if (instance.amount == null)
			{
				instance.amount = Pool.Get<List<float>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.amount.Add(ProtocolParser.ReadSingle(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemAmountList DeserializeLengthDelimited(BufferStream stream, ItemAmountList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.itemID == null)
			{
				instance.itemID = Pool.Get<List<int>>();
			}
			if (instance.amount == null)
			{
				instance.amount = Pool.Get<List<float>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.amount.Add(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemAmountList DeserializeLength(BufferStream stream, int length, ItemAmountList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.itemID == null)
			{
				instance.itemID = Pool.Get<List<int>>();
			}
			if (instance.amount == null)
			{
				instance.amount = Pool.Get<List<float>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.amount.Add(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemAmountList instance, ItemAmountList previous)
	{
		if (instance.itemID != null)
		{
			for (int i = 0; i < instance.itemID.Count; i++)
			{
				int num = instance.itemID[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.amount != null)
		{
			for (int j = 0; j < instance.amount.Count; j++)
			{
				float f = instance.amount[j];
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public static void Serialize(BufferStream stream, ItemAmountList instance)
	{
		if (instance.itemID != null)
		{
			for (int i = 0; i < instance.itemID.Count; i++)
			{
				int num = instance.itemID[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.amount != null)
		{
			for (int j = 0; j < instance.amount.Count; j++)
			{
				float f = instance.amount[j];
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class WireReconnectMessage : IDisposable, IPooled, IProto<WireReconnectMessage>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public int slotIndex;

	[NonSerialized]
	public bool isInput;

	[NonSerialized]
	public List<Vector3> linePoints;

	[NonSerialized]
	public int wireColor;

	[NonSerialized]
	public List<WireLineAnchorInfo> lineAnchors;

	[NonSerialized]
	public List<float> slackLevels;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WireReconnectMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.entityId = default(NetworkableId);
		instance.slotIndex = 0;
		instance.isInput = false;
		if (instance.linePoints != null)
		{
			List<Vector3> list = instance.linePoints;
			Pool.FreeUnmanaged<Vector3>(ref list);
			instance.linePoints = list;
		}
		instance.wireColor = 0;
		if (instance.lineAnchors != null)
		{
			for (int i = 0; i < instance.lineAnchors.Count; i++)
			{
				if (instance.lineAnchors[i] != null)
				{
					instance.lineAnchors[i].ResetToPool();
					instance.lineAnchors[i] = null;
				}
			}
			List<WireLineAnchorInfo> list2 = instance.lineAnchors;
			Pool.Free<WireLineAnchorInfo>(ref list2, false);
			instance.lineAnchors = list2;
		}
		if (instance.slackLevels != null)
		{
			List<float> list3 = instance.slackLevels;
			Pool.FreeUnmanaged<float>(ref list3);
			instance.slackLevels = list3;
		}
		Pool.Free<WireReconnectMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WireReconnectMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WireReconnectMessage instance)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		instance.entityId = entityId;
		instance.slotIndex = slotIndex;
		instance.isInput = isInput;
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<Vector3>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				Vector3 item = linePoints[i];
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
		instance.wireColor = wireColor;
		if (lineAnchors != null)
		{
			instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			for (int j = 0; j < lineAnchors.Count; j++)
			{
				WireLineAnchorInfo item2 = lineAnchors[j].Copy();
				instance.lineAnchors.Add(item2);
			}
		}
		else
		{
			instance.lineAnchors = null;
		}
		if (slackLevels != null)
		{
			instance.slackLevels = Pool.Get<List<float>>();
			for (int k = 0; k < slackLevels.Count; k++)
			{
				float item3 = slackLevels[k];
				instance.slackLevels.Add(item3);
			}
		}
		else
		{
			instance.slackLevels = null;
		}
	}

	public WireReconnectMessage Copy()
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		CopyTo(wireReconnectMessage);
		return wireReconnectMessage;
	}

	public static WireReconnectMessage Deserialize(BufferStream stream)
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		Deserialize(stream, wireReconnectMessage, isDelta: false);
		return wireReconnectMessage;
	}

	public static WireReconnectMessage DeserializeLengthDelimited(BufferStream stream)
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		DeserializeLengthDelimited(stream, wireReconnectMessage, isDelta: false);
		return wireReconnectMessage;
	}

	public static WireReconnectMessage DeserializeLength(BufferStream stream, int length)
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		DeserializeLength(stream, length, wireReconnectMessage, isDelta: false);
		return wireReconnectMessage;
	}

	public static WireReconnectMessage Deserialize(byte[] buffer)
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wireReconnectMessage, isDelta: false);
		return wireReconnectMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WireReconnectMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WireReconnectMessage Deserialize(BufferStream stream, WireReconnectMessage instance, bool isDelta)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.isInput = ProtocolParser.ReadBool(stream);
				break;
			case 34:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 40:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 50:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 61:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static WireReconnectMessage DeserializeLengthDelimited(BufferStream stream, WireReconnectMessage instance, bool isDelta)
	{
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.isInput = ProtocolParser.ReadBool(stream);
				break;
			case 34:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 40:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 50:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 61:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WireReconnectMessage DeserializeLength(BufferStream stream, int length, WireReconnectMessage instance, bool isDelta)
	{
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.isInput = ProtocolParser.ReadBool(stream);
				break;
			case 34:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 40:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 50:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 61:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WireReconnectMessage instance, WireReconnectMessage previous)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		if (instance.slotIndex != previous.slotIndex)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.isInput);
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				Vector3 val = instance.linePoints[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.wireColor != previous.wireColor)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wireColor);
		}
		if (instance.lineAnchors != null)
		{
			for (int j = 0; j < instance.lineAnchors.Count; j++)
			{
				WireLineAnchorInfo wireLineAnchorInfo = instance.lineAnchors[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WireLineAnchorInfo.SerializeDelta(stream, wireLineAnchorInfo, wireLineAnchorInfo);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(61);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public static void Serialize(BufferStream stream, WireReconnectMessage instance)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.slotIndex != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
		}
		if (instance.isInput)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.isInput);
		}
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				Vector3 instance2 = instance.linePoints[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.wireColor != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wireColor);
		}
		if (instance.lineAnchors != null)
		{
			for (int j = 0; j < instance.lineAnchors.Count; j++)
			{
				WireLineAnchorInfo instance3 = instance.lineAnchors[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WireLineAnchorInfo.Serialize(stream, instance3);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(61);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
		if (lineAnchors != null)
		{
			for (int i = 0; i < lineAnchors.Count; i++)
			{
				lineAnchors[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class WireLineAnchorInfo : IDisposable, IPooled, IProto<WireLineAnchorInfo>, IProto
{
	[NonSerialized]
	public NetworkableId parentID;

	[NonSerialized]
	public string boneName;

	[NonSerialized]
	public long index;

	[NonSerialized]
	public Vector3 position;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WireLineAnchorInfo instance)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.parentID = default(NetworkableId);
			instance.boneName = string.Empty;
			instance.index = 0L;
			instance.position = default(Vector3);
			Pool.Free<WireLineAnchorInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WireLineAnchorInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WireLineAnchorInfo instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.parentID = parentID;
		instance.boneName = boneName;
		instance.index = index;
		instance.position = position;
	}

	public WireLineAnchorInfo Copy()
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		CopyTo(wireLineAnchorInfo);
		return wireLineAnchorInfo;
	}

	public static WireLineAnchorInfo Deserialize(BufferStream stream)
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		Deserialize(stream, wireLineAnchorInfo, isDelta: false);
		return wireLineAnchorInfo;
	}

	public static WireLineAnchorInfo DeserializeLengthDelimited(BufferStream stream)
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		DeserializeLengthDelimited(stream, wireLineAnchorInfo, isDelta: false);
		return wireLineAnchorInfo;
	}

	public static WireLineAnchorInfo DeserializeLength(BufferStream stream, int length)
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		DeserializeLength(stream, length, wireLineAnchorInfo, isDelta: false);
		return wireLineAnchorInfo;
	}

	public static WireLineAnchorInfo Deserialize(byte[] buffer)
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wireLineAnchorInfo, isDelta: false);
		return wireLineAnchorInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WireLineAnchorInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WireLineAnchorInfo Deserialize(BufferStream stream, WireLineAnchorInfo instance, bool isDelta)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.boneName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.index = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WireLineAnchorInfo DeserializeLengthDelimited(BufferStream stream, WireLineAnchorInfo instance, bool isDelta)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.boneName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.index = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WireLineAnchorInfo DeserializeLength(BufferStream stream, int length, WireLineAnchorInfo instance, bool isDelta)
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.boneName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.index = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WireLineAnchorInfo instance, WireLineAnchorInfo previous)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		if (instance.boneName != previous.boneName)
		{
			if (instance.boneName == null)
			{
				throw new ArgumentNullException("boneName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.boneName);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		if (instance.position != previous.position)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, WireLineAnchorInfo instance)
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.parentID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		}
		if (instance.boneName == null)
		{
			throw new ArgumentNullException("boneName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.boneName);
		if (instance.index != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref parentID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class WireConnectionMessage : IDisposable, IPooled, IProto<WireConnectionMessage>, IProto
{
	[NonSerialized]
	public List<Vector3> linePoints;

	[NonSerialized]
	public List<WireLineAnchorInfo> lineAnchors;

	[NonSerialized]
	public NetworkableId inputID;

	[NonSerialized]
	public int inputIndex;

	[NonSerialized]
	public NetworkableId outputID;

	[NonSerialized]
	public int outputIndex;

	[NonSerialized]
	public int wireColor;

	[NonSerialized]
	public List<float> slackLevels;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WireConnectionMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.linePoints != null)
		{
			List<Vector3> list = instance.linePoints;
			Pool.FreeUnmanaged<Vector3>(ref list);
			instance.linePoints = list;
		}
		if (instance.lineAnchors != null)
		{
			for (int i = 0; i < instance.lineAnchors.Count; i++)
			{
				if (instance.lineAnchors[i] != null)
				{
					instance.lineAnchors[i].ResetToPool();
					instance.lineAnchors[i] = null;
				}
			}
			List<WireLineAnchorInfo> list2 = instance.lineAnchors;
			Pool.Free<WireLineAnchorInfo>(ref list2, false);
			instance.lineAnchors = list2;
		}
		instance.inputID = default(NetworkableId);
		instance.inputIndex = 0;
		instance.outputID = default(NetworkableId);
		instance.outputIndex = 0;
		instance.wireColor = 0;
		if (instance.slackLevels != null)
		{
			List<float> list3 = instance.slackLevels;
			Pool.FreeUnmanaged<float>(ref list3);
			instance.slackLevels = list3;
		}
		Pool.Free<WireConnectionMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WireConnectionMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WireConnectionMessage instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<Vector3>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				Vector3 item = linePoints[i];
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
		if (lineAnchors != null)
		{
			instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			for (int j = 0; j < lineAnchors.Count; j++)
			{
				WireLineAnchorInfo item2 = lineAnchors[j].Copy();
				instance.lineAnchors.Add(item2);
			}
		}
		else
		{
			instance.lineAnchors = null;
		}
		instance.inputID = inputID;
		instance.inputIndex = inputIndex;
		instance.outputID = outputID;
		instance.outputIndex = outputIndex;
		instance.wireColor = wireColor;
		if (slackLevels != null)
		{
			instance.slackLevels = Pool.Get<List<float>>();
			for (int k = 0; k < slackLevels.Count; k++)
			{
				float item3 = slackLevels[k];
				instance.slackLevels.Add(item3);
			}
		}
		else
		{
			instance.slackLevels = null;
		}
	}

	public WireConnectionMessage Copy()
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		CopyTo(wireConnectionMessage);
		return wireConnectionMessage;
	}

	public static WireConnectionMessage Deserialize(BufferStream stream)
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		Deserialize(stream, wireConnectionMessage, isDelta: false);
		return wireConnectionMessage;
	}

	public static WireConnectionMessage DeserializeLengthDelimited(BufferStream stream)
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		DeserializeLengthDelimited(stream, wireConnectionMessage, isDelta: false);
		return wireConnectionMessage;
	}

	public static WireConnectionMessage DeserializeLength(BufferStream stream, int length)
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		DeserializeLength(stream, length, wireConnectionMessage, isDelta: false);
		return wireConnectionMessage;
	}

	public static WireConnectionMessage Deserialize(byte[] buffer)
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wireConnectionMessage, isDelta: false);
		return wireConnectionMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WireConnectionMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WireConnectionMessage Deserialize(BufferStream stream, WireConnectionMessage instance, bool isDelta)
	{
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 18:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 24:
				instance.inputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 32:
				instance.inputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.outputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 48:
				instance.outputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 69:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static WireConnectionMessage DeserializeLengthDelimited(BufferStream stream, WireConnectionMessage instance, bool isDelta)
	{
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 18:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 24:
				instance.inputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 32:
				instance.inputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.outputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 48:
				instance.outputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 69:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WireConnectionMessage DeserializeLength(BufferStream stream, int length, WireConnectionMessage instance, bool isDelta)
	{
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 18:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 24:
				instance.inputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 32:
				instance.inputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.outputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 48:
				instance.outputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 69:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WireConnectionMessage instance, WireConnectionMessage previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				Vector3 val = instance.linePoints[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.lineAnchors != null)
		{
			for (int j = 0; j < instance.lineAnchors.Count; j++)
			{
				WireLineAnchorInfo wireLineAnchorInfo = instance.lineAnchors[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WireLineAnchorInfo.SerializeDelta(stream, wireLineAnchorInfo, wireLineAnchorInfo);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.inputID.Value);
		if (instance.inputIndex != previous.inputIndex)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputIndex);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.outputID.Value);
		if (instance.outputIndex != previous.outputIndex)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.outputIndex);
		}
		if (instance.wireColor != previous.wireColor)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wireColor);
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public static void Serialize(BufferStream stream, WireConnectionMessage instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				Vector3 instance2 = instance.linePoints[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.lineAnchors != null)
		{
			for (int j = 0; j < instance.lineAnchors.Count; j++)
			{
				WireLineAnchorInfo instance3 = instance.lineAnchors[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WireLineAnchorInfo.Serialize(stream, instance3);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.inputID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.inputID.Value);
		}
		if (instance.inputIndex != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputIndex);
		}
		if (instance.outputID != default(NetworkableId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.outputID.Value);
		}
		if (instance.outputIndex != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.outputIndex);
		}
		if (instance.wireColor != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wireColor);
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (lineAnchors != null)
		{
			for (int i = 0; i < lineAnchors.Count; i++)
			{
				lineAnchors[i]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref inputID.Value);
		action(UidType.NetworkableId, ref outputID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class OceanPaths : IDisposable, IPooled, IProto<OceanPaths>, IProto
{
	[NonSerialized]
	public List<Vector3> cargoPatrolPath;

	[NonSerialized]
	public List<VectorList> harborApproaches;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(OceanPaths instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.cargoPatrolPath != null)
		{
			List<Vector3> list = instance.cargoPatrolPath;
			Pool.FreeUnmanaged<Vector3>(ref list);
			instance.cargoPatrolPath = list;
		}
		if (instance.harborApproaches != null)
		{
			for (int i = 0; i < instance.harborApproaches.Count; i++)
			{
				if (instance.harborApproaches[i] != null)
				{
					instance.harborApproaches[i].ResetToPool();
					instance.harborApproaches[i] = null;
				}
			}
			List<VectorList> list2 = instance.harborApproaches;
			Pool.Free<VectorList>(ref list2, false);
			instance.harborApproaches = list2;
		}
		Pool.Free<OceanPaths>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose OceanPaths with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(OceanPaths instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (cargoPatrolPath != null)
		{
			instance.cargoPatrolPath = Pool.Get<List<Vector3>>();
			for (int i = 0; i < cargoPatrolPath.Count; i++)
			{
				Vector3 item = cargoPatrolPath[i];
				instance.cargoPatrolPath.Add(item);
			}
		}
		else
		{
			instance.cargoPatrolPath = null;
		}
		if (harborApproaches != null)
		{
			instance.harborApproaches = Pool.Get<List<VectorList>>();
			for (int j = 0; j < harborApproaches.Count; j++)
			{
				VectorList item2 = harborApproaches[j].Copy();
				instance.harborApproaches.Add(item2);
			}
		}
		else
		{
			instance.harborApproaches = null;
		}
	}

	public OceanPaths Copy()
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		CopyTo(oceanPaths);
		return oceanPaths;
	}

	public static OceanPaths Deserialize(BufferStream stream)
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		Deserialize(stream, oceanPaths, isDelta: false);
		return oceanPaths;
	}

	public static OceanPaths DeserializeLengthDelimited(BufferStream stream)
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		DeserializeLengthDelimited(stream, oceanPaths, isDelta: false);
		return oceanPaths;
	}

	public static OceanPaths DeserializeLength(BufferStream stream, int length)
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		DeserializeLength(stream, length, oceanPaths, isDelta: false);
		return oceanPaths;
	}

	public static OceanPaths Deserialize(byte[] buffer)
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, oceanPaths, isDelta: false);
		return oceanPaths;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, OceanPaths previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static OceanPaths Deserialize(BufferStream stream, OceanPaths instance, bool isDelta)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.cargoPatrolPath == null)
			{
				instance.cargoPatrolPath = Pool.Get<List<Vector3>>();
			}
			if (instance.harborApproaches == null)
			{
				instance.harborApproaches = Pool.Get<List<VectorList>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.cargoPatrolPath.Add(instance2);
				break;
			}
			case 18:
				instance.harborApproaches.Add(VectorList.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static OceanPaths DeserializeLengthDelimited(BufferStream stream, OceanPaths instance, bool isDelta)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.cargoPatrolPath == null)
			{
				instance.cargoPatrolPath = Pool.Get<List<Vector3>>();
			}
			if (instance.harborApproaches == null)
			{
				instance.harborApproaches = Pool.Get<List<VectorList>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.cargoPatrolPath.Add(instance2);
				break;
			}
			case 18:
				instance.harborApproaches.Add(VectorList.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static OceanPaths DeserializeLength(BufferStream stream, int length, OceanPaths instance, bool isDelta)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.cargoPatrolPath == null)
			{
				instance.cargoPatrolPath = Pool.Get<List<Vector3>>();
			}
			if (instance.harborApproaches == null)
			{
				instance.harborApproaches = Pool.Get<List<VectorList>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.cargoPatrolPath.Add(instance2);
				break;
			}
			case 18:
				instance.harborApproaches.Add(VectorList.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, OceanPaths instance, OceanPaths previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.cargoPatrolPath != null)
		{
			for (int i = 0; i < instance.cargoPatrolPath.Count; i++)
			{
				Vector3 val = instance.cargoPatrolPath[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cargoPatrolPath (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.harborApproaches == null)
		{
			return;
		}
		for (int j = 0; j < instance.harborApproaches.Count; j++)
		{
			VectorList vectorList = instance.harborApproaches[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(3);
			int position2 = stream.Position;
			VectorList.SerializeDelta(stream, vectorList, vectorList);
			int num2 = stream.Position - position2;
			if (num2 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field harborApproaches (ProtoBuf.VectorList)");
			}
			Span<byte> span2 = range2.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			if (num3 < 3)
			{
				span2[num3 - 1] |= 128;
				while (num3 < 2)
				{
					span2[num3++] = 128;
				}
				span2[2] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, OceanPaths instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.cargoPatrolPath != null)
		{
			for (int i = 0; i < instance.cargoPatrolPath.Count; i++)
			{
				Vector3 instance2 = instance.cargoPatrolPath[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cargoPatrolPath (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.harborApproaches == null)
		{
			return;
		}
		for (int j = 0; j < instance.harborApproaches.Count; j++)
		{
			VectorList instance3 = instance.harborApproaches[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(3);
			int position2 = stream.Position;
			VectorList.Serialize(stream, instance3);
			int num2 = stream.Position - position2;
			if (num2 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field harborApproaches (ProtoBuf.VectorList)");
			}
			Span<byte> span2 = range2.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			if (num3 < 3)
			{
				span2[num3 - 1] |= 128;
				while (num3 < 2)
				{
					span2[num3++] = 128;
				}
				span2[2] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (harborApproaches != null)
		{
			for (int i = 0; i < harborApproaches.Count; i++)
			{
				harborApproaches[i]?.InspectUids(action);
			}
		}
	}
}


