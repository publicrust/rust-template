using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SpectateTeamInfo : IDisposable, IPooled, IProto<SpectateTeamInfo>, IProto
{
	[NonSerialized]
	public List<SpectateTeam> teams;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpectateTeamInfo instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.teams != null)
		{
			for (int i = 0; i < instance.teams.Count; i++)
			{
				if (instance.teams[i] != null)
				{
					instance.teams[i].ResetToPool();
					instance.teams[i] = null;
				}
			}
			List<SpectateTeam> list = instance.teams;
			Pool.Free<SpectateTeam>(ref list, false);
			instance.teams = list;
		}
		Pool.Free<SpectateTeamInfo>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpectateTeamInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpectateTeamInfo instance)
	{
		if (teams != null)
		{
			instance.teams = Pool.Get<List<SpectateTeam>>();
			for (int i = 0; i < teams.Count; i++)
			{
				SpectateTeam item = teams[i].Copy();
				instance.teams.Add(item);
			}
		}
		else
		{
			instance.teams = null;
		}
	}

	public SpectateTeamInfo Copy()
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		CopyTo(spectateTeamInfo);
		return spectateTeamInfo;
	}

	public static SpectateTeamInfo Deserialize(BufferStream stream)
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		Deserialize(stream, spectateTeamInfo, isDelta: false);
		return spectateTeamInfo;
	}

	public static SpectateTeamInfo DeserializeLengthDelimited(BufferStream stream)
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		DeserializeLengthDelimited(stream, spectateTeamInfo, isDelta: false);
		return spectateTeamInfo;
	}

	public static SpectateTeamInfo DeserializeLength(BufferStream stream, int length)
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		DeserializeLength(stream, length, spectateTeamInfo, isDelta: false);
		return spectateTeamInfo;
	}

	public static SpectateTeamInfo Deserialize(byte[] buffer)
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spectateTeamInfo, isDelta: false);
		return spectateTeamInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpectateTeamInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpectateTeamInfo Deserialize(BufferStream stream, SpectateTeamInfo instance, bool isDelta)
	{
		if (!isDelta && instance.teams == null)
		{
			instance.teams = Pool.Get<List<SpectateTeam>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.teams.Add(SpectateTeam.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpectateTeamInfo DeserializeLengthDelimited(BufferStream stream, SpectateTeamInfo instance, bool isDelta)
	{
		if (!isDelta && instance.teams == null)
		{
			instance.teams = Pool.Get<List<SpectateTeam>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.teams.Add(SpectateTeam.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpectateTeamInfo DeserializeLength(BufferStream stream, int length, SpectateTeamInfo instance, bool isDelta)
	{
		if (!isDelta && instance.teams == null)
		{
			instance.teams = Pool.Get<List<SpectateTeam>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.teams.Add(SpectateTeam.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpectateTeamInfo instance, SpectateTeamInfo previous)
	{
		if (instance.teams == null)
		{
			return;
		}
		for (int i = 0; i < instance.teams.Count; i++)
		{
			SpectateTeam spectateTeam = instance.teams[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			SpectateTeam.SerializeDelta(stream, spectateTeam, spectateTeam);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, SpectateTeamInfo instance)
	{
		if (instance.teams == null)
		{
			return;
		}
		for (int i = 0; i < instance.teams.Count; i++)
		{
			SpectateTeam instance2 = instance.teams[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			SpectateTeam.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (teams != null)
		{
			for (int i = 0; i < teams.Count; i++)
			{
				teams[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SpectateTeam : IDisposable, IPooled, IProto<SpectateTeam>, IProto
{
	[NonSerialized]
	public ulong teamId;

	[NonSerialized]
	public List<PlayerTeam.TeamMember> teamMembers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpectateTeam instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.teamId = 0uL;
		if (instance.teamMembers != null)
		{
			for (int i = 0; i < instance.teamMembers.Count; i++)
			{
				if (instance.teamMembers[i] != null)
				{
					instance.teamMembers[i].ResetToPool();
					instance.teamMembers[i] = null;
				}
			}
			List<PlayerTeam.TeamMember> list = instance.teamMembers;
			Pool.Free<PlayerTeam.TeamMember>(ref list, false);
			instance.teamMembers = list;
		}
		Pool.Free<SpectateTeam>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpectateTeam with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpectateTeam instance)
	{
		instance.teamId = teamId;
		if (teamMembers != null)
		{
			instance.teamMembers = Pool.Get<List<PlayerTeam.TeamMember>>();
			for (int i = 0; i < teamMembers.Count; i++)
			{
				PlayerTeam.TeamMember item = teamMembers[i].Copy();
				instance.teamMembers.Add(item);
			}
		}
		else
		{
			instance.teamMembers = null;
		}
	}

	public SpectateTeam Copy()
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		CopyTo(spectateTeam);
		return spectateTeam;
	}

	public static SpectateTeam Deserialize(BufferStream stream)
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		Deserialize(stream, spectateTeam, isDelta: false);
		return spectateTeam;
	}

	public static SpectateTeam DeserializeLengthDelimited(BufferStream stream)
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		DeserializeLengthDelimited(stream, spectateTeam, isDelta: false);
		return spectateTeam;
	}

	public static SpectateTeam DeserializeLength(BufferStream stream, int length)
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		DeserializeLength(stream, length, spectateTeam, isDelta: false);
		return spectateTeam;
	}

	public static SpectateTeam Deserialize(byte[] buffer)
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spectateTeam, isDelta: false);
		return spectateTeam;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpectateTeam previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpectateTeam Deserialize(BufferStream stream, SpectateTeam instance, bool isDelta)
	{
		if (!isDelta && instance.teamMembers == null)
		{
			instance.teamMembers = Pool.Get<List<PlayerTeam.TeamMember>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamMembers.Add(PlayerTeam.TeamMember.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpectateTeam DeserializeLengthDelimited(BufferStream stream, SpectateTeam instance, bool isDelta)
	{
		if (!isDelta && instance.teamMembers == null)
		{
			instance.teamMembers = Pool.Get<List<PlayerTeam.TeamMember>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamMembers.Add(PlayerTeam.TeamMember.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpectateTeam DeserializeLength(BufferStream stream, int length, SpectateTeam instance, bool isDelta)
	{
		if (!isDelta && instance.teamMembers == null)
		{
			instance.teamMembers = Pool.Get<List<PlayerTeam.TeamMember>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamMembers.Add(PlayerTeam.TeamMember.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpectateTeam instance, SpectateTeam previous)
	{
		if (instance.teamId != previous.teamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.teamId);
		}
		if (instance.teamMembers == null)
		{
			return;
		}
		for (int i = 0; i < instance.teamMembers.Count; i++)
		{
			PlayerTeam.TeamMember teamMember = instance.teamMembers[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerTeam.TeamMember.SerializeDelta(stream, teamMember, teamMember);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, SpectateTeam instance)
	{
		if (instance.teamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.teamId);
		}
		if (instance.teamMembers == null)
		{
			return;
		}
		for (int i = 0; i < instance.teamMembers.Count; i++)
		{
			PlayerTeam.TeamMember instance2 = instance.teamMembers[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerTeam.TeamMember.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (teamMembers != null)
		{
			for (int i = 0; i < teamMembers.Count; i++)
			{
				teamMembers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerState : IDisposable, IPooled, IProto<PlayerState>, IProto
{
	[NonSerialized]
	public double unHostileTimestamp;

	[NonSerialized]
	public List<MapNote> pointsOfInterest;

	[NonSerialized]
	public MapNote deathMarker;

	[NonSerialized]
	public Missions missions;

	[NonSerialized]
	public List<MapNote> pings;

	[NonSerialized]
	public bool chatMuted;

	[NonSerialized]
	public double chatMuteExpiryTimestamp;

	[NonSerialized]
	public int numberOfTimesReported;

	[NonSerialized]
	public List<uint> fogImages;

	[NonSerialized]
	public NetworkableId fogImageNetId;

	[NonSerialized]
	public int protocol;

	[NonSerialized]
	public uint seed;

	[NonSerialized]
	public int saveCreatedTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerState instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.unHostileTimestamp = 0.0;
		if (instance.pointsOfInterest != null)
		{
			for (int i = 0; i < instance.pointsOfInterest.Count; i++)
			{
				if (instance.pointsOfInterest[i] != null)
				{
					instance.pointsOfInterest[i].ResetToPool();
					instance.pointsOfInterest[i] = null;
				}
			}
			List<MapNote> list = instance.pointsOfInterest;
			Pool.Free<MapNote>(ref list, false);
			instance.pointsOfInterest = list;
		}
		if (instance.deathMarker != null)
		{
			instance.deathMarker.ResetToPool();
			instance.deathMarker = null;
		}
		if (instance.missions != null)
		{
			instance.missions.ResetToPool();
			instance.missions = null;
		}
		if (instance.pings != null)
		{
			for (int j = 0; j < instance.pings.Count; j++)
			{
				if (instance.pings[j] != null)
				{
					instance.pings[j].ResetToPool();
					instance.pings[j] = null;
				}
			}
			List<MapNote> list2 = instance.pings;
			Pool.Free<MapNote>(ref list2, false);
			instance.pings = list2;
		}
		instance.chatMuted = false;
		instance.chatMuteExpiryTimestamp = 0.0;
		instance.numberOfTimesReported = 0;
		if (instance.fogImages != null)
		{
			List<uint> list3 = instance.fogImages;
			Pool.FreeUnmanaged<uint>(ref list3);
			instance.fogImages = list3;
		}
		instance.fogImageNetId = default(NetworkableId);
		instance.protocol = 0;
		instance.seed = 0u;
		instance.saveCreatedTime = 0;
		Pool.Free<PlayerState>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerState with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerState instance)
	{
		instance.unHostileTimestamp = unHostileTimestamp;
		if (pointsOfInterest != null)
		{
			instance.pointsOfInterest = Pool.Get<List<MapNote>>();
			for (int i = 0; i < pointsOfInterest.Count; i++)
			{
				MapNote item = pointsOfInterest[i].Copy();
				instance.pointsOfInterest.Add(item);
			}
		}
		else
		{
			instance.pointsOfInterest = null;
		}
		if (deathMarker != null)
		{
			if (instance.deathMarker == null)
			{
				instance.deathMarker = deathMarker.Copy();
			}
			else
			{
				deathMarker.CopyTo(instance.deathMarker);
			}
		}
		else
		{
			instance.deathMarker = null;
		}
		if (missions != null)
		{
			if (instance.missions == null)
			{
				instance.missions = missions.Copy();
			}
			else
			{
				missions.CopyTo(instance.missions);
			}
		}
		else
		{
			instance.missions = null;
		}
		if (pings != null)
		{
			instance.pings = Pool.Get<List<MapNote>>();
			for (int j = 0; j < pings.Count; j++)
			{
				MapNote item2 = pings[j].Copy();
				instance.pings.Add(item2);
			}
		}
		else
		{
			instance.pings = null;
		}
		instance.chatMuted = chatMuted;
		instance.chatMuteExpiryTimestamp = chatMuteExpiryTimestamp;
		instance.numberOfTimesReported = numberOfTimesReported;
		if (fogImages != null)
		{
			instance.fogImages = Pool.Get<List<uint>>();
			for (int k = 0; k < fogImages.Count; k++)
			{
				uint item3 = fogImages[k];
				instance.fogImages.Add(item3);
			}
		}
		else
		{
			instance.fogImages = null;
		}
		instance.fogImageNetId = fogImageNetId;
		instance.protocol = protocol;
		instance.seed = seed;
		instance.saveCreatedTime = saveCreatedTime;
	}

	public PlayerState Copy()
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		CopyTo(playerState);
		return playerState;
	}

	public static PlayerState Deserialize(BufferStream stream)
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		Deserialize(stream, playerState, isDelta: false);
		return playerState;
	}

	public static PlayerState DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		DeserializeLengthDelimited(stream, playerState, isDelta: false);
		return playerState;
	}

	public static PlayerState DeserializeLength(BufferStream stream, int length)
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		DeserializeLength(stream, length, playerState, isDelta: false);
		return playerState;
	}

	public static PlayerState Deserialize(byte[] buffer)
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerState, isDelta: false);
		return playerState;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerState previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerState Deserialize(BufferStream stream, PlayerState instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.pointsOfInterest == null)
			{
				instance.pointsOfInterest = Pool.Get<List<MapNote>>();
			}
			if (instance.pings == null)
			{
				instance.pings = Pool.Get<List<MapNote>>();
			}
			if (instance.fogImages == null)
			{
				instance.fogImages = Pool.Get<List<uint>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 9:
				instance.unHostileTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 26:
				instance.pointsOfInterest.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				if (instance.deathMarker == null)
				{
					instance.deathMarker = MapNote.DeserializeLengthDelimited(stream);
				}
				else
				{
					MapNote.DeserializeLengthDelimited(stream, instance.deathMarker, isDelta);
				}
				continue;
			case 42:
				if (instance.missions == null)
				{
					instance.missions = Missions.DeserializeLengthDelimited(stream);
				}
				else
				{
					Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
				}
				continue;
			case 50:
				instance.pings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.chatMuted = ProtocolParser.ReadBool(stream);
				continue;
			case 65:
				instance.chatMuteExpiryTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 72:
				instance.numberOfTimesReported = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.fogImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 88:
				instance.fogImageNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 50u:
				if (key.WireType == Wire.Varint)
				{
					instance.protocol = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 51u:
				if (key.WireType == Wire.Varint)
				{
					instance.seed = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 52u:
				if (key.WireType == Wire.Varint)
				{
					instance.saveCreatedTime = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static PlayerState DeserializeLengthDelimited(BufferStream stream, PlayerState instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.pointsOfInterest == null)
			{
				instance.pointsOfInterest = Pool.Get<List<MapNote>>();
			}
			if (instance.pings == null)
			{
				instance.pings = Pool.Get<List<MapNote>>();
			}
			if (instance.fogImages == null)
			{
				instance.fogImages = Pool.Get<List<uint>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 9:
				instance.unHostileTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 26:
				instance.pointsOfInterest.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				if (instance.deathMarker == null)
				{
					instance.deathMarker = MapNote.DeserializeLengthDelimited(stream);
				}
				else
				{
					MapNote.DeserializeLengthDelimited(stream, instance.deathMarker, isDelta);
				}
				continue;
			case 42:
				if (instance.missions == null)
				{
					instance.missions = Missions.DeserializeLengthDelimited(stream);
				}
				else
				{
					Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
				}
				continue;
			case 50:
				instance.pings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.chatMuted = ProtocolParser.ReadBool(stream);
				continue;
			case 65:
				instance.chatMuteExpiryTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 72:
				instance.numberOfTimesReported = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.fogImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 88:
				instance.fogImageNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 50u:
				if (key.WireType == Wire.Varint)
				{
					instance.protocol = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 51u:
				if (key.WireType == Wire.Varint)
				{
					instance.seed = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 52u:
				if (key.WireType == Wire.Varint)
				{
					instance.saveCreatedTime = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerState DeserializeLength(BufferStream stream, int length, PlayerState instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.pointsOfInterest == null)
			{
				instance.pointsOfInterest = Pool.Get<List<MapNote>>();
			}
			if (instance.pings == null)
			{
				instance.pings = Pool.Get<List<MapNote>>();
			}
			if (instance.fogImages == null)
			{
				instance.fogImages = Pool.Get<List<uint>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 9:
				instance.unHostileTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 26:
				instance.pointsOfInterest.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				if (instance.deathMarker == null)
				{
					instance.deathMarker = MapNote.DeserializeLengthDelimited(stream);
				}
				else
				{
					MapNote.DeserializeLengthDelimited(stream, instance.deathMarker, isDelta);
				}
				continue;
			case 42:
				if (instance.missions == null)
				{
					instance.missions = Missions.DeserializeLengthDelimited(stream);
				}
				else
				{
					Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
				}
				continue;
			case 50:
				instance.pings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.chatMuted = ProtocolParser.ReadBool(stream);
				continue;
			case 65:
				instance.chatMuteExpiryTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 72:
				instance.numberOfTimesReported = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.fogImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 88:
				instance.fogImageNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 50u:
				if (key.WireType == Wire.Varint)
				{
					instance.protocol = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 51u:
				if (key.WireType == Wire.Varint)
				{
					instance.seed = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 52u:
				if (key.WireType == Wire.Varint)
				{
					instance.saveCreatedTime = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerState instance, PlayerState previous)
	{
		if (instance.unHostileTimestamp != previous.unHostileTimestamp)
		{
			stream.WriteByte(9);
			ProtocolParser.WriteDouble(stream, instance.unHostileTimestamp);
		}
		if (instance.pointsOfInterest != null)
		{
			for (int i = 0; i < instance.pointsOfInterest.Count; i++)
			{
				MapNote mapNote = instance.pointsOfInterest[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MapNote.SerializeDelta(stream, mapNote, mapNote);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.deathMarker != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			MapNote.SerializeDelta(stream, instance.deathMarker, previous.deathMarker);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.missions != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			Missions.SerializeDelta(stream, instance.missions, previous.missions);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
		if (instance.pings != null)
		{
			for (int j = 0; j < instance.pings.Count; j++)
			{
				MapNote mapNote2 = instance.pings[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range4 = stream.GetRange(5);
				int position4 = stream.Position;
				MapNote.SerializeDelta(stream, mapNote2, mapNote2);
				int val4 = stream.Position - position4;
				Span<byte> span4 = range4.GetSpan();
				int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
				if (num4 < 5)
				{
					span4[num4 - 1] |= 128;
					while (num4 < 4)
					{
						span4[num4++] = 128;
					}
					span4[4] = 0;
				}
			}
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.chatMuted);
		if (instance.chatMuteExpiryTimestamp != previous.chatMuteExpiryTimestamp)
		{
			stream.WriteByte(65);
			ProtocolParser.WriteDouble(stream, instance.chatMuteExpiryTimestamp);
		}
		if (instance.numberOfTimesReported != previous.numberOfTimesReported)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numberOfTimesReported);
		}
		if (instance.fogImages != null)
		{
			for (int k = 0; k < instance.fogImages.Count; k++)
			{
				uint val5 = instance.fogImages[k];
				stream.WriteByte(80);
				ProtocolParser.WriteUInt32(stream, val5);
			}
		}
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, instance.fogImageNetId.Value);
		if (instance.protocol != previous.protocol)
		{
			stream.WriteByte(144);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.protocol);
		}
		if (instance.seed != previous.seed)
		{
			stream.WriteByte(152);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.saveCreatedTime != previous.saveCreatedTime)
		{
			stream.WriteByte(160);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.saveCreatedTime);
		}
	}

	public static void Serialize(BufferStream stream, PlayerState instance)
	{
		if (instance.unHostileTimestamp != 0.0)
		{
			stream.WriteByte(9);
			ProtocolParser.WriteDouble(stream, instance.unHostileTimestamp);
		}
		if (instance.pointsOfInterest != null)
		{
			for (int i = 0; i < instance.pointsOfInterest.Count; i++)
			{
				MapNote instance2 = instance.pointsOfInterest[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MapNote.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.deathMarker != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			MapNote.Serialize(stream, instance.deathMarker);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.missions != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			Missions.Serialize(stream, instance.missions);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
		if (instance.pings != null)
		{
			for (int j = 0; j < instance.pings.Count; j++)
			{
				MapNote instance3 = instance.pings[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range4 = stream.GetRange(5);
				int position4 = stream.Position;
				MapNote.Serialize(stream, instance3);
				int val4 = stream.Position - position4;
				Span<byte> span4 = range4.GetSpan();
				int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
				if (num4 < 5)
				{
					span4[num4 - 1] |= 128;
					while (num4 < 4)
					{
						span4[num4++] = 128;
					}
					span4[4] = 0;
				}
			}
		}
		if (instance.chatMuted)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.chatMuted);
		}
		if (instance.chatMuteExpiryTimestamp != 0.0)
		{
			stream.WriteByte(65);
			ProtocolParser.WriteDouble(stream, instance.chatMuteExpiryTimestamp);
		}
		if (instance.numberOfTimesReported != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numberOfTimesReported);
		}
		if (instance.fogImages != null)
		{
			for (int k = 0; k < instance.fogImages.Count; k++)
			{
				uint val5 = instance.fogImages[k];
				stream.WriteByte(80);
				ProtocolParser.WriteUInt32(stream, val5);
			}
		}
		if (instance.fogImageNetId != default(NetworkableId))
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, instance.fogImageNetId.Value);
		}
		if (instance.protocol != 0)
		{
			stream.WriteByte(144);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.protocol);
		}
		if (instance.seed != 0)
		{
			stream.WriteByte(152);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.saveCreatedTime != 0)
		{
			stream.WriteByte(160);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.saveCreatedTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (pointsOfInterest != null)
		{
			for (int i = 0; i < pointsOfInterest.Count; i++)
			{
				pointsOfInterest[i]?.InspectUids(action);
			}
		}
		deathMarker?.InspectUids(action);
		missions?.InspectUids(action);
		if (pings != null)
		{
			for (int j = 0; j < pings.Count; j++)
			{
				pings[j]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref fogImageNetId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerNameID : IDisposable, IPooled, IProto<PlayerNameID>, IProto
{
	[NonSerialized]
	public string username;

	[NonSerialized]
	public ulong userid;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerNameID instance)
	{
		if (instance.ShouldPool)
		{
			instance.username = string.Empty;
			instance.userid = 0uL;
			Pool.Free<PlayerNameID>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerNameID with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerNameID instance)
	{
		instance.username = username;
		instance.userid = userid;
	}

	public PlayerNameID Copy()
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		CopyTo(playerNameID);
		return playerNameID;
	}

	public static PlayerNameID Deserialize(BufferStream stream)
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		Deserialize(stream, playerNameID, isDelta: false);
		return playerNameID;
	}

	public static PlayerNameID DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		DeserializeLengthDelimited(stream, playerNameID, isDelta: false);
		return playerNameID;
	}

	public static PlayerNameID DeserializeLength(BufferStream stream, int length)
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		DeserializeLength(stream, length, playerNameID, isDelta: false);
		return playerNameID;
	}

	public static PlayerNameID Deserialize(byte[] buffer)
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerNameID, isDelta: false);
		return playerNameID;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerNameID previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerNameID Deserialize(BufferStream stream, PlayerNameID instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerNameID DeserializeLengthDelimited(BufferStream stream, PlayerNameID instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerNameID DeserializeLength(BufferStream stream, int length, PlayerNameID instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerNameID instance, PlayerNameID previous)
	{
		if (instance.username != previous.username)
		{
			if (instance.username == null)
			{
				throw new ArgumentNullException("username", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.username);
		}
		if (instance.userid != previous.userid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
	}

	public static void Serialize(BufferStream stream, PlayerNameID instance)
	{
		if (instance.username == null)
		{
			throw new ArgumentNullException("username", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.username);
		if (instance.userid != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class DemoHeader : IDisposable, IPooled, IProto<DemoHeader>, IProto
{
	[NonSerialized]
	public uint version;

	[NonSerialized]
	public string level;

	[NonSerialized]
	public uint levelSeed;

	[NonSerialized]
	public uint levelSize;

	[NonSerialized]
	public string checksum;

	[NonSerialized]
	public ulong localclient;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 rotation;

	[NonSerialized]
	public string levelUrl;

	[NonSerialized]
	public long recordedTime;

	[NonSerialized]
	public long length;

	[NonSerialized]
	public List<FileStorageCacheData> fileStorage;

	[NonSerialized]
	public bool nexus;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoHeader instance)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.version = 0u;
		instance.level = string.Empty;
		instance.levelSeed = 0u;
		instance.levelSize = 0u;
		instance.checksum = string.Empty;
		instance.localclient = 0uL;
		instance.position = default(Vector3);
		instance.rotation = default(Vector3);
		instance.levelUrl = string.Empty;
		instance.recordedTime = 0L;
		instance.length = 0L;
		if (instance.fileStorage != null)
		{
			for (int i = 0; i < instance.fileStorage.Count; i++)
			{
				if (instance.fileStorage[i] != null)
				{
					instance.fileStorage[i].ResetToPool();
					instance.fileStorage[i] = null;
				}
			}
			List<FileStorageCacheData> list = instance.fileStorage;
			Pool.Free<FileStorageCacheData>(ref list, false);
			instance.fileStorage = list;
		}
		instance.nexus = false;
		Pool.Free<DemoHeader>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoHeader with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoHeader instance)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.version = version;
		instance.level = level;
		instance.levelSeed = levelSeed;
		instance.levelSize = levelSize;
		instance.checksum = checksum;
		instance.localclient = localclient;
		instance.position = position;
		instance.rotation = rotation;
		instance.levelUrl = levelUrl;
		instance.recordedTime = recordedTime;
		instance.length = length;
		if (fileStorage != null)
		{
			instance.fileStorage = Pool.Get<List<FileStorageCacheData>>();
			for (int i = 0; i < fileStorage.Count; i++)
			{
				FileStorageCacheData item = fileStorage[i].Copy();
				instance.fileStorage.Add(item);
			}
		}
		else
		{
			instance.fileStorage = null;
		}
		instance.nexus = nexus;
	}

	public DemoHeader Copy()
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		CopyTo(demoHeader);
		return demoHeader;
	}

	public static DemoHeader Deserialize(BufferStream stream)
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		Deserialize(stream, demoHeader, isDelta: false);
		return demoHeader;
	}

	public static DemoHeader DeserializeLengthDelimited(BufferStream stream)
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		DeserializeLengthDelimited(stream, demoHeader, isDelta: false);
		return demoHeader;
	}

	public static DemoHeader DeserializeLength(BufferStream stream, int length)
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		DeserializeLength(stream, length, demoHeader, isDelta: false);
		return demoHeader;
	}

	public static DemoHeader Deserialize(byte[] buffer)
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoHeader, isDelta: false);
		return demoHeader;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoHeader previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoHeader Deserialize(BufferStream stream, DemoHeader instance, bool isDelta)
	{
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.fileStorage == null)
		{
			instance.fileStorage = Pool.Get<List<FileStorageCacheData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.version = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.localclient = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 74:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.recordedTime = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.length = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 98:
				instance.fileStorage.Add(FileStorageCacheData.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.nexus = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoHeader DeserializeLengthDelimited(BufferStream stream, DemoHeader instance, bool isDelta)
	{
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.fileStorage == null)
		{
			instance.fileStorage = Pool.Get<List<FileStorageCacheData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.version = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.localclient = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 74:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.recordedTime = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.length = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 98:
				instance.fileStorage.Add(FileStorageCacheData.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.nexus = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoHeader DeserializeLength(BufferStream stream, int length, DemoHeader instance, bool isDelta)
	{
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.fileStorage == null)
		{
			instance.fileStorage = Pool.Get<List<FileStorageCacheData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.version = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.localclient = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 74:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.recordedTime = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.length = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 98:
				instance.fileStorage.Add(FileStorageCacheData.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.nexus = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoHeader instance, DemoHeader previous)
	{
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		if (instance.version != previous.version)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.version);
		}
		if (instance.level != previous.level)
		{
			if (instance.level == null)
			{
				throw new ArgumentNullException("level", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.level);
		}
		if (instance.levelSeed != previous.levelSeed)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.levelSeed);
		}
		if (instance.levelSize != previous.levelSize)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.levelSize);
		}
		if (instance.checksum != null && instance.checksum != previous.checksum)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.checksum);
		}
		if (instance.localclient != previous.localclient)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.localclient);
		}
		if (instance.position != previous.position)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rotation, previous.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.levelUrl != previous.levelUrl)
		{
			if (instance.levelUrl == null)
			{
				throw new ArgumentNullException("levelUrl", "Required by proto specification.");
			}
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.levelUrl);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.recordedTime);
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.length);
		if (instance.fileStorage != null)
		{
			for (int i = 0; i < instance.fileStorage.Count; i++)
			{
				FileStorageCacheData fileStorageCacheData = instance.fileStorage[i];
				stream.WriteByte(98);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int num5 = stream.Position;
				FileStorageCacheData.SerializeDelta(stream, fileStorageCacheData, fileStorageCacheData);
				int val = stream.Position - num5;
				Span<byte> span3 = range3.GetSpan();
				int num6 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num6 < 5)
				{
					span3[num6 - 1] |= 128;
					while (num6 < 4)
					{
						span3[num6++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		stream.WriteByte(104);
		ProtocolParser.WriteBool(stream, instance.nexus);
	}

	public static void Serialize(BufferStream stream, DemoHeader instance)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if (instance.version != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.version);
		}
		if (instance.level == null)
		{
			throw new ArgumentNullException("level", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.level);
		if (instance.levelSeed != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.levelSeed);
		}
		if (instance.levelSize != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.levelSize);
		}
		if (instance.checksum != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.checksum);
		}
		if (instance.localclient != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.localclient);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.levelUrl == null)
		{
			throw new ArgumentNullException("levelUrl", "Required by proto specification.");
		}
		stream.WriteByte(74);
		ProtocolParser.WriteString(stream, instance.levelUrl);
		if (instance.recordedTime != 0L)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.recordedTime);
		}
		if (instance.length != 0L)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.length);
		}
		if (instance.fileStorage != null)
		{
			for (int i = 0; i < instance.fileStorage.Count; i++)
			{
				FileStorageCacheData instance2 = instance.fileStorage[i];
				stream.WriteByte(98);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int num5 = stream.Position;
				FileStorageCacheData.Serialize(stream, instance2);
				int val = stream.Position - num5;
				Span<byte> span3 = range3.GetSpan();
				int num6 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num6 < 5)
				{
					span3[num6 - 1] |= 128;
					while (num6 < 4)
					{
						span3[num6++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.nexus)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteBool(stream, instance.nexus);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (fileStorage != null)
		{
			for (int i = 0; i < fileStorage.Count; i++)
			{
				fileStorage[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class FileStorageCacheData : IDisposable, IPooled, IProto<FileStorageCacheData>, IProto
{
	[NonSerialized]
	public byte[] data;

	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public uint numId;

	[NonSerialized]
	public uint crc;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FileStorageCacheData instance)
	{
		if (instance.ShouldPool)
		{
			instance.data = null;
			instance.entityId = default(NetworkableId);
			instance.numId = 0u;
			instance.crc = 0u;
			Pool.Free<FileStorageCacheData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FileStorageCacheData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FileStorageCacheData instance)
	{
		if (data == null)
		{
			instance.data = null;
		}
		else
		{
			instance.data = new byte[data.Length];
			Array.Copy(data, instance.data, instance.data.Length);
		}
		instance.entityId = entityId;
		instance.numId = numId;
		instance.crc = crc;
	}

	public FileStorageCacheData Copy()
	{
		FileStorageCacheData fileStorageCacheData = Pool.Get<FileStorageCacheData>();
		CopyTo(fileStorageCacheData);
		return fileStorageCacheData;
	}

	public static FileStorageCacheData Deserialize(BufferStream stream)
	{
		FileStorageCacheData fileStorageCacheData = Pool.Get<FileStorageCacheData>();
		Deserialize(stream, fileStorageCacheData, isDelta: false);
		return fileStorageCacheData;
	}

	public static FileStorageCacheData DeserializeLengthDelimited(BufferStream stream)
	{
		FileStorageCacheData fileStorageCacheData = Pool.Get<FileStorageCacheData>();
		DeserializeLengthDelimited(stream, fileStorageCacheData, isDelta: false);
		return fileStorageCacheData;
	}

	public static FileStorageCacheData DeserializeLength(BufferStream stream, int length)
	{
		FileStorageCacheData fileStorageCacheData = Pool.Get<FileStorageCacheData>();
		DeserializeLength(stream, length, fileStorageCacheData, isDelta: false);
		return fileStorageCacheData;
	}

	public static FileStorageCacheData Deserialize(byte[] buffer)
	{
		FileStorageCacheData fileStorageCacheData = Pool.Get<FileStorageCacheData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, fileStorageCacheData, isDelta: false);
		return fileStorageCacheData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FileStorageCacheData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FileStorageCacheData Deserialize(BufferStream stream, FileStorageCacheData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case 16:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.numId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FileStorageCacheData DeserializeLengthDelimited(BufferStream stream, FileStorageCacheData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case 16:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.numId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FileStorageCacheData DeserializeLength(BufferStream stream, int length, FileStorageCacheData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case 16:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.numId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FileStorageCacheData instance, FileStorageCacheData previous)
	{
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteBytes(stream, instance.data);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		if (instance.numId != previous.numId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.numId);
		}
		if (instance.crc != previous.crc)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
	}

	public static void Serialize(BufferStream stream, FileStorageCacheData instance)
	{
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteBytes(stream, instance.data);
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.numId != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.numId);
		}
		if (instance.crc != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShot : IDisposable, IPooled, IProto<DemoShot>, IProto
{
	[NonSerialized]
	public string shotName;

	[NonSerialized]
	public string demoName;

	[NonSerialized]
	public float shotStart;

	[NonSerialized]
	public float shotLength;

	[NonSerialized]
	public DemoShotVectorTrack camPos;

	[NonSerialized]
	public DemoShotQuaternionTrack camRot;

	[NonSerialized]
	public DemoShotFloatTrack camFov;

	[NonSerialized]
	public DemoShotFloatTrack camDofDist;

	[NonSerialized]
	public DemoShotFloatTrack camDofFocalSize;

	[NonSerialized]
	public DemoShotFloatTrack camDofAperture;

	[NonSerialized]
	public DemoShotParentTrack camParent;

	[NonSerialized]
	public string folderName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShot instance)
	{
		if (instance.ShouldPool)
		{
			instance.shotName = string.Empty;
			instance.demoName = string.Empty;
			instance.shotStart = 0f;
			instance.shotLength = 0f;
			if (instance.camPos != null)
			{
				instance.camPos.ResetToPool();
				instance.camPos = null;
			}
			if (instance.camRot != null)
			{
				instance.camRot.ResetToPool();
				instance.camRot = null;
			}
			if (instance.camFov != null)
			{
				instance.camFov.ResetToPool();
				instance.camFov = null;
			}
			if (instance.camDofDist != null)
			{
				instance.camDofDist.ResetToPool();
				instance.camDofDist = null;
			}
			if (instance.camDofFocalSize != null)
			{
				instance.camDofFocalSize.ResetToPool();
				instance.camDofFocalSize = null;
			}
			if (instance.camDofAperture != null)
			{
				instance.camDofAperture.ResetToPool();
				instance.camDofAperture = null;
			}
			if (instance.camParent != null)
			{
				instance.camParent.ResetToPool();
				instance.camParent = null;
			}
			instance.folderName = string.Empty;
			Pool.Free<DemoShot>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShot with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShot instance)
	{
		instance.shotName = shotName;
		instance.demoName = demoName;
		instance.shotStart = shotStart;
		instance.shotLength = shotLength;
		if (camPos != null)
		{
			if (instance.camPos == null)
			{
				instance.camPos = camPos.Copy();
			}
			else
			{
				camPos.CopyTo(instance.camPos);
			}
		}
		else
		{
			instance.camPos = null;
		}
		if (camRot != null)
		{
			if (instance.camRot == null)
			{
				instance.camRot = camRot.Copy();
			}
			else
			{
				camRot.CopyTo(instance.camRot);
			}
		}
		else
		{
			instance.camRot = null;
		}
		if (camFov != null)
		{
			if (instance.camFov == null)
			{
				instance.camFov = camFov.Copy();
			}
			else
			{
				camFov.CopyTo(instance.camFov);
			}
		}
		else
		{
			instance.camFov = null;
		}
		if (camDofDist != null)
		{
			if (instance.camDofDist == null)
			{
				instance.camDofDist = camDofDist.Copy();
			}
			else
			{
				camDofDist.CopyTo(instance.camDofDist);
			}
		}
		else
		{
			instance.camDofDist = null;
		}
		if (camDofFocalSize != null)
		{
			if (instance.camDofFocalSize == null)
			{
				instance.camDofFocalSize = camDofFocalSize.Copy();
			}
			else
			{
				camDofFocalSize.CopyTo(instance.camDofFocalSize);
			}
		}
		else
		{
			instance.camDofFocalSize = null;
		}
		if (camDofAperture != null)
		{
			if (instance.camDofAperture == null)
			{
				instance.camDofAperture = camDofAperture.Copy();
			}
			else
			{
				camDofAperture.CopyTo(instance.camDofAperture);
			}
		}
		else
		{
			instance.camDofAperture = null;
		}
		if (camParent != null)
		{
			if (instance.camParent == null)
			{
				instance.camParent = camParent.Copy();
			}
			else
			{
				camParent.CopyTo(instance.camParent);
			}
		}
		else
		{
			instance.camParent = null;
		}
		instance.folderName = folderName;
	}

	public DemoShot Copy()
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		CopyTo(demoShot);
		return demoShot;
	}

	public static DemoShot Deserialize(BufferStream stream)
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		Deserialize(stream, demoShot, isDelta: false);
		return demoShot;
	}

	public static DemoShot DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		DeserializeLengthDelimited(stream, demoShot, isDelta: false);
		return demoShot;
	}

	public static DemoShot DeserializeLength(BufferStream stream, int length)
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		DeserializeLength(stream, length, demoShot, isDelta: false);
		return demoShot;
	}

	public static DemoShot Deserialize(byte[] buffer)
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShot, isDelta: false);
		return demoShot;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShot previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShot Deserialize(BufferStream stream, DemoShot instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.shotName = ProtocolParser.ReadString(stream);
				break;
			case 18:
				instance.demoName = ProtocolParser.ReadString(stream);
				break;
			case 29:
				instance.shotStart = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.shotLength = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.camPos == null)
				{
					instance.camPos = DemoShotVectorTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotVectorTrack.DeserializeLengthDelimited(stream, instance.camPos, isDelta);
				}
				break;
			case 50:
				if (instance.camRot == null)
				{
					instance.camRot = DemoShotQuaternionTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotQuaternionTrack.DeserializeLengthDelimited(stream, instance.camRot, isDelta);
				}
				break;
			case 58:
				if (instance.camFov == null)
				{
					instance.camFov = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camFov, isDelta);
				}
				break;
			case 74:
				if (instance.camDofDist == null)
				{
					instance.camDofDist = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofDist, isDelta);
				}
				break;
			case 82:
				if (instance.camDofFocalSize == null)
				{
					instance.camDofFocalSize = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofFocalSize, isDelta);
				}
				break;
			case 90:
				if (instance.camDofAperture == null)
				{
					instance.camDofAperture = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofAperture, isDelta);
				}
				break;
			case 98:
				if (instance.camParent == null)
				{
					instance.camParent = DemoShotParentTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotParentTrack.DeserializeLengthDelimited(stream, instance.camParent, isDelta);
				}
				break;
			case 66:
				instance.folderName = ProtocolParser.ReadString(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static DemoShot DeserializeLengthDelimited(BufferStream stream, DemoShot instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shotName = ProtocolParser.ReadString(stream);
				break;
			case 18:
				instance.demoName = ProtocolParser.ReadString(stream);
				break;
			case 29:
				instance.shotStart = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.shotLength = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.camPos == null)
				{
					instance.camPos = DemoShotVectorTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotVectorTrack.DeserializeLengthDelimited(stream, instance.camPos, isDelta);
				}
				break;
			case 50:
				if (instance.camRot == null)
				{
					instance.camRot = DemoShotQuaternionTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotQuaternionTrack.DeserializeLengthDelimited(stream, instance.camRot, isDelta);
				}
				break;
			case 58:
				if (instance.camFov == null)
				{
					instance.camFov = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camFov, isDelta);
				}
				break;
			case 74:
				if (instance.camDofDist == null)
				{
					instance.camDofDist = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofDist, isDelta);
				}
				break;
			case 82:
				if (instance.camDofFocalSize == null)
				{
					instance.camDofFocalSize = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofFocalSize, isDelta);
				}
				break;
			case 90:
				if (instance.camDofAperture == null)
				{
					instance.camDofAperture = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofAperture, isDelta);
				}
				break;
			case 98:
				if (instance.camParent == null)
				{
					instance.camParent = DemoShotParentTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotParentTrack.DeserializeLengthDelimited(stream, instance.camParent, isDelta);
				}
				break;
			case 66:
				instance.folderName = ProtocolParser.ReadString(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShot DeserializeLength(BufferStream stream, int length, DemoShot instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shotName = ProtocolParser.ReadString(stream);
				break;
			case 18:
				instance.demoName = ProtocolParser.ReadString(stream);
				break;
			case 29:
				instance.shotStart = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.shotLength = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.camPos == null)
				{
					instance.camPos = DemoShotVectorTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotVectorTrack.DeserializeLengthDelimited(stream, instance.camPos, isDelta);
				}
				break;
			case 50:
				if (instance.camRot == null)
				{
					instance.camRot = DemoShotQuaternionTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotQuaternionTrack.DeserializeLengthDelimited(stream, instance.camRot, isDelta);
				}
				break;
			case 58:
				if (instance.camFov == null)
				{
					instance.camFov = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camFov, isDelta);
				}
				break;
			case 74:
				if (instance.camDofDist == null)
				{
					instance.camDofDist = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofDist, isDelta);
				}
				break;
			case 82:
				if (instance.camDofFocalSize == null)
				{
					instance.camDofFocalSize = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofFocalSize, isDelta);
				}
				break;
			case 90:
				if (instance.camDofAperture == null)
				{
					instance.camDofAperture = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofAperture, isDelta);
				}
				break;
			case 98:
				if (instance.camParent == null)
				{
					instance.camParent = DemoShotParentTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotParentTrack.DeserializeLengthDelimited(stream, instance.camParent, isDelta);
				}
				break;
			case 66:
				instance.folderName = ProtocolParser.ReadString(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShot instance, DemoShot previous)
	{
		if (instance.shotName != previous.shotName)
		{
			if (instance.shotName == null)
			{
				throw new ArgumentNullException("shotName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.shotName);
		}
		if (instance.demoName != previous.demoName)
		{
			if (instance.demoName == null)
			{
				throw new ArgumentNullException("demoName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.demoName);
		}
		if (instance.shotStart != previous.shotStart)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.shotStart);
		}
		if (instance.shotLength != previous.shotLength)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.shotLength);
		}
		if (instance.camPos == null)
		{
			throw new ArgumentNullException("camPos", "Required by proto specification.");
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		DemoShotVectorTrack.SerializeDelta(stream, instance.camPos, previous.camPos);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camPos (ProtoBuf.DemoShotVectorTrack)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
		if (instance.camRot == null)
		{
			throw new ArgumentNullException("camRot", "Required by proto specification.");
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range2 = stream.GetRange(3);
		int position2 = stream.Position;
		DemoShotQuaternionTrack.SerializeDelta(stream, instance.camRot, previous.camRot);
		int num3 = stream.Position - position2;
		if (num3 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camRot (ProtoBuf.DemoShotQuaternionTrack)");
		}
		Span<byte> span2 = range2.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)num3, span2, 0);
		if (num4 < 3)
		{
			span2[num4 - 1] |= 128;
			while (num4 < 2)
			{
				span2[num4++] = 128;
			}
			span2[2] = 0;
		}
		if (instance.camFov == null)
		{
			throw new ArgumentNullException("camFov", "Required by proto specification.");
		}
		stream.WriteByte(58);
		BufferStream.RangeHandle range3 = stream.GetRange(3);
		int position3 = stream.Position;
		DemoShotFloatTrack.SerializeDelta(stream, instance.camFov, previous.camFov);
		int num5 = stream.Position - position3;
		if (num5 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camFov (ProtoBuf.DemoShotFloatTrack)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num6 = ProtocolParser.WriteUInt32((uint)num5, span3, 0);
		if (num6 < 3)
		{
			span3[num6 - 1] |= 128;
			while (num6 < 2)
			{
				span3[num6++] = 128;
			}
			span3[2] = 0;
		}
		if (instance.camDofDist != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range4 = stream.GetRange(3);
			int position4 = stream.Position;
			DemoShotFloatTrack.SerializeDelta(stream, instance.camDofDist, previous.camDofDist);
			int num7 = stream.Position - position4;
			if (num7 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofDist (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span4 = range4.GetSpan();
			int num8 = ProtocolParser.WriteUInt32((uint)num7, span4, 0);
			if (num8 < 3)
			{
				span4[num8 - 1] |= 128;
				while (num8 < 2)
				{
					span4[num8++] = 128;
				}
				span4[2] = 0;
			}
		}
		if (instance.camDofFocalSize != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range5 = stream.GetRange(3);
			int position5 = stream.Position;
			DemoShotFloatTrack.SerializeDelta(stream, instance.camDofFocalSize, previous.camDofFocalSize);
			int num9 = stream.Position - position5;
			if (num9 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofFocalSize (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span5 = range5.GetSpan();
			int num10 = ProtocolParser.WriteUInt32((uint)num9, span5, 0);
			if (num10 < 3)
			{
				span5[num10 - 1] |= 128;
				while (num10 < 2)
				{
					span5[num10++] = 128;
				}
				span5[2] = 0;
			}
		}
		if (instance.camDofAperture != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range6 = stream.GetRange(3);
			int position6 = stream.Position;
			DemoShotFloatTrack.SerializeDelta(stream, instance.camDofAperture, previous.camDofAperture);
			int num11 = stream.Position - position6;
			if (num11 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofAperture (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span6 = range6.GetSpan();
			int num12 = ProtocolParser.WriteUInt32((uint)num11, span6, 0);
			if (num12 < 3)
			{
				span6[num12 - 1] |= 128;
				while (num12 < 2)
				{
					span6[num12++] = 128;
				}
				span6[2] = 0;
			}
		}
		if (instance.camParent != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range7 = stream.GetRange(5);
			int position7 = stream.Position;
			DemoShotParentTrack.SerializeDelta(stream, instance.camParent, previous.camParent);
			int val = stream.Position - position7;
			Span<byte> span7 = range7.GetSpan();
			int num13 = ProtocolParser.WriteUInt32((uint)val, span7, 0);
			if (num13 < 5)
			{
				span7[num13 - 1] |= 128;
				while (num13 < 4)
				{
					span7[num13++] = 128;
				}
				span7[4] = 0;
			}
		}
		if (instance.folderName != null && instance.folderName != previous.folderName)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.folderName);
		}
	}

	public static void Serialize(BufferStream stream, DemoShot instance)
	{
		if (instance.shotName == null)
		{
			throw new ArgumentNullException("shotName", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.shotName);
		if (instance.demoName == null)
		{
			throw new ArgumentNullException("demoName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.demoName);
		if (instance.shotStart != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.shotStart);
		}
		if (instance.shotLength != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.shotLength);
		}
		if (instance.camPos == null)
		{
			throw new ArgumentNullException("camPos", "Required by proto specification.");
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		DemoShotVectorTrack.Serialize(stream, instance.camPos);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camPos (ProtoBuf.DemoShotVectorTrack)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
		if (instance.camRot == null)
		{
			throw new ArgumentNullException("camRot", "Required by proto specification.");
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range2 = stream.GetRange(3);
		int position2 = stream.Position;
		DemoShotQuaternionTrack.Serialize(stream, instance.camRot);
		int num3 = stream.Position - position2;
		if (num3 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camRot (ProtoBuf.DemoShotQuaternionTrack)");
		}
		Span<byte> span2 = range2.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)num3, span2, 0);
		if (num4 < 3)
		{
			span2[num4 - 1] |= 128;
			while (num4 < 2)
			{
				span2[num4++] = 128;
			}
			span2[2] = 0;
		}
		if (instance.camFov == null)
		{
			throw new ArgumentNullException("camFov", "Required by proto specification.");
		}
		stream.WriteByte(58);
		BufferStream.RangeHandle range3 = stream.GetRange(3);
		int position3 = stream.Position;
		DemoShotFloatTrack.Serialize(stream, instance.camFov);
		int num5 = stream.Position - position3;
		if (num5 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camFov (ProtoBuf.DemoShotFloatTrack)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num6 = ProtocolParser.WriteUInt32((uint)num5, span3, 0);
		if (num6 < 3)
		{
			span3[num6 - 1] |= 128;
			while (num6 < 2)
			{
				span3[num6++] = 128;
			}
			span3[2] = 0;
		}
		if (instance.camDofDist != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range4 = stream.GetRange(3);
			int position4 = stream.Position;
			DemoShotFloatTrack.Serialize(stream, instance.camDofDist);
			int num7 = stream.Position - position4;
			if (num7 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofDist (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span4 = range4.GetSpan();
			int num8 = ProtocolParser.WriteUInt32((uint)num7, span4, 0);
			if (num8 < 3)
			{
				span4[num8 - 1] |= 128;
				while (num8 < 2)
				{
					span4[num8++] = 128;
				}
				span4[2] = 0;
			}
		}
		if (instance.camDofFocalSize != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range5 = stream.GetRange(3);
			int position5 = stream.Position;
			DemoShotFloatTrack.Serialize(stream, instance.camDofFocalSize);
			int num9 = stream.Position - position5;
			if (num9 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofFocalSize (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span5 = range5.GetSpan();
			int num10 = ProtocolParser.WriteUInt32((uint)num9, span5, 0);
			if (num10 < 3)
			{
				span5[num10 - 1] |= 128;
				while (num10 < 2)
				{
					span5[num10++] = 128;
				}
				span5[2] = 0;
			}
		}
		if (instance.camDofAperture != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range6 = stream.GetRange(3);
			int position6 = stream.Position;
			DemoShotFloatTrack.Serialize(stream, instance.camDofAperture);
			int num11 = stream.Position - position6;
			if (num11 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofAperture (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span6 = range6.GetSpan();
			int num12 = ProtocolParser.WriteUInt32((uint)num11, span6, 0);
			if (num12 < 3)
			{
				span6[num12 - 1] |= 128;
				while (num12 < 2)
				{
					span6[num12++] = 128;
				}
				span6[2] = 0;
			}
		}
		if (instance.camParent != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range7 = stream.GetRange(5);
			int position7 = stream.Position;
			DemoShotParentTrack.Serialize(stream, instance.camParent);
			int val = stream.Position - position7;
			Span<byte> span7 = range7.GetSpan();
			int num13 = ProtocolParser.WriteUInt32((uint)val, span7, 0);
			if (num13 < 5)
			{
				span7[num13 - 1] |= 128;
				while (num13 < 4)
				{
					span7[num13++] = 128;
				}
				span7[4] = 0;
			}
		}
		if (instance.folderName != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.folderName);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		camPos?.InspectUids(action);
		camRot?.InspectUids(action);
		camFov?.InspectUids(action);
		camDofDist?.InspectUids(action);
		camDofFocalSize?.InspectUids(action);
		camDofAperture?.InspectUids(action);
		camParent?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShotVectorTrack : IDisposable, IPooled, IProto<DemoShotVectorTrack>, IProto
{
	[NonSerialized]
	public long trackType;

	[NonSerialized]
	public List<DemoShotVectorKeyframe> keyframes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShotVectorTrack instance)
	{
		if (instance.ShouldPool)
		{
			instance.trackType = 0L;
			if (instance.keyframes != null)
			{
				List<DemoShotVectorKeyframe> list = instance.keyframes;
				Pool.FreeUnmanaged<DemoShotVectorKeyframe>(ref list);
				instance.keyframes = list;
			}
			Pool.Free<DemoShotVectorTrack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShotVectorTrack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShotVectorTrack instance)
	{
		instance.trackType = trackType;
		if (keyframes != null)
		{
			instance.keyframes = Pool.Get<List<DemoShotVectorKeyframe>>();
			for (int i = 0; i < keyframes.Count; i++)
			{
				DemoShotVectorKeyframe item = keyframes[i];
				instance.keyframes.Add(item);
			}
		}
		else
		{
			instance.keyframes = null;
		}
	}

	public DemoShotVectorTrack Copy()
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		CopyTo(demoShotVectorTrack);
		return demoShotVectorTrack;
	}

	public static DemoShotVectorTrack Deserialize(BufferStream stream)
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		Deserialize(stream, demoShotVectorTrack, isDelta: false);
		return demoShotVectorTrack;
	}

	public static DemoShotVectorTrack DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		DeserializeLengthDelimited(stream, demoShotVectorTrack, isDelta: false);
		return demoShotVectorTrack;
	}

	public static DemoShotVectorTrack DeserializeLength(BufferStream stream, int length)
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		DeserializeLength(stream, length, demoShotVectorTrack, isDelta: false);
		return demoShotVectorTrack;
	}

	public static DemoShotVectorTrack Deserialize(byte[] buffer)
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShotVectorTrack, isDelta: false);
		return demoShotVectorTrack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShotVectorTrack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShotVectorTrack Deserialize(BufferStream stream, DemoShotVectorTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotVectorKeyframe>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotVectorKeyframe instance2 = default(DemoShotVectorKeyframe);
				DemoShotVectorKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static DemoShotVectorTrack DeserializeLengthDelimited(BufferStream stream, DemoShotVectorTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotVectorKeyframe>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotVectorKeyframe instance2 = default(DemoShotVectorKeyframe);
				DemoShotVectorKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotVectorTrack DeserializeLength(BufferStream stream, int length, DemoShotVectorTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotVectorKeyframe>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotVectorKeyframe instance2 = default(DemoShotVectorKeyframe);
				DemoShotVectorKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotVectorTrack instance, DemoShotVectorTrack previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotVectorKeyframe demoShotVectorKeyframe = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotVectorKeyframe.SerializeDelta(stream, demoShotVectorKeyframe, demoShotVectorKeyframe);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotVectorKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotVectorTrack instance)
	{
		if (instance.trackType != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotVectorKeyframe instance2 = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotVectorKeyframe.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotVectorKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (keyframes != null)
		{
			for (int i = 0; i < keyframes.Count; i++)
			{
				keyframes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public struct DemoShotVectorKeyframe : IProto<DemoShotVectorKeyframe>, IProto
{
	[NonSerialized]
	public float keyframeTime;

	[NonSerialized]
	public Vector3 keyFrameValue;

	public static void ResetToPool(DemoShotVectorKeyframe instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.keyframeTime = 0f;
		instance.keyFrameValue = default(Vector3);
	}

	public void CopyTo(DemoShotVectorKeyframe instance)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		instance.keyframeTime = keyframeTime;
		instance.keyFrameValue = keyFrameValue;
	}

	public DemoShotVectorKeyframe Copy()
	{
		DemoShotVectorKeyframe demoShotVectorKeyframe = default(DemoShotVectorKeyframe);
		CopyTo(demoShotVectorKeyframe);
		return demoShotVectorKeyframe;
	}

	public static DemoShotVectorKeyframe Deserialize(BufferStream stream)
	{
		DemoShotVectorKeyframe instance = default(DemoShotVectorKeyframe);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotVectorKeyframe DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotVectorKeyframe instance = default(DemoShotVectorKeyframe);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotVectorKeyframe DeserializeLength(BufferStream stream, int length)
	{
		DemoShotVectorKeyframe instance = default(DemoShotVectorKeyframe);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotVectorKeyframe Deserialize(byte[] buffer)
	{
		DemoShotVectorKeyframe instance = default(DemoShotVectorKeyframe);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, DemoShotVectorKeyframe previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static DemoShotVectorKeyframe Deserialize(BufferStream stream, ref DemoShotVectorKeyframe instance, bool isDelta)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.keyFrameValue, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoShotVectorKeyframe DeserializeLengthDelimited(BufferStream stream, ref DemoShotVectorKeyframe instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.keyFrameValue, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotVectorKeyframe DeserializeLength(BufferStream stream, int length, ref DemoShotVectorKeyframe instance, bool isDelta)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.keyFrameValue, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotVectorKeyframe instance, DemoShotVectorKeyframe previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.keyframeTime != previous.keyframeTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValue != previous.keyFrameValue)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.keyFrameValue, previous.keyFrameValue);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyFrameValue (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotVectorKeyframe instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (instance.keyframeTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValue != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.keyFrameValue);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyFrameValue (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShotFloatTrack : IDisposable, IPooled, IProto<DemoShotFloatTrack>, IProto
{
	[NonSerialized]
	public long trackType;

	[NonSerialized]
	public List<DemoShotFloatKeyframe> keyframes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShotFloatTrack instance)
	{
		if (instance.ShouldPool)
		{
			instance.trackType = 0L;
			if (instance.keyframes != null)
			{
				List<DemoShotFloatKeyframe> list = instance.keyframes;
				Pool.FreeUnmanaged<DemoShotFloatKeyframe>(ref list);
				instance.keyframes = list;
			}
			Pool.Free<DemoShotFloatTrack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShotFloatTrack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShotFloatTrack instance)
	{
		instance.trackType = trackType;
		if (keyframes != null)
		{
			instance.keyframes = Pool.Get<List<DemoShotFloatKeyframe>>();
			for (int i = 0; i < keyframes.Count; i++)
			{
				DemoShotFloatKeyframe item = keyframes[i];
				instance.keyframes.Add(item);
			}
		}
		else
		{
			instance.keyframes = null;
		}
	}

	public DemoShotFloatTrack Copy()
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		CopyTo(demoShotFloatTrack);
		return demoShotFloatTrack;
	}

	public static DemoShotFloatTrack Deserialize(BufferStream stream)
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		Deserialize(stream, demoShotFloatTrack, isDelta: false);
		return demoShotFloatTrack;
	}

	public static DemoShotFloatTrack DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		DeserializeLengthDelimited(stream, demoShotFloatTrack, isDelta: false);
		return demoShotFloatTrack;
	}

	public static DemoShotFloatTrack DeserializeLength(BufferStream stream, int length)
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		DeserializeLength(stream, length, demoShotFloatTrack, isDelta: false);
		return demoShotFloatTrack;
	}

	public static DemoShotFloatTrack Deserialize(byte[] buffer)
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShotFloatTrack, isDelta: false);
		return demoShotFloatTrack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShotFloatTrack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShotFloatTrack Deserialize(BufferStream stream, DemoShotFloatTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotFloatKeyframe>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotFloatKeyframe instance2 = default(DemoShotFloatKeyframe);
				DemoShotFloatKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static DemoShotFloatTrack DeserializeLengthDelimited(BufferStream stream, DemoShotFloatTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotFloatKeyframe>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotFloatKeyframe instance2 = default(DemoShotFloatKeyframe);
				DemoShotFloatKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotFloatTrack DeserializeLength(BufferStream stream, int length, DemoShotFloatTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotFloatKeyframe>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotFloatKeyframe instance2 = default(DemoShotFloatKeyframe);
				DemoShotFloatKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotFloatTrack instance, DemoShotFloatTrack previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotFloatKeyframe demoShotFloatKeyframe = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotFloatKeyframe.SerializeDelta(stream, demoShotFloatKeyframe, demoShotFloatKeyframe);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotFloatKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotFloatTrack instance)
	{
		if (instance.trackType != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotFloatKeyframe instance2 = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotFloatKeyframe.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotFloatKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (keyframes != null)
		{
			for (int i = 0; i < keyframes.Count; i++)
			{
				keyframes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public struct DemoShotFloatKeyframe : IProto<DemoShotFloatKeyframe>, IProto
{
	[NonSerialized]
	public float keyframeTime;

	[NonSerialized]
	public float keyFrameValue;

	public static void ResetToPool(DemoShotFloatKeyframe instance)
	{
		instance.keyframeTime = 0f;
		instance.keyFrameValue = 0f;
	}

	public void CopyTo(DemoShotFloatKeyframe instance)
	{
		instance.keyframeTime = keyframeTime;
		instance.keyFrameValue = keyFrameValue;
	}

	public DemoShotFloatKeyframe Copy()
	{
		DemoShotFloatKeyframe demoShotFloatKeyframe = default(DemoShotFloatKeyframe);
		CopyTo(demoShotFloatKeyframe);
		return demoShotFloatKeyframe;
	}

	public static DemoShotFloatKeyframe Deserialize(BufferStream stream)
	{
		DemoShotFloatKeyframe instance = default(DemoShotFloatKeyframe);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotFloatKeyframe DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotFloatKeyframe instance = default(DemoShotFloatKeyframe);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotFloatKeyframe DeserializeLength(BufferStream stream, int length)
	{
		DemoShotFloatKeyframe instance = default(DemoShotFloatKeyframe);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotFloatKeyframe Deserialize(byte[] buffer)
	{
		DemoShotFloatKeyframe instance = default(DemoShotFloatKeyframe);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, DemoShotFloatKeyframe previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static DemoShotFloatKeyframe Deserialize(BufferStream stream, ref DemoShotFloatKeyframe instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValue = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoShotFloatKeyframe DeserializeLengthDelimited(BufferStream stream, ref DemoShotFloatKeyframe instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValue = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotFloatKeyframe DeserializeLength(BufferStream stream, int length, ref DemoShotFloatKeyframe instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValue = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotFloatKeyframe instance, DemoShotFloatKeyframe previous)
	{
		if (instance.keyframeTime != previous.keyframeTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValue != previous.keyFrameValue)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValue);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotFloatKeyframe instance)
	{
		if (instance.keyframeTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValue != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValue);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShotQuaternionTrack : IDisposable, IPooled, IProto<DemoShotQuaternionTrack>, IProto
{
	[NonSerialized]
	public long trackType;

	[NonSerialized]
	public List<DemoShotQuaternionKeyframe> keyframes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShotQuaternionTrack instance)
	{
		if (instance.ShouldPool)
		{
			instance.trackType = 0L;
			if (instance.keyframes != null)
			{
				List<DemoShotQuaternionKeyframe> list = instance.keyframes;
				Pool.FreeUnmanaged<DemoShotQuaternionKeyframe>(ref list);
				instance.keyframes = list;
			}
			Pool.Free<DemoShotQuaternionTrack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShotQuaternionTrack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShotQuaternionTrack instance)
	{
		instance.trackType = trackType;
		if (keyframes != null)
		{
			instance.keyframes = Pool.Get<List<DemoShotQuaternionKeyframe>>();
			for (int i = 0; i < keyframes.Count; i++)
			{
				DemoShotQuaternionKeyframe item = keyframes[i];
				instance.keyframes.Add(item);
			}
		}
		else
		{
			instance.keyframes = null;
		}
	}

	public DemoShotQuaternionTrack Copy()
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		CopyTo(demoShotQuaternionTrack);
		return demoShotQuaternionTrack;
	}

	public static DemoShotQuaternionTrack Deserialize(BufferStream stream)
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		Deserialize(stream, demoShotQuaternionTrack, isDelta: false);
		return demoShotQuaternionTrack;
	}

	public static DemoShotQuaternionTrack DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		DeserializeLengthDelimited(stream, demoShotQuaternionTrack, isDelta: false);
		return demoShotQuaternionTrack;
	}

	public static DemoShotQuaternionTrack DeserializeLength(BufferStream stream, int length)
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		DeserializeLength(stream, length, demoShotQuaternionTrack, isDelta: false);
		return demoShotQuaternionTrack;
	}

	public static DemoShotQuaternionTrack Deserialize(byte[] buffer)
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShotQuaternionTrack, isDelta: false);
		return demoShotQuaternionTrack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShotQuaternionTrack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShotQuaternionTrack Deserialize(BufferStream stream, DemoShotQuaternionTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotQuaternionKeyframe>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotQuaternionKeyframe instance2 = default(DemoShotQuaternionKeyframe);
				DemoShotQuaternionKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static DemoShotQuaternionTrack DeserializeLengthDelimited(BufferStream stream, DemoShotQuaternionTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotQuaternionKeyframe>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotQuaternionKeyframe instance2 = default(DemoShotQuaternionKeyframe);
				DemoShotQuaternionKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotQuaternionTrack DeserializeLength(BufferStream stream, int length, DemoShotQuaternionTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotQuaternionKeyframe>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotQuaternionKeyframe instance2 = default(DemoShotQuaternionKeyframe);
				DemoShotQuaternionKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotQuaternionTrack instance, DemoShotQuaternionTrack previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotQuaternionKeyframe demoShotQuaternionKeyframe = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotQuaternionKeyframe.SerializeDelta(stream, demoShotQuaternionKeyframe, demoShotQuaternionKeyframe);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotQuaternionKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotQuaternionTrack instance)
	{
		if (instance.trackType != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotQuaternionKeyframe instance2 = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotQuaternionKeyframe.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotQuaternionKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (keyframes != null)
		{
			for (int i = 0; i < keyframes.Count; i++)
			{
				keyframes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public struct DemoShotQuaternionKeyframe : IProto<DemoShotQuaternionKeyframe>, IProto
{
	[NonSerialized]
	public float keyframeTime;

	[NonSerialized]
	public float keyFrameValueX;

	[NonSerialized]
	public float keyFrameValueY;

	[NonSerialized]
	public float keyFrameValueZ;

	[NonSerialized]
	public float keyFrameValueW;

	public static void ResetToPool(DemoShotQuaternionKeyframe instance)
	{
		instance.keyframeTime = 0f;
		instance.keyFrameValueX = 0f;
		instance.keyFrameValueY = 0f;
		instance.keyFrameValueZ = 0f;
		instance.keyFrameValueW = 0f;
	}

	public void CopyTo(DemoShotQuaternionKeyframe instance)
	{
		instance.keyframeTime = keyframeTime;
		instance.keyFrameValueX = keyFrameValueX;
		instance.keyFrameValueY = keyFrameValueY;
		instance.keyFrameValueZ = keyFrameValueZ;
		instance.keyFrameValueW = keyFrameValueW;
	}

	public DemoShotQuaternionKeyframe Copy()
	{
		DemoShotQuaternionKeyframe demoShotQuaternionKeyframe = default(DemoShotQuaternionKeyframe);
		CopyTo(demoShotQuaternionKeyframe);
		return demoShotQuaternionKeyframe;
	}

	public static DemoShotQuaternionKeyframe Deserialize(BufferStream stream)
	{
		DemoShotQuaternionKeyframe instance = default(DemoShotQuaternionKeyframe);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotQuaternionKeyframe DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotQuaternionKeyframe instance = default(DemoShotQuaternionKeyframe);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotQuaternionKeyframe DeserializeLength(BufferStream stream, int length)
	{
		DemoShotQuaternionKeyframe instance = default(DemoShotQuaternionKeyframe);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotQuaternionKeyframe Deserialize(byte[] buffer)
	{
		DemoShotQuaternionKeyframe instance = default(DemoShotQuaternionKeyframe);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, DemoShotQuaternionKeyframe previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static DemoShotQuaternionKeyframe Deserialize(BufferStream stream, ref DemoShotQuaternionKeyframe instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValueX = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.keyFrameValueY = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.keyFrameValueZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.keyFrameValueW = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoShotQuaternionKeyframe DeserializeLengthDelimited(BufferStream stream, ref DemoShotQuaternionKeyframe instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValueX = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.keyFrameValueY = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.keyFrameValueZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.keyFrameValueW = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotQuaternionKeyframe DeserializeLength(BufferStream stream, int length, ref DemoShotQuaternionKeyframe instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValueX = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.keyFrameValueY = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.keyFrameValueZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.keyFrameValueW = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotQuaternionKeyframe instance, DemoShotQuaternionKeyframe previous)
	{
		if (instance.keyframeTime != previous.keyframeTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValueX != previous.keyFrameValueX)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueX);
		}
		if (instance.keyFrameValueY != previous.keyFrameValueY)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueY);
		}
		if (instance.keyFrameValueZ != previous.keyFrameValueZ)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueZ);
		}
		if (instance.keyFrameValueW != previous.keyFrameValueW)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueW);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotQuaternionKeyframe instance)
	{
		if (instance.keyframeTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValueX != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueX);
		}
		if (instance.keyFrameValueY != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueY);
		}
		if (instance.keyFrameValueZ != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueZ);
		}
		if (instance.keyFrameValueW != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueW);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShotParentTrack : IDisposable, IPooled, IProto<DemoShotParentTrack>, IProto
{
	[NonSerialized]
	public ulong parentId;

	[NonSerialized]
	public List<DemoShotParentKeyframe> keyframes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShotParentTrack instance)
	{
		if (instance.ShouldPool)
		{
			instance.parentId = 0uL;
			if (instance.keyframes != null)
			{
				List<DemoShotParentKeyframe> list = instance.keyframes;
				Pool.FreeUnmanaged<DemoShotParentKeyframe>(ref list);
				instance.keyframes = list;
			}
			Pool.Free<DemoShotParentTrack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShotParentTrack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShotParentTrack instance)
	{
		instance.parentId = parentId;
		if (keyframes != null)
		{
			instance.keyframes = Pool.Get<List<DemoShotParentKeyframe>>();
			for (int i = 0; i < keyframes.Count; i++)
			{
				DemoShotParentKeyframe item = keyframes[i];
				instance.keyframes.Add(item);
			}
		}
		else
		{
			instance.keyframes = null;
		}
	}

	public DemoShotParentTrack Copy()
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		CopyTo(demoShotParentTrack);
		return demoShotParentTrack;
	}

	public static DemoShotParentTrack Deserialize(BufferStream stream)
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		Deserialize(stream, demoShotParentTrack, isDelta: false);
		return demoShotParentTrack;
	}

	public static DemoShotParentTrack DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		DeserializeLengthDelimited(stream, demoShotParentTrack, isDelta: false);
		return demoShotParentTrack;
	}

	public static DemoShotParentTrack DeserializeLength(BufferStream stream, int length)
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		DeserializeLength(stream, length, demoShotParentTrack, isDelta: false);
		return demoShotParentTrack;
	}

	public static DemoShotParentTrack Deserialize(byte[] buffer)
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShotParentTrack, isDelta: false);
		return demoShotParentTrack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShotParentTrack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShotParentTrack Deserialize(BufferStream stream, DemoShotParentTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotParentKeyframe>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotParentKeyframe instance2 = default(DemoShotParentKeyframe);
				DemoShotParentKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static DemoShotParentTrack DeserializeLengthDelimited(BufferStream stream, DemoShotParentTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotParentKeyframe>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotParentKeyframe instance2 = default(DemoShotParentKeyframe);
				DemoShotParentKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotParentTrack DeserializeLength(BufferStream stream, int length, DemoShotParentTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotParentKeyframe>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotParentKeyframe instance2 = default(DemoShotParentKeyframe);
				DemoShotParentKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotParentTrack instance, DemoShotParentTrack previous)
	{
		if (instance.parentId != previous.parentId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentId);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotParentKeyframe demoShotParentKeyframe = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			DemoShotParentKeyframe.SerializeDelta(stream, demoShotParentKeyframe, demoShotParentKeyframe);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, DemoShotParentTrack instance)
	{
		if (instance.parentId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentId);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotParentKeyframe instance2 = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			DemoShotParentKeyframe.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (keyframes != null)
		{
			for (int i = 0; i < keyframes.Count; i++)
			{
				keyframes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public struct DemoShotParentKeyframe : IProto<DemoShotParentKeyframe>, IProto
{
	[NonSerialized]
	public float keyframeTime;

	[NonSerialized]
	public NetworkableId keyFrameParentId;

	[NonSerialized]
	public string keyFrameParentName;

	public static void ResetToPool(DemoShotParentKeyframe instance)
	{
		instance.keyframeTime = 0f;
		instance.keyFrameParentId = default(NetworkableId);
		instance.keyFrameParentName = string.Empty;
	}

	public void CopyTo(DemoShotParentKeyframe instance)
	{
		instance.keyframeTime = keyframeTime;
		instance.keyFrameParentId = keyFrameParentId;
		instance.keyFrameParentName = keyFrameParentName;
	}

	public DemoShotParentKeyframe Copy()
	{
		DemoShotParentKeyframe demoShotParentKeyframe = default(DemoShotParentKeyframe);
		CopyTo(demoShotParentKeyframe);
		return demoShotParentKeyframe;
	}

	public static DemoShotParentKeyframe Deserialize(BufferStream stream)
	{
		DemoShotParentKeyframe instance = default(DemoShotParentKeyframe);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotParentKeyframe DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotParentKeyframe instance = default(DemoShotParentKeyframe);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotParentKeyframe DeserializeLength(BufferStream stream, int length)
	{
		DemoShotParentKeyframe instance = default(DemoShotParentKeyframe);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotParentKeyframe Deserialize(byte[] buffer)
	{
		DemoShotParentKeyframe instance = default(DemoShotParentKeyframe);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, DemoShotParentKeyframe previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static DemoShotParentKeyframe Deserialize(BufferStream stream, ref DemoShotParentKeyframe instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.keyFrameParentId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.keyFrameParentName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoShotParentKeyframe DeserializeLengthDelimited(BufferStream stream, ref DemoShotParentKeyframe instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.keyFrameParentId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.keyFrameParentName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotParentKeyframe DeserializeLength(BufferStream stream, int length, ref DemoShotParentKeyframe instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.keyFrameParentId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.keyFrameParentName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotParentKeyframe instance, DemoShotParentKeyframe previous)
	{
		if (instance.keyframeTime != previous.keyframeTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.keyFrameParentId.Value);
		if (instance.keyFrameParentName != previous.keyFrameParentName)
		{
			if (instance.keyFrameParentName == null)
			{
				throw new ArgumentNullException("keyFrameParentName", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.keyFrameParentName);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotParentKeyframe instance)
	{
		if (instance.keyframeTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameParentId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.keyFrameParentId.Value);
		}
		if (instance.keyFrameParentName == null)
		{
			throw new ArgumentNullException("keyFrameParentName", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.keyFrameParentName);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref keyFrameParentId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CopyPasteEntityInfo : IDisposable, IPooled, IProto<CopyPasteEntityInfo>, IProto
{
	[NonSerialized]
	public List<Entity> entities;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CopyPasteEntityInfo instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				if (instance.entities[i] != null)
				{
					instance.entities[i].ResetToPool();
					instance.entities[i] = null;
				}
			}
			List<Entity> list = instance.entities;
			Pool.Free<Entity>(ref list, false);
			instance.entities = list;
		}
		Pool.Free<CopyPasteEntityInfo>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CopyPasteEntityInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CopyPasteEntityInfo instance)
	{
		if (entities != null)
		{
			instance.entities = Pool.Get<List<Entity>>();
			for (int i = 0; i < entities.Count; i++)
			{
				Entity item = entities[i].Copy();
				instance.entities.Add(item);
			}
		}
		else
		{
			instance.entities = null;
		}
	}

	public CopyPasteEntityInfo Copy()
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		CopyTo(copyPasteEntityInfo);
		return copyPasteEntityInfo;
	}

	public static CopyPasteEntityInfo Deserialize(BufferStream stream)
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		Deserialize(stream, copyPasteEntityInfo, isDelta: false);
		return copyPasteEntityInfo;
	}

	public static CopyPasteEntityInfo DeserializeLengthDelimited(BufferStream stream)
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		DeserializeLengthDelimited(stream, copyPasteEntityInfo, isDelta: false);
		return copyPasteEntityInfo;
	}

	public static CopyPasteEntityInfo DeserializeLength(BufferStream stream, int length)
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		DeserializeLength(stream, length, copyPasteEntityInfo, isDelta: false);
		return copyPasteEntityInfo;
	}

	public static CopyPasteEntityInfo Deserialize(byte[] buffer)
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, copyPasteEntityInfo, isDelta: false);
		return copyPasteEntityInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CopyPasteEntityInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CopyPasteEntityInfo Deserialize(BufferStream stream, CopyPasteEntityInfo instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<Entity>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CopyPasteEntityInfo DeserializeLengthDelimited(BufferStream stream, CopyPasteEntityInfo instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<Entity>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CopyPasteEntityInfo DeserializeLength(BufferStream stream, int length, CopyPasteEntityInfo instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<Entity>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CopyPasteEntityInfo instance, CopyPasteEntityInfo previous)
	{
		if (instance.entities == null)
		{
			return;
		}
		for (int i = 0; i < instance.entities.Count; i++)
		{
			Entity entity = instance.entities[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entity.SerializeDelta(stream, entity, entity);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, CopyPasteEntityInfo instance)
	{
		if (instance.entities == null)
		{
			return;
		}
		for (int i = 0; i < instance.entities.Count; i++)
		{
			Entity instance2 = instance.entities[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entity.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entities != null)
		{
			for (int i = 0; i < entities.Count; i++)
			{
				entities[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PasteRequest : IDisposable, IPooled, IProto<PasteRequest>, IProto
{
	[NonSerialized]
	public CopyPasteEntityInfo pasteData;

	[NonSerialized]
	public Vector3 origin;

	[NonSerialized]
	public Vector3 playerRotation;

	[NonSerialized]
	public Vector3 heightOffset;

	[NonSerialized]
	public bool resources;

	[NonSerialized]
	public bool npcs;

	[NonSerialized]
	public bool vehicles;

	[NonSerialized]
	public bool deployables;

	[NonSerialized]
	public bool foundationsOnly;

	[NonSerialized]
	public bool buildingBlocksOnly;

	[NonSerialized]
	public bool snapToTerrain;

	[NonSerialized]
	public bool players;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PasteRequest instance)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			if (instance.pasteData != null)
			{
				instance.pasteData.ResetToPool();
				instance.pasteData = null;
			}
			instance.origin = default(Vector3);
			instance.playerRotation = default(Vector3);
			instance.heightOffset = default(Vector3);
			instance.resources = false;
			instance.npcs = false;
			instance.vehicles = false;
			instance.deployables = false;
			instance.foundationsOnly = false;
			instance.buildingBlocksOnly = false;
			instance.snapToTerrain = false;
			instance.players = false;
			Pool.Free<PasteRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PasteRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PasteRequest instance)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (pasteData != null)
		{
			if (instance.pasteData == null)
			{
				instance.pasteData = pasteData.Copy();
			}
			else
			{
				pasteData.CopyTo(instance.pasteData);
			}
		}
		else
		{
			instance.pasteData = null;
		}
		instance.origin = origin;
		instance.playerRotation = playerRotation;
		instance.heightOffset = heightOffset;
		instance.resources = resources;
		instance.npcs = npcs;
		instance.vehicles = vehicles;
		instance.deployables = deployables;
		instance.foundationsOnly = foundationsOnly;
		instance.buildingBlocksOnly = buildingBlocksOnly;
		instance.snapToTerrain = snapToTerrain;
		instance.players = players;
	}

	public PasteRequest Copy()
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		CopyTo(pasteRequest);
		return pasteRequest;
	}

	public static PasteRequest Deserialize(BufferStream stream)
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		Deserialize(stream, pasteRequest, isDelta: false);
		return pasteRequest;
	}

	public static PasteRequest DeserializeLengthDelimited(BufferStream stream)
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		DeserializeLengthDelimited(stream, pasteRequest, isDelta: false);
		return pasteRequest;
	}

	public static PasteRequest DeserializeLength(BufferStream stream, int length)
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		DeserializeLength(stream, length, pasteRequest, isDelta: false);
		return pasteRequest;
	}

	public static PasteRequest Deserialize(byte[] buffer)
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pasteRequest, isDelta: false);
		return pasteRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PasteRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PasteRequest Deserialize(BufferStream stream, PasteRequest instance, bool isDelta)
	{
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.pasteData == null)
				{
					instance.pasteData = CopyPasteEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					CopyPasteEntityInfo.DeserializeLengthDelimited(stream, instance.pasteData, isDelta);
				}
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerRotation, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heightOffset, isDelta);
				continue;
			case 80:
				instance.resources = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.npcs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.vehicles = ProtocolParser.ReadBool(stream);
				continue;
			case 104:
				instance.deployables = ProtocolParser.ReadBool(stream);
				continue;
			case 112:
				instance.foundationsOnly = ProtocolParser.ReadBool(stream);
				continue;
			case 120:
				instance.buildingBlocksOnly = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.snapToTerrain = ProtocolParser.ReadBool(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.players = ProtocolParser.ReadBool(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static PasteRequest DeserializeLengthDelimited(BufferStream stream, PasteRequest instance, bool isDelta)
	{
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.pasteData == null)
				{
					instance.pasteData = CopyPasteEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					CopyPasteEntityInfo.DeserializeLengthDelimited(stream, instance.pasteData, isDelta);
				}
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerRotation, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heightOffset, isDelta);
				continue;
			case 80:
				instance.resources = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.npcs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.vehicles = ProtocolParser.ReadBool(stream);
				continue;
			case 104:
				instance.deployables = ProtocolParser.ReadBool(stream);
				continue;
			case 112:
				instance.foundationsOnly = ProtocolParser.ReadBool(stream);
				continue;
			case 120:
				instance.buildingBlocksOnly = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.snapToTerrain = ProtocolParser.ReadBool(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.players = ProtocolParser.ReadBool(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PasteRequest DeserializeLength(BufferStream stream, int length, PasteRequest instance, bool isDelta)
	{
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.pasteData == null)
				{
					instance.pasteData = CopyPasteEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					CopyPasteEntityInfo.DeserializeLengthDelimited(stream, instance.pasteData, isDelta);
				}
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerRotation, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heightOffset, isDelta);
				continue;
			case 80:
				instance.resources = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.npcs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.vehicles = ProtocolParser.ReadBool(stream);
				continue;
			case 104:
				instance.deployables = ProtocolParser.ReadBool(stream);
				continue;
			case 112:
				instance.foundationsOnly = ProtocolParser.ReadBool(stream);
				continue;
			case 120:
				instance.buildingBlocksOnly = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.snapToTerrain = ProtocolParser.ReadBool(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.players = ProtocolParser.ReadBool(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PasteRequest instance, PasteRequest previous)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pasteData != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CopyPasteEntityInfo.SerializeDelta(stream, instance.pasteData, previous.pasteData);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.origin != previous.origin)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.origin, previous.origin);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.playerRotation != previous.playerRotation)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.playerRotation, previous.playerRotation);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerRotation (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.heightOffset != previous.heightOffset)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.heightOffset, previous.heightOffset);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heightOffset (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteBool(stream, instance.resources);
		stream.WriteByte(88);
		ProtocolParser.WriteBool(stream, instance.npcs);
		stream.WriteByte(96);
		ProtocolParser.WriteBool(stream, instance.vehicles);
		stream.WriteByte(104);
		ProtocolParser.WriteBool(stream, instance.deployables);
		stream.WriteByte(112);
		ProtocolParser.WriteBool(stream, instance.foundationsOnly);
		stream.WriteByte(120);
		ProtocolParser.WriteBool(stream, instance.buildingBlocksOnly);
		stream.WriteByte(128);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.snapToTerrain);
		stream.WriteByte(136);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.players);
	}

	public static void Serialize(BufferStream stream, PasteRequest instance)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pasteData != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CopyPasteEntityInfo.Serialize(stream, instance.pasteData);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.origin != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.origin);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.playerRotation != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.playerRotation);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerRotation (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.heightOffset != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.heightOffset);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heightOffset (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.resources)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteBool(stream, instance.resources);
		}
		if (instance.npcs)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteBool(stream, instance.npcs);
		}
		if (instance.vehicles)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.vehicles);
		}
		if (instance.deployables)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteBool(stream, instance.deployables);
		}
		if (instance.foundationsOnly)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteBool(stream, instance.foundationsOnly);
		}
		if (instance.buildingBlocksOnly)
		{
			stream.WriteByte(120);
			ProtocolParser.WriteBool(stream, instance.buildingBlocksOnly);
		}
		if (instance.snapToTerrain)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.snapToTerrain);
		}
		if (instance.players)
		{
			stream.WriteByte(136);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.players);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		pasteData?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public struct Half3 : IProto<Half3>, IProto, IEquatable<Half3>
{
	[NonSerialized]
	public uint x;

	[NonSerialized]
	public uint y;

	[NonSerialized]
	public uint z;

	public static void ResetToPool(Half3 instance)
	{
		instance.x = 0u;
		instance.y = 0u;
		instance.z = 0u;
	}

	public void CopyTo(Half3 instance)
	{
		instance.x = x;
		instance.y = y;
		instance.z = z;
	}

	public Half3 Copy()
	{
		Half3 half = default(Half3);
		CopyTo(half);
		return half;
	}

	public static Half3 Deserialize(BufferStream stream)
	{
		Half3 instance = default(Half3);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static Half3 DeserializeLengthDelimited(BufferStream stream)
	{
		Half3 instance = default(Half3);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static Half3 DeserializeLength(BufferStream stream, int length)
	{
		Half3 instance = default(Half3);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static Half3 Deserialize(byte[] buffer)
	{
		Half3 instance = default(Half3);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, Half3 previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static Half3 Deserialize(BufferStream stream, ref Half3 instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0u;
			instance.y = 0u;
			instance.z = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.x = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.y = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.z = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Half3 DeserializeLengthDelimited(BufferStream stream, ref Half3 instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0u;
			instance.y = 0u;
			instance.z = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.x = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.y = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.z = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Half3 DeserializeLength(BufferStream stream, int length, ref Half3 instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0u;
			instance.y = 0u;
			instance.z = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.x = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.y = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.z = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Half3 instance, Half3 previous)
	{
		if (instance.x != previous.x)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.y);
		}
		if (instance.z != previous.z)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.z);
		}
	}

	public static void Serialize(BufferStream stream, Half3 instance)
	{
		if (instance.x != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.x);
		}
		if (instance.y != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.y);
		}
		if (instance.z != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.z);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}

	public bool Equals(Half3 other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is Half3)
		{
			return Equals((Half3)obj);
		}
		return false;
	}

	public static bool operator ==(Half3 a, Half3 b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(Half3 a, Half3 b)
	{
		return !a.Equals(b);
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Approval : IDisposable, IPooled, IProto<Approval>, IProto
{
	[NonSerialized]
	public string level;

	[NonSerialized]
	public string hostname;

	[NonSerialized]
	public bool modded;

	[NonSerialized]
	public bool official;

	[NonSerialized]
	public ulong steamid;

	[NonSerialized]
	public uint ipaddress;

	[NonSerialized]
	public int port;

	[NonSerialized]
	public uint levelSeed;

	[NonSerialized]
	public uint levelSize;

	[NonSerialized]
	public string checksum;

	[NonSerialized]
	public uint encryption;

	[NonSerialized]
	public string levelUrl;

	[NonSerialized]
	public bool levelTransfer;

	[NonSerialized]
	public string version;

	[NonSerialized]
	public string levelConfig;

	[NonSerialized]
	public bool nexus;

	[NonSerialized]
	public string nexusEndpoint;

	[NonSerialized]
	public int nexusId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Approval instance)
	{
		if (instance.ShouldPool)
		{
			instance.level = string.Empty;
			instance.hostname = string.Empty;
			instance.modded = false;
			instance.official = false;
			instance.steamid = 0uL;
			instance.ipaddress = 0u;
			instance.port = 0;
			instance.levelSeed = 0u;
			instance.levelSize = 0u;
			instance.checksum = string.Empty;
			instance.encryption = 0u;
			instance.levelUrl = string.Empty;
			instance.levelTransfer = false;
			instance.version = string.Empty;
			instance.levelConfig = string.Empty;
			instance.nexus = false;
			instance.nexusEndpoint = string.Empty;
			instance.nexusId = 0;
			Pool.Free<Approval>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Approval with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Approval instance)
	{
		instance.level = level;
		instance.hostname = hostname;
		instance.modded = modded;
		instance.official = official;
		instance.steamid = steamid;
		instance.ipaddress = ipaddress;
		instance.port = port;
		instance.levelSeed = levelSeed;
		instance.levelSize = levelSize;
		instance.checksum = checksum;
		instance.encryption = encryption;
		instance.levelUrl = levelUrl;
		instance.levelTransfer = levelTransfer;
		instance.version = version;
		instance.levelConfig = levelConfig;
		instance.nexus = nexus;
		instance.nexusEndpoint = nexusEndpoint;
		instance.nexusId = nexusId;
	}

	public Approval Copy()
	{
		Approval approval = Pool.Get<Approval>();
		CopyTo(approval);
		return approval;
	}

	public static Approval Deserialize(BufferStream stream)
	{
		Approval approval = Pool.Get<Approval>();
		Deserialize(stream, approval, isDelta: false);
		return approval;
	}

	public static Approval DeserializeLengthDelimited(BufferStream stream)
	{
		Approval approval = Pool.Get<Approval>();
		DeserializeLengthDelimited(stream, approval, isDelta: false);
		return approval;
	}

	public static Approval DeserializeLength(BufferStream stream, int length)
	{
		Approval approval = Pool.Get<Approval>();
		DeserializeLength(stream, length, approval, isDelta: false);
		return approval;
	}

	public static Approval Deserialize(byte[] buffer)
	{
		Approval approval = Pool.Get<Approval>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, approval, isDelta: false);
		return approval;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Approval previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Approval Deserialize(BufferStream stream, Approval instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.hostname = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.modded = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.official = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.ipaddress = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.port = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 90:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.encryption = ProtocolParser.ReadUInt32(stream);
				continue;
			case 106:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.levelTransfer = ProtocolParser.ReadBool(stream);
				continue;
			case 122:
				instance.version = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.levelConfig = ProtocolParser.ReadString(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexus = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.nexusEndpoint = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static Approval DeserializeLengthDelimited(BufferStream stream, Approval instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.hostname = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.modded = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.official = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.ipaddress = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.port = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 90:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.encryption = ProtocolParser.ReadUInt32(stream);
				continue;
			case 106:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.levelTransfer = ProtocolParser.ReadBool(stream);
				continue;
			case 122:
				instance.version = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.levelConfig = ProtocolParser.ReadString(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexus = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.nexusEndpoint = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Approval DeserializeLength(BufferStream stream, int length, Approval instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.hostname = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.modded = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.official = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.ipaddress = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.port = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 90:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.encryption = ProtocolParser.ReadUInt32(stream);
				continue;
			case 106:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.levelTransfer = ProtocolParser.ReadBool(stream);
				continue;
			case 122:
				instance.version = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.levelConfig = ProtocolParser.ReadString(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexus = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.nexusEndpoint = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Approval instance, Approval previous)
	{
		if (instance.level != previous.level)
		{
			if (instance.level == null)
			{
				throw new ArgumentNullException("level", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.level);
		}
		if (instance.hostname != null && instance.hostname != previous.hostname)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.hostname);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.modded);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.official);
		if (instance.steamid != previous.steamid)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.steamid);
		}
		if (instance.ipaddress != previous.ipaddress)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.ipaddress);
		}
		if (instance.port != previous.port)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.port);
		}
		if (instance.levelSeed != previous.levelSeed)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.levelSeed);
		}
		if (instance.levelSize != previous.levelSize)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.levelSize);
		}
		if (instance.checksum != null && instance.checksum != previous.checksum)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.checksum);
		}
		if (instance.encryption != previous.encryption)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.encryption);
		}
		if (instance.levelUrl != null && instance.levelUrl != previous.levelUrl)
		{
			stream.WriteByte(106);
			ProtocolParser.WriteString(stream, instance.levelUrl);
		}
		stream.WriteByte(112);
		ProtocolParser.WriteBool(stream, instance.levelTransfer);
		if (instance.version != null && instance.version != previous.version)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.version);
		}
		if (instance.levelConfig != null && instance.levelConfig != previous.levelConfig)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.levelConfig);
		}
		stream.WriteByte(136);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.nexus);
		if (instance.nexusEndpoint != null && instance.nexusEndpoint != previous.nexusEndpoint)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.nexusEndpoint);
		}
		if (instance.nexusId != previous.nexusId)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nexusId);
		}
	}

	public static void Serialize(BufferStream stream, Approval instance)
	{
		if (instance.level == null)
		{
			throw new ArgumentNullException("level", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.level);
		if (instance.hostname != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.hostname);
		}
		if (instance.modded)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.modded);
		}
		if (instance.official)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.official);
		}
		if (instance.steamid != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.steamid);
		}
		if (instance.ipaddress != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.ipaddress);
		}
		if (instance.port != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.port);
		}
		if (instance.levelSeed != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.levelSeed);
		}
		if (instance.levelSize != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.levelSize);
		}
		if (instance.checksum != null)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.checksum);
		}
		if (instance.encryption != 0)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.encryption);
		}
		if (instance.levelUrl != null)
		{
			stream.WriteByte(106);
			ProtocolParser.WriteString(stream, instance.levelUrl);
		}
		if (instance.levelTransfer)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteBool(stream, instance.levelTransfer);
		}
		if (instance.version != null)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.version);
		}
		if (instance.levelConfig != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.levelConfig);
		}
		if (instance.nexus)
		{
			stream.WriteByte(136);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.nexus);
		}
		if (instance.nexusEndpoint != null)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.nexusEndpoint);
		}
		if (instance.nexusId != 0)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nexusId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class UpdateItemContainer : IDisposable, IPooled, IProto<UpdateItemContainer>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public List<ItemContainer> container;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(UpdateItemContainer instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.type = 0;
		if (instance.container != null)
		{
			for (int i = 0; i < instance.container.Count; i++)
			{
				if (instance.container[i] != null)
				{
					instance.container[i].ResetToPool();
					instance.container[i] = null;
				}
			}
			List<ItemContainer> list = instance.container;
			Pool.Free<ItemContainer>(ref list, false);
			instance.container = list;
		}
		Pool.Free<UpdateItemContainer>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose UpdateItemContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(UpdateItemContainer instance)
	{
		instance.type = type;
		if (container != null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
			for (int i = 0; i < container.Count; i++)
			{
				ItemContainer item = container[i].Copy();
				instance.container.Add(item);
			}
		}
		else
		{
			instance.container = null;
		}
	}

	public UpdateItemContainer Copy()
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		CopyTo(updateItemContainer);
		return updateItemContainer;
	}

	public static UpdateItemContainer Deserialize(BufferStream stream)
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		Deserialize(stream, updateItemContainer, isDelta: false);
		return updateItemContainer;
	}

	public static UpdateItemContainer DeserializeLengthDelimited(BufferStream stream)
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		DeserializeLengthDelimited(stream, updateItemContainer, isDelta: false);
		return updateItemContainer;
	}

	public static UpdateItemContainer DeserializeLength(BufferStream stream, int length)
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		DeserializeLength(stream, length, updateItemContainer, isDelta: false);
		return updateItemContainer;
	}

	public static UpdateItemContainer Deserialize(byte[] buffer)
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, updateItemContainer, isDelta: false);
		return updateItemContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, UpdateItemContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static UpdateItemContainer Deserialize(BufferStream stream, UpdateItemContainer instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static UpdateItemContainer DeserializeLengthDelimited(BufferStream stream, UpdateItemContainer instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static UpdateItemContainer DeserializeLength(BufferStream stream, int length, UpdateItemContainer instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, UpdateItemContainer instance, UpdateItemContainer previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.container == null)
		{
			return;
		}
		for (int i = 0; i < instance.container.Count; i++)
		{
			ItemContainer itemContainer = instance.container[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, itemContainer, itemContainer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, UpdateItemContainer instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.container == null)
		{
			return;
		}
		for (int i = 0; i < instance.container.Count; i++)
		{
			ItemContainer instance2 = instance.container[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (container != null)
		{
			for (int i = 0; i < container.Count; i++)
			{
				container[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerUpdateLoot : IDisposable, IPooled, IProto<PlayerUpdateLoot>, IProto
{
	[NonSerialized]
	public ItemId itemID;

	[NonSerialized]
	public NetworkableId entityID;

	[NonSerialized]
	public List<ItemContainer> containers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerUpdateLoot instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.itemID = default(ItemId);
		instance.entityID = default(NetworkableId);
		if (instance.containers != null)
		{
			for (int i = 0; i < instance.containers.Count; i++)
			{
				if (instance.containers[i] != null)
				{
					instance.containers[i].ResetToPool();
					instance.containers[i] = null;
				}
			}
			List<ItemContainer> list = instance.containers;
			Pool.Free<ItemContainer>(ref list, false);
			instance.containers = list;
		}
		Pool.Free<PlayerUpdateLoot>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerUpdateLoot with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerUpdateLoot instance)
	{
		instance.itemID = itemID;
		instance.entityID = entityID;
		if (containers != null)
		{
			instance.containers = Pool.Get<List<ItemContainer>>();
			for (int i = 0; i < containers.Count; i++)
			{
				ItemContainer item = containers[i].Copy();
				instance.containers.Add(item);
			}
		}
		else
		{
			instance.containers = null;
		}
	}

	public PlayerUpdateLoot Copy()
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		CopyTo(playerUpdateLoot);
		return playerUpdateLoot;
	}

	public static PlayerUpdateLoot Deserialize(BufferStream stream)
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		Deserialize(stream, playerUpdateLoot, isDelta: false);
		return playerUpdateLoot;
	}

	public static PlayerUpdateLoot DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		DeserializeLengthDelimited(stream, playerUpdateLoot, isDelta: false);
		return playerUpdateLoot;
	}

	public static PlayerUpdateLoot DeserializeLength(BufferStream stream, int length)
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		DeserializeLength(stream, length, playerUpdateLoot, isDelta: false);
		return playerUpdateLoot;
	}

	public static PlayerUpdateLoot Deserialize(byte[] buffer)
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerUpdateLoot, isDelta: false);
		return playerUpdateLoot;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerUpdateLoot previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerUpdateLoot Deserialize(BufferStream stream, PlayerUpdateLoot instance, bool isDelta)
	{
		if (!isDelta && instance.containers == null)
		{
			instance.containers = Pool.Get<List<ItemContainer>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.containers.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerUpdateLoot DeserializeLengthDelimited(BufferStream stream, PlayerUpdateLoot instance, bool isDelta)
	{
		if (!isDelta && instance.containers == null)
		{
			instance.containers = Pool.Get<List<ItemContainer>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.containers.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerUpdateLoot DeserializeLength(BufferStream stream, int length, PlayerUpdateLoot instance, bool isDelta)
	{
		if (!isDelta && instance.containers == null)
		{
			instance.containers = Pool.Get<List<ItemContainer>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.containers.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerUpdateLoot instance, PlayerUpdateLoot previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.itemID.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
		if (instance.containers == null)
		{
			return;
		}
		for (int i = 0; i < instance.containers.Count; i++)
		{
			ItemContainer itemContainer = instance.containers[i];
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, itemContainer, itemContainer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, PlayerUpdateLoot instance)
	{
		if (instance.itemID != default(ItemId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.itemID.Value);
		}
		if (instance.entityID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
		}
		if (instance.containers == null)
		{
			return;
		}
		for (int i = 0; i < instance.containers.Count; i++)
		{
			ItemContainer instance2 = instance.containers[i];
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.ItemId, ref itemID.Value);
		action(UidType.NetworkableId, ref entityID.Value);
		if (containers != null)
		{
			for (int i = 0; i < containers.Count; i++)
			{
				containers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class UpdateItem : IDisposable, IPooled, IProto<UpdateItem>, IProto
{
	[NonSerialized]
	public Item item;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(UpdateItem instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.item != null)
			{
				instance.item.ResetToPool();
				instance.item = null;
			}
			Pool.Free<UpdateItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose UpdateItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(UpdateItem instance)
	{
		if (item != null)
		{
			if (instance.item == null)
			{
				instance.item = item.Copy();
			}
			else
			{
				item.CopyTo(instance.item);
			}
		}
		else
		{
			instance.item = null;
		}
	}

	public UpdateItem Copy()
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		CopyTo(updateItem);
		return updateItem;
	}

	public static UpdateItem Deserialize(BufferStream stream)
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		Deserialize(stream, updateItem, isDelta: false);
		return updateItem;
	}

	public static UpdateItem DeserializeLengthDelimited(BufferStream stream)
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		DeserializeLengthDelimited(stream, updateItem, isDelta: false);
		return updateItem;
	}

	public static UpdateItem DeserializeLength(BufferStream stream, int length)
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		DeserializeLength(stream, length, updateItem, isDelta: false);
		return updateItem;
	}

	public static UpdateItem Deserialize(byte[] buffer)
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, updateItem, isDelta: false);
		return updateItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, UpdateItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static UpdateItem Deserialize(BufferStream stream, UpdateItem instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.item == null)
				{
					instance.item = Item.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.DeserializeLengthDelimited(stream, instance.item, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static UpdateItem DeserializeLengthDelimited(BufferStream stream, UpdateItem instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.item == null)
				{
					instance.item = Item.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.DeserializeLengthDelimited(stream, instance.item, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static UpdateItem DeserializeLength(BufferStream stream, int length, UpdateItem instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.item == null)
				{
					instance.item = Item.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.DeserializeLengthDelimited(stream, instance.item, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, UpdateItem instance, UpdateItem previous)
	{
		if (instance.item == null)
		{
			throw new ArgumentNullException("item", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		Item.SerializeDelta(stream, instance.item, previous.item);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, UpdateItem instance)
	{
		if (instance.item == null)
		{
			throw new ArgumentNullException("item", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		Item.Serialize(stream, instance.item);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		item?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TakeDamage : IDisposable, IPooled, IProto<TakeDamage>, IProto
{
	[NonSerialized]
	public float amount;

	[NonSerialized]
	public Vector3 direction;

	[NonSerialized]
	public int type;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TakeDamage instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.amount = 0f;
			instance.direction = default(Vector3);
			instance.type = 0;
			Pool.Free<TakeDamage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TakeDamage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TakeDamage instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.amount = amount;
		instance.direction = direction;
		instance.type = type;
	}

	public TakeDamage Copy()
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		CopyTo(takeDamage);
		return takeDamage;
	}

	public static TakeDamage Deserialize(BufferStream stream)
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		Deserialize(stream, takeDamage, isDelta: false);
		return takeDamage;
	}

	public static TakeDamage DeserializeLengthDelimited(BufferStream stream)
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		DeserializeLengthDelimited(stream, takeDamage, isDelta: false);
		return takeDamage;
	}

	public static TakeDamage DeserializeLength(BufferStream stream, int length)
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		DeserializeLength(stream, length, takeDamage, isDelta: false);
		return takeDamage;
	}

	public static TakeDamage Deserialize(byte[] buffer)
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, takeDamage, isDelta: false);
		return takeDamage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TakeDamage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TakeDamage Deserialize(BufferStream stream, TakeDamage instance, bool isDelta)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.amount = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.direction, isDelta);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TakeDamage DeserializeLengthDelimited(BufferStream stream, TakeDamage instance, bool isDelta)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.amount = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.direction, isDelta);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TakeDamage DeserializeLength(BufferStream stream, int length, TakeDamage instance, bool isDelta)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.amount = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.direction, isDelta);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TakeDamage instance, TakeDamage previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.amount);
		}
		if (instance.direction != previous.direction)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.direction, previous.direction);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field direction (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.type != previous.type)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
	}

	public static void Serialize(BufferStream stream, TakeDamage instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (instance.amount != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.amount);
		}
		if (instance.direction != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.direction);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field direction (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class EntityList : IDisposable, IPooled, IProto<EntityList>, IProto
{
	[NonSerialized]
	public List<Entity> entity;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EntityList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entity != null)
		{
			for (int i = 0; i < instance.entity.Count; i++)
			{
				if (instance.entity[i] != null)
				{
					instance.entity[i].ResetToPool();
					instance.entity[i] = null;
				}
			}
			List<Entity> list = instance.entity;
			Pool.Free<Entity>(ref list, false);
			instance.entity = list;
		}
		Pool.Free<EntityList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EntityList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EntityList instance)
	{
		if (entity != null)
		{
			instance.entity = Pool.Get<List<Entity>>();
			for (int i = 0; i < entity.Count; i++)
			{
				Entity item = entity[i].Copy();
				instance.entity.Add(item);
			}
		}
		else
		{
			instance.entity = null;
		}
	}

	public EntityList Copy()
	{
		EntityList entityList = Pool.Get<EntityList>();
		CopyTo(entityList);
		return entityList;
	}

	public static EntityList Deserialize(BufferStream stream)
	{
		EntityList entityList = Pool.Get<EntityList>();
		Deserialize(stream, entityList, isDelta: false);
		return entityList;
	}

	public static EntityList DeserializeLengthDelimited(BufferStream stream)
	{
		EntityList entityList = Pool.Get<EntityList>();
		DeserializeLengthDelimited(stream, entityList, isDelta: false);
		return entityList;
	}

	public static EntityList DeserializeLength(BufferStream stream, int length)
	{
		EntityList entityList = Pool.Get<EntityList>();
		DeserializeLength(stream, length, entityList, isDelta: false);
		return entityList;
	}

	public static EntityList Deserialize(byte[] buffer)
	{
		EntityList entityList = Pool.Get<EntityList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entityList, isDelta: false);
		return entityList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EntityList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EntityList Deserialize(BufferStream stream, EntityList instance, bool isDelta)
	{
		if (!isDelta && instance.entity == null)
		{
			instance.entity = Pool.Get<List<Entity>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entity.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EntityList DeserializeLengthDelimited(BufferStream stream, EntityList instance, bool isDelta)
	{
		if (!isDelta && instance.entity == null)
		{
			instance.entity = Pool.Get<List<Entity>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entity.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EntityList DeserializeLength(BufferStream stream, int length, EntityList instance, bool isDelta)
	{
		if (!isDelta && instance.entity == null)
		{
			instance.entity = Pool.Get<List<Entity>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entity.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EntityList instance, EntityList previous)
	{
		if (instance.entity == null)
		{
			return;
		}
		for (int i = 0; i < instance.entity.Count; i++)
		{
			Entity entity = instance.entity[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entity.SerializeDelta(stream, entity, entity);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, EntityList instance)
	{
		if (instance.entity == null)
		{
			return;
		}
		for (int i = 0; i < instance.entity.Count; i++)
		{
			Entity instance2 = instance.entity[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entity.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entity != null)
		{
			for (int i = 0; i < entity.Count; i++)
			{
				entity[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class CreateBuilding : IDisposable, IPooled, IProto<CreateBuilding>, IProto
{
	[NonSerialized]
	public NetworkableId entity;

	[NonSerialized]
	public uint socket;

	[NonSerialized]
	public bool onterrain;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 normal;

	[NonSerialized]
	public Ray ray;

	[NonSerialized]
	public uint blockID;

	[NonSerialized]
	public Vector3 rotation;

	[NonSerialized]
	public bool isHoldingShift;

	[NonSerialized]
	public int setToGrade;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CreateBuilding instance)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.entity = default(NetworkableId);
			instance.socket = 0u;
			instance.onterrain = false;
			instance.position = default(Vector3);
			instance.normal = default(Vector3);
			instance.ray = default(Ray);
			instance.blockID = 0u;
			instance.rotation = default(Vector3);
			instance.isHoldingShift = false;
			instance.setToGrade = 0;
			Pool.Free<CreateBuilding>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CreateBuilding with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CreateBuilding instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.entity = entity;
		instance.socket = socket;
		instance.onterrain = onterrain;
		instance.position = position;
		instance.normal = normal;
		instance.ray = ray;
		instance.blockID = blockID;
		instance.rotation = rotation;
		instance.isHoldingShift = isHoldingShift;
		instance.setToGrade = setToGrade;
	}

	public CreateBuilding Copy()
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		CopyTo(createBuilding);
		return createBuilding;
	}

	public static CreateBuilding Deserialize(BufferStream stream)
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		Deserialize(stream, createBuilding, isDelta: false);
		return createBuilding;
	}

	public static CreateBuilding DeserializeLengthDelimited(BufferStream stream)
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		DeserializeLengthDelimited(stream, createBuilding, isDelta: false);
		return createBuilding;
	}

	public static CreateBuilding DeserializeLength(BufferStream stream, int length)
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		DeserializeLength(stream, length, createBuilding, isDelta: false);
		return createBuilding;
	}

	public static CreateBuilding Deserialize(byte[] buffer)
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, createBuilding, isDelta: false);
		return createBuilding;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CreateBuilding previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CreateBuilding Deserialize(BufferStream stream, CreateBuilding instance, bool isDelta)
	{
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.socket = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.onterrain = ProtocolParser.ReadBool(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 50:
				RaySerialized.DeserializeLengthDelimited(stream, ref instance.ray, isDelta);
				continue;
			case 56:
				instance.blockID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 72:
				instance.isHoldingShift = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.setToGrade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CreateBuilding DeserializeLengthDelimited(BufferStream stream, CreateBuilding instance, bool isDelta)
	{
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.socket = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.onterrain = ProtocolParser.ReadBool(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 50:
				RaySerialized.DeserializeLengthDelimited(stream, ref instance.ray, isDelta);
				continue;
			case 56:
				instance.blockID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 72:
				instance.isHoldingShift = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.setToGrade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CreateBuilding DeserializeLength(BufferStream stream, int length, CreateBuilding instance, bool isDelta)
	{
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.socket = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.onterrain = ProtocolParser.ReadBool(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 50:
				RaySerialized.DeserializeLengthDelimited(stream, ref instance.ray, isDelta);
				continue;
			case 56:
				instance.blockID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 72:
				instance.isHoldingShift = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.setToGrade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CreateBuilding instance, CreateBuilding previous)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entity.Value);
		if (instance.socket != previous.socket)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.socket);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.onterrain);
		if (instance.position != previous.position)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.normal != previous.normal)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range3 = stream.GetRange(1);
		int num5 = stream.Position;
		RaySerialized.SerializeDelta(stream, instance.ray, previous.ray);
		int num6 = stream.Position - num5;
		if (num6 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ray (UnityEngine.Ray)");
		}
		Span<byte> span3 = range3.GetSpan();
		ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		if (instance.blockID != previous.blockID)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.blockID);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rotation, previous.rotation);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.isHoldingShift);
		if (instance.setToGrade != previous.setToGrade)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.setToGrade);
		}
	}

	public static void Serialize(BufferStream stream, CreateBuilding instance)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entity != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entity.Value);
		}
		if (instance.socket != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.socket);
		}
		if (instance.onterrain)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.onterrain);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.normal != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.normal);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (((Ray)(ref instance.ray)).origin != default(Vector3) && ((Ray)(ref instance.ray)).direction != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			RaySerialized.Serialize(stream, instance.ray);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ray (UnityEngine.Ray)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.blockID != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.blockID);
		}
		if (instance.rotation != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rotation);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		if (instance.isHoldingShift)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.isHoldingShift);
		}
		if (instance.setToGrade != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.setToGrade);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Attack : IDisposable, IPooled, IProto<Attack>, IProto
{
	[NonSerialized]
	public Vector3 pointStart;

	[NonSerialized]
	public Vector3 pointEnd;

	[NonSerialized]
	public NetworkableId hitID;

	[NonSerialized]
	public uint hitBone;

	[NonSerialized]
	public Vector3 hitNormalLocal;

	[NonSerialized]
	public Vector3 hitPositionLocal;

	[NonSerialized]
	public Vector3 hitNormalWorld;

	[NonSerialized]
	public Vector3 hitPositionWorld;

	[NonSerialized]
	public uint hitPartID;

	[NonSerialized]
	public uint hitMaterialID;

	[NonSerialized]
	public NetworkableId srcParentID;

	[NonSerialized]
	public NetworkableId dstParentID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Attack instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.pointStart = default(Vector3);
			instance.pointEnd = default(Vector3);
			instance.hitID = default(NetworkableId);
			instance.hitBone = 0u;
			instance.hitNormalLocal = default(Vector3);
			instance.hitPositionLocal = default(Vector3);
			instance.hitNormalWorld = default(Vector3);
			instance.hitPositionWorld = default(Vector3);
			instance.hitPartID = 0u;
			instance.hitMaterialID = 0u;
			instance.srcParentID = default(NetworkableId);
			instance.dstParentID = default(NetworkableId);
			Pool.Free<Attack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Attack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Attack instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.pointStart = pointStart;
		instance.pointEnd = pointEnd;
		instance.hitID = hitID;
		instance.hitBone = hitBone;
		instance.hitNormalLocal = hitNormalLocal;
		instance.hitPositionLocal = hitPositionLocal;
		instance.hitNormalWorld = hitNormalWorld;
		instance.hitPositionWorld = hitPositionWorld;
		instance.hitPartID = hitPartID;
		instance.hitMaterialID = hitMaterialID;
		instance.srcParentID = srcParentID;
		instance.dstParentID = dstParentID;
	}

	public Attack Copy()
	{
		Attack attack = Pool.Get<Attack>();
		CopyTo(attack);
		return attack;
	}

	public static Attack Deserialize(BufferStream stream)
	{
		Attack attack = Pool.Get<Attack>();
		Deserialize(stream, attack, isDelta: false);
		return attack;
	}

	public static Attack DeserializeLengthDelimited(BufferStream stream)
	{
		Attack attack = Pool.Get<Attack>();
		DeserializeLengthDelimited(stream, attack, isDelta: false);
		return attack;
	}

	public static Attack DeserializeLength(BufferStream stream, int length)
	{
		Attack attack = Pool.Get<Attack>();
		DeserializeLength(stream, length, attack, isDelta: false);
		return attack;
	}

	public static Attack Deserialize(byte[] buffer)
	{
		Attack attack = Pool.Get<Attack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, attack, isDelta: false);
		return attack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Attack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Attack Deserialize(BufferStream stream, Attack instance, bool isDelta)
	{
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointStart, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointEnd, isDelta);
				continue;
			case 24:
				instance.hitID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.hitBone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalLocal, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionLocal, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalWorld, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionWorld, isDelta);
				continue;
			case 72:
				instance.hitPartID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.hitMaterialID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.srcParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.dstParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Attack DeserializeLengthDelimited(BufferStream stream, Attack instance, bool isDelta)
	{
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointStart, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointEnd, isDelta);
				continue;
			case 24:
				instance.hitID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.hitBone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalLocal, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionLocal, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalWorld, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionWorld, isDelta);
				continue;
			case 72:
				instance.hitPartID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.hitMaterialID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.srcParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.dstParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Attack DeserializeLength(BufferStream stream, int length, Attack instance, bool isDelta)
	{
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointStart, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointEnd, isDelta);
				continue;
			case 24:
				instance.hitID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.hitBone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalLocal, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionLocal, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalWorld, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionWorld, isDelta);
				continue;
			case 72:
				instance.hitPartID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.hitMaterialID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.srcParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.dstParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Attack instance, Attack previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pointStart != previous.pointStart)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.pointStart, previous.pointStart);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pointStart (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.pointEnd != previous.pointEnd)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.pointEnd, previous.pointEnd);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pointEnd (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.hitID.Value);
		if (instance.hitBone != previous.hitBone)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.hitBone);
		}
		if (instance.hitNormalLocal != previous.hitNormalLocal)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitNormalLocal, previous.hitNormalLocal);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormalLocal (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.hitPositionLocal != previous.hitPositionLocal)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitPositionLocal, previous.hitPositionLocal);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPositionLocal (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.hitNormalWorld != previous.hitNormalWorld)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitNormalWorld, previous.hitNormalWorld);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormalWorld (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.hitPositionWorld != previous.hitPositionWorld)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitPositionWorld, previous.hitPositionWorld);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPositionWorld (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.hitPartID != previous.hitPartID)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.hitPartID);
		}
		if (instance.hitMaterialID != previous.hitMaterialID)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.hitMaterialID);
		}
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, instance.srcParentID.Value);
		stream.WriteByte(96);
		ProtocolParser.WriteUInt64(stream, instance.dstParentID.Value);
	}

	public static void Serialize(BufferStream stream, Attack instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pointStart != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.pointStart);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pointStart (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.pointEnd != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.pointEnd);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pointEnd (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.hitID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.hitID.Value);
		}
		if (instance.hitBone != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.hitBone);
		}
		if (instance.hitNormalLocal != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitNormalLocal);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormalLocal (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.hitPositionLocal != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitPositionLocal);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPositionLocal (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.hitNormalWorld != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitNormalWorld);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormalWorld (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.hitPositionWorld != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitPositionWorld);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPositionWorld (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.hitPartID != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.hitPartID);
		}
		if (instance.hitMaterialID != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.hitMaterialID);
		}
		if (instance.srcParentID != default(NetworkableId))
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, instance.srcParentID.Value);
		}
		if (instance.dstParentID != default(NetworkableId))
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt64(stream, instance.dstParentID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref hitID.Value);
		action(UidType.NetworkableId, ref srcParentID.Value);
		action(UidType.NetworkableId, ref dstParentID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerAttack : IDisposable, IPooled, IProto<PlayerAttack>, IProto
{
	[NonSerialized]
	public Attack attack;

	[NonSerialized]
	public int projectileID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerAttack instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.attack != null)
			{
				instance.attack.ResetToPool();
				instance.attack = null;
			}
			instance.projectileID = 0;
			Pool.Free<PlayerAttack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerAttack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerAttack instance)
	{
		if (attack != null)
		{
			if (instance.attack == null)
			{
				instance.attack = attack.Copy();
			}
			else
			{
				attack.CopyTo(instance.attack);
			}
		}
		else
		{
			instance.attack = null;
		}
		instance.projectileID = projectileID;
	}

	public PlayerAttack Copy()
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		CopyTo(playerAttack);
		return playerAttack;
	}

	public static PlayerAttack Deserialize(BufferStream stream)
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		Deserialize(stream, playerAttack, isDelta: false);
		return playerAttack;
	}

	public static PlayerAttack DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		DeserializeLengthDelimited(stream, playerAttack, isDelta: false);
		return playerAttack;
	}

	public static PlayerAttack DeserializeLength(BufferStream stream, int length)
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		DeserializeLength(stream, length, playerAttack, isDelta: false);
		return playerAttack;
	}

	public static PlayerAttack Deserialize(byte[] buffer)
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerAttack, isDelta: false);
		return playerAttack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerAttack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerAttack Deserialize(BufferStream stream, PlayerAttack instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.attack == null)
				{
					instance.attack = Attack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Attack.DeserializeLengthDelimited(stream, instance.attack, isDelta);
				}
				break;
			case 16:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static PlayerAttack DeserializeLengthDelimited(BufferStream stream, PlayerAttack instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.attack == null)
				{
					instance.attack = Attack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Attack.DeserializeLengthDelimited(stream, instance.attack, isDelta);
				}
				break;
			case 16:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerAttack DeserializeLength(BufferStream stream, int length, PlayerAttack instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.attack == null)
				{
					instance.attack = Attack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Attack.DeserializeLengthDelimited(stream, instance.attack, isDelta);
				}
				break;
			case 16:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerAttack instance, PlayerAttack previous)
	{
		if (instance.attack == null)
		{
			throw new ArgumentNullException("attack", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(2);
		int position = stream.Position;
		Attack.SerializeDelta(stream, instance.attack, previous.attack);
		int num = stream.Position - position;
		if (num > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field attack (ProtoBuf.Attack)");
		}
		Span<byte> span = range.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
		{
			span[0] |= 128;
			span[1] = 0;
		}
		if (instance.projectileID != previous.projectileID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
	}

	public static void Serialize(BufferStream stream, PlayerAttack instance)
	{
		if (instance.attack == null)
		{
			throw new ArgumentNullException("attack", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(2);
		int position = stream.Position;
		Attack.Serialize(stream, instance.attack);
		int num = stream.Position - position;
		if (num > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field attack (ProtoBuf.Attack)");
		}
		Span<byte> span = range.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
		{
			span[0] |= 128;
			span[1] = 0;
		}
		if (instance.projectileID != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		attack?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerProjectileAttack : IDisposable, IPooled, IProto<PlayerProjectileAttack>, IProto
{
	[NonSerialized]
	public PlayerAttack playerAttack;

	[NonSerialized]
	public Vector3 hitVelocity;

	[NonSerialized]
	public float hitDistance;

	[NonSerialized]
	public float travelTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerProjectileAttack instance)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			if (instance.playerAttack != null)
			{
				instance.playerAttack.ResetToPool();
				instance.playerAttack = null;
			}
			instance.hitVelocity = default(Vector3);
			instance.hitDistance = 0f;
			instance.travelTime = 0f;
			Pool.Free<PlayerProjectileAttack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerProjectileAttack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerProjectileAttack instance)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (playerAttack != null)
		{
			if (instance.playerAttack == null)
			{
				instance.playerAttack = playerAttack.Copy();
			}
			else
			{
				playerAttack.CopyTo(instance.playerAttack);
			}
		}
		else
		{
			instance.playerAttack = null;
		}
		instance.hitVelocity = hitVelocity;
		instance.hitDistance = hitDistance;
		instance.travelTime = travelTime;
	}

	public PlayerProjectileAttack Copy()
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		CopyTo(playerProjectileAttack);
		return playerProjectileAttack;
	}

	public static PlayerProjectileAttack Deserialize(BufferStream stream)
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		Deserialize(stream, playerProjectileAttack, isDelta: false);
		return playerProjectileAttack;
	}

	public static PlayerProjectileAttack DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		DeserializeLengthDelimited(stream, playerProjectileAttack, isDelta: false);
		return playerProjectileAttack;
	}

	public static PlayerProjectileAttack DeserializeLength(BufferStream stream, int length)
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		DeserializeLength(stream, length, playerProjectileAttack, isDelta: false);
		return playerProjectileAttack;
	}

	public static PlayerProjectileAttack Deserialize(byte[] buffer)
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerProjectileAttack, isDelta: false);
		return playerProjectileAttack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerProjectileAttack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerProjectileAttack Deserialize(BufferStream stream, PlayerProjectileAttack instance, bool isDelta)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.playerAttack == null)
				{
					instance.playerAttack = PlayerAttack.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerAttack.DeserializeLengthDelimited(stream, instance.playerAttack, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitVelocity, isDelta);
				break;
			case 29:
				instance.hitDistance = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static PlayerProjectileAttack DeserializeLengthDelimited(BufferStream stream, PlayerProjectileAttack instance, bool isDelta)
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.playerAttack == null)
				{
					instance.playerAttack = PlayerAttack.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerAttack.DeserializeLengthDelimited(stream, instance.playerAttack, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitVelocity, isDelta);
				break;
			case 29:
				instance.hitDistance = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerProjectileAttack DeserializeLength(BufferStream stream, int length, PlayerProjectileAttack instance, bool isDelta)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.playerAttack == null)
				{
					instance.playerAttack = PlayerAttack.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerAttack.DeserializeLengthDelimited(stream, instance.playerAttack, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitVelocity, isDelta);
				break;
			case 29:
				instance.hitDistance = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerProjectileAttack instance, PlayerProjectileAttack previous)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		if (instance.playerAttack == null)
		{
			throw new ArgumentNullException("playerAttack", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(2);
		int position = stream.Position;
		PlayerAttack.SerializeDelta(stream, instance.playerAttack, previous.playerAttack);
		int num = stream.Position - position;
		if (num > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerAttack (ProtoBuf.PlayerAttack)");
		}
		Span<byte> span = range.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
		{
			span[0] |= 128;
			span[1] = 0;
		}
		if (instance.hitVelocity != previous.hitVelocity)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitVelocity, previous.hitVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.hitDistance != previous.hitDistance)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.hitDistance);
		}
		if (instance.travelTime != previous.travelTime)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public static void Serialize(BufferStream stream, PlayerProjectileAttack instance)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.playerAttack == null)
		{
			throw new ArgumentNullException("playerAttack", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(2);
		int position = stream.Position;
		PlayerAttack.Serialize(stream, instance.playerAttack);
		int num = stream.Position - position;
		if (num > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerAttack (ProtoBuf.PlayerAttack)");
		}
		Span<byte> span = range.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
		{
			span[0] |= 128;
			span[1] = 0;
		}
		if (instance.hitVelocity != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.hitDistance != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.hitDistance);
		}
		if (instance.travelTime != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		playerAttack?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerProjectileRicochet : IDisposable, IPooled, IProto<PlayerProjectileRicochet>, IProto
{
	[NonSerialized]
	public int projectileID;

	[NonSerialized]
	public Vector3 hitPosition;

	[NonSerialized]
	public Vector3 inVelocity;

	[NonSerialized]
	public Vector3 outVelocity;

	[NonSerialized]
	public Vector3 hitNormal;

	[NonSerialized]
	public float travelTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerProjectileRicochet instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.projectileID = 0;
			instance.hitPosition = default(Vector3);
			instance.inVelocity = default(Vector3);
			instance.outVelocity = default(Vector3);
			instance.hitNormal = default(Vector3);
			instance.travelTime = 0f;
			Pool.Free<PlayerProjectileRicochet>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerProjectileRicochet with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerProjectileRicochet instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.projectileID = projectileID;
		instance.hitPosition = hitPosition;
		instance.inVelocity = inVelocity;
		instance.outVelocity = outVelocity;
		instance.hitNormal = hitNormal;
		instance.travelTime = travelTime;
	}

	public PlayerProjectileRicochet Copy()
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		CopyTo(playerProjectileRicochet);
		return playerProjectileRicochet;
	}

	public static PlayerProjectileRicochet Deserialize(BufferStream stream)
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		Deserialize(stream, playerProjectileRicochet, isDelta: false);
		return playerProjectileRicochet;
	}

	public static PlayerProjectileRicochet DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		DeserializeLengthDelimited(stream, playerProjectileRicochet, isDelta: false);
		return playerProjectileRicochet;
	}

	public static PlayerProjectileRicochet DeserializeLength(BufferStream stream, int length)
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		DeserializeLength(stream, length, playerProjectileRicochet, isDelta: false);
		return playerProjectileRicochet;
	}

	public static PlayerProjectileRicochet Deserialize(byte[] buffer)
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerProjectileRicochet, isDelta: false);
		return playerProjectileRicochet;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerProjectileRicochet previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerProjectileRicochet Deserialize(BufferStream stream, PlayerProjectileRicochet instance, bool isDelta)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inVelocity, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.outVelocity, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormal, isDelta);
				continue;
			case 53:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerProjectileRicochet DeserializeLengthDelimited(BufferStream stream, PlayerProjectileRicochet instance, bool isDelta)
	{
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inVelocity, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.outVelocity, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormal, isDelta);
				continue;
			case 53:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerProjectileRicochet DeserializeLength(BufferStream stream, int length, PlayerProjectileRicochet instance, bool isDelta)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inVelocity, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.outVelocity, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormal, isDelta);
				continue;
			case 53:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerProjectileRicochet instance, PlayerProjectileRicochet previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != previous.projectileID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.hitPosition != previous.hitPosition)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitPosition, previous.hitPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.inVelocity != previous.inVelocity)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.inVelocity, previous.inVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.outVelocity != previous.outVelocity)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.outVelocity, previous.outVelocity);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field outVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.hitNormal != previous.hitNormal)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitNormal, previous.hitNormal);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormal (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.travelTime != previous.travelTime)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public static void Serialize(BufferStream stream, PlayerProjectileRicochet instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.hitPosition != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.inVelocity != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.inVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.outVelocity != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.outVelocity);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field outVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.hitNormal != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitNormal);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormal (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.travelTime != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerProjectileUpdate : IDisposable, IPooled, IProto<PlayerProjectileUpdate>, IProto
{
	[NonSerialized]
	public int projectileID;

	[NonSerialized]
	public Vector3 curPosition;

	[NonSerialized]
	public Vector3 curVelocity;

	[NonSerialized]
	public float travelTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerProjectileUpdate instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.projectileID = 0;
			instance.curPosition = default(Vector3);
			instance.curVelocity = default(Vector3);
			instance.travelTime = 0f;
			Pool.Free<PlayerProjectileUpdate>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerProjectileUpdate with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerProjectileUpdate instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.projectileID = projectileID;
		instance.curPosition = curPosition;
		instance.curVelocity = curVelocity;
		instance.travelTime = travelTime;
	}

	public PlayerProjectileUpdate Copy()
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		CopyTo(playerProjectileUpdate);
		return playerProjectileUpdate;
	}

	public static PlayerProjectileUpdate Deserialize(BufferStream stream)
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		Deserialize(stream, playerProjectileUpdate, isDelta: false);
		return playerProjectileUpdate;
	}

	public static PlayerProjectileUpdate DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		DeserializeLengthDelimited(stream, playerProjectileUpdate, isDelta: false);
		return playerProjectileUpdate;
	}

	public static PlayerProjectileUpdate DeserializeLength(BufferStream stream, int length)
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		DeserializeLength(stream, length, playerProjectileUpdate, isDelta: false);
		return playerProjectileUpdate;
	}

	public static PlayerProjectileUpdate Deserialize(byte[] buffer)
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerProjectileUpdate, isDelta: false);
		return playerProjectileUpdate;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerProjectileUpdate previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerProjectileUpdate Deserialize(BufferStream stream, PlayerProjectileUpdate instance, bool isDelta)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curVelocity, isDelta);
				continue;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerProjectileUpdate DeserializeLengthDelimited(BufferStream stream, PlayerProjectileUpdate instance, bool isDelta)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curVelocity, isDelta);
				continue;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerProjectileUpdate DeserializeLength(BufferStream stream, int length, PlayerProjectileUpdate instance, bool isDelta)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curVelocity, isDelta);
				continue;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerProjectileUpdate instance, PlayerProjectileUpdate previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != previous.projectileID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.curPosition != previous.curPosition)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.curPosition, previous.curPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.curVelocity != previous.curVelocity)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.curVelocity, previous.curVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.travelTime != previous.travelTime)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public static void Serialize(BufferStream stream, PlayerProjectileUpdate instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.curPosition != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.curPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.curVelocity != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.curVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.travelTime != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ProjectileShoot : IDisposable, IPooled, IProto<ProjectileShoot>, IProto
{
	public class Projectile : IDisposable, IPooled, IProto<Projectile>, IProto
	{
		[NonSerialized]
		public int projectileID;

		[NonSerialized]
		public Vector3 startPos;

		[NonSerialized]
		public Vector3 startVel;

		[NonSerialized]
		public int seed;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Projectile instance)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.projectileID = 0;
				instance.startPos = default(Vector3);
				instance.startVel = default(Vector3);
				instance.seed = 0;
				Pool.Free<Projectile>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Projectile with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Projectile instance)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			instance.projectileID = projectileID;
			instance.startPos = startPos;
			instance.startVel = startVel;
			instance.seed = seed;
		}

		public Projectile Copy()
		{
			Projectile projectile = Pool.Get<Projectile>();
			CopyTo(projectile);
			return projectile;
		}

		public static Projectile Deserialize(BufferStream stream)
		{
			Projectile projectile = Pool.Get<Projectile>();
			Deserialize(stream, projectile, isDelta: false);
			return projectile;
		}

		public static Projectile DeserializeLengthDelimited(BufferStream stream)
		{
			Projectile projectile = Pool.Get<Projectile>();
			DeserializeLengthDelimited(stream, projectile, isDelta: false);
			return projectile;
		}

		public static Projectile DeserializeLength(BufferStream stream, int length)
		{
			Projectile projectile = Pool.Get<Projectile>();
			DeserializeLength(stream, length, projectile, isDelta: false);
			return projectile;
		}

		public static Projectile Deserialize(byte[] buffer)
		{
			Projectile projectile = Pool.Get<Projectile>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, projectile, isDelta: false);
			return projectile;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Projectile previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Projectile Deserialize(BufferStream stream, Projectile instance, bool isDelta)
		{
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
					continue;
				case 32:
					instance.seed = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Projectile DeserializeLengthDelimited(BufferStream stream, Projectile instance, bool isDelta)
		{
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
					continue;
				case 32:
					instance.seed = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Projectile DeserializeLength(BufferStream stream, int length, Projectile instance, bool isDelta)
		{
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
					continue;
				case 32:
					instance.seed = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Projectile instance, Projectile previous)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			if (instance.projectileID != previous.projectileID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
			}
			if (instance.startPos != previous.startPos)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.startPos, previous.startPos);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.startVel != previous.startVel)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.startVel, previous.startVel);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startVel (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.seed != previous.seed)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.seed);
			}
		}

		public static void Serialize(BufferStream stream, Projectile instance)
		{
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			if (instance.projectileID != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
			}
			if (instance.startPos != default(Vector3))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance.startPos);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.startVel != default(Vector3))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.startVel);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startVel (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.seed != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.seed);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public int ammoType;

	[NonSerialized]
	public List<Projectile> projectiles;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ProjectileShoot instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.ammoType = 0;
		if (instance.projectiles != null)
		{
			for (int i = 0; i < instance.projectiles.Count; i++)
			{
				if (instance.projectiles[i] != null)
				{
					instance.projectiles[i].ResetToPool();
					instance.projectiles[i] = null;
				}
			}
			List<Projectile> list = instance.projectiles;
			Pool.Free<Projectile>(ref list, false);
			instance.projectiles = list;
		}
		Pool.Free<ProjectileShoot>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ProjectileShoot with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ProjectileShoot instance)
	{
		instance.ammoType = ammoType;
		if (projectiles != null)
		{
			instance.projectiles = Pool.Get<List<Projectile>>();
			for (int i = 0; i < projectiles.Count; i++)
			{
				Projectile item = projectiles[i].Copy();
				instance.projectiles.Add(item);
			}
		}
		else
		{
			instance.projectiles = null;
		}
	}

	public ProjectileShoot Copy()
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		CopyTo(projectileShoot);
		return projectileShoot;
	}

	public static ProjectileShoot Deserialize(BufferStream stream)
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		Deserialize(stream, projectileShoot, isDelta: false);
		return projectileShoot;
	}

	public static ProjectileShoot DeserializeLengthDelimited(BufferStream stream)
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		DeserializeLengthDelimited(stream, projectileShoot, isDelta: false);
		return projectileShoot;
	}

	public static ProjectileShoot DeserializeLength(BufferStream stream, int length)
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		DeserializeLength(stream, length, projectileShoot, isDelta: false);
		return projectileShoot;
	}

	public static ProjectileShoot Deserialize(byte[] buffer)
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, projectileShoot, isDelta: false);
		return projectileShoot;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ProjectileShoot previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ProjectileShoot Deserialize(BufferStream stream, ProjectileShoot instance, bool isDelta)
	{
		if (!isDelta && instance.projectiles == null)
		{
			instance.projectiles = Pool.Get<List<Projectile>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.projectiles.Add(Projectile.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ProjectileShoot DeserializeLengthDelimited(BufferStream stream, ProjectileShoot instance, bool isDelta)
	{
		if (!isDelta && instance.projectiles == null)
		{
			instance.projectiles = Pool.Get<List<Projectile>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.projectiles.Add(Projectile.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ProjectileShoot DeserializeLength(BufferStream stream, int length, ProjectileShoot instance, bool isDelta)
	{
		if (!isDelta && instance.projectiles == null)
		{
			instance.projectiles = Pool.Get<List<Projectile>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.projectiles.Add(Projectile.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ProjectileShoot instance, ProjectileShoot previous)
	{
		if (instance.ammoType != previous.ammoType)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
		if (instance.projectiles == null)
		{
			return;
		}
		for (int i = 0; i < instance.projectiles.Count; i++)
		{
			Projectile projectile = instance.projectiles[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Projectile.SerializeDelta(stream, projectile, projectile);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field projectiles (ProtoBuf.ProjectileShoot.Projectile)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ProjectileShoot instance)
	{
		if (instance.ammoType != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
		if (instance.projectiles == null)
		{
			return;
		}
		for (int i = 0; i < instance.projectiles.Count; i++)
		{
			Projectile instance2 = instance.projectiles[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Projectile.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field projectiles (ProtoBuf.ProjectileShoot.Projectile)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (projectiles != null)
		{
			for (int i = 0; i < projectiles.Count; i++)
			{
				projectiles[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ModuleMessage : IDisposable, IPooled, IProto<ModuleMessage>, IProto
{
	[NonSerialized]
	public uint itemid;

	[NonSerialized]
	public int moduleid;

	[NonSerialized]
	public int type;

	[NonSerialized]
	public byte[] data;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ModuleMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemid = 0u;
			instance.moduleid = 0;
			instance.type = 0;
			instance.data = null;
			Pool.Free<ModuleMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ModuleMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ModuleMessage instance)
	{
		instance.itemid = itemid;
		instance.moduleid = moduleid;
		instance.type = type;
		if (data == null)
		{
			instance.data = null;
			return;
		}
		instance.data = new byte[data.Length];
		Array.Copy(data, instance.data, instance.data.Length);
	}

	public ModuleMessage Copy()
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		CopyTo(moduleMessage);
		return moduleMessage;
	}

	public static ModuleMessage Deserialize(BufferStream stream)
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		Deserialize(stream, moduleMessage, isDelta: false);
		return moduleMessage;
	}

	public static ModuleMessage DeserializeLengthDelimited(BufferStream stream)
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		DeserializeLengthDelimited(stream, moduleMessage, isDelta: false);
		return moduleMessage;
	}

	public static ModuleMessage DeserializeLength(BufferStream stream, int length)
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		DeserializeLength(stream, length, moduleMessage, isDelta: false);
		return moduleMessage;
	}

	public static ModuleMessage Deserialize(byte[] buffer)
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, moduleMessage, isDelta: false);
		return moduleMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ModuleMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ModuleMessage Deserialize(BufferStream stream, ModuleMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.moduleid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ModuleMessage DeserializeLengthDelimited(BufferStream stream, ModuleMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.moduleid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ModuleMessage DeserializeLength(BufferStream stream, int length, ModuleMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.moduleid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ModuleMessage instance, ModuleMessage previous)
	{
		if (instance.itemid != previous.itemid)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.itemid);
		}
		if (instance.moduleid != previous.moduleid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.moduleid);
		}
		if (instance.type != previous.type)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.data != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteBytes(stream, instance.data);
		}
	}

	public static void Serialize(BufferStream stream, ModuleMessage instance)
	{
		if (instance.itemid != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.itemid);
		}
		if (instance.moduleid != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.moduleid);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.data != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteBytes(stream, instance.data);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class RespawnInformation : IDisposable, IPooled, IProto<RespawnInformation>, IProto
{
	public class SpawnOptions : IDisposable, IPooled, IProto<SpawnOptions>, IProto
	{
		public enum RespawnType
		{
			SleepingBag = 1,
			Bed,
			BeachTowel,
			Camper,
			Static
		}

		public enum RespawnState
		{
			OK = 1,
			Occupied,
			Underwater,
			InNoRespawnZone
		}

		[NonSerialized]
		public RespawnType type;

		[NonSerialized]
		public NetworkableId id;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public float unlockSeconds;

		[NonSerialized]
		public Vector3 worldPosition;

		[NonSerialized]
		public RespawnState respawnState;

		[NonSerialized]
		public bool mobile;

		[NonSerialized]
		public string nexusZone;

		[NonSerialized]
		public bool corpse;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SpawnOptions instance)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.type = (RespawnType)0;
				instance.id = default(NetworkableId);
				instance.name = string.Empty;
				instance.unlockSeconds = 0f;
				instance.worldPosition = default(Vector3);
				instance.respawnState = (RespawnState)0;
				instance.mobile = false;
				instance.nexusZone = string.Empty;
				instance.corpse = false;
				Pool.Free<SpawnOptions>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SpawnOptions with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SpawnOptions instance)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			instance.type = type;
			instance.id = id;
			instance.name = name;
			instance.unlockSeconds = unlockSeconds;
			instance.worldPosition = worldPosition;
			instance.respawnState = respawnState;
			instance.mobile = mobile;
			instance.nexusZone = nexusZone;
			instance.corpse = corpse;
		}

		public SpawnOptions Copy()
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			CopyTo(spawnOptions);
			return spawnOptions;
		}

		public static SpawnOptions Deserialize(BufferStream stream)
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			Deserialize(stream, spawnOptions, isDelta: false);
			return spawnOptions;
		}

		public static SpawnOptions DeserializeLengthDelimited(BufferStream stream)
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			DeserializeLengthDelimited(stream, spawnOptions, isDelta: false);
			return spawnOptions;
		}

		public static SpawnOptions DeserializeLength(BufferStream stream, int length)
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			DeserializeLength(stream, length, spawnOptions, isDelta: false);
			return spawnOptions;
		}

		public static SpawnOptions Deserialize(byte[] buffer)
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, spawnOptions, isDelta: false);
			return spawnOptions;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SpawnOptions previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SpawnOptions Deserialize(BufferStream stream, SpawnOptions instance, bool isDelta)
		{
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				instance.respawnState = RespawnState.OK;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 37:
					instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
					continue;
				case 48:
					instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.mobile = ProtocolParser.ReadBool(stream);
					continue;
				case 66:
					instance.nexusZone = ProtocolParser.ReadString(stream);
					continue;
				case 72:
					instance.corpse = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static SpawnOptions DeserializeLengthDelimited(BufferStream stream, SpawnOptions instance, bool isDelta)
		{
			//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				instance.respawnState = RespawnState.OK;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 37:
					instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
					continue;
				case 48:
					instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.mobile = ProtocolParser.ReadBool(stream);
					continue;
				case 66:
					instance.nexusZone = ProtocolParser.ReadString(stream);
					continue;
				case 72:
					instance.corpse = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SpawnOptions DeserializeLength(BufferStream stream, int length, SpawnOptions instance, bool isDelta)
		{
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				instance.respawnState = RespawnState.OK;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 37:
					instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
					continue;
				case 48:
					instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.mobile = ProtocolParser.ReadBool(stream);
					continue;
				case 66:
					instance.nexusZone = ProtocolParser.ReadString(stream);
					continue;
				case 72:
					instance.corpse = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SpawnOptions instance, SpawnOptions previous)
		{
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.id.Value);
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.unlockSeconds != previous.unlockSeconds)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
			}
			if (instance.worldPosition != previous.worldPosition)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.worldPosition, previous.worldPosition);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.mobile);
			if (instance.nexusZone != null && instance.nexusZone != previous.nexusZone)
			{
				stream.WriteByte(66);
				ProtocolParser.WriteString(stream, instance.nexusZone);
			}
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.corpse);
		}

		public static void Serialize(BufferStream stream, SpawnOptions instance)
		{
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			if (instance.id != default(NetworkableId))
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.id.Value);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.unlockSeconds != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
			}
			if (instance.worldPosition != default(Vector3))
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance.worldPosition);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
			if (instance.mobile)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.mobile);
			}
			if (instance.nexusZone != null)
			{
				stream.WriteByte(66);
				ProtocolParser.WriteString(stream, instance.nexusZone);
			}
			if (instance.corpse)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteBool(stream, instance.corpse);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref id.Value);
		}
	}

	[NonSerialized]
	public List<SpawnOptions> spawnOptions;

	[NonSerialized]
	public PlayerLifeStory previousLife;

	[NonSerialized]
	public bool fadeIn;

	[NonSerialized]
	public bool loading;

	[NonSerialized]
	public List<Vector3> shelterPositions;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RespawnInformation instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.spawnOptions != null)
		{
			for (int i = 0; i < instance.spawnOptions.Count; i++)
			{
				if (instance.spawnOptions[i] != null)
				{
					instance.spawnOptions[i].ResetToPool();
					instance.spawnOptions[i] = null;
				}
			}
			List<SpawnOptions> list = instance.spawnOptions;
			Pool.Free<SpawnOptions>(ref list, false);
			instance.spawnOptions = list;
		}
		if (instance.previousLife != null)
		{
			instance.previousLife.ResetToPool();
			instance.previousLife = null;
		}
		instance.fadeIn = false;
		instance.loading = false;
		if (instance.shelterPositions != null)
		{
			List<Vector3> list2 = instance.shelterPositions;
			Pool.FreeUnmanaged<Vector3>(ref list2);
			instance.shelterPositions = list2;
		}
		Pool.Free<RespawnInformation>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RespawnInformation with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RespawnInformation instance)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		if (spawnOptions != null)
		{
			instance.spawnOptions = Pool.Get<List<SpawnOptions>>();
			for (int i = 0; i < spawnOptions.Count; i++)
			{
				SpawnOptions item = spawnOptions[i].Copy();
				instance.spawnOptions.Add(item);
			}
		}
		else
		{
			instance.spawnOptions = null;
		}
		if (previousLife != null)
		{
			if (instance.previousLife == null)
			{
				instance.previousLife = previousLife.Copy();
			}
			else
			{
				previousLife.CopyTo(instance.previousLife);
			}
		}
		else
		{
			instance.previousLife = null;
		}
		instance.fadeIn = fadeIn;
		instance.loading = loading;
		if (shelterPositions != null)
		{
			instance.shelterPositions = Pool.Get<List<Vector3>>();
			for (int j = 0; j < shelterPositions.Count; j++)
			{
				Vector3 item2 = shelterPositions[j];
				instance.shelterPositions.Add(item2);
			}
		}
		else
		{
			instance.shelterPositions = null;
		}
	}

	public RespawnInformation Copy()
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		CopyTo(respawnInformation);
		return respawnInformation;
	}

	public static RespawnInformation Deserialize(BufferStream stream)
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		Deserialize(stream, respawnInformation, isDelta: false);
		return respawnInformation;
	}

	public static RespawnInformation DeserializeLengthDelimited(BufferStream stream)
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		DeserializeLengthDelimited(stream, respawnInformation, isDelta: false);
		return respawnInformation;
	}

	public static RespawnInformation DeserializeLength(BufferStream stream, int length)
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		DeserializeLength(stream, length, respawnInformation, isDelta: false);
		return respawnInformation;
	}

	public static RespawnInformation Deserialize(byte[] buffer)
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, respawnInformation, isDelta: false);
		return respawnInformation;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RespawnInformation previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RespawnInformation Deserialize(BufferStream stream, RespawnInformation instance, bool isDelta)
	{
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = Pool.Get<List<SpawnOptions>>();
			}
			if (instance.shelterPositions == null)
			{
				instance.shelterPositions = Pool.Get<List<Vector3>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.spawnOptions.Add(SpawnOptions.DeserializeLengthDelimited(stream));
				break;
			case 18:
				if (instance.previousLife == null)
				{
					instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
				}
				break;
			case 24:
				instance.fadeIn = ProtocolParser.ReadBool(stream);
				break;
			case 32:
				instance.loading = ProtocolParser.ReadBool(stream);
				break;
			case 42:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.shelterPositions.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static RespawnInformation DeserializeLengthDelimited(BufferStream stream, RespawnInformation instance, bool isDelta)
	{
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = Pool.Get<List<SpawnOptions>>();
			}
			if (instance.shelterPositions == null)
			{
				instance.shelterPositions = Pool.Get<List<Vector3>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.spawnOptions.Add(SpawnOptions.DeserializeLengthDelimited(stream));
				break;
			case 18:
				if (instance.previousLife == null)
				{
					instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
				}
				break;
			case 24:
				instance.fadeIn = ProtocolParser.ReadBool(stream);
				break;
			case 32:
				instance.loading = ProtocolParser.ReadBool(stream);
				break;
			case 42:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.shelterPositions.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RespawnInformation DeserializeLength(BufferStream stream, int length, RespawnInformation instance, bool isDelta)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = Pool.Get<List<SpawnOptions>>();
			}
			if (instance.shelterPositions == null)
			{
				instance.shelterPositions = Pool.Get<List<Vector3>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.spawnOptions.Add(SpawnOptions.DeserializeLengthDelimited(stream));
				break;
			case 18:
				if (instance.previousLife == null)
				{
					instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
				}
				break;
			case 24:
				instance.fadeIn = ProtocolParser.ReadBool(stream);
				break;
			case 32:
				instance.loading = ProtocolParser.ReadBool(stream);
				break;
			case 42:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.shelterPositions.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RespawnInformation instance, RespawnInformation previous)
	{
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spawnOptions != null)
		{
			for (int i = 0; i < instance.spawnOptions.Count; i++)
			{
				SpawnOptions spawnOptions = instance.spawnOptions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				SpawnOptions.SerializeDelta(stream, spawnOptions, spawnOptions);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.previousLife != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerLifeStory.SerializeDelta(stream, instance.previousLife, previous.previousLife);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.fadeIn);
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.loading);
		if (instance.shelterPositions == null)
		{
			return;
		}
		for (int j = 0; j < instance.shelterPositions.Count; j++)
		{
			Vector3 val3 = instance.shelterPositions[j];
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, val3, val3);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field shelterPositions (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public static void Serialize(BufferStream stream, RespawnInformation instance)
	{
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spawnOptions != null)
		{
			for (int i = 0; i < instance.spawnOptions.Count; i++)
			{
				SpawnOptions instance2 = instance.spawnOptions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				SpawnOptions.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.previousLife != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerLifeStory.Serialize(stream, instance.previousLife);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.fadeIn)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.fadeIn);
		}
		if (instance.loading)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.loading);
		}
		if (instance.shelterPositions == null)
		{
			return;
		}
		for (int j = 0; j < instance.shelterPositions.Count; j++)
		{
			Vector3 instance3 = instance.shelterPositions[j];
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance3);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field shelterPositions (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (spawnOptions != null)
		{
			for (int i = 0; i < spawnOptions.Count; i++)
			{
				spawnOptions[i]?.InspectUids(action);
			}
		}
		previousLife?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClientReady : IDisposable, IPooled, IProto<ClientReady>, IProto
{
	public class ClientInfo : IDisposable, IPooled, IProto<ClientInfo>, IProto
	{
		[NonSerialized]
		public string name;

		[NonSerialized]
		public string value;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ClientInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.name = string.Empty;
				instance.value = string.Empty;
				Pool.Free<ClientInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ClientInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ClientInfo instance)
		{
			instance.name = name;
			instance.value = value;
		}

		public ClientInfo Copy()
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			CopyTo(clientInfo);
			return clientInfo;
		}

		public static ClientInfo Deserialize(BufferStream stream)
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			Deserialize(stream, clientInfo, isDelta: false);
			return clientInfo;
		}

		public static ClientInfo DeserializeLengthDelimited(BufferStream stream)
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			DeserializeLengthDelimited(stream, clientInfo, isDelta: false);
			return clientInfo;
		}

		public static ClientInfo DeserializeLength(BufferStream stream, int length)
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			DeserializeLength(stream, length, clientInfo, isDelta: false);
			return clientInfo;
		}

		public static ClientInfo Deserialize(byte[] buffer)
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, clientInfo, isDelta: false);
			return clientInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ClientInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ClientInfo Deserialize(BufferStream stream, ClientInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.value = ProtocolParser.ReadString(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ClientInfo DeserializeLengthDelimited(BufferStream stream, ClientInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.value = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ClientInfo DeserializeLength(BufferStream stream, int length, ClientInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.value = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ClientInfo instance, ClientInfo previous)
		{
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.value != previous.value)
			{
				if (instance.value == null)
				{
					throw new ArgumentNullException("value", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.value);
			}
		}

		public static void Serialize(BufferStream stream, ClientInfo instance)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.value == null)
			{
				throw new ArgumentNullException("value", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.value);
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<ClientInfo> clientInfo;

	[NonSerialized]
	public bool globalNetworking;

	[NonSerialized]
	public PartyData party;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClientReady instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.clientInfo != null)
		{
			for (int i = 0; i < instance.clientInfo.Count; i++)
			{
				if (instance.clientInfo[i] != null)
				{
					instance.clientInfo[i].ResetToPool();
					instance.clientInfo[i] = null;
				}
			}
			List<ClientInfo> list = instance.clientInfo;
			Pool.Free<ClientInfo>(ref list, false);
			instance.clientInfo = list;
		}
		instance.globalNetworking = false;
		if (instance.party != null)
		{
			instance.party.ResetToPool();
			instance.party = null;
		}
		Pool.Free<ClientReady>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClientReady with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClientReady instance)
	{
		if (clientInfo != null)
		{
			instance.clientInfo = Pool.Get<List<ClientInfo>>();
			for (int i = 0; i < clientInfo.Count; i++)
			{
				ClientInfo item = clientInfo[i].Copy();
				instance.clientInfo.Add(item);
			}
		}
		else
		{
			instance.clientInfo = null;
		}
		instance.globalNetworking = globalNetworking;
		if (party != null)
		{
			if (instance.party == null)
			{
				instance.party = party.Copy();
			}
			else
			{
				party.CopyTo(instance.party);
			}
		}
		else
		{
			instance.party = null;
		}
	}

	public ClientReady Copy()
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		CopyTo(clientReady);
		return clientReady;
	}

	public static ClientReady Deserialize(BufferStream stream)
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		Deserialize(stream, clientReady, isDelta: false);
		return clientReady;
	}

	public static ClientReady DeserializeLengthDelimited(BufferStream stream)
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		DeserializeLengthDelimited(stream, clientReady, isDelta: false);
		return clientReady;
	}

	public static ClientReady DeserializeLength(BufferStream stream, int length)
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		DeserializeLength(stream, length, clientReady, isDelta: false);
		return clientReady;
	}

	public static ClientReady Deserialize(byte[] buffer)
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clientReady, isDelta: false);
		return clientReady;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClientReady previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClientReady Deserialize(BufferStream stream, ClientReady instance, bool isDelta)
	{
		if (!isDelta && instance.clientInfo == null)
		{
			instance.clientInfo = Pool.Get<List<ClientInfo>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.clientInfo.Add(ClientInfo.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.globalNetworking = ProtocolParser.ReadBool(stream);
				break;
			case 26:
				if (instance.party == null)
				{
					instance.party = PartyData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PartyData.DeserializeLengthDelimited(stream, instance.party, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static ClientReady DeserializeLengthDelimited(BufferStream stream, ClientReady instance, bool isDelta)
	{
		if (!isDelta && instance.clientInfo == null)
		{
			instance.clientInfo = Pool.Get<List<ClientInfo>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.clientInfo.Add(ClientInfo.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.globalNetworking = ProtocolParser.ReadBool(stream);
				break;
			case 26:
				if (instance.party == null)
				{
					instance.party = PartyData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PartyData.DeserializeLengthDelimited(stream, instance.party, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClientReady DeserializeLength(BufferStream stream, int length, ClientReady instance, bool isDelta)
	{
		if (!isDelta && instance.clientInfo == null)
		{
			instance.clientInfo = Pool.Get<List<ClientInfo>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.clientInfo.Add(ClientInfo.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.globalNetworking = ProtocolParser.ReadBool(stream);
				break;
			case 26:
				if (instance.party == null)
				{
					instance.party = PartyData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PartyData.DeserializeLengthDelimited(stream, instance.party, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClientReady instance, ClientReady previous)
	{
		if (instance.clientInfo != null)
		{
			for (int i = 0; i < instance.clientInfo.Count; i++)
			{
				ClientInfo clientInfo = instance.clientInfo[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ClientInfo.SerializeDelta(stream, clientInfo, clientInfo);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.globalNetworking);
		if (instance.party == null)
		{
			return;
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		PartyData.SerializeDelta(stream, instance.party, previous.party);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, ClientReady instance)
	{
		if (instance.clientInfo != null)
		{
			for (int i = 0; i < instance.clientInfo.Count; i++)
			{
				ClientInfo instance2 = instance.clientInfo[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ClientInfo.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.globalNetworking)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.globalNetworking);
		}
		if (instance.party == null)
		{
			return;
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		PartyData.Serialize(stream, instance.party);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (clientInfo != null)
		{
			for (int i = 0; i < clientInfo.Count; i++)
			{
				clientInfo[i]?.InspectUids(action);
			}
		}
		party?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Tree : IDisposable, IPooled, IProto<Tree>, IProto
{
	[NonSerialized]
	public NetworkableId netId;

	[NonSerialized]
	public uint prefabId;

	[NonSerialized]
	public Half3 position;

	[NonSerialized]
	public float scale;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Tree instance)
	{
		if (instance.ShouldPool)
		{
			instance.netId = default(NetworkableId);
			instance.prefabId = 0u;
			instance.position = default(Half3);
			instance.scale = 0f;
			Pool.Free<Tree>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Tree with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Tree instance)
	{
		instance.netId = netId;
		instance.prefabId = prefabId;
		instance.position = position;
		instance.scale = scale;
	}

	public Tree Copy()
	{
		Tree tree = Pool.Get<Tree>();
		CopyTo(tree);
		return tree;
	}

	public static Tree Deserialize(BufferStream stream)
	{
		Tree tree = Pool.Get<Tree>();
		Deserialize(stream, tree, isDelta: false);
		return tree;
	}

	public static Tree DeserializeLengthDelimited(BufferStream stream)
	{
		Tree tree = Pool.Get<Tree>();
		DeserializeLengthDelimited(stream, tree, isDelta: false);
		return tree;
	}

	public static Tree DeserializeLength(BufferStream stream, int length)
	{
		Tree tree = Pool.Get<Tree>();
		DeserializeLength(stream, length, tree, isDelta: false);
		return tree;
	}

	public static Tree Deserialize(byte[] buffer)
	{
		Tree tree = Pool.Get<Tree>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, tree, isDelta: false);
		return tree;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Tree previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Tree Deserialize(BufferStream stream, Tree instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.netId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				Half3.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 37:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Tree DeserializeLengthDelimited(BufferStream stream, Tree instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.netId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				Half3.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 37:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Tree DeserializeLength(BufferStream stream, int length, Tree instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.netId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				Half3.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 37:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Tree instance, Tree previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.netId.Value);
		if (instance.prefabId != previous.prefabId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.prefabId);
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int num = stream.Position;
		Half3.SerializeDelta(stream, instance.position, previous.position);
		int num2 = stream.Position - num;
		if (num2 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (ProtoBuf.Half3)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num2, span, 0);
		if (instance.scale != previous.scale)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.scale);
		}
	}

	public static void Serialize(BufferStream stream, Tree instance)
	{
		if (instance.netId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.netId.Value);
		}
		if (instance.prefabId != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.prefabId);
		}
		if (instance.position != default(Half3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Half3.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (ProtoBuf.Half3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.scale != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.scale);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref netId.Value);
		position.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TreeList : IDisposable, IPooled, IProto<TreeList>, IProto
{
	[NonSerialized]
	public List<Tree> trees;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TreeList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.trees != null)
		{
			for (int i = 0; i < instance.trees.Count; i++)
			{
				if (instance.trees[i] != null)
				{
					instance.trees[i].ResetToPool();
					instance.trees[i] = null;
				}
			}
			List<Tree> list = instance.trees;
			Pool.Free<Tree>(ref list, false);
			instance.trees = list;
		}
		Pool.Free<TreeList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TreeList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TreeList instance)
	{
		if (trees != null)
		{
			instance.trees = Pool.Get<List<Tree>>();
			for (int i = 0; i < trees.Count; i++)
			{
				Tree item = trees[i].Copy();
				instance.trees.Add(item);
			}
		}
		else
		{
			instance.trees = null;
		}
	}

	public TreeList Copy()
	{
		TreeList treeList = Pool.Get<TreeList>();
		CopyTo(treeList);
		return treeList;
	}

	public static TreeList Deserialize(BufferStream stream)
	{
		TreeList treeList = Pool.Get<TreeList>();
		Deserialize(stream, treeList, isDelta: false);
		return treeList;
	}

	public static TreeList DeserializeLengthDelimited(BufferStream stream)
	{
		TreeList treeList = Pool.Get<TreeList>();
		DeserializeLengthDelimited(stream, treeList, isDelta: false);
		return treeList;
	}

	public static TreeList DeserializeLength(BufferStream stream, int length)
	{
		TreeList treeList = Pool.Get<TreeList>();
		DeserializeLength(stream, length, treeList, isDelta: false);
		return treeList;
	}

	public static TreeList Deserialize(byte[] buffer)
	{
		TreeList treeList = Pool.Get<TreeList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, treeList, isDelta: false);
		return treeList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TreeList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TreeList Deserialize(BufferStream stream, TreeList instance, bool isDelta)
	{
		if (!isDelta && instance.trees == null)
		{
			instance.trees = Pool.Get<List<Tree>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.trees.Add(Tree.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TreeList DeserializeLengthDelimited(BufferStream stream, TreeList instance, bool isDelta)
	{
		if (!isDelta && instance.trees == null)
		{
			instance.trees = Pool.Get<List<Tree>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.trees.Add(Tree.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TreeList DeserializeLength(BufferStream stream, int length, TreeList instance, bool isDelta)
	{
		if (!isDelta && instance.trees == null)
		{
			instance.trees = Pool.Get<List<Tree>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.trees.Add(Tree.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TreeList instance, TreeList previous)
	{
		if (instance.trees == null)
		{
			return;
		}
		for (int i = 0; i < instance.trees.Count; i++)
		{
			Tree tree = instance.trees[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Tree.SerializeDelta(stream, tree, tree);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field trees (ProtoBuf.Tree)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, TreeList instance)
	{
		if (instance.trees == null)
		{
			return;
		}
		for (int i = 0; i < instance.trees.Count; i++)
		{
			Tree instance2 = instance.trees[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Tree.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field trees (ProtoBuf.Tree)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (trees != null)
		{
			for (int i = 0; i < trees.Count; i++)
			{
				trees[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WorldMessage : IDisposable, IPooled, IProto<WorldMessage>, IProto
{
	public enum MessageType
	{
		Request = 1,
		Receive,
		Done
	}

	[NonSerialized]
	public MessageType status;

	[NonSerialized]
	public List<PrefabData> prefabs;

	[NonSerialized]
	public List<PathData> paths;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WorldMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.status = (MessageType)0;
		if (instance.prefabs != null)
		{
			for (int i = 0; i < instance.prefabs.Count; i++)
			{
				if (instance.prefabs[i] != null)
				{
					instance.prefabs[i].ResetToPool();
					instance.prefabs[i] = null;
				}
			}
			List<PrefabData> list = instance.prefabs;
			Pool.Free<PrefabData>(ref list, false);
			instance.prefabs = list;
		}
		if (instance.paths != null)
		{
			for (int j = 0; j < instance.paths.Count; j++)
			{
				if (instance.paths[j] != null)
				{
					instance.paths[j].ResetToPool();
					instance.paths[j] = null;
				}
			}
			List<PathData> list2 = instance.paths;
			Pool.Free<PathData>(ref list2, false);
			instance.paths = list2;
		}
		Pool.Free<WorldMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WorldMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WorldMessage instance)
	{
		instance.status = status;
		if (prefabs != null)
		{
			instance.prefabs = Pool.Get<List<PrefabData>>();
			for (int i = 0; i < prefabs.Count; i++)
			{
				PrefabData item = prefabs[i].Copy();
				instance.prefabs.Add(item);
			}
		}
		else
		{
			instance.prefabs = null;
		}
		if (paths != null)
		{
			instance.paths = Pool.Get<List<PathData>>();
			for (int j = 0; j < paths.Count; j++)
			{
				PathData item2 = paths[j].Copy();
				instance.paths.Add(item2);
			}
		}
		else
		{
			instance.paths = null;
		}
	}

	public WorldMessage Copy()
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		CopyTo(worldMessage);
		return worldMessage;
	}

	public static WorldMessage Deserialize(BufferStream stream)
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		Deserialize(stream, worldMessage, isDelta: false);
		return worldMessage;
	}

	public static WorldMessage DeserializeLengthDelimited(BufferStream stream)
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		DeserializeLengthDelimited(stream, worldMessage, isDelta: false);
		return worldMessage;
	}

	public static WorldMessage DeserializeLength(BufferStream stream, int length)
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		DeserializeLength(stream, length, worldMessage, isDelta: false);
		return worldMessage;
	}

	public static WorldMessage Deserialize(byte[] buffer)
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, worldMessage, isDelta: false);
		return worldMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WorldMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WorldMessage Deserialize(BufferStream stream, WorldMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.status = (MessageType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WorldMessage DeserializeLengthDelimited(BufferStream stream, WorldMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.status = (MessageType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WorldMessage DeserializeLength(BufferStream stream, int length, WorldMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.status = (MessageType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WorldMessage instance, WorldMessage previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.status);
		if (instance.prefabs != null)
		{
			for (int i = 0; i < instance.prefabs.Count; i++)
			{
				PrefabData prefabData = instance.prefabs[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PrefabData.SerializeDelta(stream, prefabData, prefabData);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.paths == null)
		{
			return;
		}
		for (int j = 0; j < instance.paths.Count; j++)
		{
			PathData pathData = instance.paths[j];
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PathData.SerializeDelta(stream, pathData, pathData);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, WorldMessage instance)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.status);
		if (instance.prefabs != null)
		{
			for (int i = 0; i < instance.prefabs.Count; i++)
			{
				PrefabData instance2 = instance.prefabs[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PrefabData.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.paths == null)
		{
			return;
		}
		for (int j = 0; j < instance.paths.Count; j++)
		{
			PathData instance3 = instance.paths[j];
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PathData.Serialize(stream, instance3);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (prefabs != null)
		{
			for (int i = 0; i < prefabs.Count; i++)
			{
				prefabs[i]?.InspectUids(action);
			}
		}
		if (paths != null)
		{
			for (int j = 0; j < paths.Count; j++)
			{
				paths[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ArcadeGame : IDisposable, IPooled, IProto<ArcadeGame>, IProto
{
	public class arcadeEnt : IDisposable, IPooled, IProto<arcadeEnt>, IProto
	{
		[NonSerialized]
		public uint id;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public uint spriteID;

		[NonSerialized]
		public uint soundID;

		[NonSerialized]
		public bool visible;

		[NonSerialized]
		public Vector3 position;

		[NonSerialized]
		public Vector3 heading;

		[NonSerialized]
		public bool enabled;

		[NonSerialized]
		public Vector3 scale;

		[NonSerialized]
		public Vector3 colliderScale;

		[NonSerialized]
		public float alpha;

		[NonSerialized]
		public uint prefabID;

		[NonSerialized]
		public uint parentID;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(arcadeEnt instance)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.id = 0u;
				instance.name = string.Empty;
				instance.spriteID = 0u;
				instance.soundID = 0u;
				instance.visible = false;
				instance.position = default(Vector3);
				instance.heading = default(Vector3);
				instance.enabled = false;
				instance.scale = default(Vector3);
				instance.colliderScale = default(Vector3);
				instance.alpha = 0f;
				instance.prefabID = 0u;
				instance.parentID = 0u;
				Pool.Free<arcadeEnt>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose arcadeEnt with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(arcadeEnt instance)
		{
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			instance.id = id;
			instance.name = name;
			instance.spriteID = spriteID;
			instance.soundID = soundID;
			instance.visible = visible;
			instance.position = position;
			instance.heading = heading;
			instance.enabled = enabled;
			instance.scale = scale;
			instance.colliderScale = colliderScale;
			instance.alpha = alpha;
			instance.prefabID = prefabID;
			instance.parentID = parentID;
		}

		public arcadeEnt Copy()
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			CopyTo(arcadeEnt);
			return arcadeEnt;
		}

		public static arcadeEnt Deserialize(BufferStream stream)
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			Deserialize(stream, arcadeEnt, isDelta: false);
			return arcadeEnt;
		}

		public static arcadeEnt DeserializeLengthDelimited(BufferStream stream)
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			DeserializeLengthDelimited(stream, arcadeEnt, isDelta: false);
			return arcadeEnt;
		}

		public static arcadeEnt DeserializeLength(BufferStream stream, int length)
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			DeserializeLength(stream, length, arcadeEnt, isDelta: false);
			return arcadeEnt;
		}

		public static arcadeEnt Deserialize(byte[] buffer)
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, arcadeEnt, isDelta: false);
			return arcadeEnt;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, arcadeEnt previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static arcadeEnt Deserialize(BufferStream stream, arcadeEnt instance, bool isDelta)
		{
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.id = ProtocolParser.ReadUInt32(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.spriteID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 32:
					instance.soundID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 40:
					instance.visible = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 58:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
					continue;
				case 64:
					instance.enabled = ProtocolParser.ReadBool(stream);
					continue;
				case 74:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
					continue;
				case 82:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
					continue;
				case 93:
					instance.alpha = ProtocolParser.ReadSingle(stream);
					continue;
				case 96:
					instance.prefabID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 104:
					instance.parentID = ProtocolParser.ReadUInt32(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static arcadeEnt DeserializeLengthDelimited(BufferStream stream, arcadeEnt instance, bool isDelta)
		{
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0182: Unknown result type (might be due to invalid IL or missing references)
			//IL_016f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.id = ProtocolParser.ReadUInt32(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.spriteID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 32:
					instance.soundID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 40:
					instance.visible = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 58:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
					continue;
				case 64:
					instance.enabled = ProtocolParser.ReadBool(stream);
					continue;
				case 74:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
					continue;
				case 82:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
					continue;
				case 93:
					instance.alpha = ProtocolParser.ReadSingle(stream);
					continue;
				case 96:
					instance.prefabID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 104:
					instance.parentID = ProtocolParser.ReadUInt32(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static arcadeEnt DeserializeLength(BufferStream stream, int length, arcadeEnt instance, bool isDelta)
		{
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_017a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0167: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.id = ProtocolParser.ReadUInt32(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.spriteID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 32:
					instance.soundID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 40:
					instance.visible = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 58:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
					continue;
				case 64:
					instance.enabled = ProtocolParser.ReadBool(stream);
					continue;
				case 74:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
					continue;
				case 82:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
					continue;
				case 93:
					instance.alpha = ProtocolParser.ReadSingle(stream);
					continue;
				case 96:
					instance.prefabID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 104:
					instance.parentID = ProtocolParser.ReadUInt32(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, arcadeEnt instance, arcadeEnt previous)
		{
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0202: Unknown result type (might be due to invalid IL or missing references)
			//IL_0208: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_022f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0235: Unknown result type (might be due to invalid IL or missing references)
			if (instance.id != previous.id)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, instance.id);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.spriteID != previous.spriteID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt32(stream, instance.spriteID);
			}
			if (instance.soundID != previous.soundID)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, instance.soundID);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.visible);
			if (instance.position != previous.position)
			{
				stream.WriteByte(50);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.heading != previous.heading)
			{
				stream.WriteByte(58);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.heading, previous.heading);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heading (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.enabled);
			if (instance.scale != previous.scale)
			{
				stream.WriteByte(74);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int num5 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.scale, previous.scale);
				int num6 = stream.Position - num5;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span3, 0);
			}
			if (instance.colliderScale != previous.colliderScale)
			{
				stream.WriteByte(82);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int num7 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.colliderScale, previous.colliderScale);
				int num8 = stream.Position - num7;
				if (num8 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colliderScale (UnityEngine.Vector3)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num8, span4, 0);
			}
			if (instance.alpha != previous.alpha)
			{
				stream.WriteByte(93);
				ProtocolParser.WriteSingle(stream, instance.alpha);
			}
			if (instance.prefabID != previous.prefabID)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteUInt32(stream, instance.prefabID);
			}
			if (instance.parentID != previous.parentID)
			{
				stream.WriteByte(104);
				ProtocolParser.WriteUInt32(stream, instance.parentID);
			}
		}

		public static void Serialize(BufferStream stream, arcadeEnt instance)
		{
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018c: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01af: Unknown result type (might be due to invalid IL or missing references)
			//IL_0215: Unknown result type (might be due to invalid IL or missing references)
			if (instance.id != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, instance.id);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.spriteID != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt32(stream, instance.spriteID);
			}
			if (instance.soundID != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, instance.soundID);
			}
			if (instance.visible)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.visible);
			}
			if (instance.position != default(Vector3))
			{
				stream.WriteByte(50);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.Serialize(stream, instance.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.heading != default(Vector3))
			{
				stream.WriteByte(58);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.heading);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heading (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
			if (instance.enabled)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteBool(stream, instance.enabled);
			}
			if (instance.scale != default(Vector3))
			{
				stream.WriteByte(74);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int num5 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.scale);
				int num6 = stream.Position - num5;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span3, 0);
			}
			if (instance.colliderScale != default(Vector3))
			{
				stream.WriteByte(82);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int num7 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.colliderScale);
				int num8 = stream.Position - num7;
				if (num8 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colliderScale (UnityEngine.Vector3)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num8, span4, 0);
			}
			if (instance.alpha != 0f)
			{
				stream.WriteByte(93);
				ProtocolParser.WriteSingle(stream, instance.alpha);
			}
			if (instance.prefabID != 0)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteUInt32(stream, instance.prefabID);
			}
			if (instance.parentID != 0)
			{
				stream.WriteByte(104);
				ProtocolParser.WriteUInt32(stream, instance.parentID);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<arcadeEnt> arcadeEnts;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ArcadeGame instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.arcadeEnts != null)
		{
			for (int i = 0; i < instance.arcadeEnts.Count; i++)
			{
				if (instance.arcadeEnts[i] != null)
				{
					instance.arcadeEnts[i].ResetToPool();
					instance.arcadeEnts[i] = null;
				}
			}
			List<arcadeEnt> list = instance.arcadeEnts;
			Pool.Free<arcadeEnt>(ref list, false);
			instance.arcadeEnts = list;
		}
		Pool.Free<ArcadeGame>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ArcadeGame with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ArcadeGame instance)
	{
		if (arcadeEnts != null)
		{
			instance.arcadeEnts = Pool.Get<List<arcadeEnt>>();
			for (int i = 0; i < arcadeEnts.Count; i++)
			{
				arcadeEnt item = arcadeEnts[i].Copy();
				instance.arcadeEnts.Add(item);
			}
		}
		else
		{
			instance.arcadeEnts = null;
		}
	}

	public ArcadeGame Copy()
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		CopyTo(arcadeGame);
		return arcadeGame;
	}

	public static ArcadeGame Deserialize(BufferStream stream)
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		Deserialize(stream, arcadeGame, isDelta: false);
		return arcadeGame;
	}

	public static ArcadeGame DeserializeLengthDelimited(BufferStream stream)
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		DeserializeLengthDelimited(stream, arcadeGame, isDelta: false);
		return arcadeGame;
	}

	public static ArcadeGame DeserializeLength(BufferStream stream, int length)
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		DeserializeLength(stream, length, arcadeGame, isDelta: false);
		return arcadeGame;
	}

	public static ArcadeGame Deserialize(byte[] buffer)
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, arcadeGame, isDelta: false);
		return arcadeGame;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ArcadeGame previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ArcadeGame Deserialize(BufferStream stream, ArcadeGame instance, bool isDelta)
	{
		if (!isDelta && instance.arcadeEnts == null)
		{
			instance.arcadeEnts = Pool.Get<List<arcadeEnt>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.arcadeEnts.Add(arcadeEnt.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ArcadeGame DeserializeLengthDelimited(BufferStream stream, ArcadeGame instance, bool isDelta)
	{
		if (!isDelta && instance.arcadeEnts == null)
		{
			instance.arcadeEnts = Pool.Get<List<arcadeEnt>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.arcadeEnts.Add(arcadeEnt.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ArcadeGame DeserializeLength(BufferStream stream, int length, ArcadeGame instance, bool isDelta)
	{
		if (!isDelta && instance.arcadeEnts == null)
		{
			instance.arcadeEnts = Pool.Get<List<arcadeEnt>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.arcadeEnts.Add(arcadeEnt.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ArcadeGame instance, ArcadeGame previous)
	{
		if (instance.arcadeEnts == null)
		{
			return;
		}
		for (int i = 0; i < instance.arcadeEnts.Count; i++)
		{
			arcadeEnt arcadeEnt = instance.arcadeEnts[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			arcadeEnt.SerializeDelta(stream, arcadeEnt, arcadeEnt);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ArcadeGame instance)
	{
		if (instance.arcadeEnts == null)
		{
			return;
		}
		for (int i = 0; i < instance.arcadeEnts.Count; i++)
		{
			arcadeEnt instance2 = instance.arcadeEnts[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			arcadeEnt.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (arcadeEnts != null)
		{
			for (int i = 0; i < arcadeEnts.Count; i++)
			{
				arcadeEnts[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PhoneDirectory : IDisposable, IPooled, IProto<PhoneDirectory>, IProto
{
	public class DirectoryEntry : IDisposable, IPooled, IProto<DirectoryEntry>, IProto
	{
		[NonSerialized]
		public int phoneNumber;

		[NonSerialized]
		public string phoneName;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(DirectoryEntry instance)
		{
			if (instance.ShouldPool)
			{
				instance.phoneNumber = 0;
				instance.phoneName = string.Empty;
				Pool.Free<DirectoryEntry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose DirectoryEntry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(DirectoryEntry instance)
		{
			instance.phoneNumber = phoneNumber;
			instance.phoneName = phoneName;
		}

		public DirectoryEntry Copy()
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			CopyTo(directoryEntry);
			return directoryEntry;
		}

		public static DirectoryEntry Deserialize(BufferStream stream)
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			Deserialize(stream, directoryEntry, isDelta: false);
			return directoryEntry;
		}

		public static DirectoryEntry DeserializeLengthDelimited(BufferStream stream)
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			DeserializeLengthDelimited(stream, directoryEntry, isDelta: false);
			return directoryEntry;
		}

		public static DirectoryEntry DeserializeLength(BufferStream stream, int length)
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			DeserializeLength(stream, length, directoryEntry, isDelta: false);
			return directoryEntry;
		}

		public static DirectoryEntry Deserialize(byte[] buffer)
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, directoryEntry, isDelta: false);
			return directoryEntry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, DirectoryEntry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static DirectoryEntry Deserialize(BufferStream stream, DirectoryEntry instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.phoneName = ProtocolParser.ReadString(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static DirectoryEntry DeserializeLengthDelimited(BufferStream stream, DirectoryEntry instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.phoneName = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static DirectoryEntry DeserializeLength(BufferStream stream, int length, DirectoryEntry instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.phoneName = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, DirectoryEntry instance, DirectoryEntry previous)
		{
			if (instance.phoneNumber != previous.phoneNumber)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
			}
			if (instance.phoneName != previous.phoneName)
			{
				if (instance.phoneName == null)
				{
					throw new ArgumentNullException("phoneName", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.phoneName);
			}
		}

		public static void Serialize(BufferStream stream, DirectoryEntry instance)
		{
			if (instance.phoneNumber != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
			}
			if (instance.phoneName == null)
			{
				throw new ArgumentNullException("phoneName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<DirectoryEntry> entries;

	[NonSerialized]
	public bool atEnd;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PhoneDirectory instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entries != null)
		{
			for (int i = 0; i < instance.entries.Count; i++)
			{
				if (instance.entries[i] != null)
				{
					instance.entries[i].ResetToPool();
					instance.entries[i] = null;
				}
			}
			List<DirectoryEntry> list = instance.entries;
			Pool.Free<DirectoryEntry>(ref list, false);
			instance.entries = list;
		}
		instance.atEnd = false;
		Pool.Free<PhoneDirectory>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PhoneDirectory with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PhoneDirectory instance)
	{
		if (entries != null)
		{
			instance.entries = Pool.Get<List<DirectoryEntry>>();
			for (int i = 0; i < entries.Count; i++)
			{
				DirectoryEntry item = entries[i].Copy();
				instance.entries.Add(item);
			}
		}
		else
		{
			instance.entries = null;
		}
		instance.atEnd = atEnd;
	}

	public PhoneDirectory Copy()
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		CopyTo(phoneDirectory);
		return phoneDirectory;
	}

	public static PhoneDirectory Deserialize(BufferStream stream)
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		Deserialize(stream, phoneDirectory, isDelta: false);
		return phoneDirectory;
	}

	public static PhoneDirectory DeserializeLengthDelimited(BufferStream stream)
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		DeserializeLengthDelimited(stream, phoneDirectory, isDelta: false);
		return phoneDirectory;
	}

	public static PhoneDirectory DeserializeLength(BufferStream stream, int length)
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		DeserializeLength(stream, length, phoneDirectory, isDelta: false);
		return phoneDirectory;
	}

	public static PhoneDirectory Deserialize(byte[] buffer)
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, phoneDirectory, isDelta: false);
		return phoneDirectory;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PhoneDirectory previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PhoneDirectory Deserialize(BufferStream stream, PhoneDirectory instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<DirectoryEntry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entries.Add(DirectoryEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.atEnd = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PhoneDirectory DeserializeLengthDelimited(BufferStream stream, PhoneDirectory instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<DirectoryEntry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entries.Add(DirectoryEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.atEnd = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PhoneDirectory DeserializeLength(BufferStream stream, int length, PhoneDirectory instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<DirectoryEntry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entries.Add(DirectoryEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.atEnd = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PhoneDirectory instance, PhoneDirectory previous)
	{
		if (instance.entries != null)
		{
			for (int i = 0; i < instance.entries.Count; i++)
			{
				DirectoryEntry directoryEntry = instance.entries[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				DirectoryEntry.SerializeDelta(stream, directoryEntry, directoryEntry);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.atEnd);
	}

	public static void Serialize(BufferStream stream, PhoneDirectory instance)
	{
		if (instance.entries != null)
		{
			for (int i = 0; i < instance.entries.Count; i++)
			{
				DirectoryEntry instance2 = instance.entries[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				DirectoryEntry.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.atEnd)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.atEnd);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entries != null)
		{
			for (int i = 0; i < entries.Count; i++)
			{
				entries[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class EntityIdList : IDisposable, IPooled, IProto<EntityIdList>, IProto
{
	[NonSerialized]
	public List<NetworkableId> entityIds;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EntityIdList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.entityIds != null)
			{
				List<NetworkableId> list = instance.entityIds;
				Pool.FreeUnmanaged<NetworkableId>(ref list);
				instance.entityIds = list;
			}
			Pool.Free<EntityIdList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EntityIdList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EntityIdList instance)
	{
		if (entityIds != null)
		{
			instance.entityIds = Pool.Get<List<NetworkableId>>();
			for (int i = 0; i < entityIds.Count; i++)
			{
				NetworkableId item = entityIds[i];
				instance.entityIds.Add(item);
			}
		}
		else
		{
			instance.entityIds = null;
		}
	}

	public EntityIdList Copy()
	{
		EntityIdList entityIdList = Pool.Get<EntityIdList>();
		CopyTo(entityIdList);
		return entityIdList;
	}

	public static EntityIdList Deserialize(BufferStream stream)
	{
		EntityIdList entityIdList = Pool.Get<EntityIdList>();
		Deserialize(stream, entityIdList, isDelta: false);
		return entityIdList;
	}

	public static EntityIdList DeserializeLengthDelimited(BufferStream stream)
	{
		EntityIdList entityIdList = Pool.Get<EntityIdList>();
		DeserializeLengthDelimited(stream, entityIdList, isDelta: false);
		return entityIdList;
	}

	public static EntityIdList DeserializeLength(BufferStream stream, int length)
	{
		EntityIdList entityIdList = Pool.Get<EntityIdList>();
		DeserializeLength(stream, length, entityIdList, isDelta: false);
		return entityIdList;
	}

	public static EntityIdList Deserialize(byte[] buffer)
	{
		EntityIdList entityIdList = Pool.Get<EntityIdList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entityIdList, isDelta: false);
		return entityIdList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EntityIdList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EntityIdList Deserialize(BufferStream stream, EntityIdList instance, bool isDelta)
	{
		if (!isDelta && instance.entityIds == null)
		{
			instance.entityIds = Pool.Get<List<NetworkableId>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EntityIdList DeserializeLengthDelimited(BufferStream stream, EntityIdList instance, bool isDelta)
	{
		if (!isDelta && instance.entityIds == null)
		{
			instance.entityIds = Pool.Get<List<NetworkableId>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EntityIdList DeserializeLength(BufferStream stream, int length, EntityIdList instance, bool isDelta)
	{
		if (!isDelta && instance.entityIds == null)
		{
			instance.entityIds = Pool.Get<List<NetworkableId>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EntityIdList instance, EntityIdList previous)
	{
		if (instance.entityIds != null)
		{
			for (int i = 0; i < instance.entityIds.Count; i++)
			{
				NetworkableId networkableId = instance.entityIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public static void Serialize(BufferStream stream, EntityIdList instance)
	{
		if (instance.entityIds != null)
		{
			for (int i = 0; i < instance.entityIds.Count; i++)
			{
				NetworkableId networkableId = instance.entityIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < entityIds.Count; i++)
		{
			NetworkableId value = entityIds[i];
			action(UidType.NetworkableId, ref value.Value);
			entityIds[i] = value;
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class RadioList : IDisposable, IPooled, IProto<RadioList>, IProto
{
	[NonSerialized]
	public List<string> stationUrls;

	[NonSerialized]
	public List<string> stationNames;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RadioList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.stationUrls != null)
			{
				List<string> list = instance.stationUrls;
				Pool.FreeUnmanaged<string>(ref list);
				instance.stationUrls = list;
			}
			if (instance.stationNames != null)
			{
				List<string> list2 = instance.stationNames;
				Pool.FreeUnmanaged<string>(ref list2);
				instance.stationNames = list2;
			}
			Pool.Free<RadioList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RadioList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RadioList instance)
	{
		if (stationUrls != null)
		{
			instance.stationUrls = Pool.Get<List<string>>();
			for (int i = 0; i < stationUrls.Count; i++)
			{
				string item = stationUrls[i];
				instance.stationUrls.Add(item);
			}
		}
		else
		{
			instance.stationUrls = null;
		}
		if (stationNames != null)
		{
			instance.stationNames = Pool.Get<List<string>>();
			for (int j = 0; j < stationNames.Count; j++)
			{
				string item2 = stationNames[j];
				instance.stationNames.Add(item2);
			}
		}
		else
		{
			instance.stationNames = null;
		}
	}

	public RadioList Copy()
	{
		RadioList radioList = Pool.Get<RadioList>();
		CopyTo(radioList);
		return radioList;
	}

	public static RadioList Deserialize(BufferStream stream)
	{
		RadioList radioList = Pool.Get<RadioList>();
		Deserialize(stream, radioList, isDelta: false);
		return radioList;
	}

	public static RadioList DeserializeLengthDelimited(BufferStream stream)
	{
		RadioList radioList = Pool.Get<RadioList>();
		DeserializeLengthDelimited(stream, radioList, isDelta: false);
		return radioList;
	}

	public static RadioList DeserializeLength(BufferStream stream, int length)
	{
		RadioList radioList = Pool.Get<RadioList>();
		DeserializeLength(stream, length, radioList, isDelta: false);
		return radioList;
	}

	public static RadioList Deserialize(byte[] buffer)
	{
		RadioList radioList = Pool.Get<RadioList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, radioList, isDelta: false);
		return radioList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RadioList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RadioList Deserialize(BufferStream stream, RadioList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.stationUrls == null)
			{
				instance.stationUrls = Pool.Get<List<string>>();
			}
			if (instance.stationNames == null)
			{
				instance.stationNames = Pool.Get<List<string>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.stationUrls.Add(ProtocolParser.ReadString(stream));
				continue;
			case 18:
				instance.stationNames.Add(ProtocolParser.ReadString(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RadioList DeserializeLengthDelimited(BufferStream stream, RadioList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.stationUrls == null)
			{
				instance.stationUrls = Pool.Get<List<string>>();
			}
			if (instance.stationNames == null)
			{
				instance.stationNames = Pool.Get<List<string>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.stationUrls.Add(ProtocolParser.ReadString(stream));
				continue;
			case 18:
				instance.stationNames.Add(ProtocolParser.ReadString(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RadioList DeserializeLength(BufferStream stream, int length, RadioList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.stationUrls == null)
			{
				instance.stationUrls = Pool.Get<List<string>>();
			}
			if (instance.stationNames == null)
			{
				instance.stationNames = Pool.Get<List<string>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.stationUrls.Add(ProtocolParser.ReadString(stream));
				continue;
			case 18:
				instance.stationNames.Add(ProtocolParser.ReadString(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RadioList instance, RadioList previous)
	{
		if (instance.stationUrls != null)
		{
			for (int i = 0; i < instance.stationUrls.Count; i++)
			{
				string val = instance.stationUrls[i];
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.stationNames != null)
		{
			for (int j = 0; j < instance.stationNames.Count; j++)
			{
				string val2 = instance.stationNames[j];
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, val2);
			}
		}
	}

	public static void Serialize(BufferStream stream, RadioList instance)
	{
		if (instance.stationUrls != null)
		{
			for (int i = 0; i < instance.stationUrls.Count; i++)
			{
				string val = instance.stationUrls[i];
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.stationNames != null)
		{
			for (int j = 0; j < instance.stationNames.Count; j++)
			{
				string val2 = instance.stationNames[j];
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, val2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ItemAmountList : IDisposable, IPooled, IProto<ItemAmountList>, IProto
{
	[NonSerialized]
	public List<int> itemID;

	[NonSerialized]
	public List<float> amount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemAmountList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.itemID != null)
			{
				List<int> list = instance.itemID;
				Pool.FreeUnmanaged<int>(ref list);
				instance.itemID = list;
			}
			if (instance.amount != null)
			{
				List<float> list2 = instance.amount;
				Pool.FreeUnmanaged<float>(ref list2);
				instance.amount = list2;
			}
			Pool.Free<ItemAmountList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemAmountList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemAmountList instance)
	{
		if (itemID != null)
		{
			instance.itemID = Pool.Get<List<int>>();
			for (int i = 0; i < itemID.Count; i++)
			{
				int item = itemID[i];
				instance.itemID.Add(item);
			}
		}
		else
		{
			instance.itemID = null;
		}
		if (amount != null)
		{
			instance.amount = Pool.Get<List<float>>();
			for (int j = 0; j < amount.Count; j++)
			{
				float item2 = amount[j];
				instance.amount.Add(item2);
			}
		}
		else
		{
			instance.amount = null;
		}
	}

	public ItemAmountList Copy()
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		CopyTo(itemAmountList);
		return itemAmountList;
	}

	public static ItemAmountList Deserialize(BufferStream stream)
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		Deserialize(stream, itemAmountList, isDelta: false);
		return itemAmountList;
	}

	public static ItemAmountList DeserializeLengthDelimited(BufferStream stream)
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		DeserializeLengthDelimited(stream, itemAmountList, isDelta: false);
		return itemAmountList;
	}

	public static ItemAmountList DeserializeLength(BufferStream stream, int length)
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		DeserializeLength(stream, length, itemAmountList, isDelta: false);
		return itemAmountList;
	}

	public static ItemAmountList Deserialize(byte[] buffer)
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemAmountList, isDelta: false);
		return itemAmountList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemAmountList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemAmountList Deserialize(BufferStream stream, ItemAmountList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.itemID == null)
			{
				instance.itemID = Pool.Get<List<int>>();
			}
			if (instance.amount == null)
			{
				instance.amount = Pool.Get<List<float>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.amount.Add(ProtocolParser.ReadSingle(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemAmountList DeserializeLengthDelimited(BufferStream stream, ItemAmountList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.itemID == null)
			{
				instance.itemID = Pool.Get<List<int>>();
			}
			if (instance.amount == null)
			{
				instance.amount = Pool.Get<List<float>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.amount.Add(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemAmountList DeserializeLength(BufferStream stream, int length, ItemAmountList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.itemID == null)
			{
				instance.itemID = Pool.Get<List<int>>();
			}
			if (instance.amount == null)
			{
				instance.amount = Pool.Get<List<float>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.amount.Add(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemAmountList instance, ItemAmountList previous)
	{
		if (instance.itemID != null)
		{
			for (int i = 0; i < instance.itemID.Count; i++)
			{
				int num = instance.itemID[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.amount != null)
		{
			for (int j = 0; j < instance.amount.Count; j++)
			{
				float f = instance.amount[j];
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public static void Serialize(BufferStream stream, ItemAmountList instance)
	{
		if (instance.itemID != null)
		{
			for (int i = 0; i < instance.itemID.Count; i++)
			{
				int num = instance.itemID[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.amount != null)
		{
			for (int j = 0; j < instance.amount.Count; j++)
			{
				float f = instance.amount[j];
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class WireReconnectMessage : IDisposable, IPooled, IProto<WireReconnectMessage>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public int slotIndex;

	[NonSerialized]
	public bool isInput;

	[NonSerialized]
	public List<Vector3> linePoints;

	[NonSerialized]
	public int wireColor;

	[NonSerialized]
	public List<WireLineAnchorInfo> lineAnchors;

	[NonSerialized]
	public List<float> slackLevels;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WireReconnectMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.entityId = default(NetworkableId);
		instance.slotIndex = 0;
		instance.isInput = false;
		if (instance.linePoints != null)
		{
			List<Vector3> list = instance.linePoints;
			Pool.FreeUnmanaged<Vector3>(ref list);
			instance.linePoints = list;
		}
		instance.wireColor = 0;
		if (instance.lineAnchors != null)
		{
			for (int i = 0; i < instance.lineAnchors.Count; i++)
			{
				if (instance.lineAnchors[i] != null)
				{
					instance.lineAnchors[i].ResetToPool();
					instance.lineAnchors[i] = null;
				}
			}
			List<WireLineAnchorInfo> list2 = instance.lineAnchors;
			Pool.Free<WireLineAnchorInfo>(ref list2, false);
			instance.lineAnchors = list2;
		}
		if (instance.slackLevels != null)
		{
			List<float> list3 = instance.slackLevels;
			Pool.FreeUnmanaged<float>(ref list3);
			instance.slackLevels = list3;
		}
		Pool.Free<WireReconnectMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WireReconnectMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WireReconnectMessage instance)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		instance.entityId = entityId;
		instance.slotIndex = slotIndex;
		instance.isInput = isInput;
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<Vector3>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				Vector3 item = linePoints[i];
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
		instance.wireColor = wireColor;
		if (lineAnchors != null)
		{
			instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			for (int j = 0; j < lineAnchors.Count; j++)
			{
				WireLineAnchorInfo item2 = lineAnchors[j].Copy();
				instance.lineAnchors.Add(item2);
			}
		}
		else
		{
			instance.lineAnchors = null;
		}
		if (slackLevels != null)
		{
			instance.slackLevels = Pool.Get<List<float>>();
			for (int k = 0; k < slackLevels.Count; k++)
			{
				float item3 = slackLevels[k];
				instance.slackLevels.Add(item3);
			}
		}
		else
		{
			instance.slackLevels = null;
		}
	}

	public WireReconnectMessage Copy()
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		CopyTo(wireReconnectMessage);
		return wireReconnectMessage;
	}

	public static WireReconnectMessage Deserialize(BufferStream stream)
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		Deserialize(stream, wireReconnectMessage, isDelta: false);
		return wireReconnectMessage;
	}

	public static WireReconnectMessage DeserializeLengthDelimited(BufferStream stream)
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		DeserializeLengthDelimited(stream, wireReconnectMessage, isDelta: false);
		return wireReconnectMessage;
	}

	public static WireReconnectMessage DeserializeLength(BufferStream stream, int length)
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		DeserializeLength(stream, length, wireReconnectMessage, isDelta: false);
		return wireReconnectMessage;
	}

	public static WireReconnectMessage Deserialize(byte[] buffer)
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wireReconnectMessage, isDelta: false);
		return wireReconnectMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WireReconnectMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WireReconnectMessage Deserialize(BufferStream stream, WireReconnectMessage instance, bool isDelta)
	{
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.isInput = ProtocolParser.ReadBool(stream);
				break;
			case 34:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 40:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 50:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 61:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static WireReconnectMessage DeserializeLengthDelimited(BufferStream stream, WireReconnectMessage instance, bool isDelta)
	{
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.isInput = ProtocolParser.ReadBool(stream);
				break;
			case 34:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 40:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 50:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 61:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WireReconnectMessage DeserializeLength(BufferStream stream, int length, WireReconnectMessage instance, bool isDelta)
	{
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.isInput = ProtocolParser.ReadBool(stream);
				break;
			case 34:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 40:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 50:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 61:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WireReconnectMessage instance, WireReconnectMessage previous)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		if (instance.slotIndex != previous.slotIndex)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.isInput);
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				Vector3 val = instance.linePoints[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.wireColor != previous.wireColor)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wireColor);
		}
		if (instance.lineAnchors != null)
		{
			for (int j = 0; j < instance.lineAnchors.Count; j++)
			{
				WireLineAnchorInfo wireLineAnchorInfo = instance.lineAnchors[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WireLineAnchorInfo.SerializeDelta(stream, wireLineAnchorInfo, wireLineAnchorInfo);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(61);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public static void Serialize(BufferStream stream, WireReconnectMessage instance)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.slotIndex != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
		}
		if (instance.isInput)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.isInput);
		}
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				Vector3 instance2 = instance.linePoints[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.wireColor != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wireColor);
		}
		if (instance.lineAnchors != null)
		{
			for (int j = 0; j < instance.lineAnchors.Count; j++)
			{
				WireLineAnchorInfo instance3 = instance.lineAnchors[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WireLineAnchorInfo.Serialize(stream, instance3);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(61);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
		if (lineAnchors != null)
		{
			for (int i = 0; i < lineAnchors.Count; i++)
			{
				lineAnchors[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class WireLineAnchorInfo : IDisposable, IPooled, IProto<WireLineAnchorInfo>, IProto
{
	[NonSerialized]
	public NetworkableId parentID;

	[NonSerialized]
	public string boneName;

	[NonSerialized]
	public long index;

	[NonSerialized]
	public Vector3 position;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WireLineAnchorInfo instance)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.parentID = default(NetworkableId);
			instance.boneName = string.Empty;
			instance.index = 0L;
			instance.position = default(Vector3);
			Pool.Free<WireLineAnchorInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WireLineAnchorInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WireLineAnchorInfo instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.parentID = parentID;
		instance.boneName = boneName;
		instance.index = index;
		instance.position = position;
	}

	public WireLineAnchorInfo Copy()
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		CopyTo(wireLineAnchorInfo);
		return wireLineAnchorInfo;
	}

	public static WireLineAnchorInfo Deserialize(BufferStream stream)
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		Deserialize(stream, wireLineAnchorInfo, isDelta: false);
		return wireLineAnchorInfo;
	}

	public static WireLineAnchorInfo DeserializeLengthDelimited(BufferStream stream)
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		DeserializeLengthDelimited(stream, wireLineAnchorInfo, isDelta: false);
		return wireLineAnchorInfo;
	}

	public static WireLineAnchorInfo DeserializeLength(BufferStream stream, int length)
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		DeserializeLength(stream, length, wireLineAnchorInfo, isDelta: false);
		return wireLineAnchorInfo;
	}

	public static WireLineAnchorInfo Deserialize(byte[] buffer)
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wireLineAnchorInfo, isDelta: false);
		return wireLineAnchorInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WireLineAnchorInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WireLineAnchorInfo Deserialize(BufferStream stream, WireLineAnchorInfo instance, bool isDelta)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.boneName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.index = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WireLineAnchorInfo DeserializeLengthDelimited(BufferStream stream, WireLineAnchorInfo instance, bool isDelta)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.boneName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.index = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WireLineAnchorInfo DeserializeLength(BufferStream stream, int length, WireLineAnchorInfo instance, bool isDelta)
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.boneName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.index = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WireLineAnchorInfo instance, WireLineAnchorInfo previous)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		if (instance.boneName != previous.boneName)
		{
			if (instance.boneName == null)
			{
				throw new ArgumentNullException("boneName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.boneName);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		if (instance.position != previous.position)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, WireLineAnchorInfo instance)
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.parentID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		}
		if (instance.boneName == null)
		{
			throw new ArgumentNullException("boneName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.boneName);
		if (instance.index != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref parentID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class WireConnectionMessage : IDisposable, IPooled, IProto<WireConnectionMessage>, IProto
{
	[NonSerialized]
	public List<Vector3> linePoints;

	[NonSerialized]
	public List<WireLineAnchorInfo> lineAnchors;

	[NonSerialized]
	public NetworkableId inputID;

	[NonSerialized]
	public int inputIndex;

	[NonSerialized]
	public NetworkableId outputID;

	[NonSerialized]
	public int outputIndex;

	[NonSerialized]
	public int wireColor;

	[NonSerialized]
	public List<float> slackLevels;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WireConnectionMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.linePoints != null)
		{
			List<Vector3> list = instance.linePoints;
			Pool.FreeUnmanaged<Vector3>(ref list);
			instance.linePoints = list;
		}
		if (instance.lineAnchors != null)
		{
			for (int i = 0; i < instance.lineAnchors.Count; i++)
			{
				if (instance.lineAnchors[i] != null)
				{
					instance.lineAnchors[i].ResetToPool();
					instance.lineAnchors[i] = null;
				}
			}
			List<WireLineAnchorInfo> list2 = instance.lineAnchors;
			Pool.Free<WireLineAnchorInfo>(ref list2, false);
			instance.lineAnchors = list2;
		}
		instance.inputID = default(NetworkableId);
		instance.inputIndex = 0;
		instance.outputID = default(NetworkableId);
		instance.outputIndex = 0;
		instance.wireColor = 0;
		if (instance.slackLevels != null)
		{
			List<float> list3 = instance.slackLevels;
			Pool.FreeUnmanaged<float>(ref list3);
			instance.slackLevels = list3;
		}
		Pool.Free<WireConnectionMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WireConnectionMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WireConnectionMessage instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<Vector3>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				Vector3 item = linePoints[i];
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
		if (lineAnchors != null)
		{
			instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			for (int j = 0; j < lineAnchors.Count; j++)
			{
				WireLineAnchorInfo item2 = lineAnchors[j].Copy();
				instance.lineAnchors.Add(item2);
			}
		}
		else
		{
			instance.lineAnchors = null;
		}
		instance.inputID = inputID;
		instance.inputIndex = inputIndex;
		instance.outputID = outputID;
		instance.outputIndex = outputIndex;
		instance.wireColor = wireColor;
		if (slackLevels != null)
		{
			instance.slackLevels = Pool.Get<List<float>>();
			for (int k = 0; k < slackLevels.Count; k++)
			{
				float item3 = slackLevels[k];
				instance.slackLevels.Add(item3);
			}
		}
		else
		{
			instance.slackLevels = null;
		}
	}

	public WireConnectionMessage Copy()
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		CopyTo(wireConnectionMessage);
		return wireConnectionMessage;
	}

	public static WireConnectionMessage Deserialize(BufferStream stream)
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		Deserialize(stream, wireConnectionMessage, isDelta: false);
		return wireConnectionMessage;
	}

	public static WireConnectionMessage DeserializeLengthDelimited(BufferStream stream)
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		DeserializeLengthDelimited(stream, wireConnectionMessage, isDelta: false);
		return wireConnectionMessage;
	}

	public static WireConnectionMessage DeserializeLength(BufferStream stream, int length)
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		DeserializeLength(stream, length, wireConnectionMessage, isDelta: false);
		return wireConnectionMessage;
	}

	public static WireConnectionMessage Deserialize(byte[] buffer)
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wireConnectionMessage, isDelta: false);
		return wireConnectionMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WireConnectionMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WireConnectionMessage Deserialize(BufferStream stream, WireConnectionMessage instance, bool isDelta)
	{
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 18:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 24:
				instance.inputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 32:
				instance.inputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.outputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 48:
				instance.outputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 69:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static WireConnectionMessage DeserializeLengthDelimited(BufferStream stream, WireConnectionMessage instance, bool isDelta)
	{
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 18:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 24:
				instance.inputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 32:
				instance.inputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.outputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 48:
				instance.outputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 69:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WireConnectionMessage DeserializeLength(BufferStream stream, int length, WireConnectionMessage instance, bool isDelta)
	{
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 18:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 24:
				instance.inputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 32:
				instance.inputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.outputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 48:
				instance.outputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 69:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WireConnectionMessage instance, WireConnectionMessage previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				Vector3 val = instance.linePoints[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.lineAnchors != null)
		{
			for (int j = 0; j < instance.lineAnchors.Count; j++)
			{
				WireLineAnchorInfo wireLineAnchorInfo = instance.lineAnchors[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WireLineAnchorInfo.SerializeDelta(stream, wireLineAnchorInfo, wireLineAnchorInfo);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.inputID.Value);
		if (instance.inputIndex != previous.inputIndex)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputIndex);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.outputID.Value);
		if (instance.outputIndex != previous.outputIndex)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.outputIndex);
		}
		if (instance.wireColor != previous.wireColor)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wireColor);
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public static void Serialize(BufferStream stream, WireConnectionMessage instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				Vector3 instance2 = instance.linePoints[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.lineAnchors != null)
		{
			for (int j = 0; j < instance.lineAnchors.Count; j++)
			{
				WireLineAnchorInfo instance3 = instance.lineAnchors[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WireLineAnchorInfo.Serialize(stream, instance3);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.inputID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.inputID.Value);
		}
		if (instance.inputIndex != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputIndex);
		}
		if (instance.outputID != default(NetworkableId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.outputID.Value);
		}
		if (instance.outputIndex != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.outputIndex);
		}
		if (instance.wireColor != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wireColor);
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (lineAnchors != null)
		{
			for (int i = 0; i < lineAnchors.Count; i++)
			{
				lineAnchors[i]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref inputID.Value);
		action(UidType.NetworkableId, ref outputID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class OceanPaths : IDisposable, IPooled, IProto<OceanPaths>, IProto
{
	[NonSerialized]
	public List<Vector3> cargoPatrolPath;

	[NonSerialized]
	public List<VectorList> harborApproaches;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(OceanPaths instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.cargoPatrolPath != null)
		{
			List<Vector3> list = instance.cargoPatrolPath;
			Pool.FreeUnmanaged<Vector3>(ref list);
			instance.cargoPatrolPath = list;
		}
		if (instance.harborApproaches != null)
		{
			for (int i = 0; i < instance.harborApproaches.Count; i++)
			{
				if (instance.harborApproaches[i] != null)
				{
					instance.harborApproaches[i].ResetToPool();
					instance.harborApproaches[i] = null;
				}
			}
			List<VectorList> list2 = instance.harborApproaches;
			Pool.Free<VectorList>(ref list2, false);
			instance.harborApproaches = list2;
		}
		Pool.Free<OceanPaths>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose OceanPaths with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(OceanPaths instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (cargoPatrolPath != null)
		{
			instance.cargoPatrolPath = Pool.Get<List<Vector3>>();
			for (int i = 0; i < cargoPatrolPath.Count; i++)
			{
				Vector3 item = cargoPatrolPath[i];
				instance.cargoPatrolPath.Add(item);
			}
		}
		else
		{
			instance.cargoPatrolPath = null;
		}
		if (harborApproaches != null)
		{
			instance.harborApproaches = Pool.Get<List<VectorList>>();
			for (int j = 0; j < harborApproaches.Count; j++)
			{
				VectorList item2 = harborApproaches[j].Copy();
				instance.harborApproaches.Add(item2);
			}
		}
		else
		{
			instance.harborApproaches = null;
		}
	}

	public OceanPaths Copy()
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		CopyTo(oceanPaths);
		return oceanPaths;
	}

	public static OceanPaths Deserialize(BufferStream stream)
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		Deserialize(stream, oceanPaths, isDelta: false);
		return oceanPaths;
	}

	public static OceanPaths DeserializeLengthDelimited(BufferStream stream)
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		DeserializeLengthDelimited(stream, oceanPaths, isDelta: false);
		return oceanPaths;
	}

	public static OceanPaths DeserializeLength(BufferStream stream, int length)
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		DeserializeLength(stream, length, oceanPaths, isDelta: false);
		return oceanPaths;
	}

	public static OceanPaths Deserialize(byte[] buffer)
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, oceanPaths, isDelta: false);
		return oceanPaths;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, OceanPaths previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static OceanPaths Deserialize(BufferStream stream, OceanPaths instance, bool isDelta)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.cargoPatrolPath == null)
			{
				instance.cargoPatrolPath = Pool.Get<List<Vector3>>();
			}
			if (instance.harborApproaches == null)
			{
				instance.harborApproaches = Pool.Get<List<VectorList>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.cargoPatrolPath.Add(instance2);
				break;
			}
			case 18:
				instance.harborApproaches.Add(VectorList.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static OceanPaths DeserializeLengthDelimited(BufferStream stream, OceanPaths instance, bool isDelta)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.cargoPatrolPath == null)
			{
				instance.cargoPatrolPath = Pool.Get<List<Vector3>>();
			}
			if (instance.harborApproaches == null)
			{
				instance.harborApproaches = Pool.Get<List<VectorList>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.cargoPatrolPath.Add(instance2);
				break;
			}
			case 18:
				instance.harborApproaches.Add(VectorList.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static OceanPaths DeserializeLength(BufferStream stream, int length, OceanPaths instance, bool isDelta)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.cargoPatrolPath == null)
			{
				instance.cargoPatrolPath = Pool.Get<List<Vector3>>();
			}
			if (instance.harborApproaches == null)
			{
				instance.harborApproaches = Pool.Get<List<VectorList>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.cargoPatrolPath.Add(instance2);
				break;
			}
			case 18:
				instance.harborApproaches.Add(VectorList.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, OceanPaths instance, OceanPaths previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.cargoPatrolPath != null)
		{
			for (int i = 0; i < instance.cargoPatrolPath.Count; i++)
			{
				Vector3 val = instance.cargoPatrolPath[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cargoPatrolPath (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.harborApproaches == null)
		{
			return;
		}
		for (int j = 0; j < instance.harborApproaches.Count; j++)
		{
			VectorList vectorList = instance.harborApproaches[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(3);
			int position2 = stream.Position;
			VectorList.SerializeDelta(stream, vectorList, vectorList);
			int num2 = stream.Position - position2;
			if (num2 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field harborApproaches (ProtoBuf.VectorList)");
			}
			Span<byte> span2 = range2.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			if (num3 < 3)
			{
				span2[num3 - 1] |= 128;
				while (num3 < 2)
				{
					span2[num3++] = 128;
				}
				span2[2] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, OceanPaths instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.cargoPatrolPath != null)
		{
			for (int i = 0; i < instance.cargoPatrolPath.Count; i++)
			{
				Vector3 instance2 = instance.cargoPatrolPath[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cargoPatrolPath (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.harborApproaches == null)
		{
			return;
		}
		for (int j = 0; j < instance.harborApproaches.Count; j++)
		{
			VectorList instance3 = instance.harborApproaches[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(3);
			int position2 = stream.Position;
			VectorList.Serialize(stream, instance3);
			int num2 = stream.Position - position2;
			if (num2 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field harborApproaches (ProtoBuf.VectorList)");
			}
			Span<byte> span2 = range2.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			if (num3 < 3)
			{
				span2[num3 - 1] |= 128;
				while (num3 < 2)
				{
					span2[num3++] = 128;
				}
				span2[2] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (harborApproaches != null)
		{
			for (int i = 0; i < harborApproaches.Count; i++)
			{
				harborApproaches[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class VectorList : IDisposable, IPooled, IProto<VectorList>, IProto
{
	[NonSerialized]
	public List<Vector3> vectorPoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VectorList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.vectorPoints != null)
			{
				List<Vector3> list = instance.vectorPoints;
				Pool.FreeUnmanaged<Vector3>(ref list);
				instance.vectorPoints = list;
			}
			Pool.Free<VectorList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VectorList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VectorList instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (vectorPoints != null)
		{
			instance.vectorPoints = Pool.Get<List<Vector3>>();
			for (int i = 0; i < vectorPoints.Count; i++)
			{
				Vector3 item = vectorPoints[i];
				instance.vectorPoints.Add(item);
			}
		}
		else
		{
			instance.vectorPoints = null;
		}
	}

	public VectorList Copy()
	{
		VectorList vectorList = Pool.Get<VectorList>();
		CopyTo(vectorList);
		return vectorList;
	}

	public static VectorList Deserialize(BufferStream stream)
	{
		VectorList vectorList = Pool.Get<VectorList>();
		Deserialize(stream, vectorList, isDelta: false);
		return vectorList;
	}

	public static VectorList DeserializeLengthDelimited(BufferStream stream)
	{
		VectorList vectorList = Pool.Get<VectorList>();
		DeserializeLengthDelimited(stream, vectorList, isDelta: false);
		return vectorList;
	}

	public static VectorList DeserializeLength(BufferStream stream, int length)
	{
		VectorList vectorList = Pool.Get<VectorList>();
		DeserializeLength(stream, length, vectorList, isDelta: false);
		return vectorList;
	}

	public static VectorList Deserialize(byte[] buffer)
	{
		VectorList vectorList = Pool.Get<VectorList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vectorList, isDelta: false);
		return vectorList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VectorList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VectorList Deserialize(BufferStream stream, VectorList instance, bool isDelta)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.vectorPoints == null)
		{
			instance.vectorPoints = Pool.Get<List<Vector3>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.vectorPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static VectorList DeserializeLengthDelimited(BufferStream stream, VectorList instance, bool isDelta)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.vectorPoints == null)
		{
			instance.vectorPoints = Pool.Get<List<Vector3>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.vectorPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VectorList DeserializeLength(BufferStream stream, int length, VectorList instance, bool isDelta)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.vectorPoints == null)
		{
			instance.vectorPoints = Pool.Get<List<Vector3>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.vectorPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VectorList instance, VectorList previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.vectorPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.vectorPoints.Count; i++)
		{
			Vector3 val = instance.vectorPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, val, val);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vectorPoints (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, VectorList instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.vectorPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.vectorPoints.Count; i++)
		{
			Vector3 instance2 = instance.vectorPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vectorPoints (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DigitalClockMessage : IDisposable, IPooled, IProto<DigitalClockMessage>, IProto
{
	[NonSerialized]
	public List<DigitalClockAlarm> alarms;

	[NonSerialized]
	public bool muted;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DigitalClockMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				if (instance.alarms[i] != null)
				{
					instance.alarms[i].ResetToPool();
					instance.alarms[i] = null;
				}
			}
			List<DigitalClockAlarm> list = instance.alarms;
			Pool.Free<DigitalClockAlarm>(ref list, false);
			instance.alarms = list;
		}
		instance.muted = false;
		Pool.Free<DigitalClockMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DigitalClockMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DigitalClockMessage instance)
	{
		if (alarms != null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
			for (int i = 0; i < alarms.Count; i++)
			{
				DigitalClockAlarm item = alarms[i].Copy();
				instance.alarms.Add(item);
			}
		}
		else
		{
			instance.alarms = null;
		}
		instance.muted = muted;
	}

	public DigitalClockMessage Copy()
	{
		DigitalClockMessage digitalClockMessage = Pool.Get<DigitalClockMessage>();
		CopyTo(digitalClockMessage);
		return digitalClockMessage;
	}

	public static DigitalClockMessage Deserialize(BufferStream stream)
	{
		DigitalClockMessage digitalClockMessage = Pool.Get<DigitalClockMessage>();
		Deserialize(stream, digitalClockMessage, isDelta: false);
		return digitalClockMessage;
	}

	public static DigitalClockMessage DeserializeLengthDelimited(BufferStream stream)
	{
		DigitalClockMessage digitalClockMessage = Pool.Get<DigitalClockMessage>();
		DeserializeLengthDelimited(stream, digitalClockMessage, isDelta: false);
		return digitalClockMessage;
	}

	public static DigitalClockMessage DeserializeLength(BufferStream stream, int length)
	{
		DigitalClockMessage digitalClockMessage = Pool.Get<DigitalClockMessage>();
		DeserializeLength(stream, length, digitalClockMessage, isDelta: false);
		return digitalClockMessage;
	}

	public static DigitalClockMessage Deserialize(byte[] buffer)
	{
		DigitalClockMessage digitalClockMessage = Pool.Get<DigitalClockMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, digitalClockMessage, isDelta: false);
		return digitalClockMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DigitalClockMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DigitalClockMessage Deserialize(BufferStream stream, DigitalClockMessage instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DigitalClockMessage DeserializeLengthDelimited(BufferStream stream, DigitalClockMessage instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DigitalClockMessage DeserializeLength(BufferStream stream, int length, DigitalClockMessage instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DigitalClockMessage instance, DigitalClockMessage previous)
	{
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				DigitalClockAlarm digitalClockAlarm = instance.alarms[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				DigitalClockAlarm.SerializeDelta(stream, digitalClockAlarm, digitalClockAlarm);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field alarms (ProtoBuf.DigitalClockAlarm)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.muted);
	}

	public static void Serialize(BufferStream stream, DigitalClockMessage instance)
	{
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				DigitalClockAlarm instance2 = instance.alarms[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				DigitalClockAlarm.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field alarms (ProtoBuf.DigitalClockAlarm)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.muted)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.muted);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (alarms != null)
		{
			for (int i = 0; i < alarms.Count; i++)
			{
				alarms[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DigitalClockAlarm : IDisposable, IPooled, IProto<DigitalClockAlarm>, IProto
{
	[NonSerialized]
	public float time;

	[NonSerialized]
	public bool active;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DigitalClockAlarm instance)
	{
		if (instance.ShouldPool)
		{
			instance.time = 0f;
			instance.active = false;
			Pool.Free<DigitalClockAlarm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DigitalClockAlarm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DigitalClockAlarm instance)
	{
		instance.time = time;
		instance.active = active;
	}

	public DigitalClockAlarm Copy()
	{
		DigitalClockAlarm digitalClockAlarm = Pool.Get<DigitalClockAlarm>();
		CopyTo(digitalClockAlarm);
		return digitalClockAlarm;
	}

	public static DigitalClockAlarm Deserialize(BufferStream stream)
	{
		DigitalClockAlarm digitalClockAlarm = Pool.Get<DigitalClockAlarm>();
		Deserialize(stream, digitalClockAlarm, isDelta: false);
		return digitalClockAlarm;
	}

	public static DigitalClockAlarm DeserializeLengthDelimited(BufferStream stream)
	{
		DigitalClockAlarm digitalClockAlarm = Pool.Get<DigitalClockAlarm>();
		DeserializeLengthDelimited(stream, digitalClockAlarm, isDelta: false);
		return digitalClockAlarm;
	}

	public static DigitalClockAlarm DeserializeLength(BufferStream stream, int length)
	{
		DigitalClockAlarm digitalClockAlarm = Pool.Get<DigitalClockAlarm>();
		DeserializeLength(stream, length, digitalClockAlarm, isDelta: false);
		return digitalClockAlarm;
	}

	public static DigitalClockAlarm Deserialize(byte[] buffer)
	{
		DigitalClockAlarm digitalClockAlarm = Pool.Get<DigitalClockAlarm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, digitalClockAlarm, isDelta: false);
		return digitalClockAlarm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DigitalClockAlarm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DigitalClockAlarm Deserialize(BufferStream stream, DigitalClockAlarm instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.active = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DigitalClockAlarm DeserializeLengthDelimited(BufferStream stream, DigitalClockAlarm instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.active = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DigitalClockAlarm DeserializeLength(BufferStream stream, int length, DigitalClockAlarm instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.active = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DigitalClockAlarm instance, DigitalClockAlarm previous)
	{
		if (instance.time != previous.time)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.active);
	}

	public static void Serialize(BufferStream stream, DigitalClockAlarm instance)
	{
		if (instance.time != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.active)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.active);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class VDDrawEntry : IDisposable, IPooled, IProto<VDDrawEntry>, IProto
{
	public enum Category
	{
		Line,
		Log,
		Text,
		Sphere,
		Box
	}

	[NonSerialized]
	public string entityName;

	[NonSerialized]
	public int frame;

	[NonSerialized]
	public string label;

	[NonSerialized]
	public Category category;

	[NonSerialized]
	public Color color;

	[NonSerialized]
	public Vector3 start;

	[NonSerialized]
	public Vector3 end;

	[NonSerialized]
	public float sizeX;

	[NonSerialized]
	public float sizeY;

	[NonSerialized]
	public float sizeZ;

	[NonSerialized]
	public string message;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VDDrawEntry instance)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.entityName = string.Empty;
			instance.frame = 0;
			instance.label = string.Empty;
			instance.category = Category.Line;
			instance.color = default(Color);
			instance.start = default(Vector3);
			instance.end = default(Vector3);
			instance.sizeX = 0f;
			instance.sizeY = 0f;
			instance.sizeZ = 0f;
			instance.message = string.Empty;
			Pool.Free<VDDrawEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VDDrawEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VDDrawEntry instance)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		instance.entityName = entityName;
		instance.frame = frame;
		instance.label = label;
		instance.category = category;
		instance.color = color;
		instance.start = start;
		instance.end = end;
		instance.sizeX = sizeX;
		instance.sizeY = sizeY;
		instance.sizeZ = sizeZ;
		instance.message = message;
	}

	public VDDrawEntry Copy()
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		CopyTo(vDDrawEntry);
		return vDDrawEntry;
	}

	public static VDDrawEntry Deserialize(BufferStream stream)
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		Deserialize(stream, vDDrawEntry, isDelta: false);
		return vDDrawEntry;
	}

	public static VDDrawEntry DeserializeLengthDelimited(BufferStream stream)
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		DeserializeLengthDelimited(stream, vDDrawEntry, isDelta: false);
		return vDDrawEntry;
	}

	public static VDDrawEntry DeserializeLength(BufferStream stream, int length)
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		DeserializeLength(stream, length, vDDrawEntry, isDelta: false);
		return vDDrawEntry;
	}

	public static VDDrawEntry Deserialize(byte[] buffer)
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vDDrawEntry, isDelta: false);
		return vDDrawEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VDDrawEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VDDrawEntry Deserialize(BufferStream stream, VDDrawEntry instance, bool isDelta)
	{
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entityName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.frame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.category = (Category)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.start, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.end, isDelta);
				continue;
			case 69:
				instance.sizeX = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.sizeY = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sizeZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VDDrawEntry DeserializeLengthDelimited(BufferStream stream, VDDrawEntry instance, bool isDelta)
	{
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entityName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.frame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.category = (Category)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.start, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.end, isDelta);
				continue;
			case 69:
				instance.sizeX = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.sizeY = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sizeZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VDDrawEntry DeserializeLength(BufferStream stream, int length, VDDrawEntry instance, bool isDelta)
	{
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entityName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.frame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.category = (Category)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.start, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.end, isDelta);
				continue;
			case 69:
				instance.sizeX = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.sizeY = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sizeZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VDDrawEntry instance, VDDrawEntry previous)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entityName != previous.entityName)
		{
			if (instance.entityName == null)
			{
				throw new ArgumentNullException("entityName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.entityName);
		}
		if (instance.frame != previous.frame)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.frame);
		}
		if (instance.label != previous.label)
		{
			if (instance.label == null)
			{
				throw new ArgumentNullException("label", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.label);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.category);
		if (instance.color != previous.color)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.color, previous.color);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.start != previous.start)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.start, previous.start);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field start (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.end != previous.end)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.end, previous.end);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field end (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.sizeX != previous.sizeX)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.sizeX);
		}
		if (instance.sizeY != previous.sizeY)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.sizeY);
		}
		if (instance.sizeZ != previous.sizeZ)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.sizeZ);
		}
		if (instance.message != null && instance.message != previous.message)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.message);
		}
	}

	public static void Serialize(BufferStream stream, VDDrawEntry instance)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entityName == null)
		{
			throw new ArgumentNullException("entityName", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.entityName);
		if (instance.frame != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.frame);
		}
		if (instance.label == null)
		{
			throw new ArgumentNullException("label", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.label);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.category);
		if (instance.color != default(Color))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ColorSerialized.Serialize(stream, instance.color);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.start != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.start);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field start (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.end != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.end);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field end (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.sizeX != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.sizeX);
		}
		if (instance.sizeY != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.sizeY);
		}
		if (instance.sizeZ != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.sizeZ);
		}
		if (instance.message != null)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.message);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachinePurchaseHistoryEntryMessage : IDisposable, IPooled, IProto<VendingMachinePurchaseHistoryEntryMessage>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public int amount;

	[NonSerialized]
	public int priceID;

	[NonSerialized]
	public int price;

	[NonSerialized]
	public int dateTime;

	[NonSerialized]
	public bool itemIsBp;

	[NonSerialized]
	public bool priceIsBp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachinePurchaseHistoryEntryMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.amount = 0;
			instance.priceID = 0;
			instance.price = 0;
			instance.dateTime = 0;
			instance.itemIsBp = false;
			instance.priceIsBp = false;
			Pool.Free<VendingMachinePurchaseHistoryEntryMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachinePurchaseHistoryEntryMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachinePurchaseHistoryEntryMessage instance)
	{
		instance.itemID = itemID;
		instance.amount = amount;
		instance.priceID = priceID;
		instance.price = price;
		instance.dateTime = dateTime;
		instance.itemIsBp = itemIsBp;
		instance.priceIsBp = priceIsBp;
	}

	public VendingMachinePurchaseHistoryEntryMessage Copy()
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		CopyTo(vendingMachinePurchaseHistoryEntryMessage);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public static VendingMachinePurchaseHistoryEntryMessage Deserialize(BufferStream stream)
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		Deserialize(stream, vendingMachinePurchaseHistoryEntryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public static VendingMachinePurchaseHistoryEntryMessage DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		DeserializeLengthDelimited(stream, vendingMachinePurchaseHistoryEntryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public static VendingMachinePurchaseHistoryEntryMessage DeserializeLength(BufferStream stream, int length)
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		DeserializeLength(stream, length, vendingMachinePurchaseHistoryEntryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public static VendingMachinePurchaseHistoryEntryMessage Deserialize(byte[] buffer)
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachinePurchaseHistoryEntryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachinePurchaseHistoryEntryMessage Deserialize(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.dateTime = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachinePurchaseHistoryEntryMessage DeserializeLengthDelimited(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.dateTime = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachinePurchaseHistoryEntryMessage DeserializeLength(BufferStream stream, int length, VendingMachinePurchaseHistoryEntryMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.dateTime = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage instance, VendingMachinePurchaseHistoryEntryMessage previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.priceID != previous.priceID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.priceID);
		}
		if (instance.price != previous.price)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.price);
		}
		if (instance.dateTime != previous.dateTime)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dateTime);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.itemIsBp);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.priceIsBp);
	}

	public static void Serialize(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.priceID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.priceID);
		}
		if (instance.price != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.price);
		}
		if (instance.dateTime != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dateTime);
		}
		if (instance.itemIsBp)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.itemIsBp);
		}
		if (instance.priceIsBp)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.priceIsBp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachinePurchaseHistoryEntrySmallMessage : IDisposable, IPooled, IProto<VendingMachinePurchaseHistoryEntrySmallMessage>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public int amount;

	[NonSerialized]
	public int priceID;

	[NonSerialized]
	public int price;

	[NonSerialized]
	public bool itemIsBp;

	[NonSerialized]
	public bool priceIsBp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachinePurchaseHistoryEntrySmallMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.amount = 0;
			instance.priceID = 0;
			instance.price = 0;
			instance.itemIsBp = false;
			instance.priceIsBp = false;
			Pool.Free<VendingMachinePurchaseHistoryEntrySmallMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachinePurchaseHistoryEntrySmallMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachinePurchaseHistoryEntrySmallMessage instance)
	{
		instance.itemID = itemID;
		instance.amount = amount;
		instance.priceID = priceID;
		instance.price = price;
		instance.itemIsBp = itemIsBp;
		instance.priceIsBp = priceIsBp;
	}

	public VendingMachinePurchaseHistoryEntrySmallMessage Copy()
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		CopyTo(vendingMachinePurchaseHistoryEntrySmallMessage);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage Deserialize(BufferStream stream)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		Deserialize(stream, vendingMachinePurchaseHistoryEntrySmallMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		DeserializeLengthDelimited(stream, vendingMachinePurchaseHistoryEntrySmallMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage DeserializeLength(BufferStream stream, int length)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		DeserializeLength(stream, length, vendingMachinePurchaseHistoryEntrySmallMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage Deserialize(byte[] buffer)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachinePurchaseHistoryEntrySmallMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage Deserialize(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage DeserializeLengthDelimited(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage DeserializeLength(BufferStream stream, int length, VendingMachinePurchaseHistoryEntrySmallMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage instance, VendingMachinePurchaseHistoryEntrySmallMessage previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.priceID != previous.priceID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.priceID);
		}
		if (instance.price != previous.price)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.price);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.itemIsBp);
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.priceIsBp);
	}

	public static void Serialize(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.priceID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.priceID);
		}
		if (instance.price != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.price);
		}
		if (instance.itemIsBp)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.itemIsBp);
		}
		if (instance.priceIsBp)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.priceIsBp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachinePurchaseHistoryMessage : IDisposable, IPooled, IProto<VendingMachinePurchaseHistoryMessage>, IProto
{
	[NonSerialized]
	public List<VendingMachinePurchaseHistoryEntryMessage> transactions;

	[NonSerialized]
	public List<VendingMachinePurchaseHistoryEntrySmallMessage> smallTransactions;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachinePurchaseHistoryMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.transactions != null)
		{
			for (int i = 0; i < instance.transactions.Count; i++)
			{
				if (instance.transactions[i] != null)
				{
					instance.transactions[i].ResetToPool();
					instance.transactions[i] = null;
				}
			}
			List<VendingMachinePurchaseHistoryEntryMessage> list = instance.transactions;
			Pool.Free<VendingMachinePurchaseHistoryEntryMessage>(ref list, false);
			instance.transactions = list;
		}
		if (instance.smallTransactions != null)
		{
			for (int j = 0; j < instance.smallTransactions.Count; j++)
			{
				if (instance.smallTransactions[j] != null)
				{
					instance.smallTransactions[j].ResetToPool();
					instance.smallTransactions[j] = null;
				}
			}
			List<VendingMachinePurchaseHistoryEntrySmallMessage> list2 = instance.smallTransactions;
			Pool.Free<VendingMachinePurchaseHistoryEntrySmallMessage>(ref list2, false);
			instance.smallTransactions = list2;
		}
		Pool.Free<VendingMachinePurchaseHistoryMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachinePurchaseHistoryMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachinePurchaseHistoryMessage instance)
	{
		if (transactions != null)
		{
			instance.transactions = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			for (int i = 0; i < transactions.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage item = transactions[i].Copy();
				instance.transactions.Add(item);
			}
		}
		else
		{
			instance.transactions = null;
		}
		if (smallTransactions != null)
		{
			instance.smallTransactions = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
			for (int j = 0; j < smallTransactions.Count; j++)
			{
				VendingMachinePurchaseHistoryEntrySmallMessage item2 = smallTransactions[j].Copy();
				instance.smallTransactions.Add(item2);
			}
		}
		else
		{
			instance.smallTransactions = null;
		}
	}

	public VendingMachinePurchaseHistoryMessage Copy()
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		CopyTo(vendingMachinePurchaseHistoryMessage);
		return vendingMachinePurchaseHistoryMessage;
	}

	public static VendingMachinePurchaseHistoryMessage Deserialize(BufferStream stream)
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		Deserialize(stream, vendingMachinePurchaseHistoryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryMessage;
	}

	public static VendingMachinePurchaseHistoryMessage DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		DeserializeLengthDelimited(stream, vendingMachinePurchaseHistoryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryMessage;
	}

	public static VendingMachinePurchaseHistoryMessage DeserializeLength(BufferStream stream, int length)
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		DeserializeLength(stream, length, vendingMachinePurchaseHistoryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryMessage;
	}

	public static VendingMachinePurchaseHistoryMessage Deserialize(byte[] buffer)
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachinePurchaseHistoryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachinePurchaseHistoryMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachinePurchaseHistoryMessage Deserialize(BufferStream stream, VendingMachinePurchaseHistoryMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.transactions == null)
			{
				instance.transactions = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.smallTransactions == null)
			{
				instance.smallTransactions = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.transactions.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.smallTransactions.Add(VendingMachinePurchaseHistoryEntrySmallMessage.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachinePurchaseHistoryMessage DeserializeLengthDelimited(BufferStream stream, VendingMachinePurchaseHistoryMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.transactions == null)
			{
				instance.transactions = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.smallTransactions == null)
			{
				instance.smallTransactions = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.transactions.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.smallTransactions.Add(VendingMachinePurchaseHistoryEntrySmallMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachinePurchaseHistoryMessage DeserializeLength(BufferStream stream, int length, VendingMachinePurchaseHistoryMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.transactions == null)
			{
				instance.transactions = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.smallTransactions == null)
			{
				instance.smallTransactions = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.transactions.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.smallTransactions.Add(VendingMachinePurchaseHistoryEntrySmallMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachinePurchaseHistoryMessage instance, VendingMachinePurchaseHistoryMessage previous)
	{
		if (instance.transactions != null)
		{
			for (int i = 0; i < instance.transactions.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = instance.transactions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VendingMachinePurchaseHistoryEntryMessage.SerializeDelta(stream, vendingMachinePurchaseHistoryEntryMessage, vendingMachinePurchaseHistoryEntryMessage);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field transactions (ProtoBuf.VendingMachinePurchaseHistoryEntryMessage)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.smallTransactions == null)
		{
			return;
		}
		for (int j = 0; j < instance.smallTransactions.Count; j++)
		{
			VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = instance.smallTransactions[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			VendingMachinePurchaseHistoryEntrySmallMessage.SerializeDelta(stream, vendingMachinePurchaseHistoryEntrySmallMessage, vendingMachinePurchaseHistoryEntrySmallMessage);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field smallTransactions (ProtoBuf.VendingMachinePurchaseHistoryEntrySmallMessage)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, VendingMachinePurchaseHistoryMessage instance)
	{
		if (instance.transactions != null)
		{
			for (int i = 0; i < instance.transactions.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage instance2 = instance.transactions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VendingMachinePurchaseHistoryEntryMessage.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field transactions (ProtoBuf.VendingMachinePurchaseHistoryEntryMessage)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.smallTransactions == null)
		{
			return;
		}
		for (int j = 0; j < instance.smallTransactions.Count; j++)
		{
			VendingMachinePurchaseHistoryEntrySmallMessage instance3 = instance.smallTransactions[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			VendingMachinePurchaseHistoryEntrySmallMessage.Serialize(stream, instance3);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field smallTransactions (ProtoBuf.VendingMachinePurchaseHistoryEntrySmallMessage)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (transactions != null)
		{
			for (int i = 0; i < transactions.Count; i++)
			{
				transactions[i]?.InspectUids(action);
			}
		}
		if (smallTransactions != null)
		{
			for (int j = 0; j < smallTransactions.Count; j++)
			{
				smallTransactions[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachineLongTermStats : IDisposable, IPooled, IProto<VendingMachineLongTermStats>, IProto
{
	[NonSerialized]
	public int numberOfPurchases;

	[NonSerialized]
	public long bestSalesHour;

	[NonSerialized]
	public int uniqueCustomers;

	[NonSerialized]
	public int repeatCustomers;

	[NonSerialized]
	public int bestCustomer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachineLongTermStats instance)
	{
		if (instance.ShouldPool)
		{
			instance.numberOfPurchases = 0;
			instance.bestSalesHour = 0L;
			instance.uniqueCustomers = 0;
			instance.repeatCustomers = 0;
			instance.bestCustomer = 0;
			Pool.Free<VendingMachineLongTermStats>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachineLongTermStats with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachineLongTermStats instance)
	{
		instance.numberOfPurchases = numberOfPurchases;
		instance.bestSalesHour = bestSalesHour;
		instance.uniqueCustomers = uniqueCustomers;
		instance.repeatCustomers = repeatCustomers;
		instance.bestCustomer = bestCustomer;
	}

	public VendingMachineLongTermStats Copy()
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		CopyTo(vendingMachineLongTermStats);
		return vendingMachineLongTermStats;
	}

	public static VendingMachineLongTermStats Deserialize(BufferStream stream)
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		Deserialize(stream, vendingMachineLongTermStats, isDelta: false);
		return vendingMachineLongTermStats;
	}

	public static VendingMachineLongTermStats DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		DeserializeLengthDelimited(stream, vendingMachineLongTermStats, isDelta: false);
		return vendingMachineLongTermStats;
	}

	public static VendingMachineLongTermStats DeserializeLength(BufferStream stream, int length)
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		DeserializeLength(stream, length, vendingMachineLongTermStats, isDelta: false);
		return vendingMachineLongTermStats;
	}

	public static VendingMachineLongTermStats Deserialize(byte[] buffer)
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachineLongTermStats, isDelta: false);
		return vendingMachineLongTermStats;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachineLongTermStats previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachineLongTermStats Deserialize(BufferStream stream, VendingMachineLongTermStats instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.numberOfPurchases = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.bestSalesHour = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.uniqueCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.repeatCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bestCustomer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachineLongTermStats DeserializeLengthDelimited(BufferStream stream, VendingMachineLongTermStats instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.numberOfPurchases = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.bestSalesHour = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.uniqueCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.repeatCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bestCustomer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachineLongTermStats DeserializeLength(BufferStream stream, int length, VendingMachineLongTermStats instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.numberOfPurchases = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.bestSalesHour = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.uniqueCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.repeatCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bestCustomer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachineLongTermStats instance, VendingMachineLongTermStats previous)
	{
		if (instance.numberOfPurchases != previous.numberOfPurchases)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numberOfPurchases);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.bestSalesHour);
		if (instance.uniqueCustomers != previous.uniqueCustomers)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.uniqueCustomers);
		}
		if (instance.repeatCustomers != previous.repeatCustomers)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.repeatCustomers);
		}
		if (instance.bestCustomer != previous.bestCustomer)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bestCustomer);
		}
	}

	public static void Serialize(BufferStream stream, VendingMachineLongTermStats instance)
	{
		if (instance.numberOfPurchases != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numberOfPurchases);
		}
		if (instance.bestSalesHour != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bestSalesHour);
		}
		if (instance.uniqueCustomers != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.uniqueCustomers);
		}
		if (instance.repeatCustomers != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.repeatCustomers);
		}
		if (instance.bestCustomer != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bestCustomer);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ChickenCoopStatusUpdate : IDisposable, IPooled, IProto<ChickenCoopStatusUpdate>, IProto
{
	[NonSerialized]
	public List<FarmableAnimalStatus> animals;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ChickenCoopStatusUpdate instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.animals != null)
		{
			for (int i = 0; i < instance.animals.Count; i++)
			{
				if (instance.animals[i] != null)
				{
					instance.animals[i].ResetToPool();
					instance.animals[i] = null;
				}
			}
			List<FarmableAnimalStatus> list = instance.animals;
			Pool.Free<FarmableAnimalStatus>(ref list, false);
			instance.animals = list;
		}
		Pool.Free<ChickenCoopStatusUpdate>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ChickenCoopStatusUpdate with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ChickenCoopStatusUpdate instance)
	{
		if (animals != null)
		{
			instance.animals = Pool.Get<List<FarmableAnimalStatus>>();
			for (int i = 0; i < animals.Count; i++)
			{
				FarmableAnimalStatus item = animals[i].Copy();
				instance.animals.Add(item);
			}
		}
		else
		{
			instance.animals = null;
		}
	}

	public ChickenCoopStatusUpdate Copy()
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		CopyTo(chickenCoopStatusUpdate);
		return chickenCoopStatusUpdate;
	}

	public static ChickenCoopStatusUpdate Deserialize(BufferStream stream)
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		Deserialize(stream, chickenCoopStatusUpdate, isDelta: false);
		return chickenCoopStatusUpdate;
	}

	public static ChickenCoopStatusUpdate DeserializeLengthDelimited(BufferStream stream)
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		DeserializeLengthDelimited(stream, chickenCoopStatusUpdate, isDelta: false);
		return chickenCoopStatusUpdate;
	}

	public static ChickenCoopStatusUpdate DeserializeLength(BufferStream stream, int length)
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		DeserializeLength(stream, length, chickenCoopStatusUpdate, isDelta: false);
		return chickenCoopStatusUpdate;
	}

	public static ChickenCoopStatusUpdate Deserialize(byte[] buffer)
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, chickenCoopStatusUpdate, isDelta: false);
		return chickenCoopStatusUpdate;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ChickenCoopStatusUpdate previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ChickenCoopStatusUpdate Deserialize(BufferStream stream, ChickenCoopStatusUpdate instance, bool isDelta)
	{
		if (!isDelta && instance.animals == null)
		{
			instance.animals = Pool.Get<List<FarmableAnimalStatus>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.animals.Add(FarmableAnimalStatus.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ChickenCoopStatusUpdate DeserializeLengthDelimited(BufferStream stream, ChickenCoopStatusUpdate instance, bool isDelta)
	{
		if (!isDelta && instance.animals == null)
		{
			instance.animals = Pool.Get<List<FarmableAnimalStatus>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.animals.Add(FarmableAnimalStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ChickenCoopStatusUpdate DeserializeLength(BufferStream stream, int length, ChickenCoopStatusUpdate instance, bool isDelta)
	{
		if (!isDelta && instance.animals == null)
		{
			instance.animals = Pool.Get<List<FarmableAnimalStatus>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.animals.Add(FarmableAnimalStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ChickenCoopStatusUpdate instance, ChickenCoopStatusUpdate previous)
	{
		if (instance.animals == null)
		{
			return;
		}
		for (int i = 0; i < instance.animals.Count; i++)
		{
			FarmableAnimalStatus farmableAnimalStatus = instance.animals[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			FarmableAnimalStatus.SerializeDelta(stream, farmableAnimalStatus, farmableAnimalStatus);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ChickenCoopStatusUpdate instance)
	{
		if (instance.animals == null)
		{
			return;
		}
		for (int i = 0; i < instance.animals.Count; i++)
		{
			FarmableAnimalStatus instance2 = instance.animals[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			FarmableAnimalStatus.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (animals != null)
		{
			for (int i = 0; i < animals.Count; i++)
			{
				animals[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class FarmableAnimalStatus : IDisposable, IPooled, IProto<FarmableAnimalStatus>, IProto
{
	[NonSerialized]
	public NetworkableId animal;

	[NonSerialized]
	public FarmableAnimal data;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FarmableAnimalStatus instance)
	{
		if (instance.ShouldPool)
		{
			instance.animal = default(NetworkableId);
			if (instance.data != null)
			{
				instance.data.ResetToPool();
				instance.data = null;
			}
			Pool.Free<FarmableAnimalStatus>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FarmableAnimalStatus with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FarmableAnimalStatus instance)
	{
		instance.animal = animal;
		if (data != null)
		{
			if (instance.data == null)
			{
				instance.data = data.Copy();
			}
			else
			{
				data.CopyTo(instance.data);
			}
		}
		else
		{
			instance.data = null;
		}
	}

	public FarmableAnimalStatus Copy()
	{
		FarmableAnimalStatus farmableAnimalStatus = Pool.Get<FarmableAnimalStatus>();
		CopyTo(farmableAnimalStatus);
		return farmableAnimalStatus;
	}

	public static FarmableAnimalStatus Deserialize(BufferStream stream)
	{
		FarmableAnimalStatus farmableAnimalStatus = Pool.Get<FarmableAnimalStatus>();
		Deserialize(stream, farmableAnimalStatus, isDelta: false);
		return farmableAnimalStatus;
	}

	public static FarmableAnimalStatus DeserializeLengthDelimited(BufferStream stream)
	{
		FarmableAnimalStatus farmableAnimalStatus = Pool.Get<FarmableAnimalStatus>();
		DeserializeLengthDelimited(stream, farmableAnimalStatus, isDelta: false);
		return farmableAnimalStatus;
	}

	public static FarmableAnimalStatus DeserializeLength(BufferStream stream, int length)
	{
		FarmableAnimalStatus farmableAnimalStatus = Pool.Get<FarmableAnimalStatus>();
		DeserializeLength(stream, length, farmableAnimalStatus, isDelta: false);
		return farmableAnimalStatus;
	}

	public static FarmableAnimalStatus Deserialize(byte[] buffer)
	{
		FarmableAnimalStatus farmableAnimalStatus = Pool.Get<FarmableAnimalStatus>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, farmableAnimalStatus, isDelta: false);
		return farmableAnimalStatus;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FarmableAnimalStatus previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FarmableAnimalStatus Deserialize(BufferStream stream, FarmableAnimalStatus instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.animal = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.data == null)
				{
					instance.data = FarmableAnimal.DeserializeLengthDelimited(stream);
				}
				else
				{
					FarmableAnimal.DeserializeLengthDelimited(stream, instance.data, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static FarmableAnimalStatus DeserializeLengthDelimited(BufferStream stream, FarmableAnimalStatus instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.animal = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.data == null)
				{
					instance.data = FarmableAnimal.DeserializeLengthDelimited(stream);
				}
				else
				{
					FarmableAnimal.DeserializeLengthDelimited(stream, instance.data, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FarmableAnimalStatus DeserializeLength(BufferStream stream, int length, FarmableAnimalStatus instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.animal = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.data == null)
				{
					instance.data = FarmableAnimal.DeserializeLengthDelimited(stream);
				}
				else
				{
					FarmableAnimal.DeserializeLengthDelimited(stream, instance.data, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FarmableAnimalStatus instance, FarmableAnimalStatus previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.animal.Value);
		if (instance.data == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		FarmableAnimal.SerializeDelta(stream, instance.data, previous.data);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, FarmableAnimalStatus instance)
	{
		if (instance.animal != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.animal.Value);
		}
		if (instance.data == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		FarmableAnimal.Serialize(stream, instance.data);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref animal.Value);
		data?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NPCSensesState : IDisposable, IPooled, IProto<NPCSensesState>, IProto
{
	[NonSerialized]
	public NetworkableId targetEntityId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NPCSensesState instance)
	{
		if (instance.ShouldPool)
		{
			instance.targetEntityId = default(NetworkableId);
			Pool.Free<NPCSensesState>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NPCSensesState with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NPCSensesState instance)
	{
		instance.targetEntityId = targetEntityId;
	}

	public NPCSensesState Copy()
	{
		NPCSensesState nPCSensesState = Pool.Get<NPCSensesState>();
		CopyTo(nPCSensesState);
		return nPCSensesState;
	}

	public static NPCSensesState Deserialize(BufferStream stream)
	{
		NPCSensesState nPCSensesState = Pool.Get<NPCSensesState>();
		Deserialize(stream, nPCSensesState, isDelta: false);
		return nPCSensesState;
	}

	public static NPCSensesState DeserializeLengthDelimited(BufferStream stream)
	{
		NPCSensesState nPCSensesState = Pool.Get<NPCSensesState>();
		DeserializeLengthDelimited(stream, nPCSensesState, isDelta: false);
		return nPCSensesState;
	}

	public static NPCSensesState DeserializeLength(BufferStream stream, int length)
	{
		NPCSensesState nPCSensesState = Pool.Get<NPCSensesState>();
		DeserializeLength(stream, length, nPCSensesState, isDelta: false);
		return nPCSensesState;
	}

	public static NPCSensesState Deserialize(byte[] buffer)
	{
		NPCSensesState nPCSensesState = Pool.Get<NPCSensesState>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nPCSensesState, isDelta: false);
		return nPCSensesState;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NPCSensesState previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NPCSensesState Deserialize(BufferStream stream, NPCSensesState instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NPCSensesState DeserializeLengthDelimited(BufferStream stream, NPCSensesState instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NPCSensesState DeserializeLength(BufferStream stream, int length, NPCSensesState instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NPCSensesState instance, NPCSensesState previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetEntityId.Value);
	}

	public static void Serialize(BufferStream stream, NPCSensesState instance)
	{
		if (instance.targetEntityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetEntityId.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetEntityId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PartyData : IDisposable, IPooled, IProto<PartyData>, IProto
{
	[NonSerialized]
	public ulong lobbyId;

	[NonSerialized]
	public List<PartyMemberData> members;

	[NonSerialized]
	public string joinKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PartyData instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.lobbyId = 0uL;
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				if (instance.members[i] != null)
				{
					instance.members[i].ResetToPool();
					instance.members[i] = null;
				}
			}
			List<PartyMemberData> list = instance.members;
			Pool.Free<PartyMemberData>(ref list, false);
			instance.members = list;
		}
		instance.joinKey = string.Empty;
		Pool.Free<PartyData>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PartyData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PartyData instance)
	{
		instance.lobbyId = lobbyId;
		if (members != null)
		{
			instance.members = Pool.Get<List<PartyMemberData>>();
			for (int i = 0; i < members.Count; i++)
			{
				PartyMemberData item = members[i].Copy();
				instance.members.Add(item);
			}
		}
		else
		{
			instance.members = null;
		}
		instance.joinKey = joinKey;
	}

	public PartyData Copy()
	{
		PartyData partyData = Pool.Get<PartyData>();
		CopyTo(partyData);
		return partyData;
	}

	public static PartyData Deserialize(BufferStream stream)
	{
		PartyData partyData = Pool.Get<PartyData>();
		Deserialize(stream, partyData, isDelta: false);
		return partyData;
	}

	public static PartyData DeserializeLengthDelimited(BufferStream stream)
	{
		PartyData partyData = Pool.Get<PartyData>();
		DeserializeLengthDelimited(stream, partyData, isDelta: false);
		return partyData;
	}

	public static PartyData DeserializeLength(BufferStream stream, int length)
	{
		PartyData partyData = Pool.Get<PartyData>();
		DeserializeLength(stream, length, partyData, isDelta: false);
		return partyData;
	}

	public static PartyData Deserialize(byte[] buffer)
	{
		PartyData partyData = Pool.Get<PartyData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, partyData, isDelta: false);
		return partyData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PartyData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PartyData Deserialize(BufferStream stream, PartyData instance, bool isDelta)
	{
		if (!isDelta && instance.members == null)
		{
			instance.members = Pool.Get<List<PartyMemberData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lobbyId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(PartyMemberData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PartyData DeserializeLengthDelimited(BufferStream stream, PartyData instance, bool isDelta)
	{
		if (!isDelta && instance.members == null)
		{
			instance.members = Pool.Get<List<PartyMemberData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lobbyId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(PartyMemberData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PartyData DeserializeLength(BufferStream stream, int length, PartyData instance, bool isDelta)
	{
		if (!isDelta && instance.members == null)
		{
			instance.members = Pool.Get<List<PartyMemberData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lobbyId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(PartyMemberData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PartyData instance, PartyData previous)
	{
		if (instance.lobbyId != previous.lobbyId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lobbyId);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				PartyMemberData partyMemberData = instance.members[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PartyMemberData.SerializeDelta(stream, partyMemberData, partyMemberData);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.joinKey != previous.joinKey)
		{
			if (instance.joinKey == null)
			{
				throw new ArgumentNullException("joinKey", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.joinKey);
		}
	}

	public static void Serialize(BufferStream stream, PartyData instance)
	{
		if (instance.lobbyId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lobbyId);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				PartyMemberData instance2 = instance.members[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PartyMemberData.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.joinKey == null)
		{
			throw new ArgumentNullException("joinKey", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.joinKey);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (members != null)
		{
			for (int i = 0; i < members.Count; i++)
			{
				members[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PartyMemberData : IDisposable, IPooled, IProto<PartyMemberData>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public bool isLeader;

	[NonSerialized]
	public string name;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PartyMemberData instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.isLeader = false;
			instance.name = string.Empty;
			Pool.Free<PartyMemberData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PartyMemberData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PartyMemberData instance)
	{
		instance.steamId = steamId;
		instance.isLeader = isLeader;
		instance.name = name;
	}

	public PartyMemberData Copy()
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		CopyTo(partyMemberData);
		return partyMemberData;
	}

	public static PartyMemberData Deserialize(BufferStream stream)
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		Deserialize(stream, partyMemberData, isDelta: false);
		return partyMemberData;
	}

	public static PartyMemberData DeserializeLengthDelimited(BufferStream stream)
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		DeserializeLengthDelimited(stream, partyMemberData, isDelta: false);
		return partyMemberData;
	}

	public static PartyMemberData DeserializeLength(BufferStream stream, int length)
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		DeserializeLength(stream, length, partyMemberData, isDelta: false);
		return partyMemberData;
	}

	public static PartyMemberData Deserialize(byte[] buffer)
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, partyMemberData, isDelta: false);
		return partyMemberData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PartyMemberData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PartyMemberData Deserialize(BufferStream stream, PartyMemberData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isLeader = ProtocolParser.ReadBool(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PartyMemberData DeserializeLengthDelimited(BufferStream stream, PartyMemberData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isLeader = ProtocolParser.ReadBool(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PartyMemberData DeserializeLength(BufferStream stream, int length, PartyMemberData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isLeader = ProtocolParser.ReadBool(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PartyMemberData instance, PartyMemberData previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.isLeader);
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public static void Serialize(BufferStream stream, PartyMemberData instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.isLeader)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.isLeader);
		}
		if (instance.name != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WorldData : IDisposable, IPooled, IProto<WorldData>, IProto
{
	[NonSerialized]
	public uint size;

	[NonSerialized]
	public List<MapData> maps;

	[NonSerialized]
	public List<PrefabData> prefabs;

	[NonSerialized]
	public List<PathData> paths;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WorldData instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.size = 0u;
		if (instance.maps != null)
		{
			for (int i = 0; i < instance.maps.Count; i++)
			{
				if (instance.maps[i] != null)
				{
					instance.maps[i].ResetToPool();
					instance.maps[i] = null;
				}
			}
			List<MapData> list = instance.maps;
			Pool.Free<MapData>(ref list, false);
			instance.maps = list;
		}
		if (instance.prefabs != null)
		{
			for (int j = 0; j < instance.prefabs.Count; j++)
			{
				if (instance.prefabs[j] != null)
				{
					instance.prefabs[j].ResetToPool();
					instance.prefabs[j] = null;
				}
			}
			List<PrefabData> list2 = instance.prefabs;
			Pool.Free<PrefabData>(ref list2, false);
			instance.prefabs = list2;
		}
		if (instance.paths != null)
		{
			for (int k = 0; k < instance.paths.Count; k++)
			{
				if (instance.paths[k] != null)
				{
					instance.paths[k].ResetToPool();
					instance.paths[k] = null;
				}
			}
			List<PathData> list3 = instance.paths;
			Pool.Free<PathData>(ref list3, false);
			instance.paths = list3;
		}
		Pool.Free<WorldData>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WorldData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WorldData instance)
	{
		instance.size = size;
		if (maps != null)
		{
			instance.maps = Pool.Get<List<MapData>>();
			for (int i = 0; i < maps.Count; i++)
			{
				MapData item = maps[i].Copy();
				instance.maps.Add(item);
			}
		}
		else
		{
			instance.maps = null;
		}
		if (prefabs != null)
		{
			instance.prefabs = Pool.Get<List<PrefabData>>();
			for (int j = 0; j < prefabs.Count; j++)
			{
				PrefabData item2 = prefabs[j].Copy();
				instance.prefabs.Add(item2);
			}
		}
		else
		{
			instance.prefabs = null;
		}
		if (paths != null)
		{
			instance.paths = Pool.Get<List<PathData>>();
			for (int k = 0; k < paths.Count; k++)
			{
				PathData item3 = paths[k].Copy();
				instance.paths.Add(item3);
			}
		}
		else
		{
			instance.paths = null;
		}
	}

	public WorldData Copy()
	{
		WorldData worldData = Pool.Get<WorldData>();
		CopyTo(worldData);
		return worldData;
	}

	public static WorldData Deserialize(BufferStream stream)
	{
		WorldData worldData = Pool.Get<WorldData>();
		Deserialize(stream, worldData, isDelta: false);
		return worldData;
	}

	public static WorldData DeserializeLengthDelimited(BufferStream stream)
	{
		WorldData worldData = Pool.Get<WorldData>();
		DeserializeLengthDelimited(stream, worldData, isDelta: false);
		return worldData;
	}

	public static WorldData DeserializeLength(BufferStream stream, int length)
	{
		WorldData worldData = Pool.Get<WorldData>();
		DeserializeLength(stream, length, worldData, isDelta: false);
		return worldData;
	}

	public static WorldData Deserialize(byte[] buffer)
	{
		WorldData worldData = Pool.Get<WorldData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, worldData, isDelta: false);
		return worldData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WorldData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WorldData Deserialize(BufferStream stream, WorldData instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.maps == null)
			{
				instance.maps = Pool.Get<List<MapData>>();
			}
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.size = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.maps.Add(MapData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WorldData DeserializeLengthDelimited(BufferStream stream, WorldData instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.maps == null)
			{
				instance.maps = Pool.Get<List<MapData>>();
			}
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.size = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.maps.Add(MapData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WorldData DeserializeLength(BufferStream stream, int length, WorldData instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.maps == null)
			{
				instance.maps = Pool.Get<List<MapData>>();
			}
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.size = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.maps.Add(MapData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WorldData instance, WorldData previous)
	{
		if (instance.size != previous.size)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.size);
		}
		if (instance.maps != null)
		{
			for (int i = 0; i < instance.maps.Count; i++)
			{
				MapData mapData = instance.maps[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MapData.SerializeDelta(stream, mapData, mapData);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.prefabs != null)
		{
			for (int j = 0; j < instance.prefabs.Count; j++)
			{
				PrefabData prefabData = instance.prefabs[j];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				PrefabData.SerializeDelta(stream, prefabData, prefabData);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.paths == null)
		{
			return;
		}
		for (int k = 0; k < instance.paths.Count; k++)
		{
			PathData pathData = instance.paths[k];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			PathData.SerializeDelta(stream, pathData, pathData);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, WorldData instance)
	{
		if (instance.size != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.size);
		}
		if (instance.maps != null)
		{
			for (int i = 0; i < instance.maps.Count; i++)
			{
				MapData instance2 = instance.maps[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MapData.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.prefabs != null)
		{
			for (int j = 0; j < instance.prefabs.Count; j++)
			{
				PrefabData instance3 = instance.prefabs[j];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				PrefabData.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.paths == null)
		{
			return;
		}
		for (int k = 0; k < instance.paths.Count; k++)
		{
			PathData instance4 = instance.paths[k];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			PathData.Serialize(stream, instance4);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (maps != null)
		{
			for (int i = 0; i < maps.Count; i++)
			{
				maps[i]?.InspectUids(action);
			}
		}
		if (prefabs != null)
		{
			for (int j = 0; j < prefabs.Count; j++)
			{
				prefabs[j]?.InspectUids(action);
			}
		}
		if (paths != null)
		{
			for (int k = 0; k < paths.Count; k++)
			{
				paths[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MapData : IDisposable, IPooled, IProto<MapData>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public byte[] data;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MapData instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.data = null;
			Pool.Free<MapData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MapData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MapData instance)
	{
		instance.name = name;
		if (data == null)
		{
			instance.data = null;
			return;
		}
		instance.data = new byte[data.Length];
		Array.Copy(data, instance.data, instance.data.Length);
	}

	public MapData Copy()
	{
		MapData mapData = Pool.Get<MapData>();
		CopyTo(mapData);
		return mapData;
	}

	public static MapData Deserialize(BufferStream stream)
	{
		MapData mapData = Pool.Get<MapData>();
		Deserialize(stream, mapData, isDelta: false);
		return mapData;
	}

	public static MapData DeserializeLengthDelimited(BufferStream stream)
	{
		MapData mapData = Pool.Get<MapData>();
		DeserializeLengthDelimited(stream, mapData, isDelta: false);
		return mapData;
	}

	public static MapData DeserializeLength(BufferStream stream, int length)
	{
		MapData mapData = Pool.Get<MapData>();
		DeserializeLength(stream, length, mapData, isDelta: false);
		return mapData;
	}

	public static MapData Deserialize(byte[] buffer)
	{
		MapData mapData = Pool.Get<MapData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mapData, isDelta: false);
		return mapData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MapData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MapData Deserialize(BufferStream stream, MapData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MapData DeserializeLengthDelimited(BufferStream stream, MapData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MapData DeserializeLength(BufferStream stream, int length, MapData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MapData instance, MapData previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteBytes(stream, instance.data);
	}

	public static void Serialize(BufferStream stream, MapData instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteBytes(stream, instance.data);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PrefabData : IDisposable, IPooled, IProto<PrefabData>, IProto
{
	[NonSerialized]
	public string category;

	[NonSerialized]
	public uint id;

	[NonSerialized]
	public VectorData position;

	[NonSerialized]
	public VectorData rotation;

	[NonSerialized]
	public VectorData scale;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PrefabData instance)
	{
		if (instance.ShouldPool)
		{
			instance.category = string.Empty;
			instance.id = 0u;
			instance.position = default(VectorData);
			instance.rotation = default(VectorData);
			instance.scale = default(VectorData);
			Pool.Free<PrefabData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PrefabData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PrefabData instance)
	{
		instance.category = category;
		instance.id = id;
		instance.position = position;
		instance.rotation = rotation;
		instance.scale = scale;
	}

	public PrefabData Copy()
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		CopyTo(prefabData);
		return prefabData;
	}

	public static PrefabData Deserialize(BufferStream stream)
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		Deserialize(stream, prefabData, isDelta: false);
		return prefabData;
	}

	public static PrefabData DeserializeLengthDelimited(BufferStream stream)
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		DeserializeLengthDelimited(stream, prefabData, isDelta: false);
		return prefabData;
	}

	public static PrefabData DeserializeLength(BufferStream stream, int length)
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		DeserializeLength(stream, length, prefabData, isDelta: false);
		return prefabData;
	}

	public static PrefabData Deserialize(byte[] buffer)
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, prefabData, isDelta: false);
		return prefabData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PrefabData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PrefabData Deserialize(BufferStream stream, PrefabData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.category = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				VectorData.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				VectorData.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				VectorData.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PrefabData DeserializeLengthDelimited(BufferStream stream, PrefabData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.category = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				VectorData.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				VectorData.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				VectorData.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PrefabData DeserializeLength(BufferStream stream, int length, PrefabData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.category = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				VectorData.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				VectorData.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				VectorData.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PrefabData instance, PrefabData previous)
	{
		if (instance.category != previous.category)
		{
			if (instance.category == null)
			{
				throw new ArgumentNullException("category", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.category);
		}
		if (instance.id != previous.id)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int num = stream.Position;
		VectorData.SerializeDelta(stream, instance.position, previous.position);
		int num2 = stream.Position - num;
		if (num2 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (ProtoBuf.VectorData)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num2, span, 0);
		stream.WriteByte(34);
		BufferStream.RangeHandle range2 = stream.GetRange(1);
		int num3 = stream.Position;
		VectorData.SerializeDelta(stream, instance.rotation, previous.rotation);
		int num4 = stream.Position - num3;
		if (num4 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (ProtoBuf.VectorData)");
		}
		Span<byte> span2 = range2.GetSpan();
		ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		stream.WriteByte(42);
		BufferStream.RangeHandle range3 = stream.GetRange(1);
		int num5 = stream.Position;
		VectorData.SerializeDelta(stream, instance.scale, previous.scale);
		int num6 = stream.Position - num5;
		if (num6 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (ProtoBuf.VectorData)");
		}
		Span<byte> span3 = range3.GetSpan();
		ProtocolParser.WriteUInt32((uint)num6, span3, 0);
	}

	public static void Serialize(BufferStream stream, PrefabData instance)
	{
		if (instance.category == null)
		{
			throw new ArgumentNullException("category", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.category);
		if (instance.id != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		if (instance.position != default(VectorData))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			VectorData.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != default(VectorData))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			VectorData.Serialize(stream, instance.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (ProtoBuf.VectorData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.scale != default(VectorData))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			VectorData.Serialize(stream, instance.scale);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (ProtoBuf.VectorData)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		position.InspectUids(action);
		rotation.InspectUids(action);
		scale.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PathData : IDisposable, IPooled, IProto<PathData>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public bool spline;

	[NonSerialized]
	public bool start;

	[NonSerialized]
	public bool end;

	[NonSerialized]
	public float width;

	[NonSerialized]
	public float innerPadding;

	[NonSerialized]
	public float outerPadding;

	[NonSerialized]
	public float innerFade;

	[NonSerialized]
	public float outerFade;

	[NonSerialized]
	public float randomScale;

	[NonSerialized]
	public float meshOffset;

	[NonSerialized]
	public float terrainOffset;

	[NonSerialized]
	public int splat;

	[NonSerialized]
	public int topology;

	[NonSerialized]
	public List<VectorData> nodes;

	[NonSerialized]
	public int hierarchy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PathData instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.spline = false;
			instance.start = false;
			instance.end = false;
			instance.width = 0f;
			instance.innerPadding = 0f;
			instance.outerPadding = 0f;
			instance.innerFade = 0f;
			instance.outerFade = 0f;
			instance.randomScale = 0f;
			instance.meshOffset = 0f;
			instance.terrainOffset = 0f;
			instance.splat = 0;
			instance.topology = 0;
			if (instance.nodes != null)
			{
				List<VectorData> list = instance.nodes;
				Pool.FreeUnmanaged<VectorData>(ref list);
				instance.nodes = list;
			}
			instance.hierarchy = 0;
			Pool.Free<PathData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PathData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PathData instance)
	{
		instance.name = name;
		instance.spline = spline;
		instance.start = start;
		instance.end = end;
		instance.width = width;
		instance.innerPadding = innerPadding;
		instance.outerPadding = outerPadding;
		instance.innerFade = innerFade;
		instance.outerFade = outerFade;
		instance.randomScale = randomScale;
		instance.meshOffset = meshOffset;
		instance.terrainOffset = terrainOffset;
		instance.splat = splat;
		instance.topology = topology;
		if (nodes != null)
		{
			instance.nodes = Pool.Get<List<VectorData>>();
			for (int i = 0; i < nodes.Count; i++)
			{
				VectorData item = nodes[i];
				instance.nodes.Add(item);
			}
		}
		else
		{
			instance.nodes = null;
		}
		instance.hierarchy = hierarchy;
	}

	public PathData Copy()
	{
		PathData pathData = Pool.Get<PathData>();
		CopyTo(pathData);
		return pathData;
	}

	public static PathData Deserialize(BufferStream stream)
	{
		PathData pathData = Pool.Get<PathData>();
		Deserialize(stream, pathData, isDelta: false);
		return pathData;
	}

	public static PathData DeserializeLengthDelimited(BufferStream stream)
	{
		PathData pathData = Pool.Get<PathData>();
		DeserializeLengthDelimited(stream, pathData, isDelta: false);
		return pathData;
	}

	public static PathData DeserializeLength(BufferStream stream, int length)
	{
		PathData pathData = Pool.Get<PathData>();
		DeserializeLength(stream, length, pathData, isDelta: false);
		return pathData;
	}

	public static PathData Deserialize(byte[] buffer)
	{
		PathData pathData = Pool.Get<PathData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pathData, isDelta: false);
		return pathData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PathData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PathData Deserialize(BufferStream stream, PathData instance, bool isDelta)
	{
		if (!isDelta && instance.nodes == null)
		{
			instance.nodes = Pool.Get<List<VectorData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.spline = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.start = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.end = ProtocolParser.ReadBool(stream);
				continue;
			case 45:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.innerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.outerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.innerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.outerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.randomScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.meshOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.terrainOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 104:
				instance.splat = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.topology = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.nodes.Add(instance2);
				continue;
			}
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.hierarchy = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static PathData DeserializeLengthDelimited(BufferStream stream, PathData instance, bool isDelta)
	{
		if (!isDelta && instance.nodes == null)
		{
			instance.nodes = Pool.Get<List<VectorData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.spline = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.start = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.end = ProtocolParser.ReadBool(stream);
				continue;
			case 45:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.innerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.outerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.innerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.outerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.randomScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.meshOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.terrainOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 104:
				instance.splat = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.topology = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.nodes.Add(instance2);
				continue;
			}
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.hierarchy = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PathData DeserializeLength(BufferStream stream, int length, PathData instance, bool isDelta)
	{
		if (!isDelta && instance.nodes == null)
		{
			instance.nodes = Pool.Get<List<VectorData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.spline = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.start = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.end = ProtocolParser.ReadBool(stream);
				continue;
			case 45:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.innerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.outerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.innerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.outerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.randomScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.meshOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.terrainOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 104:
				instance.splat = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.topology = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.nodes.Add(instance2);
				continue;
			}
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.hierarchy = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PathData instance, PathData previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.spline);
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.start);
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.end);
		if (instance.width != previous.width)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.width);
		}
		if (instance.innerPadding != previous.innerPadding)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.innerPadding);
		}
		if (instance.outerPadding != previous.outerPadding)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.outerPadding);
		}
		if (instance.innerFade != previous.innerFade)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.innerFade);
		}
		if (instance.outerFade != previous.outerFade)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.outerFade);
		}
		if (instance.randomScale != previous.randomScale)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.randomScale);
		}
		if (instance.meshOffset != previous.meshOffset)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.meshOffset);
		}
		if (instance.terrainOffset != previous.terrainOffset)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.terrainOffset);
		}
		if (instance.splat != previous.splat)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.splat);
		}
		if (instance.topology != previous.topology)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.topology);
		}
		if (instance.nodes != null)
		{
			for (int i = 0; i < instance.nodes.Count; i++)
			{
				VectorData vectorData = instance.nodes[i];
				stream.WriteByte(122);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VectorData.SerializeDelta(stream, vectorData, vectorData);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field nodes (ProtoBuf.VectorData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.hierarchy != previous.hierarchy)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.hierarchy);
		}
	}

	public static void Serialize(BufferStream stream, PathData instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.spline)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.spline);
		}
		if (instance.start)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.start);
		}
		if (instance.end)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.end);
		}
		if (instance.width != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.width);
		}
		if (instance.innerPadding != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.innerPadding);
		}
		if (instance.outerPadding != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.outerPadding);
		}
		if (instance.innerFade != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.innerFade);
		}
		if (instance.outerFade != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.outerFade);
		}
		if (instance.randomScale != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.randomScale);
		}
		if (instance.meshOffset != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.meshOffset);
		}
		if (instance.terrainOffset != 0f)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.terrainOffset);
		}
		if (instance.splat != 0)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.splat);
		}
		if (instance.topology != 0)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.topology);
		}
		if (instance.nodes != null)
		{
			for (int i = 0; i < instance.nodes.Count; i++)
			{
				VectorData instance2 = instance.nodes[i];
				stream.WriteByte(122);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VectorData.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field nodes (ProtoBuf.VectorData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.hierarchy != 0)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.hierarchy);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (nodes != null)
		{
			for (int i = 0; i < nodes.Count; i++)
			{
				nodes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public struct VectorData : IProto<VectorData>, IProto, IEquatable<VectorData>
{
	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public float z;

	public static void ResetToPool(VectorData instance)
	{
		instance.x = 0f;
		instance.y = 0f;
		instance.z = 0f;
	}

	public void CopyTo(VectorData instance)
	{
		instance.x = x;
		instance.y = y;
		instance.z = z;
	}

	public VectorData Copy()
	{
		VectorData vectorData = default(VectorData);
		CopyTo(vectorData);
		return vectorData;
	}

	public static VectorData Deserialize(BufferStream stream)
	{
		VectorData instance = default(VectorData);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static VectorData DeserializeLengthDelimited(BufferStream stream)
	{
		VectorData instance = default(VectorData);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static VectorData DeserializeLength(BufferStream stream, int length)
	{
		VectorData instance = default(VectorData);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static VectorData Deserialize(byte[] buffer)
	{
		VectorData instance = default(VectorData);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, VectorData previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static VectorData Deserialize(BufferStream stream, ref VectorData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VectorData DeserializeLengthDelimited(BufferStream stream, ref VectorData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VectorData DeserializeLength(BufferStream stream, int length, ref VectorData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VectorData instance, VectorData previous)
	{
		if (instance.x != previous.x)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != previous.z)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
	}

	public static void Serialize(BufferStream stream, VectorData instance)
	{
		if (instance.x != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}

	public VectorData(float x, float y, float z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public static implicit operator VectorData(Vector3 v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new VectorData(v.x, v.y, v.z);
	}

	public static implicit operator VectorData(Quaternion q)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return ((Quaternion)(ref q)).eulerAngles;
	}

	public static implicit operator Vector3(VectorData v)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(v.x, v.y, v.z);
	}

	public static implicit operator Quaternion(VectorData v)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.Euler((Vector3)v);
	}

	public bool Equals(VectorData other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is VectorData)
		{
			return Equals((VectorData)obj);
		}
		return false;
	}

	public static bool operator ==(VectorData a, VectorData b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(VectorData a, VectorData b)
	{
		return !a.Equals(b);
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppRequest : IDisposable, IPooled, IProto<AppRequest>, IProto
{
	[NonSerialized]
	public uint seq;

	[NonSerialized]
	public ulong playerId;

	[NonSerialized]
	public int playerToken;

	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public AppEmpty getInfo;

	[NonSerialized]
	public AppEmpty getTime;

	[NonSerialized]
	public AppEmpty getMap;

	[NonSerialized]
	public AppEmpty getTeamInfo;

	[NonSerialized]
	public AppEmpty getTeamChat;

	[NonSerialized]
	public AppSendMessage sendTeamMessage;

	[NonSerialized]
	public AppEmpty getEntityInfo;

	[NonSerialized]
	public AppSetEntityValue setEntityValue;

	[NonSerialized]
	public AppEmpty checkSubscription;

	[NonSerialized]
	public AppFlag setSubscription;

	[NonSerialized]
	public AppEmpty getMapMarkers;

	[NonSerialized]
	public AppPromoteToLeader promoteToLeader;

	[NonSerialized]
	public AppEmpty getClanInfo;

	[NonSerialized]
	public AppSendMessage setClanMotd;

	[NonSerialized]
	public AppEmpty getClanChat;

	[NonSerialized]
	public AppSendMessage sendClanMessage;

	[NonSerialized]
	public AppGetNexusAuth getNexusAuth;

	[NonSerialized]
	public AppCameraSubscribe cameraSubscribe;

	[NonSerialized]
	public AppEmpty cameraUnsubscribe;

	[NonSerialized]
	public AppCameraInput cameraInput;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.seq = 0u;
			instance.playerId = 0uL;
			instance.playerToken = 0;
			instance.entityId = default(NetworkableId);
			if (instance.getInfo != null)
			{
				instance.getInfo.ResetToPool();
				instance.getInfo = null;
			}
			if (instance.getTime != null)
			{
				instance.getTime.ResetToPool();
				instance.getTime = null;
			}
			if (instance.getMap != null)
			{
				instance.getMap.ResetToPool();
				instance.getMap = null;
			}
			if (instance.getTeamInfo != null)
			{
				instance.getTeamInfo.ResetToPool();
				instance.getTeamInfo = null;
			}
			if (instance.getTeamChat != null)
			{
				instance.getTeamChat.ResetToPool();
				instance.getTeamChat = null;
			}
			if (instance.sendTeamMessage != null)
			{
				instance.sendTeamMessage.ResetToPool();
				instance.sendTeamMessage = null;
			}
			if (instance.getEntityInfo != null)
			{
				instance.getEntityInfo.ResetToPool();
				instance.getEntityInfo = null;
			}
			if (instance.setEntityValue != null)
			{
				instance.setEntityValue.ResetToPool();
				instance.setEntityValue = null;
			}
			if (instance.checkSubscription != null)
			{
				instance.checkSubscription.ResetToPool();
				instance.checkSubscription = null;
			}
			if (instance.setSubscription != null)
			{
				instance.setSubscription.ResetToPool();
				instance.setSubscription = null;
			}
			if (instance.getMapMarkers != null)
			{
				instance.getMapMarkers.ResetToPool();
				instance.getMapMarkers = null;
			}
			if (instance.promoteToLeader != null)
			{
				instance.promoteToLeader.ResetToPool();
				instance.promoteToLeader = null;
			}
			if (instance.getClanInfo != null)
			{
				instance.getClanInfo.ResetToPool();
				instance.getClanInfo = null;
			}
			if (instance.setClanMotd != null)
			{
				instance.setClanMotd.ResetToPool();
				instance.setClanMotd = null;
			}
			if (instance.getClanChat != null)
			{
				instance.getClanChat.ResetToPool();
				instance.getClanChat = null;
			}
			if (instance.sendClanMessage != null)
			{
				instance.sendClanMessage.ResetToPool();
				instance.sendClanMessage = null;
			}
			if (instance.getNexusAuth != null)
			{
				instance.getNexusAuth.ResetToPool();
				instance.getNexusAuth = null;
			}
			if (instance.cameraSubscribe != null)
			{
				instance.cameraSubscribe.ResetToPool();
				instance.cameraSubscribe = null;
			}
			if (instance.cameraUnsubscribe != null)
			{
				instance.cameraUnsubscribe.ResetToPool();
				instance.cameraUnsubscribe = null;
			}
			if (instance.cameraInput != null)
			{
				instance.cameraInput.ResetToPool();
				instance.cameraInput = null;
			}
			Pool.Free<AppRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppRequest instance)
	{
		instance.seq = seq;
		instance.playerId = playerId;
		instance.playerToken = playerToken;
		instance.entityId = entityId;
		if (getInfo != null)
		{
			if (instance.getInfo == null)
			{
				instance.getInfo = getInfo.Copy();
			}
			else
			{
				getInfo.CopyTo(instance.getInfo);
			}
		}
		else
		{
			instance.getInfo = null;
		}
		if (getTime != null)
		{
			if (instance.getTime == null)
			{
				instance.getTime = getTime.Copy();
			}
			else
			{
				getTime.CopyTo(instance.getTime);
			}
		}
		else
		{
			instance.getTime = null;
		}
		if (getMap != null)
		{
			if (instance.getMap == null)
			{
				instance.getMap = getMap.Copy();
			}
			else
			{
				getMap.CopyTo(instance.getMap);
			}
		}
		else
		{
			instance.getMap = null;
		}
		if (getTeamInfo != null)
		{
			if (instance.getTeamInfo == null)
			{
				instance.getTeamInfo = getTeamInfo.Copy();
			}
			else
			{
				getTeamInfo.CopyTo(instance.getTeamInfo);
			}
		}
		else
		{
			instance.getTeamInfo = null;
		}
		if (getTeamChat != null)
		{
			if (instance.getTeamChat == null)
			{
				instance.getTeamChat = getTeamChat.Copy();
			}
			else
			{
				getTeamChat.CopyTo(instance.getTeamChat);
			}
		}
		else
		{
			instance.getTeamChat = null;
		}
		if (sendTeamMessage != null)
		{
			if (instance.sendTeamMessage == null)
			{
				instance.sendTeamMessage = sendTeamMessage.Copy();
			}
			else
			{
				sendTeamMessage.CopyTo(instance.sendTeamMessage);
			}
		}
		else
		{
			instance.sendTeamMessage = null;
		}
		if (getEntityInfo != null)
		{
			if (instance.getEntityInfo == null)
			{
				instance.getEntityInfo = getEntityInfo.Copy();
			}
			else
			{
				getEntityInfo.CopyTo(instance.getEntityInfo);
			}
		}
		else
		{
			instance.getEntityInfo = null;
		}
		if (setEntityValue != null)
		{
			if (instance.setEntityValue == null)
			{
				instance.setEntityValue = setEntityValue.Copy();
			}
			else
			{
				setEntityValue.CopyTo(instance.setEntityValue);
			}
		}
		else
		{
			instance.setEntityValue = null;
		}
		if (checkSubscription != null)
		{
			if (instance.checkSubscription == null)
			{
				instance.checkSubscription = checkSubscription.Copy();
			}
			else
			{
				checkSubscription.CopyTo(instance.checkSubscription);
			}
		}
		else
		{
			instance.checkSubscription = null;
		}
		if (setSubscription != null)
		{
			if (instance.setSubscription == null)
			{
				instance.setSubscription = setSubscription.Copy();
			}
			else
			{
				setSubscription.CopyTo(instance.setSubscription);
			}
		}
		else
		{
			instance.setSubscription = null;
		}
		if (getMapMarkers != null)
		{
			if (instance.getMapMarkers == null)
			{
				instance.getMapMarkers = getMapMarkers.Copy();
			}
			else
			{
				getMapMarkers.CopyTo(instance.getMapMarkers);
			}
		}
		else
		{
			instance.getMapMarkers = null;
		}
		if (promoteToLeader != null)
		{
			if (instance.promoteToLeader == null)
			{
				instance.promoteToLeader = promoteToLeader.Copy();
			}
			else
			{
				promoteToLeader.CopyTo(instance.promoteToLeader);
			}
		}
		else
		{
			instance.promoteToLeader = null;
		}
		if (getClanInfo != null)
		{
			if (instance.getClanInfo == null)
			{
				instance.getClanInfo = getClanInfo.Copy();
			}
			else
			{
				getClanInfo.CopyTo(instance.getClanInfo);
			}
		}
		else
		{
			instance.getClanInfo = null;
		}
		if (setClanMotd != null)
		{
			if (instance.setClanMotd == null)
			{
				instance.setClanMotd = setClanMotd.Copy();
			}
			else
			{
				setClanMotd.CopyTo(instance.setClanMotd);
			}
		}
		else
		{
			instance.setClanMotd = null;
		}
		if (getClanChat != null)
		{
			if (instance.getClanChat == null)
			{
				instance.getClanChat = getClanChat.Copy();
			}
			else
			{
				getClanChat.CopyTo(instance.getClanChat);
			}
		}
		else
		{
			instance.getClanChat = null;
		}
		if (sendClanMessage != null)
		{
			if (instance.sendClanMessage == null)
			{
				instance.sendClanMessage = sendClanMessage.Copy();
			}
			else
			{
				sendClanMessage.CopyTo(instance.sendClanMessage);
			}
		}
		else
		{
			instance.sendClanMessage = null;
		}
		if (getNexusAuth != null)
		{
			if (instance.getNexusAuth == null)
			{
				instance.getNexusAuth = getNexusAuth.Copy();
			}
			else
			{
				getNexusAuth.CopyTo(instance.getNexusAuth);
			}
		}
		else
		{
			instance.getNexusAuth = null;
		}
		if (cameraSubscribe != null)
		{
			if (instance.cameraSubscribe == null)
			{
				instance.cameraSubscribe = cameraSubscribe.Copy();
			}
			else
			{
				cameraSubscribe.CopyTo(instance.cameraSubscribe);
			}
		}
		else
		{
			instance.cameraSubscribe = null;
		}
		if (cameraUnsubscribe != null)
		{
			if (instance.cameraUnsubscribe == null)
			{
				instance.cameraUnsubscribe = cameraUnsubscribe.Copy();
			}
			else
			{
				cameraUnsubscribe.CopyTo(instance.cameraUnsubscribe);
			}
		}
		else
		{
			instance.cameraUnsubscribe = null;
		}
		if (cameraInput != null)
		{
			if (instance.cameraInput == null)
			{
				instance.cameraInput = cameraInput.Copy();
			}
			else
			{
				cameraInput.CopyTo(instance.cameraInput);
			}
		}
		else
		{
			instance.cameraInput = null;
		}
	}

	public AppRequest Copy()
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		CopyTo(appRequest);
		return appRequest;
	}

	public static AppRequest Deserialize(BufferStream stream)
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		Deserialize(stream, appRequest, isDelta: false);
		return appRequest;
	}

	public static AppRequest DeserializeLengthDelimited(BufferStream stream)
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		DeserializeLengthDelimited(stream, appRequest, isDelta: false);
		return appRequest;
	}

	public static AppRequest DeserializeLength(BufferStream stream, int length)
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		DeserializeLength(stream, length, appRequest, isDelta: false);
		return appRequest;
	}

	public static AppRequest Deserialize(byte[] buffer)
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appRequest, isDelta: false);
		return appRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppRequest Deserialize(BufferStream stream, AppRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
			instance.playerId = 0uL;
			instance.playerToken = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 66:
				if (instance.getInfo == null)
				{
					instance.getInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getInfo, isDelta);
				}
				continue;
			case 74:
				if (instance.getTime == null)
				{
					instance.getTime = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTime, isDelta);
				}
				continue;
			case 82:
				if (instance.getMap == null)
				{
					instance.getMap = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getMap, isDelta);
				}
				continue;
			case 90:
				if (instance.getTeamInfo == null)
				{
					instance.getTeamInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.getTeamChat == null)
				{
					instance.getTeamChat = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamChat, isDelta);
				}
				continue;
			case 106:
				if (instance.sendTeamMessage == null)
				{
					instance.sendTeamMessage = AppSendMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSendMessage.DeserializeLengthDelimited(stream, instance.sendTeamMessage, isDelta);
				}
				continue;
			case 114:
				if (instance.getEntityInfo == null)
				{
					instance.getEntityInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getEntityInfo, isDelta);
				}
				continue;
			case 122:
				if (instance.setEntityValue == null)
				{
					instance.setEntityValue = AppSetEntityValue.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSetEntityValue.DeserializeLengthDelimited(stream, instance.setEntityValue, isDelta);
				}
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.checkSubscription == null)
					{
						instance.checkSubscription = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.checkSubscription, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setSubscription == null)
					{
						instance.setSubscription = AppFlag.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppFlag.DeserializeLengthDelimited(stream, instance.setSubscription, isDelta);
					}
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getMapMarkers == null)
					{
						instance.getMapMarkers = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getMapMarkers, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.promoteToLeader == null)
					{
						instance.promoteToLeader = AppPromoteToLeader.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppPromoteToLeader.DeserializeLengthDelimited(stream, instance.promoteToLeader, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanInfo == null)
					{
						instance.getClanInfo = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanInfo, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setClanMotd == null)
					{
						instance.setClanMotd = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.setClanMotd, isDelta);
					}
				}
				break;
			case 23u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanChat == null)
					{
						instance.getClanChat = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanChat, isDelta);
					}
				}
				break;
			case 24u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.sendClanMessage == null)
					{
						instance.sendClanMessage = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.sendClanMessage, isDelta);
					}
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getNexusAuth == null)
					{
						instance.getNexusAuth = AppGetNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppGetNexusAuth.DeserializeLengthDelimited(stream, instance.getNexusAuth, isDelta);
					}
				}
				break;
			case 30u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribe == null)
					{
						instance.cameraSubscribe = AppCameraSubscribe.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraSubscribe.DeserializeLengthDelimited(stream, instance.cameraSubscribe, isDelta);
					}
				}
				break;
			case 31u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraUnsubscribe == null)
					{
						instance.cameraUnsubscribe = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.cameraUnsubscribe, isDelta);
					}
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraInput == null)
					{
						instance.cameraInput = AppCameraInput.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInput.DeserializeLengthDelimited(stream, instance.cameraInput, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static AppRequest DeserializeLengthDelimited(BufferStream stream, AppRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
			instance.playerId = 0uL;
			instance.playerToken = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 66:
				if (instance.getInfo == null)
				{
					instance.getInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getInfo, isDelta);
				}
				continue;
			case 74:
				if (instance.getTime == null)
				{
					instance.getTime = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTime, isDelta);
				}
				continue;
			case 82:
				if (instance.getMap == null)
				{
					instance.getMap = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getMap, isDelta);
				}
				continue;
			case 90:
				if (instance.getTeamInfo == null)
				{
					instance.getTeamInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.getTeamChat == null)
				{
					instance.getTeamChat = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamChat, isDelta);
				}
				continue;
			case 106:
				if (instance.sendTeamMessage == null)
				{
					instance.sendTeamMessage = AppSendMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSendMessage.DeserializeLengthDelimited(stream, instance.sendTeamMessage, isDelta);
				}
				continue;
			case 114:
				if (instance.getEntityInfo == null)
				{
					instance.getEntityInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getEntityInfo, isDelta);
				}
				continue;
			case 122:
				if (instance.setEntityValue == null)
				{
					instance.setEntityValue = AppSetEntityValue.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSetEntityValue.DeserializeLengthDelimited(stream, instance.setEntityValue, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.checkSubscription == null)
					{
						instance.checkSubscription = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.checkSubscription, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setSubscription == null)
					{
						instance.setSubscription = AppFlag.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppFlag.DeserializeLengthDelimited(stream, instance.setSubscription, isDelta);
					}
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getMapMarkers == null)
					{
						instance.getMapMarkers = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getMapMarkers, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.promoteToLeader == null)
					{
						instance.promoteToLeader = AppPromoteToLeader.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppPromoteToLeader.DeserializeLengthDelimited(stream, instance.promoteToLeader, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanInfo == null)
					{
						instance.getClanInfo = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanInfo, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setClanMotd == null)
					{
						instance.setClanMotd = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.setClanMotd, isDelta);
					}
				}
				break;
			case 23u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanChat == null)
					{
						instance.getClanChat = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanChat, isDelta);
					}
				}
				break;
			case 24u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.sendClanMessage == null)
					{
						instance.sendClanMessage = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.sendClanMessage, isDelta);
					}
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getNexusAuth == null)
					{
						instance.getNexusAuth = AppGetNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppGetNexusAuth.DeserializeLengthDelimited(stream, instance.getNexusAuth, isDelta);
					}
				}
				break;
			case 30u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribe == null)
					{
						instance.cameraSubscribe = AppCameraSubscribe.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraSubscribe.DeserializeLengthDelimited(stream, instance.cameraSubscribe, isDelta);
					}
				}
				break;
			case 31u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraUnsubscribe == null)
					{
						instance.cameraUnsubscribe = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.cameraUnsubscribe, isDelta);
					}
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraInput == null)
					{
						instance.cameraInput = AppCameraInput.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInput.DeserializeLengthDelimited(stream, instance.cameraInput, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppRequest DeserializeLength(BufferStream stream, int length, AppRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
			instance.playerId = 0uL;
			instance.playerToken = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 66:
				if (instance.getInfo == null)
				{
					instance.getInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getInfo, isDelta);
				}
				continue;
			case 74:
				if (instance.getTime == null)
				{
					instance.getTime = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTime, isDelta);
				}
				continue;
			case 82:
				if (instance.getMap == null)
				{
					instance.getMap = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getMap, isDelta);
				}
				continue;
			case 90:
				if (instance.getTeamInfo == null)
				{
					instance.getTeamInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.getTeamChat == null)
				{
					instance.getTeamChat = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamChat, isDelta);
				}
				continue;
			case 106:
				if (instance.sendTeamMessage == null)
				{
					instance.sendTeamMessage = AppSendMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSendMessage.DeserializeLengthDelimited(stream, instance.sendTeamMessage, isDelta);
				}
				continue;
			case 114:
				if (instance.getEntityInfo == null)
				{
					instance.getEntityInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getEntityInfo, isDelta);
				}
				continue;
			case 122:
				if (instance.setEntityValue == null)
				{
					instance.setEntityValue = AppSetEntityValue.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSetEntityValue.DeserializeLengthDelimited(stream, instance.setEntityValue, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.checkSubscription == null)
					{
						instance.checkSubscription = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.checkSubscription, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setSubscription == null)
					{
						instance.setSubscription = AppFlag.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppFlag.DeserializeLengthDelimited(stream, instance.setSubscription, isDelta);
					}
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getMapMarkers == null)
					{
						instance.getMapMarkers = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getMapMarkers, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.promoteToLeader == null)
					{
						instance.promoteToLeader = AppPromoteToLeader.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppPromoteToLeader.DeserializeLengthDelimited(stream, instance.promoteToLeader, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanInfo == null)
					{
						instance.getClanInfo = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanInfo, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setClanMotd == null)
					{
						instance.setClanMotd = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.setClanMotd, isDelta);
					}
				}
				break;
			case 23u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanChat == null)
					{
						instance.getClanChat = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanChat, isDelta);
					}
				}
				break;
			case 24u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.sendClanMessage == null)
					{
						instance.sendClanMessage = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.sendClanMessage, isDelta);
					}
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getNexusAuth == null)
					{
						instance.getNexusAuth = AppGetNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppGetNexusAuth.DeserializeLengthDelimited(stream, instance.getNexusAuth, isDelta);
					}
				}
				break;
			case 30u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribe == null)
					{
						instance.cameraSubscribe = AppCameraSubscribe.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraSubscribe.DeserializeLengthDelimited(stream, instance.cameraSubscribe, isDelta);
					}
				}
				break;
			case 31u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraUnsubscribe == null)
					{
						instance.cameraUnsubscribe = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.cameraUnsubscribe, isDelta);
					}
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraInput == null)
					{
						instance.cameraInput = AppCameraInput.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInput.DeserializeLengthDelimited(stream, instance.cameraInput, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppRequest instance, AppRequest previous)
	{
		if (instance.seq != previous.seq)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seq);
		}
		if (instance.playerId != previous.playerId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.playerToken != previous.playerToken)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerToken);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		if (instance.getInfo != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getInfo, previous.getInfo);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.getTime != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getTime, previous.getTime);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTime (ProtoBuf.AppEmpty)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.getMap != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getMap, previous.getMap);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getMap (ProtoBuf.AppEmpty)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.getTeamInfo != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getTeamInfo, previous.getTeamInfo);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTeamInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.getTeamChat != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getTeamChat, previous.getTeamChat);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTeamChat (ProtoBuf.AppEmpty)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.sendTeamMessage != null)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			AppSendMessage.SerializeDelta(stream, instance.sendTeamMessage, previous.sendTeamMessage);
			int val = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val, span6, 0);
			if (num6 < 5)
			{
				span6[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span6[num6++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.getEntityInfo != null)
		{
			stream.WriteByte(114);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getEntityInfo, previous.getEntityInfo);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getEntityInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.setEntityValue != null)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			AppSetEntityValue.SerializeDelta(stream, instance.setEntityValue, previous.setEntityValue);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field setEntityValue (ProtoBuf.AppSetEntityValue)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
		if (instance.checkSubscription != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.checkSubscription, previous.checkSubscription);
			int num9 = stream.Position - position9;
			if (num9 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field checkSubscription (ProtoBuf.AppEmpty)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num9, span9, 0);
		}
		if (instance.setSubscription != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(1);
			BufferStream.RangeHandle range10 = stream.GetRange(1);
			int position10 = stream.Position;
			AppFlag.SerializeDelta(stream, instance.setSubscription, previous.setSubscription);
			int num10 = stream.Position - position10;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field setSubscription (ProtoBuf.AppFlag)");
			}
			Span<byte> span10 = range10.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		}
		if (instance.getMapMarkers != null)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			BufferStream.RangeHandle range11 = stream.GetRange(1);
			int position11 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getMapMarkers, previous.getMapMarkers);
			int num11 = stream.Position - position11;
			if (num11 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getMapMarkers (ProtoBuf.AppEmpty)");
			}
			Span<byte> span11 = range11.GetSpan();
			ProtocolParser.WriteUInt32((uint)num11, span11, 0);
		}
		if (instance.promoteToLeader != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range12 = stream.GetRange(1);
			int position12 = stream.Position;
			AppPromoteToLeader.SerializeDelta(stream, instance.promoteToLeader, previous.promoteToLeader);
			int num12 = stream.Position - position12;
			if (num12 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field promoteToLeader (ProtoBuf.AppPromoteToLeader)");
			}
			Span<byte> span12 = range12.GetSpan();
			ProtocolParser.WriteUInt32((uint)num12, span12, 0);
		}
		if (instance.getClanInfo != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range13 = stream.GetRange(1);
			int position13 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getClanInfo, previous.getClanInfo);
			int num13 = stream.Position - position13;
			if (num13 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getClanInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span13 = range13.GetSpan();
			ProtocolParser.WriteUInt32((uint)num13, span13, 0);
		}
		if (instance.setClanMotd != null)
		{
			stream.WriteByte(178);
			stream.WriteByte(1);
			BufferStream.RangeHandle range14 = stream.GetRange(5);
			int position14 = stream.Position;
			AppSendMessage.SerializeDelta(stream, instance.setClanMotd, previous.setClanMotd);
			int val2 = stream.Position - position14;
			Span<byte> span14 = range14.GetSpan();
			int num14 = ProtocolParser.WriteUInt32((uint)val2, span14, 0);
			if (num14 < 5)
			{
				span14[num14 - 1] |= 128;
				while (num14 < 4)
				{
					span14[num14++] = 128;
				}
				span14[4] = 0;
			}
		}
		if (instance.getClanChat != null)
		{
			stream.WriteByte(186);
			stream.WriteByte(1);
			BufferStream.RangeHandle range15 = stream.GetRange(1);
			int position15 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getClanChat, previous.getClanChat);
			int num15 = stream.Position - position15;
			if (num15 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getClanChat (ProtoBuf.AppEmpty)");
			}
			Span<byte> span15 = range15.GetSpan();
			ProtocolParser.WriteUInt32((uint)num15, span15, 0);
		}
		if (instance.sendClanMessage != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(1);
			BufferStream.RangeHandle range16 = stream.GetRange(5);
			int position16 = stream.Position;
			AppSendMessage.SerializeDelta(stream, instance.sendClanMessage, previous.sendClanMessage);
			int val3 = stream.Position - position16;
			Span<byte> span16 = range16.GetSpan();
			int num16 = ProtocolParser.WriteUInt32((uint)val3, span16, 0);
			if (num16 < 5)
			{
				span16[num16 - 1] |= 128;
				while (num16 < 4)
				{
					span16[num16++] = 128;
				}
				span16[4] = 0;
			}
		}
		if (instance.getNexusAuth != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(1);
			BufferStream.RangeHandle range17 = stream.GetRange(5);
			int position17 = stream.Position;
			AppGetNexusAuth.SerializeDelta(stream, instance.getNexusAuth, previous.getNexusAuth);
			int val4 = stream.Position - position17;
			Span<byte> span17 = range17.GetSpan();
			int num17 = ProtocolParser.WriteUInt32((uint)val4, span17, 0);
			if (num17 < 5)
			{
				span17[num17 - 1] |= 128;
				while (num17 < 4)
				{
					span17[num17++] = 128;
				}
				span17[4] = 0;
			}
		}
		if (instance.cameraSubscribe != null)
		{
			stream.WriteByte(242);
			stream.WriteByte(1);
			BufferStream.RangeHandle range18 = stream.GetRange(5);
			int position18 = stream.Position;
			AppCameraSubscribe.SerializeDelta(stream, instance.cameraSubscribe, previous.cameraSubscribe);
			int val5 = stream.Position - position18;
			Span<byte> span18 = range18.GetSpan();
			int num18 = ProtocolParser.WriteUInt32((uint)val5, span18, 0);
			if (num18 < 5)
			{
				span18[num18 - 1] |= 128;
				while (num18 < 4)
				{
					span18[num18++] = 128;
				}
				span18[4] = 0;
			}
		}
		if (instance.cameraUnsubscribe != null)
		{
			stream.WriteByte(250);
			stream.WriteByte(1);
			BufferStream.RangeHandle range19 = stream.GetRange(1);
			int position19 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.cameraUnsubscribe, previous.cameraUnsubscribe);
			int num19 = stream.Position - position19;
			if (num19 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraUnsubscribe (ProtoBuf.AppEmpty)");
			}
			Span<byte> span19 = range19.GetSpan();
			ProtocolParser.WriteUInt32((uint)num19, span19, 0);
		}
		if (instance.cameraInput != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(2);
			BufferStream.RangeHandle range20 = stream.GetRange(1);
			int position20 = stream.Position;
			AppCameraInput.SerializeDelta(stream, instance.cameraInput, previous.cameraInput);
			int num20 = stream.Position - position20;
			if (num20 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraInput (ProtoBuf.AppCameraInput)");
			}
			Span<byte> span20 = range20.GetSpan();
			ProtocolParser.WriteUInt32((uint)num20, span20, 0);
		}
	}

	public static void Serialize(BufferStream stream, AppRequest instance)
	{
		if (instance.seq != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seq);
		}
		if (instance.playerId != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.playerToken != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerToken);
		}
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.getInfo != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			AppEmpty.Serialize(stream, instance.getInfo);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.getTime != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			AppEmpty.Serialize(stream, instance.getTime);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTime (ProtoBuf.AppEmpty)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.getMap != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			AppEmpty.Serialize(stream, instance.getMap);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getMap (ProtoBuf.AppEmpty)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.getTeamInfo != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			AppEmpty.Serialize(stream, instance.getTeamInfo);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTeamInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.getTeamChat != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			AppEmpty.Serialize(stream, instance.getTeamChat);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTeamChat (ProtoBuf.AppEmpty)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.sendTeamMessage != null)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			AppSendMessage.Serialize(stream, instance.sendTeamMessage);
			int val = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val, span6, 0);
			if (num6 < 5)
			{
				span6[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span6[num6++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.getEntityInfo != null)
		{
			stream.WriteByte(114);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			AppEmpty.Serialize(stream, instance.getEntityInfo);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getEntityInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.setEntityValue != null)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			AppSetEntityValue.Serialize(stream, instance.setEntityValue);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field setEntityValue (ProtoBuf.AppSetEntityValue)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
		if (instance.checkSubscription != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AppEmpty.Serialize(stream, instance.checkSubscription);
			int num9 = stream.Position - position9;
			if (num9 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field checkSubscription (ProtoBuf.AppEmpty)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num9, span9, 0);
		}
		if (instance.setSubscription != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(1);
			BufferStream.RangeHandle range10 = stream.GetRange(1);
			int position10 = stream.Position;
			AppFlag.Serialize(stream, instance.setSubscription);
			int num10 = stream.Position - position10;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field setSubscription (ProtoBuf.AppFlag)");
			}
			Span<byte> span10 = range10.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		}
		if (instance.getMapMarkers != null)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			BufferStream.RangeHandle range11 = stream.GetRange(1);
			int position11 = stream.Position;
			AppEmpty.Serialize(stream, instance.getMapMarkers);
			int num11 = stream.Position - position11;
			if (num11 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getMapMarkers (ProtoBuf.AppEmpty)");
			}
			Span<byte> span11 = range11.GetSpan();
			ProtocolParser.WriteUInt32((uint)num11, span11, 0);
		}
		if (instance.promoteToLeader != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range12 = stream.GetRange(1);
			int position12 = stream.Position;
			AppPromoteToLeader.Serialize(stream, instance.promoteToLeader);
			int num12 = stream.Position - position12;
			if (num12 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field promoteToLeader (ProtoBuf.AppPromoteToLeader)");
			}
			Span<byte> span12 = range12.GetSpan();
			ProtocolParser.WriteUInt32((uint)num12, span12, 0);
		}
		if (instance.getClanInfo != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range13 = stream.GetRange(1);
			int position13 = stream.Position;
			AppEmpty.Serialize(stream, instance.getClanInfo);
			int num13 = stream.Position - position13;
			if (num13 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getClanInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span13 = range13.GetSpan();
			ProtocolParser.WriteUInt32((uint)num13, span13, 0);
		}
		if (instance.setClanMotd != null)
		{
			stream.WriteByte(178);
			stream.WriteByte(1);
			BufferStream.RangeHandle range14 = stream.GetRange(5);
			int position14 = stream.Position;
			AppSendMessage.Serialize(stream, instance.setClanMotd);
			int val2 = stream.Position - position14;
			Span<byte> span14 = range14.GetSpan();
			int num14 = ProtocolParser.WriteUInt32((uint)val2, span14, 0);
			if (num14 < 5)
			{
				span14[num14 - 1] |= 128;
				while (num14 < 4)
				{
					span14[num14++] = 128;
				}
				span14[4] = 0;
			}
		}
		if (instance.getClanChat != null)
		{
			stream.WriteByte(186);
			stream.WriteByte(1);
			BufferStream.RangeHandle range15 = stream.GetRange(1);
			int position15 = stream.Position;
			AppEmpty.Serialize(stream, instance.getClanChat);
			int num15 = stream.Position - position15;
			if (num15 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getClanChat (ProtoBuf.AppEmpty)");
			}
			Span<byte> span15 = range15.GetSpan();
			ProtocolParser.WriteUInt32((uint)num15, span15, 0);
		}
		if (instance.sendClanMessage != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(1);
			BufferStream.RangeHandle range16 = stream.GetRange(5);
			int position16 = stream.Position;
			AppSendMessage.Serialize(stream, instance.sendClanMessage);
			int val3 = stream.Position - position16;
			Span<byte> span16 = range16.GetSpan();
			int num16 = ProtocolParser.WriteUInt32((uint)val3, span16, 0);
			if (num16 < 5)
			{
				span16[num16 - 1] |= 128;
				while (num16 < 4)
				{
					span16[num16++] = 128;
				}
				span16[4] = 0;
			}
		}
		if (instance.getNexusAuth != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(1);
			BufferStream.RangeHandle range17 = stream.GetRange(5);
			int position17 = stream.Position;
			AppGetNexusAuth.Serialize(stream, instance.getNexusAuth);
			int val4 = stream.Position - position17;
			Span<byte> span17 = range17.GetSpan();
			int num17 = ProtocolParser.WriteUInt32((uint)val4, span17, 0);
			if (num17 < 5)
			{
				span17[num17 - 1] |= 128;
				while (num17 < 4)
				{
					span17[num17++] = 128;
				}
				span17[4] = 0;
			}
		}
		if (instance.cameraSubscribe != null)
		{
			stream.WriteByte(242);
			stream.WriteByte(1);
			BufferStream.RangeHandle range18 = stream.GetRange(5);
			int position18 = stream.Position;
			AppCameraSubscribe.Serialize(stream, instance.cameraSubscribe);
			int val5 = stream.Position - position18;
			Span<byte> span18 = range18.GetSpan();
			int num18 = ProtocolParser.WriteUInt32((uint)val5, span18, 0);
			if (num18 < 5)
			{
				span18[num18 - 1] |= 128;
				while (num18 < 4)
				{
					span18[num18++] = 128;
				}
				span18[4] = 0;
			}
		}
		if (instance.cameraUnsubscribe != null)
		{
			stream.WriteByte(250);
			stream.WriteByte(1);
			BufferStream.RangeHandle range19 = stream.GetRange(1);
			int position19 = stream.Position;
			AppEmpty.Serialize(stream, instance.cameraUnsubscribe);
			int num19 = stream.Position - position19;
			if (num19 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraUnsubscribe (ProtoBuf.AppEmpty)");
			}
			Span<byte> span19 = range19.GetSpan();
			ProtocolParser.WriteUInt32((uint)num19, span19, 0);
		}
		if (instance.cameraInput != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(2);
			BufferStream.RangeHandle range20 = stream.GetRange(1);
			int position20 = stream.Position;
			AppCameraInput.Serialize(stream, instance.cameraInput);
			int num20 = stream.Position - position20;
			if (num20 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraInput (ProtoBuf.AppCameraInput)");
			}
			Span<byte> span20 = range20.GetSpan();
			ProtocolParser.WriteUInt32((uint)num20, span20, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
		getInfo?.InspectUids(action);
		getTime?.InspectUids(action);
		getMap?.InspectUids(action);
		getTeamInfo?.InspectUids(action);
		getTeamChat?.InspectUids(action);
		sendTeamMessage?.InspectUids(action);
		getEntityInfo?.InspectUids(action);
		setEntityValue?.InspectUids(action);
		checkSubscription?.InspectUids(action);
		setSubscription?.InspectUids(action);
		getMapMarkers?.InspectUids(action);
		promoteToLeader?.InspectUids(action);
		getClanInfo?.InspectUids(action);
		setClanMotd?.InspectUids(action);
		getClanChat?.InspectUids(action);
		sendClanMessage?.InspectUids(action);
		getNexusAuth?.InspectUids(action);
		cameraSubscribe?.InspectUids(action);
		cameraUnsubscribe?.InspectUids(action);
		cameraInput?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppMessage : IDisposable, IPooled, IProto<AppMessage>, IProto
{
	[NonSerialized]
	public AppResponse response;

	[NonSerialized]
	public AppBroadcast broadcast;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppMessage instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.response != null)
			{
				instance.response.ResetToPool();
				instance.response = null;
			}
			if (instance.broadcast != null)
			{
				instance.broadcast.ResetToPool();
				instance.broadcast = null;
			}
			Pool.Free<AppMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppMessage instance)
	{
		if (response != null)
		{
			if (instance.response == null)
			{
				instance.response = response.Copy();
			}
			else
			{
				response.CopyTo(instance.response);
			}
		}
		else
		{
			instance.response = null;
		}
		if (broadcast != null)
		{
			if (instance.broadcast == null)
			{
				instance.broadcast = broadcast.Copy();
			}
			else
			{
				broadcast.CopyTo(instance.broadcast);
			}
		}
		else
		{
			instance.broadcast = null;
		}
	}

	public AppMessage Copy()
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		CopyTo(appMessage);
		return appMessage;
	}

	public static AppMessage Deserialize(BufferStream stream)
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		Deserialize(stream, appMessage, isDelta: false);
		return appMessage;
	}

	public static AppMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		DeserializeLengthDelimited(stream, appMessage, isDelta: false);
		return appMessage;
	}

	public static AppMessage DeserializeLength(BufferStream stream, int length)
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		DeserializeLength(stream, length, appMessage, isDelta: false);
		return appMessage;
	}

	public static AppMessage Deserialize(byte[] buffer)
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appMessage, isDelta: false);
		return appMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppMessage Deserialize(BufferStream stream, AppMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.response == null)
				{
					instance.response = AppResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppResponse.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			case 18:
				if (instance.broadcast == null)
				{
					instance.broadcast = AppBroadcast.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppBroadcast.DeserializeLengthDelimited(stream, instance.broadcast, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static AppMessage DeserializeLengthDelimited(BufferStream stream, AppMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.response == null)
				{
					instance.response = AppResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppResponse.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			case 18:
				if (instance.broadcast == null)
				{
					instance.broadcast = AppBroadcast.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppBroadcast.DeserializeLengthDelimited(stream, instance.broadcast, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppMessage DeserializeLength(BufferStream stream, int length, AppMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.response == null)
				{
					instance.response = AppResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppResponse.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			case 18:
				if (instance.broadcast == null)
				{
					instance.broadcast = AppBroadcast.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppBroadcast.DeserializeLengthDelimited(stream, instance.broadcast, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppMessage instance, AppMessage previous)
	{
		if (instance.response != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppResponse.SerializeDelta(stream, instance.response, previous.response);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.broadcast == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		AppBroadcast.SerializeDelta(stream, instance.broadcast, previous.broadcast);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppMessage instance)
	{
		if (instance.response != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppResponse.Serialize(stream, instance.response);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.broadcast == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		AppBroadcast.Serialize(stream, instance.broadcast);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		response?.InspectUids(action);
		broadcast?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppResponse : IDisposable, IPooled, IProto<AppResponse>, IProto
{
	[NonSerialized]
	public uint seq;

	[NonSerialized]
	public AppSuccess success;

	[NonSerialized]
	public AppError error;

	[NonSerialized]
	public AppInfo info;

	[NonSerialized]
	public AppTime time;

	[NonSerialized]
	public AppMap map;

	[NonSerialized]
	public AppTeamInfo teamInfo;

	[NonSerialized]
	public AppTeamChat teamChat;

	[NonSerialized]
	public AppEntityInfo entityInfo;

	[NonSerialized]
	public AppFlag flag;

	[NonSerialized]
	public AppMapMarkers mapMarkers;

	[NonSerialized]
	public AppClanInfo clanInfo;

	[NonSerialized]
	public AppClanChat clanChat;

	[NonSerialized]
	public AppNexusAuth nexusAuth;

	[NonSerialized]
	public AppCameraInfo cameraSubscribeInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppResponse instance)
	{
		if (instance.ShouldPool)
		{
			instance.seq = 0u;
			if (instance.success != null)
			{
				instance.success.ResetToPool();
				instance.success = null;
			}
			if (instance.error != null)
			{
				instance.error.ResetToPool();
				instance.error = null;
			}
			if (instance.info != null)
			{
				instance.info.ResetToPool();
				instance.info = null;
			}
			if (instance.time != null)
			{
				instance.time.ResetToPool();
				instance.time = null;
			}
			if (instance.map != null)
			{
				instance.map.ResetToPool();
				instance.map = null;
			}
			if (instance.teamInfo != null)
			{
				instance.teamInfo.ResetToPool();
				instance.teamInfo = null;
			}
			if (instance.teamChat != null)
			{
				instance.teamChat.ResetToPool();
				instance.teamChat = null;
			}
			if (instance.entityInfo != null)
			{
				instance.entityInfo.ResetToPool();
				instance.entityInfo = null;
			}
			if (instance.flag != null)
			{
				instance.flag.ResetToPool();
				instance.flag = null;
			}
			if (instance.mapMarkers != null)
			{
				instance.mapMarkers.ResetToPool();
				instance.mapMarkers = null;
			}
			if (instance.clanInfo != null)
			{
				instance.clanInfo.ResetToPool();
				instance.clanInfo = null;
			}
			if (instance.clanChat != null)
			{
				instance.clanChat.ResetToPool();
				instance.clanChat = null;
			}
			if (instance.nexusAuth != null)
			{
				instance.nexusAuth.ResetToPool();
				instance.nexusAuth = null;
			}
			if (instance.cameraSubscribeInfo != null)
			{
				instance.cameraSubscribeInfo.ResetToPool();
				instance.cameraSubscribeInfo = null;
			}
			Pool.Free<AppResponse>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppResponse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppResponse instance)
	{
		instance.seq = seq;
		if (success != null)
		{
			if (instance.success == null)
			{
				instance.success = success.Copy();
			}
			else
			{
				success.CopyTo(instance.success);
			}
		}
		else
		{
			instance.success = null;
		}
		if (error != null)
		{
			if (instance.error == null)
			{
				instance.error = error.Copy();
			}
			else
			{
				error.CopyTo(instance.error);
			}
		}
		else
		{
			instance.error = null;
		}
		if (info != null)
		{
			if (instance.info == null)
			{
				instance.info = info.Copy();
			}
			else
			{
				info.CopyTo(instance.info);
			}
		}
		else
		{
			instance.info = null;
		}
		if (time != null)
		{
			if (instance.time == null)
			{
				instance.time = time.Copy();
			}
			else
			{
				time.CopyTo(instance.time);
			}
		}
		else
		{
			instance.time = null;
		}
		if (map != null)
		{
			if (instance.map == null)
			{
				instance.map = map.Copy();
			}
			else
			{
				map.CopyTo(instance.map);
			}
		}
		else
		{
			instance.map = null;
		}
		if (teamInfo != null)
		{
			if (instance.teamInfo == null)
			{
				instance.teamInfo = teamInfo.Copy();
			}
			else
			{
				teamInfo.CopyTo(instance.teamInfo);
			}
		}
		else
		{
			instance.teamInfo = null;
		}
		if (teamChat != null)
		{
			if (instance.teamChat == null)
			{
				instance.teamChat = teamChat.Copy();
			}
			else
			{
				teamChat.CopyTo(instance.teamChat);
			}
		}
		else
		{
			instance.teamChat = null;
		}
		if (entityInfo != null)
		{
			if (instance.entityInfo == null)
			{
				instance.entityInfo = entityInfo.Copy();
			}
			else
			{
				entityInfo.CopyTo(instance.entityInfo);
			}
		}
		else
		{
			instance.entityInfo = null;
		}
		if (flag != null)
		{
			if (instance.flag == null)
			{
				instance.flag = flag.Copy();
			}
			else
			{
				flag.CopyTo(instance.flag);
			}
		}
		else
		{
			instance.flag = null;
		}
		if (mapMarkers != null)
		{
			if (instance.mapMarkers == null)
			{
				instance.mapMarkers = mapMarkers.Copy();
			}
			else
			{
				mapMarkers.CopyTo(instance.mapMarkers);
			}
		}
		else
		{
			instance.mapMarkers = null;
		}
		if (clanInfo != null)
		{
			if (instance.clanInfo == null)
			{
				instance.clanInfo = clanInfo.Copy();
			}
			else
			{
				clanInfo.CopyTo(instance.clanInfo);
			}
		}
		else
		{
			instance.clanInfo = null;
		}
		if (clanChat != null)
		{
			if (instance.clanChat == null)
			{
				instance.clanChat = clanChat.Copy();
			}
			else
			{
				clanChat.CopyTo(instance.clanChat);
			}
		}
		else
		{
			instance.clanChat = null;
		}
		if (nexusAuth != null)
		{
			if (instance.nexusAuth == null)
			{
				instance.nexusAuth = nexusAuth.Copy();
			}
			else
			{
				nexusAuth.CopyTo(instance.nexusAuth);
			}
		}
		else
		{
			instance.nexusAuth = null;
		}
		if (cameraSubscribeInfo != null)
		{
			if (instance.cameraSubscribeInfo == null)
			{
				instance.cameraSubscribeInfo = cameraSubscribeInfo.Copy();
			}
			else
			{
				cameraSubscribeInfo.CopyTo(instance.cameraSubscribeInfo);
			}
		}
		else
		{
			instance.cameraSubscribeInfo = null;
		}
	}

	public AppResponse Copy()
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		CopyTo(appResponse);
		return appResponse;
	}

	public static AppResponse Deserialize(BufferStream stream)
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		Deserialize(stream, appResponse, isDelta: false);
		return appResponse;
	}

	public static AppResponse DeserializeLengthDelimited(BufferStream stream)
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		DeserializeLengthDelimited(stream, appResponse, isDelta: false);
		return appResponse;
	}

	public static AppResponse DeserializeLength(BufferStream stream, int length)
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		DeserializeLength(stream, length, appResponse, isDelta: false);
		return appResponse;
	}

	public static AppResponse Deserialize(byte[] buffer)
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appResponse, isDelta: false);
		return appResponse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppResponse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppResponse Deserialize(BufferStream stream, AppResponse instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				if (instance.success == null)
				{
					instance.success = AppSuccess.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSuccess.DeserializeLengthDelimited(stream, instance.success, isDelta);
				}
				continue;
			case 42:
				if (instance.error == null)
				{
					instance.error = AppError.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppError.DeserializeLengthDelimited(stream, instance.error, isDelta);
				}
				continue;
			case 50:
				if (instance.info == null)
				{
					instance.info = AppInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				continue;
			case 58:
				if (instance.time == null)
				{
					instance.time = AppTime.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTime.DeserializeLengthDelimited(stream, instance.time, isDelta);
				}
				continue;
			case 66:
				if (instance.map == null)
				{
					instance.map = AppMap.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMap.DeserializeLengthDelimited(stream, instance.map, isDelta);
				}
				continue;
			case 74:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				continue;
			case 82:
				if (instance.teamChat == null)
				{
					instance.teamChat = AppTeamChat.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChat.DeserializeLengthDelimited(stream, instance.teamChat, isDelta);
				}
				continue;
			case 90:
				if (instance.entityInfo == null)
				{
					instance.entityInfo = AppEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityInfo.DeserializeLengthDelimited(stream, instance.entityInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.flag == null)
				{
					instance.flag = AppFlag.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppFlag.DeserializeLengthDelimited(stream, instance.flag, isDelta);
				}
				continue;
			case 106:
				if (instance.mapMarkers == null)
				{
					instance.mapMarkers = AppMapMarkers.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMapMarkers.DeserializeLengthDelimited(stream, instance.mapMarkers, isDelta);
				}
				continue;
			case 122:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = AppClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.clanChat == null)
					{
						instance.clanChat = AppClanChat.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppClanChat.DeserializeLengthDelimited(stream, instance.clanChat, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.nexusAuth == null)
					{
						instance.nexusAuth = AppNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppNexusAuth.DeserializeLengthDelimited(stream, instance.nexusAuth, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribeInfo == null)
					{
						instance.cameraSubscribeInfo = AppCameraInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInfo.DeserializeLengthDelimited(stream, instance.cameraSubscribeInfo, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static AppResponse DeserializeLengthDelimited(BufferStream stream, AppResponse instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				if (instance.success == null)
				{
					instance.success = AppSuccess.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSuccess.DeserializeLengthDelimited(stream, instance.success, isDelta);
				}
				continue;
			case 42:
				if (instance.error == null)
				{
					instance.error = AppError.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppError.DeserializeLengthDelimited(stream, instance.error, isDelta);
				}
				continue;
			case 50:
				if (instance.info == null)
				{
					instance.info = AppInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				continue;
			case 58:
				if (instance.time == null)
				{
					instance.time = AppTime.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTime.DeserializeLengthDelimited(stream, instance.time, isDelta);
				}
				continue;
			case 66:
				if (instance.map == null)
				{
					instance.map = AppMap.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMap.DeserializeLengthDelimited(stream, instance.map, isDelta);
				}
				continue;
			case 74:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				continue;
			case 82:
				if (instance.teamChat == null)
				{
					instance.teamChat = AppTeamChat.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChat.DeserializeLengthDelimited(stream, instance.teamChat, isDelta);
				}
				continue;
			case 90:
				if (instance.entityInfo == null)
				{
					instance.entityInfo = AppEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityInfo.DeserializeLengthDelimited(stream, instance.entityInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.flag == null)
				{
					instance.flag = AppFlag.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppFlag.DeserializeLengthDelimited(stream, instance.flag, isDelta);
				}
				continue;
			case 106:
				if (instance.mapMarkers == null)
				{
					instance.mapMarkers = AppMapMarkers.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMapMarkers.DeserializeLengthDelimited(stream, instance.mapMarkers, isDelta);
				}
				continue;
			case 122:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = AppClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.clanChat == null)
					{
						instance.clanChat = AppClanChat.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppClanChat.DeserializeLengthDelimited(stream, instance.clanChat, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.nexusAuth == null)
					{
						instance.nexusAuth = AppNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppNexusAuth.DeserializeLengthDelimited(stream, instance.nexusAuth, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribeInfo == null)
					{
						instance.cameraSubscribeInfo = AppCameraInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInfo.DeserializeLengthDelimited(stream, instance.cameraSubscribeInfo, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppResponse DeserializeLength(BufferStream stream, int length, AppResponse instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				if (instance.success == null)
				{
					instance.success = AppSuccess.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSuccess.DeserializeLengthDelimited(stream, instance.success, isDelta);
				}
				continue;
			case 42:
				if (instance.error == null)
				{
					instance.error = AppError.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppError.DeserializeLengthDelimited(stream, instance.error, isDelta);
				}
				continue;
			case 50:
				if (instance.info == null)
				{
					instance.info = AppInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				continue;
			case 58:
				if (instance.time == null)
				{
					instance.time = AppTime.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTime.DeserializeLengthDelimited(stream, instance.time, isDelta);
				}
				continue;
			case 66:
				if (instance.map == null)
				{
					instance.map = AppMap.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMap.DeserializeLengthDelimited(stream, instance.map, isDelta);
				}
				continue;
			case 74:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				continue;
			case 82:
				if (instance.teamChat == null)
				{
					instance.teamChat = AppTeamChat.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChat.DeserializeLengthDelimited(stream, instance.teamChat, isDelta);
				}
				continue;
			case 90:
				if (instance.entityInfo == null)
				{
					instance.entityInfo = AppEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityInfo.DeserializeLengthDelimited(stream, instance.entityInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.flag == null)
				{
					instance.flag = AppFlag.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppFlag.DeserializeLengthDelimited(stream, instance.flag, isDelta);
				}
				continue;
			case 106:
				if (instance.mapMarkers == null)
				{
					instance.mapMarkers = AppMapMarkers.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMapMarkers.DeserializeLengthDelimited(stream, instance.mapMarkers, isDelta);
				}
				continue;
			case 122:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = AppClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.clanChat == null)
					{
						instance.clanChat = AppClanChat.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppClanChat.DeserializeLengthDelimited(stream, instance.clanChat, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.nexusAuth == null)
					{
						instance.nexusAuth = AppNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppNexusAuth.DeserializeLengthDelimited(stream, instance.nexusAuth, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribeInfo == null)
					{
						instance.cameraSubscribeInfo = AppCameraInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInfo.DeserializeLengthDelimited(stream, instance.cameraSubscribeInfo, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppResponse instance, AppResponse previous)
	{
		if (instance.seq != previous.seq)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seq);
		}
		if (instance.success != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			AppSuccess.SerializeDelta(stream, instance.success, previous.success);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field success (ProtoBuf.AppSuccess)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.error != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			AppError.SerializeDelta(stream, instance.error, previous.error);
			int val = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.info != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			AppInfo.SerializeDelta(stream, instance.info, previous.info);
			int val2 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val2, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
		if (instance.time != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			AppTime.SerializeDelta(stream, instance.time, previous.time);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field time (ProtoBuf.AppTime)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.map != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			AppMap.SerializeDelta(stream, instance.map, previous.map);
			int val3 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)val3, span5, 0);
			if (num5 < 5)
			{
				span5[num5 - 1] |= 128;
				while (num5 < 4)
				{
					span5[num5++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.teamInfo != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			AppTeamInfo.SerializeDelta(stream, instance.teamInfo, previous.teamInfo);
			int val4 = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val4, span6, 0);
			if (num6 < 5)
			{
				span6[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span6[num6++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.teamChat != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range7 = stream.GetRange(5);
			int position7 = stream.Position;
			AppTeamChat.SerializeDelta(stream, instance.teamChat, previous.teamChat);
			int val5 = stream.Position - position7;
			Span<byte> span7 = range7.GetSpan();
			int num7 = ProtocolParser.WriteUInt32((uint)val5, span7, 0);
			if (num7 < 5)
			{
				span7[num7 - 1] |= 128;
				while (num7 < 4)
				{
					span7[num7++] = 128;
				}
				span7[4] = 0;
			}
		}
		if (instance.entityInfo != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range8 = stream.GetRange(3);
			int position8 = stream.Position;
			AppEntityInfo.SerializeDelta(stream, instance.entityInfo, previous.entityInfo);
			int num8 = stream.Position - position8;
			if (num8 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entityInfo (ProtoBuf.AppEntityInfo)");
			}
			Span<byte> span8 = range8.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)num8, span8, 0);
			if (num9 < 3)
			{
				span8[num9 - 1] |= 128;
				while (num9 < 2)
				{
					span8[num9++] = 128;
				}
				span8[2] = 0;
			}
		}
		if (instance.flag != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AppFlag.SerializeDelta(stream, instance.flag, previous.flag);
			int num10 = stream.Position - position9;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field flag (ProtoBuf.AppFlag)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span9, 0);
		}
		if (instance.mapMarkers != null)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range10 = stream.GetRange(5);
			int position10 = stream.Position;
			AppMapMarkers.SerializeDelta(stream, instance.mapMarkers, previous.mapMarkers);
			int val6 = stream.Position - position10;
			Span<byte> span10 = range10.GetSpan();
			int num11 = ProtocolParser.WriteUInt32((uint)val6, span10, 0);
			if (num11 < 5)
			{
				span10[num11 - 1] |= 128;
				while (num11 < 4)
				{
					span10[num11++] = 128;
				}
				span10[4] = 0;
			}
		}
		if (instance.clanInfo != null)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range11 = stream.GetRange(5);
			int position11 = stream.Position;
			AppClanInfo.SerializeDelta(stream, instance.clanInfo, previous.clanInfo);
			int val7 = stream.Position - position11;
			Span<byte> span11 = range11.GetSpan();
			int num12 = ProtocolParser.WriteUInt32((uint)val7, span11, 0);
			if (num12 < 5)
			{
				span11[num12 - 1] |= 128;
				while (num12 < 4)
				{
					span11[num12++] = 128;
				}
				span11[4] = 0;
			}
		}
		if (instance.clanChat != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range12 = stream.GetRange(5);
			int position12 = stream.Position;
			AppClanChat.SerializeDelta(stream, instance.clanChat, previous.clanChat);
			int val8 = stream.Position - position12;
			Span<byte> span12 = range12.GetSpan();
			int num13 = ProtocolParser.WriteUInt32((uint)val8, span12, 0);
			if (num13 < 5)
			{
				span12[num13 - 1] |= 128;
				while (num13 < 4)
				{
					span12[num13++] = 128;
				}
				span12[4] = 0;
			}
		}
		if (instance.nexusAuth != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(1);
			BufferStream.RangeHandle range13 = stream.GetRange(5);
			int position13 = stream.Position;
			AppNexusAuth.SerializeDelta(stream, instance.nexusAuth, previous.nexusAuth);
			int val9 = stream.Position - position13;
			Span<byte> span13 = range13.GetSpan();
			int num14 = ProtocolParser.WriteUInt32((uint)val9, span13, 0);
			if (num14 < 5)
			{
				span13[num14 - 1] |= 128;
				while (num14 < 4)
				{
					span13[num14++] = 128;
				}
				span13[4] = 0;
			}
		}
		if (instance.cameraSubscribeInfo != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range14 = stream.GetRange(1);
			int position14 = stream.Position;
			AppCameraInfo.SerializeDelta(stream, instance.cameraSubscribeInfo, previous.cameraSubscribeInfo);
			int num15 = stream.Position - position14;
			if (num15 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraSubscribeInfo (ProtoBuf.AppCameraInfo)");
			}
			Span<byte> span14 = range14.GetSpan();
			ProtocolParser.WriteUInt32((uint)num15, span14, 0);
		}
	}

	public static void Serialize(BufferStream stream, AppResponse instance)
	{
		if (instance.seq != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seq);
		}
		if (instance.success != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			AppSuccess.Serialize(stream, instance.success);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field success (ProtoBuf.AppSuccess)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.error != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			AppError.Serialize(stream, instance.error);
			int val = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.info != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			AppInfo.Serialize(stream, instance.info);
			int val2 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val2, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
		if (instance.time != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			AppTime.Serialize(stream, instance.time);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field time (ProtoBuf.AppTime)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.map != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			AppMap.Serialize(stream, instance.map);
			int val3 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)val3, span5, 0);
			if (num5 < 5)
			{
				span5[num5 - 1] |= 128;
				while (num5 < 4)
				{
					span5[num5++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.teamInfo != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			AppTeamInfo.Serialize(stream, instance.teamInfo);
			int val4 = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val4, span6, 0);
			if (num6 < 5)
			{
				span6[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span6[num6++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.teamChat != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range7 = stream.GetRange(5);
			int position7 = stream.Position;
			AppTeamChat.Serialize(stream, instance.teamChat);
			int val5 = stream.Position - position7;
			Span<byte> span7 = range7.GetSpan();
			int num7 = ProtocolParser.WriteUInt32((uint)val5, span7, 0);
			if (num7 < 5)
			{
				span7[num7 - 1] |= 128;
				while (num7 < 4)
				{
					span7[num7++] = 128;
				}
				span7[4] = 0;
			}
		}
		if (instance.entityInfo != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range8 = stream.GetRange(3);
			int position8 = stream.Position;
			AppEntityInfo.Serialize(stream, instance.entityInfo);
			int num8 = stream.Position - position8;
			if (num8 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entityInfo (ProtoBuf.AppEntityInfo)");
			}
			Span<byte> span8 = range8.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)num8, span8, 0);
			if (num9 < 3)
			{
				span8[num9 - 1] |= 128;
				while (num9 < 2)
				{
					span8[num9++] = 128;
				}
				span8[2] = 0;
			}
		}
		if (instance.flag != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AppFlag.Serialize(stream, instance.flag);
			int num10 = stream.Position - position9;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field flag (ProtoBuf.AppFlag)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span9, 0);
		}
		if (instance.mapMarkers != null)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range10 = stream.GetRange(5);
			int position10 = stream.Position;
			AppMapMarkers.Serialize(stream, instance.mapMarkers);
			int val6 = stream.Position - position10;
			Span<byte> span10 = range10.GetSpan();
			int num11 = ProtocolParser.WriteUInt32((uint)val6, span10, 0);
			if (num11 < 5)
			{
				span10[num11 - 1] |= 128;
				while (num11 < 4)
				{
					span10[num11++] = 128;
				}
				span10[4] = 0;
			}
		}
		if (instance.clanInfo != null)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range11 = stream.GetRange(5);
			int position11 = stream.Position;
			AppClanInfo.Serialize(stream, instance.clanInfo);
			int val7 = stream.Position - position11;
			Span<byte> span11 = range11.GetSpan();
			int num12 = ProtocolParser.WriteUInt32((uint)val7, span11, 0);
			if (num12 < 5)
			{
				span11[num12 - 1] |= 128;
				while (num12 < 4)
				{
					span11[num12++] = 128;
				}
				span11[4] = 0;
			}
		}
		if (instance.clanChat != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range12 = stream.GetRange(5);
			int position12 = stream.Position;
			AppClanChat.Serialize(stream, instance.clanChat);
			int val8 = stream.Position - position12;
			Span<byte> span12 = range12.GetSpan();
			int num13 = ProtocolParser.WriteUInt32((uint)val8, span12, 0);
			if (num13 < 5)
			{
				span12[num13 - 1] |= 128;
				while (num13 < 4)
				{
					span12[num13++] = 128;
				}
				span12[4] = 0;
			}
		}
		if (instance.nexusAuth != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(1);
			BufferStream.RangeHandle range13 = stream.GetRange(5);
			int position13 = stream.Position;
			AppNexusAuth.Serialize(stream, instance.nexusAuth);
			int val9 = stream.Position - position13;
			Span<byte> span13 = range13.GetSpan();
			int num14 = ProtocolParser.WriteUInt32((uint)val9, span13, 0);
			if (num14 < 5)
			{
				span13[num14 - 1] |= 128;
				while (num14 < 4)
				{
					span13[num14++] = 128;
				}
				span13[4] = 0;
			}
		}
		if (instance.cameraSubscribeInfo != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range14 = stream.GetRange(1);
			int position14 = stream.Position;
			AppCameraInfo.Serialize(stream, instance.cameraSubscribeInfo);
			int num15 = stream.Position - position14;
			if (num15 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraSubscribeInfo (ProtoBuf.AppCameraInfo)");
			}
			Span<byte> span14 = range14.GetSpan();
			ProtocolParser.WriteUInt32((uint)num15, span14, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		success?.InspectUids(action);
		error?.InspectUids(action);
		info?.InspectUids(action);
		time?.InspectUids(action);
		map?.InspectUids(action);
		teamInfo?.InspectUids(action);
		teamChat?.InspectUids(action);
		entityInfo?.InspectUids(action);
		flag?.InspectUids(action);
		mapMarkers?.InspectUids(action);
		clanInfo?.InspectUids(action);
		clanChat?.InspectUids(action);
		nexusAuth?.InspectUids(action);
		cameraSubscribeInfo?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppBroadcast : IDisposable, IPooled, IProto<AppBroadcast>, IProto
{
	[NonSerialized]
	public AppTeamChanged teamChanged;

	[NonSerialized]
	public AppNewTeamMessage teamMessage;

	[NonSerialized]
	public AppEntityChanged entityChanged;

	[NonSerialized]
	public AppClanChanged clanChanged;

	[NonSerialized]
	public AppNewClanMessage clanMessage;

	[NonSerialized]
	public AppCameraRays cameraRays;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppBroadcast instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.teamChanged != null)
			{
				instance.teamChanged.ResetToPool();
				instance.teamChanged = null;
			}
			if (instance.teamMessage != null)
			{
				instance.teamMessage.ResetToPool();
				instance.teamMessage = null;
			}
			if (instance.entityChanged != null)
			{
				instance.entityChanged.ResetToPool();
				instance.entityChanged = null;
			}
			if (instance.clanChanged != null)
			{
				instance.clanChanged.ResetToPool();
				instance.clanChanged = null;
			}
			if (instance.clanMessage != null)
			{
				instance.clanMessage.ResetToPool();
				instance.clanMessage = null;
			}
			if (instance.cameraRays != null)
			{
				instance.cameraRays.ResetToPool();
				instance.cameraRays = null;
			}
			Pool.Free<AppBroadcast>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppBroadcast with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppBroadcast instance)
	{
		if (teamChanged != null)
		{
			if (instance.teamChanged == null)
			{
				instance.teamChanged = teamChanged.Copy();
			}
			else
			{
				teamChanged.CopyTo(instance.teamChanged);
			}
		}
		else
		{
			instance.teamChanged = null;
		}
		if (teamMessage != null)
		{
			if (instance.teamMessage == null)
			{
				instance.teamMessage = teamMessage.Copy();
			}
			else
			{
				teamMessage.CopyTo(instance.teamMessage);
			}
		}
		else
		{
			instance.teamMessage = null;
		}
		if (entityChanged != null)
		{
			if (instance.entityChanged == null)
			{
				instance.entityChanged = entityChanged.Copy();
			}
			else
			{
				entityChanged.CopyTo(instance.entityChanged);
			}
		}
		else
		{
			instance.entityChanged = null;
		}
		if (clanChanged != null)
		{
			if (instance.clanChanged == null)
			{
				instance.clanChanged = clanChanged.Copy();
			}
			else
			{
				clanChanged.CopyTo(instance.clanChanged);
			}
		}
		else
		{
			instance.clanChanged = null;
		}
		if (clanMessage != null)
		{
			if (instance.clanMessage == null)
			{
				instance.clanMessage = clanMessage.Copy();
			}
			else
			{
				clanMessage.CopyTo(instance.clanMessage);
			}
		}
		else
		{
			instance.clanMessage = null;
		}
		if (cameraRays != null)
		{
			if (instance.cameraRays == null)
			{
				instance.cameraRays = cameraRays.Copy();
			}
			else
			{
				cameraRays.CopyTo(instance.cameraRays);
			}
		}
		else
		{
			instance.cameraRays = null;
		}
	}

	public AppBroadcast Copy()
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		CopyTo(appBroadcast);
		return appBroadcast;
	}

	public static AppBroadcast Deserialize(BufferStream stream)
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		Deserialize(stream, appBroadcast, isDelta: false);
		return appBroadcast;
	}

	public static AppBroadcast DeserializeLengthDelimited(BufferStream stream)
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		DeserializeLengthDelimited(stream, appBroadcast, isDelta: false);
		return appBroadcast;
	}

	public static AppBroadcast DeserializeLength(BufferStream stream, int length)
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		DeserializeLength(stream, length, appBroadcast, isDelta: false);
		return appBroadcast;
	}

	public static AppBroadcast Deserialize(byte[] buffer)
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appBroadcast, isDelta: false);
		return appBroadcast;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppBroadcast previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppBroadcast Deserialize(BufferStream stream, AppBroadcast instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 34:
				if (instance.teamChanged == null)
				{
					instance.teamChanged = AppTeamChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChanged.DeserializeLengthDelimited(stream, instance.teamChanged, isDelta);
				}
				break;
			case 42:
				if (instance.teamMessage == null)
				{
					instance.teamMessage = AppNewTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewTeamMessage.DeserializeLengthDelimited(stream, instance.teamMessage, isDelta);
				}
				break;
			case 50:
				if (instance.entityChanged == null)
				{
					instance.entityChanged = AppEntityChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityChanged.DeserializeLengthDelimited(stream, instance.entityChanged, isDelta);
				}
				break;
			case 58:
				if (instance.clanChanged == null)
				{
					instance.clanChanged = AppClanChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanChanged.DeserializeLengthDelimited(stream, instance.clanChanged, isDelta);
				}
				break;
			case 66:
				if (instance.clanMessage == null)
				{
					instance.clanMessage = AppNewClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewClanMessage.DeserializeLengthDelimited(stream, instance.clanMessage, isDelta);
				}
				break;
			case 82:
				if (instance.cameraRays == null)
				{
					instance.cameraRays = AppCameraRays.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppCameraRays.DeserializeLengthDelimited(stream, instance.cameraRays, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static AppBroadcast DeserializeLengthDelimited(BufferStream stream, AppBroadcast instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 34:
				if (instance.teamChanged == null)
				{
					instance.teamChanged = AppTeamChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChanged.DeserializeLengthDelimited(stream, instance.teamChanged, isDelta);
				}
				break;
			case 42:
				if (instance.teamMessage == null)
				{
					instance.teamMessage = AppNewTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewTeamMessage.DeserializeLengthDelimited(stream, instance.teamMessage, isDelta);
				}
				break;
			case 50:
				if (instance.entityChanged == null)
				{
					instance.entityChanged = AppEntityChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityChanged.DeserializeLengthDelimited(stream, instance.entityChanged, isDelta);
				}
				break;
			case 58:
				if (instance.clanChanged == null)
				{
					instance.clanChanged = AppClanChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanChanged.DeserializeLengthDelimited(stream, instance.clanChanged, isDelta);
				}
				break;
			case 66:
				if (instance.clanMessage == null)
				{
					instance.clanMessage = AppNewClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewClanMessage.DeserializeLengthDelimited(stream, instance.clanMessage, isDelta);
				}
				break;
			case 82:
				if (instance.cameraRays == null)
				{
					instance.cameraRays = AppCameraRays.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppCameraRays.DeserializeLengthDelimited(stream, instance.cameraRays, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppBroadcast DeserializeLength(BufferStream stream, int length, AppBroadcast instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 34:
				if (instance.teamChanged == null)
				{
					instance.teamChanged = AppTeamChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChanged.DeserializeLengthDelimited(stream, instance.teamChanged, isDelta);
				}
				break;
			case 42:
				if (instance.teamMessage == null)
				{
					instance.teamMessage = AppNewTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewTeamMessage.DeserializeLengthDelimited(stream, instance.teamMessage, isDelta);
				}
				break;
			case 50:
				if (instance.entityChanged == null)
				{
					instance.entityChanged = AppEntityChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityChanged.DeserializeLengthDelimited(stream, instance.entityChanged, isDelta);
				}
				break;
			case 58:
				if (instance.clanChanged == null)
				{
					instance.clanChanged = AppClanChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanChanged.DeserializeLengthDelimited(stream, instance.clanChanged, isDelta);
				}
				break;
			case 66:
				if (instance.clanMessage == null)
				{
					instance.clanMessage = AppNewClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewClanMessage.DeserializeLengthDelimited(stream, instance.clanMessage, isDelta);
				}
				break;
			case 82:
				if (instance.cameraRays == null)
				{
					instance.cameraRays = AppCameraRays.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppCameraRays.DeserializeLengthDelimited(stream, instance.cameraRays, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppBroadcast instance, AppBroadcast previous)
	{
		if (instance.teamChanged != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppTeamChanged.SerializeDelta(stream, instance.teamChanged, previous.teamChanged);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.teamMessage != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			AppNewTeamMessage.SerializeDelta(stream, instance.teamMessage, previous.teamMessage);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.entityChanged != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(3);
			int position3 = stream.Position;
			AppEntityChanged.SerializeDelta(stream, instance.entityChanged, previous.entityChanged);
			int num3 = stream.Position - position3;
			if (num3 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entityChanged (ProtoBuf.AppEntityChanged)");
			}
			Span<byte> span3 = range3.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			if (num4 < 3)
			{
				span3[num4 - 1] |= 128;
				while (num4 < 2)
				{
					span3[num4++] = 128;
				}
				span3[2] = 0;
			}
		}
		if (instance.clanChanged != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			AppClanChanged.SerializeDelta(stream, instance.clanChanged, previous.clanChanged);
			int val3 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)val3, span4, 0);
			if (num5 < 5)
			{
				span4[num5 - 1] |= 128;
				while (num5 < 4)
				{
					span4[num5++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.clanMessage != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			AppNewClanMessage.SerializeDelta(stream, instance.clanMessage, previous.clanMessage);
			int val4 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val4, span5, 0);
			if (num6 < 5)
			{
				span5[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span5[num6++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.cameraRays == null)
		{
			return;
		}
		stream.WriteByte(82);
		BufferStream.RangeHandle range6 = stream.GetRange(5);
		int position6 = stream.Position;
		AppCameraRays.SerializeDelta(stream, instance.cameraRays, previous.cameraRays);
		int val5 = stream.Position - position6;
		Span<byte> span6 = range6.GetSpan();
		int num7 = ProtocolParser.WriteUInt32((uint)val5, span6, 0);
		if (num7 < 5)
		{
			span6[num7 - 1] |= 128;
			while (num7 < 4)
			{
				span6[num7++] = 128;
			}
			span6[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppBroadcast instance)
	{
		if (instance.teamChanged != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppTeamChanged.Serialize(stream, instance.teamChanged);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.teamMessage != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			AppNewTeamMessage.Serialize(stream, instance.teamMessage);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.entityChanged != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(3);
			int position3 = stream.Position;
			AppEntityChanged.Serialize(stream, instance.entityChanged);
			int num3 = stream.Position - position3;
			if (num3 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entityChanged (ProtoBuf.AppEntityChanged)");
			}
			Span<byte> span3 = range3.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			if (num4 < 3)
			{
				span3[num4 - 1] |= 128;
				while (num4 < 2)
				{
					span3[num4++] = 128;
				}
				span3[2] = 0;
			}
		}
		if (instance.clanChanged != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			AppClanChanged.Serialize(stream, instance.clanChanged);
			int val3 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)val3, span4, 0);
			if (num5 < 5)
			{
				span4[num5 - 1] |= 128;
				while (num5 < 4)
				{
					span4[num5++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.clanMessage != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			AppNewClanMessage.Serialize(stream, instance.clanMessage);
			int val4 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val4, span5, 0);
			if (num6 < 5)
			{
				span5[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span5[num6++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.cameraRays == null)
		{
			return;
		}
		stream.WriteByte(82);
		BufferStream.RangeHandle range6 = stream.GetRange(5);
		int position6 = stream.Position;
		AppCameraRays.Serialize(stream, instance.cameraRays);
		int val5 = stream.Position - position6;
		Span<byte> span6 = range6.GetSpan();
		int num7 = ProtocolParser.WriteUInt32((uint)val5, span6, 0);
		if (num7 < 5)
		{
			span6[num7 - 1] |= 128;
			while (num7 < 4)
			{
				span6[num7++] = 128;
			}
			span6[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		teamChanged?.InspectUids(action);
		teamMessage?.InspectUids(action);
		entityChanged?.InspectUids(action);
		clanChanged?.InspectUids(action);
		clanMessage?.InspectUids(action);
		cameraRays?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppEmpty : IDisposable, IPooled, IProto<AppEmpty>, IProto
{
	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppEmpty instance)
	{
		if (instance.ShouldPool)
		{
			Pool.Free<AppEmpty>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppEmpty with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppEmpty instance)
	{
	}

	public AppEmpty Copy()
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		CopyTo(appEmpty);
		return appEmpty;
	}

	public static AppEmpty Deserialize(BufferStream stream)
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		Deserialize(stream, appEmpty, isDelta: false);
		return appEmpty;
	}

	public static AppEmpty DeserializeLengthDelimited(BufferStream stream)
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		DeserializeLengthDelimited(stream, appEmpty, isDelta: false);
		return appEmpty;
	}

	public static AppEmpty DeserializeLength(BufferStream stream, int length)
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		DeserializeLength(stream, length, appEmpty, isDelta: false);
		return appEmpty;
	}

	public static AppEmpty Deserialize(byte[] buffer)
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appEmpty, isDelta: false);
		return appEmpty;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppEmpty previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppEmpty Deserialize(BufferStream stream, AppEmpty instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static AppEmpty DeserializeLengthDelimited(BufferStream stream, AppEmpty instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static AppEmpty DeserializeLength(BufferStream stream, int length, AppEmpty instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppEmpty instance, AppEmpty previous)
	{
	}

	public static void Serialize(BufferStream stream, AppEmpty instance)
	{
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppSendMessage : IDisposable, IPooled, IProto<AppSendMessage>, IProto
{
	[NonSerialized]
	public string message;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppSendMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.message = string.Empty;
			Pool.Free<AppSendMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppSendMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppSendMessage instance)
	{
		instance.message = message;
	}

	public AppSendMessage Copy()
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		CopyTo(appSendMessage);
		return appSendMessage;
	}

	public static AppSendMessage Deserialize(BufferStream stream)
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		Deserialize(stream, appSendMessage, isDelta: false);
		return appSendMessage;
	}

	public static AppSendMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		DeserializeLengthDelimited(stream, appSendMessage, isDelta: false);
		return appSendMessage;
	}

	public static AppSendMessage DeserializeLength(BufferStream stream, int length)
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		DeserializeLength(stream, length, appSendMessage, isDelta: false);
		return appSendMessage;
	}

	public static AppSendMessage Deserialize(byte[] buffer)
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appSendMessage, isDelta: false);
		return appSendMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppSendMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppSendMessage Deserialize(BufferStream stream, AppSendMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppSendMessage DeserializeLengthDelimited(BufferStream stream, AppSendMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppSendMessage DeserializeLength(BufferStream stream, int length, AppSendMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppSendMessage instance, AppSendMessage previous)
	{
		if (instance.message != previous.message)
		{
			if (instance.message == null)
			{
				throw new ArgumentNullException("message", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.message);
		}
	}

	public static void Serialize(BufferStream stream, AppSendMessage instance)
	{
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.message);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppSetEntityValue : IDisposable, IPooled, IProto<AppSetEntityValue>, IProto
{
	[NonSerialized]
	public bool value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppSetEntityValue instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = false;
			Pool.Free<AppSetEntityValue>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppSetEntityValue with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppSetEntityValue instance)
	{
		instance.value = value;
	}

	public AppSetEntityValue Copy()
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		CopyTo(appSetEntityValue);
		return appSetEntityValue;
	}

	public static AppSetEntityValue Deserialize(BufferStream stream)
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		Deserialize(stream, appSetEntityValue, isDelta: false);
		return appSetEntityValue;
	}

	public static AppSetEntityValue DeserializeLengthDelimited(BufferStream stream)
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		DeserializeLengthDelimited(stream, appSetEntityValue, isDelta: false);
		return appSetEntityValue;
	}

	public static AppSetEntityValue DeserializeLength(BufferStream stream, int length)
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		DeserializeLength(stream, length, appSetEntityValue, isDelta: false);
		return appSetEntityValue;
	}

	public static AppSetEntityValue Deserialize(byte[] buffer)
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appSetEntityValue, isDelta: false);
		return appSetEntityValue;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppSetEntityValue previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppSetEntityValue Deserialize(BufferStream stream, AppSetEntityValue instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppSetEntityValue DeserializeLengthDelimited(BufferStream stream, AppSetEntityValue instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppSetEntityValue DeserializeLength(BufferStream stream, int length, AppSetEntityValue instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppSetEntityValue instance, AppSetEntityValue previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.value);
	}

	public static void Serialize(BufferStream stream, AppSetEntityValue instance)
	{
		if (instance.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppPromoteToLeader : IDisposable, IPooled, IProto<AppPromoteToLeader>, IProto
{
	[NonSerialized]
	public ulong steamId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppPromoteToLeader instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			Pool.Free<AppPromoteToLeader>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppPromoteToLeader with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppPromoteToLeader instance)
	{
		instance.steamId = steamId;
	}

	public AppPromoteToLeader Copy()
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		CopyTo(appPromoteToLeader);
		return appPromoteToLeader;
	}

	public static AppPromoteToLeader Deserialize(BufferStream stream)
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		Deserialize(stream, appPromoteToLeader, isDelta: false);
		return appPromoteToLeader;
	}

	public static AppPromoteToLeader DeserializeLengthDelimited(BufferStream stream)
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		DeserializeLengthDelimited(stream, appPromoteToLeader, isDelta: false);
		return appPromoteToLeader;
	}

	public static AppPromoteToLeader DeserializeLength(BufferStream stream, int length)
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		DeserializeLength(stream, length, appPromoteToLeader, isDelta: false);
		return appPromoteToLeader;
	}

	public static AppPromoteToLeader Deserialize(byte[] buffer)
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appPromoteToLeader, isDelta: false);
		return appPromoteToLeader;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppPromoteToLeader previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppPromoteToLeader Deserialize(BufferStream stream, AppPromoteToLeader instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppPromoteToLeader DeserializeLengthDelimited(BufferStream stream, AppPromoteToLeader instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppPromoteToLeader DeserializeLength(BufferStream stream, int length, AppPromoteToLeader instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppPromoteToLeader instance, AppPromoteToLeader previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
	}

	public static void Serialize(BufferStream stream, AppPromoteToLeader instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppGetNexusAuth : IDisposable, IPooled, IProto<AppGetNexusAuth>, IProto
{
	[NonSerialized]
	public string appKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppGetNexusAuth instance)
	{
		if (instance.ShouldPool)
		{
			instance.appKey = string.Empty;
			Pool.Free<AppGetNexusAuth>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppGetNexusAuth with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppGetNexusAuth instance)
	{
		instance.appKey = appKey;
	}

	public AppGetNexusAuth Copy()
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		CopyTo(appGetNexusAuth);
		return appGetNexusAuth;
	}

	public static AppGetNexusAuth Deserialize(BufferStream stream)
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		Deserialize(stream, appGetNexusAuth, isDelta: false);
		return appGetNexusAuth;
	}

	public static AppGetNexusAuth DeserializeLengthDelimited(BufferStream stream)
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		DeserializeLengthDelimited(stream, appGetNexusAuth, isDelta: false);
		return appGetNexusAuth;
	}

	public static AppGetNexusAuth DeserializeLength(BufferStream stream, int length)
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		DeserializeLength(stream, length, appGetNexusAuth, isDelta: false);
		return appGetNexusAuth;
	}

	public static AppGetNexusAuth Deserialize(byte[] buffer)
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appGetNexusAuth, isDelta: false);
		return appGetNexusAuth;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppGetNexusAuth previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppGetNexusAuth Deserialize(BufferStream stream, AppGetNexusAuth instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.appKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppGetNexusAuth DeserializeLengthDelimited(BufferStream stream, AppGetNexusAuth instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.appKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppGetNexusAuth DeserializeLength(BufferStream stream, int length, AppGetNexusAuth instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.appKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppGetNexusAuth instance, AppGetNexusAuth previous)
	{
		if (instance.appKey != previous.appKey)
		{
			if (instance.appKey == null)
			{
				throw new ArgumentNullException("appKey", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.appKey);
		}
	}

	public static void Serialize(BufferStream stream, AppGetNexusAuth instance)
	{
		if (instance.appKey == null)
		{
			throw new ArgumentNullException("appKey", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.appKey);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppCameraSubscribe : IDisposable, IPooled, IProto<AppCameraSubscribe>, IProto
{
	[NonSerialized]
	public string cameraId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppCameraSubscribe instance)
	{
		if (instance.ShouldPool)
		{
			instance.cameraId = string.Empty;
			Pool.Free<AppCameraSubscribe>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppCameraSubscribe with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppCameraSubscribe instance)
	{
		instance.cameraId = cameraId;
	}

	public AppCameraSubscribe Copy()
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		CopyTo(appCameraSubscribe);
		return appCameraSubscribe;
	}

	public static AppCameraSubscribe Deserialize(BufferStream stream)
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		Deserialize(stream, appCameraSubscribe, isDelta: false);
		return appCameraSubscribe;
	}

	public static AppCameraSubscribe DeserializeLengthDelimited(BufferStream stream)
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		DeserializeLengthDelimited(stream, appCameraSubscribe, isDelta: false);
		return appCameraSubscribe;
	}

	public static AppCameraSubscribe DeserializeLength(BufferStream stream, int length)
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		DeserializeLength(stream, length, appCameraSubscribe, isDelta: false);
		return appCameraSubscribe;
	}

	public static AppCameraSubscribe Deserialize(byte[] buffer)
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appCameraSubscribe, isDelta: false);
		return appCameraSubscribe;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppCameraSubscribe previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppCameraSubscribe Deserialize(BufferStream stream, AppCameraSubscribe instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.cameraId = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppCameraSubscribe DeserializeLengthDelimited(BufferStream stream, AppCameraSubscribe instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.cameraId = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppCameraSubscribe DeserializeLength(BufferStream stream, int length, AppCameraSubscribe instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.cameraId = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppCameraSubscribe instance, AppCameraSubscribe previous)
	{
		if (instance.cameraId != previous.cameraId)
		{
			if (instance.cameraId == null)
			{
				throw new ArgumentNullException("cameraId", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.cameraId);
		}
	}

	public static void Serialize(BufferStream stream, AppCameraSubscribe instance)
	{
		if (instance.cameraId == null)
		{
			throw new ArgumentNullException("cameraId", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.cameraId);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class AppCameraInput : IDisposable, IPooled, IProto<AppCameraInput>, IProto
{
	[NonSerialized]
	public int buttons;

	[NonSerialized]
	public Vector2 mouseDelta;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppCameraInput instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.buttons = 0;
			instance.mouseDelta = default(Vector2);
			Pool.Free<AppCameraInput>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppCameraInput with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppCameraInput instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.buttons = buttons;
		instance.mouseDelta = mouseDelta;
	}

	public AppCameraInput Copy()
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		CopyTo(appCameraInput);
		return appCameraInput;
	}

	public static AppCameraInput Deserialize(BufferStream stream)
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		Deserialize(stream, appCameraInput, isDelta: false);
		return appCameraInput;
	}

	public static AppCameraInput DeserializeLengthDelimited(BufferStream stream)
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		DeserializeLengthDelimited(stream, appCameraInput, isDelta: false);
		return appCameraInput;
	}

	public static AppCameraInput DeserializeLength(BufferStream stream, int length)
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		DeserializeLength(stream, length, appCameraInput, isDelta: false);
		return appCameraInput;
	}

	public static AppCameraInput Deserialize(byte[] buffer)
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appCameraInput, isDelta: false);
		return appCameraInput;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppCameraInput previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppCameraInput Deserialize(BufferStream stream, AppCameraInput instance, bool isDelta)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.buttons = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppCameraInput DeserializeLengthDelimited(BufferStream stream, AppCameraInput instance, bool isDelta)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.buttons = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppCameraInput DeserializeLength(BufferStream stream, int length, AppCameraInput instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.buttons = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppCameraInput instance, AppCameraInput previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.buttons != previous.buttons)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.buttons);
		}
		if (instance.mouseDelta != previous.mouseDelta)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector2Serialized.SerializeDelta(stream, instance.mouseDelta, previous.mouseDelta);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mouseDelta (UnityEngine.Vector2)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, AppCameraInput instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.buttons != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.buttons);
		}
		if (instance.mouseDelta != default(Vector2))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector2Serialized.Serialize(stream, instance.mouseDelta);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mouseDelta (UnityEngine.Vector2)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppSuccess : IDisposable, IPooled, IProto<AppSuccess>, IProto
{
	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppSuccess instance)
	{
		if (instance.ShouldPool)
		{
			Pool.Free<AppSuccess>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppSuccess with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppSuccess instance)
	{
	}

	public AppSuccess Copy()
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		CopyTo(appSuccess);
		return appSuccess;
	}

	public static AppSuccess Deserialize(BufferStream stream)
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		Deserialize(stream, appSuccess, isDelta: false);
		return appSuccess;
	}

	public static AppSuccess DeserializeLengthDelimited(BufferStream stream)
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		DeserializeLengthDelimited(stream, appSuccess, isDelta: false);
		return appSuccess;
	}

	public static AppSuccess DeserializeLength(BufferStream stream, int length)
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		DeserializeLength(stream, length, appSuccess, isDelta: false);
		return appSuccess;
	}

	public static AppSuccess Deserialize(byte[] buffer)
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appSuccess, isDelta: false);
		return appSuccess;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppSuccess previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppSuccess Deserialize(BufferStream stream, AppSuccess instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static AppSuccess DeserializeLengthDelimited(BufferStream stream, AppSuccess instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static AppSuccess DeserializeLength(BufferStream stream, int length, AppSuccess instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppSuccess instance, AppSuccess previous)
	{
	}

	public static void Serialize(BufferStream stream, AppSuccess instance)
	{
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppError : IDisposable, IPooled, IProto<AppError>, IProto
{
	[NonSerialized]
	public string error;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppError instance)
	{
		if (instance.ShouldPool)
		{
			instance.error = string.Empty;
			Pool.Free<AppError>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppError with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppError instance)
	{
		instance.error = error;
	}

	public AppError Copy()
	{
		AppError appError = Pool.Get<AppError>();
		CopyTo(appError);
		return appError;
	}

	public static AppError Deserialize(BufferStream stream)
	{
		AppError appError = Pool.Get<AppError>();
		Deserialize(stream, appError, isDelta: false);
		return appError;
	}

	public static AppError DeserializeLengthDelimited(BufferStream stream)
	{
		AppError appError = Pool.Get<AppError>();
		DeserializeLengthDelimited(stream, appError, isDelta: false);
		return appError;
	}

	public static AppError DeserializeLength(BufferStream stream, int length)
	{
		AppError appError = Pool.Get<AppError>();
		DeserializeLength(stream, length, appError, isDelta: false);
		return appError;
	}

	public static AppError Deserialize(byte[] buffer)
	{
		AppError appError = Pool.Get<AppError>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appError, isDelta: false);
		return appError;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppError previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppError Deserialize(BufferStream stream, AppError instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.error = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppError DeserializeLengthDelimited(BufferStream stream, AppError instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.error = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppError DeserializeLength(BufferStream stream, int length, AppError instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.error = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppError instance, AppError previous)
	{
		if (instance.error != previous.error)
		{
			if (instance.error == null)
			{
				throw new ArgumentNullException("error", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.error);
		}
	}

	public static void Serialize(BufferStream stream, AppError instance)
	{
		if (instance.error == null)
		{
			throw new ArgumentNullException("error", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.error);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppFlag : IDisposable, IPooled, IProto<AppFlag>, IProto
{
	[NonSerialized]
	public bool value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppFlag instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = false;
			Pool.Free<AppFlag>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppFlag with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppFlag instance)
	{
		instance.value = value;
	}

	public AppFlag Copy()
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		CopyTo(appFlag);
		return appFlag;
	}

	public static AppFlag Deserialize(BufferStream stream)
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		Deserialize(stream, appFlag, isDelta: false);
		return appFlag;
	}

	public static AppFlag DeserializeLengthDelimited(BufferStream stream)
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		DeserializeLengthDelimited(stream, appFlag, isDelta: false);
		return appFlag;
	}

	public static AppFlag DeserializeLength(BufferStream stream, int length)
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		DeserializeLength(stream, length, appFlag, isDelta: false);
		return appFlag;
	}

	public static AppFlag Deserialize(byte[] buffer)
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appFlag, isDelta: false);
		return appFlag;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppFlag previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppFlag Deserialize(BufferStream stream, AppFlag instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppFlag DeserializeLengthDelimited(BufferStream stream, AppFlag instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppFlag DeserializeLength(BufferStream stream, int length, AppFlag instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppFlag instance, AppFlag previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.value);
	}

	public static void Serialize(BufferStream stream, AppFlag instance)
	{
		if (instance.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppInfo : IDisposable, IPooled, IProto<AppInfo>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public string headerImage;

	[NonSerialized]
	public string url;

	[NonSerialized]
	public string map;

	[NonSerialized]
	public uint mapSize;

	[NonSerialized]
	public uint wipeTime;

	[NonSerialized]
	public uint players;

	[NonSerialized]
	public uint maxPlayers;

	[NonSerialized]
	public uint queuedPlayers;

	[NonSerialized]
	public uint seed;

	[NonSerialized]
	public uint salt;

	[NonSerialized]
	public string logoImage;

	[NonSerialized]
	public string nexus;

	[NonSerialized]
	public int nexusId;

	[NonSerialized]
	public string nexusZone;

	[NonSerialized]
	public bool camerasEnabled;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.headerImage = string.Empty;
			instance.url = string.Empty;
			instance.map = string.Empty;
			instance.mapSize = 0u;
			instance.wipeTime = 0u;
			instance.players = 0u;
			instance.maxPlayers = 0u;
			instance.queuedPlayers = 0u;
			instance.seed = 0u;
			instance.salt = 0u;
			instance.logoImage = string.Empty;
			instance.nexus = string.Empty;
			instance.nexusId = 0;
			instance.nexusZone = string.Empty;
			instance.camerasEnabled = false;
			Pool.Free<AppInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppInfo instance)
	{
		instance.name = name;
		instance.headerImage = headerImage;
		instance.url = url;
		instance.map = map;
		instance.mapSize = mapSize;
		instance.wipeTime = wipeTime;
		instance.players = players;
		instance.maxPlayers = maxPlayers;
		instance.queuedPlayers = queuedPlayers;
		instance.seed = seed;
		instance.salt = salt;
		instance.logoImage = logoImage;
		instance.nexus = nexus;
		instance.nexusId = nexusId;
		instance.nexusZone = nexusZone;
		instance.camerasEnabled = camerasEnabled;
	}

	public AppInfo Copy()
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		CopyTo(appInfo);
		return appInfo;
	}

	public static AppInfo Deserialize(BufferStream stream)
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		Deserialize(stream, appInfo, isDelta: false);
		return appInfo;
	}

	public static AppInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		DeserializeLengthDelimited(stream, appInfo, isDelta: false);
		return appInfo;
	}

	public static AppInfo DeserializeLength(BufferStream stream, int length)
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		DeserializeLength(stream, length, appInfo, isDelta: false);
		return appInfo;
	}

	public static AppInfo Deserialize(byte[] buffer)
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appInfo, isDelta: false);
		return appInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppInfo Deserialize(BufferStream stream, AppInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.mapSize = 0u;
			instance.wipeTime = 0u;
			instance.players = 0u;
			instance.maxPlayers = 0u;
			instance.queuedPlayers = 0u;
			instance.seed = 0u;
			instance.salt = 0u;
			instance.nexusId = 0;
			instance.camerasEnabled = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.headerImage = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.url = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.map = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.mapSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.wipeTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.players = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.maxPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.queuedPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.salt = ProtocolParser.ReadUInt32(stream);
				continue;
			case 98:
				instance.logoImage = ProtocolParser.ReadString(stream);
				continue;
			case 106:
				instance.nexus = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.camerasEnabled = ProtocolParser.ReadBool(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static AppInfo DeserializeLengthDelimited(BufferStream stream, AppInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.mapSize = 0u;
			instance.wipeTime = 0u;
			instance.players = 0u;
			instance.maxPlayers = 0u;
			instance.queuedPlayers = 0u;
			instance.seed = 0u;
			instance.salt = 0u;
			instance.nexusId = 0;
			instance.camerasEnabled = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.headerImage = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.url = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.map = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.mapSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.wipeTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.players = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.maxPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.queuedPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.salt = ProtocolParser.ReadUInt32(stream);
				continue;
			case 98:
				instance.logoImage = ProtocolParser.ReadString(stream);
				continue;
			case 106:
				instance.nexus = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.camerasEnabled = ProtocolParser.ReadBool(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppInfo DeserializeLength(BufferStream stream, int length, AppInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.mapSize = 0u;
			instance.wipeTime = 0u;
			instance.players = 0u;
			instance.maxPlayers = 0u;
			instance.queuedPlayers = 0u;
			instance.seed = 0u;
			instance.salt = 0u;
			instance.nexusId = 0;
			instance.camerasEnabled = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.headerImage = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.url = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.map = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.mapSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.wipeTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.players = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.maxPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.queuedPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.salt = ProtocolParser.ReadUInt32(stream);
				continue;
			case 98:
				instance.logoImage = ProtocolParser.ReadString(stream);
				continue;
			case 106:
				instance.nexus = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.camerasEnabled = ProtocolParser.ReadBool(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppInfo instance, AppInfo previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.headerImage != previous.headerImage)
		{
			if (instance.headerImage == null)
			{
				throw new ArgumentNullException("headerImage", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.headerImage);
		}
		if (instance.url != previous.url)
		{
			if (instance.url == null)
			{
				throw new ArgumentNullException("url", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.url);
		}
		if (instance.map != previous.map)
		{
			if (instance.map == null)
			{
				throw new ArgumentNullException("map", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.map);
		}
		if (instance.mapSize != previous.mapSize)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.mapSize);
		}
		if (instance.wipeTime != previous.wipeTime)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.wipeTime);
		}
		if (instance.players != previous.players)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.players);
		}
		if (instance.maxPlayers != previous.maxPlayers)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.maxPlayers);
		}
		if (instance.queuedPlayers != previous.queuedPlayers)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.queuedPlayers);
		}
		if (instance.seed != previous.seed)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.salt != previous.salt)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt32(stream, instance.salt);
		}
		if (instance.logoImage != null && instance.logoImage != previous.logoImage)
		{
			stream.WriteByte(98);
			ProtocolParser.WriteString(stream, instance.logoImage);
		}
		if (instance.nexus != null && instance.nexus != previous.nexus)
		{
			stream.WriteByte(106);
			ProtocolParser.WriteString(stream, instance.nexus);
		}
		if (instance.nexusId != previous.nexusId)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nexusId);
		}
		if (instance.nexusZone != null && instance.nexusZone != previous.nexusZone)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		stream.WriteByte(128);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.camerasEnabled);
	}

	public static void Serialize(BufferStream stream, AppInfo instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.headerImage == null)
		{
			throw new ArgumentNullException("headerImage", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.headerImage);
		if (instance.url == null)
		{
			throw new ArgumentNullException("url", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.url);
		if (instance.map == null)
		{
			throw new ArgumentNullException("map", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteString(stream, instance.map);
		if (instance.mapSize != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.mapSize);
		}
		if (instance.wipeTime != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.wipeTime);
		}
		if (instance.players != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.players);
		}
		if (instance.maxPlayers != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.maxPlayers);
		}
		if (instance.queuedPlayers != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.queuedPlayers);
		}
		if (instance.seed != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.salt != 0)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt32(stream, instance.salt);
		}
		if (instance.logoImage != null)
		{
			stream.WriteByte(98);
			ProtocolParser.WriteString(stream, instance.logoImage);
		}
		if (instance.nexus != null)
		{
			stream.WriteByte(106);
			ProtocolParser.WriteString(stream, instance.nexus);
		}
		if (instance.nexusId != 0)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nexusId);
		}
		if (instance.nexusZone != null)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		if (instance.camerasEnabled)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.camerasEnabled);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTime : IDisposable, IPooled, IProto<AppTime>, IProto
{
	[NonSerialized]
	public float dayLengthMinutes;

	[NonSerialized]
	public float timeScale;

	[NonSerialized]
	public float sunrise;

	[NonSerialized]
	public float sunset;

	[NonSerialized]
	public float time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTime instance)
	{
		if (instance.ShouldPool)
		{
			instance.dayLengthMinutes = 0f;
			instance.timeScale = 0f;
			instance.sunrise = 0f;
			instance.sunset = 0f;
			instance.time = 0f;
			Pool.Free<AppTime>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTime with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTime instance)
	{
		instance.dayLengthMinutes = dayLengthMinutes;
		instance.timeScale = timeScale;
		instance.sunrise = sunrise;
		instance.sunset = sunset;
		instance.time = time;
	}

	public AppTime Copy()
	{
		AppTime appTime = Pool.Get<AppTime>();
		CopyTo(appTime);
		return appTime;
	}

	public static AppTime Deserialize(BufferStream stream)
	{
		AppTime appTime = Pool.Get<AppTime>();
		Deserialize(stream, appTime, isDelta: false);
		return appTime;
	}

	public static AppTime DeserializeLengthDelimited(BufferStream stream)
	{
		AppTime appTime = Pool.Get<AppTime>();
		DeserializeLengthDelimited(stream, appTime, isDelta: false);
		return appTime;
	}

	public static AppTime DeserializeLength(BufferStream stream, int length)
	{
		AppTime appTime = Pool.Get<AppTime>();
		DeserializeLength(stream, length, appTime, isDelta: false);
		return appTime;
	}

	public static AppTime Deserialize(byte[] buffer)
	{
		AppTime appTime = Pool.Get<AppTime>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTime, isDelta: false);
		return appTime;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTime previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTime Deserialize(BufferStream stream, AppTime instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.dayLengthMinutes = 0f;
			instance.timeScale = 0f;
			instance.sunrise = 0f;
			instance.sunset = 0f;
			instance.time = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.dayLengthMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.timeScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.sunrise = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunset = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppTime DeserializeLengthDelimited(BufferStream stream, AppTime instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.dayLengthMinutes = 0f;
			instance.timeScale = 0f;
			instance.sunrise = 0f;
			instance.sunset = 0f;
			instance.time = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.dayLengthMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.timeScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.sunrise = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunset = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTime DeserializeLength(BufferStream stream, int length, AppTime instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.dayLengthMinutes = 0f;
			instance.timeScale = 0f;
			instance.sunrise = 0f;
			instance.sunset = 0f;
			instance.time = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.dayLengthMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.timeScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.sunrise = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunset = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTime instance, AppTime previous)
	{
		if (instance.dayLengthMinutes != previous.dayLengthMinutes)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.dayLengthMinutes);
		}
		if (instance.timeScale != previous.timeScale)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeScale);
		}
		if (instance.sunrise != previous.sunrise)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.sunrise);
		}
		if (instance.sunset != previous.sunset)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.sunset);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public static void Serialize(BufferStream stream, AppTime instance)
	{
		if (instance.dayLengthMinutes != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.dayLengthMinutes);
		}
		if (instance.timeScale != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeScale);
		}
		if (instance.sunrise != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.sunrise);
		}
		if (instance.sunset != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.sunset);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppMap : IDisposable, IPooled, IProto<AppMap>, IProto
{
	public class Monument : IDisposable, IPooled, IProto<Monument>, IProto
	{
		[NonSerialized]
		public string token;

		[NonSerialized]
		public float x;

		[NonSerialized]
		public float y;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Monument instance)
		{
			if (instance.ShouldPool)
			{
				instance.token = string.Empty;
				instance.x = 0f;
				instance.y = 0f;
				Pool.Free<Monument>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Monument with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Monument instance)
		{
			instance.token = token;
			instance.x = x;
			instance.y = y;
		}

		public Monument Copy()
		{
			Monument monument = Pool.Get<Monument>();
			CopyTo(monument);
			return monument;
		}

		public static Monument Deserialize(BufferStream stream)
		{
			Monument monument = Pool.Get<Monument>();
			Deserialize(stream, monument, isDelta: false);
			return monument;
		}

		public static Monument DeserializeLengthDelimited(BufferStream stream)
		{
			Monument monument = Pool.Get<Monument>();
			DeserializeLengthDelimited(stream, monument, isDelta: false);
			return monument;
		}

		public static Monument DeserializeLength(BufferStream stream, int length)
		{
			Monument monument = Pool.Get<Monument>();
			DeserializeLength(stream, length, monument, isDelta: false);
			return monument;
		}

		public static Monument Deserialize(byte[] buffer)
		{
			Monument monument = Pool.Get<Monument>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, monument, isDelta: false);
			return monument;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Monument previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Monument Deserialize(BufferStream stream, Monument instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.x = 0f;
				instance.y = 0f;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.token = ProtocolParser.ReadString(stream);
					continue;
				case 21:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 29:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Monument DeserializeLengthDelimited(BufferStream stream, Monument instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.x = 0f;
				instance.y = 0f;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.token = ProtocolParser.ReadString(stream);
					continue;
				case 21:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 29:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Monument DeserializeLength(BufferStream stream, int length, Monument instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.x = 0f;
				instance.y = 0f;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.token = ProtocolParser.ReadString(stream);
					continue;
				case 21:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 29:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Monument instance, Monument previous)
		{
			if (instance.token != previous.token)
			{
				if (instance.token == null)
				{
					throw new ArgumentNullException("token", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.token);
			}
			if (instance.x != previous.x)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != previous.y)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
		}

		public static void Serialize(BufferStream stream, Monument instance)
		{
			if (instance.token == null)
			{
				throw new ArgumentNullException("token", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.token);
			if (instance.x != 0f)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public uint width;

	[NonSerialized]
	public uint height;

	[NonSerialized]
	public byte[] jpgImage;

	[NonSerialized]
	public int oceanMargin;

	[NonSerialized]
	public List<Monument> monuments;

	[NonSerialized]
	public string background;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppMap instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.width = 0u;
		instance.height = 0u;
		instance.jpgImage = null;
		instance.oceanMargin = 0;
		if (instance.monuments != null)
		{
			for (int i = 0; i < instance.monuments.Count; i++)
			{
				if (instance.monuments[i] != null)
				{
					instance.monuments[i].ResetToPool();
					instance.monuments[i] = null;
				}
			}
			List<Monument> list = instance.monuments;
			Pool.Free<Monument>(ref list, false);
			instance.monuments = list;
		}
		instance.background = string.Empty;
		Pool.Free<AppMap>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppMap with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppMap instance)
	{
		instance.width = width;
		instance.height = height;
		if (jpgImage == null)
		{
			instance.jpgImage = null;
		}
		else
		{
			instance.jpgImage = new byte[jpgImage.Length];
			Array.Copy(jpgImage, instance.jpgImage, instance.jpgImage.Length);
		}
		instance.oceanMargin = oceanMargin;
		if (monuments != null)
		{
			instance.monuments = Pool.Get<List<Monument>>();
			for (int i = 0; i < monuments.Count; i++)
			{
				Monument item = monuments[i].Copy();
				instance.monuments.Add(item);
			}
		}
		else
		{
			instance.monuments = null;
		}
		instance.background = background;
	}

	public AppMap Copy()
	{
		AppMap appMap = Pool.Get<AppMap>();
		CopyTo(appMap);
		return appMap;
	}

	public static AppMap Deserialize(BufferStream stream)
	{
		AppMap appMap = Pool.Get<AppMap>();
		Deserialize(stream, appMap, isDelta: false);
		return appMap;
	}

	public static AppMap DeserializeLengthDelimited(BufferStream stream)
	{
		AppMap appMap = Pool.Get<AppMap>();
		DeserializeLengthDelimited(stream, appMap, isDelta: false);
		return appMap;
	}

	public static AppMap DeserializeLength(BufferStream stream, int length)
	{
		AppMap appMap = Pool.Get<AppMap>();
		DeserializeLength(stream, length, appMap, isDelta: false);
		return appMap;
	}

	public static AppMap Deserialize(byte[] buffer)
	{
		AppMap appMap = Pool.Get<AppMap>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appMap, isDelta: false);
		return appMap;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppMap previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppMap Deserialize(BufferStream stream, AppMap instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0u;
			instance.height = 0u;
			instance.oceanMargin = 0;
			if (instance.monuments == null)
			{
				instance.monuments = Pool.Get<List<Monument>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.width = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.height = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				instance.jpgImage = ProtocolParser.ReadBytes(stream);
				continue;
			case 32:
				instance.oceanMargin = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.monuments.Add(Monument.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.background = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppMap DeserializeLengthDelimited(BufferStream stream, AppMap instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0u;
			instance.height = 0u;
			instance.oceanMargin = 0;
			if (instance.monuments == null)
			{
				instance.monuments = Pool.Get<List<Monument>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.width = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.height = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				instance.jpgImage = ProtocolParser.ReadBytes(stream);
				continue;
			case 32:
				instance.oceanMargin = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.monuments.Add(Monument.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.background = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppMap DeserializeLength(BufferStream stream, int length, AppMap instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0u;
			instance.height = 0u;
			instance.oceanMargin = 0;
			if (instance.monuments == null)
			{
				instance.monuments = Pool.Get<List<Monument>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.width = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.height = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				instance.jpgImage = ProtocolParser.ReadBytes(stream);
				continue;
			case 32:
				instance.oceanMargin = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.monuments.Add(Monument.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.background = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppMap instance, AppMap previous)
	{
		if (instance.width != previous.width)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.width);
		}
		if (instance.height != previous.height)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.height);
		}
		if (instance.jpgImage == null)
		{
			throw new ArgumentNullException("jpgImage", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteBytes(stream, instance.jpgImage);
		if (instance.oceanMargin != previous.oceanMargin)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oceanMargin);
		}
		if (instance.monuments != null)
		{
			for (int i = 0; i < instance.monuments.Count; i++)
			{
				Monument monument = instance.monuments[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Monument.SerializeDelta(stream, monument, monument);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.background != null && instance.background != previous.background)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.background);
		}
	}

	public static void Serialize(BufferStream stream, AppMap instance)
	{
		if (instance.width != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.width);
		}
		if (instance.height != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.height);
		}
		if (instance.jpgImage == null)
		{
			throw new ArgumentNullException("jpgImage", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteBytes(stream, instance.jpgImage);
		if (instance.oceanMargin != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oceanMargin);
		}
		if (instance.monuments != null)
		{
			for (int i = 0; i < instance.monuments.Count; i++)
			{
				Monument instance2 = instance.monuments[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Monument.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.background != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.background);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (monuments != null)
		{
			for (int i = 0; i < monuments.Count; i++)
			{
				monuments[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppEntityInfo : IDisposable, IPooled, IProto<AppEntityInfo>, IProto
{
	[NonSerialized]
	public AppEntityType type;

	[NonSerialized]
	public AppEntityPayload payload;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppEntityInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = (AppEntityType)0;
			if (instance.payload != null)
			{
				instance.payload.ResetToPool();
				instance.payload = null;
			}
			Pool.Free<AppEntityInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppEntityInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppEntityInfo instance)
	{
		instance.type = type;
		if (payload != null)
		{
			if (instance.payload == null)
			{
				instance.payload = payload.Copy();
			}
			else
			{
				payload.CopyTo(instance.payload);
			}
		}
		else
		{
			instance.payload = null;
		}
	}

	public AppEntityInfo Copy()
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		CopyTo(appEntityInfo);
		return appEntityInfo;
	}

	public static AppEntityInfo Deserialize(BufferStream stream)
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		Deserialize(stream, appEntityInfo, isDelta: false);
		return appEntityInfo;
	}

	public static AppEntityInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		DeserializeLengthDelimited(stream, appEntityInfo, isDelta: false);
		return appEntityInfo;
	}

	public static AppEntityInfo DeserializeLength(BufferStream stream, int length)
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		DeserializeLength(stream, length, appEntityInfo, isDelta: false);
		return appEntityInfo;
	}

	public static AppEntityInfo Deserialize(byte[] buffer)
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appEntityInfo, isDelta: false);
		return appEntityInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppEntityInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppEntityInfo Deserialize(BufferStream stream, AppEntityInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (AppEntityType)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static AppEntityInfo DeserializeLengthDelimited(BufferStream stream, AppEntityInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (AppEntityType)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppEntityInfo DeserializeLength(BufferStream stream, int length, AppEntityInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (AppEntityType)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppEntityInfo instance, AppEntityInfo previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.payload == null)
		{
			throw new ArgumentNullException("payload", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		AppEntityPayload.SerializeDelta(stream, instance.payload, previous.payload);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field payload (ProtoBuf.AppEntityPayload)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppEntityInfo instance)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.payload == null)
		{
			throw new ArgumentNullException("payload", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		AppEntityPayload.Serialize(stream, instance.payload);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field payload (ProtoBuf.AppEntityPayload)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		payload?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppEntityPayload : IDisposable, IPooled, IProto<AppEntityPayload>, IProto
{
	public class Item : IDisposable, IPooled, IProto<Item>, IProto
	{
		[NonSerialized]
		public int itemId;

		[NonSerialized]
		public int quantity;

		[NonSerialized]
		public bool itemIsBlueprint;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Item instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.itemIsBlueprint = false;
				Pool.Free<Item>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Item with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Item instance)
		{
			instance.itemId = itemId;
			instance.quantity = quantity;
			instance.itemIsBlueprint = itemIsBlueprint;
		}

		public Item Copy()
		{
			Item item = Pool.Get<Item>();
			CopyTo(item);
			return item;
		}

		public static Item Deserialize(BufferStream stream)
		{
			Item item = Pool.Get<Item>();
			Deserialize(stream, item, isDelta: false);
			return item;
		}

		public static Item DeserializeLengthDelimited(BufferStream stream)
		{
			Item item = Pool.Get<Item>();
			DeserializeLengthDelimited(stream, item, isDelta: false);
			return item;
		}

		public static Item DeserializeLength(BufferStream stream, int length)
		{
			Item item = Pool.Get<Item>();
			DeserializeLength(stream, length, item, isDelta: false);
			return item;
		}

		public static Item Deserialize(byte[] buffer)
		{
			Item item = Pool.Get<Item>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, item, isDelta: false);
			return item;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Item previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Item Deserialize(BufferStream stream, Item instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.itemIsBlueprint = false;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Item DeserializeLengthDelimited(BufferStream stream, Item instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.itemIsBlueprint = false;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Item DeserializeLength(BufferStream stream, int length, Item instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.itemIsBlueprint = false;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Item instance, Item previous)
		{
			if (instance.itemId != previous.itemId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.quantity != previous.quantity)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		}

		public static void Serialize(BufferStream stream, Item instance)
		{
			if (instance.itemId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.quantity != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
			}
			if (instance.itemIsBlueprint)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public bool value;

	[NonSerialized]
	public List<Item> items;

	[NonSerialized]
	public int capacity;

	[NonSerialized]
	public bool hasProtection;

	[NonSerialized]
	public uint protectionExpiry;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppEntityPayload instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.value = false;
		if (instance.items != null)
		{
			for (int i = 0; i < instance.items.Count; i++)
			{
				if (instance.items[i] != null)
				{
					instance.items[i].ResetToPool();
					instance.items[i] = null;
				}
			}
			List<Item> list = instance.items;
			Pool.Free<Item>(ref list, false);
			instance.items = list;
		}
		instance.capacity = 0;
		instance.hasProtection = false;
		instance.protectionExpiry = 0u;
		Pool.Free<AppEntityPayload>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppEntityPayload with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppEntityPayload instance)
	{
		instance.value = value;
		if (items != null)
		{
			instance.items = Pool.Get<List<Item>>();
			for (int i = 0; i < items.Count; i++)
			{
				Item item = items[i].Copy();
				instance.items.Add(item);
			}
		}
		else
		{
			instance.items = null;
		}
		instance.capacity = capacity;
		instance.hasProtection = hasProtection;
		instance.protectionExpiry = protectionExpiry;
	}

	public AppEntityPayload Copy()
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		CopyTo(appEntityPayload);
		return appEntityPayload;
	}

	public static AppEntityPayload Deserialize(BufferStream stream)
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		Deserialize(stream, appEntityPayload, isDelta: false);
		return appEntityPayload;
	}

	public static AppEntityPayload DeserializeLengthDelimited(BufferStream stream)
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		DeserializeLengthDelimited(stream, appEntityPayload, isDelta: false);
		return appEntityPayload;
	}

	public static AppEntityPayload DeserializeLength(BufferStream stream, int length)
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		DeserializeLength(stream, length, appEntityPayload, isDelta: false);
		return appEntityPayload;
	}

	public static AppEntityPayload Deserialize(byte[] buffer)
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appEntityPayload, isDelta: false);
		return appEntityPayload;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppEntityPayload previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppEntityPayload Deserialize(BufferStream stream, AppEntityPayload instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
			if (instance.items == null)
			{
				instance.items = Pool.Get<List<Item>>();
			}
			instance.capacity = 0;
			instance.protectionExpiry = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.items.Add(Item.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.capacity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.hasProtection = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.protectionExpiry = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppEntityPayload DeserializeLengthDelimited(BufferStream stream, AppEntityPayload instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
			if (instance.items == null)
			{
				instance.items = Pool.Get<List<Item>>();
			}
			instance.capacity = 0;
			instance.protectionExpiry = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.items.Add(Item.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.capacity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.hasProtection = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.protectionExpiry = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppEntityPayload DeserializeLength(BufferStream stream, int length, AppEntityPayload instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
			if (instance.items == null)
			{
				instance.items = Pool.Get<List<Item>>();
			}
			instance.capacity = 0;
			instance.protectionExpiry = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.items.Add(Item.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.capacity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.hasProtection = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.protectionExpiry = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppEntityPayload instance, AppEntityPayload previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.value);
		if (instance.items != null)
		{
			for (int i = 0; i < instance.items.Count; i++)
			{
				Item item = instance.items[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Item.SerializeDelta(stream, item, item);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field items (ProtoBuf.AppEntityPayload.Item)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.capacity != previous.capacity)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.capacity);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.hasProtection);
		if (instance.protectionExpiry != previous.protectionExpiry)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.protectionExpiry);
		}
	}

	public static void Serialize(BufferStream stream, AppEntityPayload instance)
	{
		if (instance.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.value);
		}
		if (instance.items != null)
		{
			for (int i = 0; i < instance.items.Count; i++)
			{
				Item instance2 = instance.items[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Item.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field items (ProtoBuf.AppEntityPayload.Item)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.capacity != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.capacity);
		}
		if (instance.hasProtection)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.hasProtection);
		}
		if (instance.protectionExpiry != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.protectionExpiry);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (items != null)
		{
			for (int i = 0; i < items.Count; i++)
			{
				items[i]?.InspectUids(action);
			}
		}
	}
}


