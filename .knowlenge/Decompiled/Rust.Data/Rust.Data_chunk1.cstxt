using System;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;

[CompilerGenerated]
[Embedded]
internal sealed class IsUnmanagedAttribute : Attribute
{
}


public enum UidType
{
	NetworkableId,
	ItemContainerId,
	ItemId,
	Clear
}


public delegate void UidInspector<T>(UidType type, ref T value);


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class InputMessage : IDisposable, IPooled, IProto<InputMessage>, IProto
{
	[NonSerialized]
	public int buttons;

	[NonSerialized]
	public Vector3 aimAngles;

	[NonSerialized]
	public Vector3 mouseDelta;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InputMessage instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.buttons = 0;
			instance.aimAngles = default(Vector3);
			instance.mouseDelta = default(Vector3);
			Pool.Free<InputMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InputMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InputMessage instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.buttons = buttons;
		instance.aimAngles = aimAngles;
		instance.mouseDelta = mouseDelta;
	}

	public InputMessage Copy()
	{
		InputMessage inputMessage = Pool.Get<InputMessage>();
		CopyTo(inputMessage);
		return inputMessage;
	}

	public static InputMessage Deserialize(BufferStream stream)
	{
		InputMessage inputMessage = Pool.Get<InputMessage>();
		Deserialize(stream, inputMessage, isDelta: false);
		return inputMessage;
	}

	public static InputMessage DeserializeLengthDelimited(BufferStream stream)
	{
		InputMessage inputMessage = Pool.Get<InputMessage>();
		DeserializeLengthDelimited(stream, inputMessage, isDelta: false);
		return inputMessage;
	}

	public static InputMessage DeserializeLength(BufferStream stream, int length)
	{
		InputMessage inputMessage = Pool.Get<InputMessage>();
		DeserializeLength(stream, length, inputMessage, isDelta: false);
		return inputMessage;
	}

	public static InputMessage Deserialize(byte[] buffer)
	{
		InputMessage inputMessage = Pool.Get<InputMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, inputMessage, isDelta: false);
		return inputMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InputMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InputMessage Deserialize(BufferStream stream, InputMessage instance, bool isDelta)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimAngles, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InputMessage DeserializeLengthDelimited(BufferStream stream, InputMessage instance, bool isDelta)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimAngles, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InputMessage DeserializeLength(BufferStream stream, int length, InputMessage instance, bool isDelta)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimAngles, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InputMessage instance, InputMessage previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (instance.buttons != previous.buttons)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.buttons);
		}
		if (instance.aimAngles != previous.aimAngles)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aimAngles, previous.aimAngles);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimAngles (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.mouseDelta != previous.mouseDelta)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.mouseDelta, previous.mouseDelta);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mouseDelta (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, InputMessage instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (instance.buttons != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.buttons);
		}
		if (instance.aimAngles != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aimAngles);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimAngles (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.mouseDelta != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.mouseDelta);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mouseDelta (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerTick : IDisposable, IPooled, IProto<PlayerTick>, IProto
{
	[NonSerialized]
	public InputMessage inputState;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public ModelState modelState;

	[NonSerialized]
	public ItemId activeItem;

	[NonSerialized]
	public Vector3 eyePos;

	[NonSerialized]
	public NetworkableId parentID;

	[NonSerialized]
	public uint deltaMs;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerTick instance)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			if (instance.inputState != null)
			{
				instance.inputState.ResetToPool();
				instance.inputState = null;
			}
			instance.position = default(Vector3);
			if (instance.modelState != null)
			{
				instance.modelState.ResetToPool();
				instance.modelState = null;
			}
			instance.activeItem = default(ItemId);
			instance.eyePos = default(Vector3);
			instance.parentID = default(NetworkableId);
			instance.deltaMs = 0u;
			Pool.Free<PlayerTick>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerTick with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerTick instance)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		if (inputState != null)
		{
			if (instance.inputState == null)
			{
				instance.inputState = inputState.Copy();
			}
			else
			{
				inputState.CopyTo(instance.inputState);
			}
		}
		else
		{
			instance.inputState = null;
		}
		instance.position = position;
		if (modelState != null)
		{
			if (instance.modelState == null)
			{
				instance.modelState = modelState.Copy();
			}
			else
			{
				modelState.CopyTo(instance.modelState);
			}
		}
		else
		{
			instance.modelState = null;
		}
		instance.activeItem = activeItem;
		instance.eyePos = eyePos;
		instance.parentID = parentID;
		instance.deltaMs = deltaMs;
	}

	public PlayerTick Copy()
	{
		PlayerTick playerTick = Pool.Get<PlayerTick>();
		CopyTo(playerTick);
		return playerTick;
	}

	public static PlayerTick Deserialize(BufferStream stream)
	{
		PlayerTick playerTick = Pool.Get<PlayerTick>();
		Deserialize(stream, playerTick, isDelta: false);
		return playerTick;
	}

	public static PlayerTick DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerTick playerTick = Pool.Get<PlayerTick>();
		DeserializeLengthDelimited(stream, playerTick, isDelta: false);
		return playerTick;
	}

	public static PlayerTick DeserializeLength(BufferStream stream, int length)
	{
		PlayerTick playerTick = Pool.Get<PlayerTick>();
		DeserializeLength(stream, length, playerTick, isDelta: false);
		return playerTick;
	}

	public static PlayerTick Deserialize(byte[] buffer)
	{
		PlayerTick playerTick = Pool.Get<PlayerTick>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerTick, isDelta: false);
		return playerTick;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerTick previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerTick Deserialize(BufferStream stream, PlayerTick instance, bool isDelta)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.inputState == null)
				{
					instance.inputState = InputMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					InputMessage.DeserializeLengthDelimited(stream, instance.inputState, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				break;
			case 34:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				break;
			case 40:
				instance.activeItem = new ItemId(ProtocolParser.ReadUInt64(stream));
				break;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.eyePos, isDelta);
				break;
			case 56:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 64:
				instance.deltaMs = ProtocolParser.ReadUInt32(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static PlayerTick DeserializeLengthDelimited(BufferStream stream, PlayerTick instance, bool isDelta)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.inputState == null)
				{
					instance.inputState = InputMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					InputMessage.DeserializeLengthDelimited(stream, instance.inputState, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				break;
			case 34:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				break;
			case 40:
				instance.activeItem = new ItemId(ProtocolParser.ReadUInt64(stream));
				break;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.eyePos, isDelta);
				break;
			case 56:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 64:
				instance.deltaMs = ProtocolParser.ReadUInt32(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerTick DeserializeLength(BufferStream stream, int length, PlayerTick instance, bool isDelta)
	{
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.inputState == null)
				{
					instance.inputState = InputMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					InputMessage.DeserializeLengthDelimited(stream, instance.inputState, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				break;
			case 34:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				break;
			case 40:
				instance.activeItem = new ItemId(ProtocolParser.ReadUInt64(stream));
				break;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.eyePos, isDelta);
				break;
			case 56:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 64:
				instance.deltaMs = ProtocolParser.ReadUInt32(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerTick instance, PlayerTick previous)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		if (instance.inputState == null)
		{
			throw new ArgumentNullException("inputState", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int num = stream.Position;
		InputMessage.SerializeDelta(stream, instance.inputState, previous.inputState);
		int num2 = stream.Position - num;
		if (num2 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inputState (global::InputMessage)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num2, span, 0);
		if (instance.position != previous.position)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.modelState == null)
		{
			throw new ArgumentNullException("modelState", "Required by proto specification.");
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range3 = stream.GetRange(2);
		int num5 = stream.Position;
		ModelState.SerializeDelta(stream, instance.modelState, previous.modelState);
		int num6 = stream.Position - num5;
		if (num6 > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modelState (global::ModelState)");
		}
		Span<byte> span3 = range3.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num6, span3, 0) < 2)
		{
			span3[0] |= 128;
			span3[1] = 0;
		}
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.activeItem.Value);
		if (instance.eyePos != previous.eyePos)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.eyePos, previous.eyePos);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field eyePos (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		if (instance.deltaMs != previous.deltaMs)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.deltaMs);
		}
	}

	public static void Serialize(BufferStream stream, PlayerTick instance)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		if (instance.inputState == null)
		{
			throw new ArgumentNullException("inputState", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int num = stream.Position;
		InputMessage.Serialize(stream, instance.inputState);
		int num2 = stream.Position - num;
		if (num2 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inputState (global::InputMessage)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num2, span, 0);
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.modelState == null)
		{
			throw new ArgumentNullException("modelState", "Required by proto specification.");
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range3 = stream.GetRange(2);
		int num5 = stream.Position;
		ModelState.Serialize(stream, instance.modelState);
		int num6 = stream.Position - num5;
		if (num6 > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modelState (global::ModelState)");
		}
		Span<byte> span3 = range3.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num6, span3, 0) < 2)
		{
			span3[0] |= 128;
			span3[1] = 0;
		}
		if (instance.activeItem != default(ItemId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.activeItem.Value);
		}
		if (instance.eyePos != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.eyePos);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field eyePos (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		if (instance.parentID != default(NetworkableId))
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		}
		if (instance.deltaMs != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.deltaMs);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		inputState?.InspectUids(action);
		modelState?.InspectUids(action);
		action(UidType.ItemId, ref activeItem.Value);
		action(UidType.NetworkableId, ref parentID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ModelState : IDisposable, IPooled, IProto<ModelState>, IProto
{
	public enum Flag
	{
		Ducked = 1,
		Jumped = 2,
		OnGround = 4,
		Sleeping = 8,
		Sprinting = 0x10,
		OnLadder = 0x20,
		Flying = 0x40,
		Aiming = 0x80,
		Prone = 0x100,
		Mounted = 0x200,
		Relaxed = 0x400,
		OnPhone = 0x800,
		Crawling = 0x1000,
		Loading = 0x2000,
		HeadLook = 0x4000,
		HasParachute = 0x8000,
		Blocking = 0x10000,
		Ragdolling = 0x20000,
		Catching = 0x40000
	}

	[NonSerialized]
	public float waterLevel;

	[NonSerialized]
	public Vector3 lookDir;

	[NonSerialized]
	public int flags;

	[NonSerialized]
	public int poseType;

	[NonSerialized]
	public Vector3 inheritedVelocity;

	[NonSerialized]
	public int ladderType;

	[NonSerialized]
	public Vector3 guidePosition;

	[NonSerialized]
	public Vector3 guideRotation;

	[NonSerialized]
	public uint guidePrefab;

	[NonSerialized]
	public bool guideValid;

	[NonSerialized]
	public int guideVersion;

	[NonSerialized]
	public float ducking;

	[NonSerialized]
	public Vector3 localShieldPos;

	[NonSerialized]
	public Vector3 localShieldRot;

	public bool ShouldPool = true;

	private bool _disposed;

	public bool ducked
	{
		get
		{
			return HasFlag(Flag.Ducked);
		}
		set
		{
			SetFlag(Flag.Ducked, value);
		}
	}

	public bool jumped
	{
		get
		{
			return HasFlag(Flag.Jumped);
		}
		set
		{
			SetFlag(Flag.Jumped, value);
		}
	}

	public bool onground
	{
		get
		{
			return HasFlag(Flag.OnGround);
		}
		set
		{
			SetFlag(Flag.OnGround, value);
		}
	}

	public bool sleeping
	{
		get
		{
			return HasFlag(Flag.Sleeping);
		}
		set
		{
			SetFlag(Flag.Sleeping, value);
		}
	}

	public bool sprinting
	{
		get
		{
			return HasFlag(Flag.Sprinting);
		}
		set
		{
			SetFlag(Flag.Sprinting, value);
		}
	}

	public bool onLadder
	{
		get
		{
			return HasFlag(Flag.OnLadder);
		}
		set
		{
			SetFlag(Flag.OnLadder, value);
		}
	}

	public bool flying
	{
		get
		{
			return HasFlag(Flag.Flying);
		}
		set
		{
			SetFlag(Flag.Flying, value);
		}
	}

	public bool aiming
	{
		get
		{
			return HasFlag(Flag.Aiming);
		}
		set
		{
			SetFlag(Flag.Aiming, value);
		}
	}

	public bool prone
	{
		get
		{
			return HasFlag(Flag.Prone);
		}
		set
		{
			SetFlag(Flag.Prone, value);
		}
	}

	public bool mounted
	{
		get
		{
			return HasFlag(Flag.Mounted);
		}
		set
		{
			SetFlag(Flag.Mounted, value);
		}
	}

	public bool relaxed
	{
		get
		{
			return HasFlag(Flag.Relaxed);
		}
		set
		{
			SetFlag(Flag.Relaxed, value);
		}
	}

	public bool onPhone
	{
		get
		{
			return HasFlag(Flag.OnPhone);
		}
		set
		{
			SetFlag(Flag.OnPhone, value);
		}
	}

	public bool crawling
	{
		get
		{
			return HasFlag(Flag.Crawling);
		}
		set
		{
			SetFlag(Flag.Crawling, value);
		}
	}

	public bool catching
	{
		get
		{
			return HasFlag(Flag.Catching);
		}
		set
		{
			SetFlag(Flag.Catching, value);
		}
	}

	public bool hasParachute
	{
		get
		{
			return HasFlag(Flag.HasParachute);
		}
		set
		{
			SetFlag(Flag.HasParachute, value);
		}
	}

	public bool ragdolling
	{
		get
		{
			return HasFlag(Flag.Ragdolling);
		}
		set
		{
			SetFlag(Flag.Ragdolling, value);
		}
	}

	public bool blocking
	{
		get
		{
			return HasFlag(Flag.Blocking);
		}
		set
		{
			SetFlag(Flag.Blocking, value);
		}
	}

	public bool headLook
	{
		get
		{
			return HasFlag(Flag.HeadLook);
		}
		set
		{
			SetFlag(Flag.HeadLook, value);
		}
	}

	public bool loading
	{
		get
		{
			return HasFlag(Flag.Loading);
		}
		set
		{
			SetFlag(Flag.Loading, value);
		}
	}

	public static void ResetToPool(ModelState instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.waterLevel = 0f;
			instance.lookDir = default(Vector3);
			instance.flags = 0;
			instance.poseType = 0;
			instance.inheritedVelocity = default(Vector3);
			instance.ladderType = 0;
			instance.guidePosition = default(Vector3);
			instance.guideRotation = default(Vector3);
			instance.guidePrefab = 0u;
			instance.guideValid = false;
			instance.guideVersion = 0;
			instance.ducking = 0f;
			instance.localShieldPos = default(Vector3);
			instance.localShieldRot = default(Vector3);
			Pool.Free<ModelState>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ModelState with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ModelState instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		instance.waterLevel = waterLevel;
		instance.lookDir = lookDir;
		instance.flags = flags;
		instance.poseType = poseType;
		instance.inheritedVelocity = inheritedVelocity;
		instance.ladderType = ladderType;
		instance.guidePosition = guidePosition;
		instance.guideRotation = guideRotation;
		instance.guidePrefab = guidePrefab;
		instance.guideValid = guideValid;
		instance.guideVersion = guideVersion;
		instance.ducking = ducking;
		instance.localShieldPos = localShieldPos;
		instance.localShieldRot = localShieldRot;
	}

	public ModelState Copy()
	{
		ModelState modelState = Pool.Get<ModelState>();
		CopyTo(modelState);
		return modelState;
	}

	public static ModelState Deserialize(BufferStream stream)
	{
		ModelState modelState = Pool.Get<ModelState>();
		Deserialize(stream, modelState, isDelta: false);
		return modelState;
	}

	public static ModelState DeserializeLengthDelimited(BufferStream stream)
	{
		ModelState modelState = Pool.Get<ModelState>();
		DeserializeLengthDelimited(stream, modelState, isDelta: false);
		return modelState;
	}

	public static ModelState DeserializeLength(BufferStream stream, int length)
	{
		ModelState modelState = Pool.Get<ModelState>();
		DeserializeLength(stream, length, modelState, isDelta: false);
		return modelState;
	}

	public static ModelState Deserialize(byte[] buffer)
	{
		ModelState modelState = Pool.Get<ModelState>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, modelState, isDelta: false);
		return modelState;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ModelState previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ModelState Deserialize(BufferStream stream, ModelState instance, bool isDelta)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 37:
				instance.waterLevel = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.lookDir, isDelta);
				continue;
			case 88:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.poseType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 106:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inheritedVelocity, isDelta);
				continue;
			case 112:
				instance.ladderType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.guidePosition, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.guideRotation, isDelta);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.guidePrefab = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.Varint)
				{
					instance.guideValid = ProtocolParser.ReadBool(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.guideVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.ducking = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localShieldPos, isDelta);
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localShieldRot, isDelta);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static ModelState DeserializeLengthDelimited(BufferStream stream, ModelState instance, bool isDelta)
	{
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 37:
				instance.waterLevel = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.lookDir, isDelta);
				continue;
			case 88:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.poseType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 106:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inheritedVelocity, isDelta);
				continue;
			case 112:
				instance.ladderType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.guidePosition, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.guideRotation, isDelta);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.guidePrefab = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.Varint)
				{
					instance.guideValid = ProtocolParser.ReadBool(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.guideVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.ducking = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localShieldPos, isDelta);
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localShieldRot, isDelta);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ModelState DeserializeLength(BufferStream stream, int length, ModelState instance, bool isDelta)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 37:
				instance.waterLevel = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.lookDir, isDelta);
				continue;
			case 88:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.poseType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 106:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inheritedVelocity, isDelta);
				continue;
			case 112:
				instance.ladderType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.guidePosition, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.guideRotation, isDelta);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.guidePrefab = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.Varint)
				{
					instance.guideValid = ProtocolParser.ReadBool(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.guideVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.ducking = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localShieldPos, isDelta);
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localShieldRot, isDelta);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ModelState instance, ModelState previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_034a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		if (instance.waterLevel != previous.waterLevel)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.waterLevel);
		}
		if (instance.lookDir != previous.lookDir)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.lookDir, previous.lookDir);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field lookDir (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.flags != previous.flags)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.poseType != previous.poseType)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.poseType);
		}
		if (instance.inheritedVelocity != previous.inheritedVelocity)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.inheritedVelocity, previous.inheritedVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inheritedVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.ladderType != previous.ladderType)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ladderType);
		}
		if (instance.guidePosition != previous.guidePosition)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.guidePosition, previous.guidePosition);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field guidePosition (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.guideRotation != previous.guideRotation)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.guideRotation, previous.guideRotation);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field guideRotation (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.guidePrefab != previous.guidePrefab)
		{
			stream.WriteByte(136);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.guidePrefab);
		}
		stream.WriteByte(144);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.guideValid);
		if (instance.guideVersion != previous.guideVersion)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.guideVersion);
		}
		if (instance.ducking != previous.ducking)
		{
			stream.WriteByte(165);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.ducking);
		}
		if (instance.localShieldPos != previous.localShieldPos)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.localShieldPos, previous.localShieldPos);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localShieldPos (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.localShieldRot != previous.localShieldRot)
		{
			stream.WriteByte(178);
			stream.WriteByte(1);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.localShieldRot, previous.localShieldRot);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localShieldRot (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
	}

	public static void Serialize(BufferStream stream, ModelState instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.waterLevel != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.waterLevel);
		}
		if (instance.lookDir != default(Vector3))
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.lookDir);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field lookDir (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.flags != 0)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.poseType != 0)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.poseType);
		}
		if (instance.inheritedVelocity != default(Vector3))
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.inheritedVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inheritedVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.ladderType != 0)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ladderType);
		}
		if (instance.guidePosition != default(Vector3))
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.guidePosition);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field guidePosition (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.guideRotation != default(Vector3))
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.guideRotation);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field guideRotation (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.guidePrefab != 0)
		{
			stream.WriteByte(136);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.guidePrefab);
		}
		if (instance.guideValid)
		{
			stream.WriteByte(144);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.guideValid);
		}
		if (instance.guideVersion != 0)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.guideVersion);
		}
		if (instance.ducking != 0f)
		{
			stream.WriteByte(165);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.ducking);
		}
		if (instance.localShieldPos != default(Vector3))
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.localShieldPos);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localShieldPos (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.localShieldRot != default(Vector3))
		{
			stream.WriteByte(178);
			stream.WriteByte(1);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.localShieldRot);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localShieldRot (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}

	public ModelState()
	{
		onground = true;
		waterLevel = 0f;
		flying = false;
		sprinting = false;
		ducked = false;
		onLadder = false;
		sleeping = false;
		mounted = false;
		relaxed = false;
		crawling = false;
		loading = false;
		ragdolling = false;
		poseType = 0;
		ducking = 0f;
	}

	public bool HasFlag(Flag f)
	{
		return ((uint)flags & (uint)f) == (uint)f;
	}

	public void SetFlag(Flag f, bool b)
	{
		if (b)
		{
			flags |= (int)f;
		}
		else
		{
			flags &= (int)(~f);
		}
	}

	public static bool Equal(ModelState a, ModelState b)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		if (a == b)
		{
			return true;
		}
		if (a == null || b == null)
		{
			return false;
		}
		if (a.flags != b.flags)
		{
			return false;
		}
		if (a.waterLevel != b.waterLevel)
		{
			return false;
		}
		if (a.lookDir != b.lookDir)
		{
			return false;
		}
		if (a.poseType != b.poseType)
		{
			return false;
		}
		if (a.guidePrefab != b.guidePrefab)
		{
			return false;
		}
		if (a.guidePosition != b.guidePosition)
		{
			return false;
		}
		if (a.guideRotation != b.guideRotation)
		{
			return false;
		}
		if (a.guideValid != b.guideValid)
		{
			return false;
		}
		if (a.ducking != b.ducking)
		{
			return false;
		}
		return true;
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class EffectData : IDisposable, IPooled, IProto<EffectData>, IProto
{
	[NonSerialized]
	public uint type;

	[NonSerialized]
	public uint pooledstringid;

	[NonSerialized]
	public int number;

	[NonSerialized]
	public Vector3 origin;

	[NonSerialized]
	public Vector3 normal;

	[NonSerialized]
	public float scale;

	[NonSerialized]
	public NetworkableId entity;

	[NonSerialized]
	public uint bone;

	[NonSerialized]
	public ulong source;

	[NonSerialized]
	public float distanceOverride;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EffectData instance)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.type = 0u;
			instance.pooledstringid = 0u;
			instance.number = 0;
			instance.origin = default(Vector3);
			instance.normal = default(Vector3);
			instance.scale = 0f;
			instance.entity = default(NetworkableId);
			instance.bone = 0u;
			instance.source = 0uL;
			instance.distanceOverride = 0f;
			Pool.Free<EffectData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EffectData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EffectData instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.type = type;
		instance.pooledstringid = pooledstringid;
		instance.number = number;
		instance.origin = origin;
		instance.normal = normal;
		instance.scale = scale;
		instance.entity = entity;
		instance.bone = bone;
		instance.source = source;
		instance.distanceOverride = distanceOverride;
	}

	public EffectData Copy()
	{
		EffectData effectData = Pool.Get<EffectData>();
		CopyTo(effectData);
		return effectData;
	}

	public static EffectData Deserialize(BufferStream stream)
	{
		EffectData effectData = Pool.Get<EffectData>();
		Deserialize(stream, effectData, isDelta: false);
		return effectData;
	}

	public static EffectData DeserializeLengthDelimited(BufferStream stream)
	{
		EffectData effectData = Pool.Get<EffectData>();
		DeserializeLengthDelimited(stream, effectData, isDelta: false);
		return effectData;
	}

	public static EffectData DeserializeLength(BufferStream stream, int length)
	{
		EffectData effectData = Pool.Get<EffectData>();
		DeserializeLength(stream, length, effectData, isDelta: false);
		return effectData;
	}

	public static EffectData Deserialize(byte[] buffer)
	{
		EffectData effectData = Pool.Get<EffectData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, effectData, isDelta: false);
		return effectData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EffectData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EffectData Deserialize(BufferStream stream, EffectData instance, bool isDelta)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.pooledstringid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.number = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 53:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.bone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.source = ProtocolParser.ReadUInt64(stream);
				continue;
			case 85:
				instance.distanceOverride = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EffectData DeserializeLengthDelimited(BufferStream stream, EffectData instance, bool isDelta)
	{
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.pooledstringid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.number = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 53:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.bone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.source = ProtocolParser.ReadUInt64(stream);
				continue;
			case 85:
				instance.distanceOverride = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EffectData DeserializeLength(BufferStream stream, int length, EffectData instance, bool isDelta)
	{
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.pooledstringid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.number = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 53:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.bone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.source = ProtocolParser.ReadUInt64(stream);
				continue;
			case 85:
				instance.distanceOverride = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EffectData instance, EffectData previous)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.type);
		}
		if (instance.pooledstringid != previous.pooledstringid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.pooledstringid);
		}
		if (instance.number != previous.number)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.number);
		}
		if (instance.origin != previous.origin)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.origin, previous.origin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != previous.normal)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.scale != previous.scale)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.scale);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, instance.entity.Value);
		if (instance.bone != previous.bone)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.bone);
		}
		if (instance.source != previous.source)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, instance.source);
		}
		if (instance.distanceOverride != previous.distanceOverride)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.distanceOverride);
		}
	}

	public static void Serialize(BufferStream stream, EffectData instance)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.type);
		}
		if (instance.pooledstringid != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.pooledstringid);
		}
		if (instance.number != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.number);
		}
		if (instance.origin != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.origin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.scale != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.scale);
		}
		if (instance.entity != default(NetworkableId))
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.entity.Value);
		}
		if (instance.bone != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.bone);
		}
		if (instance.source != 0L)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, instance.source);
		}
		if (instance.distanceOverride != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.distanceOverride);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public static class ProtoStreamExtensions
{
	public static void WriteToStream(this IProto proto, Stream stream, bool lengthDelimited = false, int maxSizeHint = 2097152)
	{
		if (proto == null)
		{
			throw new ArgumentNullException("proto");
		}
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
		using BufferStream bufferStream = Pool.Get<BufferStream>().Initialize();
		(int MaxLength, int LengthPrefixSize) lengthPrefixSize = GetLengthPrefixSize(maxSizeHint);
		int item = lengthPrefixSize.MaxLength;
		int item2 = lengthPrefixSize.LengthPrefixSize;
		BufferStream.RangeHandle rangeHandle = default(BufferStream.RangeHandle);
		if (lengthDelimited)
		{
			rangeHandle = bufferStream.GetRange(item2);
		}
		int position = bufferStream.Position;
		proto.WriteToStream(bufferStream);
		if (lengthDelimited)
		{
			int num = bufferStream.Position - position;
			if (num > item)
			{
				throw new InvalidOperationException($"Written proto exceeds maximum size hint (maxSizeHint={maxSizeHint}, actualLength={num})");
			}
			Span<byte> span = rangeHandle.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 != item2)
			{
				span[num2 - 1] |= 128;
				while (num2 < item2 - 1)
				{
					span[num2++] = 128;
				}
				span[num2] = 0;
			}
		}
		if (bufferStream.Length > 0)
		{
			ArraySegment<byte> buffer = bufferStream.GetBuffer();
			stream.Write(buffer.Array, buffer.Offset, buffer.Count);
		}
	}

	private static (int MaxLength, int LengthPrefixSize) GetLengthPrefixSize(int maxSizeHint)
	{
		if (maxSizeHint < 0)
		{
			throw new ArgumentOutOfRangeException("maxSizeHint");
		}
		if (maxSizeHint <= 127)
		{
			return (MaxLength: 127, LengthPrefixSize: 1);
		}
		if (maxSizeHint <= 16383)
		{
			return (MaxLength: 16383, LengthPrefixSize: 2);
		}
		if (maxSizeHint <= 2097151)
		{
			return (MaxLength: 2097151, LengthPrefixSize: 3);
		}
		if (maxSizeHint <= 268435455)
		{
			return (MaxLength: 16777215, LengthPrefixSize: 4);
		}
		throw new ArgumentOutOfRangeException("maxSizeHint");
	}

	public static void ReadFromStream(this IProto proto, Stream stream, bool isDelta = false, int maxSize = 1048576)
	{
		if (proto == null)
		{
			throw new ArgumentNullException("proto");
		}
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
		long position = stream.Position;
		byte[] array = BufferStream.Shared.ArrayPool.Rent(maxSize);
		int num = 0;
		int num2 = maxSize;
		while (num2 > 0)
		{
			int num3 = stream.Read(array, num, num2);
			if (num3 <= 0)
			{
				break;
			}
			num += num3;
			num2 -= num3;
		}
		using BufferStream bufferStream = Pool.Get<BufferStream>().Initialize(array, num);
		proto.ReadFromStream(bufferStream, isDelta);
		BufferStream.Shared.ArrayPool.Return(array);
		int position2 = bufferStream.Position;
		stream.Position = position + position2;
	}

	public static void ReadFromStream(this IProto proto, Stream stream, int length, bool isDelta = false)
	{
		if (proto == null)
		{
			throw new ArgumentNullException("proto");
		}
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
		if (length <= 0)
		{
			throw new ArgumentOutOfRangeException("length");
		}
		byte[] array = BufferStream.Shared.ArrayPool.Rent(length);
		int num = 0;
		int num2 = length;
		while (num2 > 0)
		{
			int num3 = stream.Read(array, num, num2);
			if (num3 <= 0)
			{
				throw new InvalidOperationException("Unexpected end of stream");
			}
			num += num3;
			num2 -= num3;
		}
		using BufferStream stream2 = Pool.Get<BufferStream>().Initialize(array, length);
		proto.ReadFromStream(stream2, isDelta);
		BufferStream.Shared.ArrayPool.Return(array);
	}

	public static void ReadFromStreamLengthDelimited(this IProto proto, Stream stream, bool isDelta = false)
	{
		if (proto == null)
		{
			throw new ArgumentNullException("proto");
		}
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
		int length = (int)ProtocolParser.ReadUInt32(stream);
		proto.ReadFromStream(stream, length, isDelta);
	}

	public static byte[] ToProtoBytes(this IProto proto)
	{
		if (proto == null)
		{
			throw new ArgumentNullException("proto");
		}
		using BufferStream bufferStream = Pool.Get<BufferStream>().Initialize();
		proto.WriteToStream(bufferStream);
		ArraySegment<byte> buffer = bufferStream.GetBuffer();
		byte[] array = new byte[bufferStream.Position];
		new Span<byte>(buffer.Array, buffer.Offset, buffer.Count).CopyTo(array);
		return array;
	}
}


using System;
using System.Runtime.CompilerServices;
using Facepunch;
using UnityEngine;

public sealed class BufferStream : IDisposable, IPooled
{
	public static class Shared
	{
		public static int StartingCapacity = 64;

		public static int MaximumCapacity = 536870912;

		public static int MaximumPooledSize = 67108864;

		public static readonly ArrayPool<byte> ArrayPool = new ArrayPool<byte>(MaximumPooledSize);
	}

	public readonly ref struct RangeHandle
	{
		private readonly BufferStream _stream;

		private readonly int _offset;

		private readonly int _length;

		public RangeHandle(BufferStream stream, int offset, int length)
		{
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			_stream = stream ?? throw new ArgumentNullException("stream");
			_offset = offset;
			_length = length;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Span<byte> GetSpan()
		{
			return new Span<byte>(_stream._buffer, _offset, _length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public ArraySegment<byte> GetSegment()
		{
			return new ArraySegment<byte>(_stream._buffer, _offset, _length);
		}
	}

	private bool _isBufferOwned;

	private byte[] _buffer;

	private int _length;

	private int _position;

	public int Length
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return _length;
		}
		set
		{
			if (value < 0)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			if (_position > value)
			{
				throw new InvalidOperationException("Cannot shrink buffer below current position!");
			}
			int num = value - _length;
			if (num > 0)
			{
				EnsureCapacity(num);
			}
			_length = value;
		}
	}

	public int Position
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return _position;
		}
		set
		{
			if (value < 0 || value > _length)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_position = value;
		}
	}

	public BufferStream Initialize()
	{
		_isBufferOwned = true;
		_buffer = null;
		_length = 0;
		_position = 0;
		return this;
	}

	public BufferStream Initialize(Span<byte> buffer)
	{
		_isBufferOwned = true;
		_buffer = null;
		_length = buffer.Length;
		_position = 0;
		EnsureCapacity(buffer.Length);
		buffer.CopyTo(_buffer);
		return this;
	}

	public BufferStream Initialize(byte[] buffer, int length = -1)
	{
		if (buffer == null)
		{
			throw new ArgumentNullException("buffer");
		}
		if (length > buffer.Length)
		{
			throw new ArgumentOutOfRangeException("length");
		}
		_isBufferOwned = false;
		_buffer = buffer;
		_length = ((length < 0) ? buffer.Length : length);
		_position = 0;
		return this;
	}

	public void Dispose()
	{
		if (_isBufferOwned && _buffer != null)
		{
			ReturnBuffer(_buffer);
		}
		_buffer = null;
		BufferStream bufferStream = this;
		Pool.Free<BufferStream>(ref bufferStream);
	}

	void IPooled.EnterPool()
	{
		if (_isBufferOwned && _buffer != null)
		{
			ReturnBuffer(_buffer);
		}
		_buffer = null;
	}

	void IPooled.LeavePool()
	{
	}

	public void Clear()
	{
		_length = 0;
		_position = 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int ReadByte()
	{
		if (_position >= _length)
		{
			return -1;
		}
		return _buffer[_position++];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void WriteByte(byte b)
	{
		EnsureCapacity(1);
		_buffer[_position++] = b;
		_length = Math.Max(_length, _position);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public T Read<T>() where T : unmanaged
	{
		int num = Unsafe.SizeOf<T>();
		if (_length - _position < num)
		{
			ThrowReadOutOfBounds();
		}
		ref T reference = ref Unsafe.As<byte, T>(ref _buffer[_position]);
		_position += num;
		return reference;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public T Peek<T>() where T : unmanaged
	{
		int num = Unsafe.SizeOf<T>();
		if (_length - _position < num)
		{
			ThrowReadOutOfBounds();
		}
		return Unsafe.As<byte, T>(ref _buffer[_position]);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void ThrowReadOutOfBounds()
	{
		throw new InvalidOperationException("Attempted to read past the end of the BufferStream");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Write<T>(T value) where T : unmanaged
	{
		int num = Unsafe.SizeOf<T>();
		EnsureCapacity(num);
		Unsafe.As<byte, T>(ref _buffer[_position]) = value;
		_position += num;
		_length = Math.Max(_length, _position);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public RangeHandle GetRange(int count)
	{
		EnsureCapacity(count);
		RangeHandle result = new RangeHandle(this, _position, count);
		_position += count;
		_length = Math.Max(_length, _position);
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Skip(int count)
	{
		_position += count;
	}

	public ArraySegment<byte> GetBuffer()
	{
		if (_length == 0)
		{
			return new ArraySegment<byte>(Array.Empty<byte>(), 0, 0);
		}
		return new ArraySegment<byte>(_buffer, 0, _length);
	}

	private void EnsureCapacity(int spaceRequired)
	{
		if (spaceRequired < 0)
		{
			throw new ArgumentOutOfRangeException("spaceRequired");
		}
		if (_buffer == null)
		{
			if (!_isBufferOwned)
			{
				throw new InvalidOperationException("Cannot allocate for BufferStream that doesn't own the buffer (did you forget to call Initialize?)");
			}
			int num = ((spaceRequired <= Shared.StartingCapacity) ? Shared.StartingCapacity : spaceRequired);
			int num2 = Mathf.NextPowerOfTwo(num);
			if (num2 > Shared.MaximumCapacity)
			{
				throw new Exception($"Preventing BufferStream buffer from growing too large (requiredLength={num})");
			}
			_buffer = RentBuffer(num2);
		}
		else if (_buffer.Length - _position < spaceRequired)
		{
			int num3 = _position + spaceRequired;
			int num4 = Mathf.NextPowerOfTwo(Math.Max(num3, _buffer.Length));
			if (!_isBufferOwned)
			{
				throw new InvalidOperationException($"Cannot grow buffer for BufferStream that doesn't own the buffer (requiredLength={num3})");
			}
			if (num4 > Shared.MaximumCapacity)
			{
				throw new Exception($"Preventing BufferStream buffer from growing too large (requiredLength={num3})");
			}
			byte[] array = RentBuffer(num4);
			Buffer.BlockCopy(_buffer, 0, array, 0, _length);
			ReturnBuffer(_buffer);
			_buffer = array;
		}
	}

	private static byte[] RentBuffer(int minSize)
	{
		if (minSize > Shared.MaximumPooledSize)
		{
			return new byte[minSize];
		}
		return Shared.ArrayPool.Rent(minSize);
	}

	private static void ReturnBuffer(byte[] buffer)
	{
		if (buffer != null && buffer.Length <= Shared.MaximumPooledSize)
		{
			Shared.ArrayPool.Return(buffer);
		}
	}
}


public interface IStreamReader
{
	byte UInt8();

	ushort UInt16();

	uint UInt32();

	ulong UInt64();

	sbyte Int8();

	short Int16();

	int Int32();

	long Int64();

	bool Bool();

	float Float();

	double Double();

	uint VarUInt32();

	string StringRaw(int maxLength, bool variableLength = false);

	byte[] BytesWithSize(uint maxLength, bool variableLength = false);
}


public interface IStreamWriter
{
	void UInt8(byte val);

	void UInt16(ushort val);

	void UInt32(uint val);

	void UInt64(ulong val);

	void Int8(sbyte val);

	void Int16(short val);

	void Int32(int val);

	void Int64(long val);

	void Bool(bool val);

	void Float(float val);

	void Double(double val);

	void Bytes(byte[] val);

	void BytesWithSize(byte[] val, bool variableLength = false);

	void String(string val, bool variableLength = false);
}


using System;

public struct ItemContainerId : IEquatable<ItemContainerId>
{
	public ulong Value;

	public static readonly ItemContainerId Invalid = new ItemContainerId(ulong.MaxValue);

	public bool IsValid => Value != 0;

	public ItemContainerId(ulong value)
	{
		Value = value;
	}

	public override string ToString()
	{
		return Value.ToString("G");
	}

	public bool Equals(ItemContainerId other)
	{
		return Value == other.Value;
	}

	public override bool Equals(object obj)
	{
		if (obj is ItemContainerId other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public static bool operator ==(ItemContainerId left, ItemContainerId right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(ItemContainerId left, ItemContainerId right)
	{
		return !left.Equals(right);
	}
}


using System;

public struct ItemId : IEquatable<ItemId>
{
	public ulong Value;

	public bool IsValid => Value != 0;

	public ItemId(ulong value)
	{
		Value = value;
	}

	public override string ToString()
	{
		return Value.ToString("G");
	}

	public bool Equals(ItemId other)
	{
		return Value == other.Value;
	}

	public override bool Equals(object obj)
	{
		if (obj is ItemId other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public static bool operator ==(ItemId left, ItemId right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(ItemId left, ItemId right)
	{
		return !left.Equals(right);
	}
}


using System;

[Flags]
public enum ItemMoveModifier
{
	None = 0,
	Alt = 2,
	Shift = 4,
	Ctrl = 8,
	BackpackOpen = 0x10
}


using System;

public struct NetworkableId : IEquatable<NetworkableId>
{
	public ulong Value;

	public bool IsValid => Value != 0;

	public NetworkableId(ulong value)
	{
		Value = value;
	}

	public override string ToString()
	{
		return Value.ToString("G");
	}

	public bool Equals(NetworkableId other)
	{
		return Value == other.Value;
	}

	public override bool Equals(object obj)
	{
		if (obj is NetworkableId other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public static bool operator ==(NetworkableId left, NetworkableId right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(NetworkableId left, NetworkableId right)
	{
		return !left.Equals(right);
	}
}


public class NetworkDefines
{
	public const int MinNetWriteBufferSize = 2048;

	public const int MaxNetWriteBufferSize = 4194304;

	public const int MaxNetReadPacketSize = 6291456;

	public const int MinNetReadBufferSize = 2048;

	public const int MaxNetReadBufferSize = 8388608;

	public const int MaxServerPacketSize = 10000000;
}


using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		MonoScriptData result = default(MonoScriptData);
		result.FilePathsData = new byte[628]
		{
			0, 0, 1, 170, 0, 0, 0, 54, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 68,
			97, 116, 97, 92, 103, 101, 110, 101, 114, 97,
			116, 101, 100, 92, 80, 114, 111, 116, 111, 99,
			111, 108, 66, 117, 102, 102, 101, 114, 115, 46,
			99, 115, 0, 0, 1, 176, 0, 0, 0, 65,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 82, 117, 115, 116,
			46, 68, 97, 116, 97, 92, 103, 101, 110, 101,
			114, 97, 116, 101, 100, 92, 80, 114, 111, 116,
			111, 99, 111, 108, 66, 117, 102, 102, 101, 114,
			115, 46, 83, 101, 114, 105, 97, 108, 105, 122,
			101, 114, 46, 99, 115, 0, 0, 0, 11, 0,
			0, 0, 53, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 82,
			117, 115, 116, 46, 68, 97, 116, 97, 92, 103,
			101, 110, 101, 114, 97, 116, 101, 100, 92, 80,
			114, 111, 116, 111, 99, 111, 108, 80, 97, 114,
			115, 101, 114, 46, 99, 115, 0, 0, 0, 1,
			0, 0, 0, 34, 92, 65, 115, 115, 101, 116,
			115, 92, 80, 108, 117, 103, 105, 110, 115, 92,
			82, 117, 115, 116, 46, 68, 97, 116, 97, 92,
			72, 97, 108, 102, 51, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 42, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 82, 117, 115, 116, 46, 68, 97, 116,
			97, 92, 73, 83, 116, 114, 101, 97, 109, 82,
			101, 97, 100, 101, 114, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 42, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 82, 117, 115, 116, 46, 68, 97, 116,
			97, 92, 73, 83, 116, 114, 101, 97, 109, 87,
			114, 105, 116, 101, 114, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 44, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 82, 117, 115, 116, 46, 68, 97, 116,
			97, 92, 73, 116, 101, 109, 67, 111, 110, 116,
			97, 105, 110, 101, 114, 73, 100, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 35, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 68,
			97, 116, 97, 92, 73, 116, 101, 109, 73, 100,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			39, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 82, 117, 115,
			116, 46, 68, 97, 116, 97, 92, 77, 111, 100,
			101, 108, 83, 116, 97, 116, 101, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 42, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 68,
			97, 116, 97, 92, 78, 101, 116, 119, 111, 114,
			107, 97, 98, 108, 101, 73, 100, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 43, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 68,
			97, 116, 97, 92, 78, 101, 116, 119, 111, 114,
			107, 68, 101, 102, 105, 110, 101, 115, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 39, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 82, 117, 115, 116, 46,
			68, 97, 116, 97, 92, 86, 101, 99, 116, 111,
			114, 68, 97, 116, 97, 46, 99, 115
		};
		result.TypesData = new byte[25661]
		{
			1, 0, 0, 0, 17, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 73, 68, 101, 115, 105,
			103, 110, 1, 0, 0, 0, 25, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 73, 83, 116,
			97, 116, 101, 67, 111, 110, 116, 97, 105, 110,
			101, 114, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 73, 69, 118,
			101, 110, 116, 68, 97, 116, 97, 1, 0, 0,
			0, 25, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 84, 105, 109, 101, 114, 65, 73, 69, 118,
			101, 110, 116, 68, 97, 116, 97, 1, 0, 0,
			0, 34, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 108, 97, 121, 101, 114, 68, 101, 116,
			101, 99, 116, 101, 100, 65, 73, 69, 118, 101,
			110, 116, 68, 97, 116, 97, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			72, 101, 97, 108, 116, 104, 66, 101, 108, 111,
			119, 65, 73, 69, 118, 101, 110, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 27, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 73, 110, 82, 97,
			110, 103, 101, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 31, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 72, 117,
			110, 103, 101, 114, 65, 98, 111, 118, 101, 65,
			73, 69, 118, 101, 110, 116, 68, 97, 116, 97,
			1, 0, 0, 0, 34, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 84, 105, 114, 101, 100, 110,
			101, 115, 115, 65, 98, 111, 118, 101, 65, 73,
			69, 118, 101, 110, 116, 68, 97, 116, 97, 1,
			0, 0, 0, 29, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 109, 109, 111, 66, 101, 108,
			111, 119, 65, 73, 69, 118, 101, 110, 116, 68,
			97, 116, 97, 1, 0, 0, 0, 34, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 84, 104, 114,
			101, 97, 116, 68, 101, 116, 101, 99, 116, 101,
			100, 65, 73, 69, 118, 101, 110, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 34, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 84, 97, 114, 103,
			101, 116, 68, 101, 116, 101, 99, 116, 101, 100,
			65, 73, 69, 118, 101, 110, 116, 68, 97, 116,
			97, 1, 0, 0, 0, 26, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 67, 104, 97, 110, 99,
			101, 65, 73, 69, 118, 101, 110, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 35, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 84, 105, 109, 101,
			83, 105, 110, 99, 101, 84, 104, 114, 101, 97,
			116, 65, 73, 69, 118, 101, 110, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 35, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 103, 103, 114,
			101, 115, 115, 105, 111, 110, 84, 105, 109, 101,
			114, 65, 73, 69, 118, 101, 110, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 19, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 101, 109, 111,
			114, 121, 66, 97, 110, 107, 1, 0, 0, 0,
			33, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			73, 110, 82, 97, 110, 103, 101, 79, 102, 72,
			111, 109, 101, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 82, 101, 113, 117, 101, 115, 116, 1, 0,
			0, 0, 19, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 77, 101, 115, 115, 97,
			103, 101, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 112, 112, 82,
			101, 115, 112, 111, 110, 115, 101, 1, 0, 0,
			0, 21, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 66, 114, 111, 97, 100, 99,
			97, 115, 116, 1, 0, 0, 0, 17, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			69, 109, 112, 116, 121, 1, 0, 0, 0, 23,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 83, 101, 110, 100, 77, 101, 115, 115,
			97, 103, 101, 1, 0, 0, 0, 26, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			83, 101, 116, 69, 110, 116, 105, 116, 121, 86,
			97, 108, 117, 101, 1, 0, 0, 0, 27, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 80, 114, 111, 109, 111, 116, 101, 84, 111,
			76, 101, 97, 100, 101, 114, 1, 0, 0, 0,
			24, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 112, 112, 71, 101, 116, 78, 101, 120, 117,
			115, 65, 117, 116, 104, 1, 0, 0, 0, 27,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 67, 97, 109, 101, 114, 97, 83, 117,
			98, 115, 99, 114, 105, 98, 101, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 67, 97, 109, 101, 114, 97,
			73, 110, 112, 117, 116, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 83, 117, 99, 99, 101, 115, 115, 1,
			0, 0, 0, 17, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 69, 114, 114, 111,
			114, 1, 0, 0, 0, 16, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 112, 112, 70, 108,
			97, 103, 1, 0, 0, 0, 16, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 112, 112, 73,
			110, 102, 111, 1, 0, 0, 0, 16, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			84, 105, 109, 101, 1, 0, 0, 0, 15, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 77, 97, 112, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 65, 112,
			112, 77, 97, 112, 124, 77, 111, 110, 117, 109,
			101, 110, 116, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			69, 110, 116, 105, 116, 121, 73, 110, 102, 111,
			1, 0, 0, 0, 25, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 69, 110, 116,
			105, 116, 121, 80, 97, 121, 108, 111, 97, 100,
			1, 0, 0, 0, 30, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 65, 112, 112, 69, 110, 116,
			105, 116, 121, 80, 97, 121, 108, 111, 97, 100,
			124, 73, 116, 101, 109, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 84, 101, 97, 109, 73, 110, 102, 111,
			1, 0, 0, 0, 27, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 65, 112, 112, 84, 101, 97,
			109, 73, 110, 102, 111, 124, 77, 101, 109, 98,
			101, 114, 1, 0, 0, 0, 25, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 65, 112, 112, 84,
			101, 97, 109, 73, 110, 102, 111, 124, 78, 111,
			116, 101, 1, 0, 0, 0, 23, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 112, 112, 84,
			101, 97, 109, 77, 101, 115, 115, 97, 103, 101,
			1, 0, 0, 0, 20, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 84, 101, 97,
			109, 67, 104, 97, 116, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 77, 97, 114, 107, 101, 114, 1, 0,
			0, 0, 28, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 65, 112, 112, 77, 97, 114, 107, 101,
			114, 124, 83, 101, 108, 108, 79, 114, 100, 101,
			114, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 112, 112, 77, 97,
			112, 77, 97, 114, 107, 101, 114, 115, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 67, 108, 97, 110, 73,
			110, 102, 111, 1, 0, 0, 0, 23, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			67, 108, 97, 110, 77, 101, 115, 115, 97, 103,
			101, 1, 0, 0, 0, 20, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 112, 112, 67, 108,
			97, 110, 67, 104, 97, 116, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 112, 112, 78, 101, 120, 117, 115, 65, 117,
			116, 104, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 112, 112, 67,
			97, 109, 101, 114, 97, 73, 110, 102, 111, 1,
			0, 0, 0, 23, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 84, 101, 97, 109,
			67, 104, 97, 110, 103, 101, 100, 1, 0, 0,
			0, 26, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 78, 101, 119, 84, 101, 97,
			109, 77, 101, 115, 115, 97, 103, 101, 1, 0,
			0, 0, 25, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 69, 110, 116, 105, 116,
			121, 67, 104, 97, 110, 103, 101, 100, 1, 0,
			0, 0, 23, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 67, 108, 97, 110, 67,
			104, 97, 110, 103, 101, 100, 1, 0, 0, 0,
			26, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 112, 112, 78, 101, 119, 67, 108, 97, 110,
			77, 101, 115, 115, 97, 103, 101, 1, 0, 0,
			0, 22, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 67, 97, 109, 101, 114, 97,
			82, 97, 121, 115, 1, 0, 0, 0, 29, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 65, 112,
			112, 67, 97, 109, 101, 114, 97, 82, 97, 121,
			115, 124, 69, 110, 116, 105, 116, 121, 1, 0,
			0, 0, 25, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 108, 97, 110, 65, 99, 116, 105,
			111, 110, 82, 101, 115, 117, 108, 116, 1, 0,
			0, 0, 17, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 108, 97, 110, 73, 110, 102, 111,
			1, 0, 0, 0, 22, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 67, 108, 97, 110, 73, 110,
			102, 111, 124, 82, 111, 108, 101, 1, 0, 0,
			0, 24, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 67, 108, 97, 110, 73, 110, 102, 111, 124,
			77, 101, 109, 98, 101, 114, 1, 0, 0, 0,
			24, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			67, 108, 97, 110, 73, 110, 102, 111, 124, 73,
			110, 118, 105, 116, 101, 1, 0, 0, 0, 16,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			108, 97, 110, 76, 111, 103, 1, 0, 0, 0,
			22, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			67, 108, 97, 110, 76, 111, 103, 124, 69, 110,
			116, 114, 121, 1, 0, 0, 0, 24, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 67, 108, 97,
			110, 83, 99, 111, 114, 101, 69, 118, 101, 110,
			116, 115, 1, 0, 0, 0, 30, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 67, 108, 97, 110,
			83, 99, 111, 114, 101, 69, 118, 101, 110, 116,
			115, 124, 69, 110, 116, 114, 121, 1, 0, 0,
			0, 24, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 67, 108, 97, 110, 73, 110, 118, 105, 116,
			97, 116, 105, 111, 110, 115, 1, 0, 0, 0,
			35, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			67, 108, 97, 110, 73, 110, 118, 105, 116, 97,
			116, 105, 111, 110, 115, 124, 73, 110, 118, 105,
			116, 97, 116, 105, 111, 110, 1, 0, 0, 0,
			24, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 108, 97, 110, 76, 101, 97, 100, 101, 114,
			98, 111, 97, 114, 100, 1, 0, 0, 0, 30,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 67,
			108, 97, 110, 76, 101, 97, 100, 101, 114, 98,
			111, 97, 114, 100, 124, 69, 110, 116, 114, 121,
			1, 0, 0, 0, 14, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 72, 97, 108, 102, 51, 1,
			0, 0, 0, 15, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 69, 110, 116, 105, 116, 121, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 66, 117, 114, 105, 101, 100, 73,
			116, 101, 109, 115, 1, 0, 0, 0, 37, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 66, 117,
			114, 105, 101, 100, 73, 116, 101, 109, 115, 124,
			83, 116, 111, 114, 101, 100, 66, 117, 114, 105,
			101, 100, 73, 116, 101, 109, 1, 0, 0, 0,
			24, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			66, 97, 115, 101, 78, 101, 116, 119, 111, 114,
			107, 97, 98, 108, 101, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			97, 115, 101, 69, 110, 116, 105, 116, 121, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 66, 97, 115, 101, 67, 111, 109,
			98, 97, 116, 1, 0, 0, 0, 16, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 66, 97, 115,
			101, 78, 80, 67, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 69, 110,
			116, 105, 116, 121, 83, 108, 111, 116, 115, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 66, 97, 115, 101, 82, 101, 115,
			111, 117, 114, 99, 101, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 69,
			110, 118, 105, 114, 111, 110, 109, 101, 110, 116,
			1, 0, 0, 0, 15, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 111, 114, 112, 115, 101,
			1, 0, 0, 0, 23, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 76, 111, 111, 116, 97, 98,
			108, 101, 67, 111, 114, 112, 115, 101, 1, 0,
			0, 0, 31, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 76, 111, 111, 116, 97, 98, 108, 101,
			67, 111, 114, 112, 115, 101, 124, 80, 114, 105,
			118, 97, 116, 101, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 80, 97,
			114, 101, 110, 116, 73, 110, 102, 111, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 66, 117, 105, 108, 100, 105, 110, 103,
			66, 108, 111, 99, 107, 1, 0, 0, 0, 22,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 87,
			97, 108, 108, 112, 97, 112, 101, 114, 84, 111,
			111, 108, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 87, 111, 114, 108,
			100, 73, 116, 101, 109, 1, 0, 0, 0, 16,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 75,
			101, 121, 76, 111, 99, 107, 1, 0, 0, 0,
			17, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 111, 100, 101, 76, 111, 99, 107, 1, 0,
			0, 0, 25, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 111, 100, 101, 76, 111, 99, 107,
			124, 80, 114, 105, 118, 97, 116, 101, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 87, 104, 105, 116, 101, 108, 105, 115,
			116, 1, 0, 0, 0, 23, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 87, 101, 97, 112, 111,
			110, 82, 97, 99, 107, 73, 116, 101, 109, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 87, 101, 97, 112, 111, 110, 82,
			97, 99, 107, 1, 0, 0, 0, 26, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 70, 114, 97,
			110, 107, 101, 110, 115, 116, 101, 105, 110, 84,
			97, 98, 108, 101, 1, 0, 0, 0, 26, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 66, 117,
			105, 108, 100, 105, 110, 103, 80, 114, 105, 118,
			105, 108, 101, 103, 101, 1, 0, 0, 0, 31,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			117, 105, 108, 100, 105, 110, 103, 80, 114, 105,
			118, 105, 108, 101, 103, 101, 82, 101, 116, 114,
			111, 1, 0, 0, 0, 35, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 117, 105, 108, 100,
			105, 110, 103, 80, 114, 105, 118, 105, 108, 101,
			103, 101, 82, 101, 116, 114, 111, 84, 111, 111,
			108, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 83, 116, 111, 114, 97,
			103, 101, 66, 111, 120, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 72,
			101, 108, 100, 69, 110, 116, 105, 116, 121, 1,
			0, 0, 0, 13, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 76, 111, 111, 116, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 71, 101, 110, 101, 114, 105, 99, 83, 112,
			97, 119, 110, 101, 114, 1, 0, 0, 0, 34,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 71,
			101, 110, 101, 114, 105, 99, 83, 112, 97, 119,
			110, 101, 114, 124, 83, 112, 97, 119, 110, 101,
			100, 69, 110, 116, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 108,
			101, 101, 112, 105, 110, 103, 66, 97, 103, 1,
			0, 0, 0, 17, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 97, 103, 97, 122, 105, 110,
			101, 1, 0, 0, 0, 23, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 97, 115, 101, 80,
			114, 111, 106, 101, 99, 116, 105, 108, 101, 1,
			0, 0, 0, 13, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 83, 105, 103, 110, 1, 0, 0,
			0, 18, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 77, 97, 112, 69, 110, 116, 105, 116, 121,
			1, 0, 0, 0, 22, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 82, 101, 115, 101, 97, 114,
			99, 104, 84, 97, 98, 108, 101, 1, 0, 0,
			0, 21, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 68, 117, 100, 69, 120, 112, 108, 111, 115,
			105, 118, 101, 1, 0, 0, 0, 26, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 82, 101, 115,
			111, 117, 114, 99, 101, 69, 120, 116, 114, 97,
			99, 116, 111, 114, 1, 0, 0, 0, 21, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 77, 105,
			110, 105, 110, 103, 81, 117, 97, 114, 114, 121,
			1, 0, 0, 0, 23, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 71, 114, 111, 119, 97, 98,
			108, 101, 69, 110, 116, 105, 116, 121, 1, 0,
			0, 0, 17, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 76, 97, 110, 100, 109, 105, 110, 101,
			1, 0, 0, 0, 20, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 66, 97, 115, 101, 86, 101,
			104, 105, 99, 108, 101, 1, 0, 0, 0, 31,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 66,
			97, 115, 101, 86, 101, 104, 105, 99, 108, 101,
			124, 77, 111, 117, 110, 116, 80, 111, 105, 110,
			116, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 72, 101, 108, 105, 99,
			111, 112, 116, 101, 114, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 83,
			101, 114, 118, 101, 114, 71, 105, 98, 1, 0,
			0, 0, 19, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 117, 116, 111, 84, 117, 114, 114,
			101, 116, 1, 0, 0, 0, 21, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 112, 104, 101,
			114, 101, 69, 110, 116, 105, 116, 121, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 116, 97, 98, 105, 108, 105, 116,
			121, 69, 110, 116, 105, 116, 121, 1, 0, 0,
			0, 18, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 79, 119, 110, 101, 114, 73, 110, 102, 111,
			1, 0, 0, 0, 20, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 68, 101, 99, 97, 121, 69,
			110, 116, 105, 116, 121, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 83,
			112, 97, 119, 110, 97, 98, 108, 101, 1, 0,
			0, 0, 21, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 112, 105, 110, 110, 101, 114, 87,
			104, 101, 101, 108, 1, 0, 0, 0, 13, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 76, 105,
			102, 116, 1, 0, 0, 0, 23, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 86, 101, 110, 100,
			105, 110, 103, 77, 97, 99, 104, 105, 110, 101,
			1, 0, 0, 0, 33, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 86, 101, 110, 100, 105, 110,
			103, 77, 97, 99, 104, 105, 110, 101, 124, 83,
			101, 108, 108, 79, 114, 100, 101, 114, 1, 0,
			0, 0, 42, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 86, 101, 110, 100, 105, 110, 103, 77,
			97, 99, 104, 105, 110, 101, 124, 83, 101, 108,
			108, 79, 114, 100, 101, 114, 67, 111, 110, 116,
			97, 105, 110, 101, 114, 1, 0, 0, 0, 28,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 86,
			101, 110, 100, 105, 110, 103, 77, 97, 99, 104,
			105, 110, 101, 83, 116, 97, 116, 115, 1, 0,
			0, 0, 19, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 66, 114, 97, 100, 108, 101, 121, 65,
			80, 67, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 87, 97, 116, 101,
			114, 87, 101, 108, 108, 1, 0, 0, 0, 22,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 72,
			111, 116, 65, 105, 114, 66, 97, 108, 108, 111,
			111, 110, 1, 0, 0, 0, 16, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 65, 77, 83,
			105, 116, 101, 1, 0, 0, 0, 18, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 111, 116,
			111, 114, 98, 111, 97, 116, 1, 0, 0, 0,
			19, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			77, 105, 110, 105, 99, 111, 112, 116, 101, 114,
			1, 0, 0, 0, 23, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 77, 111, 100, 117, 108, 97,
			114, 86, 101, 104, 105, 99, 108, 101, 1, 0,
			0, 0, 19, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 77, 111, 100, 117, 108, 97, 114, 67,
			97, 114, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 105, 109, 112,
			108, 101, 85, 73, 68, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 83,
			105, 109, 112, 108, 101, 85, 73, 110, 116, 1,
			0, 0, 0, 18, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 83, 105, 109, 112, 108, 101, 73,
			110, 116, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 86, 101, 104, 105,
			99, 108, 101, 76, 105, 102, 116, 1, 0, 0,
			0, 22, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 69, 110, 103, 105, 110, 101, 83, 116, 111,
			114, 97, 103, 101, 1, 0, 0, 0, 17, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 73, 79,
			69, 110, 116, 105, 116, 121, 1, 0, 0, 0,
			30, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			73, 79, 69, 110, 116, 105, 116, 121, 124, 73,
			79, 67, 111, 110, 110, 101, 99, 116, 105, 111,
			110, 1, 0, 0, 0, 38, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 73, 79, 69, 110, 116,
			105, 116, 121, 43, 73, 79, 67, 111, 110, 110,
			101, 99, 116, 105, 111, 110, 124, 76, 105, 110,
			101, 86, 101, 99, 1, 0, 0, 0, 44, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 73, 79,
			69, 110, 116, 105, 116, 121, 43, 73, 79, 67,
			111, 110, 110, 101, 99, 116, 105, 111, 110, 124,
			76, 105, 110, 101, 80, 111, 105, 110, 116, 76,
			105, 115, 116, 1, 0, 0, 0, 20, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 80, 117, 122,
			122, 108, 101, 82, 101, 115, 101, 116, 1, 0,
			0, 0, 28, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 82, 101, 108, 97, 116, 105, 111, 110,
			115, 104, 105, 112, 77, 97, 110, 97, 103, 101,
			114, 1, 0, 0, 0, 51, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 82, 101, 108, 97, 116,
			105, 111, 110, 115, 104, 105, 112, 77, 97, 110,
			97, 103, 101, 114, 124, 80, 108, 97, 121, 101,
			114, 82, 101, 108, 97, 116, 105, 111, 110, 115,
			104, 105, 112, 73, 110, 102, 111, 1, 0, 0,
			0, 48, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 82, 101, 108, 97, 116, 105, 111, 110, 115,
			104, 105, 112, 77, 97, 110, 97, 103, 101, 114,
			124, 80, 108, 97, 121, 101, 114, 82, 101, 108,
			97, 116, 105, 111, 110, 115, 104, 105, 112, 115,
			1, 0, 0, 0, 16, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 69, 103, 103, 72, 117, 110,
			116, 1, 0, 0, 0, 26, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 69, 103, 103, 72, 117,
			110, 116, 124, 69, 103, 103, 72, 117, 110, 116,
			101, 114, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 114, 99, 97,
			100, 101, 77, 97, 99, 104, 105, 110, 101, 1,
			0, 0, 0, 33, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 65, 114, 99, 97, 100, 101, 77,
			97, 99, 104, 105, 110, 101, 124, 83, 99, 111,
			114, 101, 69, 110, 116, 114, 121, 1, 0, 0,
			0, 14, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 72, 111, 114, 115, 101, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			72, 111, 114, 115, 101, 77, 111, 100, 105, 102,
			105, 101, 114, 115, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 109,
			97, 114, 116, 65, 108, 97, 114, 109, 1, 0,
			0, 0, 28, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 73, 110, 115, 116, 114, 117, 109, 101,
			110, 116, 82, 101, 99, 111, 114, 100, 105, 110,
			103, 1, 0, 0, 0, 32, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 73, 110, 115, 116, 114,
			117, 109, 101, 110, 116, 82, 101, 99, 111, 114,
			100, 105, 110, 103, 78, 111, 116, 101, 1, 0,
			0, 0, 31, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 73, 110, 115, 116, 114, 117, 109, 101,
			110, 116, 77, 105, 100, 105, 66, 105, 110, 100,
			105, 110, 103, 115, 1, 0, 0, 0, 30, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 73, 110,
			115, 116, 114, 117, 109, 101, 110, 116, 77, 105,
			100, 105, 66, 105, 110, 100, 105, 110, 103, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 76, 105, 103, 104, 116, 83, 116,
			114, 105, 110, 103, 1, 0, 0, 0, 32, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 76, 105,
			103, 104, 116, 83, 116, 114, 105, 110, 103, 124,
			83, 116, 114, 105, 110, 103, 80, 111, 105, 110,
			116, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 76, 105, 103, 104, 116,
			68, 101, 112, 108, 111, 121, 101, 114, 1, 0,
			0, 0, 17, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 82, 67, 69, 110, 116, 105, 116, 121,
			1, 0, 0, 0, 24, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 111, 109, 112, 117, 116,
			101, 114, 83, 116, 97, 116, 105, 111, 110, 1,
			0, 0, 0, 18, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 111, 109, 112, 111, 115, 116,
			101, 114, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 86, 101, 104, 105,
			99, 108, 101, 86, 101, 110, 100, 111, 114, 1,
			0, 0, 0, 36, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 86, 101, 104, 105, 99, 108, 101,
			86, 101, 110, 100, 111, 114, 124, 80, 108, 97,
			121, 101, 114, 83, 116, 111, 114, 97, 103, 101,
			1, 0, 0, 0, 56, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 86, 101, 104, 105, 99, 108,
			101, 86, 101, 110, 100, 111, 114, 43, 80, 108,
			97, 121, 101, 114, 83, 116, 111, 114, 97, 103,
			101, 124, 80, 108, 97, 121, 101, 114, 83, 116,
			111, 114, 101, 100, 86, 101, 104, 105, 99, 108,
			101, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 83, 104, 111, 112, 75,
			101, 101, 112, 101, 114, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 87,
			97, 116, 101, 114, 80, 111, 111, 108, 1, 0,
			0, 0, 14, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 80, 104, 111, 116, 111, 1, 0, 0,
			0, 19, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 104, 111, 116, 111, 70, 114, 97, 109,
			101, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 86, 101, 104, 105, 99,
			108, 101, 77, 111, 100, 117, 108, 101, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 77, 105, 120, 105, 110, 103, 84, 97,
			98, 108, 101, 1, 0, 0, 0, 17, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 69, 108, 101,
			118, 97, 116, 111, 114, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 83,
			107, 117, 108, 108, 84, 114, 111, 112, 104, 121,
			1, 0, 0, 0, 17, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 97, 115, 115, 101, 116,
			116, 101, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 84, 101, 108, 101,
			112, 104, 111, 110, 101, 1, 0, 0, 0, 16,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			111, 111, 109, 66, 111, 120, 1, 0, 0, 0,
			17, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			78, 101, 111, 110, 83, 105, 103, 110, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 78, 101, 111, 110, 83, 105, 103, 110,
			124, 76, 105, 103, 104, 116, 115, 1, 0, 0,
			0, 20, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 84, 114, 97, 105, 110, 69, 110, 103, 105,
			110, 101, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 117, 98, 69,
			110, 116, 105, 116, 121, 76, 105, 115, 116, 1,
			0, 0, 0, 23, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 97, 114, 107, 101, 116, 84,
			101, 114, 109, 105, 110, 97, 108, 1, 0, 0,
			0, 36, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 77, 97, 114, 107, 101, 116, 84, 101, 114,
			109, 105, 110, 97, 108, 124, 80, 101, 110, 100,
			105, 110, 103, 79, 114, 100, 101, 114, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 68, 101, 108, 105, 118, 101, 114, 121,
			68, 114, 111, 110, 101, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 71,
			97, 109, 101, 77, 111, 100, 101, 1, 0, 0,
			0, 26, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 71, 97, 109, 101, 77, 111, 100, 101, 124,
			84, 101, 97, 109, 73, 110, 102, 111, 1, 0,
			0, 0, 29, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 71, 97, 109, 101, 77, 111, 100, 101,
			124, 83, 99, 111, 114, 101, 67, 111, 108, 117,
			109, 110, 1, 0, 0, 0, 29, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 71, 97, 109, 101,
			77, 111, 100, 101, 124, 80, 108, 97, 121, 101,
			114, 83, 99, 111, 114, 101, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			82, 101, 99, 108, 97, 105, 109, 77, 97, 110,
			97, 103, 101, 114, 1, 0, 0, 0, 35, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 82, 101,
			99, 108, 97, 105, 109, 77, 97, 110, 97, 103,
			101, 114, 124, 82, 101, 99, 108, 97, 105, 109,
			73, 110, 102, 111, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 82, 101,
			99, 108, 97, 105, 109, 84, 101, 114, 109, 105,
			110, 97, 108, 1, 0, 0, 0, 20, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 83, 108, 111,
			116, 77, 97, 99, 104, 105, 110, 101, 1, 0,
			0, 0, 17, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 97, 114, 100, 71, 97, 109, 101,
			1, 0, 0, 0, 28, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 67, 97, 114, 100, 71, 97,
			109, 101, 124, 67, 97, 114, 100, 80, 108, 97,
			121, 101, 114, 1, 0, 0, 0, 29, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 67, 97, 114,
			100, 71, 97, 109, 101, 124, 84, 101, 120, 97,
			115, 72, 111, 108, 100, 69, 109, 1, 0, 0,
			0, 30, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 67, 97, 114, 100, 71, 97, 109, 101, 124,
			82, 111, 117, 110, 100, 82, 101, 115, 117, 108,
			116, 115, 1, 0, 0, 0, 37, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 67, 97, 114, 100,
			71, 97, 109, 101, 43, 82, 111, 117, 110, 100,
			82, 101, 115, 117, 108, 116, 115, 124, 82, 101,
			115, 117, 108, 116, 1, 0, 0, 0, 27, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 67, 97,
			114, 100, 71, 97, 109, 101, 124, 66, 108, 97,
			99, 107, 106, 97, 99, 107, 1, 0, 0, 0,
			37, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			67, 97, 114, 100, 71, 97, 109, 101, 124, 66,
			108, 97, 99, 107, 106, 97, 99, 107, 67, 97,
			114, 100, 80, 108, 97, 121, 101, 114, 1, 0,
			0, 0, 26, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 97, 114, 100, 71, 97, 109, 101,
			124, 67, 97, 114, 100, 76, 105, 115, 116, 1,
			0, 0, 0, 14, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 114, 97, 110, 101, 1, 0,
			0, 0, 25, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 111, 110, 110, 101, 99, 116, 101,
			100, 83, 112, 101, 97, 107, 101, 114, 1, 0,
			0, 0, 23, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 111, 105, 99, 101, 109, 97, 105,
			108, 69, 110, 116, 114, 121, 1, 0, 0, 0,
			20, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 117, 100, 105, 111, 69, 110, 116, 105, 116,
			121, 1, 0, 0, 0, 24, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 77, 105, 99, 114, 111,
			112, 104, 111, 110, 101, 83, 116, 97, 110, 100,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 111, 109, 109, 97, 110,
			100, 66, 108, 111, 99, 107, 1, 0, 0, 0,
			18, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			83, 117, 98, 109, 97, 114, 105, 110, 101, 1,
			0, 0, 0, 26, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 83, 108, 101, 101, 112, 105, 110,
			103, 66, 97, 103, 67, 97, 109, 112, 101, 114,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 97, 109, 112, 101, 114,
			77, 111, 100, 117, 108, 101, 1, 0, 0, 0,
			22, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			80, 97, 105, 110, 116, 97, 98, 108, 101, 83,
			105, 103, 110, 1, 0, 0, 0, 13, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 76, 82,
			83, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 83, 110, 111, 119, 109,
			111, 98, 105, 108, 101, 1, 0, 0, 0, 24,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 80,
			97, 116, 116, 101, 114, 110, 70, 105, 114, 101,
			119, 111, 114, 107, 1, 0, 0, 0, 31, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 80, 97,
			116, 116, 101, 114, 110, 70, 105, 114, 101, 119,
			111, 114, 107, 124, 68, 101, 115, 105, 103, 110,
			1, 0, 0, 0, 29, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 80, 97, 116, 116, 101, 114,
			110, 70, 105, 114, 101, 119, 111, 114, 107, 124,
			83, 116, 97, 114, 1, 0, 0, 0, 36, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 80, 97,
			116, 116, 101, 114, 110, 70, 105, 114, 101, 119,
			111, 114, 107, 124, 83, 97, 118, 101, 100, 68,
			101, 115, 105, 103, 110, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			97, 114, 103, 111, 80, 108, 97, 110, 101, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 97, 105, 110, 116, 101, 100,
			73, 116, 101, 109, 1, 0, 0, 0, 14, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 112,
			114, 97, 121, 1, 0, 0, 0, 18, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 83, 112, 114,
			97, 121, 76, 105, 110, 101, 1, 0, 0, 0,
			18, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			83, 112, 114, 97, 121, 76, 105, 115, 116, 1,
			0, 0, 0, 18, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 76, 105, 110, 101, 80, 111, 105,
			110, 116, 1, 0, 0, 0, 16, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 90, 105, 112, 108,
			105, 110, 101, 1, 0, 0, 0, 25, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 90, 105, 112,
			108, 105, 110, 101, 77, 111, 117, 110, 116, 97,
			98, 108, 101, 1, 0, 0, 0, 28, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 90, 105, 112,
			108, 105, 110, 101, 65, 114, 114, 105, 118, 97,
			108, 80, 111, 105, 110, 116, 1, 0, 0, 0,
			18, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			66, 97, 115, 101, 84, 114, 97, 105, 110, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 111, 97, 108, 105, 110, 103,
			84, 111, 119, 101, 114, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			97, 115, 101, 79, 118, 101, 110, 1, 0, 0,
			0, 29, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 66, 97, 115, 101, 79, 118, 101, 110, 124,
			67, 111, 111, 107, 105, 110, 103, 73, 116, 101,
			109, 1, 0, 0, 0, 23, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 114, 97, 105, 110,
			67, 111, 109, 112, 111, 110, 101, 110, 116, 1,
			0, 0, 0, 26, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 114, 111, 99, 101, 100, 117,
			114, 97, 108, 68, 117, 110, 103, 101, 111, 110,
			1, 0, 0, 0, 27, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 73, 110, 100, 117, 115, 116,
			114, 105, 97, 108, 67, 111, 110, 118, 101, 121,
			111, 114, 1, 0, 0, 0, 38, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 73, 110, 100, 117,
			115, 116, 114, 105, 97, 108, 67, 111, 110, 118,
			101, 121, 111, 114, 124, 73, 116, 101, 109, 70,
			105, 108, 116, 101, 114, 1, 0, 0, 0, 42,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 73,
			110, 100, 117, 115, 116, 114, 105, 97, 108, 67,
			111, 110, 118, 101, 121, 111, 114, 124, 73, 116,
			101, 109, 70, 105, 108, 116, 101, 114, 76, 105,
			115, 116, 1, 0, 0, 0, 26, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 73, 110, 100, 117,
			115, 116, 114, 105, 97, 108, 67, 114, 97, 102,
			116, 101, 114, 1, 0, 0, 0, 35, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 73, 110, 100,
			117, 115, 116, 114, 105, 97, 108, 67, 111, 110,
			118, 101, 121, 111, 114, 84, 114, 97, 110, 115,
			102, 101, 114, 1, 0, 0, 0, 48, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 73, 110, 100,
			117, 115, 116, 114, 105, 97, 108, 67, 111, 110,
			118, 101, 121, 111, 114, 84, 114, 97, 110, 115,
			102, 101, 114, 124, 73, 116, 101, 109, 84, 114,
			97, 110, 115, 102, 101, 114, 1, 0, 0, 0,
			14, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			68, 114, 111, 110, 101, 1, 0, 0, 0, 23,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 84,
			105, 109, 101, 100, 69, 120, 112, 108, 111, 115,
			105, 118, 101, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 116, 116,
			97, 99, 107, 72, 101, 108, 105, 1, 0, 0,
			0, 25, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 116, 116, 97, 99, 107, 72, 101, 108,
			105, 84, 117, 114, 114, 101, 116, 1, 0, 0,
			0, 26, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 116, 116, 97, 99, 107, 72, 101, 108,
			105, 82, 111, 99, 107, 101, 116, 115, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 108, 97, 110, 77, 97, 110, 97,
			103, 101, 114, 1, 0, 0, 0, 24, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 115, 115,
			111, 99, 105, 97, 116, 101, 100, 70, 105, 108,
			101, 115, 1, 0, 0, 0, 39, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 65, 115, 115, 111,
			99, 105, 97, 116, 101, 100, 70, 105, 108, 101,
			115, 124, 65, 115, 115, 111, 99, 105, 97, 116,
			101, 100, 70, 105, 108, 101, 1, 0, 0, 0,
			19, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			78, 101, 120, 117, 115, 70, 101, 114, 114, 121,
			1, 0, 0, 0, 20, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 78, 101, 120, 117, 115, 73,
			115, 108, 97, 110, 100, 1, 0, 0, 0, 26,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 78,
			101, 120, 117, 115, 68, 111, 99, 107, 84, 101,
			114, 109, 105, 110, 97, 108, 1, 0, 0, 0,
			40, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			78, 101, 120, 117, 115, 68, 111, 99, 107, 84,
			101, 114, 109, 105, 110, 97, 108, 124, 83, 99,
			104, 101, 100, 117, 108, 101, 69, 110, 116, 114,
			121, 1, 0, 0, 0, 17, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 97, 115, 101, 66,
			111, 97, 116, 1, 0, 0, 0, 21, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 68, 105, 101,
			115, 101, 108, 69, 110, 103, 105, 110, 101, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 82, 111, 99, 107, 105, 110, 103,
			67, 104, 97, 105, 114, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 72,
			101, 97, 100, 68, 97, 116, 97, 1, 0, 0,
			0, 21, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 87, 97, 110, 116, 101, 100, 80, 111, 115,
			116, 101, 114, 1, 0, 0, 0, 21, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 87, 97, 121,
			112, 111, 105, 110, 116, 82, 97, 99, 101, 1,
			0, 0, 0, 16, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 82, 97, 103, 100, 111, 108, 108,
			1, 0, 0, 0, 22, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 76, 101, 103, 97, 99, 121,
			83, 104, 101, 108, 116, 101, 114, 1, 0, 0,
			0, 28, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 77, 101, 116, 97, 108, 68, 101, 116, 101,
			99, 116, 111, 114, 83, 111, 117, 114, 99, 101,
			1, 0, 0, 0, 23, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 84, 117, 116, 111, 114, 105,
			97, 108, 73, 115, 108, 97, 110, 100, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 105, 110, 101, 109, 97, 116, 105,
			99, 69, 110, 116, 105, 116, 121, 1, 0, 0,
			0, 20, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 72, 97, 114, 98, 111, 114, 67, 114, 97,
			110, 101, 1, 0, 0, 0, 31, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 72, 97, 114, 98,
			111, 114, 67, 114, 97, 110, 101, 124, 81, 117,
			101, 117, 101, 100, 77, 111, 118, 101, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 97, 114, 103, 111, 83, 104, 105,
			112, 1, 0, 0, 0, 27, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 67, 97, 114, 103, 111,
			83, 104, 105, 112, 67, 111, 110, 116, 97, 105,
			110, 101, 114, 1, 0, 0, 0, 25, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 105, 115,
			115, 105, 111, 110, 77, 97, 112, 77, 97, 114,
			107, 101, 114, 1, 0, 0, 0, 13, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 66, 105, 107,
			101, 1, 0, 0, 0, 25, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 84, 114, 97, 118, 101,
			108, 108, 105, 110, 103, 86, 101, 110, 100, 111,
			114, 1, 0, 0, 0, 30, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 86, 101, 110, 100, 105,
			110, 103, 68, 121, 110, 97, 109, 105, 99, 80,
			114, 105, 99, 105, 110, 103, 1, 0, 0, 0,
			18, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			83, 97, 108, 101, 115, 68, 97, 116, 97, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 84, 105, 110, 67, 97, 110, 65,
			108, 97, 114, 109, 1, 0, 0, 0, 21, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 68, 105,
			103, 105, 116, 97, 108, 67, 108, 111, 99, 107,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 69, 108, 101, 118, 97, 116,
			111, 114, 76, 105, 102, 116, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			68, 105, 118, 101, 114, 80, 114, 111, 112, 117,
			108, 115, 105, 111, 110, 86, 101, 104, 105, 99,
			108, 101, 1, 0, 0, 0, 26, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 78, 80, 67, 86,
			101, 110, 100, 105, 110, 103, 77, 97, 99, 104,
			105, 110, 101, 1, 0, 0, 0, 16, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 97, 105,
			108, 98, 111, 120, 1, 0, 0, 0, 21, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 71, 117,
			110, 87, 101, 97, 112, 111, 110, 77, 111, 100,
			1, 0, 0, 0, 22, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 66, 97, 115, 101, 83, 99,
			117, 108, 112, 116, 117, 114, 101, 1, 0, 0,
			0, 17, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 67, 97, 116, 97, 112, 117, 108, 116, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 83, 105, 101, 103, 101, 84, 111,
			119, 101, 114, 1, 0, 0, 0, 17, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 66, 97, 108,
			108, 105, 115, 116, 97, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			97, 108, 108, 105, 115, 116, 97, 71, 117, 110,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 66, 97, 116, 116, 101, 114,
			105, 110, 103, 82, 97, 109, 1, 0, 0, 0,
			25, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			84, 101, 109, 112, 111, 114, 97, 114, 121, 82,
			97, 103, 100, 111, 108, 108, 1, 0, 0, 0,
			28, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 111, 110, 115, 116, 114, 117, 99, 116, 97,
			98, 108, 101, 69, 110, 116, 105, 116, 121, 1,
			0, 0, 0, 22, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 104, 105, 99, 107, 101, 110,
			83, 116, 97, 116, 117, 115, 1, 0, 0, 0,
			20, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 104, 105, 99, 107, 101, 110, 67, 111, 111,
			112, 1, 0, 0, 0, 23, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 70, 97, 114, 109, 97,
			98, 108, 101, 65, 110, 105, 109, 97, 108, 1,
			0, 0, 0, 16, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 66, 101, 101, 104, 105, 118, 101,
			1, 0, 0, 0, 23, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 66, 101, 101, 77, 97, 115,
			116, 101, 114, 83, 119, 97, 114, 109, 1, 0,
			0, 0, 28, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 111, 110, 116, 97, 105, 110, 101,
			114, 67, 111, 114, 112, 115, 101, 68, 97, 116,
			97, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 86, 105, 110, 101, 77,
			111, 117, 110, 116, 97, 98, 108, 101, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 84, 114, 101, 101, 82, 101, 115, 112,
			97, 119, 110, 1, 0, 0, 0, 17, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 86, 105, 110,
			101, 84, 114, 101, 101, 1, 0, 0, 0, 24,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 86,
			105, 110, 101, 68, 101, 115, 116, 105, 110, 97,
			116, 105, 111, 110, 1, 0, 0, 0, 30, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 116,
			97, 116, 105, 99, 82, 101, 115, 112, 97, 119,
			110, 65, 114, 101, 97, 68, 97, 116, 97, 1,
			0, 0, 0, 18, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 97, 110, 110, 101, 113, 117,
			105, 110, 1, 0, 0, 0, 31, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 77, 97, 110, 110,
			101, 113, 117, 105, 110, 124, 67, 108, 111, 116,
			104, 105, 110, 103, 73, 116, 101, 109, 1, 0,
			0, 0, 21, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 80, 108, 97, 121, 101, 114, 78, 97,
			109, 101, 73, 68, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 68, 101,
			109, 111, 72, 101, 97, 100, 101, 114, 1, 0,
			0, 0, 29, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 70, 105, 108, 101, 83, 116, 111, 114,
			97, 103, 101, 67, 97, 99, 104, 101, 68, 97,
			116, 97, 1, 0, 0, 0, 17, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 68, 101, 109, 111,
			83, 104, 111, 116, 1, 0, 0, 0, 28, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 68, 101,
			109, 111, 83, 104, 111, 116, 86, 101, 99, 116,
			111, 114, 84, 114, 97, 99, 107, 1, 0, 0,
			0, 31, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 68, 101, 109, 111, 83, 104, 111, 116, 86,
			101, 99, 116, 111, 114, 75, 101, 121, 102, 114,
			97, 109, 101, 1, 0, 0, 0, 27, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 68, 101, 109,
			111, 83, 104, 111, 116, 70, 108, 111, 97, 116,
			84, 114, 97, 99, 107, 1, 0, 0, 0, 30,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 68,
			101, 109, 111, 83, 104, 111, 116, 70, 108, 111,
			97, 116, 75, 101, 121, 102, 114, 97, 109, 101,
			1, 0, 0, 0, 32, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 68, 101, 109, 111, 83, 104,
			111, 116, 81, 117, 97, 116, 101, 114, 110, 105,
			111, 110, 84, 114, 97, 99, 107, 1, 0, 0,
			0, 35, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 68, 101, 109, 111, 83, 104, 111, 116, 81,
			117, 97, 116, 101, 114, 110, 105, 111, 110, 75,
			101, 121, 102, 114, 97, 109, 101, 1, 0, 0,
			0, 28, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 68, 101, 109, 111, 83, 104, 111, 116, 80,
			97, 114, 101, 110, 116, 84, 114, 97, 99, 107,
			1, 0, 0, 0, 31, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 68, 101, 109, 111, 83, 104,
			111, 116, 80, 97, 114, 101, 110, 116, 75, 101,
			121, 102, 114, 97, 109, 101, 1, 0, 0, 0,
			28, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 111, 112, 121, 80, 97, 115, 116, 101, 69,
			110, 116, 105, 116, 121, 73, 110, 102, 111, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 97, 115, 116, 101, 82, 101,
			113, 117, 101, 115, 116, 1, 0, 0, 0, 22,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 73,
			116, 101, 109, 67, 111, 110, 116, 97, 105, 110,
			101, 114, 1, 0, 0, 0, 13, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 73, 116, 101, 109,
			1, 0, 0, 0, 26, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 73, 116, 101, 109, 124, 73,
			110, 115, 116, 97, 110, 99, 101, 68, 97, 116,
			97, 1, 0, 0, 0, 27, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 73, 116, 101, 109, 124,
			67, 111, 110, 100, 105, 116, 105, 111, 110, 68,
			97, 116, 97, 1, 0, 0, 0, 28, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 73, 116, 101,
			109, 79, 119, 110, 101, 114, 115, 104, 105, 112,
			65, 109, 111, 117, 110, 116, 1, 0, 0, 0,
			13, 124, 73, 110, 112, 117, 116, 77, 101, 115,
			115, 97, 103, 101, 1, 0, 0, 0, 17, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 114, 111, 118, 97, 108, 1, 0, 0, 0,
			28, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			85, 112, 100, 97, 116, 101, 73, 116, 101, 109,
			67, 111, 110, 116, 97, 105, 110, 101, 114, 1,
			0, 0, 0, 25, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 108, 97, 121, 101, 114, 85,
			112, 100, 97, 116, 101, 76, 111, 111, 116, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 85, 112, 100, 97, 116, 101, 73,
			116, 101, 109, 1, 0, 0, 0, 11, 124, 80,
			108, 97, 121, 101, 114, 84, 105, 99, 107, 1,
			0, 0, 0, 11, 124, 77, 111, 100, 101, 108,
			83, 116, 97, 116, 101, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 84,
			97, 107, 101, 68, 97, 109, 97, 103, 101, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 69, 110, 116, 105, 116, 121, 76,
			105, 115, 116, 1, 0, 0, 0, 23, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 67, 114, 101,
			97, 116, 101, 66, 117, 105, 108, 100, 105, 110,
			103, 1, 0, 0, 0, 15, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 116, 116, 97, 99,
			107, 1, 0, 0, 0, 21, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 108, 97, 121, 101,
			114, 65, 116, 116, 97, 99, 107, 1, 0, 0,
			0, 31, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 108, 97, 121, 101, 114, 80, 114, 111,
			106, 101, 99, 116, 105, 108, 101, 65, 116, 116,
			97, 99, 107, 1, 0, 0, 0, 33, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 80, 108, 97,
			121, 101, 114, 80, 114, 111, 106, 101, 99, 116,
			105, 108, 101, 82, 105, 99, 111, 99, 104, 101,
			116, 1, 0, 0, 0, 31, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 108, 97, 121, 101,
			114, 80, 114, 111, 106, 101, 99, 116, 105, 108,
			101, 85, 112, 100, 97, 116, 101, 1, 0, 0,
			0, 24, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 114, 111, 106, 101, 99, 116, 105, 108,
			101, 83, 104, 111, 111, 116, 1, 0, 0, 0,
			35, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			80, 114, 111, 106, 101, 99, 116, 105, 108, 101,
			83, 104, 111, 111, 116, 124, 80, 114, 111, 106,
			101, 99, 116, 105, 108, 101, 1, 0, 0, 0,
			11, 124, 69, 102, 102, 101, 99, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 111, 100, 117,
			108, 101, 77, 101, 115, 115, 97, 103, 101, 1,
			0, 0, 0, 27, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 82, 101, 115, 112, 97, 119, 110,
			73, 110, 102, 111, 114, 109, 97, 116, 105, 111,
			110, 1, 0, 0, 0, 40, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 82, 101, 115, 112, 97,
			119, 110, 73, 110, 102, 111, 114, 109, 97, 116,
			105, 111, 110, 124, 83, 112, 97, 119, 110, 79,
			112, 116, 105, 111, 110, 115, 1, 0, 0, 0,
			20, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 108, 105, 101, 110, 116, 82, 101, 97, 100,
			121, 1, 0, 0, 0, 31, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 67, 108, 105, 101, 110,
			116, 82, 101, 97, 100, 121, 124, 67, 108, 105,
			101, 110, 116, 73, 110, 102, 111, 1, 0, 0,
			0, 13, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 84, 114, 101, 101, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 84,
			114, 101, 101, 76, 105, 115, 116, 1, 0, 0,
			0, 21, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 87, 111, 114, 108, 100, 77, 101, 115, 115,
			97, 103, 101, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 114, 99,
			97, 100, 101, 71, 97, 109, 101, 1, 0, 0,
			0, 29, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 65, 114, 99, 97, 100, 101, 71, 97, 109,
			101, 124, 97, 114, 99, 97, 100, 101, 69, 110,
			116, 1, 0, 0, 0, 23, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 104, 111, 110, 101,
			68, 105, 114, 101, 99, 116, 111, 114, 121, 1,
			0, 0, 0, 38, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 80, 104, 111, 110, 101, 68, 105,
			114, 101, 99, 116, 111, 114, 121, 124, 68, 105,
			114, 101, 99, 116, 111, 114, 121, 69, 110, 116,
			114, 121, 1, 0, 0, 0, 21, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 69, 110, 116, 105,
			116, 121, 73, 100, 76, 105, 115, 116, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 82, 97, 100, 105, 111, 76, 105, 115,
			116, 1, 0, 0, 0, 23, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 73, 116, 101, 109, 65,
			109, 111, 117, 110, 116, 76, 105, 115, 116, 1,
			0, 0, 0, 29, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 87, 105, 114, 101, 82, 101, 99,
			111, 110, 110, 101, 99, 116, 77, 101, 115, 115,
			97, 103, 101, 1, 0, 0, 0, 27, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 87, 105, 114,
			101, 76, 105, 110, 101, 65, 110, 99, 104, 111,
			114, 73, 110, 102, 111, 1, 0, 0, 0, 30,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 87,
			105, 114, 101, 67, 111, 110, 110, 101, 99, 116,
			105, 111, 110, 77, 101, 115, 115, 97, 103, 101,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 79, 99, 101, 97, 110, 80,
			97, 116, 104, 115, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 86, 101,
			99, 116, 111, 114, 76, 105, 115, 116, 1, 0,
			0, 0, 28, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 68, 105, 103, 105, 116, 97, 108, 67,
			108, 111, 99, 107, 77, 101, 115, 115, 97, 103,
			101, 1, 0, 0, 0, 26, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 68, 105, 103, 105, 116,
			97, 108, 67, 108, 111, 99, 107, 65, 108, 97,
			114, 109, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 86, 68, 68, 114,
			97, 119, 69, 110, 116, 114, 121, 1, 0, 0,
			0, 50, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 86, 101, 110, 100, 105, 110, 103, 77, 97,
			99, 104, 105, 110, 101, 80, 117, 114, 99, 104,
			97, 115, 101, 72, 105, 115, 116, 111, 114, 121,
			69, 110, 116, 114, 121, 77, 101, 115, 115, 97,
			103, 101, 1, 0, 0, 0, 55, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 86, 101, 110, 100,
			105, 110, 103, 77, 97, 99, 104, 105, 110, 101,
			80, 117, 114, 99, 104, 97, 115, 101, 72, 105,
			115, 116, 111, 114, 121, 69, 110, 116, 114, 121,
			83, 109, 97, 108, 108, 77, 101, 115, 115, 97,
			103, 101, 1, 0, 0, 0, 45, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 86, 101, 110, 100,
			105, 110, 103, 77, 97, 99, 104, 105, 110, 101,
			80, 117, 114, 99, 104, 97, 115, 101, 72, 105,
			115, 116, 111, 114, 121, 77, 101, 115, 115, 97,
			103, 101, 1, 0, 0, 0, 36, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 86, 101, 110, 100,
			105, 110, 103, 77, 97, 99, 104, 105, 110, 101,
			76, 111, 110, 103, 84, 101, 114, 109, 83, 116,
			97, 116, 115, 1, 0, 0, 0, 32, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 67, 104, 105,
			99, 107, 101, 110, 67, 111, 111, 112, 83, 116,
			97, 116, 117, 115, 85, 112, 100, 97, 116, 101,
			1, 0, 0, 0, 29, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 70, 97, 114, 109, 97, 98,
			108, 101, 65, 110, 105, 109, 97, 108, 83, 116,
			97, 116, 117, 115, 1, 0, 0, 0, 23, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 78, 80,
			67, 83, 101, 110, 115, 101, 115, 83, 116, 97,
			116, 101, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 80, 97, 114, 116,
			121, 68, 97, 116, 97, 1, 0, 0, 0, 24,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 80,
			97, 114, 116, 121, 77, 101, 109, 98, 101, 114,
			68, 97, 116, 97, 1, 0, 0, 0, 21, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			120, 117, 115, 124, 80, 97, 99, 107, 101, 116,
			1, 0, 0, 0, 22, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 78, 101, 120, 117, 115, 124,
			82, 101, 113, 117, 101, 115, 116, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 78, 101, 120, 117, 115, 124, 82, 101, 115,
			112, 111, 110, 115, 101, 1, 0, 0, 0, 21,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 124, 83, 116, 97, 116, 117,
			115, 1, 0, 0, 0, 26, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 78, 101, 120, 117, 115,
			124, 80, 105, 110, 103, 82, 101, 113, 117, 101,
			115, 116, 1, 0, 0, 0, 27, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 78, 101, 120, 117,
			115, 124, 80, 105, 110, 103, 82, 101, 115, 112,
			111, 110, 115, 101, 1, 0, 0, 0, 30, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			120, 117, 115, 124, 84, 114, 97, 110, 115, 102,
			101, 114, 82, 101, 113, 117, 101, 115, 116, 1,
			0, 0, 0, 34, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 78, 101, 120, 117, 115, 124, 80,
			108, 97, 121, 101, 114, 83, 101, 99, 111, 110,
			100, 97, 114, 121, 68, 97, 116, 97, 1, 0,
			0, 0, 51, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 78, 101, 120, 117, 115, 46, 80, 108,
			97, 121, 101, 114, 83, 101, 99, 111, 110, 100,
			97, 114, 121, 68, 97, 116, 97, 124, 82, 101,
			108, 97, 116, 105, 111, 110, 115, 104, 105, 112,
			68, 97, 116, 97, 1, 0, 0, 0, 34, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			120, 117, 115, 124, 83, 112, 97, 119, 110, 79,
			112, 116, 105, 111, 110, 115, 82, 101, 113, 117,
			101, 115, 116, 1, 0, 0, 0, 35, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 78, 101, 120,
			117, 115, 124, 83, 112, 97, 119, 110, 79, 112,
			116, 105, 111, 110, 115, 82, 101, 115, 112, 111,
			110, 115, 101, 1, 0, 0, 0, 40, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 78, 101, 120,
			117, 115, 124, 83, 108, 101, 101, 112, 105, 110,
			103, 66, 97, 103, 82, 101, 115, 112, 97, 119,
			110, 82, 101, 113, 117, 101, 115, 116, 1, 0,
			0, 0, 40, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 78, 101, 120, 117, 115, 124, 83, 108,
			101, 101, 112, 105, 110, 103, 66, 97, 103, 68,
			101, 115, 116, 114, 111, 121, 82, 101, 113, 117,
			101, 115, 116, 1, 0, 0, 0, 33, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 78, 101, 120,
			117, 115, 124, 70, 101, 114, 114, 121, 83, 116,
			97, 116, 117, 115, 82, 101, 113, 117, 101, 115,
			116, 1, 0, 0, 0, 34, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 78, 101, 120, 117, 115,
			124, 70, 101, 114, 114, 121, 83, 116, 97, 116,
			117, 115, 82, 101, 115, 112, 111, 110, 115, 101,
			1, 0, 0, 0, 26, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 78, 101, 120, 117, 115, 124,
			70, 101, 114, 114, 121, 83, 116, 97, 116, 117,
			115, 1, 0, 0, 0, 33, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 78, 101, 120, 117, 115,
			124, 70, 101, 114, 114, 121, 82, 101, 116, 105,
			114, 101, 82, 101, 113, 117, 101, 115, 116, 1,
			0, 0, 0, 41, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 78, 101, 120, 117, 115, 124, 70,
			101, 114, 114, 121, 85, 112, 100, 97, 116, 101,
			83, 99, 104, 101, 100, 117, 108, 101, 82, 101,
			113, 117, 101, 115, 116, 1, 0, 0, 0, 35,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 124, 67, 108, 97, 110, 67,
			104, 97, 116, 66, 97, 116, 99, 104, 82, 101,
			113, 117, 101, 115, 116, 1, 0, 0, 0, 43,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 46, 67, 108, 97, 110, 67,
			104, 97, 116, 66, 97, 116, 99, 104, 82, 101,
			113, 117, 101, 115, 116, 124, 77, 101, 115, 115,
			97, 103, 101, 1, 0, 0, 0, 36, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 78, 101, 120,
			117, 115, 124, 80, 108, 97, 121, 101, 114, 77,
			97, 110, 105, 102, 101, 115, 116, 82, 101, 113,
			117, 101, 115, 116, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 66, 97,
			115, 101, 80, 108, 97, 121, 101, 114, 1, 0,
			0, 0, 19, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 80, 108, 97, 121, 101, 114, 84, 101,
			97, 109, 1, 0, 0, 0, 30, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 80, 108, 97, 121,
			101, 114, 84, 101, 97, 109, 124, 84, 101, 97,
			109, 77, 101, 109, 98, 101, 114, 1, 0, 0,
			0, 25, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 108, 97, 121, 101, 114, 77, 101, 116,
			97, 98, 111, 108, 105, 115, 109, 1, 0, 0,
			0, 24, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 108, 97, 121, 101, 114, 77, 111, 100,
			105, 102, 105, 101, 114, 115, 1, 0, 0, 0,
			17, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			77, 111, 100, 105, 102, 105, 101, 114, 1, 0,
			0, 0, 17, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 77, 105, 115, 115, 105, 111, 110, 115,
			1, 0, 0, 0, 24, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 79, 98, 106, 101, 99, 116,
			105, 118, 101, 83, 116, 97, 116, 117, 115, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 105, 115, 115, 105, 111, 110,
			80, 111, 105, 110, 116, 1, 0, 0, 0, 22,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 77,
			105, 115, 115, 105, 111, 110, 69, 110, 116, 105,
			116, 121, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 105, 115, 115,
			105, 111, 110, 82, 101, 119, 97, 114, 100, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 105, 115, 115, 105, 111, 110,
			73, 110, 115, 116, 97, 110, 99, 101, 1, 0,
			0, 0, 28, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 77, 105, 115, 115, 105, 111, 110, 73,
			110, 115, 116, 97, 110, 99, 101, 68, 97, 116,
			97, 1, 0, 0, 0, 24, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 108, 97, 121, 101,
			114, 73, 110, 118, 101, 110, 116, 111, 114, 121,
			1, 0, 0, 0, 25, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 80, 101, 114, 115, 105, 115,
			116, 97, 110, 116, 80, 108, 97, 121, 101, 114,
			1, 0, 0, 0, 24, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 80, 108, 97, 121, 101, 114,
			76, 105, 102, 101, 83, 116, 111, 114, 121, 1,
			0, 0, 0, 34, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 80, 108, 97, 121, 101, 114, 76,
			105, 102, 101, 83, 116, 111, 114, 121, 124, 68,
			101, 97, 116, 104, 73, 110, 102, 111, 1, 0,
			0, 0, 36, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 80, 108, 97, 121, 101, 114, 76, 105,
			102, 101, 83, 116, 111, 114, 121, 124, 87, 101,
			97, 112, 111, 110, 83, 116, 97, 116, 115, 1,
			0, 0, 0, 36, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 80, 108, 97, 121, 101, 114, 76,
			105, 102, 101, 83, 116, 111, 114, 121, 124, 71,
			101, 110, 101, 114, 105, 99, 83, 116, 97, 116,
			1, 0, 0, 0, 16, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 77, 97, 112, 78, 111, 116,
			101, 1, 0, 0, 0, 20, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 77, 97, 112, 78, 111,
			116, 101, 76, 105, 115, 116, 1, 0, 0, 0,
			20, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			73, 116, 101, 109, 67, 114, 97, 102, 116, 101,
			114, 1, 0, 0, 0, 25, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 73, 116, 101, 109, 67,
			114, 97, 102, 116, 101, 114, 124, 84, 97, 115,
			107, 1, 0, 0, 0, 25, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 83, 112, 101, 99, 116,
			97, 116, 101, 84, 101, 97, 109, 73, 110, 102,
			111, 1, 0, 0, 0, 21, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 83, 112, 101, 99, 116,
			97, 116, 101, 84, 101, 97, 109, 1, 0, 0,
			0, 20, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 108, 97, 121, 101, 114, 83, 116, 97,
			116, 101, 1, 0, 0, 0, 25, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 71, 108, 111, 98,
			97, 108, 69, 110, 116, 105, 116, 121, 68, 97,
			116, 97, 1, 0, 0, 0, 31, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 71, 108, 111, 98,
			97, 108, 69, 110, 116, 105, 116, 121, 67, 111,
			108, 108, 101, 99, 116, 105, 111, 110, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 87, 111, 114, 108, 100, 68, 97, 116,
			97, 1, 0, 0, 0, 16, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 77, 97, 112, 68, 97,
			116, 97, 1, 0, 0, 0, 19, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 80, 114, 101, 102,
			97, 98, 68, 97, 116, 97, 1, 0, 0, 0,
			17, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			80, 97, 116, 104, 68, 97, 116, 97, 1, 0,
			0, 0, 19, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 101, 99, 116, 111, 114, 68, 97,
			116, 97, 1, 0, 0, 0, 17, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 73, 68, 101,
			115, 105, 103, 110, 1, 0, 0, 0, 25, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 73,
			83, 116, 97, 116, 101, 67, 111, 110, 116, 97,
			105, 110, 101, 114, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 73,
			69, 118, 101, 110, 116, 68, 97, 116, 97, 1,
			0, 0, 0, 25, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 84, 105, 109, 101, 114, 65, 73,
			69, 118, 101, 110, 116, 68, 97, 116, 97, 1,
			0, 0, 0, 34, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 108, 97, 121, 101, 114, 68,
			101, 116, 101, 99, 116, 101, 100, 65, 73, 69,
			118, 101, 110, 116, 68, 97, 116, 97, 1, 0,
			0, 0, 31, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 72, 101, 97, 108, 116, 104, 66, 101,
			108, 111, 119, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 27, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 73, 110,
			82, 97, 110, 103, 101, 65, 73, 69, 118, 101,
			110, 116, 68, 97, 116, 97, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			72, 117, 110, 103, 101, 114, 65, 98, 111, 118,
			101, 65, 73, 69, 118, 101, 110, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 34, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 84, 105, 114, 101,
			100, 110, 101, 115, 115, 65, 98, 111, 118, 101,
			65, 73, 69, 118, 101, 110, 116, 68, 97, 116,
			97, 1, 0, 0, 0, 29, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 109, 109, 111, 66,
			101, 108, 111, 119, 65, 73, 69, 118, 101, 110,
			116, 68, 97, 116, 97, 1, 0, 0, 0, 34,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 84,
			104, 114, 101, 97, 116, 68, 101, 116, 101, 99,
			116, 101, 100, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 34, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 84, 97,
			114, 103, 101, 116, 68, 101, 116, 101, 99, 116,
			101, 100, 65, 73, 69, 118, 101, 110, 116, 68,
			97, 116, 97, 1, 0, 0, 0, 26, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 67, 104, 97,
			110, 99, 101, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 35, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 84, 105,
			109, 101, 83, 105, 110, 99, 101, 84, 104, 114,
			101, 97, 116, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 35, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 103,
			103, 114, 101, 115, 115, 105, 111, 110, 84, 105,
			109, 101, 114, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 77, 101,
			109, 111, 114, 121, 66, 97, 110, 107, 1, 0,
			0, 0, 33, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 73, 110, 82, 97, 110, 103, 101, 79,
			102, 72, 111, 109, 101, 65, 73, 69, 118, 101,
			110, 116, 68, 97, 116, 97, 1, 0, 0, 0,
			19, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 112, 112, 82, 101, 113, 117, 101, 115, 116,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 77, 101, 115,
			115, 97, 103, 101, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 82, 101, 115, 112, 111, 110, 115, 101, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 66, 114, 111, 97,
			100, 99, 97, 115, 116, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 69, 109, 112, 116, 121, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 83, 101, 110, 100, 77, 101,
			115, 115, 97, 103, 101, 1, 0, 0, 0, 26,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 83, 101, 116, 69, 110, 116, 105, 116,
			121, 86, 97, 108, 117, 101, 1, 0, 0, 0,
			27, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 112, 112, 80, 114, 111, 109, 111, 116, 101,
			84, 111, 76, 101, 97, 100, 101, 114, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 71, 101, 116, 78, 101,
			120, 117, 115, 65, 117, 116, 104, 1, 0, 0,
			0, 27, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 67, 97, 109, 101, 114, 97,
			83, 117, 98, 115, 99, 114, 105, 98, 101, 1,
			0, 0, 0, 23, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 67, 97, 109, 101,
			114, 97, 73, 110, 112, 117, 116, 1, 0, 0,
			0, 19, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 83, 117, 99, 99, 101, 115,
			115, 1, 0, 0, 0, 17, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 112, 112, 69, 114,
			114, 111, 114, 1, 0, 0, 0, 16, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			70, 108, 97, 103, 1, 0, 0, 0, 16, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 73, 110, 102, 111, 1, 0, 0, 0, 16,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 84, 105, 109, 101, 1, 0, 0, 0,
			15, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 112, 112, 77, 97, 112, 1, 0, 0, 0,
			24, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			65, 112, 112, 77, 97, 112, 124, 77, 111, 110,
			117, 109, 101, 110, 116, 1, 0, 0, 0, 22,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 69, 110, 116, 105, 116, 121, 73, 110,
			102, 111, 1, 0, 0, 0, 25, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 112, 112, 69,
			110, 116, 105, 116, 121, 80, 97, 121, 108, 111,
			97, 100, 1, 0, 0, 0, 30, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 65, 112, 112, 69,
			110, 116, 105, 116, 121, 80, 97, 121, 108, 111,
			97, 100, 124, 73, 116, 101, 109, 1, 0, 0,
			0, 20, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 84, 101, 97, 109, 73, 110,
			102, 111, 1, 0, 0, 0, 27, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 65, 112, 112, 84,
			101, 97, 109, 73, 110, 102, 111, 124, 77, 101,
			109, 98, 101, 114, 1, 0, 0, 0, 25, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 65, 112,
			112, 84, 101, 97, 109, 73, 110, 102, 111, 124,
			78, 111, 116, 101, 1, 0, 0, 0, 23, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 84, 101, 97, 109, 77, 101, 115, 115, 97,
			103, 101, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 112, 112, 84,
			101, 97, 109, 67, 104, 97, 116, 1, 0, 0,
			0, 18, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 77, 97, 114, 107, 101, 114,
			1, 0, 0, 0, 28, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 65, 112, 112, 77, 97, 114,
			107, 101, 114, 124, 83, 101, 108, 108, 79, 114,
			100, 101, 114, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			77, 97, 112, 77, 97, 114, 107, 101, 114, 115,
			1, 0, 0, 0, 20, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 67, 108, 97,
			110, 73, 110, 102, 111, 1, 0, 0, 0, 23,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 67, 108, 97, 110, 77, 101, 115, 115,
			97, 103, 101, 1, 0, 0, 0, 20, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			67, 108, 97, 110, 67, 104, 97, 116, 1, 0,
			0, 0, 21, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 78, 101, 120, 117, 115,
			65, 117, 116, 104, 1, 0, 0, 0, 22, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 67, 97, 109, 101, 114, 97, 73, 110, 102,
			111, 1, 0, 0, 0, 23, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 112, 112, 84, 101,
			97, 109, 67, 104, 97, 110, 103, 101, 100, 1,
			0, 0, 0, 26, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 78, 101, 119, 84,
			101, 97, 109, 77, 101, 115, 115, 97, 103, 101,
			1, 0, 0, 0, 25, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 69, 110, 116,
			105, 116, 121, 67, 104, 97, 110, 103, 101, 100,
			1, 0, 0, 0, 23, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 67, 108, 97,
			110, 67, 104, 97, 110, 103, 101, 100, 1, 0,
			0, 0, 26, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 78, 101, 119, 67, 108,
			97, 110, 77, 101, 115, 115, 97, 103, 101, 1,
			0, 0, 0, 22, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 67, 97, 109, 101,
			114, 97, 82, 97, 121, 115, 1, 0, 0, 0,
			29, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			65, 112, 112, 67, 97, 109, 101, 114, 97, 82,
			97, 121, 115, 124, 69, 110, 116, 105, 116, 121,
			1, 0, 0, 0, 25, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 108, 97, 110, 65, 99,
			116, 105, 111, 110, 82, 101, 115, 117, 108, 116,
			1, 0, 0, 0, 17, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 108, 97, 110, 73, 110,
			102, 111, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 67, 108, 97, 110,
			73, 110, 102, 111, 124, 82, 111, 108, 101, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 67, 108, 97, 110, 73, 110, 102,
			111, 124, 77, 101, 109, 98, 101, 114, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 108, 97, 110, 73, 110, 102, 111,
			124, 73, 110, 118, 105, 116, 101, 1, 0, 0,
			0, 16, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 67, 108, 97, 110, 76, 111, 103, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 108, 97, 110, 76, 111, 103, 124,
			69, 110, 116, 114, 121, 1, 0, 0, 0, 24,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			108, 97, 110, 83, 99, 111, 114, 101, 69, 118,
			101, 110, 116, 115, 1, 0, 0, 0, 30, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 67, 108,
			97, 110, 83, 99, 111, 114, 101, 69, 118, 101,
			110, 116, 115, 124, 69, 110, 116, 114, 121, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 108, 97, 110, 73, 110, 118,
			105, 116, 97, 116, 105, 111, 110, 115, 1, 0,
			0, 0, 35, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 108, 97, 110, 73, 110, 118, 105,
			116, 97, 116, 105, 111, 110, 115, 124, 73, 110,
			118, 105, 116, 97, 116, 105, 111, 110, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 108, 97, 110, 76, 101, 97, 100,
			101, 114, 98, 111, 97, 114, 100, 1, 0, 0,
			0, 30, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 67, 108, 97, 110, 76, 101, 97, 100, 101,
			114, 98, 111, 97, 114, 100, 124, 69, 110, 116,
			114, 121, 0, 0, 0, 0, 29, 85, 110, 105,
			116, 121, 69, 110, 103, 105, 110, 101, 124, 86,
			101, 99, 116, 111, 114, 51, 83, 101, 114, 105,
			97, 108, 105, 122, 101, 100, 1, 0, 0, 0,
			14, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			72, 97, 108, 102, 51, 0, 0, 0, 0, 25,
			85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
			101, 124, 82, 97, 121, 83, 101, 114, 105, 97,
			108, 105, 122, 101, 100, 0, 0, 0, 0, 29,
			85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
			101, 124, 86, 101, 99, 116, 111, 114, 52, 83,
			101, 114, 105, 97, 108, 105, 122, 101, 100, 0,
			0, 0, 0, 27, 85, 110, 105, 116, 121, 69,
			110, 103, 105, 110, 101, 124, 67, 111, 108, 111,
			114, 83, 101, 114, 105, 97, 108, 105, 122, 101,
			100, 0, 0, 0, 0, 29, 85, 110, 105, 116,
			121, 69, 110, 103, 105, 110, 101, 124, 86, 101,
			99, 116, 111, 114, 50, 83, 101, 114, 105, 97,
			108, 105, 122, 101, 100, 1, 0, 0, 0, 15,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 69,
			110, 116, 105, 116, 121, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			117, 114, 105, 101, 100, 73, 116, 101, 109, 115,
			1, 0, 0, 0, 37, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 66, 117, 114, 105, 101, 100,
			73, 116, 101, 109, 115, 124, 83, 116, 111, 114,
			101, 100, 66, 117, 114, 105, 101, 100, 73, 116,
			101, 109, 1, 0, 0, 0, 24, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 66, 97, 115, 101,
			78, 101, 116, 119, 111, 114, 107, 97, 98, 108,
			101, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 97, 115, 101, 69,
			110, 116, 105, 116, 121, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			97, 115, 101, 67, 111, 109, 98, 97, 116, 1,
			0, 0, 0, 16, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 66, 97, 115, 101, 78, 80, 67,
			1, 0, 0, 0, 20, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 69, 110, 116, 105, 116, 121,
			83, 108, 111, 116, 115, 1, 0, 0, 0, 21,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			97, 115, 101, 82, 101, 115, 111, 117, 114, 99,
			101, 1, 0, 0, 0, 20, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 69, 110, 118, 105, 114,
			111, 110, 109, 101, 110, 116, 1, 0, 0, 0,
			15, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 111, 114, 112, 115, 101, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			76, 111, 111, 116, 97, 98, 108, 101, 67, 111,
			114, 112, 115, 101, 1, 0, 0, 0, 31, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 76, 111,
			111, 116, 97, 98, 108, 101, 67, 111, 114, 112,
			115, 101, 124, 80, 114, 105, 118, 97, 116, 101,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 80, 97, 114, 101, 110, 116,
			73, 110, 102, 111, 1, 0, 0, 0, 22, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 66, 117,
			105, 108, 100, 105, 110, 103, 66, 108, 111, 99,
			107, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 87, 97, 108, 108, 112,
			97, 112, 101, 114, 84, 111, 111, 108, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 87, 111, 114, 108, 100, 73, 116, 101,
			109, 1, 0, 0, 0, 16, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 75, 101, 121, 76, 111,
			99, 107, 1, 0, 0, 0, 17, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 67, 111, 100, 101,
			76, 111, 99, 107, 1, 0, 0, 0, 25, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 67, 111,
			100, 101, 76, 111, 99, 107, 124, 80, 114, 105,
			118, 97, 116, 101, 1, 0, 0, 0, 18, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 87, 104,
			105, 116, 101, 108, 105, 115, 116, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 87, 101, 97, 112, 111, 110, 82, 97, 99,
			107, 73, 116, 101, 109, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 87,
			101, 97, 112, 111, 110, 82, 97, 99, 107, 1,
			0, 0, 0, 26, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 70, 114, 97, 110, 107, 101, 110,
			115, 116, 101, 105, 110, 84, 97, 98, 108, 101,
			1, 0, 0, 0, 26, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 66, 117, 105, 108, 100, 105,
			110, 103, 80, 114, 105, 118, 105, 108, 101, 103,
			101, 1, 0, 0, 0, 31, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 117, 105, 108, 100,
			105, 110, 103, 80, 114, 105, 118, 105, 108, 101,
			103, 101, 82, 101, 116, 114, 111, 1, 0, 0,
			0, 35, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 66, 117, 105, 108, 100, 105, 110, 103, 80,
			114, 105, 118, 105, 108, 101, 103, 101, 82, 101,
			116, 114, 111, 84, 111, 111, 108, 1, 0, 0,
			0, 19, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 83, 116, 111, 114, 97, 103, 101, 66, 111,
			120, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 72, 101, 108, 100, 69,
			110, 116, 105, 116, 121, 1, 0, 0, 0, 13,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 76,
			111, 111, 116, 1, 0, 0, 0, 23, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 71, 101, 110,
			101, 114, 105, 99, 83, 112, 97, 119, 110, 101,
			114, 1, 0, 0, 0, 34, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 71, 101, 110, 101, 114,
			105, 99, 83, 112, 97, 119, 110, 101, 114, 124,
			83, 112, 97, 119, 110, 101, 100, 69, 110, 116,
			1, 0, 0, 0, 20, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 83, 108, 101, 101, 112, 105,
			110, 103, 66, 97, 103, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 77,
			97, 103, 97, 122, 105, 110, 101, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 66, 97, 115, 101, 80, 114, 111, 106, 101,
			99, 116, 105, 108, 101, 1, 0, 0, 0, 13,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 83,
			105, 103, 110, 1, 0, 0, 0, 18, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 97, 112,
			69, 110, 116, 105, 116, 121, 1, 0, 0, 0,
			22, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			82, 101, 115, 101, 97, 114, 99, 104, 84, 97,
			98, 108, 101, 1, 0, 0, 0, 21, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 68, 117, 100,
			69, 120, 112, 108, 111, 115, 105, 118, 101, 1,
			0, 0, 0, 26, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 82, 101, 115, 111, 117, 114, 99,
			101, 69, 120, 116, 114, 97, 99, 116, 111, 114,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 77, 105, 110, 105, 110, 103,
			81, 117, 97, 114, 114, 121, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			71, 114, 111, 119, 97, 98, 108, 101, 69, 110,
			116, 105, 116, 121, 1, 0, 0, 0, 17, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 76, 97,
			110, 100, 109, 105, 110, 101, 1, 0, 0, 0,
			20, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			66, 97, 115, 101, 86, 101, 104, 105, 99, 108,
			101, 1, 0, 0, 0, 31, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 66, 97, 115, 101, 86,
			101, 104, 105, 99, 108, 101, 124, 77, 111, 117,
			110, 116, 80, 111, 105, 110, 116, 1, 0, 0,
			0, 19, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 72, 101, 108, 105, 99, 111, 112, 116, 101,
			114, 1, 0, 0, 0, 18, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 83, 101, 114, 118, 101,
			114, 71, 105, 98, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 117,
			116, 111, 84, 117, 114, 114, 101, 116, 1, 0,
			0, 0, 21, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 112, 104, 101, 114, 101, 69, 110,
			116, 105, 116, 121, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 116,
			97, 98, 105, 108, 105, 116, 121, 69, 110, 116,
			105, 116, 121, 1, 0, 0, 0, 18, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 79, 119, 110,
			101, 114, 73, 110, 102, 111, 1, 0, 0, 0,
			20, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			68, 101, 99, 97, 121, 69, 110, 116, 105, 116,
			121, 1, 0, 0, 0, 18, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 83, 112, 97, 119, 110,
			97, 98, 108, 101, 1, 0, 0, 0, 21, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 112,
			105, 110, 110, 101, 114, 87, 104, 101, 101, 108,
			1, 0, 0, 0, 13, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 76, 105, 102, 116, 1, 0,
			0, 0, 23, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 101, 110, 100, 105, 110, 103, 77,
			97, 99, 104, 105, 110, 101, 1, 0, 0, 0,
			33, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			86, 101, 110, 100, 105, 110, 103, 77, 97, 99,
			104, 105, 110, 101, 124, 83, 101, 108, 108, 79,
			114, 100, 101, 114, 1, 0, 0, 0, 42, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 86, 101,
			110, 100, 105, 110, 103, 77, 97, 99, 104, 105,
			110, 101, 124, 83, 101, 108, 108, 79, 114, 100,
			101, 114, 67, 111, 110, 116, 97, 105, 110, 101,
			114, 1, 0, 0, 0, 28, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 86, 101, 110, 100, 105,
			110, 103, 77, 97, 99, 104, 105, 110, 101, 83,
			116, 97, 116, 115, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 66, 114,
			97, 100, 108, 101, 121, 65, 80, 67, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 87, 97, 116, 101, 114, 87, 101, 108,
			108, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 72, 111, 116, 65, 105,
			114, 66, 97, 108, 108, 111, 111, 110, 1, 0,
			0, 0, 16, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 65, 77, 83, 105, 116, 101, 1,
			0, 0, 0, 18, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 111, 116, 111, 114, 98, 111,
			97, 116, 1, 0, 0, 0, 19, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 105, 110, 105,
			99, 111, 112, 116, 101, 114, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			77, 111, 100, 117, 108, 97, 114, 86, 101, 104,
			105, 99, 108, 101, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 77, 111,
			100, 117, 108, 97, 114, 67, 97, 114, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 105, 109, 112, 108, 101, 85, 73,
			68, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 83, 105, 109, 112, 108,
			101, 85, 73, 110, 116, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 83,
			105, 109, 112, 108, 101, 73, 110, 116, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 101, 104, 105, 99, 108, 101, 76,
			105, 102, 116, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 69, 110, 103,
			105, 110, 101, 83, 116, 111, 114, 97, 103, 101,
			1, 0, 0, 0, 17, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 73, 79, 69, 110, 116, 105,
			116, 121, 1, 0, 0, 0, 30, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 73, 79, 69, 110,
			116, 105, 116, 121, 124, 73, 79, 67, 111, 110,
			110, 101, 99, 116, 105, 111, 110, 1, 0, 0,
			0, 38, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 73, 79, 69, 110, 116, 105, 116, 121, 43,
			73, 79, 67, 111, 110, 110, 101, 99, 116, 105,
			111, 110, 124, 76, 105, 110, 101, 86, 101, 99,
			1, 0, 0, 0, 44, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 73, 79, 69, 110, 116, 105,
			116, 121, 43, 73, 79, 67, 111, 110, 110, 101,
			99, 116, 105, 111, 110, 124, 76, 105, 110, 101,
			80, 111, 105, 110, 116, 76, 105, 115, 116, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 117, 122, 122, 108, 101, 82,
			101, 115, 101, 116, 1, 0, 0, 0, 28, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 82, 101,
			108, 97, 116, 105, 111, 110, 115, 104, 105, 112,
			77, 97, 110, 97, 103, 101, 114, 1, 0, 0,
			0, 51, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 82, 101, 108, 97, 116, 105, 111, 110, 115,
			104, 105, 112, 77, 97, 110, 97, 103, 101, 114,
			124, 80, 108, 97, 121, 101, 114, 82, 101, 108,
			97, 116, 105, 111, 110, 115, 104, 105, 112, 73,
			110, 102, 111, 1, 0, 0, 0, 48, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 82, 101, 108,
			97, 116, 105, 111, 110, 115, 104, 105, 112, 77,
			97, 110, 97, 103, 101, 114, 124, 80, 108, 97,
			121, 101, 114, 82, 101, 108, 97, 116, 105, 111,
			110, 115, 104, 105, 112, 115, 1, 0, 0, 0,
			16, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			69, 103, 103, 72, 117, 110, 116, 1, 0, 0,
			0, 26, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 69, 103, 103, 72, 117, 110, 116, 124, 69,
			103, 103, 72, 117, 110, 116, 101, 114, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 114, 99, 97, 100, 101, 77, 97,
			99, 104, 105, 110, 101, 1, 0, 0, 0, 33,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 65,
			114, 99, 97, 100, 101, 77, 97, 99, 104, 105,
			110, 101, 124, 83, 99, 111, 114, 101, 69, 110,
			116, 114, 121, 1, 0, 0, 0, 14, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 72, 111, 114,
			115, 101, 1, 0, 0, 0, 23, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 72, 111, 114, 115,
			101, 77, 111, 100, 105, 102, 105, 101, 114, 115,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 83, 109, 97, 114, 116, 65,
			108, 97, 114, 109, 1, 0, 0, 0, 28, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 73, 110,
			115, 116, 114, 117, 109, 101, 110, 116, 82, 101,
			99, 111, 114, 100, 105, 110, 103, 1, 0, 0,
			0, 32, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 73, 110, 115, 116, 114, 117, 109, 101, 110,
			116, 82, 101, 99, 111, 114, 100, 105, 110, 103,
			78, 111, 116, 101, 1, 0, 0, 0, 31, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 73, 110,
			115, 116, 114, 117, 109, 101, 110, 116, 77, 105,
			100, 105, 66, 105, 110, 100, 105, 110, 103, 115,
			1, 0, 0, 0, 30, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 73, 110, 115, 116, 114, 117,
			109, 101, 110, 116, 77, 105, 100, 105, 66, 105,
			110, 100, 105, 110, 103, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 76,
			105, 103, 104, 116, 83, 116, 114, 105, 110, 103,
			1, 0, 0, 0, 32, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 76, 105, 103, 104, 116, 83,
			116, 114, 105, 110, 103, 124, 83, 116, 114, 105,
			110, 103, 80, 111, 105, 110, 116, 1, 0, 0,
			0, 22, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 76, 105, 103, 104, 116, 68, 101, 112, 108,
			111, 121, 101, 114, 1, 0, 0, 0, 17, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 82, 67,
			69, 110, 116, 105, 116, 121, 1, 0, 0, 0,
			24, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 111, 109, 112, 117, 116, 101, 114, 83, 116,
			97, 116, 105, 111, 110, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			111, 109, 112, 111, 115, 116, 101, 114, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 101, 104, 105, 99, 108, 101, 86,
			101, 110, 100, 111, 114, 1, 0, 0, 0, 36,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 86,
			101, 104, 105, 99, 108, 101, 86, 101, 110, 100,
			111, 114, 124, 80, 108, 97, 121, 101, 114, 83,
			116, 111, 114, 97, 103, 101, 1, 0, 0, 0,
			56, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			86, 101, 104, 105, 99, 108, 101, 86, 101, 110,
			100, 111, 114, 43, 80, 108, 97, 121, 101, 114,
			83, 116, 111, 114, 97, 103, 101, 124, 80, 108,
			97, 121, 101, 114, 83, 116, 111, 114, 101, 100,
			86, 101, 104, 105, 99, 108, 101, 1, 0, 0,
			0, 19, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 83, 104, 111, 112, 75, 101, 101, 112, 101,
			114, 1, 0, 0, 0, 18, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 87, 97, 116, 101, 114,
			80, 111, 111, 108, 1, 0, 0, 0, 14, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 80, 104,
			111, 116, 111, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 80, 104, 111,
			116, 111, 70, 114, 97, 109, 101, 1, 0, 0,
			0, 22, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 86, 101, 104, 105, 99, 108, 101, 77, 111,
			100, 117, 108, 101, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 77, 105,
			120, 105, 110, 103, 84, 97, 98, 108, 101, 1,
			0, 0, 0, 17, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 69, 108, 101, 118, 97, 116, 111,
			114, 1, 0, 0, 0, 20, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 83, 107, 117, 108, 108,
			84, 114, 111, 112, 104, 121, 1, 0, 0, 0,
			17, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 97, 115, 115, 101, 116, 116, 101, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 84, 101, 108, 101, 112, 104, 111, 110,
			101, 1, 0, 0, 0, 16, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 111, 111, 109, 66,
			111, 120, 1, 0, 0, 0, 17, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 78, 101, 111, 110,
			83, 105, 103, 110, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			111, 110, 83, 105, 103, 110, 124, 76, 105, 103,
			104, 116, 115, 1, 0, 0, 0, 20, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 84, 114, 97,
			105, 110, 69, 110, 103, 105, 110, 101, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 117, 98, 69, 110, 116, 105, 116,
			121, 76, 105, 115, 116, 1, 0, 0, 0, 23,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 77,
			97, 114, 107, 101, 116, 84, 101, 114, 109, 105,
			110, 97, 108, 1, 0, 0, 0, 36, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 77, 97, 114,
			107, 101, 116, 84, 101, 114, 109, 105, 110, 97,
			108, 124, 80, 101, 110, 100, 105, 110, 103, 79,
			114, 100, 101, 114, 1, 0, 0, 0, 22, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 68, 101,
			108, 105, 118, 101, 114, 121, 68, 114, 111, 110,
			101, 1, 0, 0, 0, 17, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 71, 97, 109, 101, 77,
			111, 100, 101, 1, 0, 0, 0, 26, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 71, 97, 109,
			101, 77, 111, 100, 101, 124, 84, 101, 97, 109,
			73, 110, 102, 111, 1, 0, 0, 0, 29, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 71, 97,
			109, 101, 77, 111, 100, 101, 124, 83, 99, 111,
			114, 101, 67, 111, 108, 117, 109, 110, 1, 0,
			0, 0, 29, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 71, 97, 109, 101, 77, 111, 100, 101,
			124, 80, 108, 97, 121, 101, 114, 83, 99, 111,
			114, 101, 1, 0, 0, 0, 23, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 82, 101, 99, 108,
			97, 105, 109, 77, 97, 110, 97, 103, 101, 114,
			1, 0, 0, 0, 35, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 82, 101, 99, 108, 97, 105,
			109, 77, 97, 110, 97, 103, 101, 114, 124, 82,
			101, 99, 108, 97, 105, 109, 73, 110, 102, 111,
			1, 0, 0, 0, 24, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 82, 101, 99, 108, 97, 105,
			109, 84, 101, 114, 109, 105, 110, 97, 108, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 83, 108, 111, 116, 77, 97, 99,
			104, 105, 110, 101, 1, 0, 0, 0, 17, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 67, 97,
			114, 100, 71, 97, 109, 101, 1, 0, 0, 0,
			28, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			67, 97, 114, 100, 71, 97, 109, 101, 124, 67,
			97, 114, 100, 80, 108, 97, 121, 101, 114, 1,
			0, 0, 0, 29, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 67, 97, 114, 100, 71, 97, 109,
			101, 124, 84, 101, 120, 97, 115, 72, 111, 108,
			100, 69, 109, 1, 0, 0, 0, 30, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 67, 97, 114,
			100, 71, 97, 109, 101, 124, 82, 111, 117, 110,
			100, 82, 101, 115, 117, 108, 116, 115, 1, 0,
			0, 0, 37, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 97, 114, 100, 71, 97, 109, 101,
			43, 82, 111, 117, 110, 100, 82, 101, 115, 117,
			108, 116, 115, 124, 82, 101, 115, 117, 108, 116,
			1, 0, 0, 0, 27, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 67, 97, 114, 100, 71, 97,
			109, 101, 124, 66, 108, 97, 99, 107, 106, 97,
			99, 107, 1, 0, 0, 0, 37, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 67, 97, 114, 100,
			71, 97, 109, 101, 124, 66, 108, 97, 99, 107,
			106, 97, 99, 107, 67, 97, 114, 100, 80, 108,
			97, 121, 101, 114, 1, 0, 0, 0, 26, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 67, 97,
			114, 100, 71, 97, 109, 101, 124, 67, 97, 114,
			100, 76, 105, 115, 116, 1, 0, 0, 0, 14,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			114, 97, 110, 101, 1, 0, 0, 0, 25, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 67, 111,
			110, 110, 101, 99, 116, 101, 100, 83, 112, 101,
			97, 107, 101, 114, 1, 0, 0, 0, 23, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 86, 111,
			105, 99, 101, 109, 97, 105, 108, 69, 110, 116,
			114, 121, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 117, 100, 105,
			111, 69, 110, 116, 105, 116, 121, 1, 0, 0,
			0, 24, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 77, 105, 99, 114, 111, 112, 104, 111, 110,
			101, 83, 116, 97, 110, 100, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 111, 109, 109, 97, 110, 100, 66, 108, 111,
			99, 107, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 117, 98, 109,
			97, 114, 105, 110, 101, 1, 0, 0, 0, 26,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 83,
			108, 101, 101, 112, 105, 110, 103, 66, 97, 103,
			67, 97, 109, 112, 101, 114, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 97, 109, 112, 101, 114, 77, 111, 100, 117,
			108, 101, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 80, 97, 105, 110,
			116, 97, 98, 108, 101, 83, 105, 103, 110, 1,
			0, 0, 0, 13, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 76, 82, 83, 1, 0, 0,
			0, 19, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 83, 110, 111, 119, 109, 111, 98, 105, 108,
			101, 1, 0, 0, 0, 24, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 97, 116, 116, 101,
			114, 110, 70, 105, 114, 101, 119, 111, 114, 107,
			1, 0, 0, 0, 31, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 80, 97, 116, 116, 101, 114,
			110, 70, 105, 114, 101, 119, 111, 114, 107, 124,
			68, 101, 115, 105, 103, 110, 1, 0, 0, 0,
			29, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			80, 97, 116, 116, 101, 114, 110, 70, 105, 114,
			101, 119, 111, 114, 107, 124, 83, 116, 97, 114,
			1, 0, 0, 0, 36, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 80, 97, 116, 116, 101, 114,
			110, 70, 105, 114, 101, 119, 111, 114, 107, 124,
			83, 97, 118, 101, 100, 68, 101, 115, 105, 103,
			110, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 67, 97, 114, 103, 111,
			80, 108, 97, 110, 101, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 80,
			97, 105, 110, 116, 101, 100, 73, 116, 101, 109,
			1, 0, 0, 0, 14, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 83, 112, 114, 97, 121, 1,
			0, 0, 0, 18, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 83, 112, 114, 97, 121, 76, 105,
			110, 101, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 112, 114, 97,
			121, 76, 105, 115, 116, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 76,
			105, 110, 101, 80, 111, 105, 110, 116, 1, 0,
			0, 0, 16, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 90, 105, 112, 108, 105, 110, 101, 1,
			0, 0, 0, 25, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 90, 105, 112, 108, 105, 110, 101,
			77, 111, 117, 110, 116, 97, 98, 108, 101, 1,
			0, 0, 0, 28, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 90, 105, 112, 108, 105, 110, 101,
			65, 114, 114, 105, 118, 97, 108, 80, 111, 105,
			110, 116, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 66, 97, 115, 101,
			84, 114, 97, 105, 110, 1, 0, 0, 0, 21,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			111, 97, 108, 105, 110, 103, 84, 111, 119, 101,
			114, 1, 0, 0, 0, 17, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 97, 115, 101, 79,
			118, 101, 110, 1, 0, 0, 0, 29, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 66, 97, 115,
			101, 79, 118, 101, 110, 124, 67, 111, 111, 107,
			105, 110, 103, 73, 116, 101, 109, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 66, 114, 97, 105, 110, 67, 111, 109, 112,
			111, 110, 101, 110, 116, 1, 0, 0, 0, 26,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 80,
			114, 111, 99, 101, 100, 117, 114, 97, 108, 68,
			117, 110, 103, 101, 111, 110, 1, 0, 0, 0,
			27, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			73, 110, 100, 117, 115, 116, 114, 105, 97, 108,
			67, 111, 110, 118, 101, 121, 111, 114, 1, 0,
			0, 0, 38, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 73, 110, 100, 117, 115, 116, 114, 105,
			97, 108, 67, 111, 110, 118, 101, 121, 111, 114,
			124, 73, 116, 101, 109, 70, 105, 108, 116, 101,
			114, 1, 0, 0, 0, 42, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 73, 110, 100, 117, 115,
			116, 114, 105, 97, 108, 67, 111, 110, 118, 101,
			121, 111, 114, 124, 73, 116, 101, 109, 70, 105,
			108, 116, 101, 114, 76, 105, 115, 116, 1, 0,
			0, 0, 26, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 73, 110, 100, 117, 115, 116, 114, 105,
			97, 108, 67, 114, 97, 102, 116, 101, 114, 1,
			0, 0, 0, 35, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 73, 110, 100, 117, 115, 116, 114,
			105, 97, 108, 67, 111, 110, 118, 101, 121, 111,
			114, 84, 114, 97, 110, 115, 102, 101, 114, 1,
			0, 0, 0, 48, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 73, 110, 100, 117, 115, 116, 114,
			105, 97, 108, 67, 111, 110, 118, 101, 121, 111,
			114, 84, 114, 97, 110, 115, 102, 101, 114, 124,
			73, 116, 101, 109, 84, 114, 97, 110, 115, 102,
			101, 114, 1, 0, 0, 0, 14, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 68, 114, 111, 110,
			101, 1, 0, 0, 0, 23, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 84, 105, 109, 101, 100,
			69, 120, 112, 108, 111, 115, 105, 118, 101, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 116, 116, 97, 99, 107, 72,
			101, 108, 105, 1, 0, 0, 0, 25, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 116, 116,
			97, 99, 107, 72, 101, 108, 105, 84, 117, 114,
			114, 101, 116, 1, 0, 0, 0, 26, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 116, 116,
			97, 99, 107, 72, 101, 108, 105, 82, 111, 99,
			107, 101, 116, 115, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 67, 108,
			97, 110, 77, 97, 110, 97, 103, 101, 114, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 115, 115, 111, 99, 105, 97,
			116, 101, 100, 70, 105, 108, 101, 115, 1, 0,
			0, 0, 39, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 65, 115, 115, 111, 99, 105, 97, 116,
			101, 100, 70, 105, 108, 101, 115, 124, 65, 115,
			115, 111, 99, 105, 97, 116, 101, 100, 70, 105,
			108, 101, 1, 0, 0, 0, 19, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 78, 101, 120, 117,
			115, 70, 101, 114, 114, 121, 1, 0, 0, 0,
			20, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			78, 101, 120, 117, 115, 73, 115, 108, 97, 110,
			100, 1, 0, 0, 0, 26, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 78, 101, 120, 117, 115,
			68, 111, 99, 107, 84, 101, 114, 109, 105, 110,
			97, 108, 1, 0, 0, 0, 40, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 78, 101, 120, 117,
			115, 68, 111, 99, 107, 84, 101, 114, 109, 105,
			110, 97, 108, 124, 83, 99, 104, 101, 100, 117,
			108, 101, 69, 110, 116, 114, 121, 1, 0, 0,
			0, 17, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 66, 97, 115, 101, 66, 111, 97, 116, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 68, 105, 101, 115, 101, 108, 69,
			110, 103, 105, 110, 101, 1, 0, 0, 0, 21,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 82,
			111, 99, 107, 105, 110, 103, 67, 104, 97, 105,
			114, 1, 0, 0, 0, 17, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 72, 101, 97, 100, 68,
			97, 116, 97, 1, 0, 0, 0, 21, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 87, 97, 110,
			116, 101, 100, 80, 111, 115, 116, 101, 114, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 87, 97, 121, 112, 111, 105, 110,
			116, 82, 97, 99, 101, 1, 0, 0, 0, 16,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 82,
			97, 103, 100, 111, 108, 108, 1, 0, 0, 0,
			22, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			76, 101, 103, 97, 99, 121, 83, 104, 101, 108,
			116, 101, 114, 1, 0, 0, 0, 28, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 101, 116,
			97, 108, 68, 101, 116, 101, 99, 116, 111, 114,
			83, 111, 117, 114, 99, 101, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			84, 117, 116, 111, 114, 105, 97, 108, 73, 115,
			108, 97, 110, 100, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 67, 105,
			110, 101, 109, 97, 116, 105, 99, 69, 110, 116,
			105, 116, 121, 1, 0, 0, 0, 20, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 72, 97, 114,
			98, 111, 114, 67, 114, 97, 110, 101, 1, 0,
			0, 0, 31, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 72, 97, 114, 98, 111, 114, 67, 114,
			97, 110, 101, 124, 81, 117, 101, 117, 101, 100,
			77, 111, 118, 101, 1, 0, 0, 0, 18, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 67, 97,
			114, 103, 111, 83, 104, 105, 112, 1, 0, 0,
			0, 27, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 67, 97, 114, 103, 111, 83, 104, 105, 112,
			67, 111, 110, 116, 97, 105, 110, 101, 114, 1,
			0, 0, 0, 25, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 105, 115, 115, 105, 111, 110,
			77, 97, 112, 77, 97, 114, 107, 101, 114, 1,
			0, 0, 0, 13, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 66, 105, 107, 101, 1, 0, 0,
			0, 25, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 84, 114, 97, 118, 101, 108, 108, 105, 110,
			103, 86, 101, 110, 100, 111, 114, 1, 0, 0,
			0, 30, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 86, 101, 110, 100, 105, 110, 103, 68, 121,
			110, 97, 109, 105, 99, 80, 114, 105, 99, 105,
			110, 103, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 97, 108, 101,
			115, 68, 97, 116, 97, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 84,
			105, 110, 67, 97, 110, 65, 108, 97, 114, 109,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 68, 105, 103, 105, 116, 97,
			108, 67, 108, 111, 99, 107, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			69, 108, 101, 118, 97, 116, 111, 114, 76, 105,
			102, 116, 1, 0, 0, 0, 31, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 68, 105, 118, 101,
			114, 80, 114, 111, 112, 117, 108, 115, 105, 111,
			110, 86, 101, 104, 105, 99, 108, 101, 1, 0,
			0, 0, 26, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 78, 80, 67, 86, 101, 110, 100, 105,
			110, 103, 77, 97, 99, 104, 105, 110, 101, 1,
			0, 0, 0, 16, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 97, 105, 108, 98, 111, 120,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 71, 117, 110, 87, 101, 97,
			112, 111, 110, 77, 111, 100, 1, 0, 0, 0,
			22, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			66, 97, 115, 101, 83, 99, 117, 108, 112, 116,
			117, 114, 101, 1, 0, 0, 0, 17, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 67, 97, 116,
			97, 112, 117, 108, 116, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 83,
			105, 101, 103, 101, 84, 111, 119, 101, 114, 1,
			0, 0, 0, 17, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 66, 97, 108, 108, 105, 115, 116,
			97, 1, 0, 0, 0, 20, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 97, 108, 108, 105,
			115, 116, 97, 71, 117, 110, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			66, 97, 116, 116, 101, 114, 105, 110, 103, 82,
			97, 109, 1, 0, 0, 0, 25, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 84, 101, 109, 112,
			111, 114, 97, 114, 121, 82, 97, 103, 100, 111,
			108, 108, 1, 0, 0, 0, 28, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 67, 111, 110, 115,
			116, 114, 117, 99, 116, 97, 98, 108, 101, 69,
			110, 116, 105, 116, 121, 1, 0, 0, 0, 22,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			104, 105, 99, 107, 101, 110, 83, 116, 97, 116,
			117, 115, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 67, 104, 105, 99,
			107, 101, 110, 67, 111, 111, 112, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 70, 97, 114, 109, 97, 98, 108, 101, 65,
			110, 105, 109, 97, 108, 1, 0, 0, 0, 16,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			101, 101, 104, 105, 118, 101, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			66, 101, 101, 77, 97, 115, 116, 101, 114, 83,
			119, 97, 114, 109, 1, 0, 0, 0, 28, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 67, 111,
			110, 116, 97, 105, 110, 101, 114, 67, 111, 114,
			112, 115, 101, 68, 97, 116, 97, 1, 0, 0,
			0, 22, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 86, 105, 110, 101, 77, 111, 117, 110, 116,
			97, 98, 108, 101, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 84, 114,
			101, 101, 82, 101, 115, 112, 97, 119, 110, 1,
			0, 0, 0, 17, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 86, 105, 110, 101, 84, 114, 101,
			101, 1, 0, 0, 0, 24, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 86, 105, 110, 101, 68,
			101, 115, 116, 105, 110, 97, 116, 105, 111, 110,
			1, 0, 0, 0, 30, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 83, 116, 97, 116, 105, 99,
			82, 101, 115, 112, 97, 119, 110, 65, 114, 101,
			97, 68, 97, 116, 97, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 77,
			97, 110, 110, 101, 113, 117, 105, 110, 1, 0,
			0, 0, 31, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 77, 97, 110, 110, 101, 113, 117, 105,
			110, 124, 67, 108, 111, 116, 104, 105, 110, 103,
			73, 116, 101, 109, 1, 0, 0, 0, 21, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 80, 108,
			97, 121, 101, 114, 78, 97, 109, 101, 73, 68,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 68, 101, 109, 111, 72, 101,
			97, 100, 101, 114, 1, 0, 0, 0, 29, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 70, 105,
			108, 101, 83, 116, 111, 114, 97, 103, 101, 67,
			97, 99, 104, 101, 68, 97, 116, 97, 1, 0,
			0, 0, 17, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 68, 101, 109, 111, 83, 104, 111, 116,
			1, 0, 0, 0, 28, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 68, 101, 109, 111, 83, 104,
			111, 116, 86, 101, 99, 116, 111, 114, 84, 114,
			97, 99, 107, 1, 0, 0, 0, 31, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 68, 101, 109,
			111, 83, 104, 111, 116, 86, 101, 99, 116, 111,
			114, 75, 101, 121, 102, 114, 97, 109, 101, 1,
			0, 0, 0, 27, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 68, 101, 109, 111, 83, 104, 111,
			116, 70, 108, 111, 97, 116, 84, 114, 97, 99,
			107, 1, 0, 0, 0, 30, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 68, 101, 109, 111, 83,
			104, 111, 116, 70, 108, 111, 97, 116, 75, 101,
			121, 102, 114, 97, 109, 101, 1, 0, 0, 0,
			32, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			68, 101, 109, 111, 83, 104, 111, 116, 81, 117,
			97, 116, 101, 114, 110, 105, 111, 110, 84, 114,
			97, 99, 107, 1, 0, 0, 0, 35, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 68, 101, 109,
			111, 83, 104, 111, 116, 81, 117, 97, 116, 101,
			114, 110, 105, 111, 110, 75, 101, 121, 102, 114,
			97, 109, 101, 1, 0, 0, 0, 28, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 68, 101, 109,
			111, 83, 104, 111, 116, 80, 97, 114, 101, 110,
			116, 84, 114, 97, 99, 107, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			68, 101, 109, 111, 83, 104, 111, 116, 80, 97,
			114, 101, 110, 116, 75, 101, 121, 102, 114, 97,
			109, 101, 1, 0, 0, 0, 28, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 67, 111, 112, 121,
			80, 97, 115, 116, 101, 69, 110, 116, 105, 116,
			121, 73, 110, 102, 111, 1, 0, 0, 0, 21,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 80,
			97, 115, 116, 101, 82, 101, 113, 117, 101, 115,
			116, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 73, 116, 101, 109, 67,
			111, 110, 116, 97, 105, 110, 101, 114, 1, 0,
			0, 0, 13, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 73, 116, 101, 109, 1, 0, 0, 0,
			26, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			73, 116, 101, 109, 124, 73, 110, 115, 116, 97,
			110, 99, 101, 68, 97, 116, 97, 1, 0, 0,
			0, 27, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 73, 116, 101, 109, 124, 67, 111, 110, 100,
			105, 116, 105, 111, 110, 68, 97, 116, 97, 1,
			0, 0, 0, 28, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 73, 116, 101, 109, 79, 119, 110,
			101, 114, 115, 104, 105, 112, 65, 109, 111, 117,
			110, 116, 1, 0, 0, 0, 13, 124, 73, 110,
			112, 117, 116, 77, 101, 115, 115, 97, 103, 101,
			1, 0, 0, 0, 17, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 114, 111, 118,
			97, 108, 1, 0, 0, 0, 28, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 85, 112, 100, 97,
			116, 101, 73, 116, 101, 109, 67, 111, 110, 116,
			97, 105, 110, 101, 114, 1, 0, 0, 0, 25,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 80,
			108, 97, 121, 101, 114, 85, 112, 100, 97, 116,
			101, 76, 111, 111, 116, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 85,
			112, 100, 97, 116, 101, 73, 116, 101, 109, 1,
			0, 0, 0, 11, 124, 80, 108, 97, 121, 101,
			114, 84, 105, 99, 107, 1, 0, 0, 0, 11,
			124, 77, 111, 100, 101, 108, 83, 116, 97, 116,
			101, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 84, 97, 107, 101, 68,
			97, 109, 97, 103, 101, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 69,
			110, 116, 105, 116, 121, 76, 105, 115, 116, 1,
			0, 0, 0, 23, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 114, 101, 97, 116, 101, 66,
			117, 105, 108, 100, 105, 110, 103, 1, 0, 0,
			0, 15, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 116, 116, 97, 99, 107, 1, 0, 0,
			0, 21, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 108, 97, 121, 101, 114, 65, 116, 116,
			97, 99, 107, 1, 0, 0, 0, 31, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 80, 108, 97,
			121, 101, 114, 80, 114, 111, 106, 101, 99, 116,
			105, 108, 101, 65, 116, 116, 97, 99, 107, 1,
			0, 0, 0, 33, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 108, 97, 121, 101, 114, 80,
			114, 111, 106, 101, 99, 116, 105, 108, 101, 82,
			105, 99, 111, 99, 104, 101, 116, 1, 0, 0,
			0, 31, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 108, 97, 121, 101, 114, 80, 114, 111,
			106, 101, 99, 116, 105, 108, 101, 85, 112, 100,
			97, 116, 101, 1, 0, 0, 0, 24, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 80, 114, 111,
			106, 101, 99, 116, 105, 108, 101, 83, 104, 111,
			111, 116, 1, 0, 0, 0, 35, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 80, 114, 111, 106,
			101, 99, 116, 105, 108, 101, 83, 104, 111, 111,
			116, 124, 80, 114, 111, 106, 101, 99, 116, 105,
			108, 101, 1, 0, 0, 0, 11, 124, 69, 102,
			102, 101, 99, 116, 68, 97, 116, 97, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 77, 111, 100, 117, 108, 101, 77, 101,
			115, 115, 97, 103, 101, 1, 0, 0, 0, 27,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 82,
			101, 115, 112, 97, 119, 110, 73, 110, 102, 111,
			114, 109, 97, 116, 105, 111, 110, 1, 0, 0,
			0, 40, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 82, 101, 115, 112, 97, 119, 110, 73, 110,
			102, 111, 114, 109, 97, 116, 105, 111, 110, 124,
			83, 112, 97, 119, 110, 79, 112, 116, 105, 111,
			110, 115, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 67, 108, 105, 101,
			110, 116, 82, 101, 97, 100, 121, 1, 0, 0,
			0, 31, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 67, 108, 105, 101, 110, 116, 82, 101, 97,
			100, 121, 124, 67, 108, 105, 101, 110, 116, 73,
			110, 102, 111, 1, 0, 0, 0, 13, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 84, 114, 101,
			101, 1, 0, 0, 0, 17, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 84, 114, 101, 101, 76,
			105, 115, 116, 1, 0, 0, 0, 21, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 87, 111, 114,
			108, 100, 77, 101, 115, 115, 97, 103, 101, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 114, 99, 97, 100, 101, 71,
			97, 109, 101, 1, 0, 0, 0, 29, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 65, 114, 99,
			97, 100, 101, 71, 97, 109, 101, 124, 97, 114,
			99, 97, 100, 101, 69, 110, 116, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 104, 111, 110, 101, 68, 105, 114, 101,
			99, 116, 111, 114, 121, 1, 0, 0, 0, 38,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 80,
			104, 111, 110, 101, 68, 105, 114, 101, 99, 116,
			111, 114, 121, 124, 68, 105, 114, 101, 99, 116,
			111, 114, 121, 69, 110, 116, 114, 121, 1, 0,
			0, 0, 21, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 69, 110, 116, 105, 116, 121, 73, 100,
			76, 105, 115, 116, 1, 0, 0, 0, 18, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 82, 97,
			100, 105, 111, 76, 105, 115, 116, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 73, 116, 101, 109, 65, 109, 111, 117, 110,
			116, 76, 105, 115, 116, 1, 0, 0, 0, 29,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 87,
			105, 114, 101, 82, 101, 99, 111, 110, 110, 101,
			99, 116, 77, 101, 115, 115, 97, 103, 101, 1,
			0, 0, 0, 27, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 87, 105, 114, 101, 76, 105, 110,
			101, 65, 110, 99, 104, 111, 114, 73, 110, 102,
			111, 1, 0, 0, 0, 30, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 87, 105, 114, 101, 67,
			111, 110, 110, 101, 99, 116, 105, 111, 110, 77,
			101, 115, 115, 97, 103, 101, 1, 0, 0, 0,
			19, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			79, 99, 101, 97, 110, 80, 97, 116, 104, 115,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 86, 101, 99, 116, 111, 114,
			76, 105, 115, 116, 1, 0, 0, 0, 28, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 68, 105,
			103, 105, 116, 97, 108, 67, 108, 111, 99, 107,
			77, 101, 115, 115, 97, 103, 101, 1, 0, 0,
			0, 26, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 68, 105, 103, 105, 116, 97, 108, 67, 108,
			111, 99, 107, 65, 108, 97, 114, 109, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 68, 68, 114, 97, 119, 69, 110,
			116, 114, 121, 1, 0, 0, 0, 50, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 86, 101, 110,
			100, 105, 110, 103, 77, 97, 99, 104, 105, 110,
			101, 80, 117, 114, 99, 104, 97, 115, 101, 72,
			105, 115, 116, 111, 114, 121, 69, 110, 116, 114,
			121, 77, 101, 115, 115, 97, 103, 101, 1, 0,
			0, 0, 55, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 101, 110, 100, 105, 110, 103, 77,
			97, 99, 104, 105, 110, 101, 80, 117, 114, 99,
			104, 97, 115, 101, 72, 105, 115, 116, 111, 114,
			121, 69, 110, 116, 114, 121, 83, 109, 97, 108,
			108, 77, 101, 115, 115, 97, 103, 101, 1, 0,
			0, 0, 45, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 101, 110, 100, 105, 110, 103, 77,
			97, 99, 104, 105, 110, 101, 80, 117, 114, 99,
			104, 97, 115, 101, 72, 105, 115, 116, 111, 114,
			121, 77, 101, 115, 115, 97, 103, 101, 1, 0,
			0, 0, 36, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 101, 110, 100, 105, 110, 103, 77,
			97, 99, 104, 105, 110, 101, 76, 111, 110, 103,
			84, 101, 114, 109, 83, 116, 97, 116, 115, 1,
			0, 0, 0, 32, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 104, 105, 99, 107, 101, 110,
			67, 111, 111, 112, 83, 116, 97, 116, 117, 115,
			85, 112, 100, 97, 116, 101, 1, 0, 0, 0,
			29, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			70, 97, 114, 109, 97, 98, 108, 101, 65, 110,
			105, 109, 97, 108, 83, 116, 97, 116, 117, 115,
			1, 0, 0, 0, 23, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 78, 80, 67, 83, 101, 110,
			115, 101, 115, 83, 116, 97, 116, 101, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 80, 97, 114, 116, 121, 68, 97, 116,
			97, 1, 0, 0, 0, 24, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 97, 114, 116, 121,
			77, 101, 109, 98, 101, 114, 68, 97, 116, 97,
			0, 0, 0, 0, 30, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 46, 78, 101, 120, 117, 115,
			124, 85, 117, 105, 100, 83, 101, 114, 105, 97,
			108, 105, 122, 101, 100, 1, 0, 0, 0, 21,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 124, 80, 97, 99, 107, 101,
			116, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 78, 101, 120, 117, 115,
			124, 82, 101, 113, 117, 101, 115, 116, 1, 0,
			0, 0, 23, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 78, 101, 120, 117, 115, 124, 82, 101,
			115, 112, 111, 110, 115, 101, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			78, 101, 120, 117, 115, 124, 83, 116, 97, 116,
			117, 115, 1, 0, 0, 0, 26, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 78, 101, 120, 117,
			115, 124, 80, 105, 110, 103, 82, 101, 113, 117,
			101, 115, 116, 1, 0, 0, 0, 27, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 78, 101, 120,
			117, 115, 124, 80, 105, 110, 103, 82, 101, 115,
			112, 111, 110, 115, 101, 1, 0, 0, 0, 30,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 124, 84, 114, 97, 110, 115,
			102, 101, 114, 82, 101, 113, 117, 101, 115, 116,
			1, 0, 0, 0, 34, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 78, 101, 120, 117, 115, 124,
			80, 108, 97, 121, 101, 114, 83, 101, 99, 111,
			110, 100, 97, 114, 121, 68, 97, 116, 97, 1,
			0, 0, 0, 51, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 78, 101, 120, 117, 115, 46, 80,
			108, 97, 121, 101, 114, 83, 101, 99, 111, 110,
			100, 97, 114, 121, 68, 97, 116, 97, 124, 82,
			101, 108, 97, 116, 105, 111, 110, 115, 104, 105,
			112, 68, 97, 116, 97, 1, 0, 0, 0, 34,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 124, 83, 112, 97, 119, 110,
			79, 112, 116, 105, 111, 110, 115, 82, 101, 113,
			117, 101, 115, 116, 1, 0, 0, 0, 35, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			120, 117, 115, 124, 83, 112, 97, 119, 110, 79,
			112, 116, 105, 111, 110, 115, 82, 101, 115, 112,
			111, 110, 115, 101, 1, 0, 0, 0, 40, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			120, 117, 115, 124, 83, 108, 101, 101, 112, 105,
			110, 103, 66, 97, 103, 82, 101, 115, 112, 97,
			119, 110, 82, 101, 113, 117, 101, 115, 116, 1,
			0, 0, 0, 40, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 78, 101, 120, 117, 115, 124, 83,
			108, 101, 101, 112, 105, 110, 103, 66, 97, 103,
			68, 101, 115, 116, 114, 111, 121, 82, 101, 113,
			117, 101, 115, 116, 1, 0, 0, 0, 33, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			120, 117, 115, 124, 70, 101, 114, 114, 121, 83,
			116, 97, 116, 117, 115, 82, 101, 113, 117, 101,
			115, 116, 1, 0, 0, 0, 34, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 78, 101, 120, 117,
			115, 124, 70, 101, 114, 114, 121, 83, 116, 97,
			116, 117, 115, 82, 101, 115, 112, 111, 110, 115,
			101, 1, 0, 0, 0, 26, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 78, 101, 120, 117, 115,
			124, 70, 101, 114, 114, 121, 83, 116, 97, 116,
			117, 115, 1, 0, 0, 0, 33, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 78, 101, 120, 117,
			115, 124, 70, 101, 114, 114, 121, 82, 101, 116,
			105, 114, 101, 82, 101, 113, 117, 101, 115, 116,
			1, 0, 0, 0, 41, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 78, 101, 120, 117, 115, 124,
			70, 101, 114, 114, 121, 85, 112, 100, 97, 116,
			101, 83, 99, 104, 101, 100, 117, 108, 101, 82,
			101, 113, 117, 101, 115, 116, 1, 0, 0, 0,
			35, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			78, 101, 120, 117, 115, 124, 67, 108, 97, 110,
			67, 104, 97, 116, 66, 97, 116, 99, 104, 82,
			101, 113, 117, 101, 115, 116, 1, 0, 0, 0,
			43, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			78, 101, 120, 117, 115, 46, 67, 108, 97, 110,
			67, 104, 97, 116, 66, 97, 116, 99, 104, 82,
			101, 113, 117, 101, 115, 116, 124, 77, 101, 115,
			115, 97, 103, 101, 1, 0, 0, 0, 36, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			120, 117, 115, 124, 80, 108, 97, 121, 101, 114,
			77, 97, 110, 105, 102, 101, 115, 116, 82, 101,
			113, 117, 101, 115, 116, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			97, 115, 101, 80, 108, 97, 121, 101, 114, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 108, 97, 121, 101, 114, 84,
			101, 97, 109, 1, 0, 0, 0, 30, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 80, 108, 97,
			121, 101, 114, 84, 101, 97, 109, 124, 84, 101,
			97, 109, 77, 101, 109, 98, 101, 114, 1, 0,
			0, 0, 25, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 80, 108, 97, 121, 101, 114, 77, 101,
			116, 97, 98, 111, 108, 105, 115, 109, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 80, 108, 97, 121, 101, 114, 77, 111,
			100, 105, 102, 105, 101, 114, 115, 1, 0, 0,
			0, 17, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 77, 111, 100, 105, 102, 105, 101, 114, 1,
			0, 0, 0, 17, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 105, 115, 115, 105, 111, 110,
			115, 1, 0, 0, 0, 24, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 79, 98, 106, 101, 99,
			116, 105, 118, 101, 83, 116, 97, 116, 117, 115,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 77, 105, 115, 115, 105, 111,
			110, 80, 111, 105, 110, 116, 1, 0, 0, 0,
			22, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			77, 105, 115, 115, 105, 111, 110, 69, 110, 116,
			105, 116, 121, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 105, 115,
			115, 105, 111, 110, 82, 101, 119, 97, 114, 100,
			1, 0, 0, 0, 24, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 77, 105, 115, 115, 105, 111,
			110, 73, 110, 115, 116, 97, 110, 99, 101, 1,
			0, 0, 0, 28, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 105, 115, 115, 105, 111, 110,
			73, 110, 115, 116, 97, 110, 99, 101, 68, 97,
			116, 97, 1, 0, 0, 0, 24, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 80, 108, 97, 121,
			101, 114, 73, 110, 118, 101, 110, 116, 111, 114,
			121, 1, 0, 0, 0, 25, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 101, 114, 115, 105,
			115, 116, 97, 110, 116, 80, 108, 97, 121, 101,
			114, 1, 0, 0, 0, 24, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 108, 97, 121, 101,
			114, 76, 105, 102, 101, 83, 116, 111, 114, 121,
			1, 0, 0, 0, 34, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 80, 108, 97, 121, 101, 114,
			76, 105, 102, 101, 83, 116, 111, 114, 121, 124,
			68, 101, 97, 116, 104, 73, 110, 102, 111, 1,
			0, 0, 0, 36, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 80, 108, 97, 121, 101, 114, 76,
			105, 102, 101, 83, 116, 111, 114, 121, 124, 87,
			101, 97, 112, 111, 110, 83, 116, 97, 116, 115,
			1, 0, 0, 0, 36, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 80, 108, 97, 121, 101, 114,
			76, 105, 102, 101, 83, 116, 111, 114, 121, 124,
			71, 101, 110, 101, 114, 105, 99, 83, 116, 97,
			116, 1, 0, 0, 0, 16, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 77, 97, 112, 78, 111,
			116, 101, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 97, 112, 78,
			111, 116, 101, 76, 105, 115, 116, 1, 0, 0,
			0, 20, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 73, 116, 101, 109, 67, 114, 97, 102, 116,
			101, 114, 1, 0, 0, 0, 25, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 73, 116, 101, 109,
			67, 114, 97, 102, 116, 101, 114, 124, 84, 97,
			115, 107, 1, 0, 0, 0, 25, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 112, 101, 99,
			116, 97, 116, 101, 84, 101, 97, 109, 73, 110,
			102, 111, 1, 0, 0, 0, 21, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 112, 101, 99,
			116, 97, 116, 101, 84, 101, 97, 109, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 80, 108, 97, 121, 101, 114, 83, 116,
			97, 116, 101, 1, 0, 0, 0, 25, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 71, 108, 111,
			98, 97, 108, 69, 110, 116, 105, 116, 121, 68,
			97, 116, 97, 1, 0, 0, 0, 31, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 71, 108, 111,
			98, 97, 108, 69, 110, 116, 105, 116, 121, 67,
			111, 108, 108, 101, 99, 116, 105, 111, 110, 1,
			0, 0, 0, 18, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 87, 111, 114, 108, 100, 68, 97,
			116, 97, 1, 0, 0, 0, 16, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 97, 112, 68,
			97, 116, 97, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 80, 114, 101,
			102, 97, 98, 68, 97, 116, 97, 1, 0, 0,
			0, 17, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 97, 116, 104, 68, 97, 116, 97, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 86, 101, 99, 116, 111, 114, 68,
			97, 116, 97, 1, 0, 0, 0, 34, 83, 105,
			108, 101, 110, 116, 79, 114, 98, 105, 116, 46,
			80, 114, 111, 116, 111, 99, 111, 108, 66, 117,
			102, 102, 101, 114, 115, 124, 73, 80, 114, 111,
			116, 111, 1, 0, 0, 0, 34, 83, 105, 108,
			101, 110, 116, 79, 114, 98, 105, 116, 46, 80,
			114, 111, 116, 111, 99, 111, 108, 66, 117, 102,
			102, 101, 114, 115, 124, 73, 80, 114, 111, 116,
			111, 1, 0, 0, 0, 42, 83, 105, 108, 101,
			110, 116, 79, 114, 98, 105, 116, 46, 80, 114,
			111, 116, 111, 99, 111, 108, 66, 117, 102, 102,
			101, 114, 115, 124, 80, 114, 111, 116, 111, 99,
			111, 108, 80, 97, 114, 115, 101, 114, 0, 0,
			0, 0, 22, 124, 80, 114, 111, 116, 111, 83,
			116, 114, 101, 97, 109, 69, 120, 116, 101, 110,
			115, 105, 111, 110, 115, 0, 0, 0, 0, 51,
			83, 105, 108, 101, 110, 116, 79, 114, 98, 105,
			116, 46, 80, 114, 111, 116, 111, 99, 111, 108,
			66, 117, 102, 102, 101, 114, 115, 124, 80, 114,
			111, 116, 111, 99, 111, 108, 66, 117, 102, 102,
			101, 114, 69, 120, 99, 101, 112, 116, 105, 111,
			110, 0, 0, 0, 0, 31, 83, 105, 108, 101,
			110, 116, 79, 114, 98, 105, 116, 46, 80, 114,
			111, 116, 111, 99, 111, 108, 66, 117, 102, 102,
			101, 114, 115, 124, 75, 101, 121, 1, 0, 0,
			0, 42, 83, 105, 108, 101, 110, 116, 79, 114,
			98, 105, 116, 46, 80, 114, 111, 116, 111, 99,
			111, 108, 66, 117, 102, 102, 101, 114, 115, 124,
			80, 114, 111, 116, 111, 99, 111, 108, 80, 97,
			114, 115, 101, 114, 1, 0, 0, 0, 42, 83,
			105, 108, 101, 110, 116, 79, 114, 98, 105, 116,
			46, 80, 114, 111, 116, 111, 99, 111, 108, 66,
			117, 102, 102, 101, 114, 115, 124, 80, 114, 111,
			116, 111, 99, 111, 108, 80, 97, 114, 115, 101,
			114, 0, 0, 0, 0, 13, 124, 66, 117, 102,
			102, 101, 114, 83, 116, 114, 101, 97, 109, 0,
			0, 0, 0, 19, 66, 117, 102, 102, 101, 114,
			83, 116, 114, 101, 97, 109, 124, 83, 104, 97,
			114, 101, 100, 0, 0, 0, 0, 24, 66, 117,
			102, 102, 101, 114, 83, 116, 114, 101, 97, 109,
			124, 82, 97, 110, 103, 101, 72, 97, 110, 100,
			108, 101, 1, 0, 0, 0, 14, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 72, 97, 108, 102,
			51, 0, 0, 0, 0, 14, 124, 73, 83, 116,
			114, 101, 97, 109, 82, 101, 97, 100, 101, 114,
			0, 0, 0, 0, 14, 124, 73, 83, 116, 114,
			101, 97, 109, 87, 114, 105, 116, 101, 114, 0,
			0, 0, 0, 16, 124, 73, 116, 101, 109, 67,
			111, 110, 116, 97, 105, 110, 101, 114, 73, 100,
			0, 0, 0, 0, 7, 124, 73, 116, 101, 109,
			73, 100, 1, 0, 0, 0, 11, 124, 77, 111,
			100, 101, 108, 83, 116, 97, 116, 101, 0, 0,
			0, 0, 14, 124, 78, 101, 116, 119, 111, 114,
			107, 97, 98, 108, 101, 73, 100, 0, 0, 0,
			0, 15, 124, 78, 101, 116, 119, 111, 114, 107,
			68, 101, 102, 105, 110, 101, 115, 1, 0, 0,
			0, 19, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 86, 101, 99, 116, 111, 114, 68, 97, 116,
			97
		};
		result.TotalFiles = 12;
		result.TotalTypes = 878;
		result.IsEditorOnly = false;
		return result;
	}
}


public interface IProto
{
	void WriteToStream(BufferStream stream);

	void ReadFromStream(BufferStream stream, bool isDelta = false);

	void ReadFromStream(BufferStream stream, int size, bool isDelta = false);
}


using SilentOrbit.ProtocolBuffers;

public interface IProto<in T> : IProto where T : IProto
{
	void WriteToStreamDelta(BufferStream stream, T previousProto);

	void CopyTo(T other);
}


using System;
using System.IO;
using System.Text;
using SilentOrbit.ProtocolBuffers;

public static class ProtocolParser
{
	private const int staticBufferSize = 131072;

	[ThreadStatic]
	private static byte[] _staticBuffer;

	private static byte[] GetStaticBuffer()
	{
		return _staticBuffer ?? (_staticBuffer = new byte[131072]);
	}

	public static int ReadFixedInt32(BufferStream stream)
	{
		return stream.Read<int>();
	}

	public static void WriteFixedInt32(BufferStream stream, int i)
	{
		stream.Write(i);
	}

	public static long ReadFixedInt64(BufferStream stream)
	{
		return stream.Read<long>();
	}

	public static void WriteFixedInt64(BufferStream stream, long i)
	{
		stream.Write(i);
	}

	public static float ReadSingle(BufferStream stream)
	{
		return stream.Read<float>();
	}

	public static void WriteSingle(BufferStream stream, float f)
	{
		stream.Write(f);
	}

	public static double ReadDouble(BufferStream stream)
	{
		return stream.Read<double>();
	}

	public static void WriteDouble(BufferStream stream, double f)
	{
		stream.Write(f);
	}

	public unsafe static string ReadString(BufferStream stream)
	{
		int num = (int)ReadUInt32(stream);
		if (num <= 0)
		{
			return "";
		}
		string @string;
		fixed (byte* bytes = &stream.GetRange(num).GetSpan()[0])
		{
			@string = Encoding.UTF8.GetString(bytes, num);
		}
		return @string;
	}

	public static void WriteString(BufferStream stream, string val)
	{
		byte[] staticBuffer = GetStaticBuffer();
		int bytes = Encoding.UTF8.GetBytes(val, 0, val.Length, staticBuffer, 0);
		WriteUInt32(stream, (uint)bytes);
		if (bytes > 0)
		{
			new Span<byte>(staticBuffer, 0, bytes).CopyTo(stream.GetRange(bytes).GetSpan());
		}
	}

	public static byte[] ReadBytes(BufferStream stream)
	{
		int num = (int)ReadUInt32(stream);
		byte[] array = new byte[num];
		ReadBytesInto(stream, array, num);
		return array;
	}

	public static ArraySegment<byte> ReadPooledBytes(BufferStream stream)
	{
		int num = (int)ReadUInt32(stream);
		byte[] array = BufferStream.Shared.ArrayPool.Rent(num);
		ReadBytesInto(stream, array, num);
		return new ArraySegment<byte>(array, 0, num);
	}

	private static void ReadBytesInto(BufferStream stream, byte[] buffer, int length)
	{
		stream.GetRange(length).GetSpan().CopyTo(buffer);
	}

	public static void SkipBytes(BufferStream stream)
	{
		int count = (int)ReadUInt32(stream);
		stream.Skip(count);
	}

	public static void WriteBytes(BufferStream stream, byte[] val)
	{
		WriteUInt32(stream, (uint)val.Length);
		new Span<byte>(val).CopyTo(stream.GetRange(val.Length).GetSpan());
	}

	public static void WritePooledBytes(BufferStream stream, ArraySegment<byte> segment)
	{
		if (segment.Array == null)
		{
			WriteUInt32(stream, 0u);
			return;
		}
		WriteUInt32(stream, (uint)segment.Count);
		new Span<byte>(segment.Array, segment.Offset, segment.Count).CopyTo(stream.GetRange(segment.Count).GetSpan());
	}

	public static Key ReadKey(BufferStream stream)
	{
		uint num = ReadUInt32(stream);
		return new Key(num >> 3, (Wire)(num & 7));
	}

	public static Key ReadKey(byte firstByte, BufferStream stream)
	{
		if (firstByte < 128)
		{
			return new Key((uint)(firstByte >> 3), (Wire)(firstByte & 7));
		}
		return new Key((ReadUInt32(stream) << 4) | (uint)((firstByte >> 3) & 0xF), (Wire)(firstByte & 7));
	}

	public static void WriteKey(BufferStream stream, Key key)
	{
		uint val = (key.Field << 3) | (uint)key.WireType;
		WriteUInt32(stream, val);
	}

	public static void SkipKey(BufferStream stream, Key key)
	{
		switch (key.WireType)
		{
		case Wire.Fixed32:
			stream.Skip(4);
			break;
		case Wire.Fixed64:
			stream.Skip(8);
			break;
		case Wire.LengthDelimited:
			stream.Skip((int)ReadUInt32(stream));
			break;
		case Wire.Varint:
			ReadSkipVarInt(stream);
			break;
		default:
			throw new NotImplementedException("Unknown wire type: " + key.WireType);
		}
	}

	public static void ReadSkipVarInt(BufferStream stream)
	{
		int num;
		do
		{
			num = stream.ReadByte();
			if (num < 0)
			{
				throw new IOException("Stream ended too early");
			}
		}
		while ((num & 0x80) != 0);
	}

	public static uint ReadUInt32(Span<byte> array, int pos, out int length)
	{
		uint num = 0u;
		length = 0;
		for (int i = 0; i < 5; i++)
		{
			length++;
			if (pos >= array.Length)
			{
				break;
			}
			int num2 = array[pos++];
			if (num2 < 0)
			{
				throw new IOException("Stream ended too early");
			}
			if (i == 4 && (num2 & 0xF0) != 0)
			{
				throw new ProtocolBufferException("Got larger VarInt than 32bit unsigned");
			}
			if ((num2 & 0x80) == 0)
			{
				return num | (uint)(num2 << 7 * i);
			}
			num |= (uint)((num2 & 0x7F) << 7 * i);
		}
		throw new ProtocolBufferException("Got larger VarInt than 32bit unsigned");
	}

	public static int WriteUInt32(uint val, Span<byte> array, int pos)
	{
		int num = 0;
		while (pos < array.Length)
		{
			num++;
			byte b = (byte)(val & 0x7F);
			val >>= 7;
			if (val == 0)
			{
				array[pos++] = b;
				break;
			}
			b |= 0x80;
			array[pos++] = b;
		}
		return num;
	}

	public static int ReadZInt32(BufferStream stream)
	{
		uint num = ReadUInt32(stream);
		return (int)(num >> 1) ^ ((int)(num << 31) >> 31);
	}

	public static void WriteZInt32(BufferStream stream, int val)
	{
		WriteUInt32(stream, (uint)((val << 1) ^ (val >> 31)));
	}

	public static uint ReadUInt32(BufferStream stream)
	{
		uint num = 0u;
		for (int i = 0; i < 5; i++)
		{
			int num2 = stream.ReadByte();
			if (num2 < 0)
			{
				throw new IOException("Stream ended too early");
			}
			if (i == 4 && (num2 & 0xF0) != 0)
			{
				throw new ProtocolBufferException("Got larger VarInt than 32bit unsigned");
			}
			if ((num2 & 0x80) == 0)
			{
				return num | (uint)(num2 << 7 * i);
			}
			num |= (uint)((num2 & 0x7F) << 7 * i);
		}
		throw new ProtocolBufferException("Got larger VarInt than 32bit unsigned");
	}

	public static void WriteUInt32(BufferStream stream, uint val)
	{
		byte b;
		while (true)
		{
			b = (byte)(val & 0x7F);
			val >>= 7;
			if (val == 0)
			{
				break;
			}
			b |= 0x80;
			stream.WriteByte(b);
		}
		stream.WriteByte(b);
	}

	public static uint ReadUInt32(Stream stream)
	{
		uint num = 0u;
		for (int i = 0; i < 5; i++)
		{
			int num2 = stream.ReadByte();
			if (num2 < 0)
			{
				throw new IOException("Stream ended too early");
			}
			if (i == 4 && (num2 & 0xF0) != 0)
			{
				throw new ProtocolBufferException("Got larger VarInt than 32bit unsigned");
			}
			if ((num2 & 0x80) == 0)
			{
				return num | (uint)(num2 << 7 * i);
			}
			num |= (uint)((num2 & 0x7F) << 7 * i);
		}
		throw new ProtocolBufferException("Got larger VarInt than 32bit unsigned");
	}

	public static void WriteUInt32(Stream stream, uint val)
	{
		byte b;
		while (true)
		{
			b = (byte)(val & 0x7F);
			val >>= 7;
			if (val == 0)
			{
				break;
			}
			b |= 0x80;
			stream.WriteByte(b);
		}
		stream.WriteByte(b);
	}

	public static long ReadZInt64(BufferStream stream)
	{
		ulong num = ReadUInt64(stream);
		return (long)(num >> 1) ^ ((long)(num << 63) >> 63);
	}

	public static void WriteZInt64(BufferStream stream, long val)
	{
		WriteUInt64(stream, (ulong)((val << 1) ^ (val >> 63)));
	}

	public static ulong ReadUInt64(BufferStream stream)
	{
		ulong num = 0uL;
		for (int i = 0; i < 10; i++)
		{
			int num2 = stream.ReadByte();
			if (num2 < 0)
			{
				throw new IOException("Stream ended too early");
			}
			if (i == 9 && (num2 & 0xFE) != 0)
			{
				throw new ProtocolBufferException("Got larger VarInt than 64 bit unsigned");
			}
			if ((num2 & 0x80) == 0)
			{
				return num | (ulong)((long)num2 << 7 * i);
			}
			num |= (ulong)((long)(num2 & 0x7F) << 7 * i);
		}
		throw new ProtocolBufferException("Got larger VarInt than 64 bit unsigned");
	}

	public static void WriteUInt64(BufferStream stream, ulong val)
	{
		byte b;
		while (true)
		{
			b = (byte)(val & 0x7F);
			val >>= 7;
			if (val == 0L)
			{
				break;
			}
			b |= 0x80;
			stream.WriteByte(b);
		}
		stream.WriteByte(b);
	}

	public static ulong ReadUInt64(Span<byte> array, int pos, out int length)
	{
		ulong num = 0uL;
		length = 0;
		for (int i = 0; i < 10; i++)
		{
			length++;
			int num2 = array[pos++];
			if (num2 < 0)
			{
				throw new IOException("Stream ended too early");
			}
			if (i == 9 && (num2 & 0xFE) != 0)
			{
				throw new ProtocolBufferException("Got larger VarInt than 64 bit unsigned");
			}
			if ((num2 & 0x80) == 0)
			{
				return num | (ulong)((long)num2 << 7 * i);
			}
			num |= (ulong)((long)(num2 & 0x7F) << 7 * i);
		}
		throw new ProtocolBufferException("Got larger VarInt than 64 bit unsigned");
	}

	public static int WriteUInt64(ulong val, Span<byte> buffer, int pos)
	{
		int num = 0;
		byte b;
		while (true)
		{
			num++;
			b = (byte)(val & 0x7F);
			val >>= 7;
			if (val == 0L)
			{
				break;
			}
			b |= 0x80;
			buffer[pos++] = b;
		}
		buffer[pos] = b;
		return num;
	}

	public static bool ReadBool(BufferStream stream)
	{
		int num = stream.ReadByte();
		if (num < 0)
		{
			throw new IOException("Stream ended too early");
		}
		return num switch
		{
			1 => true, 
			0 => false, 
			_ => throw new ProtocolBufferException("Invalid boolean value"), 
		};
	}

	public static void WriteBool(BufferStream stream, bool val)
	{
		stream.WriteByte((byte)(val ? 1 : 0));
	}
}


using System;

public class ProtocolBufferException : Exception
{
	public ProtocolBufferException(string message)
		: base(message)
	{
	}
}


public enum Wire
{
	Varint = 0,
	Fixed64 = 1,
	LengthDelimited = 2,
	Fixed32 = 5
}


using SilentOrbit.ProtocolBuffers;

public struct Key
{
	public uint Field { get; set; }

	public Wire WireType { get; set; }

	public Key(uint field, Wire wireType)
	{
		Field = field;
		WireType = wireType;
	}

	public override string ToString()
	{
		return $"[Key: {Field}, {WireType}]";
	}
}


using System.IO;
using Facepunch.Nexus;
using SilentOrbit.ProtocolBuffers;

public class UuidSerialized
{
	public static void ResetToPool(Uuid instance)
	{
		((Uuid)(ref instance)).NodeId = 0;
		((Uuid)(ref instance)).Sequence = 0;
		((Uuid)(ref instance)).Timestamp = 0uL;
	}

	public static Uuid Deserialize(BufferStream stream, ref Uuid instance, bool isDelta)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				((Uuid)(ref instance)).NodeId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				((Uuid)(ref instance)).Sequence = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				((Uuid)(ref instance)).Timestamp = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Uuid DeserializeLengthDelimited(BufferStream stream, ref Uuid instance, bool isDelta)
	{
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				((Uuid)(ref instance)).NodeId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				((Uuid)(ref instance)).Sequence = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				((Uuid)(ref instance)).Timestamp = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Uuid DeserializeLength(BufferStream stream, int length, ref Uuid instance, bool isDelta)
	{
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				((Uuid)(ref instance)).NodeId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				((Uuid)(ref instance)).Sequence = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				((Uuid)(ref instance)).Timestamp = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Uuid instance, Uuid previous)
	{
		if (((Uuid)(ref instance)).NodeId != ((Uuid)(ref previous)).NodeId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)((Uuid)(ref instance)).NodeId);
		}
		if (((Uuid)(ref instance)).Sequence != ((Uuid)(ref previous)).Sequence)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)((Uuid)(ref instance)).Sequence);
		}
		if (((Uuid)(ref instance)).Timestamp != ((Uuid)(ref previous)).Timestamp)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, ((Uuid)(ref instance)).Timestamp);
		}
	}

	public static void Serialize(BufferStream stream, Uuid instance)
	{
		if (((Uuid)(ref instance)).NodeId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)((Uuid)(ref instance)).NodeId);
		}
		if (((Uuid)(ref instance)).Sequence != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)((Uuid)(ref instance)).Sequence);
		}
		if (((Uuid)(ref instance)).Timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, ((Uuid)(ref instance)).Timestamp);
		}
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System.IO;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Vector3Serialized
{
	public static void ResetToPool(Vector3 instance)
	{
		instance.x = 0f;
		instance.y = 0f;
		instance.z = 0f;
	}

	public static Vector3 Deserialize(BufferStream stream, ref Vector3 instance, bool isDelta)
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.z = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Vector3 DeserializeLengthDelimited(BufferStream stream, ref Vector3 instance, bool isDelta)
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.z = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Vector3 DeserializeLength(BufferStream stream, int length, ref Vector3 instance, bool isDelta)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.z = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Vector3 instance, Vector3 previous)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.x != previous.x)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != previous.z)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
	}

	public static void Serialize(BufferStream stream, Vector3 instance)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (instance.x != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class RaySerialized
{
	public static void ResetToPool(Ray instance)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		((Ray)(ref instance)).origin = default(Vector3);
		((Ray)(ref instance)).direction = default(Vector3);
	}

	public static Ray Deserialize(BufferStream stream, ref Ray instance, bool isDelta)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance3 = ((Ray)(ref instance)).origin;
				((Ray)(ref instance)).origin = Vector3Serialized.DeserializeLengthDelimited(stream, ref instance3, isDelta);
				break;
			}
			case 18:
			{
				Vector3 instance2 = ((Ray)(ref instance)).direction;
				((Ray)(ref instance)).direction = Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Ray DeserializeLengthDelimited(BufferStream stream, ref Ray instance, bool isDelta)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance3 = ((Ray)(ref instance)).origin;
				((Ray)(ref instance)).origin = Vector3Serialized.DeserializeLengthDelimited(stream, ref instance3, isDelta);
				break;
			}
			case 18:
			{
				Vector3 instance2 = ((Ray)(ref instance)).direction;
				((Ray)(ref instance)).direction = Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Ray DeserializeLength(BufferStream stream, int length, ref Ray instance, bool isDelta)
	{
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance3 = ((Ray)(ref instance)).origin;
				((Ray)(ref instance)).origin = Vector3Serialized.DeserializeLengthDelimited(stream, ref instance3, isDelta);
				break;
			}
			case 18:
			{
				Vector3 instance2 = ((Ray)(ref instance)).direction;
				((Ray)(ref instance)).direction = Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Ray instance, Ray previous)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (((Ray)(ref instance)).origin != ((Ray)(ref previous)).origin)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, ((Ray)(ref instance)).origin, ((Ray)(ref previous)).origin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (((Ray)(ref instance)).direction != ((Ray)(ref previous)).direction)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, ((Ray)(ref instance)).direction, ((Ray)(ref previous)).direction);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field direction (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, Ray instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		if (((Ray)(ref instance)).origin != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, ((Ray)(ref instance)).origin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (((Ray)(ref instance)).direction != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, ((Ray)(ref instance)).direction);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field direction (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System.IO;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Vector4Serialized
{
	public static void ResetToPool(Vector4 instance)
	{
		instance.x = 0f;
		instance.y = 0f;
		instance.z = 0f;
		instance.w = 0f;
	}

	public static Vector4 Deserialize(BufferStream stream, ref Vector4 instance, bool isDelta)
	{
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.z = 0f;
			instance.w = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.w = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Vector4 DeserializeLengthDelimited(BufferStream stream, ref Vector4 instance, bool isDelta)
	{
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.z = 0f;
			instance.w = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.w = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Vector4 DeserializeLength(BufferStream stream, int length, ref Vector4 instance, bool isDelta)
	{
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.z = 0f;
			instance.w = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.w = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Vector4 instance, Vector4 previous)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.x != previous.x)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != previous.z)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
		if (instance.w != previous.w)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.w);
		}
	}

	public static void Serialize(BufferStream stream, Vector4 instance)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (instance.x != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
		if (instance.w != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.w);
		}
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System.IO;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ColorSerialized
{
	public static void ResetToPool(Color instance)
	{
		instance.r = 0f;
		instance.g = 0f;
		instance.b = 0f;
		instance.a = 0f;
	}

	public static Color Deserialize(BufferStream stream, ref Color instance, bool isDelta)
	{
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.r = 0f;
			instance.g = 0f;
			instance.b = 0f;
			instance.a = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.r = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.g = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.b = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.a = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Color DeserializeLengthDelimited(BufferStream stream, ref Color instance, bool isDelta)
	{
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.r = 0f;
			instance.g = 0f;
			instance.b = 0f;
			instance.a = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.r = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.g = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.b = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.a = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Color DeserializeLength(BufferStream stream, int length, ref Color instance, bool isDelta)
	{
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.r = 0f;
			instance.g = 0f;
			instance.b = 0f;
			instance.a = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.r = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.g = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.b = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.a = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Color instance, Color previous)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.r != previous.r)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.r);
		}
		if (instance.g != previous.g)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.g);
		}
		if (instance.b != previous.b)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.b);
		}
		if (instance.a != previous.a)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.a);
		}
	}

	public static void Serialize(BufferStream stream, Color instance)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (instance.r != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.r);
		}
		if (instance.g != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.g);
		}
		if (instance.b != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.b);
		}
		if (instance.a != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.a);
		}
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System.IO;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Vector2Serialized
{
	public static void ResetToPool(Vector2 instance)
	{
		instance.x = 0f;
		instance.y = 0f;
	}

	public static Vector2 Deserialize(BufferStream stream, ref Vector2 instance, bool isDelta)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Vector2 DeserializeLengthDelimited(BufferStream stream, ref Vector2 instance, bool isDelta)
	{
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Vector2 DeserializeLength(BufferStream stream, int length, ref Vector2 instance, bool isDelta)
	{
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Vector2 instance, Vector2 previous)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		if (instance.x != previous.x)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
	}

	public static void Serialize(BufferStream stream, Vector2 instance)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (instance.x != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AIDesign : IDisposable, IPooled, IProto<AIDesign>, IProto
{
	[NonSerialized]
	public List<int> availableStates;

	[NonSerialized]
	public List<AIStateContainer> stateContainers;

	[NonSerialized]
	public int defaultStateContainer;

	[NonSerialized]
	public string description;

	[NonSerialized]
	public int scope;

	[NonSerialized]
	public int intialViewStateID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AIDesign instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.availableStates != null)
		{
			List<int> list = instance.availableStates;
			Pool.FreeUnmanaged<int>(ref list);
			instance.availableStates = list;
		}
		if (instance.stateContainers != null)
		{
			for (int i = 0; i < instance.stateContainers.Count; i++)
			{
				if (instance.stateContainers[i] != null)
				{
					instance.stateContainers[i].ResetToPool();
					instance.stateContainers[i] = null;
				}
			}
			List<AIStateContainer> list2 = instance.stateContainers;
			Pool.Free<AIStateContainer>(ref list2, false);
			instance.stateContainers = list2;
		}
		instance.defaultStateContainer = 0;
		instance.description = string.Empty;
		instance.scope = 0;
		instance.intialViewStateID = 0;
		Pool.Free<AIDesign>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AIDesign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AIDesign instance)
	{
		if (availableStates != null)
		{
			instance.availableStates = Pool.Get<List<int>>();
			for (int i = 0; i < availableStates.Count; i++)
			{
				int item = availableStates[i];
				instance.availableStates.Add(item);
			}
		}
		else
		{
			instance.availableStates = null;
		}
		if (stateContainers != null)
		{
			instance.stateContainers = Pool.Get<List<AIStateContainer>>();
			for (int j = 0; j < stateContainers.Count; j++)
			{
				AIStateContainer item2 = stateContainers[j].Copy();
				instance.stateContainers.Add(item2);
			}
		}
		else
		{
			instance.stateContainers = null;
		}
		instance.defaultStateContainer = defaultStateContainer;
		instance.description = description;
		instance.scope = scope;
		instance.intialViewStateID = intialViewStateID;
	}

	public AIDesign Copy()
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		CopyTo(aIDesign);
		return aIDesign;
	}

	public static AIDesign Deserialize(BufferStream stream)
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		Deserialize(stream, aIDesign, isDelta: false);
		return aIDesign;
	}

	public static AIDesign DeserializeLengthDelimited(BufferStream stream)
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		DeserializeLengthDelimited(stream, aIDesign, isDelta: false);
		return aIDesign;
	}

	public static AIDesign DeserializeLength(BufferStream stream, int length)
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		DeserializeLength(stream, length, aIDesign, isDelta: false);
		return aIDesign;
	}

	public static AIDesign Deserialize(byte[] buffer)
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, aIDesign, isDelta: false);
		return aIDesign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AIDesign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AIDesign Deserialize(BufferStream stream, AIDesign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.availableStates == null)
			{
				instance.availableStates = Pool.Get<List<int>>();
			}
			if (instance.stateContainers == null)
			{
				instance.stateContainers = Pool.Get<List<AIStateContainer>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.availableStates.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.stateContainers.Add(AIStateContainer.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.defaultStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.description = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.scope = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.intialViewStateID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AIDesign DeserializeLengthDelimited(BufferStream stream, AIDesign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.availableStates == null)
			{
				instance.availableStates = Pool.Get<List<int>>();
			}
			if (instance.stateContainers == null)
			{
				instance.stateContainers = Pool.Get<List<AIStateContainer>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.availableStates.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.stateContainers.Add(AIStateContainer.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.defaultStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.description = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.scope = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.intialViewStateID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AIDesign DeserializeLength(BufferStream stream, int length, AIDesign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.availableStates == null)
			{
				instance.availableStates = Pool.Get<List<int>>();
			}
			if (instance.stateContainers == null)
			{
				instance.stateContainers = Pool.Get<List<AIStateContainer>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.availableStates.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.stateContainers.Add(AIStateContainer.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.defaultStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.description = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.scope = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.intialViewStateID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AIDesign instance, AIDesign previous)
	{
		if (instance.availableStates != null)
		{
			for (int i = 0; i < instance.availableStates.Count; i++)
			{
				int num = instance.availableStates[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.stateContainers != null)
		{
			for (int j = 0; j < instance.stateContainers.Count; j++)
			{
				AIStateContainer aIStateContainer = instance.stateContainers[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				AIStateContainer.SerializeDelta(stream, aIStateContainer, aIStateContainer);
				int num2 = stream.Position - position;
				if (num2 > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stateContainers (ProtoBuf.AIStateContainer)");
				}
				Span<byte> span = range.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
				if (num3 < 3)
				{
					span[num3 - 1] |= 128;
					while (num3 < 2)
					{
						span[num3++] = 128;
					}
					span[2] = 0;
				}
			}
		}
		if (instance.defaultStateContainer != previous.defaultStateContainer)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.defaultStateContainer);
		}
		if (instance.description != null && instance.description != previous.description)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.description);
		}
		if (instance.scope != previous.scope)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scope);
		}
		if (instance.intialViewStateID != previous.intialViewStateID)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.intialViewStateID);
		}
	}

	public static void Serialize(BufferStream stream, AIDesign instance)
	{
		if (instance.availableStates != null)
		{
			for (int i = 0; i < instance.availableStates.Count; i++)
			{
				int num = instance.availableStates[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.stateContainers != null)
		{
			for (int j = 0; j < instance.stateContainers.Count; j++)
			{
				AIStateContainer instance2 = instance.stateContainers[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				AIStateContainer.Serialize(stream, instance2);
				int num2 = stream.Position - position;
				if (num2 > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stateContainers (ProtoBuf.AIStateContainer)");
				}
				Span<byte> span = range.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
				if (num3 < 3)
				{
					span[num3 - 1] |= 128;
					while (num3 < 2)
					{
						span[num3++] = 128;
					}
					span[2] = 0;
				}
			}
		}
		if (instance.defaultStateContainer != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.defaultStateContainer);
		}
		if (instance.description != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.description);
		}
		if (instance.scope != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scope);
		}
		if (instance.intialViewStateID != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.intialViewStateID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (stateContainers != null)
		{
			for (int i = 0; i < stateContainers.Count; i++)
			{
				stateContainers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AIStateContainer : IDisposable, IPooled, IProto<AIStateContainer>, IProto
{
	[NonSerialized]
	public int id;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public List<AIEventData> events;

	[NonSerialized]
	public int inputMemorySlot;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AIStateContainer instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.id = 0;
		instance.state = 0;
		if (instance.events != null)
		{
			for (int i = 0; i < instance.events.Count; i++)
			{
				if (instance.events[i] != null)
				{
					instance.events[i].ResetToPool();
					instance.events[i] = null;
				}
			}
			List<AIEventData> list = instance.events;
			Pool.Free<AIEventData>(ref list, false);
			instance.events = list;
		}
		instance.inputMemorySlot = 0;
		Pool.Free<AIStateContainer>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AIStateContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AIStateContainer instance)
	{
		instance.id = id;
		instance.state = state;
		if (events != null)
		{
			instance.events = Pool.Get<List<AIEventData>>();
			for (int i = 0; i < events.Count; i++)
			{
				AIEventData item = events[i].Copy();
				instance.events.Add(item);
			}
		}
		else
		{
			instance.events = null;
		}
		instance.inputMemorySlot = inputMemorySlot;
	}

	public AIStateContainer Copy()
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		CopyTo(aIStateContainer);
		return aIStateContainer;
	}

	public static AIStateContainer Deserialize(BufferStream stream)
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		Deserialize(stream, aIStateContainer, isDelta: false);
		return aIStateContainer;
	}

	public static AIStateContainer DeserializeLengthDelimited(BufferStream stream)
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		DeserializeLengthDelimited(stream, aIStateContainer, isDelta: false);
		return aIStateContainer;
	}

	public static AIStateContainer DeserializeLength(BufferStream stream, int length)
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		DeserializeLength(stream, length, aIStateContainer, isDelta: false);
		return aIStateContainer;
	}

	public static AIStateContainer Deserialize(byte[] buffer)
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, aIStateContainer, isDelta: false);
		return aIStateContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AIStateContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AIStateContainer Deserialize(BufferStream stream, AIStateContainer instance, bool isDelta)
	{
		if (!isDelta && instance.events == null)
		{
			instance.events = Pool.Get<List<AIEventData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.events.Add(AIEventData.DeserializeLengthDelimited(stream));
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AIStateContainer DeserializeLengthDelimited(BufferStream stream, AIStateContainer instance, bool isDelta)
	{
		if (!isDelta && instance.events == null)
		{
			instance.events = Pool.Get<List<AIEventData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.events.Add(AIEventData.DeserializeLengthDelimited(stream));
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AIStateContainer DeserializeLength(BufferStream stream, int length, AIStateContainer instance, bool isDelta)
	{
		if (!isDelta && instance.events == null)
		{
			instance.events = Pool.Get<List<AIEventData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.events.Add(AIEventData.DeserializeLengthDelimited(stream));
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AIStateContainer instance, AIStateContainer previous)
	{
		if (instance.id != previous.id)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.id);
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.events != null)
		{
			for (int i = 0; i < instance.events.Count; i++)
			{
				AIEventData aIEventData = instance.events[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(2);
				int position = stream.Position;
				AIEventData.SerializeDelta(stream, aIEventData, aIEventData);
				int num = stream.Position - position;
				if (num > 16383)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field events (ProtoBuf.AIEventData)");
				}
				Span<byte> span = range.GetSpan();
				if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
				{
					span[0] |= 128;
					span[1] = 0;
				}
			}
		}
		if (instance.inputMemorySlot != previous.inputMemorySlot)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputMemorySlot);
		}
	}

	public static void Serialize(BufferStream stream, AIStateContainer instance)
	{
		if (instance.id != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.id);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.events != null)
		{
			for (int i = 0; i < instance.events.Count; i++)
			{
				AIEventData instance2 = instance.events[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(2);
				int position = stream.Position;
				AIEventData.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 16383)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field events (ProtoBuf.AIEventData)");
				}
				Span<byte> span = range.GetSpan();
				if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
				{
					span[0] |= 128;
					span[1] = 0;
				}
			}
		}
		if (instance.inputMemorySlot != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputMemorySlot);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (events != null)
		{
			for (int i = 0; i < events.Count; i++)
			{
				events[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AIEventData : IDisposable, IPooled, IProto<AIEventData>, IProto
{
	[NonSerialized]
	public int eventType;

	[NonSerialized]
	public int triggerStateContainer;

	[NonSerialized]
	public bool inverted;

	[NonSerialized]
	public int inputMemorySlot;

	[NonSerialized]
	public int outputMemorySlot;

	[NonSerialized]
	public int id;

	[NonSerialized]
	public TimerAIEventData timerData;

	[NonSerialized]
	public PlayerDetectedAIEventData playerDetectedData;

	[NonSerialized]
	public HealthBelowAIEventData healthBelowData;

	[NonSerialized]
	public InRangeAIEventData inRangeData;

	[NonSerialized]
	public HungerAboveAIEventData hungerAboveData;

	[NonSerialized]
	public TirednessAboveAIEventData tirednessAboveData;

	[NonSerialized]
	public ThreatDetectedAIEventData threatDetectedData;

	[NonSerialized]
	public TargetDetectedAIEventData targetDetectedData;

	[NonSerialized]
	public AmmoBelowAIEventData ammoBelowData;

	[NonSerialized]
	public ChanceAIEventData chanceData;

	[NonSerialized]
	public TimeSinceThreatAIEventData timeSinceThreatData;

	[NonSerialized]
	public AggressionTimerAIEventData aggressionTimerData;

	[NonSerialized]
	public InRangeOfHomeAIEventData inRangeOfHomeData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.eventType = 0;
			instance.triggerStateContainer = 0;
			instance.inverted = false;
			instance.inputMemorySlot = 0;
			instance.outputMemorySlot = 0;
			instance.id = 0;
			if (instance.timerData != null)
			{
				instance.timerData.ResetToPool();
				instance.timerData = null;
			}
			if (instance.playerDetectedData != null)
			{
				instance.playerDetectedData.ResetToPool();
				instance.playerDetectedData = null;
			}
			if (instance.healthBelowData != null)
			{
				instance.healthBelowData.ResetToPool();
				instance.healthBelowData = null;
			}
			if (instance.inRangeData != null)
			{
				instance.inRangeData.ResetToPool();
				instance.inRangeData = null;
			}
			if (instance.hungerAboveData != null)
			{
				instance.hungerAboveData.ResetToPool();
				instance.hungerAboveData = null;
			}
			if (instance.tirednessAboveData != null)
			{
				instance.tirednessAboveData.ResetToPool();
				instance.tirednessAboveData = null;
			}
			if (instance.threatDetectedData != null)
			{
				instance.threatDetectedData.ResetToPool();
				instance.threatDetectedData = null;
			}
			if (instance.targetDetectedData != null)
			{
				instance.targetDetectedData.ResetToPool();
				instance.targetDetectedData = null;
			}
			if (instance.ammoBelowData != null)
			{
				instance.ammoBelowData.ResetToPool();
				instance.ammoBelowData = null;
			}
			if (instance.chanceData != null)
			{
				instance.chanceData.ResetToPool();
				instance.chanceData = null;
			}
			if (instance.timeSinceThreatData != null)
			{
				instance.timeSinceThreatData.ResetToPool();
				instance.timeSinceThreatData = null;
			}
			if (instance.aggressionTimerData != null)
			{
				instance.aggressionTimerData.ResetToPool();
				instance.aggressionTimerData = null;
			}
			if (instance.inRangeOfHomeData != null)
			{
				instance.inRangeOfHomeData.ResetToPool();
				instance.inRangeOfHomeData = null;
			}
			Pool.Free<AIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AIEventData instance)
	{
		instance.eventType = eventType;
		instance.triggerStateContainer = triggerStateContainer;
		instance.inverted = inverted;
		instance.inputMemorySlot = inputMemorySlot;
		instance.outputMemorySlot = outputMemorySlot;
		instance.id = id;
		if (timerData != null)
		{
			if (instance.timerData == null)
			{
				instance.timerData = timerData.Copy();
			}
			else
			{
				timerData.CopyTo(instance.timerData);
			}
		}
		else
		{
			instance.timerData = null;
		}
		if (playerDetectedData != null)
		{
			if (instance.playerDetectedData == null)
			{
				instance.playerDetectedData = playerDetectedData.Copy();
			}
			else
			{
				playerDetectedData.CopyTo(instance.playerDetectedData);
			}
		}
		else
		{
			instance.playerDetectedData = null;
		}
		if (healthBelowData != null)
		{
			if (instance.healthBelowData == null)
			{
				instance.healthBelowData = healthBelowData.Copy();
			}
			else
			{
				healthBelowData.CopyTo(instance.healthBelowData);
			}
		}
		else
		{
			instance.healthBelowData = null;
		}
		if (inRangeData != null)
		{
			if (instance.inRangeData == null)
			{
				instance.inRangeData = inRangeData.Copy();
			}
			else
			{
				inRangeData.CopyTo(instance.inRangeData);
			}
		}
		else
		{
			instance.inRangeData = null;
		}
		if (hungerAboveData != null)
		{
			if (instance.hungerAboveData == null)
			{
				instance.hungerAboveData = hungerAboveData.Copy();
			}
			else
			{
				hungerAboveData.CopyTo(instance.hungerAboveData);
			}
		}
		else
		{
			instance.hungerAboveData = null;
		}
		if (tirednessAboveData != null)
		{
			if (instance.tirednessAboveData == null)
			{
				instance.tirednessAboveData = tirednessAboveData.Copy();
			}
			else
			{
				tirednessAboveData.CopyTo(instance.tirednessAboveData);
			}
		}
		else
		{
			instance.tirednessAboveData = null;
		}
		if (threatDetectedData != null)
		{
			if (instance.threatDetectedData == null)
			{
				instance.threatDetectedData = threatDetectedData.Copy();
			}
			else
			{
				threatDetectedData.CopyTo(instance.threatDetectedData);
			}
		}
		else
		{
			instance.threatDetectedData = null;
		}
		if (targetDetectedData != null)
		{
			if (instance.targetDetectedData == null)
			{
				instance.targetDetectedData = targetDetectedData.Copy();
			}
			else
			{
				targetDetectedData.CopyTo(instance.targetDetectedData);
			}
		}
		else
		{
			instance.targetDetectedData = null;
		}
		if (ammoBelowData != null)
		{
			if (instance.ammoBelowData == null)
			{
				instance.ammoBelowData = ammoBelowData.Copy();
			}
			else
			{
				ammoBelowData.CopyTo(instance.ammoBelowData);
			}
		}
		else
		{
			instance.ammoBelowData = null;
		}
		if (chanceData != null)
		{
			if (instance.chanceData == null)
			{
				instance.chanceData = chanceData.Copy();
			}
			else
			{
				chanceData.CopyTo(instance.chanceData);
			}
		}
		else
		{
			instance.chanceData = null;
		}
		if (timeSinceThreatData != null)
		{
			if (instance.timeSinceThreatData == null)
			{
				instance.timeSinceThreatData = timeSinceThreatData.Copy();
			}
			else
			{
				timeSinceThreatData.CopyTo(instance.timeSinceThreatData);
			}
		}
		else
		{
			instance.timeSinceThreatData = null;
		}
		if (aggressionTimerData != null)
		{
			if (instance.aggressionTimerData == null)
			{
				instance.aggressionTimerData = aggressionTimerData.Copy();
			}
			else
			{
				aggressionTimerData.CopyTo(instance.aggressionTimerData);
			}
		}
		else
		{
			instance.aggressionTimerData = null;
		}
		if (inRangeOfHomeData != null)
		{
			if (instance.inRangeOfHomeData == null)
			{
				instance.inRangeOfHomeData = inRangeOfHomeData.Copy();
			}
			else
			{
				inRangeOfHomeData.CopyTo(instance.inRangeOfHomeData);
			}
		}
		else
		{
			instance.inRangeOfHomeData = null;
		}
	}

	public AIEventData Copy()
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		CopyTo(aIEventData);
		return aIEventData;
	}

	public static AIEventData Deserialize(BufferStream stream)
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		Deserialize(stream, aIEventData, isDelta: false);
		return aIEventData;
	}

	public static AIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		DeserializeLengthDelimited(stream, aIEventData, isDelta: false);
		return aIEventData;
	}

	public static AIEventData DeserializeLength(BufferStream stream, int length)
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		DeserializeLength(stream, length, aIEventData, isDelta: false);
		return aIEventData;
	}

	public static AIEventData Deserialize(byte[] buffer)
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, aIEventData, isDelta: false);
		return aIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AIEventData Deserialize(BufferStream stream, AIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.eventType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.triggerStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.inverted = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.outputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timerData == null)
					{
						instance.timerData = TimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimerAIEventData.DeserializeLengthDelimited(stream, instance.timerData, isDelta);
					}
				}
				break;
			case 101u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.playerDetectedData == null)
					{
						instance.playerDetectedData = PlayerDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerDetectedAIEventData.DeserializeLengthDelimited(stream, instance.playerDetectedData, isDelta);
					}
				}
				break;
			case 102u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.healthBelowData == null)
					{
						instance.healthBelowData = HealthBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HealthBelowAIEventData.DeserializeLengthDelimited(stream, instance.healthBelowData, isDelta);
					}
				}
				break;
			case 103u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeData == null)
					{
						instance.inRangeData = InRangeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeData, isDelta);
					}
				}
				break;
			case 104u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.hungerAboveData == null)
					{
						instance.hungerAboveData = HungerAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HungerAboveAIEventData.DeserializeLengthDelimited(stream, instance.hungerAboveData, isDelta);
					}
				}
				break;
			case 105u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.tirednessAboveData == null)
					{
						instance.tirednessAboveData = TirednessAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TirednessAboveAIEventData.DeserializeLengthDelimited(stream, instance.tirednessAboveData, isDelta);
					}
				}
				break;
			case 106u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.threatDetectedData == null)
					{
						instance.threatDetectedData = ThreatDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ThreatDetectedAIEventData.DeserializeLengthDelimited(stream, instance.threatDetectedData, isDelta);
					}
				}
				break;
			case 107u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.targetDetectedData == null)
					{
						instance.targetDetectedData = TargetDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TargetDetectedAIEventData.DeserializeLengthDelimited(stream, instance.targetDetectedData, isDelta);
					}
				}
				break;
			case 108u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.ammoBelowData == null)
					{
						instance.ammoBelowData = AmmoBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AmmoBelowAIEventData.DeserializeLengthDelimited(stream, instance.ammoBelowData, isDelta);
					}
				}
				break;
			case 109u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.chanceData == null)
					{
						instance.chanceData = ChanceAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ChanceAIEventData.DeserializeLengthDelimited(stream, instance.chanceData, isDelta);
					}
				}
				break;
			case 110u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timeSinceThreatData == null)
					{
						instance.timeSinceThreatData = TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream, instance.timeSinceThreatData, isDelta);
					}
				}
				break;
			case 111u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.aggressionTimerData == null)
					{
						instance.aggressionTimerData = AggressionTimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AggressionTimerAIEventData.DeserializeLengthDelimited(stream, instance.aggressionTimerData, isDelta);
					}
				}
				break;
			case 112u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeOfHomeData == null)
					{
						instance.inRangeOfHomeData = InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeOfHomeData, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static AIEventData DeserializeLengthDelimited(BufferStream stream, AIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.eventType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.triggerStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.inverted = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.outputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timerData == null)
					{
						instance.timerData = TimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimerAIEventData.DeserializeLengthDelimited(stream, instance.timerData, isDelta);
					}
				}
				break;
			case 101u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.playerDetectedData == null)
					{
						instance.playerDetectedData = PlayerDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerDetectedAIEventData.DeserializeLengthDelimited(stream, instance.playerDetectedData, isDelta);
					}
				}
				break;
			case 102u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.healthBelowData == null)
					{
						instance.healthBelowData = HealthBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HealthBelowAIEventData.DeserializeLengthDelimited(stream, instance.healthBelowData, isDelta);
					}
				}
				break;
			case 103u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeData == null)
					{
						instance.inRangeData = InRangeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeData, isDelta);
					}
				}
				break;
			case 104u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.hungerAboveData == null)
					{
						instance.hungerAboveData = HungerAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HungerAboveAIEventData.DeserializeLengthDelimited(stream, instance.hungerAboveData, isDelta);
					}
				}
				break;
			case 105u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.tirednessAboveData == null)
					{
						instance.tirednessAboveData = TirednessAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TirednessAboveAIEventData.DeserializeLengthDelimited(stream, instance.tirednessAboveData, isDelta);
					}
				}
				break;
			case 106u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.threatDetectedData == null)
					{
						instance.threatDetectedData = ThreatDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ThreatDetectedAIEventData.DeserializeLengthDelimited(stream, instance.threatDetectedData, isDelta);
					}
				}
				break;
			case 107u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.targetDetectedData == null)
					{
						instance.targetDetectedData = TargetDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TargetDetectedAIEventData.DeserializeLengthDelimited(stream, instance.targetDetectedData, isDelta);
					}
				}
				break;
			case 108u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.ammoBelowData == null)
					{
						instance.ammoBelowData = AmmoBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AmmoBelowAIEventData.DeserializeLengthDelimited(stream, instance.ammoBelowData, isDelta);
					}
				}
				break;
			case 109u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.chanceData == null)
					{
						instance.chanceData = ChanceAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ChanceAIEventData.DeserializeLengthDelimited(stream, instance.chanceData, isDelta);
					}
				}
				break;
			case 110u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timeSinceThreatData == null)
					{
						instance.timeSinceThreatData = TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream, instance.timeSinceThreatData, isDelta);
					}
				}
				break;
			case 111u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.aggressionTimerData == null)
					{
						instance.aggressionTimerData = AggressionTimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AggressionTimerAIEventData.DeserializeLengthDelimited(stream, instance.aggressionTimerData, isDelta);
					}
				}
				break;
			case 112u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeOfHomeData == null)
					{
						instance.inRangeOfHomeData = InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeOfHomeData, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AIEventData DeserializeLength(BufferStream stream, int length, AIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.eventType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.triggerStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.inverted = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.outputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timerData == null)
					{
						instance.timerData = TimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimerAIEventData.DeserializeLengthDelimited(stream, instance.timerData, isDelta);
					}
				}
				break;
			case 101u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.playerDetectedData == null)
					{
						instance.playerDetectedData = PlayerDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerDetectedAIEventData.DeserializeLengthDelimited(stream, instance.playerDetectedData, isDelta);
					}
				}
				break;
			case 102u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.healthBelowData == null)
					{
						instance.healthBelowData = HealthBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HealthBelowAIEventData.DeserializeLengthDelimited(stream, instance.healthBelowData, isDelta);
					}
				}
				break;
			case 103u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeData == null)
					{
						instance.inRangeData = InRangeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeData, isDelta);
					}
				}
				break;
			case 104u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.hungerAboveData == null)
					{
						instance.hungerAboveData = HungerAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HungerAboveAIEventData.DeserializeLengthDelimited(stream, instance.hungerAboveData, isDelta);
					}
				}
				break;
			case 105u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.tirednessAboveData == null)
					{
						instance.tirednessAboveData = TirednessAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TirednessAboveAIEventData.DeserializeLengthDelimited(stream, instance.tirednessAboveData, isDelta);
					}
				}
				break;
			case 106u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.threatDetectedData == null)
					{
						instance.threatDetectedData = ThreatDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ThreatDetectedAIEventData.DeserializeLengthDelimited(stream, instance.threatDetectedData, isDelta);
					}
				}
				break;
			case 107u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.targetDetectedData == null)
					{
						instance.targetDetectedData = TargetDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TargetDetectedAIEventData.DeserializeLengthDelimited(stream, instance.targetDetectedData, isDelta);
					}
				}
				break;
			case 108u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.ammoBelowData == null)
					{
						instance.ammoBelowData = AmmoBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AmmoBelowAIEventData.DeserializeLengthDelimited(stream, instance.ammoBelowData, isDelta);
					}
				}
				break;
			case 109u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.chanceData == null)
					{
						instance.chanceData = ChanceAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ChanceAIEventData.DeserializeLengthDelimited(stream, instance.chanceData, isDelta);
					}
				}
				break;
			case 110u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timeSinceThreatData == null)
					{
						instance.timeSinceThreatData = TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream, instance.timeSinceThreatData, isDelta);
					}
				}
				break;
			case 111u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.aggressionTimerData == null)
					{
						instance.aggressionTimerData = AggressionTimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AggressionTimerAIEventData.DeserializeLengthDelimited(stream, instance.aggressionTimerData, isDelta);
					}
				}
				break;
			case 112u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeOfHomeData == null)
					{
						instance.inRangeOfHomeData = InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeOfHomeData, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AIEventData instance, AIEventData previous)
	{
		if (instance.eventType != previous.eventType)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.eventType);
		}
		if (instance.triggerStateContainer != previous.triggerStateContainer)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.triggerStateContainer);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.inverted);
		if (instance.inputMemorySlot != previous.inputMemorySlot)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputMemorySlot);
		}
		if (instance.outputMemorySlot != previous.outputMemorySlot)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.outputMemorySlot);
		}
		if (instance.id != previous.id)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.id);
		}
		if (instance.timerData != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(6);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			TimerAIEventData.SerializeDelta(stream, instance.timerData, previous.timerData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field timerData (ProtoBuf.TimerAIEventData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.playerDetectedData != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(6);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PlayerDetectedAIEventData.SerializeDelta(stream, instance.playerDetectedData, previous.playerDetectedData);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerDetectedData (ProtoBuf.PlayerDetectedAIEventData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.healthBelowData != null)
		{
			stream.WriteByte(178);
			stream.WriteByte(6);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			HealthBelowAIEventData.SerializeDelta(stream, instance.healthBelowData, previous.healthBelowData);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field healthBelowData (ProtoBuf.HealthBelowAIEventData)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.inRangeData != null)
		{
			stream.WriteByte(186);
			stream.WriteByte(6);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			InRangeAIEventData.SerializeDelta(stream, instance.inRangeData, previous.inRangeData);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inRangeData (ProtoBuf.InRangeAIEventData)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.hungerAboveData != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(6);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			HungerAboveAIEventData.SerializeDelta(stream, instance.hungerAboveData, previous.hungerAboveData);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hungerAboveData (ProtoBuf.HungerAboveAIEventData)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.tirednessAboveData != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(6);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			TirednessAboveAIEventData.SerializeDelta(stream, instance.tirednessAboveData, previous.tirednessAboveData);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field tirednessAboveData (ProtoBuf.TirednessAboveAIEventData)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.threatDetectedData != null)
		{
			stream.WriteByte(210);
			stream.WriteByte(6);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			ThreatDetectedAIEventData.SerializeDelta(stream, instance.threatDetectedData, previous.threatDetectedData);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field threatDetectedData (ProtoBuf.ThreatDetectedAIEventData)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.targetDetectedData != null)
		{
			stream.WriteByte(218);
			stream.WriteByte(6);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			TargetDetectedAIEventData.SerializeDelta(stream, instance.targetDetectedData, previous.targetDetectedData);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetDetectedData (ProtoBuf.TargetDetectedAIEventData)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
		if (instance.ammoBelowData != null)
		{
			stream.WriteByte(226);
			stream.WriteByte(6);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AmmoBelowAIEventData.SerializeDelta(stream, instance.ammoBelowData, previous.ammoBelowData);
			int num9 = stream.Position - position9;
			if (num9 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ammoBelowData (ProtoBuf.AmmoBelowAIEventData)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num9, span9, 0);
		}
		if (instance.chanceData != null)
		{
			stream.WriteByte(234);
			stream.WriteByte(6);
			BufferStream.RangeHandle range10 = stream.GetRange(1);
			int position10 = stream.Position;
			ChanceAIEventData.SerializeDelta(stream, instance.chanceData, previous.chanceData);
			int num10 = stream.Position - position10;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field chanceData (ProtoBuf.ChanceAIEventData)");
			}
			Span<byte> span10 = range10.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		}
		if (instance.timeSinceThreatData != null)
		{
			stream.WriteByte(242);
			stream.WriteByte(6);
			BufferStream.RangeHandle range11 = stream.GetRange(1);
			int position11 = stream.Position;
			TimeSinceThreatAIEventData.SerializeDelta(stream, instance.timeSinceThreatData, previous.timeSinceThreatData);
			int num11 = stream.Position - position11;
			if (num11 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field timeSinceThreatData (ProtoBuf.TimeSinceThreatAIEventData)");
			}
			Span<byte> span11 = range11.GetSpan();
			ProtocolParser.WriteUInt32((uint)num11, span11, 0);
		}
		if (instance.aggressionTimerData != null)
		{
			stream.WriteByte(250);
			stream.WriteByte(6);
			BufferStream.RangeHandle range12 = stream.GetRange(1);
			int position12 = stream.Position;
			AggressionTimerAIEventData.SerializeDelta(stream, instance.aggressionTimerData, previous.aggressionTimerData);
			int num12 = stream.Position - position12;
			if (num12 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aggressionTimerData (ProtoBuf.AggressionTimerAIEventData)");
			}
			Span<byte> span12 = range12.GetSpan();
			ProtocolParser.WriteUInt32((uint)num12, span12, 0);
		}
		if (instance.inRangeOfHomeData != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(7);
			BufferStream.RangeHandle range13 = stream.GetRange(1);
			int position13 = stream.Position;
			InRangeOfHomeAIEventData.SerializeDelta(stream, instance.inRangeOfHomeData, previous.inRangeOfHomeData);
			int num13 = stream.Position - position13;
			if (num13 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inRangeOfHomeData (ProtoBuf.InRangeOfHomeAIEventData)");
			}
			Span<byte> span13 = range13.GetSpan();
			ProtocolParser.WriteUInt32((uint)num13, span13, 0);
		}
	}

	public static void Serialize(BufferStream stream, AIEventData instance)
	{
		if (instance.eventType != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.eventType);
		}
		if (instance.triggerStateContainer != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.triggerStateContainer);
		}
		if (instance.inverted)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.inverted);
		}
		if (instance.inputMemorySlot != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputMemorySlot);
		}
		if (instance.outputMemorySlot != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.outputMemorySlot);
		}
		if (instance.id != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.id);
		}
		if (instance.timerData != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(6);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			TimerAIEventData.Serialize(stream, instance.timerData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field timerData (ProtoBuf.TimerAIEventData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.playerDetectedData != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(6);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PlayerDetectedAIEventData.Serialize(stream, instance.playerDetectedData);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerDetectedData (ProtoBuf.PlayerDetectedAIEventData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.healthBelowData != null)
		{
			stream.WriteByte(178);
			stream.WriteByte(6);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			HealthBelowAIEventData.Serialize(stream, instance.healthBelowData);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field healthBelowData (ProtoBuf.HealthBelowAIEventData)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.inRangeData != null)
		{
			stream.WriteByte(186);
			stream.WriteByte(6);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			InRangeAIEventData.Serialize(stream, instance.inRangeData);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inRangeData (ProtoBuf.InRangeAIEventData)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.hungerAboveData != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(6);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			HungerAboveAIEventData.Serialize(stream, instance.hungerAboveData);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hungerAboveData (ProtoBuf.HungerAboveAIEventData)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.tirednessAboveData != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(6);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			TirednessAboveAIEventData.Serialize(stream, instance.tirednessAboveData);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field tirednessAboveData (ProtoBuf.TirednessAboveAIEventData)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.threatDetectedData != null)
		{
			stream.WriteByte(210);
			stream.WriteByte(6);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			ThreatDetectedAIEventData.Serialize(stream, instance.threatDetectedData);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field threatDetectedData (ProtoBuf.ThreatDetectedAIEventData)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.targetDetectedData != null)
		{
			stream.WriteByte(218);
			stream.WriteByte(6);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			TargetDetectedAIEventData.Serialize(stream, instance.targetDetectedData);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetDetectedData (ProtoBuf.TargetDetectedAIEventData)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
		if (instance.ammoBelowData != null)
		{
			stream.WriteByte(226);
			stream.WriteByte(6);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AmmoBelowAIEventData.Serialize(stream, instance.ammoBelowData);
			int num9 = stream.Position - position9;
			if (num9 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ammoBelowData (ProtoBuf.AmmoBelowAIEventData)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num9, span9, 0);
		}
		if (instance.chanceData != null)
		{
			stream.WriteByte(234);
			stream.WriteByte(6);
			BufferStream.RangeHandle range10 = stream.GetRange(1);
			int position10 = stream.Position;
			ChanceAIEventData.Serialize(stream, instance.chanceData);
			int num10 = stream.Position - position10;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field chanceData (ProtoBuf.ChanceAIEventData)");
			}
			Span<byte> span10 = range10.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		}
		if (instance.timeSinceThreatData != null)
		{
			stream.WriteByte(242);
			stream.WriteByte(6);
			BufferStream.RangeHandle range11 = stream.GetRange(1);
			int position11 = stream.Position;
			TimeSinceThreatAIEventData.Serialize(stream, instance.timeSinceThreatData);
			int num11 = stream.Position - position11;
			if (num11 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field timeSinceThreatData (ProtoBuf.TimeSinceThreatAIEventData)");
			}
			Span<byte> span11 = range11.GetSpan();
			ProtocolParser.WriteUInt32((uint)num11, span11, 0);
		}
		if (instance.aggressionTimerData != null)
		{
			stream.WriteByte(250);
			stream.WriteByte(6);
			BufferStream.RangeHandle range12 = stream.GetRange(1);
			int position12 = stream.Position;
			AggressionTimerAIEventData.Serialize(stream, instance.aggressionTimerData);
			int num12 = stream.Position - position12;
			if (num12 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aggressionTimerData (ProtoBuf.AggressionTimerAIEventData)");
			}
			Span<byte> span12 = range12.GetSpan();
			ProtocolParser.WriteUInt32((uint)num12, span12, 0);
		}
		if (instance.inRangeOfHomeData != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(7);
			BufferStream.RangeHandle range13 = stream.GetRange(1);
			int position13 = stream.Position;
			InRangeOfHomeAIEventData.Serialize(stream, instance.inRangeOfHomeData);
			int num13 = stream.Position - position13;
			if (num13 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inRangeOfHomeData (ProtoBuf.InRangeOfHomeAIEventData)");
			}
			Span<byte> span13 = range13.GetSpan();
			ProtocolParser.WriteUInt32((uint)num13, span13, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		timerData?.InspectUids(action);
		playerDetectedData?.InspectUids(action);
		healthBelowData?.InspectUids(action);
		inRangeData?.InspectUids(action);
		hungerAboveData?.InspectUids(action);
		tirednessAboveData?.InspectUids(action);
		threatDetectedData?.InspectUids(action);
		targetDetectedData?.InspectUids(action);
		ammoBelowData?.InspectUids(action);
		chanceData?.InspectUids(action);
		timeSinceThreatData?.InspectUids(action);
		aggressionTimerData?.InspectUids(action);
		inRangeOfHomeData?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TimerAIEventData : IDisposable, IPooled, IProto<TimerAIEventData>, IProto
{
	[NonSerialized]
	public float duration;

	[NonSerialized]
	public float durationMax;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TimerAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.duration = 0f;
			instance.durationMax = 0f;
			Pool.Free<TimerAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TimerAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TimerAIEventData instance)
	{
		instance.duration = duration;
		instance.durationMax = durationMax;
	}

	public TimerAIEventData Copy()
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		CopyTo(timerAIEventData);
		return timerAIEventData;
	}

	public static TimerAIEventData Deserialize(BufferStream stream)
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		Deserialize(stream, timerAIEventData, isDelta: false);
		return timerAIEventData;
	}

	public static TimerAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		DeserializeLengthDelimited(stream, timerAIEventData, isDelta: false);
		return timerAIEventData;
	}

	public static TimerAIEventData DeserializeLength(BufferStream stream, int length)
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		DeserializeLength(stream, length, timerAIEventData, isDelta: false);
		return timerAIEventData;
	}

	public static TimerAIEventData Deserialize(byte[] buffer)
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, timerAIEventData, isDelta: false);
		return timerAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TimerAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TimerAIEventData Deserialize(BufferStream stream, TimerAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.durationMax = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TimerAIEventData DeserializeLengthDelimited(BufferStream stream, TimerAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.durationMax = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TimerAIEventData DeserializeLength(BufferStream stream, int length, TimerAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.durationMax = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TimerAIEventData instance, TimerAIEventData previous)
	{
		if (instance.duration != previous.duration)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
		if (instance.durationMax != previous.durationMax)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.durationMax);
		}
	}

	public static void Serialize(BufferStream stream, TimerAIEventData instance)
	{
		if (instance.duration != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
		if (instance.durationMax != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.durationMax);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerDetectedAIEventData : IDisposable, IPooled, IProto<PlayerDetectedAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerDetectedAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<PlayerDetectedAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerDetectedAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerDetectedAIEventData instance)
	{
		instance.range = range;
	}

	public PlayerDetectedAIEventData Copy()
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		CopyTo(playerDetectedAIEventData);
		return playerDetectedAIEventData;
	}

	public static PlayerDetectedAIEventData Deserialize(BufferStream stream)
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		Deserialize(stream, playerDetectedAIEventData, isDelta: false);
		return playerDetectedAIEventData;
	}

	public static PlayerDetectedAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		DeserializeLengthDelimited(stream, playerDetectedAIEventData, isDelta: false);
		return playerDetectedAIEventData;
	}

	public static PlayerDetectedAIEventData DeserializeLength(BufferStream stream, int length)
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		DeserializeLength(stream, length, playerDetectedAIEventData, isDelta: false);
		return playerDetectedAIEventData;
	}

	public static PlayerDetectedAIEventData Deserialize(byte[] buffer)
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerDetectedAIEventData, isDelta: false);
		return playerDetectedAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerDetectedAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerDetectedAIEventData Deserialize(BufferStream stream, PlayerDetectedAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerDetectedAIEventData DeserializeLengthDelimited(BufferStream stream, PlayerDetectedAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerDetectedAIEventData DeserializeLength(BufferStream stream, int length, PlayerDetectedAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerDetectedAIEventData instance, PlayerDetectedAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, PlayerDetectedAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class HealthBelowAIEventData : IDisposable, IPooled, IProto<HealthBelowAIEventData>, IProto
{
	[NonSerialized]
	public float healthFraction;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(HealthBelowAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.healthFraction = 0f;
			Pool.Free<HealthBelowAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose HealthBelowAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(HealthBelowAIEventData instance)
	{
		instance.healthFraction = healthFraction;
	}

	public HealthBelowAIEventData Copy()
	{
		HealthBelowAIEventData healthBelowAIEventData = Pool.Get<HealthBelowAIEventData>();
		CopyTo(healthBelowAIEventData);
		return healthBelowAIEventData;
	}

	public static HealthBelowAIEventData Deserialize(BufferStream stream)
	{
		HealthBelowAIEventData healthBelowAIEventData = Pool.Get<HealthBelowAIEventData>();
		Deserialize(stream, healthBelowAIEventData, isDelta: false);
		return healthBelowAIEventData;
	}

	public static HealthBelowAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		HealthBelowAIEventData healthBelowAIEventData = Pool.Get<HealthBelowAIEventData>();
		DeserializeLengthDelimited(stream, healthBelowAIEventData, isDelta: false);
		return healthBelowAIEventData;
	}

	public static HealthBelowAIEventData DeserializeLength(BufferStream stream, int length)
	{
		HealthBelowAIEventData healthBelowAIEventData = Pool.Get<HealthBelowAIEventData>();
		DeserializeLength(stream, length, healthBelowAIEventData, isDelta: false);
		return healthBelowAIEventData;
	}

	public static HealthBelowAIEventData Deserialize(byte[] buffer)
	{
		HealthBelowAIEventData healthBelowAIEventData = Pool.Get<HealthBelowAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, healthBelowAIEventData, isDelta: false);
		return healthBelowAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, HealthBelowAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static HealthBelowAIEventData Deserialize(BufferStream stream, HealthBelowAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static HealthBelowAIEventData DeserializeLengthDelimited(BufferStream stream, HealthBelowAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static HealthBelowAIEventData DeserializeLength(BufferStream stream, int length, HealthBelowAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, HealthBelowAIEventData instance, HealthBelowAIEventData previous)
	{
		if (instance.healthFraction != previous.healthFraction)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.healthFraction);
		}
	}

	public static void Serialize(BufferStream stream, HealthBelowAIEventData instance)
	{
		if (instance.healthFraction != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.healthFraction);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class InRangeAIEventData : IDisposable, IPooled, IProto<InRangeAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InRangeAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<InRangeAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InRangeAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InRangeAIEventData instance)
	{
		instance.range = range;
	}

	public InRangeAIEventData Copy()
	{
		InRangeAIEventData inRangeAIEventData = Pool.Get<InRangeAIEventData>();
		CopyTo(inRangeAIEventData);
		return inRangeAIEventData;
	}

	public static InRangeAIEventData Deserialize(BufferStream stream)
	{
		InRangeAIEventData inRangeAIEventData = Pool.Get<InRangeAIEventData>();
		Deserialize(stream, inRangeAIEventData, isDelta: false);
		return inRangeAIEventData;
	}

	public static InRangeAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		InRangeAIEventData inRangeAIEventData = Pool.Get<InRangeAIEventData>();
		DeserializeLengthDelimited(stream, inRangeAIEventData, isDelta: false);
		return inRangeAIEventData;
	}

	public static InRangeAIEventData DeserializeLength(BufferStream stream, int length)
	{
		InRangeAIEventData inRangeAIEventData = Pool.Get<InRangeAIEventData>();
		DeserializeLength(stream, length, inRangeAIEventData, isDelta: false);
		return inRangeAIEventData;
	}

	public static InRangeAIEventData Deserialize(byte[] buffer)
	{
		InRangeAIEventData inRangeAIEventData = Pool.Get<InRangeAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, inRangeAIEventData, isDelta: false);
		return inRangeAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InRangeAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InRangeAIEventData Deserialize(BufferStream stream, InRangeAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InRangeAIEventData DeserializeLengthDelimited(BufferStream stream, InRangeAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InRangeAIEventData DeserializeLength(BufferStream stream, int length, InRangeAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InRangeAIEventData instance, InRangeAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, InRangeAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class HungerAboveAIEventData : IDisposable, IPooled, IProto<HungerAboveAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(HungerAboveAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<HungerAboveAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose HungerAboveAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(HungerAboveAIEventData instance)
	{
		instance.value = value;
	}

	public HungerAboveAIEventData Copy()
	{
		HungerAboveAIEventData hungerAboveAIEventData = Pool.Get<HungerAboveAIEventData>();
		CopyTo(hungerAboveAIEventData);
		return hungerAboveAIEventData;
	}

	public static HungerAboveAIEventData Deserialize(BufferStream stream)
	{
		HungerAboveAIEventData hungerAboveAIEventData = Pool.Get<HungerAboveAIEventData>();
		Deserialize(stream, hungerAboveAIEventData, isDelta: false);
		return hungerAboveAIEventData;
	}

	public static HungerAboveAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		HungerAboveAIEventData hungerAboveAIEventData = Pool.Get<HungerAboveAIEventData>();
		DeserializeLengthDelimited(stream, hungerAboveAIEventData, isDelta: false);
		return hungerAboveAIEventData;
	}

	public static HungerAboveAIEventData DeserializeLength(BufferStream stream, int length)
	{
		HungerAboveAIEventData hungerAboveAIEventData = Pool.Get<HungerAboveAIEventData>();
		DeserializeLength(stream, length, hungerAboveAIEventData, isDelta: false);
		return hungerAboveAIEventData;
	}

	public static HungerAboveAIEventData Deserialize(byte[] buffer)
	{
		HungerAboveAIEventData hungerAboveAIEventData = Pool.Get<HungerAboveAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, hungerAboveAIEventData, isDelta: false);
		return hungerAboveAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, HungerAboveAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static HungerAboveAIEventData Deserialize(BufferStream stream, HungerAboveAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static HungerAboveAIEventData DeserializeLengthDelimited(BufferStream stream, HungerAboveAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static HungerAboveAIEventData DeserializeLength(BufferStream stream, int length, HungerAboveAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, HungerAboveAIEventData instance, HungerAboveAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, HungerAboveAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TirednessAboveAIEventData : IDisposable, IPooled, IProto<TirednessAboveAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TirednessAboveAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<TirednessAboveAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TirednessAboveAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TirednessAboveAIEventData instance)
	{
		instance.value = value;
	}

	public TirednessAboveAIEventData Copy()
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		CopyTo(tirednessAboveAIEventData);
		return tirednessAboveAIEventData;
	}

	public static TirednessAboveAIEventData Deserialize(BufferStream stream)
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		Deserialize(stream, tirednessAboveAIEventData, isDelta: false);
		return tirednessAboveAIEventData;
	}

	public static TirednessAboveAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		DeserializeLengthDelimited(stream, tirednessAboveAIEventData, isDelta: false);
		return tirednessAboveAIEventData;
	}

	public static TirednessAboveAIEventData DeserializeLength(BufferStream stream, int length)
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		DeserializeLength(stream, length, tirednessAboveAIEventData, isDelta: false);
		return tirednessAboveAIEventData;
	}

	public static TirednessAboveAIEventData Deserialize(byte[] buffer)
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, tirednessAboveAIEventData, isDelta: false);
		return tirednessAboveAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TirednessAboveAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TirednessAboveAIEventData Deserialize(BufferStream stream, TirednessAboveAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TirednessAboveAIEventData DeserializeLengthDelimited(BufferStream stream, TirednessAboveAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TirednessAboveAIEventData DeserializeLength(BufferStream stream, int length, TirednessAboveAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TirednessAboveAIEventData instance, TirednessAboveAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, TirednessAboveAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AmmoBelowAIEventData : IDisposable, IPooled, IProto<AmmoBelowAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AmmoBelowAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<AmmoBelowAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AmmoBelowAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AmmoBelowAIEventData instance)
	{
		instance.value = value;
	}

	public AmmoBelowAIEventData Copy()
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		CopyTo(ammoBelowAIEventData);
		return ammoBelowAIEventData;
	}

	public static AmmoBelowAIEventData Deserialize(BufferStream stream)
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		Deserialize(stream, ammoBelowAIEventData, isDelta: false);
		return ammoBelowAIEventData;
	}

	public static AmmoBelowAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		DeserializeLengthDelimited(stream, ammoBelowAIEventData, isDelta: false);
		return ammoBelowAIEventData;
	}

	public static AmmoBelowAIEventData DeserializeLength(BufferStream stream, int length)
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		DeserializeLength(stream, length, ammoBelowAIEventData, isDelta: false);
		return ammoBelowAIEventData;
	}

	public static AmmoBelowAIEventData Deserialize(byte[] buffer)
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ammoBelowAIEventData, isDelta: false);
		return ammoBelowAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AmmoBelowAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AmmoBelowAIEventData Deserialize(BufferStream stream, AmmoBelowAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AmmoBelowAIEventData DeserializeLengthDelimited(BufferStream stream, AmmoBelowAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AmmoBelowAIEventData DeserializeLength(BufferStream stream, int length, AmmoBelowAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AmmoBelowAIEventData instance, AmmoBelowAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, AmmoBelowAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ThreatDetectedAIEventData : IDisposable, IPooled, IProto<ThreatDetectedAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ThreatDetectedAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<ThreatDetectedAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ThreatDetectedAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ThreatDetectedAIEventData instance)
	{
		instance.range = range;
	}

	public ThreatDetectedAIEventData Copy()
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		CopyTo(threatDetectedAIEventData);
		return threatDetectedAIEventData;
	}

	public static ThreatDetectedAIEventData Deserialize(BufferStream stream)
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		Deserialize(stream, threatDetectedAIEventData, isDelta: false);
		return threatDetectedAIEventData;
	}

	public static ThreatDetectedAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		DeserializeLengthDelimited(stream, threatDetectedAIEventData, isDelta: false);
		return threatDetectedAIEventData;
	}

	public static ThreatDetectedAIEventData DeserializeLength(BufferStream stream, int length)
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		DeserializeLength(stream, length, threatDetectedAIEventData, isDelta: false);
		return threatDetectedAIEventData;
	}

	public static ThreatDetectedAIEventData Deserialize(byte[] buffer)
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, threatDetectedAIEventData, isDelta: false);
		return threatDetectedAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ThreatDetectedAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ThreatDetectedAIEventData Deserialize(BufferStream stream, ThreatDetectedAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ThreatDetectedAIEventData DeserializeLengthDelimited(BufferStream stream, ThreatDetectedAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ThreatDetectedAIEventData DeserializeLength(BufferStream stream, int length, ThreatDetectedAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ThreatDetectedAIEventData instance, ThreatDetectedAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, ThreatDetectedAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TargetDetectedAIEventData : IDisposable, IPooled, IProto<TargetDetectedAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TargetDetectedAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<TargetDetectedAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TargetDetectedAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TargetDetectedAIEventData instance)
	{
		instance.range = range;
	}

	public TargetDetectedAIEventData Copy()
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		CopyTo(targetDetectedAIEventData);
		return targetDetectedAIEventData;
	}

	public static TargetDetectedAIEventData Deserialize(BufferStream stream)
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		Deserialize(stream, targetDetectedAIEventData, isDelta: false);
		return targetDetectedAIEventData;
	}

	public static TargetDetectedAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		DeserializeLengthDelimited(stream, targetDetectedAIEventData, isDelta: false);
		return targetDetectedAIEventData;
	}

	public static TargetDetectedAIEventData DeserializeLength(BufferStream stream, int length)
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		DeserializeLength(stream, length, targetDetectedAIEventData, isDelta: false);
		return targetDetectedAIEventData;
	}

	public static TargetDetectedAIEventData Deserialize(byte[] buffer)
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, targetDetectedAIEventData, isDelta: false);
		return targetDetectedAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TargetDetectedAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TargetDetectedAIEventData Deserialize(BufferStream stream, TargetDetectedAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TargetDetectedAIEventData DeserializeLengthDelimited(BufferStream stream, TargetDetectedAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TargetDetectedAIEventData DeserializeLength(BufferStream stream, int length, TargetDetectedAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TargetDetectedAIEventData instance, TargetDetectedAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, TargetDetectedAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ChanceAIEventData : IDisposable, IPooled, IProto<ChanceAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ChanceAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<ChanceAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ChanceAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ChanceAIEventData instance)
	{
		instance.value = value;
	}

	public ChanceAIEventData Copy()
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		CopyTo(chanceAIEventData);
		return chanceAIEventData;
	}

	public static ChanceAIEventData Deserialize(BufferStream stream)
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		Deserialize(stream, chanceAIEventData, isDelta: false);
		return chanceAIEventData;
	}

	public static ChanceAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		DeserializeLengthDelimited(stream, chanceAIEventData, isDelta: false);
		return chanceAIEventData;
	}

	public static ChanceAIEventData DeserializeLength(BufferStream stream, int length)
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		DeserializeLength(stream, length, chanceAIEventData, isDelta: false);
		return chanceAIEventData;
	}

	public static ChanceAIEventData Deserialize(byte[] buffer)
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, chanceAIEventData, isDelta: false);
		return chanceAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ChanceAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ChanceAIEventData Deserialize(BufferStream stream, ChanceAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ChanceAIEventData DeserializeLengthDelimited(BufferStream stream, ChanceAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ChanceAIEventData DeserializeLength(BufferStream stream, int length, ChanceAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ChanceAIEventData instance, ChanceAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, ChanceAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TimeSinceThreatAIEventData : IDisposable, IPooled, IProto<TimeSinceThreatAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TimeSinceThreatAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<TimeSinceThreatAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TimeSinceThreatAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TimeSinceThreatAIEventData instance)
	{
		instance.value = value;
	}

	public TimeSinceThreatAIEventData Copy()
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		CopyTo(timeSinceThreatAIEventData);
		return timeSinceThreatAIEventData;
	}

	public static TimeSinceThreatAIEventData Deserialize(BufferStream stream)
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		Deserialize(stream, timeSinceThreatAIEventData, isDelta: false);
		return timeSinceThreatAIEventData;
	}

	public static TimeSinceThreatAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		DeserializeLengthDelimited(stream, timeSinceThreatAIEventData, isDelta: false);
		return timeSinceThreatAIEventData;
	}

	public static TimeSinceThreatAIEventData DeserializeLength(BufferStream stream, int length)
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		DeserializeLength(stream, length, timeSinceThreatAIEventData, isDelta: false);
		return timeSinceThreatAIEventData;
	}

	public static TimeSinceThreatAIEventData Deserialize(byte[] buffer)
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, timeSinceThreatAIEventData, isDelta: false);
		return timeSinceThreatAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TimeSinceThreatAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TimeSinceThreatAIEventData Deserialize(BufferStream stream, TimeSinceThreatAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TimeSinceThreatAIEventData DeserializeLengthDelimited(BufferStream stream, TimeSinceThreatAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TimeSinceThreatAIEventData DeserializeLength(BufferStream stream, int length, TimeSinceThreatAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TimeSinceThreatAIEventData instance, TimeSinceThreatAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, TimeSinceThreatAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AggressionTimerAIEventData : IDisposable, IPooled, IProto<AggressionTimerAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AggressionTimerAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<AggressionTimerAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AggressionTimerAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AggressionTimerAIEventData instance)
	{
		instance.value = value;
	}

	public AggressionTimerAIEventData Copy()
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		CopyTo(aggressionTimerAIEventData);
		return aggressionTimerAIEventData;
	}

	public static AggressionTimerAIEventData Deserialize(BufferStream stream)
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		Deserialize(stream, aggressionTimerAIEventData, isDelta: false);
		return aggressionTimerAIEventData;
	}

	public static AggressionTimerAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		DeserializeLengthDelimited(stream, aggressionTimerAIEventData, isDelta: false);
		return aggressionTimerAIEventData;
	}

	public static AggressionTimerAIEventData DeserializeLength(BufferStream stream, int length)
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		DeserializeLength(stream, length, aggressionTimerAIEventData, isDelta: false);
		return aggressionTimerAIEventData;
	}

	public static AggressionTimerAIEventData Deserialize(byte[] buffer)
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, aggressionTimerAIEventData, isDelta: false);
		return aggressionTimerAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AggressionTimerAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AggressionTimerAIEventData Deserialize(BufferStream stream, AggressionTimerAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AggressionTimerAIEventData DeserializeLengthDelimited(BufferStream stream, AggressionTimerAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AggressionTimerAIEventData DeserializeLength(BufferStream stream, int length, AggressionTimerAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AggressionTimerAIEventData instance, AggressionTimerAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, AggressionTimerAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MemoryBank : IDisposable, IPooled, IProto<MemoryBank>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public int slotCount;

	[NonSerialized]
	public List<int> slots;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MemoryBank instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.slotCount = 0;
			if (instance.slots != null)
			{
				List<int> list = instance.slots;
				Pool.FreeUnmanaged<int>(ref list);
				instance.slots = list;
			}
			Pool.Free<MemoryBank>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MemoryBank with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MemoryBank instance)
	{
		instance.type = type;
		instance.slotCount = slotCount;
		if (slots != null)
		{
			instance.slots = Pool.Get<List<int>>();
			for (int i = 0; i < slots.Count; i++)
			{
				int item = slots[i];
				instance.slots.Add(item);
			}
		}
		else
		{
			instance.slots = null;
		}
	}

	public MemoryBank Copy()
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		CopyTo(memoryBank);
		return memoryBank;
	}

	public static MemoryBank Deserialize(BufferStream stream)
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		Deserialize(stream, memoryBank, isDelta: false);
		return memoryBank;
	}

	public static MemoryBank DeserializeLengthDelimited(BufferStream stream)
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		DeserializeLengthDelimited(stream, memoryBank, isDelta: false);
		return memoryBank;
	}

	public static MemoryBank DeserializeLength(BufferStream stream, int length)
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		DeserializeLength(stream, length, memoryBank, isDelta: false);
		return memoryBank;
	}

	public static MemoryBank Deserialize(byte[] buffer)
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, memoryBank, isDelta: false);
		return memoryBank;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MemoryBank previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MemoryBank Deserialize(BufferStream stream, MemoryBank instance, bool isDelta)
	{
		if (!isDelta && instance.slots == null)
		{
			instance.slots = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MemoryBank DeserializeLengthDelimited(BufferStream stream, MemoryBank instance, bool isDelta)
	{
		if (!isDelta && instance.slots == null)
		{
			instance.slots = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MemoryBank DeserializeLength(BufferStream stream, int length, MemoryBank instance, bool isDelta)
	{
		if (!isDelta && instance.slots == null)
		{
			instance.slots = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MemoryBank instance, MemoryBank previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.slotCount != previous.slotCount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotCount);
		}
		if (instance.slots != null)
		{
			for (int i = 0; i < instance.slots.Count; i++)
			{
				int num = instance.slots[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public static void Serialize(BufferStream stream, MemoryBank instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.slotCount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotCount);
		}
		if (instance.slots != null)
		{
			for (int i = 0; i < instance.slots.Count; i++)
			{
				int num = instance.slots[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class InRangeOfHomeAIEventData : IDisposable, IPooled, IProto<InRangeOfHomeAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InRangeOfHomeAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<InRangeOfHomeAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InRangeOfHomeAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InRangeOfHomeAIEventData instance)
	{
		instance.range = range;
	}

	public InRangeOfHomeAIEventData Copy()
	{
		InRangeOfHomeAIEventData inRangeOfHomeAIEventData = Pool.Get<InRangeOfHomeAIEventData>();
		CopyTo(inRangeOfHomeAIEventData);
		return inRangeOfHomeAIEventData;
	}

	public static InRangeOfHomeAIEventData Deserialize(BufferStream stream)
	{
		InRangeOfHomeAIEventData inRangeOfHomeAIEventData = Pool.Get<InRangeOfHomeAIEventData>();
		Deserialize(stream, inRangeOfHomeAIEventData, isDelta: false);
		return inRangeOfHomeAIEventData;
	}

	public static InRangeOfHomeAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		InRangeOfHomeAIEventData inRangeOfHomeAIEventData = Pool.Get<InRangeOfHomeAIEventData>();
		DeserializeLengthDelimited(stream, inRangeOfHomeAIEventData, isDelta: false);
		return inRangeOfHomeAIEventData;
	}

	public static InRangeOfHomeAIEventData DeserializeLength(BufferStream stream, int length)
	{
		InRangeOfHomeAIEventData inRangeOfHomeAIEventData = Pool.Get<InRangeOfHomeAIEventData>();
		DeserializeLength(stream, length, inRangeOfHomeAIEventData, isDelta: false);
		return inRangeOfHomeAIEventData;
	}

	public static InRangeOfHomeAIEventData Deserialize(byte[] buffer)
	{
		InRangeOfHomeAIEventData inRangeOfHomeAIEventData = Pool.Get<InRangeOfHomeAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, inRangeOfHomeAIEventData, isDelta: false);
		return inRangeOfHomeAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InRangeOfHomeAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InRangeOfHomeAIEventData Deserialize(BufferStream stream, InRangeOfHomeAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InRangeOfHomeAIEventData DeserializeLengthDelimited(BufferStream stream, InRangeOfHomeAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InRangeOfHomeAIEventData DeserializeLength(BufferStream stream, int length, InRangeOfHomeAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InRangeOfHomeAIEventData instance, InRangeOfHomeAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, InRangeOfHomeAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppRequest : IDisposable, IPooled, IProto<AppRequest>, IProto
{
	[NonSerialized]
	public uint seq;

	[NonSerialized]
	public ulong playerId;

	[NonSerialized]
	public int playerToken;

	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public AppEmpty getInfo;

	[NonSerialized]
	public AppEmpty getTime;

	[NonSerialized]
	public AppEmpty getMap;

	[NonSerialized]
	public AppEmpty getTeamInfo;

	[NonSerialized]
	public AppEmpty getTeamChat;

	[NonSerialized]
	public AppSendMessage sendTeamMessage;

	[NonSerialized]
	public AppEmpty getEntityInfo;

	[NonSerialized]
	public AppSetEntityValue setEntityValue;

	[NonSerialized]
	public AppEmpty checkSubscription;

	[NonSerialized]
	public AppFlag setSubscription;

	[NonSerialized]
	public AppEmpty getMapMarkers;

	[NonSerialized]
	public AppPromoteToLeader promoteToLeader;

	[NonSerialized]
	public AppEmpty getClanInfo;

	[NonSerialized]
	public AppSendMessage setClanMotd;

	[NonSerialized]
	public AppEmpty getClanChat;

	[NonSerialized]
	public AppSendMessage sendClanMessage;

	[NonSerialized]
	public AppGetNexusAuth getNexusAuth;

	[NonSerialized]
	public AppCameraSubscribe cameraSubscribe;

	[NonSerialized]
	public AppEmpty cameraUnsubscribe;

	[NonSerialized]
	public AppCameraInput cameraInput;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.seq = 0u;
			instance.playerId = 0uL;
			instance.playerToken = 0;
			instance.entityId = default(NetworkableId);
			if (instance.getInfo != null)
			{
				instance.getInfo.ResetToPool();
				instance.getInfo = null;
			}
			if (instance.getTime != null)
			{
				instance.getTime.ResetToPool();
				instance.getTime = null;
			}
			if (instance.getMap != null)
			{
				instance.getMap.ResetToPool();
				instance.getMap = null;
			}
			if (instance.getTeamInfo != null)
			{
				instance.getTeamInfo.ResetToPool();
				instance.getTeamInfo = null;
			}
			if (instance.getTeamChat != null)
			{
				instance.getTeamChat.ResetToPool();
				instance.getTeamChat = null;
			}
			if (instance.sendTeamMessage != null)
			{
				instance.sendTeamMessage.ResetToPool();
				instance.sendTeamMessage = null;
			}
			if (instance.getEntityInfo != null)
			{
				instance.getEntityInfo.ResetToPool();
				instance.getEntityInfo = null;
			}
			if (instance.setEntityValue != null)
			{
				instance.setEntityValue.ResetToPool();
				instance.setEntityValue = null;
			}
			if (instance.checkSubscription != null)
			{
				instance.checkSubscription.ResetToPool();
				instance.checkSubscription = null;
			}
			if (instance.setSubscription != null)
			{
				instance.setSubscription.ResetToPool();
				instance.setSubscription = null;
			}
			if (instance.getMapMarkers != null)
			{
				instance.getMapMarkers.ResetToPool();
				instance.getMapMarkers = null;
			}
			if (instance.promoteToLeader != null)
			{
				instance.promoteToLeader.ResetToPool();
				instance.promoteToLeader = null;
			}
			if (instance.getClanInfo != null)
			{
				instance.getClanInfo.ResetToPool();
				instance.getClanInfo = null;
			}
			if (instance.setClanMotd != null)
			{
				instance.setClanMotd.ResetToPool();
				instance.setClanMotd = null;
			}
			if (instance.getClanChat != null)
			{
				instance.getClanChat.ResetToPool();
				instance.getClanChat = null;
			}
			if (instance.sendClanMessage != null)
			{
				instance.sendClanMessage.ResetToPool();
				instance.sendClanMessage = null;
			}
			if (instance.getNexusAuth != null)
			{
				instance.getNexusAuth.ResetToPool();
				instance.getNexusAuth = null;
			}
			if (instance.cameraSubscribe != null)
			{
				instance.cameraSubscribe.ResetToPool();
				instance.cameraSubscribe = null;
			}
			if (instance.cameraUnsubscribe != null)
			{
				instance.cameraUnsubscribe.ResetToPool();
				instance.cameraUnsubscribe = null;
			}
			if (instance.cameraInput != null)
			{
				instance.cameraInput.ResetToPool();
				instance.cameraInput = null;
			}
			Pool.Free<AppRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppRequest instance)
	{
		instance.seq = seq;
		instance.playerId = playerId;
		instance.playerToken = playerToken;
		instance.entityId = entityId;
		if (getInfo != null)
		{
			if (instance.getInfo == null)
			{
				instance.getInfo = getInfo.Copy();
			}
			else
			{
				getInfo.CopyTo(instance.getInfo);
			}
		}
		else
		{
			instance.getInfo = null;
		}
		if (getTime != null)
		{
			if (instance.getTime == null)
			{
				instance.getTime = getTime.Copy();
			}
			else
			{
				getTime.CopyTo(instance.getTime);
			}
		}
		else
		{
			instance.getTime = null;
		}
		if (getMap != null)
		{
			if (instance.getMap == null)
			{
				instance.getMap = getMap.Copy();
			}
			else
			{
				getMap.CopyTo(instance.getMap);
			}
		}
		else
		{
			instance.getMap = null;
		}
		if (getTeamInfo != null)
		{
			if (instance.getTeamInfo == null)
			{
				instance.getTeamInfo = getTeamInfo.Copy();
			}
			else
			{
				getTeamInfo.CopyTo(instance.getTeamInfo);
			}
		}
		else
		{
			instance.getTeamInfo = null;
		}
		if (getTeamChat != null)
		{
			if (instance.getTeamChat == null)
			{
				instance.getTeamChat = getTeamChat.Copy();
			}
			else
			{
				getTeamChat.CopyTo(instance.getTeamChat);
			}
		}
		else
		{
			instance.getTeamChat = null;
		}
		if (sendTeamMessage != null)
		{
			if (instance.sendTeamMessage == null)
			{
				instance.sendTeamMessage = sendTeamMessage.Copy();
			}
			else
			{
				sendTeamMessage.CopyTo(instance.sendTeamMessage);
			}
		}
		else
		{
			instance.sendTeamMessage = null;
		}
		if (getEntityInfo != null)
		{
			if (instance.getEntityInfo == null)
			{
				instance.getEntityInfo = getEntityInfo.Copy();
			}
			else
			{
				getEntityInfo.CopyTo(instance.getEntityInfo);
			}
		}
		else
		{
			instance.getEntityInfo = null;
		}
		if (setEntityValue != null)
		{
			if (instance.setEntityValue == null)
			{
				instance.setEntityValue = setEntityValue.Copy();
			}
			else
			{
				setEntityValue.CopyTo(instance.setEntityValue);
			}
		}
		else
		{
			instance.setEntityValue = null;
		}
		if (checkSubscription != null)
		{
			if (instance.checkSubscription == null)
			{
				instance.checkSubscription = checkSubscription.Copy();
			}
			else
			{
				checkSubscription.CopyTo(instance.checkSubscription);
			}
		}
		else
		{
			instance.checkSubscription = null;
		}
		if (setSubscription != null)
		{
			if (instance.setSubscription == null)
			{
				instance.setSubscription = setSubscription.Copy();
			}
			else
			{
				setSubscription.CopyTo(instance.setSubscription);
			}
		}
		else
		{
			instance.setSubscription = null;
		}
		if (getMapMarkers != null)
		{
			if (instance.getMapMarkers == null)
			{
				instance.getMapMarkers = getMapMarkers.Copy();
			}
			else
			{
				getMapMarkers.CopyTo(instance.getMapMarkers);
			}
		}
		else
		{
			instance.getMapMarkers = null;
		}
		if (promoteToLeader != null)
		{
			if (instance.promoteToLeader == null)
			{
				instance.promoteToLeader = promoteToLeader.Copy();
			}
			else
			{
				promoteToLeader.CopyTo(instance.promoteToLeader);
			}
		}
		else
		{
			instance.promoteToLeader = null;
		}
		if (getClanInfo != null)
		{
			if (instance.getClanInfo == null)
			{
				instance.getClanInfo = getClanInfo.Copy();
			}
			else
			{
				getClanInfo.CopyTo(instance.getClanInfo);
			}
		}
		else
		{
			instance.getClanInfo = null;
		}
		if (setClanMotd != null)
		{
			if (instance.setClanMotd == null)
			{
				instance.setClanMotd = setClanMotd.Copy();
			}
			else
			{
				setClanMotd.CopyTo(instance.setClanMotd);
			}
		}
		else
		{
			instance.setClanMotd = null;
		}
		if (getClanChat != null)
		{
			if (instance.getClanChat == null)
			{
				instance.getClanChat = getClanChat.Copy();
			}
			else
			{
				getClanChat.CopyTo(instance.getClanChat);
			}
		}
		else
		{
			instance.getClanChat = null;
		}
		if (sendClanMessage != null)
		{
			if (instance.sendClanMessage == null)
			{
				instance.sendClanMessage = sendClanMessage.Copy();
			}
			else
			{
				sendClanMessage.CopyTo(instance.sendClanMessage);
			}
		}
		else
		{
			instance.sendClanMessage = null;
		}
		if (getNexusAuth != null)
		{
			if (instance.getNexusAuth == null)
			{
				instance.getNexusAuth = getNexusAuth.Copy();
			}
			else
			{
				getNexusAuth.CopyTo(instance.getNexusAuth);
			}
		}
		else
		{
			instance.getNexusAuth = null;
		}
		if (cameraSubscribe != null)
		{
			if (instance.cameraSubscribe == null)
			{
				instance.cameraSubscribe = cameraSubscribe.Copy();
			}
			else
			{
				cameraSubscribe.CopyTo(instance.cameraSubscribe);
			}
		}
		else
		{
			instance.cameraSubscribe = null;
		}
		if (cameraUnsubscribe != null)
		{
			if (instance.cameraUnsubscribe == null)
			{
				instance.cameraUnsubscribe = cameraUnsubscribe.Copy();
			}
			else
			{
				cameraUnsubscribe.CopyTo(instance.cameraUnsubscribe);
			}
		}
		else
		{
			instance.cameraUnsubscribe = null;
		}
		if (cameraInput != null)
		{
			if (instance.cameraInput == null)
			{
				instance.cameraInput = cameraInput.Copy();
			}
			else
			{
				cameraInput.CopyTo(instance.cameraInput);
			}
		}
		else
		{
			instance.cameraInput = null;
		}
	}

	public AppRequest Copy()
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		CopyTo(appRequest);
		return appRequest;
	}

	public static AppRequest Deserialize(BufferStream stream)
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		Deserialize(stream, appRequest, isDelta: false);
		return appRequest;
	}

	public static AppRequest DeserializeLengthDelimited(BufferStream stream)
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		DeserializeLengthDelimited(stream, appRequest, isDelta: false);
		return appRequest;
	}

	public static AppRequest DeserializeLength(BufferStream stream, int length)
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		DeserializeLength(stream, length, appRequest, isDelta: false);
		return appRequest;
	}

	public static AppRequest Deserialize(byte[] buffer)
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appRequest, isDelta: false);
		return appRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppRequest Deserialize(BufferStream stream, AppRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
			instance.playerId = 0uL;
			instance.playerToken = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 66:
				if (instance.getInfo == null)
				{
					instance.getInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getInfo, isDelta);
				}
				continue;
			case 74:
				if (instance.getTime == null)
				{
					instance.getTime = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTime, isDelta);
				}
				continue;
			case 82:
				if (instance.getMap == null)
				{
					instance.getMap = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getMap, isDelta);
				}
				continue;
			case 90:
				if (instance.getTeamInfo == null)
				{
					instance.getTeamInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.getTeamChat == null)
				{
					instance.getTeamChat = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamChat, isDelta);
				}
				continue;
			case 106:
				if (instance.sendTeamMessage == null)
				{
					instance.sendTeamMessage = AppSendMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSendMessage.DeserializeLengthDelimited(stream, instance.sendTeamMessage, isDelta);
				}
				continue;
			case 114:
				if (instance.getEntityInfo == null)
				{
					instance.getEntityInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getEntityInfo, isDelta);
				}
				continue;
			case 122:
				if (instance.setEntityValue == null)
				{
					instance.setEntityValue = AppSetEntityValue.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSetEntityValue.DeserializeLengthDelimited(stream, instance.setEntityValue, isDelta);
				}
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.checkSubscription == null)
					{
						instance.checkSubscription = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.checkSubscription, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setSubscription == null)
					{
						instance.setSubscription = AppFlag.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppFlag.DeserializeLengthDelimited(stream, instance.setSubscription, isDelta);
					}
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getMapMarkers == null)
					{
						instance.getMapMarkers = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getMapMarkers, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.promoteToLeader == null)
					{
						instance.promoteToLeader = AppPromoteToLeader.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppPromoteToLeader.DeserializeLengthDelimited(stream, instance.promoteToLeader, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanInfo == null)
					{
						instance.getClanInfo = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanInfo, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setClanMotd == null)
					{
						instance.setClanMotd = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.setClanMotd, isDelta);
					}
				}
				break;
			case 23u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanChat == null)
					{
						instance.getClanChat = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanChat, isDelta);
					}
				}
				break;
			case 24u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.sendClanMessage == null)
					{
						instance.sendClanMessage = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.sendClanMessage, isDelta);
					}
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getNexusAuth == null)
					{
						instance.getNexusAuth = AppGetNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppGetNexusAuth.DeserializeLengthDelimited(stream, instance.getNexusAuth, isDelta);
					}
				}
				break;
			case 30u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribe == null)
					{
						instance.cameraSubscribe = AppCameraSubscribe.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraSubscribe.DeserializeLengthDelimited(stream, instance.cameraSubscribe, isDelta);
					}
				}
				break;
			case 31u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraUnsubscribe == null)
					{
						instance.cameraUnsubscribe = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.cameraUnsubscribe, isDelta);
					}
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraInput == null)
					{
						instance.cameraInput = AppCameraInput.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInput.DeserializeLengthDelimited(stream, instance.cameraInput, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static AppRequest DeserializeLengthDelimited(BufferStream stream, AppRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
			instance.playerId = 0uL;
			instance.playerToken = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 66:
				if (instance.getInfo == null)
				{
					instance.getInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getInfo, isDelta);
				}
				continue;
			case 74:
				if (instance.getTime == null)
				{
					instance.getTime = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTime, isDelta);
				}
				continue;
			case 82:
				if (instance.getMap == null)
				{
					instance.getMap = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getMap, isDelta);
				}
				continue;
			case 90:
				if (instance.getTeamInfo == null)
				{
					instance.getTeamInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.getTeamChat == null)
				{
					instance.getTeamChat = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamChat, isDelta);
				}
				continue;
			case 106:
				if (instance.sendTeamMessage == null)
				{
					instance.sendTeamMessage = AppSendMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSendMessage.DeserializeLengthDelimited(stream, instance.sendTeamMessage, isDelta);
				}
				continue;
			case 114:
				if (instance.getEntityInfo == null)
				{
					instance.getEntityInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getEntityInfo, isDelta);
				}
				continue;
			case 122:
				if (instance.setEntityValue == null)
				{
					instance.setEntityValue = AppSetEntityValue.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSetEntityValue.DeserializeLengthDelimited(stream, instance.setEntityValue, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.checkSubscription == null)
					{
						instance.checkSubscription = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.checkSubscription, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setSubscription == null)
					{
						instance.setSubscription = AppFlag.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppFlag.DeserializeLengthDelimited(stream, instance.setSubscription, isDelta);
					}
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getMapMarkers == null)
					{
						instance.getMapMarkers = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getMapMarkers, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.promoteToLeader == null)
					{
						instance.promoteToLeader = AppPromoteToLeader.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppPromoteToLeader.DeserializeLengthDelimited(stream, instance.promoteToLeader, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanInfo == null)
					{
						instance.getClanInfo = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanInfo, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setClanMotd == null)
					{
						instance.setClanMotd = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.setClanMotd, isDelta);
					}
				}
				break;
			case 23u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanChat == null)
					{
						instance.getClanChat = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanChat, isDelta);
					}
				}
				break;
			case 24u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.sendClanMessage == null)
					{
						instance.sendClanMessage = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.sendClanMessage, isDelta);
					}
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getNexusAuth == null)
					{
						instance.getNexusAuth = AppGetNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppGetNexusAuth.DeserializeLengthDelimited(stream, instance.getNexusAuth, isDelta);
					}
				}
				break;
			case 30u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribe == null)
					{
						instance.cameraSubscribe = AppCameraSubscribe.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraSubscribe.DeserializeLengthDelimited(stream, instance.cameraSubscribe, isDelta);
					}
				}
				break;
			case 31u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraUnsubscribe == null)
					{
						instance.cameraUnsubscribe = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.cameraUnsubscribe, isDelta);
					}
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraInput == null)
					{
						instance.cameraInput = AppCameraInput.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInput.DeserializeLengthDelimited(stream, instance.cameraInput, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppRequest DeserializeLength(BufferStream stream, int length, AppRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
			instance.playerId = 0uL;
			instance.playerToken = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 66:
				if (instance.getInfo == null)
				{
					instance.getInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getInfo, isDelta);
				}
				continue;
			case 74:
				if (instance.getTime == null)
				{
					instance.getTime = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTime, isDelta);
				}
				continue;
			case 82:
				if (instance.getMap == null)
				{
					instance.getMap = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getMap, isDelta);
				}
				continue;
			case 90:
				if (instance.getTeamInfo == null)
				{
					instance.getTeamInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.getTeamChat == null)
				{
					instance.getTeamChat = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamChat, isDelta);
				}
				continue;
			case 106:
				if (instance.sendTeamMessage == null)
				{
					instance.sendTeamMessage = AppSendMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSendMessage.DeserializeLengthDelimited(stream, instance.sendTeamMessage, isDelta);
				}
				continue;
			case 114:
				if (instance.getEntityInfo == null)
				{
					instance.getEntityInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getEntityInfo, isDelta);
				}
				continue;
			case 122:
				if (instance.setEntityValue == null)
				{
					instance.setEntityValue = AppSetEntityValue.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSetEntityValue.DeserializeLengthDelimited(stream, instance.setEntityValue, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.checkSubscription == null)
					{
						instance.checkSubscription = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.checkSubscription, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setSubscription == null)
					{
						instance.setSubscription = AppFlag.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppFlag.DeserializeLengthDelimited(stream, instance.setSubscription, isDelta);
					}
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getMapMarkers == null)
					{
						instance.getMapMarkers = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getMapMarkers, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.promoteToLeader == null)
					{
						instance.promoteToLeader = AppPromoteToLeader.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppPromoteToLeader.DeserializeLengthDelimited(stream, instance.promoteToLeader, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanInfo == null)
					{
						instance.getClanInfo = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanInfo, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setClanMotd == null)
					{
						instance.setClanMotd = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.setClanMotd, isDelta);
					}
				}
				break;
			case 23u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanChat == null)
					{
						instance.getClanChat = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanChat, isDelta);
					}
				}
				break;
			case 24u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.sendClanMessage == null)
					{
						instance.sendClanMessage = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.sendClanMessage, isDelta);
					}
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getNexusAuth == null)
					{
						instance.getNexusAuth = AppGetNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppGetNexusAuth.DeserializeLengthDelimited(stream, instance.getNexusAuth, isDelta);
					}
				}
				break;
			case 30u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribe == null)
					{
						instance.cameraSubscribe = AppCameraSubscribe.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraSubscribe.DeserializeLengthDelimited(stream, instance.cameraSubscribe, isDelta);
					}
				}
				break;
			case 31u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraUnsubscribe == null)
					{
						instance.cameraUnsubscribe = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.cameraUnsubscribe, isDelta);
					}
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraInput == null)
					{
						instance.cameraInput = AppCameraInput.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInput.DeserializeLengthDelimited(stream, instance.cameraInput, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppRequest instance, AppRequest previous)
	{
		if (instance.seq != previous.seq)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seq);
		}
		if (instance.playerId != previous.playerId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.playerToken != previous.playerToken)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerToken);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		if (instance.getInfo != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getInfo, previous.getInfo);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.getTime != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getTime, previous.getTime);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTime (ProtoBuf.AppEmpty)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.getMap != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getMap, previous.getMap);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getMap (ProtoBuf.AppEmpty)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.getTeamInfo != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getTeamInfo, previous.getTeamInfo);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTeamInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.getTeamChat != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getTeamChat, previous.getTeamChat);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTeamChat (ProtoBuf.AppEmpty)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.sendTeamMessage != null)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			AppSendMessage.SerializeDelta(stream, instance.sendTeamMessage, previous.sendTeamMessage);
			int val = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val, span6, 0);
			if (num6 < 5)
			{
				span6[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span6[num6++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.getEntityInfo != null)
		{
			stream.WriteByte(114);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getEntityInfo, previous.getEntityInfo);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getEntityInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.setEntityValue != null)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			AppSetEntityValue.SerializeDelta(stream, instance.setEntityValue, previous.setEntityValue);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field setEntityValue (ProtoBuf.AppSetEntityValue)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
		if (instance.checkSubscription != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.checkSubscription, previous.checkSubscription);
			int num9 = stream.Position - position9;
			if (num9 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field checkSubscription (ProtoBuf.AppEmpty)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num9, span9, 0);
		}
		if (instance.setSubscription != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(1);
			BufferStream.RangeHandle range10 = stream.GetRange(1);
			int position10 = stream.Position;
			AppFlag.SerializeDelta(stream, instance.setSubscription, previous.setSubscription);
			int num10 = stream.Position - position10;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field setSubscription (ProtoBuf.AppFlag)");
			}
			Span<byte> span10 = range10.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		}
		if (instance.getMapMarkers != null)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			BufferStream.RangeHandle range11 = stream.GetRange(1);
			int position11 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getMapMarkers, previous.getMapMarkers);
			int num11 = stream.Position - position11;
			if (num11 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getMapMarkers (ProtoBuf.AppEmpty)");
			}
			Span<byte> span11 = range11.GetSpan();
			ProtocolParser.WriteUInt32((uint)num11, span11, 0);
		}
		if (instance.promoteToLeader != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range12 = stream.GetRange(1);
			int position12 = stream.Position;
			AppPromoteToLeader.SerializeDelta(stream, instance.promoteToLeader, previous.promoteToLeader);
			int num12 = stream.Position - position12;
			if (num12 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field promoteToLeader (ProtoBuf.AppPromoteToLeader)");
			}
			Span<byte> span12 = range12.GetSpan();
			ProtocolParser.WriteUInt32((uint)num12, span12, 0);
		}
		if (instance.getClanInfo != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range13 = stream.GetRange(1);
			int position13 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getClanInfo, previous.getClanInfo);
			int num13 = stream.Position - position13;
			if (num13 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getClanInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span13 = range13.GetSpan();
			ProtocolParser.WriteUInt32((uint)num13, span13, 0);
		}
		if (instance.setClanMotd != null)
		{
			stream.WriteByte(178);
			stream.WriteByte(1);
			BufferStream.RangeHandle range14 = stream.GetRange(5);
			int position14 = stream.Position;
			AppSendMessage.SerializeDelta(stream, instance.setClanMotd, previous.setClanMotd);
			int val2 = stream.Position - position14;
			Span<byte> span14 = range14.GetSpan();
			int num14 = ProtocolParser.WriteUInt32((uint)val2, span14, 0);
			if (num14 < 5)
			{
				span14[num14 - 1] |= 128;
				while (num14 < 4)
				{
					span14[num14++] = 128;
				}
				span14[4] = 0;
			}
		}
		if (instance.getClanChat != null)
		{
			stream.WriteByte(186);
			stream.WriteByte(1);
			BufferStream.RangeHandle range15 = stream.GetRange(1);
			int position15 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getClanChat, previous.getClanChat);
			int num15 = stream.Position - position15;
			if (num15 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getClanChat (ProtoBuf.AppEmpty)");
			}
			Span<byte> span15 = range15.GetSpan();
			ProtocolParser.WriteUInt32((uint)num15, span15, 0);
		}
		if (instance.sendClanMessage != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(1);
			BufferStream.RangeHandle range16 = stream.GetRange(5);
			int position16 = stream.Position;
			AppSendMessage.SerializeDelta(stream, instance.sendClanMessage, previous.sendClanMessage);
			int val3 = stream.Position - position16;
			Span<byte> span16 = range16.GetSpan();
			int num16 = ProtocolParser.WriteUInt32((uint)val3, span16, 0);
			if (num16 < 5)
			{
				span16[num16 - 1] |= 128;
				while (num16 < 4)
				{
					span16[num16++] = 128;
				}
				span16[4] = 0;
			}
		}
		if (instance.getNexusAuth != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(1);
			BufferStream.RangeHandle range17 = stream.GetRange(5);
			int position17 = stream.Position;
			AppGetNexusAuth.SerializeDelta(stream, instance.getNexusAuth, previous.getNexusAuth);
			int val4 = stream.Position - position17;
			Span<byte> span17 = range17.GetSpan();
			int num17 = ProtocolParser.WriteUInt32((uint)val4, span17, 0);
			if (num17 < 5)
			{
				span17[num17 - 1] |= 128;
				while (num17 < 4)
				{
					span17[num17++] = 128;
				}
				span17[4] = 0;
			}
		}
		if (instance.cameraSubscribe != null)
		{
			stream.WriteByte(242);
			stream.WriteByte(1);
			BufferStream.RangeHandle range18 = stream.GetRange(5);
			int position18 = stream.Position;
			AppCameraSubscribe.SerializeDelta(stream, instance.cameraSubscribe, previous.cameraSubscribe);
			int val5 = stream.Position - position18;
			Span<byte> span18 = range18.GetSpan();
			int num18 = ProtocolParser.WriteUInt32((uint)val5, span18, 0);
			if (num18 < 5)
			{
				span18[num18 - 1] |= 128;
				while (num18 < 4)
				{
					span18[num18++] = 128;
				}
				span18[4] = 0;
			}
		}
		if (instance.cameraUnsubscribe != null)
		{
			stream.WriteByte(250);
			stream.WriteByte(1);
			BufferStream.RangeHandle range19 = stream.GetRange(1);
			int position19 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.cameraUnsubscribe, previous.cameraUnsubscribe);
			int num19 = stream.Position - position19;
			if (num19 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraUnsubscribe (ProtoBuf.AppEmpty)");
			}
			Span<byte> span19 = range19.GetSpan();
			ProtocolParser.WriteUInt32((uint)num19, span19, 0);
		}
		if (instance.cameraInput != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(2);
			BufferStream.RangeHandle range20 = stream.GetRange(1);
			int position20 = stream.Position;
			AppCameraInput.SerializeDelta(stream, instance.cameraInput, previous.cameraInput);
			int num20 = stream.Position - position20;
			if (num20 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraInput (ProtoBuf.AppCameraInput)");
			}
			Span<byte> span20 = range20.GetSpan();
			ProtocolParser.WriteUInt32((uint)num20, span20, 0);
		}
	}

	public static void Serialize(BufferStream stream, AppRequest instance)
	{
		if (instance.seq != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seq);
		}
		if (instance.playerId != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.playerToken != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerToken);
		}
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.getInfo != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			AppEmpty.Serialize(stream, instance.getInfo);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.getTime != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			AppEmpty.Serialize(stream, instance.getTime);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTime (ProtoBuf.AppEmpty)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.getMap != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			AppEmpty.Serialize(stream, instance.getMap);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getMap (ProtoBuf.AppEmpty)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.getTeamInfo != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			AppEmpty.Serialize(stream, instance.getTeamInfo);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTeamInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.getTeamChat != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			AppEmpty.Serialize(stream, instance.getTeamChat);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTeamChat (ProtoBuf.AppEmpty)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.sendTeamMessage != null)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			AppSendMessage.Serialize(stream, instance.sendTeamMessage);
			int val = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val, span6, 0);
			if (num6 < 5)
			{
				span6[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span6[num6++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.getEntityInfo != null)
		{
			stream.WriteByte(114);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			AppEmpty.Serialize(stream, instance.getEntityInfo);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getEntityInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.setEntityValue != null)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			AppSetEntityValue.Serialize(stream, instance.setEntityValue);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field setEntityValue (ProtoBuf.AppSetEntityValue)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
		if (instance.checkSubscription != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AppEmpty.Serialize(stream, instance.checkSubscription);
			int num9 = stream.Position - position9;
			if (num9 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field checkSubscription (ProtoBuf.AppEmpty)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num9, span9, 0);
		}
		if (instance.setSubscription != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(1);
			BufferStream.RangeHandle range10 = stream.GetRange(1);
			int position10 = stream.Position;
			AppFlag.Serialize(stream, instance.setSubscription);
			int num10 = stream.Position - position10;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field setSubscription (ProtoBuf.AppFlag)");
			}
			Span<byte> span10 = range10.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		}
		if (instance.getMapMarkers != null)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			BufferStream.RangeHandle range11 = stream.GetRange(1);
			int position11 = stream.Position;
			AppEmpty.Serialize(stream, instance.getMapMarkers);
			int num11 = stream.Position - position11;
			if (num11 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getMapMarkers (ProtoBuf.AppEmpty)");
			}
			Span<byte> span11 = range11.GetSpan();
			ProtocolParser.WriteUInt32((uint)num11, span11, 0);
		}
		if (instance.promoteToLeader != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range12 = stream.GetRange(1);
			int position12 = stream.Position;
			AppPromoteToLeader.Serialize(stream, instance.promoteToLeader);
			int num12 = stream.Position - position12;
			if (num12 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field promoteToLeader (ProtoBuf.AppPromoteToLeader)");
			}
			Span<byte> span12 = range12.GetSpan();
			ProtocolParser.WriteUInt32((uint)num12, span12, 0);
		}
		if (instance.getClanInfo != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range13 = stream.GetRange(1);
			int position13 = stream.Position;
			AppEmpty.Serialize(stream, instance.getClanInfo);
			int num13 = stream.Position - position13;
			if (num13 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getClanInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span13 = range13.GetSpan();
			ProtocolParser.WriteUInt32((uint)num13, span13, 0);
		}
		if (instance.setClanMotd != null)
		{
			stream.WriteByte(178);
			stream.WriteByte(1);
			BufferStream.RangeHandle range14 = stream.GetRange(5);
			int position14 = stream.Position;
			AppSendMessage.Serialize(stream, instance.setClanMotd);
			int val2 = stream.Position - position14;
			Span<byte> span14 = range14.GetSpan();
			int num14 = ProtocolParser.WriteUInt32((uint)val2, span14, 0);
			if (num14 < 5)
			{
				span14[num14 - 1] |= 128;
				while (num14 < 4)
				{
					span14[num14++] = 128;
				}
				span14[4] = 0;
			}
		}
		if (instance.getClanChat != null)
		{
			stream.WriteByte(186);
			stream.WriteByte(1);
			BufferStream.RangeHandle range15 = stream.GetRange(1);
			int position15 = stream.Position;
			AppEmpty.Serialize(stream, instance.getClanChat);
			int num15 = stream.Position - position15;
			if (num15 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getClanChat (ProtoBuf.AppEmpty)");
			}
			Span<byte> span15 = range15.GetSpan();
			ProtocolParser.WriteUInt32((uint)num15, span15, 0);
		}
		if (instance.sendClanMessage != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(1);
			BufferStream.RangeHandle range16 = stream.GetRange(5);
			int position16 = stream.Position;
			AppSendMessage.Serialize(stream, instance.sendClanMessage);
			int val3 = stream.Position - position16;
			Span<byte> span16 = range16.GetSpan();
			int num16 = ProtocolParser.WriteUInt32((uint)val3, span16, 0);
			if (num16 < 5)
			{
				span16[num16 - 1] |= 128;
				while (num16 < 4)
				{
					span16[num16++] = 128;
				}
				span16[4] = 0;
			}
		}
		if (instance.getNexusAuth != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(1);
			BufferStream.RangeHandle range17 = stream.GetRange(5);
			int position17 = stream.Position;
			AppGetNexusAuth.Serialize(stream, instance.getNexusAuth);
			int val4 = stream.Position - position17;
			Span<byte> span17 = range17.GetSpan();
			int num17 = ProtocolParser.WriteUInt32((uint)val4, span17, 0);
			if (num17 < 5)
			{
				span17[num17 - 1] |= 128;
				while (num17 < 4)
				{
					span17[num17++] = 128;
				}
				span17[4] = 0;
			}
		}
		if (instance.cameraSubscribe != null)
		{
			stream.WriteByte(242);
			stream.WriteByte(1);
			BufferStream.RangeHandle range18 = stream.GetRange(5);
			int position18 = stream.Position;
			AppCameraSubscribe.Serialize(stream, instance.cameraSubscribe);
			int val5 = stream.Position - position18;
			Span<byte> span18 = range18.GetSpan();
			int num18 = ProtocolParser.WriteUInt32((uint)val5, span18, 0);
			if (num18 < 5)
			{
				span18[num18 - 1] |= 128;
				while (num18 < 4)
				{
					span18[num18++] = 128;
				}
				span18[4] = 0;
			}
		}
		if (instance.cameraUnsubscribe != null)
		{
			stream.WriteByte(250);
			stream.WriteByte(1);
			BufferStream.RangeHandle range19 = stream.GetRange(1);
			int position19 = stream.Position;
			AppEmpty.Serialize(stream, instance.cameraUnsubscribe);
			int num19 = stream.Position - position19;
			if (num19 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraUnsubscribe (ProtoBuf.AppEmpty)");
			}
			Span<byte> span19 = range19.GetSpan();
			ProtocolParser.WriteUInt32((uint)num19, span19, 0);
		}
		if (instance.cameraInput != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(2);
			BufferStream.RangeHandle range20 = stream.GetRange(1);
			int position20 = stream.Position;
			AppCameraInput.Serialize(stream, instance.cameraInput);
			int num20 = stream.Position - position20;
			if (num20 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraInput (ProtoBuf.AppCameraInput)");
			}
			Span<byte> span20 = range20.GetSpan();
			ProtocolParser.WriteUInt32((uint)num20, span20, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
		getInfo?.InspectUids(action);
		getTime?.InspectUids(action);
		getMap?.InspectUids(action);
		getTeamInfo?.InspectUids(action);
		getTeamChat?.InspectUids(action);
		sendTeamMessage?.InspectUids(action);
		getEntityInfo?.InspectUids(action);
		setEntityValue?.InspectUids(action);
		checkSubscription?.InspectUids(action);
		setSubscription?.InspectUids(action);
		getMapMarkers?.InspectUids(action);
		promoteToLeader?.InspectUids(action);
		getClanInfo?.InspectUids(action);
		setClanMotd?.InspectUids(action);
		getClanChat?.InspectUids(action);
		sendClanMessage?.InspectUids(action);
		getNexusAuth?.InspectUids(action);
		cameraSubscribe?.InspectUids(action);
		cameraUnsubscribe?.InspectUids(action);
		cameraInput?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppMessage : IDisposable, IPooled, IProto<AppMessage>, IProto
{
	[NonSerialized]
	public AppResponse response;

	[NonSerialized]
	public AppBroadcast broadcast;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppMessage instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.response != null)
			{
				instance.response.ResetToPool();
				instance.response = null;
			}
			if (instance.broadcast != null)
			{
				instance.broadcast.ResetToPool();
				instance.broadcast = null;
			}
			Pool.Free<AppMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppMessage instance)
	{
		if (response != null)
		{
			if (instance.response == null)
			{
				instance.response = response.Copy();
			}
			else
			{
				response.CopyTo(instance.response);
			}
		}
		else
		{
			instance.response = null;
		}
		if (broadcast != null)
		{
			if (instance.broadcast == null)
			{
				instance.broadcast = broadcast.Copy();
			}
			else
			{
				broadcast.CopyTo(instance.broadcast);
			}
		}
		else
		{
			instance.broadcast = null;
		}
	}

	public AppMessage Copy()
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		CopyTo(appMessage);
		return appMessage;
	}

	public static AppMessage Deserialize(BufferStream stream)
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		Deserialize(stream, appMessage, isDelta: false);
		return appMessage;
	}

	public static AppMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		DeserializeLengthDelimited(stream, appMessage, isDelta: false);
		return appMessage;
	}

	public static AppMessage DeserializeLength(BufferStream stream, int length)
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		DeserializeLength(stream, length, appMessage, isDelta: false);
		return appMessage;
	}

	public static AppMessage Deserialize(byte[] buffer)
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appMessage, isDelta: false);
		return appMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppMessage Deserialize(BufferStream stream, AppMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.response == null)
				{
					instance.response = AppResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppResponse.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			case 18:
				if (instance.broadcast == null)
				{
					instance.broadcast = AppBroadcast.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppBroadcast.DeserializeLengthDelimited(stream, instance.broadcast, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppMessage DeserializeLengthDelimited(BufferStream stream, AppMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.response == null)
				{
					instance.response = AppResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppResponse.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			case 18:
				if (instance.broadcast == null)
				{
					instance.broadcast = AppBroadcast.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppBroadcast.DeserializeLengthDelimited(stream, instance.broadcast, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppMessage DeserializeLength(BufferStream stream, int length, AppMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.response == null)
				{
					instance.response = AppResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppResponse.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			case 18:
				if (instance.broadcast == null)
				{
					instance.broadcast = AppBroadcast.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppBroadcast.DeserializeLengthDelimited(stream, instance.broadcast, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppMessage instance, AppMessage previous)
	{
		if (instance.response != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppResponse.SerializeDelta(stream, instance.response, previous.response);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.broadcast == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		AppBroadcast.SerializeDelta(stream, instance.broadcast, previous.broadcast);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppMessage instance)
	{
		if (instance.response != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppResponse.Serialize(stream, instance.response);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.broadcast == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		AppBroadcast.Serialize(stream, instance.broadcast);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		response?.InspectUids(action);
		broadcast?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppResponse : IDisposable, IPooled, IProto<AppResponse>, IProto
{
	[NonSerialized]
	public uint seq;

	[NonSerialized]
	public AppSuccess success;

	[NonSerialized]
	public AppError error;

	[NonSerialized]
	public AppInfo info;

	[NonSerialized]
	public AppTime time;

	[NonSerialized]
	public AppMap map;

	[NonSerialized]
	public AppTeamInfo teamInfo;

	[NonSerialized]
	public AppTeamChat teamChat;

	[NonSerialized]
	public AppEntityInfo entityInfo;

	[NonSerialized]
	public AppFlag flag;

	[NonSerialized]
	public AppMapMarkers mapMarkers;

	[NonSerialized]
	public AppClanInfo clanInfo;

	[NonSerialized]
	public AppClanChat clanChat;

	[NonSerialized]
	public AppNexusAuth nexusAuth;

	[NonSerialized]
	public AppCameraInfo cameraSubscribeInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppResponse instance)
	{
		if (instance.ShouldPool)
		{
			instance.seq = 0u;
			if (instance.success != null)
			{
				instance.success.ResetToPool();
				instance.success = null;
			}
			if (instance.error != null)
			{
				instance.error.ResetToPool();
				instance.error = null;
			}
			if (instance.info != null)
			{
				instance.info.ResetToPool();
				instance.info = null;
			}
			if (instance.time != null)
			{
				instance.time.ResetToPool();
				instance.time = null;
			}
			if (instance.map != null)
			{
				instance.map.ResetToPool();
				instance.map = null;
			}
			if (instance.teamInfo != null)
			{
				instance.teamInfo.ResetToPool();
				instance.teamInfo = null;
			}
			if (instance.teamChat != null)
			{
				instance.teamChat.ResetToPool();
				instance.teamChat = null;
			}
			if (instance.entityInfo != null)
			{
				instance.entityInfo.ResetToPool();
				instance.entityInfo = null;
			}
			if (instance.flag != null)
			{
				instance.flag.ResetToPool();
				instance.flag = null;
			}
			if (instance.mapMarkers != null)
			{
				instance.mapMarkers.ResetToPool();
				instance.mapMarkers = null;
			}
			if (instance.clanInfo != null)
			{
				instance.clanInfo.ResetToPool();
				instance.clanInfo = null;
			}
			if (instance.clanChat != null)
			{
				instance.clanChat.ResetToPool();
				instance.clanChat = null;
			}
			if (instance.nexusAuth != null)
			{
				instance.nexusAuth.ResetToPool();
				instance.nexusAuth = null;
			}
			if (instance.cameraSubscribeInfo != null)
			{
				instance.cameraSubscribeInfo.ResetToPool();
				instance.cameraSubscribeInfo = null;
			}
			Pool.Free<AppResponse>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppResponse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppResponse instance)
	{
		instance.seq = seq;
		if (success != null)
		{
			if (instance.success == null)
			{
				instance.success = success.Copy();
			}
			else
			{
				success.CopyTo(instance.success);
			}
		}
		else
		{
			instance.success = null;
		}
		if (error != null)
		{
			if (instance.error == null)
			{
				instance.error = error.Copy();
			}
			else
			{
				error.CopyTo(instance.error);
			}
		}
		else
		{
			instance.error = null;
		}
		if (info != null)
		{
			if (instance.info == null)
			{
				instance.info = info.Copy();
			}
			else
			{
				info.CopyTo(instance.info);
			}
		}
		else
		{
			instance.info = null;
		}
		if (time != null)
		{
			if (instance.time == null)
			{
				instance.time = time.Copy();
			}
			else
			{
				time.CopyTo(instance.time);
			}
		}
		else
		{
			instance.time = null;
		}
		if (map != null)
		{
			if (instance.map == null)
			{
				instance.map = map.Copy();
			}
			else
			{
				map.CopyTo(instance.map);
			}
		}
		else
		{
			instance.map = null;
		}
		if (teamInfo != null)
		{
			if (instance.teamInfo == null)
			{
				instance.teamInfo = teamInfo.Copy();
			}
			else
			{
				teamInfo.CopyTo(instance.teamInfo);
			}
		}
		else
		{
			instance.teamInfo = null;
		}
		if (teamChat != null)
		{
			if (instance.teamChat == null)
			{
				instance.teamChat = teamChat.Copy();
			}
			else
			{
				teamChat.CopyTo(instance.teamChat);
			}
		}
		else
		{
			instance.teamChat = null;
		}
		if (entityInfo != null)
		{
			if (instance.entityInfo == null)
			{
				instance.entityInfo = entityInfo.Copy();
			}
			else
			{
				entityInfo.CopyTo(instance.entityInfo);
			}
		}
		else
		{
			instance.entityInfo = null;
		}
		if (flag != null)
		{
			if (instance.flag == null)
			{
				instance.flag = flag.Copy();
			}
			else
			{
				flag.CopyTo(instance.flag);
			}
		}
		else
		{
			instance.flag = null;
		}
		if (mapMarkers != null)
		{
			if (instance.mapMarkers == null)
			{
				instance.mapMarkers = mapMarkers.Copy();
			}
			else
			{
				mapMarkers.CopyTo(instance.mapMarkers);
			}
		}
		else
		{
			instance.mapMarkers = null;
		}
		if (clanInfo != null)
		{
			if (instance.clanInfo == null)
			{
				instance.clanInfo = clanInfo.Copy();
			}
			else
			{
				clanInfo.CopyTo(instance.clanInfo);
			}
		}
		else
		{
			instance.clanInfo = null;
		}
		if (clanChat != null)
		{
			if (instance.clanChat == null)
			{
				instance.clanChat = clanChat.Copy();
			}
			else
			{
				clanChat.CopyTo(instance.clanChat);
			}
		}
		else
		{
			instance.clanChat = null;
		}
		if (nexusAuth != null)
		{
			if (instance.nexusAuth == null)
			{
				instance.nexusAuth = nexusAuth.Copy();
			}
			else
			{
				nexusAuth.CopyTo(instance.nexusAuth);
			}
		}
		else
		{
			instance.nexusAuth = null;
		}
		if (cameraSubscribeInfo != null)
		{
			if (instance.cameraSubscribeInfo == null)
			{
				instance.cameraSubscribeInfo = cameraSubscribeInfo.Copy();
			}
			else
			{
				cameraSubscribeInfo.CopyTo(instance.cameraSubscribeInfo);
			}
		}
		else
		{
			instance.cameraSubscribeInfo = null;
		}
	}

	public AppResponse Copy()
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		CopyTo(appResponse);
		return appResponse;
	}

	public static AppResponse Deserialize(BufferStream stream)
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		Deserialize(stream, appResponse, isDelta: false);
		return appResponse;
	}

	public static AppResponse DeserializeLengthDelimited(BufferStream stream)
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		DeserializeLengthDelimited(stream, appResponse, isDelta: false);
		return appResponse;
	}

	public static AppResponse DeserializeLength(BufferStream stream, int length)
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		DeserializeLength(stream, length, appResponse, isDelta: false);
		return appResponse;
	}

	public static AppResponse Deserialize(byte[] buffer)
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appResponse, isDelta: false);
		return appResponse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppResponse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppResponse Deserialize(BufferStream stream, AppResponse instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				if (instance.success == null)
				{
					instance.success = AppSuccess.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSuccess.DeserializeLengthDelimited(stream, instance.success, isDelta);
				}
				continue;
			case 42:
				if (instance.error == null)
				{
					instance.error = AppError.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppError.DeserializeLengthDelimited(stream, instance.error, isDelta);
				}
				continue;
			case 50:
				if (instance.info == null)
				{
					instance.info = AppInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				continue;
			case 58:
				if (instance.time == null)
				{
					instance.time = AppTime.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTime.DeserializeLengthDelimited(stream, instance.time, isDelta);
				}
				continue;
			case 66:
				if (instance.map == null)
				{
					instance.map = AppMap.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMap.DeserializeLengthDelimited(stream, instance.map, isDelta);
				}
				continue;
			case 74:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				continue;
			case 82:
				if (instance.teamChat == null)
				{
					instance.teamChat = AppTeamChat.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChat.DeserializeLengthDelimited(stream, instance.teamChat, isDelta);
				}
				continue;
			case 90:
				if (instance.entityInfo == null)
				{
					instance.entityInfo = AppEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityInfo.DeserializeLengthDelimited(stream, instance.entityInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.flag == null)
				{
					instance.flag = AppFlag.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppFlag.DeserializeLengthDelimited(stream, instance.flag, isDelta);
				}
				continue;
			case 106:
				if (instance.mapMarkers == null)
				{
					instance.mapMarkers = AppMapMarkers.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMapMarkers.DeserializeLengthDelimited(stream, instance.mapMarkers, isDelta);
				}
				continue;
			case 122:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = AppClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.clanChat == null)
					{
						instance.clanChat = AppClanChat.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppClanChat.DeserializeLengthDelimited(stream, instance.clanChat, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.nexusAuth == null)
					{
						instance.nexusAuth = AppNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppNexusAuth.DeserializeLengthDelimited(stream, instance.nexusAuth, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribeInfo == null)
					{
						instance.cameraSubscribeInfo = AppCameraInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInfo.DeserializeLengthDelimited(stream, instance.cameraSubscribeInfo, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static AppResponse DeserializeLengthDelimited(BufferStream stream, AppResponse instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				if (instance.success == null)
				{
					instance.success = AppSuccess.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSuccess.DeserializeLengthDelimited(stream, instance.success, isDelta);
				}
				continue;
			case 42:
				if (instance.error == null)
				{
					instance.error = AppError.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppError.DeserializeLengthDelimited(stream, instance.error, isDelta);
				}
				continue;
			case 50:
				if (instance.info == null)
				{
					instance.info = AppInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				continue;
			case 58:
				if (instance.time == null)
				{
					instance.time = AppTime.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTime.DeserializeLengthDelimited(stream, instance.time, isDelta);
				}
				continue;
			case 66:
				if (instance.map == null)
				{
					instance.map = AppMap.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMap.DeserializeLengthDelimited(stream, instance.map, isDelta);
				}
				continue;
			case 74:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				continue;
			case 82:
				if (instance.teamChat == null)
				{
					instance.teamChat = AppTeamChat.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChat.DeserializeLengthDelimited(stream, instance.teamChat, isDelta);
				}
				continue;
			case 90:
				if (instance.entityInfo == null)
				{
					instance.entityInfo = AppEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityInfo.DeserializeLengthDelimited(stream, instance.entityInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.flag == null)
				{
					instance.flag = AppFlag.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppFlag.DeserializeLengthDelimited(stream, instance.flag, isDelta);
				}
				continue;
			case 106:
				if (instance.mapMarkers == null)
				{
					instance.mapMarkers = AppMapMarkers.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMapMarkers.DeserializeLengthDelimited(stream, instance.mapMarkers, isDelta);
				}
				continue;
			case 122:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = AppClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.clanChat == null)
					{
						instance.clanChat = AppClanChat.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppClanChat.DeserializeLengthDelimited(stream, instance.clanChat, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.nexusAuth == null)
					{
						instance.nexusAuth = AppNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppNexusAuth.DeserializeLengthDelimited(stream, instance.nexusAuth, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribeInfo == null)
					{
						instance.cameraSubscribeInfo = AppCameraInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInfo.DeserializeLengthDelimited(stream, instance.cameraSubscribeInfo, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppResponse DeserializeLength(BufferStream stream, int length, AppResponse instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				if (instance.success == null)
				{
					instance.success = AppSuccess.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSuccess.DeserializeLengthDelimited(stream, instance.success, isDelta);
				}
				continue;
			case 42:
				if (instance.error == null)
				{
					instance.error = AppError.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppError.DeserializeLengthDelimited(stream, instance.error, isDelta);
				}
				continue;
			case 50:
				if (instance.info == null)
				{
					instance.info = AppInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				continue;
			case 58:
				if (instance.time == null)
				{
					instance.time = AppTime.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTime.DeserializeLengthDelimited(stream, instance.time, isDelta);
				}
				continue;
			case 66:
				if (instance.map == null)
				{
					instance.map = AppMap.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMap.DeserializeLengthDelimited(stream, instance.map, isDelta);
				}
				continue;
			case 74:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				continue;
			case 82:
				if (instance.teamChat == null)
				{
					instance.teamChat = AppTeamChat.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChat.DeserializeLengthDelimited(stream, instance.teamChat, isDelta);
				}
				continue;
			case 90:
				if (instance.entityInfo == null)
				{
					instance.entityInfo = AppEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityInfo.DeserializeLengthDelimited(stream, instance.entityInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.flag == null)
				{
					instance.flag = AppFlag.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppFlag.DeserializeLengthDelimited(stream, instance.flag, isDelta);
				}
				continue;
			case 106:
				if (instance.mapMarkers == null)
				{
					instance.mapMarkers = AppMapMarkers.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMapMarkers.DeserializeLengthDelimited(stream, instance.mapMarkers, isDelta);
				}
				continue;
			case 122:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = AppClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.clanChat == null)
					{
						instance.clanChat = AppClanChat.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppClanChat.DeserializeLengthDelimited(stream, instance.clanChat, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.nexusAuth == null)
					{
						instance.nexusAuth = AppNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppNexusAuth.DeserializeLengthDelimited(stream, instance.nexusAuth, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribeInfo == null)
					{
						instance.cameraSubscribeInfo = AppCameraInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInfo.DeserializeLengthDelimited(stream, instance.cameraSubscribeInfo, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppResponse instance, AppResponse previous)
	{
		if (instance.seq != previous.seq)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seq);
		}
		if (instance.success != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			AppSuccess.SerializeDelta(stream, instance.success, previous.success);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field success (ProtoBuf.AppSuccess)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.error != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			AppError.SerializeDelta(stream, instance.error, previous.error);
			int val = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.info != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			AppInfo.SerializeDelta(stream, instance.info, previous.info);
			int val2 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val2, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
		if (instance.time != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			AppTime.SerializeDelta(stream, instance.time, previous.time);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field time (ProtoBuf.AppTime)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.map != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			AppMap.SerializeDelta(stream, instance.map, previous.map);
			int val3 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)val3, span5, 0);
			if (num5 < 5)
			{
				span5[num5 - 1] |= 128;
				while (num5 < 4)
				{
					span5[num5++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.teamInfo != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			AppTeamInfo.SerializeDelta(stream, instance.teamInfo, previous.teamInfo);
			int val4 = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val4, span6, 0);
			if (num6 < 5)
			{
				span6[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span6[num6++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.teamChat != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range7 = stream.GetRange(5);
			int position7 = stream.Position;
			AppTeamChat.SerializeDelta(stream, instance.teamChat, previous.teamChat);
			int val5 = stream.Position - position7;
			Span<byte> span7 = range7.GetSpan();
			int num7 = ProtocolParser.WriteUInt32((uint)val5, span7, 0);
			if (num7 < 5)
			{
				span7[num7 - 1] |= 128;
				while (num7 < 4)
				{
					span7[num7++] = 128;
				}
				span7[4] = 0;
			}
		}
		if (instance.entityInfo != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range8 = stream.GetRange(3);
			int position8 = stream.Position;
			AppEntityInfo.SerializeDelta(stream, instance.entityInfo, previous.entityInfo);
			int num8 = stream.Position - position8;
			if (num8 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entityInfo (ProtoBuf.AppEntityInfo)");
			}
			Span<byte> span8 = range8.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)num8, span8, 0);
			if (num9 < 3)
			{
				span8[num9 - 1] |= 128;
				while (num9 < 2)
				{
					span8[num9++] = 128;
				}
				span8[2] = 0;
			}
		}
		if (instance.flag != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AppFlag.SerializeDelta(stream, instance.flag, previous.flag);
			int num10 = stream.Position - position9;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field flag (ProtoBuf.AppFlag)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span9, 0);
		}
		if (instance.mapMarkers != null)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range10 = stream.GetRange(5);
			int position10 = stream.Position;
			AppMapMarkers.SerializeDelta(stream, instance.mapMarkers, previous.mapMarkers);
			int val6 = stream.Position - position10;
			Span<byte> span10 = range10.GetSpan();
			int num11 = ProtocolParser.WriteUInt32((uint)val6, span10, 0);
			if (num11 < 5)
			{
				span10[num11 - 1] |= 128;
				while (num11 < 4)
				{
					span10[num11++] = 128;
				}
				span10[4] = 0;
			}
		}
		if (instance.clanInfo != null)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range11 = stream.GetRange(5);
			int position11 = stream.Position;
			AppClanInfo.SerializeDelta(stream, instance.clanInfo, previous.clanInfo);
			int val7 = stream.Position - position11;
			Span<byte> span11 = range11.GetSpan();
			int num12 = ProtocolParser.WriteUInt32((uint)val7, span11, 0);
			if (num12 < 5)
			{
				span11[num12 - 1] |= 128;
				while (num12 < 4)
				{
					span11[num12++] = 128;
				}
				span11[4] = 0;
			}
		}
		if (instance.clanChat != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range12 = stream.GetRange(5);
			int position12 = stream.Position;
			AppClanChat.SerializeDelta(stream, instance.clanChat, previous.clanChat);
			int val8 = stream.Position - position12;
			Span<byte> span12 = range12.GetSpan();
			int num13 = ProtocolParser.WriteUInt32((uint)val8, span12, 0);
			if (num13 < 5)
			{
				span12[num13 - 1] |= 128;
				while (num13 < 4)
				{
					span12[num13++] = 128;
				}
				span12[4] = 0;
			}
		}
		if (instance.nexusAuth != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(1);
			BufferStream.RangeHandle range13 = stream.GetRange(5);
			int position13 = stream.Position;
			AppNexusAuth.SerializeDelta(stream, instance.nexusAuth, previous.nexusAuth);
			int val9 = stream.Position - position13;
			Span<byte> span13 = range13.GetSpan();
			int num14 = ProtocolParser.WriteUInt32((uint)val9, span13, 0);
			if (num14 < 5)
			{
				span13[num14 - 1] |= 128;
				while (num14 < 4)
				{
					span13[num14++] = 128;
				}
				span13[4] = 0;
			}
		}
		if (instance.cameraSubscribeInfo != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range14 = stream.GetRange(1);
			int position14 = stream.Position;
			AppCameraInfo.SerializeDelta(stream, instance.cameraSubscribeInfo, previous.cameraSubscribeInfo);
			int num15 = stream.Position - position14;
			if (num15 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraSubscribeInfo (ProtoBuf.AppCameraInfo)");
			}
			Span<byte> span14 = range14.GetSpan();
			ProtocolParser.WriteUInt32((uint)num15, span14, 0);
		}
	}

	public static void Serialize(BufferStream stream, AppResponse instance)
	{
		if (instance.seq != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seq);
		}
		if (instance.success != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			AppSuccess.Serialize(stream, instance.success);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field success (ProtoBuf.AppSuccess)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.error != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			AppError.Serialize(stream, instance.error);
			int val = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.info != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			AppInfo.Serialize(stream, instance.info);
			int val2 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val2, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
		if (instance.time != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			AppTime.Serialize(stream, instance.time);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field time (ProtoBuf.AppTime)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.map != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			AppMap.Serialize(stream, instance.map);
			int val3 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)val3, span5, 0);
			if (num5 < 5)
			{
				span5[num5 - 1] |= 128;
				while (num5 < 4)
				{
					span5[num5++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.teamInfo != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			AppTeamInfo.Serialize(stream, instance.teamInfo);
			int val4 = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val4, span6, 0);
			if (num6 < 5)
			{
				span6[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span6[num6++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.teamChat != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range7 = stream.GetRange(5);
			int position7 = stream.Position;
			AppTeamChat.Serialize(stream, instance.teamChat);
			int val5 = stream.Position - position7;
			Span<byte> span7 = range7.GetSpan();
			int num7 = ProtocolParser.WriteUInt32((uint)val5, span7, 0);
			if (num7 < 5)
			{
				span7[num7 - 1] |= 128;
				while (num7 < 4)
				{
					span7[num7++] = 128;
				}
				span7[4] = 0;
			}
		}
		if (instance.entityInfo != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range8 = stream.GetRange(3);
			int position8 = stream.Position;
			AppEntityInfo.Serialize(stream, instance.entityInfo);
			int num8 = stream.Position - position8;
			if (num8 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entityInfo (ProtoBuf.AppEntityInfo)");
			}
			Span<byte> span8 = range8.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)num8, span8, 0);
			if (num9 < 3)
			{
				span8[num9 - 1] |= 128;
				while (num9 < 2)
				{
					span8[num9++] = 128;
				}
				span8[2] = 0;
			}
		}
		if (instance.flag != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AppFlag.Serialize(stream, instance.flag);
			int num10 = stream.Position - position9;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field flag (ProtoBuf.AppFlag)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span9, 0);
		}
		if (instance.mapMarkers != null)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range10 = stream.GetRange(5);
			int position10 = stream.Position;
			AppMapMarkers.Serialize(stream, instance.mapMarkers);
			int val6 = stream.Position - position10;
			Span<byte> span10 = range10.GetSpan();
			int num11 = ProtocolParser.WriteUInt32((uint)val6, span10, 0);
			if (num11 < 5)
			{
				span10[num11 - 1] |= 128;
				while (num11 < 4)
				{
					span10[num11++] = 128;
				}
				span10[4] = 0;
			}
		}
		if (instance.clanInfo != null)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range11 = stream.GetRange(5);
			int position11 = stream.Position;
			AppClanInfo.Serialize(stream, instance.clanInfo);
			int val7 = stream.Position - position11;
			Span<byte> span11 = range11.GetSpan();
			int num12 = ProtocolParser.WriteUInt32((uint)val7, span11, 0);
			if (num12 < 5)
			{
				span11[num12 - 1] |= 128;
				while (num12 < 4)
				{
					span11[num12++] = 128;
				}
				span11[4] = 0;
			}
		}
		if (instance.clanChat != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range12 = stream.GetRange(5);
			int position12 = stream.Position;
			AppClanChat.Serialize(stream, instance.clanChat);
			int val8 = stream.Position - position12;
			Span<byte> span12 = range12.GetSpan();
			int num13 = ProtocolParser.WriteUInt32((uint)val8, span12, 0);
			if (num13 < 5)
			{
				span12[num13 - 1] |= 128;
				while (num13 < 4)
				{
					span12[num13++] = 128;
				}
				span12[4] = 0;
			}
		}
		if (instance.nexusAuth != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(1);
			BufferStream.RangeHandle range13 = stream.GetRange(5);
			int position13 = stream.Position;
			AppNexusAuth.Serialize(stream, instance.nexusAuth);
			int val9 = stream.Position - position13;
			Span<byte> span13 = range13.GetSpan();
			int num14 = ProtocolParser.WriteUInt32((uint)val9, span13, 0);
			if (num14 < 5)
			{
				span13[num14 - 1] |= 128;
				while (num14 < 4)
				{
					span13[num14++] = 128;
				}
				span13[4] = 0;
			}
		}
		if (instance.cameraSubscribeInfo != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range14 = stream.GetRange(1);
			int position14 = stream.Position;
			AppCameraInfo.Serialize(stream, instance.cameraSubscribeInfo);
			int num15 = stream.Position - position14;
			if (num15 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraSubscribeInfo (ProtoBuf.AppCameraInfo)");
			}
			Span<byte> span14 = range14.GetSpan();
			ProtocolParser.WriteUInt32((uint)num15, span14, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		success?.InspectUids(action);
		error?.InspectUids(action);
		info?.InspectUids(action);
		time?.InspectUids(action);
		map?.InspectUids(action);
		teamInfo?.InspectUids(action);
		teamChat?.InspectUids(action);
		entityInfo?.InspectUids(action);
		flag?.InspectUids(action);
		mapMarkers?.InspectUids(action);
		clanInfo?.InspectUids(action);
		clanChat?.InspectUids(action);
		nexusAuth?.InspectUids(action);
		cameraSubscribeInfo?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppBroadcast : IDisposable, IPooled, IProto<AppBroadcast>, IProto
{
	[NonSerialized]
	public AppTeamChanged teamChanged;

	[NonSerialized]
	public AppNewTeamMessage teamMessage;

	[NonSerialized]
	public AppEntityChanged entityChanged;

	[NonSerialized]
	public AppClanChanged clanChanged;

	[NonSerialized]
	public AppNewClanMessage clanMessage;

	[NonSerialized]
	public AppCameraRays cameraRays;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppBroadcast instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.teamChanged != null)
			{
				instance.teamChanged.ResetToPool();
				instance.teamChanged = null;
			}
			if (instance.teamMessage != null)
			{
				instance.teamMessage.ResetToPool();
				instance.teamMessage = null;
			}
			if (instance.entityChanged != null)
			{
				instance.entityChanged.ResetToPool();
				instance.entityChanged = null;
			}
			if (instance.clanChanged != null)
			{
				instance.clanChanged.ResetToPool();
				instance.clanChanged = null;
			}
			if (instance.clanMessage != null)
			{
				instance.clanMessage.ResetToPool();
				instance.clanMessage = null;
			}
			if (instance.cameraRays != null)
			{
				instance.cameraRays.ResetToPool();
				instance.cameraRays = null;
			}
			Pool.Free<AppBroadcast>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppBroadcast with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppBroadcast instance)
	{
		if (teamChanged != null)
		{
			if (instance.teamChanged == null)
			{
				instance.teamChanged = teamChanged.Copy();
			}
			else
			{
				teamChanged.CopyTo(instance.teamChanged);
			}
		}
		else
		{
			instance.teamChanged = null;
		}
		if (teamMessage != null)
		{
			if (instance.teamMessage == null)
			{
				instance.teamMessage = teamMessage.Copy();
			}
			else
			{
				teamMessage.CopyTo(instance.teamMessage);
			}
		}
		else
		{
			instance.teamMessage = null;
		}
		if (entityChanged != null)
		{
			if (instance.entityChanged == null)
			{
				instance.entityChanged = entityChanged.Copy();
			}
			else
			{
				entityChanged.CopyTo(instance.entityChanged);
			}
		}
		else
		{
			instance.entityChanged = null;
		}
		if (clanChanged != null)
		{
			if (instance.clanChanged == null)
			{
				instance.clanChanged = clanChanged.Copy();
			}
			else
			{
				clanChanged.CopyTo(instance.clanChanged);
			}
		}
		else
		{
			instance.clanChanged = null;
		}
		if (clanMessage != null)
		{
			if (instance.clanMessage == null)
			{
				instance.clanMessage = clanMessage.Copy();
			}
			else
			{
				clanMessage.CopyTo(instance.clanMessage);
			}
		}
		else
		{
			instance.clanMessage = null;
		}
		if (cameraRays != null)
		{
			if (instance.cameraRays == null)
			{
				instance.cameraRays = cameraRays.Copy();
			}
			else
			{
				cameraRays.CopyTo(instance.cameraRays);
			}
		}
		else
		{
			instance.cameraRays = null;
		}
	}

	public AppBroadcast Copy()
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		CopyTo(appBroadcast);
		return appBroadcast;
	}

	public static AppBroadcast Deserialize(BufferStream stream)
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		Deserialize(stream, appBroadcast, isDelta: false);
		return appBroadcast;
	}

	public static AppBroadcast DeserializeLengthDelimited(BufferStream stream)
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		DeserializeLengthDelimited(stream, appBroadcast, isDelta: false);
		return appBroadcast;
	}

	public static AppBroadcast DeserializeLength(BufferStream stream, int length)
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		DeserializeLength(stream, length, appBroadcast, isDelta: false);
		return appBroadcast;
	}

	public static AppBroadcast Deserialize(byte[] buffer)
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appBroadcast, isDelta: false);
		return appBroadcast;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppBroadcast previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppBroadcast Deserialize(BufferStream stream, AppBroadcast instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 34:
				if (instance.teamChanged == null)
				{
					instance.teamChanged = AppTeamChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChanged.DeserializeLengthDelimited(stream, instance.teamChanged, isDelta);
				}
				break;
			case 42:
				if (instance.teamMessage == null)
				{
					instance.teamMessage = AppNewTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewTeamMessage.DeserializeLengthDelimited(stream, instance.teamMessage, isDelta);
				}
				break;
			case 50:
				if (instance.entityChanged == null)
				{
					instance.entityChanged = AppEntityChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityChanged.DeserializeLengthDelimited(stream, instance.entityChanged, isDelta);
				}
				break;
			case 58:
				if (instance.clanChanged == null)
				{
					instance.clanChanged = AppClanChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanChanged.DeserializeLengthDelimited(stream, instance.clanChanged, isDelta);
				}
				break;
			case 66:
				if (instance.clanMessage == null)
				{
					instance.clanMessage = AppNewClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewClanMessage.DeserializeLengthDelimited(stream, instance.clanMessage, isDelta);
				}
				break;
			case 82:
				if (instance.cameraRays == null)
				{
					instance.cameraRays = AppCameraRays.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppCameraRays.DeserializeLengthDelimited(stream, instance.cameraRays, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppBroadcast DeserializeLengthDelimited(BufferStream stream, AppBroadcast instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 34:
				if (instance.teamChanged == null)
				{
					instance.teamChanged = AppTeamChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChanged.DeserializeLengthDelimited(stream, instance.teamChanged, isDelta);
				}
				break;
			case 42:
				if (instance.teamMessage == null)
				{
					instance.teamMessage = AppNewTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewTeamMessage.DeserializeLengthDelimited(stream, instance.teamMessage, isDelta);
				}
				break;
			case 50:
				if (instance.entityChanged == null)
				{
					instance.entityChanged = AppEntityChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityChanged.DeserializeLengthDelimited(stream, instance.entityChanged, isDelta);
				}
				break;
			case 58:
				if (instance.clanChanged == null)
				{
					instance.clanChanged = AppClanChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanChanged.DeserializeLengthDelimited(stream, instance.clanChanged, isDelta);
				}
				break;
			case 66:
				if (instance.clanMessage == null)
				{
					instance.clanMessage = AppNewClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewClanMessage.DeserializeLengthDelimited(stream, instance.clanMessage, isDelta);
				}
				break;
			case 82:
				if (instance.cameraRays == null)
				{
					instance.cameraRays = AppCameraRays.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppCameraRays.DeserializeLengthDelimited(stream, instance.cameraRays, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppBroadcast DeserializeLength(BufferStream stream, int length, AppBroadcast instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 34:
				if (instance.teamChanged == null)
				{
					instance.teamChanged = AppTeamChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChanged.DeserializeLengthDelimited(stream, instance.teamChanged, isDelta);
				}
				break;
			case 42:
				if (instance.teamMessage == null)
				{
					instance.teamMessage = AppNewTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewTeamMessage.DeserializeLengthDelimited(stream, instance.teamMessage, isDelta);
				}
				break;
			case 50:
				if (instance.entityChanged == null)
				{
					instance.entityChanged = AppEntityChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityChanged.DeserializeLengthDelimited(stream, instance.entityChanged, isDelta);
				}
				break;
			case 58:
				if (instance.clanChanged == null)
				{
					instance.clanChanged = AppClanChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanChanged.DeserializeLengthDelimited(stream, instance.clanChanged, isDelta);
				}
				break;
			case 66:
				if (instance.clanMessage == null)
				{
					instance.clanMessage = AppNewClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewClanMessage.DeserializeLengthDelimited(stream, instance.clanMessage, isDelta);
				}
				break;
			case 82:
				if (instance.cameraRays == null)
				{
					instance.cameraRays = AppCameraRays.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppCameraRays.DeserializeLengthDelimited(stream, instance.cameraRays, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppBroadcast instance, AppBroadcast previous)
	{
		if (instance.teamChanged != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppTeamChanged.SerializeDelta(stream, instance.teamChanged, previous.teamChanged);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.teamMessage != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			AppNewTeamMessage.SerializeDelta(stream, instance.teamMessage, previous.teamMessage);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.entityChanged != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(3);
			int position3 = stream.Position;
			AppEntityChanged.SerializeDelta(stream, instance.entityChanged, previous.entityChanged);
			int num3 = stream.Position - position3;
			if (num3 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entityChanged (ProtoBuf.AppEntityChanged)");
			}
			Span<byte> span3 = range3.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			if (num4 < 3)
			{
				span3[num4 - 1] |= 128;
				while (num4 < 2)
				{
					span3[num4++] = 128;
				}
				span3[2] = 0;
			}
		}
		if (instance.clanChanged != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			AppClanChanged.SerializeDelta(stream, instance.clanChanged, previous.clanChanged);
			int val3 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)val3, span4, 0);
			if (num5 < 5)
			{
				span4[num5 - 1] |= 128;
				while (num5 < 4)
				{
					span4[num5++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.clanMessage != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			AppNewClanMessage.SerializeDelta(stream, instance.clanMessage, previous.clanMessage);
			int val4 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val4, span5, 0);
			if (num6 < 5)
			{
				span5[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span5[num6++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.cameraRays == null)
		{
			return;
		}
		stream.WriteByte(82);
		BufferStream.RangeHandle range6 = stream.GetRange(5);
		int position6 = stream.Position;
		AppCameraRays.SerializeDelta(stream, instance.cameraRays, previous.cameraRays);
		int val5 = stream.Position - position6;
		Span<byte> span6 = range6.GetSpan();
		int num7 = ProtocolParser.WriteUInt32((uint)val5, span6, 0);
		if (num7 < 5)
		{
			span6[num7 - 1] |= 128;
			while (num7 < 4)
			{
				span6[num7++] = 128;
			}
			span6[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppBroadcast instance)
	{
		if (instance.teamChanged != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppTeamChanged.Serialize(stream, instance.teamChanged);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.teamMessage != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			AppNewTeamMessage.Serialize(stream, instance.teamMessage);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.entityChanged != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(3);
			int position3 = stream.Position;
			AppEntityChanged.Serialize(stream, instance.entityChanged);
			int num3 = stream.Position - position3;
			if (num3 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entityChanged (ProtoBuf.AppEntityChanged)");
			}
			Span<byte> span3 = range3.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			if (num4 < 3)
			{
				span3[num4 - 1] |= 128;
				while (num4 < 2)
				{
					span3[num4++] = 128;
				}
				span3[2] = 0;
			}
		}
		if (instance.clanChanged != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			AppClanChanged.Serialize(stream, instance.clanChanged);
			int val3 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)val3, span4, 0);
			if (num5 < 5)
			{
				span4[num5 - 1] |= 128;
				while (num5 < 4)
				{
					span4[num5++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.clanMessage != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			AppNewClanMessage.Serialize(stream, instance.clanMessage);
			int val4 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val4, span5, 0);
			if (num6 < 5)
			{
				span5[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span5[num6++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.cameraRays == null)
		{
			return;
		}
		stream.WriteByte(82);
		BufferStream.RangeHandle range6 = stream.GetRange(5);
		int position6 = stream.Position;
		AppCameraRays.Serialize(stream, instance.cameraRays);
		int val5 = stream.Position - position6;
		Span<byte> span6 = range6.GetSpan();
		int num7 = ProtocolParser.WriteUInt32((uint)val5, span6, 0);
		if (num7 < 5)
		{
			span6[num7 - 1] |= 128;
			while (num7 < 4)
			{
				span6[num7++] = 128;
			}
			span6[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		teamChanged?.InspectUids(action);
		teamMessage?.InspectUids(action);
		entityChanged?.InspectUids(action);
		clanChanged?.InspectUids(action);
		clanMessage?.InspectUids(action);
		cameraRays?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppEmpty : IDisposable, IPooled, IProto<AppEmpty>, IProto
{
	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppEmpty instance)
	{
		if (instance.ShouldPool)
		{
			Pool.Free<AppEmpty>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppEmpty with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppEmpty instance)
	{
	}

	public AppEmpty Copy()
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		CopyTo(appEmpty);
		return appEmpty;
	}

	public static AppEmpty Deserialize(BufferStream stream)
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		Deserialize(stream, appEmpty, isDelta: false);
		return appEmpty;
	}

	public static AppEmpty DeserializeLengthDelimited(BufferStream stream)
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		DeserializeLengthDelimited(stream, appEmpty, isDelta: false);
		return appEmpty;
	}

	public static AppEmpty DeserializeLength(BufferStream stream, int length)
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		DeserializeLength(stream, length, appEmpty, isDelta: false);
		return appEmpty;
	}

	public static AppEmpty Deserialize(byte[] buffer)
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appEmpty, isDelta: false);
		return appEmpty;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppEmpty previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppEmpty Deserialize(BufferStream stream, AppEmpty instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1 || num == 0)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static AppEmpty DeserializeLengthDelimited(BufferStream stream, AppEmpty instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static AppEmpty DeserializeLength(BufferStream stream, int length, AppEmpty instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppEmpty instance, AppEmpty previous)
	{
	}

	public static void Serialize(BufferStream stream, AppEmpty instance)
	{
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppSendMessage : IDisposable, IPooled, IProto<AppSendMessage>, IProto
{
	[NonSerialized]
	public string message;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppSendMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.message = string.Empty;
			Pool.Free<AppSendMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppSendMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppSendMessage instance)
	{
		instance.message = message;
	}

	public AppSendMessage Copy()
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		CopyTo(appSendMessage);
		return appSendMessage;
	}

	public static AppSendMessage Deserialize(BufferStream stream)
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		Deserialize(stream, appSendMessage, isDelta: false);
		return appSendMessage;
	}

	public static AppSendMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		DeserializeLengthDelimited(stream, appSendMessage, isDelta: false);
		return appSendMessage;
	}

	public static AppSendMessage DeserializeLength(BufferStream stream, int length)
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		DeserializeLength(stream, length, appSendMessage, isDelta: false);
		return appSendMessage;
	}

	public static AppSendMessage Deserialize(byte[] buffer)
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appSendMessage, isDelta: false);
		return appSendMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppSendMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppSendMessage Deserialize(BufferStream stream, AppSendMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppSendMessage DeserializeLengthDelimited(BufferStream stream, AppSendMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppSendMessage DeserializeLength(BufferStream stream, int length, AppSendMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppSendMessage instance, AppSendMessage previous)
	{
		if (instance.message != previous.message)
		{
			if (instance.message == null)
			{
				throw new ArgumentNullException("message", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.message);
		}
	}

	public static void Serialize(BufferStream stream, AppSendMessage instance)
	{
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.message);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppSetEntityValue : IDisposable, IPooled, IProto<AppSetEntityValue>, IProto
{
	[NonSerialized]
	public bool value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppSetEntityValue instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = false;
			Pool.Free<AppSetEntityValue>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppSetEntityValue with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppSetEntityValue instance)
	{
		instance.value = value;
	}

	public AppSetEntityValue Copy()
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		CopyTo(appSetEntityValue);
		return appSetEntityValue;
	}

	public static AppSetEntityValue Deserialize(BufferStream stream)
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		Deserialize(stream, appSetEntityValue, isDelta: false);
		return appSetEntityValue;
	}

	public static AppSetEntityValue DeserializeLengthDelimited(BufferStream stream)
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		DeserializeLengthDelimited(stream, appSetEntityValue, isDelta: false);
		return appSetEntityValue;
	}

	public static AppSetEntityValue DeserializeLength(BufferStream stream, int length)
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		DeserializeLength(stream, length, appSetEntityValue, isDelta: false);
		return appSetEntityValue;
	}

	public static AppSetEntityValue Deserialize(byte[] buffer)
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appSetEntityValue, isDelta: false);
		return appSetEntityValue;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppSetEntityValue previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppSetEntityValue Deserialize(BufferStream stream, AppSetEntityValue instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppSetEntityValue DeserializeLengthDelimited(BufferStream stream, AppSetEntityValue instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppSetEntityValue DeserializeLength(BufferStream stream, int length, AppSetEntityValue instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppSetEntityValue instance, AppSetEntityValue previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.value);
	}

	public static void Serialize(BufferStream stream, AppSetEntityValue instance)
	{
		if (instance.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppPromoteToLeader : IDisposable, IPooled, IProto<AppPromoteToLeader>, IProto
{
	[NonSerialized]
	public ulong steamId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppPromoteToLeader instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			Pool.Free<AppPromoteToLeader>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppPromoteToLeader with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppPromoteToLeader instance)
	{
		instance.steamId = steamId;
	}

	public AppPromoteToLeader Copy()
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		CopyTo(appPromoteToLeader);
		return appPromoteToLeader;
	}

	public static AppPromoteToLeader Deserialize(BufferStream stream)
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		Deserialize(stream, appPromoteToLeader, isDelta: false);
		return appPromoteToLeader;
	}

	public static AppPromoteToLeader DeserializeLengthDelimited(BufferStream stream)
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		DeserializeLengthDelimited(stream, appPromoteToLeader, isDelta: false);
		return appPromoteToLeader;
	}

	public static AppPromoteToLeader DeserializeLength(BufferStream stream, int length)
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		DeserializeLength(stream, length, appPromoteToLeader, isDelta: false);
		return appPromoteToLeader;
	}

	public static AppPromoteToLeader Deserialize(byte[] buffer)
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appPromoteToLeader, isDelta: false);
		return appPromoteToLeader;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppPromoteToLeader previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppPromoteToLeader Deserialize(BufferStream stream, AppPromoteToLeader instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppPromoteToLeader DeserializeLengthDelimited(BufferStream stream, AppPromoteToLeader instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppPromoteToLeader DeserializeLength(BufferStream stream, int length, AppPromoteToLeader instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppPromoteToLeader instance, AppPromoteToLeader previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
	}

	public static void Serialize(BufferStream stream, AppPromoteToLeader instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppGetNexusAuth : IDisposable, IPooled, IProto<AppGetNexusAuth>, IProto
{
	[NonSerialized]
	public string appKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppGetNexusAuth instance)
	{
		if (instance.ShouldPool)
		{
			instance.appKey = string.Empty;
			Pool.Free<AppGetNexusAuth>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppGetNexusAuth with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppGetNexusAuth instance)
	{
		instance.appKey = appKey;
	}

	public AppGetNexusAuth Copy()
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		CopyTo(appGetNexusAuth);
		return appGetNexusAuth;
	}

	public static AppGetNexusAuth Deserialize(BufferStream stream)
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		Deserialize(stream, appGetNexusAuth, isDelta: false);
		return appGetNexusAuth;
	}

	public static AppGetNexusAuth DeserializeLengthDelimited(BufferStream stream)
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		DeserializeLengthDelimited(stream, appGetNexusAuth, isDelta: false);
		return appGetNexusAuth;
	}

	public static AppGetNexusAuth DeserializeLength(BufferStream stream, int length)
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		DeserializeLength(stream, length, appGetNexusAuth, isDelta: false);
		return appGetNexusAuth;
	}

	public static AppGetNexusAuth Deserialize(byte[] buffer)
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appGetNexusAuth, isDelta: false);
		return appGetNexusAuth;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppGetNexusAuth previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppGetNexusAuth Deserialize(BufferStream stream, AppGetNexusAuth instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.appKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppGetNexusAuth DeserializeLengthDelimited(BufferStream stream, AppGetNexusAuth instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.appKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppGetNexusAuth DeserializeLength(BufferStream stream, int length, AppGetNexusAuth instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.appKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppGetNexusAuth instance, AppGetNexusAuth previous)
	{
		if (instance.appKey != previous.appKey)
		{
			if (instance.appKey == null)
			{
				throw new ArgumentNullException("appKey", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.appKey);
		}
	}

	public static void Serialize(BufferStream stream, AppGetNexusAuth instance)
	{
		if (instance.appKey == null)
		{
			throw new ArgumentNullException("appKey", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.appKey);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppCameraSubscribe : IDisposable, IPooled, IProto<AppCameraSubscribe>, IProto
{
	[NonSerialized]
	public string cameraId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppCameraSubscribe instance)
	{
		if (instance.ShouldPool)
		{
			instance.cameraId = string.Empty;
			Pool.Free<AppCameraSubscribe>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppCameraSubscribe with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppCameraSubscribe instance)
	{
		instance.cameraId = cameraId;
	}

	public AppCameraSubscribe Copy()
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		CopyTo(appCameraSubscribe);
		return appCameraSubscribe;
	}

	public static AppCameraSubscribe Deserialize(BufferStream stream)
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		Deserialize(stream, appCameraSubscribe, isDelta: false);
		return appCameraSubscribe;
	}

	public static AppCameraSubscribe DeserializeLengthDelimited(BufferStream stream)
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		DeserializeLengthDelimited(stream, appCameraSubscribe, isDelta: false);
		return appCameraSubscribe;
	}

	public static AppCameraSubscribe DeserializeLength(BufferStream stream, int length)
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		DeserializeLength(stream, length, appCameraSubscribe, isDelta: false);
		return appCameraSubscribe;
	}

	public static AppCameraSubscribe Deserialize(byte[] buffer)
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appCameraSubscribe, isDelta: false);
		return appCameraSubscribe;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppCameraSubscribe previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppCameraSubscribe Deserialize(BufferStream stream, AppCameraSubscribe instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.cameraId = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppCameraSubscribe DeserializeLengthDelimited(BufferStream stream, AppCameraSubscribe instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.cameraId = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppCameraSubscribe DeserializeLength(BufferStream stream, int length, AppCameraSubscribe instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.cameraId = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppCameraSubscribe instance, AppCameraSubscribe previous)
	{
		if (instance.cameraId != previous.cameraId)
		{
			if (instance.cameraId == null)
			{
				throw new ArgumentNullException("cameraId", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.cameraId);
		}
	}

	public static void Serialize(BufferStream stream, AppCameraSubscribe instance)
	{
		if (instance.cameraId == null)
		{
			throw new ArgumentNullException("cameraId", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.cameraId);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class AppCameraInput : IDisposable, IPooled, IProto<AppCameraInput>, IProto
{
	[NonSerialized]
	public int buttons;

	[NonSerialized]
	public Vector2 mouseDelta;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppCameraInput instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.buttons = 0;
			instance.mouseDelta = default(Vector2);
			Pool.Free<AppCameraInput>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppCameraInput with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppCameraInput instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.buttons = buttons;
		instance.mouseDelta = mouseDelta;
	}

	public AppCameraInput Copy()
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		CopyTo(appCameraInput);
		return appCameraInput;
	}

	public static AppCameraInput Deserialize(BufferStream stream)
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		Deserialize(stream, appCameraInput, isDelta: false);
		return appCameraInput;
	}

	public static AppCameraInput DeserializeLengthDelimited(BufferStream stream)
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		DeserializeLengthDelimited(stream, appCameraInput, isDelta: false);
		return appCameraInput;
	}

	public static AppCameraInput DeserializeLength(BufferStream stream, int length)
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		DeserializeLength(stream, length, appCameraInput, isDelta: false);
		return appCameraInput;
	}

	public static AppCameraInput Deserialize(byte[] buffer)
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appCameraInput, isDelta: false);
		return appCameraInput;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppCameraInput previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppCameraInput Deserialize(BufferStream stream, AppCameraInput instance, bool isDelta)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.buttons = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppCameraInput DeserializeLengthDelimited(BufferStream stream, AppCameraInput instance, bool isDelta)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.buttons = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppCameraInput DeserializeLength(BufferStream stream, int length, AppCameraInput instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.buttons = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppCameraInput instance, AppCameraInput previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.buttons != previous.buttons)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.buttons);
		}
		if (instance.mouseDelta != previous.mouseDelta)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector2Serialized.SerializeDelta(stream, instance.mouseDelta, previous.mouseDelta);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mouseDelta (UnityEngine.Vector2)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, AppCameraInput instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.buttons != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.buttons);
		}
		if (instance.mouseDelta != default(Vector2))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector2Serialized.Serialize(stream, instance.mouseDelta);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mouseDelta (UnityEngine.Vector2)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppSuccess : IDisposable, IPooled, IProto<AppSuccess>, IProto
{
	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppSuccess instance)
	{
		if (instance.ShouldPool)
		{
			Pool.Free<AppSuccess>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppSuccess with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppSuccess instance)
	{
	}

	public AppSuccess Copy()
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		CopyTo(appSuccess);
		return appSuccess;
	}

	public static AppSuccess Deserialize(BufferStream stream)
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		Deserialize(stream, appSuccess, isDelta: false);
		return appSuccess;
	}

	public static AppSuccess DeserializeLengthDelimited(BufferStream stream)
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		DeserializeLengthDelimited(stream, appSuccess, isDelta: false);
		return appSuccess;
	}

	public static AppSuccess DeserializeLength(BufferStream stream, int length)
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		DeserializeLength(stream, length, appSuccess, isDelta: false);
		return appSuccess;
	}

	public static AppSuccess Deserialize(byte[] buffer)
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appSuccess, isDelta: false);
		return appSuccess;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppSuccess previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppSuccess Deserialize(BufferStream stream, AppSuccess instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1 || num == 0)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static AppSuccess DeserializeLengthDelimited(BufferStream stream, AppSuccess instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static AppSuccess DeserializeLength(BufferStream stream, int length, AppSuccess instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppSuccess instance, AppSuccess previous)
	{
	}

	public static void Serialize(BufferStream stream, AppSuccess instance)
	{
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppError : IDisposable, IPooled, IProto<AppError>, IProto
{
	[NonSerialized]
	public string error;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppError instance)
	{
		if (instance.ShouldPool)
		{
			instance.error = string.Empty;
			Pool.Free<AppError>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppError with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppError instance)
	{
		instance.error = error;
	}

	public AppError Copy()
	{
		AppError appError = Pool.Get<AppError>();
		CopyTo(appError);
		return appError;
	}

	public static AppError Deserialize(BufferStream stream)
	{
		AppError appError = Pool.Get<AppError>();
		Deserialize(stream, appError, isDelta: false);
		return appError;
	}

	public static AppError DeserializeLengthDelimited(BufferStream stream)
	{
		AppError appError = Pool.Get<AppError>();
		DeserializeLengthDelimited(stream, appError, isDelta: false);
		return appError;
	}

	public static AppError DeserializeLength(BufferStream stream, int length)
	{
		AppError appError = Pool.Get<AppError>();
		DeserializeLength(stream, length, appError, isDelta: false);
		return appError;
	}

	public static AppError Deserialize(byte[] buffer)
	{
		AppError appError = Pool.Get<AppError>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appError, isDelta: false);
		return appError;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppError previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppError Deserialize(BufferStream stream, AppError instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.error = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppError DeserializeLengthDelimited(BufferStream stream, AppError instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.error = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppError DeserializeLength(BufferStream stream, int length, AppError instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.error = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppError instance, AppError previous)
	{
		if (instance.error != previous.error)
		{
			if (instance.error == null)
			{
				throw new ArgumentNullException("error", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.error);
		}
	}

	public static void Serialize(BufferStream stream, AppError instance)
	{
		if (instance.error == null)
		{
			throw new ArgumentNullException("error", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.error);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppFlag : IDisposable, IPooled, IProto<AppFlag>, IProto
{
	[NonSerialized]
	public bool value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppFlag instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = false;
			Pool.Free<AppFlag>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppFlag with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppFlag instance)
	{
		instance.value = value;
	}

	public AppFlag Copy()
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		CopyTo(appFlag);
		return appFlag;
	}

	public static AppFlag Deserialize(BufferStream stream)
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		Deserialize(stream, appFlag, isDelta: false);
		return appFlag;
	}

	public static AppFlag DeserializeLengthDelimited(BufferStream stream)
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		DeserializeLengthDelimited(stream, appFlag, isDelta: false);
		return appFlag;
	}

	public static AppFlag DeserializeLength(BufferStream stream, int length)
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		DeserializeLength(stream, length, appFlag, isDelta: false);
		return appFlag;
	}

	public static AppFlag Deserialize(byte[] buffer)
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appFlag, isDelta: false);
		return appFlag;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppFlag previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppFlag Deserialize(BufferStream stream, AppFlag instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppFlag DeserializeLengthDelimited(BufferStream stream, AppFlag instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppFlag DeserializeLength(BufferStream stream, int length, AppFlag instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppFlag instance, AppFlag previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.value);
	}

	public static void Serialize(BufferStream stream, AppFlag instance)
	{
		if (instance.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppInfo : IDisposable, IPooled, IProto<AppInfo>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public string headerImage;

	[NonSerialized]
	public string url;

	[NonSerialized]
	public string map;

	[NonSerialized]
	public uint mapSize;

	[NonSerialized]
	public uint wipeTime;

	[NonSerialized]
	public uint players;

	[NonSerialized]
	public uint maxPlayers;

	[NonSerialized]
	public uint queuedPlayers;

	[NonSerialized]
	public uint seed;

	[NonSerialized]
	public uint salt;

	[NonSerialized]
	public string logoImage;

	[NonSerialized]
	public string nexus;

	[NonSerialized]
	public int nexusId;

	[NonSerialized]
	public string nexusZone;

	[NonSerialized]
	public bool camerasEnabled;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.headerImage = string.Empty;
			instance.url = string.Empty;
			instance.map = string.Empty;
			instance.mapSize = 0u;
			instance.wipeTime = 0u;
			instance.players = 0u;
			instance.maxPlayers = 0u;
			instance.queuedPlayers = 0u;
			instance.seed = 0u;
			instance.salt = 0u;
			instance.logoImage = string.Empty;
			instance.nexus = string.Empty;
			instance.nexusId = 0;
			instance.nexusZone = string.Empty;
			instance.camerasEnabled = false;
			Pool.Free<AppInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppInfo instance)
	{
		instance.name = name;
		instance.headerImage = headerImage;
		instance.url = url;
		instance.map = map;
		instance.mapSize = mapSize;
		instance.wipeTime = wipeTime;
		instance.players = players;
		instance.maxPlayers = maxPlayers;
		instance.queuedPlayers = queuedPlayers;
		instance.seed = seed;
		instance.salt = salt;
		instance.logoImage = logoImage;
		instance.nexus = nexus;
		instance.nexusId = nexusId;
		instance.nexusZone = nexusZone;
		instance.camerasEnabled = camerasEnabled;
	}

	public AppInfo Copy()
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		CopyTo(appInfo);
		return appInfo;
	}

	public static AppInfo Deserialize(BufferStream stream)
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		Deserialize(stream, appInfo, isDelta: false);
		return appInfo;
	}

	public static AppInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		DeserializeLengthDelimited(stream, appInfo, isDelta: false);
		return appInfo;
	}

	public static AppInfo DeserializeLength(BufferStream stream, int length)
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		DeserializeLength(stream, length, appInfo, isDelta: false);
		return appInfo;
	}

	public static AppInfo Deserialize(byte[] buffer)
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appInfo, isDelta: false);
		return appInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppInfo Deserialize(BufferStream stream, AppInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.mapSize = 0u;
			instance.wipeTime = 0u;
			instance.players = 0u;
			instance.maxPlayers = 0u;
			instance.queuedPlayers = 0u;
			instance.seed = 0u;
			instance.salt = 0u;
			instance.nexusId = 0;
			instance.camerasEnabled = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.headerImage = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.url = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.map = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.mapSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.wipeTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.players = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.maxPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.queuedPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.salt = ProtocolParser.ReadUInt32(stream);
				continue;
			case 98:
				instance.logoImage = ProtocolParser.ReadString(stream);
				continue;
			case 106:
				instance.nexus = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.camerasEnabled = ProtocolParser.ReadBool(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static AppInfo DeserializeLengthDelimited(BufferStream stream, AppInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.mapSize = 0u;
			instance.wipeTime = 0u;
			instance.players = 0u;
			instance.maxPlayers = 0u;
			instance.queuedPlayers = 0u;
			instance.seed = 0u;
			instance.salt = 0u;
			instance.nexusId = 0;
			instance.camerasEnabled = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.headerImage = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.url = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.map = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.mapSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.wipeTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.players = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.maxPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.queuedPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.salt = ProtocolParser.ReadUInt32(stream);
				continue;
			case 98:
				instance.logoImage = ProtocolParser.ReadString(stream);
				continue;
			case 106:
				instance.nexus = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.camerasEnabled = ProtocolParser.ReadBool(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppInfo DeserializeLength(BufferStream stream, int length, AppInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.mapSize = 0u;
			instance.wipeTime = 0u;
			instance.players = 0u;
			instance.maxPlayers = 0u;
			instance.queuedPlayers = 0u;
			instance.seed = 0u;
			instance.salt = 0u;
			instance.nexusId = 0;
			instance.camerasEnabled = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.headerImage = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.url = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.map = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.mapSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.wipeTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.players = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.maxPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.queuedPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.salt = ProtocolParser.ReadUInt32(stream);
				continue;
			case 98:
				instance.logoImage = ProtocolParser.ReadString(stream);
				continue;
			case 106:
				instance.nexus = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.camerasEnabled = ProtocolParser.ReadBool(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppInfo instance, AppInfo previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.headerImage != previous.headerImage)
		{
			if (instance.headerImage == null)
			{
				throw new ArgumentNullException("headerImage", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.headerImage);
		}
		if (instance.url != previous.url)
		{
			if (instance.url == null)
			{
				throw new ArgumentNullException("url", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.url);
		}
		if (instance.map != previous.map)
		{
			if (instance.map == null)
			{
				throw new ArgumentNullException("map", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.map);
		}
		if (instance.mapSize != previous.mapSize)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.mapSize);
		}
		if (instance.wipeTime != previous.wipeTime)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.wipeTime);
		}
		if (instance.players != previous.players)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.players);
		}
		if (instance.maxPlayers != previous.maxPlayers)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.maxPlayers);
		}
		if (instance.queuedPlayers != previous.queuedPlayers)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.queuedPlayers);
		}
		if (instance.seed != previous.seed)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.salt != previous.salt)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt32(stream, instance.salt);
		}
		if (instance.logoImage != null && instance.logoImage != previous.logoImage)
		{
			stream.WriteByte(98);
			ProtocolParser.WriteString(stream, instance.logoImage);
		}
		if (instance.nexus != null && instance.nexus != previous.nexus)
		{
			stream.WriteByte(106);
			ProtocolParser.WriteString(stream, instance.nexus);
		}
		if (instance.nexusId != previous.nexusId)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nexusId);
		}
		if (instance.nexusZone != null && instance.nexusZone != previous.nexusZone)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		stream.WriteByte(128);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.camerasEnabled);
	}

	public static void Serialize(BufferStream stream, AppInfo instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.headerImage == null)
		{
			throw new ArgumentNullException("headerImage", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.headerImage);
		if (instance.url == null)
		{
			throw new ArgumentNullException("url", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.url);
		if (instance.map == null)
		{
			throw new ArgumentNullException("map", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteString(stream, instance.map);
		if (instance.mapSize != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.mapSize);
		}
		if (instance.wipeTime != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.wipeTime);
		}
		if (instance.players != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.players);
		}
		if (instance.maxPlayers != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.maxPlayers);
		}
		if (instance.queuedPlayers != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.queuedPlayers);
		}
		if (instance.seed != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.salt != 0)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt32(stream, instance.salt);
		}
		if (instance.logoImage != null)
		{
			stream.WriteByte(98);
			ProtocolParser.WriteString(stream, instance.logoImage);
		}
		if (instance.nexus != null)
		{
			stream.WriteByte(106);
			ProtocolParser.WriteString(stream, instance.nexus);
		}
		if (instance.nexusId != 0)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nexusId);
		}
		if (instance.nexusZone != null)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		if (instance.camerasEnabled)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.camerasEnabled);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTime : IDisposable, IPooled, IProto<AppTime>, IProto
{
	[NonSerialized]
	public float dayLengthMinutes;

	[NonSerialized]
	public float timeScale;

	[NonSerialized]
	public float sunrise;

	[NonSerialized]
	public float sunset;

	[NonSerialized]
	public float time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTime instance)
	{
		if (instance.ShouldPool)
		{
			instance.dayLengthMinutes = 0f;
			instance.timeScale = 0f;
			instance.sunrise = 0f;
			instance.sunset = 0f;
			instance.time = 0f;
			Pool.Free<AppTime>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTime with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTime instance)
	{
		instance.dayLengthMinutes = dayLengthMinutes;
		instance.timeScale = timeScale;
		instance.sunrise = sunrise;
		instance.sunset = sunset;
		instance.time = time;
	}

	public AppTime Copy()
	{
		AppTime appTime = Pool.Get<AppTime>();
		CopyTo(appTime);
		return appTime;
	}

	public static AppTime Deserialize(BufferStream stream)
	{
		AppTime appTime = Pool.Get<AppTime>();
		Deserialize(stream, appTime, isDelta: false);
		return appTime;
	}

	public static AppTime DeserializeLengthDelimited(BufferStream stream)
	{
		AppTime appTime = Pool.Get<AppTime>();
		DeserializeLengthDelimited(stream, appTime, isDelta: false);
		return appTime;
	}

	public static AppTime DeserializeLength(BufferStream stream, int length)
	{
		AppTime appTime = Pool.Get<AppTime>();
		DeserializeLength(stream, length, appTime, isDelta: false);
		return appTime;
	}

	public static AppTime Deserialize(byte[] buffer)
	{
		AppTime appTime = Pool.Get<AppTime>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTime, isDelta: false);
		return appTime;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTime previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTime Deserialize(BufferStream stream, AppTime instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.dayLengthMinutes = 0f;
			instance.timeScale = 0f;
			instance.sunrise = 0f;
			instance.sunset = 0f;
			instance.time = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.dayLengthMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.timeScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.sunrise = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunset = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppTime DeserializeLengthDelimited(BufferStream stream, AppTime instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.dayLengthMinutes = 0f;
			instance.timeScale = 0f;
			instance.sunrise = 0f;
			instance.sunset = 0f;
			instance.time = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.dayLengthMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.timeScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.sunrise = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunset = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTime DeserializeLength(BufferStream stream, int length, AppTime instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.dayLengthMinutes = 0f;
			instance.timeScale = 0f;
			instance.sunrise = 0f;
			instance.sunset = 0f;
			instance.time = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.dayLengthMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.timeScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.sunrise = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunset = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTime instance, AppTime previous)
	{
		if (instance.dayLengthMinutes != previous.dayLengthMinutes)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.dayLengthMinutes);
		}
		if (instance.timeScale != previous.timeScale)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeScale);
		}
		if (instance.sunrise != previous.sunrise)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.sunrise);
		}
		if (instance.sunset != previous.sunset)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.sunset);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public static void Serialize(BufferStream stream, AppTime instance)
	{
		if (instance.dayLengthMinutes != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.dayLengthMinutes);
		}
		if (instance.timeScale != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeScale);
		}
		if (instance.sunrise != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.sunrise);
		}
		if (instance.sunset != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.sunset);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppMap : IDisposable, IPooled, IProto<AppMap>, IProto
{
	public class Monument : IDisposable, IPooled, IProto<Monument>, IProto
	{
		[NonSerialized]
		public string token;

		[NonSerialized]
		public float x;

		[NonSerialized]
		public float y;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Monument instance)
		{
			if (instance.ShouldPool)
			{
				instance.token = string.Empty;
				instance.x = 0f;
				instance.y = 0f;
				Pool.Free<Monument>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Monument with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Monument instance)
		{
			instance.token = token;
			instance.x = x;
			instance.y = y;
		}

		public Monument Copy()
		{
			Monument monument = Pool.Get<Monument>();
			CopyTo(monument);
			return monument;
		}

		public static Monument Deserialize(BufferStream stream)
		{
			Monument monument = Pool.Get<Monument>();
			Deserialize(stream, monument, isDelta: false);
			return monument;
		}

		public static Monument DeserializeLengthDelimited(BufferStream stream)
		{
			Monument monument = Pool.Get<Monument>();
			DeserializeLengthDelimited(stream, monument, isDelta: false);
			return monument;
		}

		public static Monument DeserializeLength(BufferStream stream, int length)
		{
			Monument monument = Pool.Get<Monument>();
			DeserializeLength(stream, length, monument, isDelta: false);
			return monument;
		}

		public static Monument Deserialize(byte[] buffer)
		{
			Monument monument = Pool.Get<Monument>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, monument, isDelta: false);
			return monument;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Monument previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Monument Deserialize(BufferStream stream, Monument instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.x = 0f;
				instance.y = 0f;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.token = ProtocolParser.ReadString(stream);
					continue;
				case 21:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 29:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Monument DeserializeLengthDelimited(BufferStream stream, Monument instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.x = 0f;
				instance.y = 0f;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.token = ProtocolParser.ReadString(stream);
					continue;
				case 21:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 29:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Monument DeserializeLength(BufferStream stream, int length, Monument instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.x = 0f;
				instance.y = 0f;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.token = ProtocolParser.ReadString(stream);
					continue;
				case 21:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 29:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Monument instance, Monument previous)
		{
			if (instance.token != previous.token)
			{
				if (instance.token == null)
				{
					throw new ArgumentNullException("token", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.token);
			}
			if (instance.x != previous.x)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != previous.y)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
		}

		public static void Serialize(BufferStream stream, Monument instance)
		{
			if (instance.token == null)
			{
				throw new ArgumentNullException("token", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.token);
			if (instance.x != 0f)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public uint width;

	[NonSerialized]
	public uint height;

	[NonSerialized]
	public byte[] jpgImage;

	[NonSerialized]
	public int oceanMargin;

	[NonSerialized]
	public List<Monument> monuments;

	[NonSerialized]
	public string background;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppMap instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.width = 0u;
		instance.height = 0u;
		instance.jpgImage = null;
		instance.oceanMargin = 0;
		if (instance.monuments != null)
		{
			for (int i = 0; i < instance.monuments.Count; i++)
			{
				if (instance.monuments[i] != null)
				{
					instance.monuments[i].ResetToPool();
					instance.monuments[i] = null;
				}
			}
			List<Monument> list = instance.monuments;
			Pool.Free<Monument>(ref list, false);
			instance.monuments = list;
		}
		instance.background = string.Empty;
		Pool.Free<AppMap>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppMap with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppMap instance)
	{
		instance.width = width;
		instance.height = height;
		if (jpgImage == null)
		{
			instance.jpgImage = null;
		}
		else
		{
			instance.jpgImage = new byte[jpgImage.Length];
			Array.Copy(jpgImage, instance.jpgImage, instance.jpgImage.Length);
		}
		instance.oceanMargin = oceanMargin;
		if (monuments != null)
		{
			instance.monuments = Pool.Get<List<Monument>>();
			for (int i = 0; i < monuments.Count; i++)
			{
				Monument item = monuments[i].Copy();
				instance.monuments.Add(item);
			}
		}
		else
		{
			instance.monuments = null;
		}
		instance.background = background;
	}

	public AppMap Copy()
	{
		AppMap appMap = Pool.Get<AppMap>();
		CopyTo(appMap);
		return appMap;
	}

	public static AppMap Deserialize(BufferStream stream)
	{
		AppMap appMap = Pool.Get<AppMap>();
		Deserialize(stream, appMap, isDelta: false);
		return appMap;
	}

	public static AppMap DeserializeLengthDelimited(BufferStream stream)
	{
		AppMap appMap = Pool.Get<AppMap>();
		DeserializeLengthDelimited(stream, appMap, isDelta: false);
		return appMap;
	}

	public static AppMap DeserializeLength(BufferStream stream, int length)
	{
		AppMap appMap = Pool.Get<AppMap>();
		DeserializeLength(stream, length, appMap, isDelta: false);
		return appMap;
	}

	public static AppMap Deserialize(byte[] buffer)
	{
		AppMap appMap = Pool.Get<AppMap>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appMap, isDelta: false);
		return appMap;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppMap previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppMap Deserialize(BufferStream stream, AppMap instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0u;
			instance.height = 0u;
			instance.oceanMargin = 0;
			if (instance.monuments == null)
			{
				instance.monuments = Pool.Get<List<Monument>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.width = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.height = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				instance.jpgImage = ProtocolParser.ReadBytes(stream);
				continue;
			case 32:
				instance.oceanMargin = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.monuments.Add(Monument.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.background = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppMap DeserializeLengthDelimited(BufferStream stream, AppMap instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0u;
			instance.height = 0u;
			instance.oceanMargin = 0;
			if (instance.monuments == null)
			{
				instance.monuments = Pool.Get<List<Monument>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.width = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.height = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				instance.jpgImage = ProtocolParser.ReadBytes(stream);
				continue;
			case 32:
				instance.oceanMargin = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.monuments.Add(Monument.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.background = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppMap DeserializeLength(BufferStream stream, int length, AppMap instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0u;
			instance.height = 0u;
			instance.oceanMargin = 0;
			if (instance.monuments == null)
			{
				instance.monuments = Pool.Get<List<Monument>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.width = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.height = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				instance.jpgImage = ProtocolParser.ReadBytes(stream);
				continue;
			case 32:
				instance.oceanMargin = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.monuments.Add(Monument.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.background = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppMap instance, AppMap previous)
	{
		if (instance.width != previous.width)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.width);
		}
		if (instance.height != previous.height)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.height);
		}
		if (instance.jpgImage == null)
		{
			throw new ArgumentNullException("jpgImage", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteBytes(stream, instance.jpgImage);
		if (instance.oceanMargin != previous.oceanMargin)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oceanMargin);
		}
		if (instance.monuments != null)
		{
			for (int i = 0; i < instance.monuments.Count; i++)
			{
				Monument monument = instance.monuments[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Monument.SerializeDelta(stream, monument, monument);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.background != null && instance.background != previous.background)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.background);
		}
	}

	public static void Serialize(BufferStream stream, AppMap instance)
	{
		if (instance.width != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.width);
		}
		if (instance.height != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.height);
		}
		if (instance.jpgImage == null)
		{
			throw new ArgumentNullException("jpgImage", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteBytes(stream, instance.jpgImage);
		if (instance.oceanMargin != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oceanMargin);
		}
		if (instance.monuments != null)
		{
			for (int i = 0; i < instance.monuments.Count; i++)
			{
				Monument instance2 = instance.monuments[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Monument.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.background != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.background);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (monuments != null)
		{
			for (int i = 0; i < monuments.Count; i++)
			{
				monuments[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppEntityInfo : IDisposable, IPooled, IProto<AppEntityInfo>, IProto
{
	[NonSerialized]
	public AppEntityType type;

	[NonSerialized]
	public AppEntityPayload payload;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppEntityInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = (AppEntityType)0;
			if (instance.payload != null)
			{
				instance.payload.ResetToPool();
				instance.payload = null;
			}
			Pool.Free<AppEntityInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppEntityInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppEntityInfo instance)
	{
		instance.type = type;
		if (payload != null)
		{
			if (instance.payload == null)
			{
				instance.payload = payload.Copy();
			}
			else
			{
				payload.CopyTo(instance.payload);
			}
		}
		else
		{
			instance.payload = null;
		}
	}

	public AppEntityInfo Copy()
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		CopyTo(appEntityInfo);
		return appEntityInfo;
	}

	public static AppEntityInfo Deserialize(BufferStream stream)
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		Deserialize(stream, appEntityInfo, isDelta: false);
		return appEntityInfo;
	}

	public static AppEntityInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		DeserializeLengthDelimited(stream, appEntityInfo, isDelta: false);
		return appEntityInfo;
	}

	public static AppEntityInfo DeserializeLength(BufferStream stream, int length)
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		DeserializeLength(stream, length, appEntityInfo, isDelta: false);
		return appEntityInfo;
	}

	public static AppEntityInfo Deserialize(byte[] buffer)
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appEntityInfo, isDelta: false);
		return appEntityInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppEntityInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppEntityInfo Deserialize(BufferStream stream, AppEntityInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (AppEntityType)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppEntityInfo DeserializeLengthDelimited(BufferStream stream, AppEntityInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (AppEntityType)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppEntityInfo DeserializeLength(BufferStream stream, int length, AppEntityInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (AppEntityType)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppEntityInfo instance, AppEntityInfo previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.payload == null)
		{
			throw new ArgumentNullException("payload", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		AppEntityPayload.SerializeDelta(stream, instance.payload, previous.payload);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field payload (ProtoBuf.AppEntityPayload)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppEntityInfo instance)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.payload == null)
		{
			throw new ArgumentNullException("payload", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		AppEntityPayload.Serialize(stream, instance.payload);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field payload (ProtoBuf.AppEntityPayload)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		payload?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppEntityPayload : IDisposable, IPooled, IProto<AppEntityPayload>, IProto
{
	public class Item : IDisposable, IPooled, IProto<Item>, IProto
	{
		[NonSerialized]
		public int itemId;

		[NonSerialized]
		public int quantity;

		[NonSerialized]
		public bool itemIsBlueprint;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Item instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.itemIsBlueprint = false;
				Pool.Free<Item>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Item with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Item instance)
		{
			instance.itemId = itemId;
			instance.quantity = quantity;
			instance.itemIsBlueprint = itemIsBlueprint;
		}

		public Item Copy()
		{
			Item item = Pool.Get<Item>();
			CopyTo(item);
			return item;
		}

		public static Item Deserialize(BufferStream stream)
		{
			Item item = Pool.Get<Item>();
			Deserialize(stream, item, isDelta: false);
			return item;
		}

		public static Item DeserializeLengthDelimited(BufferStream stream)
		{
			Item item = Pool.Get<Item>();
			DeserializeLengthDelimited(stream, item, isDelta: false);
			return item;
		}

		public static Item DeserializeLength(BufferStream stream, int length)
		{
			Item item = Pool.Get<Item>();
			DeserializeLength(stream, length, item, isDelta: false);
			return item;
		}

		public static Item Deserialize(byte[] buffer)
		{
			Item item = Pool.Get<Item>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, item, isDelta: false);
			return item;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Item previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Item Deserialize(BufferStream stream, Item instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.itemIsBlueprint = false;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Item DeserializeLengthDelimited(BufferStream stream, Item instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.itemIsBlueprint = false;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Item DeserializeLength(BufferStream stream, int length, Item instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.itemIsBlueprint = false;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Item instance, Item previous)
		{
			if (instance.itemId != previous.itemId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.quantity != previous.quantity)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		}

		public static void Serialize(BufferStream stream, Item instance)
		{
			if (instance.itemId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.quantity != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
			}
			if (instance.itemIsBlueprint)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public bool value;

	[NonSerialized]
	public List<Item> items;

	[NonSerialized]
	public int capacity;

	[NonSerialized]
	public bool hasProtection;

	[NonSerialized]
	public uint protectionExpiry;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppEntityPayload instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.value = false;
		if (instance.items != null)
		{
			for (int i = 0; i < instance.items.Count; i++)
			{
				if (instance.items[i] != null)
				{
					instance.items[i].ResetToPool();
					instance.items[i] = null;
				}
			}
			List<Item> list = instance.items;
			Pool.Free<Item>(ref list, false);
			instance.items = list;
		}
		instance.capacity = 0;
		instance.hasProtection = false;
		instance.protectionExpiry = 0u;
		Pool.Free<AppEntityPayload>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppEntityPayload with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppEntityPayload instance)
	{
		instance.value = value;
		if (items != null)
		{
			instance.items = Pool.Get<List<Item>>();
			for (int i = 0; i < items.Count; i++)
			{
				Item item = items[i].Copy();
				instance.items.Add(item);
			}
		}
		else
		{
			instance.items = null;
		}
		instance.capacity = capacity;
		instance.hasProtection = hasProtection;
		instance.protectionExpiry = protectionExpiry;
	}

	public AppEntityPayload Copy()
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		CopyTo(appEntityPayload);
		return appEntityPayload;
	}

	public static AppEntityPayload Deserialize(BufferStream stream)
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		Deserialize(stream, appEntityPayload, isDelta: false);
		return appEntityPayload;
	}

	public static AppEntityPayload DeserializeLengthDelimited(BufferStream stream)
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		DeserializeLengthDelimited(stream, appEntityPayload, isDelta: false);
		return appEntityPayload;
	}

	public static AppEntityPayload DeserializeLength(BufferStream stream, int length)
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		DeserializeLength(stream, length, appEntityPayload, isDelta: false);
		return appEntityPayload;
	}

	public static AppEntityPayload Deserialize(byte[] buffer)
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appEntityPayload, isDelta: false);
		return appEntityPayload;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppEntityPayload previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppEntityPayload Deserialize(BufferStream stream, AppEntityPayload instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
			if (instance.items == null)
			{
				instance.items = Pool.Get<List<Item>>();
			}
			instance.capacity = 0;
			instance.protectionExpiry = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.items.Add(Item.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.capacity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.hasProtection = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.protectionExpiry = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppEntityPayload DeserializeLengthDelimited(BufferStream stream, AppEntityPayload instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
			if (instance.items == null)
			{
				instance.items = Pool.Get<List<Item>>();
			}
			instance.capacity = 0;
			instance.protectionExpiry = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.items.Add(Item.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.capacity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.hasProtection = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.protectionExpiry = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppEntityPayload DeserializeLength(BufferStream stream, int length, AppEntityPayload instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
			if (instance.items == null)
			{
				instance.items = Pool.Get<List<Item>>();
			}
			instance.capacity = 0;
			instance.protectionExpiry = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.items.Add(Item.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.capacity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.hasProtection = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.protectionExpiry = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppEntityPayload instance, AppEntityPayload previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.value);
		if (instance.items != null)
		{
			for (int i = 0; i < instance.items.Count; i++)
			{
				Item item = instance.items[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Item.SerializeDelta(stream, item, item);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field items (ProtoBuf.AppEntityPayload.Item)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.capacity != previous.capacity)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.capacity);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.hasProtection);
		if (instance.protectionExpiry != previous.protectionExpiry)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.protectionExpiry);
		}
	}

	public static void Serialize(BufferStream stream, AppEntityPayload instance)
	{
		if (instance.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.value);
		}
		if (instance.items != null)
		{
			for (int i = 0; i < instance.items.Count; i++)
			{
				Item instance2 = instance.items[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Item.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field items (ProtoBuf.AppEntityPayload.Item)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.capacity != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.capacity);
		}
		if (instance.hasProtection)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.hasProtection);
		}
		if (instance.protectionExpiry != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.protectionExpiry);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (items != null)
		{
			for (int i = 0; i < items.Count; i++)
			{
				items[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTeamInfo : IDisposable, IPooled, IProto<AppTeamInfo>, IProto
{
	public class Member : IDisposable, IPooled, IProto<Member>, IProto
	{
		[NonSerialized]
		public ulong steamId;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public float x;

		[NonSerialized]
		public float y;

		[NonSerialized]
		public bool isOnline;

		[NonSerialized]
		public uint spawnTime;

		[NonSerialized]
		public bool isAlive;

		[NonSerialized]
		public uint deathTime;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Member instance)
		{
			if (instance.ShouldPool)
			{
				instance.steamId = 0uL;
				instance.name = string.Empty;
				instance.x = 0f;
				instance.y = 0f;
				instance.isOnline = false;
				instance.spawnTime = 0u;
				instance.isAlive = false;
				instance.deathTime = 0u;
				Pool.Free<Member>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Member with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Member instance)
		{
			instance.steamId = steamId;
			instance.name = name;
			instance.x = x;
			instance.y = y;
			instance.isOnline = isOnline;
			instance.spawnTime = spawnTime;
			instance.isAlive = isAlive;
			instance.deathTime = deathTime;
		}

		public Member Copy()
		{
			Member member = Pool.Get<Member>();
			CopyTo(member);
			return member;
		}

		public static Member Deserialize(BufferStream stream)
		{
			Member member = Pool.Get<Member>();
			Deserialize(stream, member, isDelta: false);
			return member;
		}

		public static Member DeserializeLengthDelimited(BufferStream stream)
		{
			Member member = Pool.Get<Member>();
			DeserializeLengthDelimited(stream, member, isDelta: false);
			return member;
		}

		public static Member DeserializeLength(BufferStream stream, int length)
		{
			Member member = Pool.Get<Member>();
			DeserializeLength(stream, length, member, isDelta: false);
			return member;
		}

		public static Member Deserialize(byte[] buffer)
		{
			Member member = Pool.Get<Member>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, member, isDelta: false);
			return member;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Member previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Member Deserialize(BufferStream stream, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.x = 0f;
				instance.y = 0f;
				instance.isOnline = false;
				instance.spawnTime = 0u;
				instance.isAlive = false;
				instance.deathTime = 0u;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.isOnline = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.spawnTime = ProtocolParser.ReadUInt32(stream);
					continue;
				case 56:
					instance.isAlive = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.deathTime = ProtocolParser.ReadUInt32(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Member DeserializeLengthDelimited(BufferStream stream, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.x = 0f;
				instance.y = 0f;
				instance.isOnline = false;
				instance.spawnTime = 0u;
				instance.isAlive = false;
				instance.deathTime = 0u;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.isOnline = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.spawnTime = ProtocolParser.ReadUInt32(stream);
					continue;
				case 56:
					instance.isAlive = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.deathTime = ProtocolParser.ReadUInt32(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Member DeserializeLength(BufferStream stream, int length, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.x = 0f;
				instance.y = 0f;
				instance.isOnline = false;
				instance.spawnTime = 0u;
				instance.isAlive = false;
				instance.deathTime = 0u;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.isOnline = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.spawnTime = ProtocolParser.ReadUInt32(stream);
					continue;
				case 56:
					instance.isAlive = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.deathTime = ProtocolParser.ReadUInt32(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Member instance, Member previous)
		{
			if (instance.steamId != previous.steamId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.x != previous.x)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != previous.y)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isOnline);
			if (instance.spawnTime != previous.spawnTime)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt32(stream, instance.spawnTime);
			}
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isAlive);
			if (instance.deathTime != previous.deathTime)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteUInt32(stream, instance.deathTime);
			}
		}

		public static void Serialize(BufferStream stream, Member instance)
		{
			if (instance.steamId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.x != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
			if (instance.isOnline)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.isOnline);
			}
			if (instance.spawnTime != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt32(stream, instance.spawnTime);
			}
			if (instance.isAlive)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.isAlive);
			}
			if (instance.deathTime != 0)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteUInt32(stream, instance.deathTime);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class Note : IDisposable, IPooled, IProto<Note>, IProto
	{
		[NonSerialized]
		public int type;

		[NonSerialized]
		public float x;

		[NonSerialized]
		public float y;

		[NonSerialized]
		public int icon;

		[NonSerialized]
		public int colourIndex;

		[NonSerialized]
		public string label;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Note instance)
		{
			if (instance.ShouldPool)
			{
				instance.type = 0;
				instance.x = 0f;
				instance.y = 0f;
				instance.icon = 0;
				instance.colourIndex = 0;
				instance.label = string.Empty;
				Pool.Free<Note>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Note with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Note instance)
		{
			instance.type = type;
			instance.x = x;
			instance.y = y;
			instance.icon = icon;
			instance.colourIndex = colourIndex;
			instance.label = label;
		}

		public Note Copy()
		{
			Note note = Pool.Get<Note>();
			CopyTo(note);
			return note;
		}

		public static Note Deserialize(BufferStream stream)
		{
			Note note = Pool.Get<Note>();
			Deserialize(stream, note, isDelta: false);
			return note;
		}

		public static Note DeserializeLengthDelimited(BufferStream stream)
		{
			Note note = Pool.Get<Note>();
			DeserializeLengthDelimited(stream, note, isDelta: false);
			return note;
		}

		public static Note DeserializeLength(BufferStream stream, int length)
		{
			Note note = Pool.Get<Note>();
			DeserializeLength(stream, length, note, isDelta: false);
			return note;
		}

		public static Note Deserialize(byte[] buffer)
		{
			Note note = Pool.Get<Note>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, note, isDelta: false);
			return note;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Note previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Note Deserialize(BufferStream stream, Note instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.type = 0;
				instance.x = 0f;
				instance.y = 0f;
				instance.icon = 0;
				instance.colourIndex = 0;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.icon = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 58:
					instance.label = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Note DeserializeLengthDelimited(BufferStream stream, Note instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.type = 0;
				instance.x = 0f;
				instance.y = 0f;
				instance.icon = 0;
				instance.colourIndex = 0;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.icon = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 58:
					instance.label = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Note DeserializeLength(BufferStream stream, int length, Note instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.type = 0;
				instance.x = 0f;
				instance.y = 0f;
				instance.icon = 0;
				instance.colourIndex = 0;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.icon = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 58:
					instance.label = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Note instance, Note previous)
		{
			if (instance.type != previous.type)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.x != previous.x)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != previous.y)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
			if (instance.icon != previous.icon)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
			}
			if (instance.colourIndex != previous.colourIndex)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
			}
			if (instance.label != null && instance.label != previous.label)
			{
				stream.WriteByte(58);
				ProtocolParser.WriteString(stream, instance.label);
			}
		}

		public static void Serialize(BufferStream stream, Note instance)
		{
			if (instance.type != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.x != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
			if (instance.icon != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
			}
			if (instance.colourIndex != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
			}
			if (instance.label != null)
			{
				stream.WriteByte(58);
				ProtocolParser.WriteString(stream, instance.label);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public ulong leaderSteamId;

	[NonSerialized]
	public List<Member> members;

	[NonSerialized]
	public List<Note> mapNotes;

	[NonSerialized]
	public List<Note> leaderMapNotes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTeamInfo instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.leaderSteamId = 0uL;
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				if (instance.members[i] != null)
				{
					instance.members[i].ResetToPool();
					instance.members[i] = null;
				}
			}
			List<Member> list = instance.members;
			Pool.Free<Member>(ref list, false);
			instance.members = list;
		}
		if (instance.mapNotes != null)
		{
			for (int j = 0; j < instance.mapNotes.Count; j++)
			{
				if (instance.mapNotes[j] != null)
				{
					instance.mapNotes[j].ResetToPool();
					instance.mapNotes[j] = null;
				}
			}
			List<Note> list2 = instance.mapNotes;
			Pool.Free<Note>(ref list2, false);
			instance.mapNotes = list2;
		}
		if (instance.leaderMapNotes != null)
		{
			for (int k = 0; k < instance.leaderMapNotes.Count; k++)
			{
				if (instance.leaderMapNotes[k] != null)
				{
					instance.leaderMapNotes[k].ResetToPool();
					instance.leaderMapNotes[k] = null;
				}
			}
			List<Note> list3 = instance.leaderMapNotes;
			Pool.Free<Note>(ref list3, false);
			instance.leaderMapNotes = list3;
		}
		Pool.Free<AppTeamInfo>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTeamInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTeamInfo instance)
	{
		instance.leaderSteamId = leaderSteamId;
		if (members != null)
		{
			instance.members = Pool.Get<List<Member>>();
			for (int i = 0; i < members.Count; i++)
			{
				Member item = members[i].Copy();
				instance.members.Add(item);
			}
		}
		else
		{
			instance.members = null;
		}
		if (mapNotes != null)
		{
			instance.mapNotes = Pool.Get<List<Note>>();
			for (int j = 0; j < mapNotes.Count; j++)
			{
				Note item2 = mapNotes[j].Copy();
				instance.mapNotes.Add(item2);
			}
		}
		else
		{
			instance.mapNotes = null;
		}
		if (leaderMapNotes != null)
		{
			instance.leaderMapNotes = Pool.Get<List<Note>>();
			for (int k = 0; k < leaderMapNotes.Count; k++)
			{
				Note item3 = leaderMapNotes[k].Copy();
				instance.leaderMapNotes.Add(item3);
			}
		}
		else
		{
			instance.leaderMapNotes = null;
		}
	}

	public AppTeamInfo Copy()
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		CopyTo(appTeamInfo);
		return appTeamInfo;
	}

	public static AppTeamInfo Deserialize(BufferStream stream)
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		Deserialize(stream, appTeamInfo, isDelta: false);
		return appTeamInfo;
	}

	public static AppTeamInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		DeserializeLengthDelimited(stream, appTeamInfo, isDelta: false);
		return appTeamInfo;
	}

	public static AppTeamInfo DeserializeLength(BufferStream stream, int length)
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		DeserializeLength(stream, length, appTeamInfo, isDelta: false);
		return appTeamInfo;
	}

	public static AppTeamInfo Deserialize(byte[] buffer)
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTeamInfo, isDelta: false);
		return appTeamInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTeamInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTeamInfo Deserialize(BufferStream stream, AppTeamInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.leaderSteamId = 0uL;
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.mapNotes == null)
			{
				instance.mapNotes = Pool.Get<List<Note>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<Note>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.leaderSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.mapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.leaderMapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppTeamInfo DeserializeLengthDelimited(BufferStream stream, AppTeamInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.leaderSteamId = 0uL;
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.mapNotes == null)
			{
				instance.mapNotes = Pool.Get<List<Note>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<Note>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.leaderSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.mapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.leaderMapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTeamInfo DeserializeLength(BufferStream stream, int length, AppTeamInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.leaderSteamId = 0uL;
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.mapNotes == null)
			{
				instance.mapNotes = Pool.Get<List<Note>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<Note>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.leaderSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.mapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.leaderMapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTeamInfo instance, AppTeamInfo previous)
	{
		if (instance.leaderSteamId != previous.leaderSteamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.leaderSteamId);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				Member member = instance.members[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Member.SerializeDelta(stream, member, member);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.mapNotes != null)
		{
			for (int j = 0; j < instance.mapNotes.Count; j++)
			{
				Note note = instance.mapNotes[j];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Note.SerializeDelta(stream, note, note);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.leaderMapNotes == null)
		{
			return;
		}
		for (int k = 0; k < instance.leaderMapNotes.Count; k++)
		{
			Note note2 = instance.leaderMapNotes[k];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			Note.SerializeDelta(stream, note2, note2);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AppTeamInfo instance)
	{
		if (instance.leaderSteamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.leaderSteamId);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				Member instance2 = instance.members[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Member.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.mapNotes != null)
		{
			for (int j = 0; j < instance.mapNotes.Count; j++)
			{
				Note instance3 = instance.mapNotes[j];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Note.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.leaderMapNotes == null)
		{
			return;
		}
		for (int k = 0; k < instance.leaderMapNotes.Count; k++)
		{
			Note instance4 = instance.leaderMapNotes[k];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			Note.Serialize(stream, instance4);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (members != null)
		{
			for (int i = 0; i < members.Count; i++)
			{
				members[i]?.InspectUids(action);
			}
		}
		if (mapNotes != null)
		{
			for (int j = 0; j < mapNotes.Count; j++)
			{
				mapNotes[j]?.InspectUids(action);
			}
		}
		if (leaderMapNotes != null)
		{
			for (int k = 0; k < leaderMapNotes.Count; k++)
			{
				leaderMapNotes[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTeamMessage : IDisposable, IPooled, IProto<AppTeamMessage>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public string message;

	[NonSerialized]
	public string color;

	[NonSerialized]
	public uint time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTeamMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.name = string.Empty;
			instance.message = string.Empty;
			instance.color = string.Empty;
			instance.time = 0u;
			Pool.Free<AppTeamMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTeamMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTeamMessage instance)
	{
		instance.steamId = steamId;
		instance.name = name;
		instance.message = message;
		instance.color = color;
		instance.time = time;
	}

	public AppTeamMessage Copy()
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		CopyTo(appTeamMessage);
		return appTeamMessage;
	}

	public static AppTeamMessage Deserialize(BufferStream stream)
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		Deserialize(stream, appTeamMessage, isDelta: false);
		return appTeamMessage;
	}

	public static AppTeamMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		DeserializeLengthDelimited(stream, appTeamMessage, isDelta: false);
		return appTeamMessage;
	}

	public static AppTeamMessage DeserializeLength(BufferStream stream, int length)
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		DeserializeLength(stream, length, appTeamMessage, isDelta: false);
		return appTeamMessage;
	}

	public static AppTeamMessage Deserialize(byte[] buffer)
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTeamMessage, isDelta: false);
		return appTeamMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTeamMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTeamMessage Deserialize(BufferStream stream, AppTeamMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.color = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.time = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppTeamMessage DeserializeLengthDelimited(BufferStream stream, AppTeamMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.color = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.time = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTeamMessage DeserializeLength(BufferStream stream, int length, AppTeamMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.color = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.time = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTeamMessage instance, AppTeamMessage previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.message != previous.message)
		{
			if (instance.message == null)
			{
				throw new ArgumentNullException("message", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.message);
		}
		if (instance.color != previous.color)
		{
			if (instance.color == null)
			{
				throw new ArgumentNullException("color", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.color);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.time);
		}
	}

	public static void Serialize(BufferStream stream, AppTeamMessage instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.message);
		if (instance.color == null)
		{
			throw new ArgumentNullException("color", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteString(stream, instance.color);
		if (instance.time != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTeamChat : IDisposable, IPooled, IProto<AppTeamChat>, IProto
{
	[NonSerialized]
	public List<AppTeamMessage> messages;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTeamChat instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.messages != null)
		{
			for (int i = 0; i < instance.messages.Count; i++)
			{
				if (instance.messages[i] != null)
				{
					instance.messages[i].ResetToPool();
					instance.messages[i] = null;
				}
			}
			List<AppTeamMessage> list = instance.messages;
			Pool.Free<AppTeamMessage>(ref list, false);
			instance.messages = list;
		}
		Pool.Free<AppTeamChat>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTeamChat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTeamChat instance)
	{
		if (messages != null)
		{
			instance.messages = Pool.Get<List<AppTeamMessage>>();
			for (int i = 0; i < messages.Count; i++)
			{
				AppTeamMessage item = messages[i].Copy();
				instance.messages.Add(item);
			}
		}
		else
		{
			instance.messages = null;
		}
	}

	public AppTeamChat Copy()
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		CopyTo(appTeamChat);
		return appTeamChat;
	}

	public static AppTeamChat Deserialize(BufferStream stream)
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		Deserialize(stream, appTeamChat, isDelta: false);
		return appTeamChat;
	}

	public static AppTeamChat DeserializeLengthDelimited(BufferStream stream)
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		DeserializeLengthDelimited(stream, appTeamChat, isDelta: false);
		return appTeamChat;
	}

	public static AppTeamChat DeserializeLength(BufferStream stream, int length)
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		DeserializeLength(stream, length, appTeamChat, isDelta: false);
		return appTeamChat;
	}

	public static AppTeamChat Deserialize(byte[] buffer)
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTeamChat, isDelta: false);
		return appTeamChat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTeamChat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTeamChat Deserialize(BufferStream stream, AppTeamChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppTeamMessage>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.messages.Add(AppTeamMessage.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppTeamChat DeserializeLengthDelimited(BufferStream stream, AppTeamChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppTeamMessage>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(AppTeamMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTeamChat DeserializeLength(BufferStream stream, int length, AppTeamChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppTeamMessage>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(AppTeamMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTeamChat instance, AppTeamChat previous)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			AppTeamMessage appTeamMessage = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppTeamMessage.SerializeDelta(stream, appTeamMessage, appTeamMessage);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AppTeamChat instance)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			AppTeamMessage instance2 = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppTeamMessage.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (messages != null)
		{
			for (int i = 0; i < messages.Count; i++)
			{
				messages[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class AppMarker : IDisposable, IPooled, IProto<AppMarker>, IProto
{
	public class SellOrder : IDisposable, IPooled, IProto<SellOrder>, IProto
	{
		[NonSerialized]
		public int itemId;

		[NonSerialized]
		public int quantity;

		[NonSerialized]
		public int currencyId;

		[NonSerialized]
		public int costPerItem;

		[NonSerialized]
		public int amountInStock;

		[NonSerialized]
		public bool itemIsBlueprint;

		[NonSerialized]
		public bool currencyIsBlueprint;

		[NonSerialized]
		public float itemCondition;

		[NonSerialized]
		public float itemConditionMax;

		[NonSerialized]
		public float priceMultiplier;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SellOrder instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.currencyId = 0;
				instance.costPerItem = 0;
				instance.amountInStock = 0;
				instance.itemIsBlueprint = false;
				instance.currencyIsBlueprint = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.priceMultiplier = 0f;
				Pool.Free<SellOrder>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SellOrder with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SellOrder instance)
		{
			instance.itemId = itemId;
			instance.quantity = quantity;
			instance.currencyId = currencyId;
			instance.costPerItem = costPerItem;
			instance.amountInStock = amountInStock;
			instance.itemIsBlueprint = itemIsBlueprint;
			instance.currencyIsBlueprint = currencyIsBlueprint;
			instance.itemCondition = itemCondition;
			instance.itemConditionMax = itemConditionMax;
			instance.priceMultiplier = priceMultiplier;
		}

		public SellOrder Copy()
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			CopyTo(sellOrder);
			return sellOrder;
		}

		public static SellOrder Deserialize(BufferStream stream)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			Deserialize(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder DeserializeLengthDelimited(BufferStream stream)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			DeserializeLengthDelimited(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder DeserializeLength(BufferStream stream, int length)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			DeserializeLength(stream, length, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder Deserialize(byte[] buffer)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SellOrder previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SellOrder Deserialize(BufferStream stream, SellOrder instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.currencyId = 0;
				instance.costPerItem = 0;
				instance.amountInStock = 0;
				instance.itemIsBlueprint = false;
				instance.currencyIsBlueprint = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.priceMultiplier = 0f;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 85:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static SellOrder DeserializeLengthDelimited(BufferStream stream, SellOrder instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.currencyId = 0;
				instance.costPerItem = 0;
				instance.amountInStock = 0;
				instance.itemIsBlueprint = false;
				instance.currencyIsBlueprint = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.priceMultiplier = 0f;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 85:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SellOrder DeserializeLength(BufferStream stream, int length, SellOrder instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.currencyId = 0;
				instance.costPerItem = 0;
				instance.amountInStock = 0;
				instance.itemIsBlueprint = false;
				instance.currencyIsBlueprint = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.priceMultiplier = 0f;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 85:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SellOrder instance, SellOrder previous)
		{
			if (instance.itemId != previous.itemId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.quantity != previous.quantity)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
			}
			if (instance.currencyId != previous.currencyId)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
			}
			if (instance.costPerItem != previous.costPerItem)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
			}
			if (instance.amountInStock != previous.amountInStock)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
			if (instance.itemCondition != previous.itemCondition)
			{
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, instance.itemCondition);
			}
			if (instance.itemConditionMax != previous.itemConditionMax)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
			}
			if (instance.priceMultiplier != previous.priceMultiplier)
			{
				stream.WriteByte(85);
				ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
			}
		}

		public static void Serialize(BufferStream stream, SellOrder instance)
		{
			if (instance.itemId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.quantity != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
			}
			if (instance.currencyId != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
			}
			if (instance.costPerItem != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
			}
			if (instance.amountInStock != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
			}
			if (instance.itemIsBlueprint)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
			}
			if (instance.currencyIsBlueprint)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
			}
			if (instance.itemCondition != 0f)
			{
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, instance.itemCondition);
			}
			if (instance.itemConditionMax != 0f)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
			}
			if (instance.priceMultiplier != 0f)
			{
				stream.WriteByte(85);
				ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public NetworkableId id;

	[NonSerialized]
	public AppMarkerType type;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public float rotation;

	[NonSerialized]
	public float radius;

	[NonSerialized]
	public Vector4 color1;

	[NonSerialized]
	public Vector4 color2;

	[NonSerialized]
	public float alpha;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public bool outOfStock;

	[NonSerialized]
	public List<SellOrder> sellOrders;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppMarker instance)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.id = default(NetworkableId);
		instance.type = AppMarkerType.Undefined;
		instance.x = 0f;
		instance.y = 0f;
		instance.steamId = 0uL;
		instance.rotation = 0f;
		instance.radius = 0f;
		instance.color1 = default(Vector4);
		instance.color2 = default(Vector4);
		instance.alpha = 0f;
		instance.name = string.Empty;
		instance.outOfStock = false;
		if (instance.sellOrders != null)
		{
			for (int i = 0; i < instance.sellOrders.Count; i++)
			{
				if (instance.sellOrders[i] != null)
				{
					instance.sellOrders[i].ResetToPool();
					instance.sellOrders[i] = null;
				}
			}
			List<SellOrder> list = instance.sellOrders;
			Pool.Free<SellOrder>(ref list, false);
			instance.sellOrders = list;
		}
		Pool.Free<AppMarker>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppMarker with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppMarker instance)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		instance.id = id;
		instance.type = type;
		instance.x = x;
		instance.y = y;
		instance.steamId = steamId;
		instance.rotation = rotation;
		instance.radius = radius;
		instance.color1 = color1;
		instance.color2 = color2;
		instance.alpha = alpha;
		instance.name = name;
		instance.outOfStock = outOfStock;
		if (sellOrders != null)
		{
			instance.sellOrders = Pool.Get<List<SellOrder>>();
			for (int i = 0; i < sellOrders.Count; i++)
			{
				SellOrder item = sellOrders[i].Copy();
				instance.sellOrders.Add(item);
			}
		}
		else
		{
			instance.sellOrders = null;
		}
	}

	public AppMarker Copy()
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		CopyTo(appMarker);
		return appMarker;
	}

	public static AppMarker Deserialize(BufferStream stream)
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		Deserialize(stream, appMarker, isDelta: false);
		return appMarker;
	}

	public static AppMarker DeserializeLengthDelimited(BufferStream stream)
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		DeserializeLengthDelimited(stream, appMarker, isDelta: false);
		return appMarker;
	}

	public static AppMarker DeserializeLength(BufferStream stream, int length)
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		DeserializeLength(stream, length, appMarker, isDelta: false);
		return appMarker;
	}

	public static AppMarker Deserialize(byte[] buffer)
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appMarker, isDelta: false);
		return appMarker;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppMarker previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppMarker Deserialize(BufferStream stream, AppMarker instance, bool isDelta)
	{
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.steamId = 0uL;
			instance.rotation = 0f;
			instance.radius = 0f;
			instance.alpha = 0f;
			instance.outOfStock = false;
			if (instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (AppMarkerType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.rotation = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color1, isDelta);
				continue;
			case 74:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color2, isDelta);
				continue;
			case 85:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.outOfStock = ProtocolParser.ReadBool(stream);
				continue;
			case 106:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppMarker DeserializeLengthDelimited(BufferStream stream, AppMarker instance, bool isDelta)
	{
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.steamId = 0uL;
			instance.rotation = 0f;
			instance.radius = 0f;
			instance.alpha = 0f;
			instance.outOfStock = false;
			if (instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (AppMarkerType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.rotation = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color1, isDelta);
				continue;
			case 74:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color2, isDelta);
				continue;
			case 85:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.outOfStock = ProtocolParser.ReadBool(stream);
				continue;
			case 106:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppMarker DeserializeLength(BufferStream stream, int length, AppMarker instance, bool isDelta)
	{
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.steamId = 0uL;
			instance.rotation = 0f;
			instance.radius = 0f;
			instance.alpha = 0f;
			instance.outOfStock = false;
			if (instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (AppMarkerType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.rotation = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color1, isDelta);
				continue;
			case 74:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color2, isDelta);
				continue;
			case 85:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.outOfStock = ProtocolParser.ReadBool(stream);
				continue;
			case 106:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppMarker instance, AppMarker previous)
	{
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.id.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.x != previous.x)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.rotation);
		}
		if (instance.radius != previous.radius)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.radius);
		}
		if (instance.color1 != previous.color1)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.color1, previous.color1);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color1 (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.color2 != previous.color2)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.color2, previous.color2);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color2 (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.alpha != previous.alpha)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(96);
		ProtocolParser.WriteBool(stream, instance.outOfStock);
		if (instance.sellOrders == null)
		{
			return;
		}
		for (int i = 0; i < instance.sellOrders.Count; i++)
		{
			SellOrder sellOrder = instance.sellOrders[i];
			stream.WriteByte(106);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			SellOrder.SerializeDelta(stream, sellOrder, sellOrder);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.AppMarker.SellOrder)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public static void Serialize(BufferStream stream, AppMarker instance)
	{
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		if (instance.id != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.id.Value);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.x != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.steamId != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.rotation != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.rotation);
		}
		if (instance.radius != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.radius);
		}
		if (instance.color1 != default(Vector4))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.Serialize(stream, instance.color1);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color1 (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.color2 != default(Vector4))
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.color2);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color2 (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.alpha != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.name != null)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.outOfStock)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.outOfStock);
		}
		if (instance.sellOrders == null)
		{
			return;
		}
		for (int i = 0; i < instance.sellOrders.Count; i++)
		{
			SellOrder instance2 = instance.sellOrders[i];
			stream.WriteByte(106);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			SellOrder.Serialize(stream, instance2);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.AppMarker.SellOrder)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref id.Value);
		if (sellOrders != null)
		{
			for (int i = 0; i < sellOrders.Count; i++)
			{
				sellOrders[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppMapMarkers : IDisposable, IPooled, IProto<AppMapMarkers>, IProto
{
	[NonSerialized]
	public List<AppMarker> markers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppMapMarkers instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.markers != null)
		{
			for (int i = 0; i < instance.markers.Count; i++)
			{
				if (instance.markers[i] != null)
				{
					instance.markers[i].ResetToPool();
					instance.markers[i] = null;
				}
			}
			List<AppMarker> list = instance.markers;
			Pool.Free<AppMarker>(ref list, false);
			instance.markers = list;
		}
		Pool.Free<AppMapMarkers>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppMapMarkers with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppMapMarkers instance)
	{
		if (markers != null)
		{
			instance.markers = Pool.Get<List<AppMarker>>();
			for (int i = 0; i < markers.Count; i++)
			{
				AppMarker item = markers[i].Copy();
				instance.markers.Add(item);
			}
		}
		else
		{
			instance.markers = null;
		}
	}

	public AppMapMarkers Copy()
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		CopyTo(appMapMarkers);
		return appMapMarkers;
	}

	public static AppMapMarkers Deserialize(BufferStream stream)
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		Deserialize(stream, appMapMarkers, isDelta: false);
		return appMapMarkers;
	}

	public static AppMapMarkers DeserializeLengthDelimited(BufferStream stream)
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		DeserializeLengthDelimited(stream, appMapMarkers, isDelta: false);
		return appMapMarkers;
	}

	public static AppMapMarkers DeserializeLength(BufferStream stream, int length)
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		DeserializeLength(stream, length, appMapMarkers, isDelta: false);
		return appMapMarkers;
	}

	public static AppMapMarkers Deserialize(byte[] buffer)
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appMapMarkers, isDelta: false);
		return appMapMarkers;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppMapMarkers previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppMapMarkers Deserialize(BufferStream stream, AppMapMarkers instance, bool isDelta)
	{
		if (!isDelta && instance.markers == null)
		{
			instance.markers = Pool.Get<List<AppMarker>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.markers.Add(AppMarker.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppMapMarkers DeserializeLengthDelimited(BufferStream stream, AppMapMarkers instance, bool isDelta)
	{
		if (!isDelta && instance.markers == null)
		{
			instance.markers = Pool.Get<List<AppMarker>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.markers.Add(AppMarker.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppMapMarkers DeserializeLength(BufferStream stream, int length, AppMapMarkers instance, bool isDelta)
	{
		if (!isDelta && instance.markers == null)
		{
			instance.markers = Pool.Get<List<AppMarker>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.markers.Add(AppMarker.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppMapMarkers instance, AppMapMarkers previous)
	{
		if (instance.markers == null)
		{
			return;
		}
		for (int i = 0; i < instance.markers.Count; i++)
		{
			AppMarker appMarker = instance.markers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppMarker.SerializeDelta(stream, appMarker, appMarker);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AppMapMarkers instance)
	{
		if (instance.markers == null)
		{
			return;
		}
		for (int i = 0; i < instance.markers.Count; i++)
		{
			AppMarker instance2 = instance.markers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppMarker.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (markers != null)
		{
			for (int i = 0; i < markers.Count; i++)
			{
				markers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppClanInfo : IDisposable, IPooled, IProto<AppClanInfo>, IProto
{
	[NonSerialized]
	public ClanInfo clanInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppClanInfo instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.clanInfo != null)
			{
				instance.clanInfo.ResetToPool();
				instance.clanInfo = null;
			}
			Pool.Free<AppClanInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppClanInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppClanInfo instance)
	{
		if (clanInfo != null)
		{
			if (instance.clanInfo == null)
			{
				instance.clanInfo = clanInfo.Copy();
			}
			else
			{
				clanInfo.CopyTo(instance.clanInfo);
			}
		}
		else
		{
			instance.clanInfo = null;
		}
	}

	public AppClanInfo Copy()
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		CopyTo(appClanInfo);
		return appClanInfo;
	}

	public static AppClanInfo Deserialize(BufferStream stream)
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		Deserialize(stream, appClanInfo, isDelta: false);
		return appClanInfo;
	}

	public static AppClanInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		DeserializeLengthDelimited(stream, appClanInfo, isDelta: false);
		return appClanInfo;
	}

	public static AppClanInfo DeserializeLength(BufferStream stream, int length)
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		DeserializeLength(stream, length, appClanInfo, isDelta: false);
		return appClanInfo;
	}

	public static AppClanInfo Deserialize(byte[] buffer)
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appClanInfo, isDelta: false);
		return appClanInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppClanInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppClanInfo Deserialize(BufferStream stream, AppClanInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppClanInfo DeserializeLengthDelimited(BufferStream stream, AppClanInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppClanInfo DeserializeLength(BufferStream stream, int length, AppClanInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppClanInfo instance, AppClanInfo previous)
	{
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.SerializeDelta(stream, instance.clanInfo, previous.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppClanInfo instance)
	{
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.Serialize(stream, instance.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		clanInfo?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppClanMessage : IDisposable, IPooled, IProto<AppClanMessage>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public string message;

	[NonSerialized]
	public long time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppClanMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.name = string.Empty;
			instance.message = string.Empty;
			instance.time = 0L;
			Pool.Free<AppClanMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppClanMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppClanMessage instance)
	{
		instance.steamId = steamId;
		instance.name = name;
		instance.message = message;
		instance.time = time;
	}

	public AppClanMessage Copy()
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		CopyTo(appClanMessage);
		return appClanMessage;
	}

	public static AppClanMessage Deserialize(BufferStream stream)
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		Deserialize(stream, appClanMessage, isDelta: false);
		return appClanMessage;
	}

	public static AppClanMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		DeserializeLengthDelimited(stream, appClanMessage, isDelta: false);
		return appClanMessage;
	}

	public static AppClanMessage DeserializeLength(BufferStream stream, int length)
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		DeserializeLength(stream, length, appClanMessage, isDelta: false);
		return appClanMessage;
	}

	public static AppClanMessage Deserialize(byte[] buffer)
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appClanMessage, isDelta: false);
		return appClanMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppClanMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppClanMessage Deserialize(BufferStream stream, AppClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.time = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppClanMessage DeserializeLengthDelimited(BufferStream stream, AppClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.time = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppClanMessage DeserializeLength(BufferStream stream, int length, AppClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.time = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppClanMessage instance, AppClanMessage previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.message != previous.message)
		{
			if (instance.message == null)
			{
				throw new ArgumentNullException("message", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.message);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.time);
	}

	public static void Serialize(BufferStream stream, AppClanMessage instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.message);
		if (instance.time != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppClanChat : IDisposable, IPooled, IProto<AppClanChat>, IProto
{
	[NonSerialized]
	public List<AppClanMessage> messages;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppClanChat instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.messages != null)
		{
			for (int i = 0; i < instance.messages.Count; i++)
			{
				if (instance.messages[i] != null)
				{
					instance.messages[i].ResetToPool();
					instance.messages[i] = null;
				}
			}
			List<AppClanMessage> list = instance.messages;
			Pool.Free<AppClanMessage>(ref list, false);
			instance.messages = list;
		}
		Pool.Free<AppClanChat>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppClanChat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppClanChat instance)
	{
		if (messages != null)
		{
			instance.messages = Pool.Get<List<AppClanMessage>>();
			for (int i = 0; i < messages.Count; i++)
			{
				AppClanMessage item = messages[i].Copy();
				instance.messages.Add(item);
			}
		}
		else
		{
			instance.messages = null;
		}
	}

	public AppClanChat Copy()
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		CopyTo(appClanChat);
		return appClanChat;
	}

	public static AppClanChat Deserialize(BufferStream stream)
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		Deserialize(stream, appClanChat, isDelta: false);
		return appClanChat;
	}

	public static AppClanChat DeserializeLengthDelimited(BufferStream stream)
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		DeserializeLengthDelimited(stream, appClanChat, isDelta: false);
		return appClanChat;
	}

	public static AppClanChat DeserializeLength(BufferStream stream, int length)
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		DeserializeLength(stream, length, appClanChat, isDelta: false);
		return appClanChat;
	}

	public static AppClanChat Deserialize(byte[] buffer)
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appClanChat, isDelta: false);
		return appClanChat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppClanChat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppClanChat Deserialize(BufferStream stream, AppClanChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppClanMessage>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.messages.Add(AppClanMessage.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppClanChat DeserializeLengthDelimited(BufferStream stream, AppClanChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppClanMessage>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(AppClanMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppClanChat DeserializeLength(BufferStream stream, int length, AppClanChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppClanMessage>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(AppClanMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppClanChat instance, AppClanChat previous)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			AppClanMessage appClanMessage = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppClanMessage.SerializeDelta(stream, appClanMessage, appClanMessage);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AppClanChat instance)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			AppClanMessage instance2 = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppClanMessage.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (messages != null)
		{
			for (int i = 0; i < messages.Count; i++)
			{
				messages[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppNexusAuth : IDisposable, IPooled, IProto<AppNexusAuth>, IProto
{
	[NonSerialized]
	public string serverId;

	[NonSerialized]
	public int playerToken;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppNexusAuth instance)
	{
		if (instance.ShouldPool)
		{
			instance.serverId = string.Empty;
			instance.playerToken = 0;
			Pool.Free<AppNexusAuth>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppNexusAuth with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppNexusAuth instance)
	{
		instance.serverId = serverId;
		instance.playerToken = playerToken;
	}

	public AppNexusAuth Copy()
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		CopyTo(appNexusAuth);
		return appNexusAuth;
	}

	public static AppNexusAuth Deserialize(BufferStream stream)
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		Deserialize(stream, appNexusAuth, isDelta: false);
		return appNexusAuth;
	}

	public static AppNexusAuth DeserializeLengthDelimited(BufferStream stream)
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		DeserializeLengthDelimited(stream, appNexusAuth, isDelta: false);
		return appNexusAuth;
	}

	public static AppNexusAuth DeserializeLength(BufferStream stream, int length)
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		DeserializeLength(stream, length, appNexusAuth, isDelta: false);
		return appNexusAuth;
	}

	public static AppNexusAuth Deserialize(byte[] buffer)
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appNexusAuth, isDelta: false);
		return appNexusAuth;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppNexusAuth previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppNexusAuth Deserialize(BufferStream stream, AppNexusAuth instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerToken = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.serverId = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppNexusAuth DeserializeLengthDelimited(BufferStream stream, AppNexusAuth instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerToken = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.serverId = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppNexusAuth DeserializeLength(BufferStream stream, int length, AppNexusAuth instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerToken = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.serverId = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppNexusAuth instance, AppNexusAuth previous)
	{
		if (instance.serverId != previous.serverId)
		{
			if (instance.serverId == null)
			{
				throw new ArgumentNullException("serverId", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.serverId);
		}
		if (instance.playerToken != previous.playerToken)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerToken);
		}
	}

	public static void Serialize(BufferStream stream, AppNexusAuth instance)
	{
		if (instance.serverId == null)
		{
			throw new ArgumentNullException("serverId", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.serverId);
		if (instance.playerToken != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerToken);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppCameraInfo : IDisposable, IPooled, IProto<AppCameraInfo>, IProto
{
	[NonSerialized]
	public int width;

	[NonSerialized]
	public int height;

	[NonSerialized]
	public float nearPlane;

	[NonSerialized]
	public float farPlane;

	[NonSerialized]
	public int controlFlags;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppCameraInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.width = 0;
			instance.height = 0;
			instance.nearPlane = 0f;
			instance.farPlane = 0f;
			instance.controlFlags = 0;
			Pool.Free<AppCameraInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppCameraInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppCameraInfo instance)
	{
		instance.width = width;
		instance.height = height;
		instance.nearPlane = nearPlane;
		instance.farPlane = farPlane;
		instance.controlFlags = controlFlags;
	}

	public AppCameraInfo Copy()
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		CopyTo(appCameraInfo);
		return appCameraInfo;
	}

	public static AppCameraInfo Deserialize(BufferStream stream)
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		Deserialize(stream, appCameraInfo, isDelta: false);
		return appCameraInfo;
	}

	public static AppCameraInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		DeserializeLengthDelimited(stream, appCameraInfo, isDelta: false);
		return appCameraInfo;
	}

	public static AppCameraInfo DeserializeLength(BufferStream stream, int length)
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		DeserializeLength(stream, length, appCameraInfo, isDelta: false);
		return appCameraInfo;
	}

	public static AppCameraInfo Deserialize(byte[] buffer)
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appCameraInfo, isDelta: false);
		return appCameraInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppCameraInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppCameraInfo Deserialize(BufferStream stream, AppCameraInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0;
			instance.height = 0;
			instance.nearPlane = 0f;
			instance.farPlane = 0f;
			instance.controlFlags = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.width = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.height = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.nearPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.farPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.controlFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppCameraInfo DeserializeLengthDelimited(BufferStream stream, AppCameraInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0;
			instance.height = 0;
			instance.nearPlane = 0f;
			instance.farPlane = 0f;
			instance.controlFlags = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.width = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.height = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.nearPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.farPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.controlFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppCameraInfo DeserializeLength(BufferStream stream, int length, AppCameraInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0;
			instance.height = 0;
			instance.nearPlane = 0f;
			instance.farPlane = 0f;
			instance.controlFlags = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.width = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.height = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.nearPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.farPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.controlFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppCameraInfo instance, AppCameraInfo previous)
	{
		if (instance.width != previous.width)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.width);
		}
		if (instance.height != previous.height)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.height);
		}
		if (instance.nearPlane != previous.nearPlane)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.nearPlane);
		}
		if (instance.farPlane != previous.farPlane)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.farPlane);
		}
		if (instance.controlFlags != previous.controlFlags)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.controlFlags);
		}
	}

	public static void Serialize(BufferStream stream, AppCameraInfo instance)
	{
		if (instance.width != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.width);
		}
		if (instance.height != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.height);
		}
		if (instance.nearPlane != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.nearPlane);
		}
		if (instance.farPlane != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.farPlane);
		}
		if (instance.controlFlags != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.controlFlags);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTeamChanged : IDisposable, IPooled, IProto<AppTeamChanged>, IProto
{
	[NonSerialized]
	public ulong playerId;

	[NonSerialized]
	public AppTeamInfo teamInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTeamChanged instance)
	{
		if (instance.ShouldPool)
		{
			instance.playerId = 0uL;
			if (instance.teamInfo != null)
			{
				instance.teamInfo.ResetToPool();
				instance.teamInfo = null;
			}
			Pool.Free<AppTeamChanged>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTeamChanged with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTeamChanged instance)
	{
		instance.playerId = playerId;
		if (teamInfo != null)
		{
			if (instance.teamInfo == null)
			{
				instance.teamInfo = teamInfo.Copy();
			}
			else
			{
				teamInfo.CopyTo(instance.teamInfo);
			}
		}
		else
		{
			instance.teamInfo = null;
		}
	}

	public AppTeamChanged Copy()
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		CopyTo(appTeamChanged);
		return appTeamChanged;
	}

	public static AppTeamChanged Deserialize(BufferStream stream)
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		Deserialize(stream, appTeamChanged, isDelta: false);
		return appTeamChanged;
	}

	public static AppTeamChanged DeserializeLengthDelimited(BufferStream stream)
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		DeserializeLengthDelimited(stream, appTeamChanged, isDelta: false);
		return appTeamChanged;
	}

	public static AppTeamChanged DeserializeLength(BufferStream stream, int length)
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		DeserializeLength(stream, length, appTeamChanged, isDelta: false);
		return appTeamChanged;
	}

	public static AppTeamChanged Deserialize(byte[] buffer)
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTeamChanged, isDelta: false);
		return appTeamChanged;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTeamChanged previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTeamChanged Deserialize(BufferStream stream, AppTeamChanged instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerId = 0uL;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppTeamChanged DeserializeLengthDelimited(BufferStream stream, AppTeamChanged instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerId = 0uL;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTeamChanged DeserializeLength(BufferStream stream, int length, AppTeamChanged instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerId = 0uL;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTeamChanged instance, AppTeamChanged previous)
	{
		if (instance.playerId != previous.playerId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.teamInfo == null)
		{
			throw new ArgumentNullException("teamInfo", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppTeamInfo.SerializeDelta(stream, instance.teamInfo, previous.teamInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppTeamChanged instance)
	{
		if (instance.playerId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.teamInfo == null)
		{
			throw new ArgumentNullException("teamInfo", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppTeamInfo.Serialize(stream, instance.teamInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		teamInfo?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppNewTeamMessage : IDisposable, IPooled, IProto<AppNewTeamMessage>, IProto
{
	[NonSerialized]
	public AppTeamMessage message;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppNewTeamMessage instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.message != null)
			{
				instance.message.ResetToPool();
				instance.message = null;
			}
			Pool.Free<AppNewTeamMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppNewTeamMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppNewTeamMessage instance)
	{
		if (message != null)
		{
			if (instance.message == null)
			{
				instance.message = message.Copy();
			}
			else
			{
				message.CopyTo(instance.message);
			}
		}
		else
		{
			instance.message = null;
		}
	}

	public AppNewTeamMessage Copy()
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		CopyTo(appNewTeamMessage);
		return appNewTeamMessage;
	}

	public static AppNewTeamMessage Deserialize(BufferStream stream)
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		Deserialize(stream, appNewTeamMessage, isDelta: false);
		return appNewTeamMessage;
	}

	public static AppNewTeamMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		DeserializeLengthDelimited(stream, appNewTeamMessage, isDelta: false);
		return appNewTeamMessage;
	}

	public static AppNewTeamMessage DeserializeLength(BufferStream stream, int length)
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		DeserializeLength(stream, length, appNewTeamMessage, isDelta: false);
		return appNewTeamMessage;
	}

	public static AppNewTeamMessage Deserialize(byte[] buffer)
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appNewTeamMessage, isDelta: false);
		return appNewTeamMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppNewTeamMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppNewTeamMessage Deserialize(BufferStream stream, AppNewTeamMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.message == null)
				{
					instance.message = AppTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppNewTeamMessage DeserializeLengthDelimited(BufferStream stream, AppNewTeamMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.message == null)
				{
					instance.message = AppTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppNewTeamMessage DeserializeLength(BufferStream stream, int length, AppNewTeamMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.message == null)
				{
					instance.message = AppTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppNewTeamMessage instance, AppNewTeamMessage previous)
	{
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppTeamMessage.SerializeDelta(stream, instance.message, previous.message);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppNewTeamMessage instance)
	{
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppTeamMessage.Serialize(stream, instance.message);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		message?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppEntityChanged : IDisposable, IPooled, IProto<AppEntityChanged>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public AppEntityPayload payload;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppEntityChanged instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			if (instance.payload != null)
			{
				instance.payload.ResetToPool();
				instance.payload = null;
			}
			Pool.Free<AppEntityChanged>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppEntityChanged with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppEntityChanged instance)
	{
		instance.entityId = entityId;
		if (payload != null)
		{
			if (instance.payload == null)
			{
				instance.payload = payload.Copy();
			}
			else
			{
				payload.CopyTo(instance.payload);
			}
		}
		else
		{
			instance.payload = null;
		}
	}

	public AppEntityChanged Copy()
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		CopyTo(appEntityChanged);
		return appEntityChanged;
	}

	public static AppEntityChanged Deserialize(BufferStream stream)
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		Deserialize(stream, appEntityChanged, isDelta: false);
		return appEntityChanged;
	}

	public static AppEntityChanged DeserializeLengthDelimited(BufferStream stream)
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		DeserializeLengthDelimited(stream, appEntityChanged, isDelta: false);
		return appEntityChanged;
	}

	public static AppEntityChanged DeserializeLength(BufferStream stream, int length)
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		DeserializeLength(stream, length, appEntityChanged, isDelta: false);
		return appEntityChanged;
	}

	public static AppEntityChanged Deserialize(byte[] buffer)
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appEntityChanged, isDelta: false);
		return appEntityChanged;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppEntityChanged previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppEntityChanged Deserialize(BufferStream stream, AppEntityChanged instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppEntityChanged DeserializeLengthDelimited(BufferStream stream, AppEntityChanged instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppEntityChanged DeserializeLength(BufferStream stream, int length, AppEntityChanged instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppEntityChanged instance, AppEntityChanged previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		if (instance.payload == null)
		{
			throw new ArgumentNullException("payload", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		AppEntityPayload.SerializeDelta(stream, instance.payload, previous.payload);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field payload (ProtoBuf.AppEntityPayload)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppEntityChanged instance)
	{
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.payload == null)
		{
			throw new ArgumentNullException("payload", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		AppEntityPayload.Serialize(stream, instance.payload);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field payload (ProtoBuf.AppEntityPayload)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
		payload?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppClanChanged : IDisposable, IPooled, IProto<AppClanChanged>, IProto
{
	[NonSerialized]
	public ClanInfo clanInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppClanChanged instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.clanInfo != null)
			{
				instance.clanInfo.ResetToPool();
				instance.clanInfo = null;
			}
			Pool.Free<AppClanChanged>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppClanChanged with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppClanChanged instance)
	{
		if (clanInfo != null)
		{
			if (instance.clanInfo == null)
			{
				instance.clanInfo = clanInfo.Copy();
			}
			else
			{
				clanInfo.CopyTo(instance.clanInfo);
			}
		}
		else
		{
			instance.clanInfo = null;
		}
	}

	public AppClanChanged Copy()
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		CopyTo(appClanChanged);
		return appClanChanged;
	}

	public static AppClanChanged Deserialize(BufferStream stream)
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		Deserialize(stream, appClanChanged, isDelta: false);
		return appClanChanged;
	}

	public static AppClanChanged DeserializeLengthDelimited(BufferStream stream)
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		DeserializeLengthDelimited(stream, appClanChanged, isDelta: false);
		return appClanChanged;
	}

	public static AppClanChanged DeserializeLength(BufferStream stream, int length)
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		DeserializeLength(stream, length, appClanChanged, isDelta: false);
		return appClanChanged;
	}

	public static AppClanChanged Deserialize(byte[] buffer)
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appClanChanged, isDelta: false);
		return appClanChanged;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppClanChanged previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppClanChanged Deserialize(BufferStream stream, AppClanChanged instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppClanChanged DeserializeLengthDelimited(BufferStream stream, AppClanChanged instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppClanChanged DeserializeLength(BufferStream stream, int length, AppClanChanged instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppClanChanged instance, AppClanChanged previous)
	{
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.SerializeDelta(stream, instance.clanInfo, previous.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppClanChanged instance)
	{
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.Serialize(stream, instance.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		clanInfo?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppNewClanMessage : IDisposable, IPooled, IProto<AppNewClanMessage>, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public AppClanMessage message;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppNewClanMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			if (instance.message != null)
			{
				instance.message.ResetToPool();
				instance.message = null;
			}
			Pool.Free<AppNewClanMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppNewClanMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppNewClanMessage instance)
	{
		instance.clanId = clanId;
		if (message != null)
		{
			if (instance.message == null)
			{
				instance.message = message.Copy();
			}
			else
			{
				message.CopyTo(instance.message);
			}
		}
		else
		{
			instance.message = null;
		}
	}

	public AppNewClanMessage Copy()
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		CopyTo(appNewClanMessage);
		return appNewClanMessage;
	}

	public static AppNewClanMessage Deserialize(BufferStream stream)
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		Deserialize(stream, appNewClanMessage, isDelta: false);
		return appNewClanMessage;
	}

	public static AppNewClanMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		DeserializeLengthDelimited(stream, appNewClanMessage, isDelta: false);
		return appNewClanMessage;
	}

	public static AppNewClanMessage DeserializeLength(BufferStream stream, int length)
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		DeserializeLength(stream, length, appNewClanMessage, isDelta: false);
		return appNewClanMessage;
	}

	public static AppNewClanMessage Deserialize(byte[] buffer)
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appNewClanMessage, isDelta: false);
		return appNewClanMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppNewClanMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppNewClanMessage Deserialize(BufferStream stream, AppNewClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.message == null)
				{
					instance.message = AppClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppNewClanMessage DeserializeLengthDelimited(BufferStream stream, AppNewClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.message == null)
				{
					instance.message = AppClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppNewClanMessage DeserializeLength(BufferStream stream, int length, AppNewClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.message == null)
				{
					instance.message = AppClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppNewClanMessage instance, AppNewClanMessage previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppClanMessage.SerializeDelta(stream, instance.message, previous.message);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppNewClanMessage instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppClanMessage.Serialize(stream, instance.message);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		message?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class AppCameraRays : IDisposable, IPooled, IProto<AppCameraRays>, IProto
{
	public enum EntityType
	{
		Tree = 1,
		Player
	}

	public class Entity : IDisposable, IPooled, IProto<Entity>, IProto
	{
		[NonSerialized]
		public NetworkableId entityId;

		[NonSerialized]
		public EntityType type;

		[NonSerialized]
		public Vector3 position;

		[NonSerialized]
		public Vector3 rotation;

		[NonSerialized]
		public Vector3 size;

		[NonSerialized]
		public string name;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Entity instance)
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.entityId = default(NetworkableId);
				instance.type = (EntityType)0;
				instance.position = default(Vector3);
				instance.rotation = default(Vector3);
				instance.size = default(Vector3);
				instance.name = string.Empty;
				Pool.Free<Entity>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Entity with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Entity instance)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			instance.entityId = entityId;
			instance.type = type;
			instance.position = position;
			instance.rotation = rotation;
			instance.size = size;
			instance.name = name;
		}

		public Entity Copy()
		{
			Entity entity = Pool.Get<Entity>();
			CopyTo(entity);
			return entity;
		}

		public static Entity Deserialize(BufferStream stream)
		{
			Entity entity = Pool.Get<Entity>();
			Deserialize(stream, entity, isDelta: false);
			return entity;
		}

		public static Entity DeserializeLengthDelimited(BufferStream stream)
		{
			Entity entity = Pool.Get<Entity>();
			DeserializeLengthDelimited(stream, entity, isDelta: false);
			return entity;
		}

		public static Entity DeserializeLength(BufferStream stream, int length)
		{
			Entity entity = Pool.Get<Entity>();
			DeserializeLength(stream, length, entity, isDelta: false);
			return entity;
		}

		public static Entity Deserialize(byte[] buffer)
		{
			Entity entity = Pool.Get<Entity>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, entity, isDelta: false);
			return entity;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Entity previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Entity Deserialize(BufferStream stream, Entity instance, bool isDelta)
		{
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
					continue;
				case 50:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Entity DeserializeLengthDelimited(BufferStream stream, Entity instance, bool isDelta)
		{
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
					continue;
				case 50:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Entity DeserializeLength(BufferStream stream, int length, Entity instance, bool isDelta)
		{
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
					continue;
				case 50:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Entity instance, Entity previous)
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			if (instance.position != previous.position)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.rotation != previous.rotation)
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.rotation, previous.rotation);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
			if (instance.size != previous.size)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int num5 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.size, previous.size);
				int num6 = stream.Position - num5;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span3, 0);
			}
			if (instance.name != null && instance.name != previous.name)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.name);
			}
		}

		public static void Serialize(BufferStream stream, Entity instance)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_013d: Unknown result type (might be due to invalid IL or missing references)
			if (instance.entityId != default(NetworkableId))
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
			}
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			if (instance.position != default(Vector3))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.Serialize(stream, instance.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.rotation != default(Vector3))
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.rotation);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
			if (instance.size != default(Vector3))
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int num5 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.size);
				int num6 = stream.Position - num5;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span3, 0);
			}
			if (instance.name != null)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.name);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref entityId.Value);
		}
	}

	[NonSerialized]
	public float verticalFov;

	[NonSerialized]
	public int sampleOffset;

	[NonSerialized]
	public ArraySegment<byte> rayData;

	[NonSerialized]
	public float distance;

	[NonSerialized]
	public List<Entity> entities;

	[NonSerialized]
	public float timeOfDay;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppCameraRays instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.verticalFov = 0f;
		instance.sampleOffset = 0;
		if (instance.rayData.Array != null)
		{
			BufferStream.Shared.ArrayPool.Return(instance.rayData.Array);
		}
		instance.rayData = default(ArraySegment<byte>);
		instance.distance = 0f;
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				if (instance.entities[i] != null)
				{
					instance.entities[i].ResetToPool();
					instance.entities[i] = null;
				}
			}
			List<Entity> list = instance.entities;
			Pool.Free<Entity>(ref list, false);
			instance.entities = list;
		}
		instance.timeOfDay = 0f;
		Pool.Free<AppCameraRays>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppCameraRays with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppCameraRays instance)
	{
		instance.verticalFov = verticalFov;
		instance.sampleOffset = sampleOffset;
		if (rayData.Array == null)
		{
			instance.rayData = default(ArraySegment<byte>);
		}
		else
		{
			byte[] array = BufferStream.Shared.ArrayPool.Rent(rayData.Count);
			Array.Copy(rayData.Array, 0, array, 0, rayData.Count);
			instance.rayData = new ArraySegment<byte>(array, 0, rayData.Count);
		}
		instance.distance = distance;
		if (entities != null)
		{
			instance.entities = Pool.Get<List<Entity>>();
			for (int i = 0; i < entities.Count; i++)
			{
				Entity item = entities[i].Copy();
				instance.entities.Add(item);
			}
		}
		else
		{
			instance.entities = null;
		}
		instance.timeOfDay = timeOfDay;
	}

	public AppCameraRays Copy()
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		CopyTo(appCameraRays);
		return appCameraRays;
	}

	public static AppCameraRays Deserialize(BufferStream stream)
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		Deserialize(stream, appCameraRays, isDelta: false);
		return appCameraRays;
	}

	public static AppCameraRays DeserializeLengthDelimited(BufferStream stream)
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		DeserializeLengthDelimited(stream, appCameraRays, isDelta: false);
		return appCameraRays;
	}

	public static AppCameraRays DeserializeLength(BufferStream stream, int length)
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		DeserializeLength(stream, length, appCameraRays, isDelta: false);
		return appCameraRays;
	}

	public static AppCameraRays Deserialize(byte[] buffer)
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appCameraRays, isDelta: false);
		return appCameraRays;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppCameraRays previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppCameraRays Deserialize(BufferStream stream, AppCameraRays instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.verticalFov = 0f;
			instance.sampleOffset = 0;
			instance.distance = 0f;
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			instance.timeOfDay = 1f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.verticalFov = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.sampleOffset = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.rayData = ProtocolParser.ReadPooledBytes(stream);
				continue;
			case 37:
				instance.distance = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.timeOfDay = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppCameraRays DeserializeLengthDelimited(BufferStream stream, AppCameraRays instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.verticalFov = 0f;
			instance.sampleOffset = 0;
			instance.distance = 0f;
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			instance.timeOfDay = 1f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.verticalFov = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.sampleOffset = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.rayData = ProtocolParser.ReadPooledBytes(stream);
				continue;
			case 37:
				instance.distance = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.timeOfDay = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppCameraRays DeserializeLength(BufferStream stream, int length, AppCameraRays instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.verticalFov = 0f;
			instance.sampleOffset = 0;
			instance.distance = 0f;
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			instance.timeOfDay = 1f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.verticalFov = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.sampleOffset = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.rayData = ProtocolParser.ReadPooledBytes(stream);
				continue;
			case 37:
				instance.distance = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.timeOfDay = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppCameraRays instance, AppCameraRays previous)
	{
		if (instance.verticalFov != previous.verticalFov)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.verticalFov);
		}
		if (instance.sampleOffset != previous.sampleOffset)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sampleOffset);
		}
		if (instance.rayData.Array == null)
		{
			throw new ArgumentNullException("rayData", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WritePooledBytes(stream, instance.rayData);
		if (instance.distance != previous.distance)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.distance);
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				Entity entity = instance.entities[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Entity.SerializeDelta(stream, entity, entity);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.timeOfDay != previous.timeOfDay)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.timeOfDay);
		}
	}

	public static void Serialize(BufferStream stream, AppCameraRays instance)
	{
		if (instance.verticalFov != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.verticalFov);
		}
		if (instance.sampleOffset != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sampleOffset);
		}
		if (instance.rayData.Array == null)
		{
			throw new ArgumentNullException("rayData", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WritePooledBytes(stream, instance.rayData);
		if (instance.distance != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.distance);
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				Entity instance2 = instance.entities[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Entity.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.timeOfDay != 1f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.timeOfDay);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entities != null)
		{
			for (int i = 0; i < entities.Count; i++)
			{
				entities[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanActionResult : IDisposable, IPooled, IProto<ClanActionResult>, IProto
{
	[NonSerialized]
	public int requestId;

	[NonSerialized]
	public int result;

	[NonSerialized]
	public bool hasClanInfo;

	[NonSerialized]
	public ClanInfo clanInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanActionResult instance)
	{
		if (instance.ShouldPool)
		{
			instance.requestId = 0;
			instance.result = 0;
			instance.hasClanInfo = false;
			if (instance.clanInfo != null)
			{
				instance.clanInfo.ResetToPool();
				instance.clanInfo = null;
			}
			Pool.Free<ClanActionResult>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanActionResult with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanActionResult instance)
	{
		instance.requestId = requestId;
		instance.result = result;
		instance.hasClanInfo = hasClanInfo;
		if (clanInfo != null)
		{
			if (instance.clanInfo == null)
			{
				instance.clanInfo = clanInfo.Copy();
			}
			else
			{
				clanInfo.CopyTo(instance.clanInfo);
			}
		}
		else
		{
			instance.clanInfo = null;
		}
	}

	public ClanActionResult Copy()
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		CopyTo(instance);
		return instance;
	}

	public static ClanActionResult Deserialize(BufferStream stream)
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		Deserialize(stream, instance, isDelta: false);
		return instance;
	}

	public static ClanActionResult DeserializeLengthDelimited(BufferStream stream)
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		DeserializeLengthDelimited(stream, instance, isDelta: false);
		return instance;
	}

	public static ClanActionResult DeserializeLength(BufferStream stream, int length)
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		DeserializeLength(stream, length, instance, isDelta: false);
		return instance;
	}

	public static ClanActionResult Deserialize(byte[] buffer)
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanActionResult previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanActionResult Deserialize(BufferStream stream, ClanActionResult instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.requestId = 0;
			instance.result = 0;
			instance.hasClanInfo = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.requestId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.result = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.hasClanInfo = ProtocolParser.ReadBool(stream);
				break;
			case 34:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static ClanActionResult DeserializeLengthDelimited(BufferStream stream, ClanActionResult instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.requestId = 0;
			instance.result = 0;
			instance.hasClanInfo = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.requestId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.result = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.hasClanInfo = ProtocolParser.ReadBool(stream);
				break;
			case 34:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanActionResult DeserializeLength(BufferStream stream, int length, ClanActionResult instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.requestId = 0;
			instance.result = 0;
			instance.hasClanInfo = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.requestId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.result = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.hasClanInfo = ProtocolParser.ReadBool(stream);
				break;
			case 34:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanActionResult instance, ClanActionResult previous)
	{
		if (instance.requestId != previous.requestId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.requestId);
		}
		if (instance.result != previous.result)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.result);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.hasClanInfo);
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.SerializeDelta(stream, instance.clanInfo, previous.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, ClanActionResult instance)
	{
		if (instance.requestId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.requestId);
		}
		if (instance.result != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.result);
		}
		if (instance.hasClanInfo)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.hasClanInfo);
		}
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.Serialize(stream, instance.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		clanInfo?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanInfo : IDisposable, IPooled, IProto<ClanInfo>, IProto
{
	public class Role : IDisposable, IPooled, IProto<Role>, IProto
	{
		[NonSerialized]
		public int roleId;

		[NonSerialized]
		public int rank;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public bool canSetMotd;

		[NonSerialized]
		public bool canSetLogo;

		[NonSerialized]
		public bool canInvite;

		[NonSerialized]
		public bool canKick;

		[NonSerialized]
		public bool canPromote;

		[NonSerialized]
		public bool canDemote;

		[NonSerialized]
		public bool canSetPlayerNotes;

		[NonSerialized]
		public bool canAccessLogs;

		[NonSerialized]
		public bool canAccessScoreEvents;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Role instance)
		{
			if (instance.ShouldPool)
			{
				instance.roleId = 0;
				instance.rank = 0;
				instance.name = string.Empty;
				instance.canSetMotd = false;
				instance.canSetLogo = false;
				instance.canInvite = false;
				instance.canKick = false;
				instance.canPromote = false;
				instance.canDemote = false;
				instance.canSetPlayerNotes = false;
				instance.canAccessLogs = false;
				instance.canAccessScoreEvents = false;
				Pool.Free<Role>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Role with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Role instance)
		{
			instance.roleId = roleId;
			instance.rank = rank;
			instance.name = name;
			instance.canSetMotd = canSetMotd;
			instance.canSetLogo = canSetLogo;
			instance.canInvite = canInvite;
			instance.canKick = canKick;
			instance.canPromote = canPromote;
			instance.canDemote = canDemote;
			instance.canSetPlayerNotes = canSetPlayerNotes;
			instance.canAccessLogs = canAccessLogs;
			instance.canAccessScoreEvents = canAccessScoreEvents;
		}

		public Role Copy()
		{
			Role role = Pool.Get<Role>();
			CopyTo(role);
			return role;
		}

		public static Role Deserialize(BufferStream stream)
		{
			Role role = Pool.Get<Role>();
			Deserialize(stream, role, isDelta: false);
			return role;
		}

		public static Role DeserializeLengthDelimited(BufferStream stream)
		{
			Role role = Pool.Get<Role>();
			DeserializeLengthDelimited(stream, role, isDelta: false);
			return role;
		}

		public static Role DeserializeLength(BufferStream stream, int length)
		{
			Role role = Pool.Get<Role>();
			DeserializeLength(stream, length, role, isDelta: false);
			return role;
		}

		public static Role Deserialize(byte[] buffer)
		{
			Role role = Pool.Get<Role>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, role, isDelta: false);
			return role;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Role previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Role Deserialize(BufferStream stream, Role instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.roleId = 0;
				instance.rank = 0;
				instance.canSetMotd = false;
				instance.canSetLogo = false;
				instance.canInvite = false;
				instance.canKick = false;
				instance.canPromote = false;
				instance.canDemote = false;
				instance.canSetPlayerNotes = false;
				instance.canAccessLogs = false;
				instance.canAccessScoreEvents = false;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.rank = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 32:
					instance.canSetMotd = ProtocolParser.ReadBool(stream);
					continue;
				case 40:
					instance.canSetLogo = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.canInvite = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.canKick = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.canPromote = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.canDemote = ProtocolParser.ReadBool(stream);
					continue;
				case 80:
					instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
					continue;
				case 88:
					instance.canAccessLogs = ProtocolParser.ReadBool(stream);
					continue;
				case 96:
					instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Role DeserializeLengthDelimited(BufferStream stream, Role instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.roleId = 0;
				instance.rank = 0;
				instance.canSetMotd = false;
				instance.canSetLogo = false;
				instance.canInvite = false;
				instance.canKick = false;
				instance.canPromote = false;
				instance.canDemote = false;
				instance.canSetPlayerNotes = false;
				instance.canAccessLogs = false;
				instance.canAccessScoreEvents = false;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.rank = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 32:
					instance.canSetMotd = ProtocolParser.ReadBool(stream);
					continue;
				case 40:
					instance.canSetLogo = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.canInvite = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.canKick = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.canPromote = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.canDemote = ProtocolParser.ReadBool(stream);
					continue;
				case 80:
					instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
					continue;
				case 88:
					instance.canAccessLogs = ProtocolParser.ReadBool(stream);
					continue;
				case 96:
					instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Role DeserializeLength(BufferStream stream, int length, Role instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.roleId = 0;
				instance.rank = 0;
				instance.canSetMotd = false;
				instance.canSetLogo = false;
				instance.canInvite = false;
				instance.canKick = false;
				instance.canPromote = false;
				instance.canDemote = false;
				instance.canSetPlayerNotes = false;
				instance.canAccessLogs = false;
				instance.canAccessScoreEvents = false;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.rank = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 32:
					instance.canSetMotd = ProtocolParser.ReadBool(stream);
					continue;
				case 40:
					instance.canSetLogo = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.canInvite = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.canKick = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.canPromote = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.canDemote = ProtocolParser.ReadBool(stream);
					continue;
				case 80:
					instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
					continue;
				case 88:
					instance.canAccessLogs = ProtocolParser.ReadBool(stream);
					continue;
				case 96:
					instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Role instance, Role previous)
		{
			if (instance.roleId != previous.roleId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
			}
			if (instance.rank != previous.rank)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.name);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.canSetMotd);
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.canSetLogo);
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.canInvite);
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.canKick);
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.canPromote);
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.canDemote);
			stream.WriteByte(80);
			ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
			stream.WriteByte(88);
			ProtocolParser.WriteBool(stream, instance.canAccessLogs);
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
		}

		public static void Serialize(BufferStream stream, Role instance)
		{
			if (instance.roleId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
			}
			if (instance.rank != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.canSetMotd)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteBool(stream, instance.canSetMotd);
			}
			if (instance.canSetLogo)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.canSetLogo);
			}
			if (instance.canInvite)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.canInvite);
			}
			if (instance.canKick)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.canKick);
			}
			if (instance.canPromote)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteBool(stream, instance.canPromote);
			}
			if (instance.canDemote)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteBool(stream, instance.canDemote);
			}
			if (instance.canSetPlayerNotes)
			{
				stream.WriteByte(80);
				ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
			}
			if (instance.canAccessLogs)
			{
				stream.WriteByte(88);
				ProtocolParser.WriteBool(stream, instance.canAccessLogs);
			}
			if (instance.canAccessScoreEvents)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class Member : IDisposable, IPooled, IProto<Member>, IProto
	{
		[NonSerialized]
		public ulong steamId;

		[NonSerialized]
		public int roleId;

		[NonSerialized]
		public long joined;

		[NonSerialized]
		public long lastSeen;

		[NonSerialized]
		public string notes;

		[NonSerialized]
		public bool online;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Member instance)
		{
			if (instance.ShouldPool)
			{
				instance.steamId = 0uL;
				instance.roleId = 0;
				instance.joined = 0L;
				instance.lastSeen = 0L;
				instance.notes = string.Empty;
				instance.online = false;
				Pool.Free<Member>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Member with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Member instance)
		{
			instance.steamId = steamId;
			instance.roleId = roleId;
			instance.joined = joined;
			instance.lastSeen = lastSeen;
			instance.notes = notes;
			instance.online = online;
		}

		public Member Copy()
		{
			Member member = Pool.Get<Member>();
			CopyTo(member);
			return member;
		}

		public static Member Deserialize(BufferStream stream)
		{
			Member member = Pool.Get<Member>();
			Deserialize(stream, member, isDelta: false);
			return member;
		}

		public static Member DeserializeLengthDelimited(BufferStream stream)
		{
			Member member = Pool.Get<Member>();
			DeserializeLengthDelimited(stream, member, isDelta: false);
			return member;
		}

		public static Member DeserializeLength(BufferStream stream, int length)
		{
			Member member = Pool.Get<Member>();
			DeserializeLength(stream, length, member, isDelta: false);
			return member;
		}

		public static Member Deserialize(byte[] buffer)
		{
			Member member = Pool.Get<Member>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, member, isDelta: false);
			return member;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Member previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Member Deserialize(BufferStream stream, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.roleId = 0;
				instance.joined = 0L;
				instance.lastSeen = 0L;
				instance.online = false;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.joined = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 42:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 48:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Member DeserializeLengthDelimited(BufferStream stream, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.roleId = 0;
				instance.joined = 0L;
				instance.lastSeen = 0L;
				instance.online = false;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.joined = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 42:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 48:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Member DeserializeLength(BufferStream stream, int length, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.roleId = 0;
				instance.joined = 0L;
				instance.lastSeen = 0L;
				instance.online = false;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.joined = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 42:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 48:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Member instance, Member previous)
		{
			if (instance.steamId != previous.steamId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.roleId != previous.roleId)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
			if (instance.notes != null && instance.notes != previous.notes)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.notes);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.online);
		}

		public static void Serialize(BufferStream stream, Member instance)
		{
			if (instance.steamId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.roleId != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
			}
			if (instance.joined != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
			}
			if (instance.lastSeen != 0L)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
			}
			if (instance.notes != null)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.notes);
			}
			if (instance.online)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.online);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class Invite : IDisposable, IPooled, IProto<Invite>, IProto
	{
		[NonSerialized]
		public ulong steamId;

		[NonSerialized]
		public ulong recruiter;

		[NonSerialized]
		public long timestamp;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Invite instance)
		{
			if (instance.ShouldPool)
			{
				instance.steamId = 0uL;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
				Pool.Free<Invite>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Invite with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Invite instance)
		{
			instance.steamId = steamId;
			instance.recruiter = recruiter;
			instance.timestamp = timestamp;
		}

		public Invite Copy()
		{
			Invite invite = Pool.Get<Invite>();
			CopyTo(invite);
			return invite;
		}

		public static Invite Deserialize(BufferStream stream)
		{
			Invite invite = Pool.Get<Invite>();
			Deserialize(stream, invite, isDelta: false);
			return invite;
		}

		public static Invite DeserializeLengthDelimited(BufferStream stream)
		{
			Invite invite = Pool.Get<Invite>();
			DeserializeLengthDelimited(stream, invite, isDelta: false);
			return invite;
		}

		public static Invite DeserializeLength(BufferStream stream, int length)
		{
			Invite invite = Pool.Get<Invite>();
			DeserializeLength(stream, length, invite, isDelta: false);
			return invite;
		}

		public static Invite Deserialize(byte[] buffer)
		{
			Invite invite = Pool.Get<Invite>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, invite, isDelta: false);
			return invite;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Invite previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Invite Deserialize(BufferStream stream, Invite instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Invite DeserializeLengthDelimited(BufferStream stream, Invite instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Invite DeserializeLength(BufferStream stream, int length, Invite instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Invite instance, Invite previous)
		{
			if (instance.steamId != previous.steamId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.recruiter != previous.recruiter)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.recruiter);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}

		public static void Serialize(BufferStream stream, Invite instance)
		{
			if (instance.steamId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.recruiter != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.recruiter);
			}
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public long created;

	[NonSerialized]
	public ulong creator;

	[NonSerialized]
	public string motd;

	[NonSerialized]
	public long motdTimestamp;

	[NonSerialized]
	public ulong motdAuthor;

	[NonSerialized]
	public byte[] logo;

	[NonSerialized]
	public int color;

	[NonSerialized]
	public List<Role> roles;

	[NonSerialized]
	public List<Member> members;

	[NonSerialized]
	public List<Invite> invites;

	[NonSerialized]
	public int maxMemberCount;

	[NonSerialized]
	public long score;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanInfo instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.clanId = 0L;
		instance.name = string.Empty;
		instance.created = 0L;
		instance.creator = 0uL;
		instance.motd = string.Empty;
		instance.motdTimestamp = 0L;
		instance.motdAuthor = 0uL;
		instance.logo = null;
		instance.color = 0;
		if (instance.roles != null)
		{
			for (int i = 0; i < instance.roles.Count; i++)
			{
				if (instance.roles[i] != null)
				{
					instance.roles[i].ResetToPool();
					instance.roles[i] = null;
				}
			}
			List<Role> list = instance.roles;
			Pool.Free<Role>(ref list, false);
			instance.roles = list;
		}
		if (instance.members != null)
		{
			for (int j = 0; j < instance.members.Count; j++)
			{
				if (instance.members[j] != null)
				{
					instance.members[j].ResetToPool();
					instance.members[j] = null;
				}
			}
			List<Member> list2 = instance.members;
			Pool.Free<Member>(ref list2, false);
			instance.members = list2;
		}
		if (instance.invites != null)
		{
			for (int k = 0; k < instance.invites.Count; k++)
			{
				if (instance.invites[k] != null)
				{
					instance.invites[k].ResetToPool();
					instance.invites[k] = null;
				}
			}
			List<Invite> list3 = instance.invites;
			Pool.Free<Invite>(ref list3, false);
			instance.invites = list3;
		}
		instance.maxMemberCount = 0;
		instance.score = 0L;
		Pool.Free<ClanInfo>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanInfo instance)
	{
		instance.clanId = clanId;
		instance.name = name;
		instance.created = created;
		instance.creator = creator;
		instance.motd = motd;
		instance.motdTimestamp = motdTimestamp;
		instance.motdAuthor = motdAuthor;
		if (logo == null)
		{
			instance.logo = null;
		}
		else
		{
			instance.logo = new byte[logo.Length];
			Array.Copy(logo, instance.logo, instance.logo.Length);
		}
		instance.color = color;
		if (roles != null)
		{
			instance.roles = Pool.Get<List<Role>>();
			for (int i = 0; i < roles.Count; i++)
			{
				Role item = roles[i].Copy();
				instance.roles.Add(item);
			}
		}
		else
		{
			instance.roles = null;
		}
		if (members != null)
		{
			instance.members = Pool.Get<List<Member>>();
			for (int j = 0; j < members.Count; j++)
			{
				Member item2 = members[j].Copy();
				instance.members.Add(item2);
			}
		}
		else
		{
			instance.members = null;
		}
		if (invites != null)
		{
			instance.invites = Pool.Get<List<Invite>>();
			for (int k = 0; k < invites.Count; k++)
			{
				Invite item3 = invites[k].Copy();
				instance.invites.Add(item3);
			}
		}
		else
		{
			instance.invites = null;
		}
		instance.maxMemberCount = maxMemberCount;
		instance.score = score;
	}

	public ClanInfo Copy()
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		CopyTo(clanInfo);
		return clanInfo;
	}

	public static ClanInfo Deserialize(BufferStream stream)
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		Deserialize(stream, clanInfo, isDelta: false);
		return clanInfo;
	}

	public static ClanInfo DeserializeLengthDelimited(BufferStream stream)
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		DeserializeLengthDelimited(stream, clanInfo, isDelta: false);
		return clanInfo;
	}

	public static ClanInfo DeserializeLength(BufferStream stream, int length)
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		DeserializeLength(stream, length, clanInfo, isDelta: false);
		return clanInfo;
	}

	public static ClanInfo Deserialize(byte[] buffer)
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanInfo, isDelta: false);
		return clanInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanInfo Deserialize(BufferStream stream, ClanInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.created = 0L;
			instance.creator = 0uL;
			instance.motdTimestamp = 0L;
			instance.motdAuthor = 0uL;
			instance.color = 0;
			if (instance.roles == null)
			{
				instance.roles = Pool.Get<List<Role>>();
			}
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<Invite>>();
			}
			instance.maxMemberCount = 0;
			instance.score = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.created = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.creator = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.motd = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.motdTimestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.motdAuthor = ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.logo = ProtocolParser.ReadBytes(stream);
				continue;
			case 72:
				instance.color = ProtocolParser.ReadZInt32(stream);
				continue;
			case 82:
				instance.roles.Add(Role.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 98:
				instance.invites.Add(Invite.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.maxMemberCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanInfo DeserializeLengthDelimited(BufferStream stream, ClanInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.created = 0L;
			instance.creator = 0uL;
			instance.motdTimestamp = 0L;
			instance.motdAuthor = 0uL;
			instance.color = 0;
			if (instance.roles == null)
			{
				instance.roles = Pool.Get<List<Role>>();
			}
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<Invite>>();
			}
			instance.maxMemberCount = 0;
			instance.score = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.created = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.creator = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.motd = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.motdTimestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.motdAuthor = ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.logo = ProtocolParser.ReadBytes(stream);
				continue;
			case 72:
				instance.color = ProtocolParser.ReadZInt32(stream);
				continue;
			case 82:
				instance.roles.Add(Role.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 98:
				instance.invites.Add(Invite.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.maxMemberCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanInfo DeserializeLength(BufferStream stream, int length, ClanInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.created = 0L;
			instance.creator = 0uL;
			instance.motdTimestamp = 0L;
			instance.motdAuthor = 0uL;
			instance.color = 0;
			if (instance.roles == null)
			{
				instance.roles = Pool.Get<List<Role>>();
			}
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<Invite>>();
			}
			instance.maxMemberCount = 0;
			instance.score = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.created = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.creator = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.motd = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.motdTimestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.motdAuthor = ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.logo = ProtocolParser.ReadBytes(stream);
				continue;
			case 72:
				instance.color = ProtocolParser.ReadZInt32(stream);
				continue;
			case 82:
				instance.roles.Add(Role.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 98:
				instance.invites.Add(Invite.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.maxMemberCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanInfo instance, ClanInfo previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.created);
		if (instance.creator != previous.creator)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.creator);
		}
		if (instance.motd != null && instance.motd != previous.motd)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.motd);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.motdTimestamp);
		if (instance.motdAuthor != previous.motdAuthor)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.motdAuthor);
		}
		if (instance.logo != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteBytes(stream, instance.logo);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteZInt32(stream, instance.color);
		if (instance.roles != null)
		{
			for (int i = 0; i < instance.roles.Count; i++)
			{
				Role role = instance.roles[i];
				stream.WriteByte(82);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Role.SerializeDelta(stream, role, role);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.members != null)
		{
			for (int j = 0; j < instance.members.Count; j++)
			{
				Member member = instance.members[j];
				stream.WriteByte(90);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Member.SerializeDelta(stream, member, member);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.invites != null)
		{
			for (int k = 0; k < instance.invites.Count; k++)
			{
				Invite invite = instance.invites[k];
				stream.WriteByte(98);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				Invite.SerializeDelta(stream, invite, invite);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field invites (ProtoBuf.ClanInfo.Invite)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.maxMemberCount != previous.maxMemberCount)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxMemberCount);
		}
		stream.WriteByte(112);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
	}

	public static void Serialize(BufferStream stream, ClanInfo instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.created != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.created);
		}
		if (instance.creator != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.creator);
		}
		if (instance.motd != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.motd);
		}
		if (instance.motdTimestamp != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.motdTimestamp);
		}
		if (instance.motdAuthor != 0L)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.motdAuthor);
		}
		if (instance.logo != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteBytes(stream, instance.logo);
		}
		if (instance.color != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteZInt32(stream, instance.color);
		}
		if (instance.roles != null)
		{
			for (int i = 0; i < instance.roles.Count; i++)
			{
				Role instance2 = instance.roles[i];
				stream.WriteByte(82);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Role.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.members != null)
		{
			for (int j = 0; j < instance.members.Count; j++)
			{
				Member instance3 = instance.members[j];
				stream.WriteByte(90);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Member.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.invites != null)
		{
			for (int k = 0; k < instance.invites.Count; k++)
			{
				Invite instance4 = instance.invites[k];
				stream.WriteByte(98);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				Invite.Serialize(stream, instance4);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field invites (ProtoBuf.ClanInfo.Invite)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.maxMemberCount != 0)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxMemberCount);
		}
		if (instance.score != 0L)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (roles != null)
		{
			for (int i = 0; i < roles.Count; i++)
			{
				roles[i]?.InspectUids(action);
			}
		}
		if (members != null)
		{
			for (int j = 0; j < members.Count; j++)
			{
				members[j]?.InspectUids(action);
			}
		}
		if (invites != null)
		{
			for (int k = 0; k < invites.Count; k++)
			{
				invites[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanLog : IDisposable, IPooled, IProto<ClanLog>, IProto
{
	public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
	{
		[NonSerialized]
		public long timestamp;

		[NonSerialized]
		public string eventKey;

		[NonSerialized]
		public string arg1;

		[NonSerialized]
		public string arg2;

		[NonSerialized]
		public string arg3;

		[NonSerialized]
		public string arg4;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Entry instance)
		{
			if (instance.ShouldPool)
			{
				instance.timestamp = 0L;
				instance.eventKey = string.Empty;
				instance.arg1 = string.Empty;
				instance.arg2 = string.Empty;
				instance.arg3 = string.Empty;
				instance.arg4 = string.Empty;
				Pool.Free<Entry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Entry instance)
		{
			instance.timestamp = timestamp;
			instance.eventKey = eventKey;
			instance.arg1 = arg1;
			instance.arg2 = arg2;
			instance.arg3 = arg3;
			instance.arg4 = arg4;
		}

		public Entry Copy()
		{
			Entry entry = Pool.Get<Entry>();
			CopyTo(entry);
			return entry;
		}

		public static Entry Deserialize(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLengthDelimited(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLength(BufferStream stream, int length)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLength(stream, length, entry, isDelta: false);
			return entry;
		}

		public static Entry Deserialize(byte[] buffer)
		{
			Entry entry = Pool.Get<Entry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.eventKey = ProtocolParser.ReadString(stream);
					continue;
				case 26:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				case 42:
					instance.arg3 = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.arg4 = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.eventKey = ProtocolParser.ReadString(stream);
					continue;
				case 26:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				case 42:
					instance.arg3 = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.arg4 = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.eventKey = ProtocolParser.ReadString(stream);
					continue;
				case 26:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				case 42:
					instance.arg3 = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.arg4 = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			if (instance.eventKey != previous.eventKey)
			{
				if (instance.eventKey == null)
				{
					throw new ArgumentNullException("eventKey", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.eventKey);
			}
			if (instance.arg1 != null && instance.arg1 != previous.arg1)
			{
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.arg1);
			}
			if (instance.arg2 != null && instance.arg2 != previous.arg2)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.arg2);
			}
			if (instance.arg3 != null && instance.arg3 != previous.arg3)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.arg3);
			}
			if (instance.arg4 != null && instance.arg4 != previous.arg4)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.arg4);
			}
		}

		public static void Serialize(BufferStream stream, Entry instance)
		{
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
			if (instance.eventKey == null)
			{
				throw new ArgumentNullException("eventKey", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.eventKey);
			if (instance.arg1 != null)
			{
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.arg1);
			}
			if (instance.arg2 != null)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.arg2);
			}
			if (instance.arg3 != null)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.arg3);
			}
			if (instance.arg4 != null)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.arg4);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public List<Entry> logEntries;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanLog instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.clanId = 0L;
		if (instance.logEntries != null)
		{
			for (int i = 0; i < instance.logEntries.Count; i++)
			{
				if (instance.logEntries[i] != null)
				{
					instance.logEntries[i].ResetToPool();
					instance.logEntries[i] = null;
				}
			}
			List<Entry> list = instance.logEntries;
			Pool.Free<Entry>(ref list, false);
			instance.logEntries = list;
		}
		Pool.Free<ClanLog>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanLog with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanLog instance)
	{
		instance.clanId = clanId;
		if (logEntries != null)
		{
			instance.logEntries = Pool.Get<List<Entry>>();
			for (int i = 0; i < logEntries.Count; i++)
			{
				Entry item = logEntries[i].Copy();
				instance.logEntries.Add(item);
			}
		}
		else
		{
			instance.logEntries = null;
		}
	}

	public ClanLog Copy()
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		CopyTo(clanLog);
		return clanLog;
	}

	public static ClanLog Deserialize(BufferStream stream)
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		Deserialize(stream, clanLog, isDelta: false);
		return clanLog;
	}

	public static ClanLog DeserializeLengthDelimited(BufferStream stream)
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		DeserializeLengthDelimited(stream, clanLog, isDelta: false);
		return clanLog;
	}

	public static ClanLog DeserializeLength(BufferStream stream, int length)
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		DeserializeLength(stream, length, clanLog, isDelta: false);
		return clanLog;
	}

	public static ClanLog Deserialize(byte[] buffer)
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanLog, isDelta: false);
		return clanLog;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanLog previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanLog Deserialize(BufferStream stream, ClanLog instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.logEntries == null)
			{
				instance.logEntries = Pool.Get<List<Entry>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.logEntries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanLog DeserializeLengthDelimited(BufferStream stream, ClanLog instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.logEntries == null)
			{
				instance.logEntries = Pool.Get<List<Entry>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.logEntries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanLog DeserializeLength(BufferStream stream, int length, ClanLog instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.logEntries == null)
			{
				instance.logEntries = Pool.Get<List<Entry>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.logEntries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanLog instance, ClanLog previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.logEntries == null)
		{
			return;
		}
		for (int i = 0; i < instance.logEntries.Count; i++)
		{
			Entry entry = instance.logEntries[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.SerializeDelta(stream, entry, entry);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ClanLog instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.logEntries == null)
		{
			return;
		}
		for (int i = 0; i < instance.logEntries.Count; i++)
		{
			Entry instance2 = instance.logEntries[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (logEntries != null)
		{
			for (int i = 0; i < logEntries.Count; i++)
			{
				logEntries[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanScoreEvents : IDisposable, IPooled, IProto<ClanScoreEvents>, IProto
{
	public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
	{
		[NonSerialized]
		public long timestamp;

		[NonSerialized]
		public int type;

		[NonSerialized]
		public int score;

		[NonSerialized]
		public int multiplier;

		[NonSerialized]
		public ulong steamId;

		[NonSerialized]
		public ulong otherSteamId;

		[NonSerialized]
		public long otherClanId;

		[NonSerialized]
		public string arg1;

		[NonSerialized]
		public string arg2;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Entry instance)
		{
			if (instance.ShouldPool)
			{
				instance.timestamp = 0L;
				instance.type = 0;
				instance.score = 0;
				instance.multiplier = 0;
				instance.steamId = 0uL;
				instance.otherSteamId = 0uL;
				instance.otherClanId = 0L;
				instance.arg1 = string.Empty;
				instance.arg2 = string.Empty;
				Pool.Free<Entry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Entry instance)
		{
			instance.timestamp = timestamp;
			instance.type = type;
			instance.score = score;
			instance.multiplier = multiplier;
			instance.steamId = steamId;
			instance.otherSteamId = otherSteamId;
			instance.otherClanId = otherClanId;
			instance.arg1 = arg1;
			instance.arg2 = arg2;
		}

		public Entry Copy()
		{
			Entry entry = Pool.Get<Entry>();
			CopyTo(entry);
			return entry;
		}

		public static Entry Deserialize(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLengthDelimited(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLength(BufferStream stream, int length)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLength(stream, length, entry, isDelta: false);
			return entry;
		}

		public static Entry Deserialize(byte[] buffer)
		{
			Entry entry = Pool.Get<Entry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
				instance.type = 0;
				instance.score = 0;
				instance.multiplier = 0;
				instance.steamId = 0uL;
				instance.otherSteamId = 0uL;
				instance.otherClanId = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 74:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
				instance.type = 0;
				instance.score = 0;
				instance.multiplier = 0;
				instance.steamId = 0uL;
				instance.otherSteamId = 0uL;
				instance.otherClanId = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 74:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
				instance.type = 0;
				instance.score = 0;
				instance.multiplier = 0;
				instance.steamId = 0uL;
				instance.otherSteamId = 0uL;
				instance.otherClanId = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 74:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			if (instance.type != previous.type)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.score != previous.score)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
			if (instance.multiplier != previous.multiplier)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
			}
			if (instance.steamId != previous.steamId)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.otherSteamId != previous.otherSteamId)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
			}
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
			if (instance.arg1 != null && instance.arg1 != previous.arg1)
			{
				stream.WriteByte(66);
				ProtocolParser.WriteString(stream, instance.arg1);
			}
			if (instance.arg2 != null && instance.arg2 != previous.arg2)
			{
				stream.WriteByte(74);
				ProtocolParser.WriteString(stream, instance.arg2);
			}
		}

		public static void Serialize(BufferStream stream, Entry instance)
		{
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
			if (instance.type != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.score != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
			if (instance.multiplier != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
			}
			if (instance.steamId != 0L)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.otherSteamId != 0L)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
			}
			if (instance.otherClanId != 0L)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
			}
			if (instance.arg1 != null)
			{
				stream.WriteByte(66);
				ProtocolParser.WriteString(stream, instance.arg1);
			}
			if (instance.arg2 != null)
			{
				stream.WriteByte(74);
				ProtocolParser.WriteString(stream, instance.arg2);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public List<Entry> scoreEvents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanScoreEvents instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.clanId = 0L;
		if (instance.scoreEvents != null)
		{
			for (int i = 0; i < instance.scoreEvents.Count; i++)
			{
				if (instance.scoreEvents[i] != null)
				{
					instance.scoreEvents[i].ResetToPool();
					instance.scoreEvents[i] = null;
				}
			}
			List<Entry> list = instance.scoreEvents;
			Pool.Free<Entry>(ref list, false);
			instance.scoreEvents = list;
		}
		Pool.Free<ClanScoreEvents>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanScoreEvents with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanScoreEvents instance)
	{
		instance.clanId = clanId;
		if (scoreEvents != null)
		{
			instance.scoreEvents = Pool.Get<List<Entry>>();
			for (int i = 0; i < scoreEvents.Count; i++)
			{
				Entry item = scoreEvents[i].Copy();
				instance.scoreEvents.Add(item);
			}
		}
		else
		{
			instance.scoreEvents = null;
		}
	}

	public ClanScoreEvents Copy()
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		CopyTo(clanScoreEvents);
		return clanScoreEvents;
	}

	public static ClanScoreEvents Deserialize(BufferStream stream)
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		Deserialize(stream, clanScoreEvents, isDelta: false);
		return clanScoreEvents;
	}

	public static ClanScoreEvents DeserializeLengthDelimited(BufferStream stream)
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		DeserializeLengthDelimited(stream, clanScoreEvents, isDelta: false);
		return clanScoreEvents;
	}

	public static ClanScoreEvents DeserializeLength(BufferStream stream, int length)
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		DeserializeLength(stream, length, clanScoreEvents, isDelta: false);
		return clanScoreEvents;
	}

	public static ClanScoreEvents Deserialize(byte[] buffer)
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanScoreEvents, isDelta: false);
		return clanScoreEvents;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanScoreEvents previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanScoreEvents Deserialize(BufferStream stream, ClanScoreEvents instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.scoreEvents == null)
			{
				instance.scoreEvents = Pool.Get<List<Entry>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.scoreEvents.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanScoreEvents DeserializeLengthDelimited(BufferStream stream, ClanScoreEvents instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.scoreEvents == null)
			{
				instance.scoreEvents = Pool.Get<List<Entry>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.scoreEvents.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanScoreEvents DeserializeLength(BufferStream stream, int length, ClanScoreEvents instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.scoreEvents == null)
			{
				instance.scoreEvents = Pool.Get<List<Entry>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.scoreEvents.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanScoreEvents instance, ClanScoreEvents previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.scoreEvents == null)
		{
			return;
		}
		for (int i = 0; i < instance.scoreEvents.Count; i++)
		{
			Entry entry = instance.scoreEvents[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.SerializeDelta(stream, entry, entry);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ClanScoreEvents instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.scoreEvents == null)
		{
			return;
		}
		for (int i = 0; i < instance.scoreEvents.Count; i++)
		{
			Entry instance2 = instance.scoreEvents[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (scoreEvents != null)
		{
			for (int i = 0; i < scoreEvents.Count; i++)
			{
				scoreEvents[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanInvitations : IDisposable, IPooled, IProto<ClanInvitations>, IProto
{
	public class Invitation : IDisposable, IPooled, IProto<Invitation>, IProto
	{
		[NonSerialized]
		public long clanId;

		[NonSerialized]
		public ulong recruiter;

		[NonSerialized]
		public long timestamp;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Invitation instance)
		{
			if (instance.ShouldPool)
			{
				instance.clanId = 0L;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
				Pool.Free<Invitation>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Invitation with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Invitation instance)
		{
			instance.clanId = clanId;
			instance.recruiter = recruiter;
			instance.timestamp = timestamp;
		}

		public Invitation Copy()
		{
			Invitation invitation = Pool.Get<Invitation>();
			CopyTo(invitation);
			return invitation;
		}

		public static Invitation Deserialize(BufferStream stream)
		{
			Invitation invitation = Pool.Get<Invitation>();
			Deserialize(stream, invitation, isDelta: false);
			return invitation;
		}

		public static Invitation DeserializeLengthDelimited(BufferStream stream)
		{
			Invitation invitation = Pool.Get<Invitation>();
			DeserializeLengthDelimited(stream, invitation, isDelta: false);
			return invitation;
		}

		public static Invitation DeserializeLength(BufferStream stream, int length)
		{
			Invitation invitation = Pool.Get<Invitation>();
			DeserializeLength(stream, length, invitation, isDelta: false);
			return invitation;
		}

		public static Invitation Deserialize(byte[] buffer)
		{
			Invitation invitation = Pool.Get<Invitation>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, invitation, isDelta: false);
			return invitation;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Invitation previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Invitation Deserialize(BufferStream stream, Invitation instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Invitation DeserializeLengthDelimited(BufferStream stream, Invitation instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Invitation DeserializeLength(BufferStream stream, int length, Invitation instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Invitation instance, Invitation previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			if (instance.recruiter != previous.recruiter)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.recruiter);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}

		public static void Serialize(BufferStream stream, Invitation instance)
		{
			if (instance.clanId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			}
			if (instance.recruiter != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.recruiter);
			}
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Invitation> invitations;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanInvitations instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.invitations != null)
		{
			for (int i = 0; i < instance.invitations.Count; i++)
			{
				if (instance.invitations[i] != null)
				{
					instance.invitations[i].ResetToPool();
					instance.invitations[i] = null;
				}
			}
			List<Invitation> list = instance.invitations;
			Pool.Free<Invitation>(ref list, false);
			instance.invitations = list;
		}
		Pool.Free<ClanInvitations>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanInvitations with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanInvitations instance)
	{
		if (invitations != null)
		{
			instance.invitations = Pool.Get<List<Invitation>>();
			for (int i = 0; i < invitations.Count; i++)
			{
				Invitation item = invitations[i].Copy();
				instance.invitations.Add(item);
			}
		}
		else
		{
			instance.invitations = null;
		}
	}

	public ClanInvitations Copy()
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		CopyTo(clanInvitations);
		return clanInvitations;
	}

	public static ClanInvitations Deserialize(BufferStream stream)
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		Deserialize(stream, clanInvitations, isDelta: false);
		return clanInvitations;
	}

	public static ClanInvitations DeserializeLengthDelimited(BufferStream stream)
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		DeserializeLengthDelimited(stream, clanInvitations, isDelta: false);
		return clanInvitations;
	}

	public static ClanInvitations DeserializeLength(BufferStream stream, int length)
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		DeserializeLength(stream, length, clanInvitations, isDelta: false);
		return clanInvitations;
	}

	public static ClanInvitations Deserialize(byte[] buffer)
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanInvitations, isDelta: false);
		return clanInvitations;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanInvitations previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanInvitations Deserialize(BufferStream stream, ClanInvitations instance, bool isDelta)
	{
		if (!isDelta && instance.invitations == null)
		{
			instance.invitations = Pool.Get<List<Invitation>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.invitations.Add(Invitation.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanInvitations DeserializeLengthDelimited(BufferStream stream, ClanInvitations instance, bool isDelta)
	{
		if (!isDelta && instance.invitations == null)
		{
			instance.invitations = Pool.Get<List<Invitation>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.invitations.Add(Invitation.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanInvitations DeserializeLength(BufferStream stream, int length, ClanInvitations instance, bool isDelta)
	{
		if (!isDelta && instance.invitations == null)
		{
			instance.invitations = Pool.Get<List<Invitation>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.invitations.Add(Invitation.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanInvitations instance, ClanInvitations previous)
	{
		if (instance.invitations == null)
		{
			return;
		}
		for (int i = 0; i < instance.invitations.Count; i++)
		{
			Invitation invitation = instance.invitations[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Invitation.SerializeDelta(stream, invitation, invitation);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field invitations (ProtoBuf.ClanInvitations.Invitation)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ClanInvitations instance)
	{
		if (instance.invitations == null)
		{
			return;
		}
		for (int i = 0; i < instance.invitations.Count; i++)
		{
			Invitation instance2 = instance.invitations[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Invitation.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field invitations (ProtoBuf.ClanInvitations.Invitation)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (invitations != null)
		{
			for (int i = 0; i < invitations.Count; i++)
			{
				invitations[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanLeaderboard : IDisposable, IPooled, IProto<ClanLeaderboard>, IProto
{
	public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
	{
		[NonSerialized]
		public long clanId;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public long score;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Entry instance)
		{
			if (instance.ShouldPool)
			{
				instance.clanId = 0L;
				instance.name = string.Empty;
				instance.score = 0L;
				Pool.Free<Entry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Entry instance)
		{
			instance.clanId = clanId;
			instance.name = name;
			instance.score = score;
		}

		public Entry Copy()
		{
			Entry entry = Pool.Get<Entry>();
			CopyTo(entry);
			return entry;
		}

		public static Entry Deserialize(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLengthDelimited(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLength(BufferStream stream, int length)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLength(stream, length, entry, isDelta: false);
			return entry;
		}

		public static Entry Deserialize(byte[] buffer)
		{
			Entry entry = Pool.Get<Entry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.score = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.score = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.score = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.name);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}

		public static void Serialize(BufferStream stream, Entry instance)
		{
			if (instance.clanId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.score != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Entry> entries;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanLeaderboard instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entries != null)
		{
			for (int i = 0; i < instance.entries.Count; i++)
			{
				if (instance.entries[i] != null)
				{
					instance.entries[i].ResetToPool();
					instance.entries[i] = null;
				}
			}
			List<Entry> list = instance.entries;
			Pool.Free<Entry>(ref list, false);
			instance.entries = list;
		}
		Pool.Free<ClanLeaderboard>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanLeaderboard with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanLeaderboard instance)
	{
		if (entries != null)
		{
			instance.entries = Pool.Get<List<Entry>>();
			for (int i = 0; i < entries.Count; i++)
			{
				Entry item = entries[i].Copy();
				instance.entries.Add(item);
			}
		}
		else
		{
			instance.entries = null;
		}
	}

	public ClanLeaderboard Copy()
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		CopyTo(clanLeaderboard);
		return clanLeaderboard;
	}

	public static ClanLeaderboard Deserialize(BufferStream stream)
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		Deserialize(stream, clanLeaderboard, isDelta: false);
		return clanLeaderboard;
	}

	public static ClanLeaderboard DeserializeLengthDelimited(BufferStream stream)
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		DeserializeLengthDelimited(stream, clanLeaderboard, isDelta: false);
		return clanLeaderboard;
	}

	public static ClanLeaderboard DeserializeLength(BufferStream stream, int length)
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		DeserializeLength(stream, length, clanLeaderboard, isDelta: false);
		return clanLeaderboard;
	}

	public static ClanLeaderboard Deserialize(byte[] buffer)
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanLeaderboard, isDelta: false);
		return clanLeaderboard;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanLeaderboard previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanLeaderboard Deserialize(BufferStream stream, ClanLeaderboard instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<Entry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanLeaderboard DeserializeLengthDelimited(BufferStream stream, ClanLeaderboard instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<Entry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanLeaderboard DeserializeLength(BufferStream stream, int length, ClanLeaderboard instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<Entry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanLeaderboard instance, ClanLeaderboard previous)
	{
		if (instance.entries == null)
		{
			return;
		}
		for (int i = 0; i < instance.entries.Count; i++)
		{
			Entry entry = instance.entries[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.SerializeDelta(stream, entry, entry);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ClanLeaderboard instance)
	{
		if (instance.entries == null)
		{
			return;
		}
		for (int i = 0; i < instance.entries.Count; i++)
		{
			Entry instance2 = instance.entries[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entries != null)
		{
			for (int i = 0; i < entries.Count; i++)
			{
				entries[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public struct Half3 : IProto<Half3>, IProto, IEquatable<Half3>
{
	[NonSerialized]
	public uint x;

	[NonSerialized]
	public uint y;

	[NonSerialized]
	public uint z;

	public static void ResetToPool(Half3 instance)
	{
		instance.x = 0u;
		instance.y = 0u;
		instance.z = 0u;
	}

	public void CopyTo(Half3 instance)
	{
		instance.x = x;
		instance.y = y;
		instance.z = z;
	}

	public Half3 Copy()
	{
		Half3 half = default(Half3);
		CopyTo(half);
		return half;
	}

	public static Half3 Deserialize(BufferStream stream)
	{
		Half3 instance = default(Half3);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static Half3 DeserializeLengthDelimited(BufferStream stream)
	{
		Half3 instance = default(Half3);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static Half3 DeserializeLength(BufferStream stream, int length)
	{
		Half3 instance = default(Half3);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static Half3 Deserialize(byte[] buffer)
	{
		Half3 instance = default(Half3);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, Half3 previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static Half3 Deserialize(BufferStream stream, ref Half3 instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0u;
			instance.y = 0u;
			instance.z = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.x = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.y = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.z = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Half3 DeserializeLengthDelimited(BufferStream stream, ref Half3 instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0u;
			instance.y = 0u;
			instance.z = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.x = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.y = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.z = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Half3 DeserializeLength(BufferStream stream, int length, ref Half3 instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0u;
			instance.y = 0u;
			instance.z = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.x = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.y = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.z = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Half3 instance, Half3 previous)
	{
		if (instance.x != previous.x)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.y);
		}
		if (instance.z != previous.z)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.z);
		}
	}

	public static void Serialize(BufferStream stream, Half3 instance)
	{
		if (instance.x != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.x);
		}
		if (instance.y != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.y);
		}
		if (instance.z != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.z);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}

	public bool Equals(Half3 other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is Half3)
		{
			return Equals((Half3)obj);
		}
		return false;
	}

	public static bool operator ==(Half3 a, Half3 b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(Half3 a, Half3 b)
	{
		return !a.Equals(b);
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}
}


