using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class VDDrawEntry : IDisposable, IPooled, IProto<VDDrawEntry>, IProto
{
	public enum Category
	{
		Line,
		Log,
		Text,
		Sphere,
		Box
	}

	[NonSerialized]
	public string entityName;

	[NonSerialized]
	public int frame;

	[NonSerialized]
	public string label;

	[NonSerialized]
	public Category category;

	[NonSerialized]
	public Color color;

	[NonSerialized]
	public Vector3 start;

	[NonSerialized]
	public Vector3 end;

	[NonSerialized]
	public float sizeX;

	[NonSerialized]
	public float sizeY;

	[NonSerialized]
	public float sizeZ;

	[NonSerialized]
	public string message;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VDDrawEntry instance)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.entityName = string.Empty;
			instance.frame = 0;
			instance.label = string.Empty;
			instance.category = Category.Line;
			instance.color = default(Color);
			instance.start = default(Vector3);
			instance.end = default(Vector3);
			instance.sizeX = 0f;
			instance.sizeY = 0f;
			instance.sizeZ = 0f;
			instance.message = string.Empty;
			Pool.Free<VDDrawEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VDDrawEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VDDrawEntry instance)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		instance.entityName = entityName;
		instance.frame = frame;
		instance.label = label;
		instance.category = category;
		instance.color = color;
		instance.start = start;
		instance.end = end;
		instance.sizeX = sizeX;
		instance.sizeY = sizeY;
		instance.sizeZ = sizeZ;
		instance.message = message;
	}

	public VDDrawEntry Copy()
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		CopyTo(vDDrawEntry);
		return vDDrawEntry;
	}

	public static VDDrawEntry Deserialize(BufferStream stream)
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		Deserialize(stream, vDDrawEntry, isDelta: false);
		return vDDrawEntry;
	}

	public static VDDrawEntry DeserializeLengthDelimited(BufferStream stream)
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		DeserializeLengthDelimited(stream, vDDrawEntry, isDelta: false);
		return vDDrawEntry;
	}

	public static VDDrawEntry DeserializeLength(BufferStream stream, int length)
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		DeserializeLength(stream, length, vDDrawEntry, isDelta: false);
		return vDDrawEntry;
	}

	public static VDDrawEntry Deserialize(byte[] buffer)
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vDDrawEntry, isDelta: false);
		return vDDrawEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VDDrawEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VDDrawEntry Deserialize(BufferStream stream, VDDrawEntry instance, bool isDelta)
	{
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entityName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.frame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.category = (Category)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.start, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.end, isDelta);
				continue;
			case 69:
				instance.sizeX = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.sizeY = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sizeZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VDDrawEntry DeserializeLengthDelimited(BufferStream stream, VDDrawEntry instance, bool isDelta)
	{
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entityName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.frame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.category = (Category)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.start, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.end, isDelta);
				continue;
			case 69:
				instance.sizeX = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.sizeY = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sizeZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VDDrawEntry DeserializeLength(BufferStream stream, int length, VDDrawEntry instance, bool isDelta)
	{
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entityName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.frame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.category = (Category)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.start, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.end, isDelta);
				continue;
			case 69:
				instance.sizeX = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.sizeY = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sizeZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VDDrawEntry instance, VDDrawEntry previous)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entityName != previous.entityName)
		{
			if (instance.entityName == null)
			{
				throw new ArgumentNullException("entityName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.entityName);
		}
		if (instance.frame != previous.frame)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.frame);
		}
		if (instance.label != previous.label)
		{
			if (instance.label == null)
			{
				throw new ArgumentNullException("label", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.label);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.category);
		if (instance.color != previous.color)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.color, previous.color);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.start != previous.start)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.start, previous.start);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field start (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.end != previous.end)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.end, previous.end);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field end (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.sizeX != previous.sizeX)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.sizeX);
		}
		if (instance.sizeY != previous.sizeY)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.sizeY);
		}
		if (instance.sizeZ != previous.sizeZ)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.sizeZ);
		}
		if (instance.message != null && instance.message != previous.message)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.message);
		}
	}

	public static void Serialize(BufferStream stream, VDDrawEntry instance)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entityName == null)
		{
			throw new ArgumentNullException("entityName", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.entityName);
		if (instance.frame != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.frame);
		}
		if (instance.label == null)
		{
			throw new ArgumentNullException("label", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.label);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.category);
		if (instance.color != default(Color))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ColorSerialized.Serialize(stream, instance.color);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.start != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.start);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field start (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.end != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.end);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field end (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.sizeX != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.sizeX);
		}
		if (instance.sizeY != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.sizeY);
		}
		if (instance.sizeZ != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.sizeZ);
		}
		if (instance.message != null)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.message);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachinePurchaseHistoryEntryMessage : IDisposable, IPooled, IProto<VendingMachinePurchaseHistoryEntryMessage>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public int amount;

	[NonSerialized]
	public int priceID;

	[NonSerialized]
	public int price;

	[NonSerialized]
	public int dateTime;

	[NonSerialized]
	public bool itemIsBp;

	[NonSerialized]
	public bool priceIsBp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachinePurchaseHistoryEntryMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.amount = 0;
			instance.priceID = 0;
			instance.price = 0;
			instance.dateTime = 0;
			instance.itemIsBp = false;
			instance.priceIsBp = false;
			Pool.Free<VendingMachinePurchaseHistoryEntryMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachinePurchaseHistoryEntryMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachinePurchaseHistoryEntryMessage instance)
	{
		instance.itemID = itemID;
		instance.amount = amount;
		instance.priceID = priceID;
		instance.price = price;
		instance.dateTime = dateTime;
		instance.itemIsBp = itemIsBp;
		instance.priceIsBp = priceIsBp;
	}

	public VendingMachinePurchaseHistoryEntryMessage Copy()
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		CopyTo(vendingMachinePurchaseHistoryEntryMessage);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public static VendingMachinePurchaseHistoryEntryMessage Deserialize(BufferStream stream)
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		Deserialize(stream, vendingMachinePurchaseHistoryEntryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public static VendingMachinePurchaseHistoryEntryMessage DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		DeserializeLengthDelimited(stream, vendingMachinePurchaseHistoryEntryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public static VendingMachinePurchaseHistoryEntryMessage DeserializeLength(BufferStream stream, int length)
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		DeserializeLength(stream, length, vendingMachinePurchaseHistoryEntryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public static VendingMachinePurchaseHistoryEntryMessage Deserialize(byte[] buffer)
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachinePurchaseHistoryEntryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachinePurchaseHistoryEntryMessage Deserialize(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.dateTime = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachinePurchaseHistoryEntryMessage DeserializeLengthDelimited(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.dateTime = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachinePurchaseHistoryEntryMessage DeserializeLength(BufferStream stream, int length, VendingMachinePurchaseHistoryEntryMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.dateTime = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage instance, VendingMachinePurchaseHistoryEntryMessage previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.priceID != previous.priceID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.priceID);
		}
		if (instance.price != previous.price)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.price);
		}
		if (instance.dateTime != previous.dateTime)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dateTime);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.itemIsBp);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.priceIsBp);
	}

	public static void Serialize(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.priceID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.priceID);
		}
		if (instance.price != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.price);
		}
		if (instance.dateTime != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dateTime);
		}
		if (instance.itemIsBp)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.itemIsBp);
		}
		if (instance.priceIsBp)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.priceIsBp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachinePurchaseHistoryEntrySmallMessage : IDisposable, IPooled, IProto<VendingMachinePurchaseHistoryEntrySmallMessage>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public int amount;

	[NonSerialized]
	public int priceID;

	[NonSerialized]
	public int price;

	[NonSerialized]
	public bool itemIsBp;

	[NonSerialized]
	public bool priceIsBp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachinePurchaseHistoryEntrySmallMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.amount = 0;
			instance.priceID = 0;
			instance.price = 0;
			instance.itemIsBp = false;
			instance.priceIsBp = false;
			Pool.Free<VendingMachinePurchaseHistoryEntrySmallMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachinePurchaseHistoryEntrySmallMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachinePurchaseHistoryEntrySmallMessage instance)
	{
		instance.itemID = itemID;
		instance.amount = amount;
		instance.priceID = priceID;
		instance.price = price;
		instance.itemIsBp = itemIsBp;
		instance.priceIsBp = priceIsBp;
	}

	public VendingMachinePurchaseHistoryEntrySmallMessage Copy()
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		CopyTo(vendingMachinePurchaseHistoryEntrySmallMessage);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage Deserialize(BufferStream stream)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		Deserialize(stream, vendingMachinePurchaseHistoryEntrySmallMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		DeserializeLengthDelimited(stream, vendingMachinePurchaseHistoryEntrySmallMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage DeserializeLength(BufferStream stream, int length)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		DeserializeLength(stream, length, vendingMachinePurchaseHistoryEntrySmallMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage Deserialize(byte[] buffer)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachinePurchaseHistoryEntrySmallMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage Deserialize(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage DeserializeLengthDelimited(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage DeserializeLength(BufferStream stream, int length, VendingMachinePurchaseHistoryEntrySmallMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage instance, VendingMachinePurchaseHistoryEntrySmallMessage previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.priceID != previous.priceID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.priceID);
		}
		if (instance.price != previous.price)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.price);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.itemIsBp);
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.priceIsBp);
	}

	public static void Serialize(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.priceID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.priceID);
		}
		if (instance.price != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.price);
		}
		if (instance.itemIsBp)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.itemIsBp);
		}
		if (instance.priceIsBp)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.priceIsBp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachinePurchaseHistoryMessage : IDisposable, IPooled, IProto<VendingMachinePurchaseHistoryMessage>, IProto
{
	[NonSerialized]
	public List<VendingMachinePurchaseHistoryEntryMessage> transactions;

	[NonSerialized]
	public List<VendingMachinePurchaseHistoryEntrySmallMessage> smallTransactions;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachinePurchaseHistoryMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.transactions != null)
		{
			for (int i = 0; i < instance.transactions.Count; i++)
			{
				if (instance.transactions[i] != null)
				{
					instance.transactions[i].ResetToPool();
					instance.transactions[i] = null;
				}
			}
			List<VendingMachinePurchaseHistoryEntryMessage> list = instance.transactions;
			Pool.Free<VendingMachinePurchaseHistoryEntryMessage>(ref list, false);
			instance.transactions = list;
		}
		if (instance.smallTransactions != null)
		{
			for (int j = 0; j < instance.smallTransactions.Count; j++)
			{
				if (instance.smallTransactions[j] != null)
				{
					instance.smallTransactions[j].ResetToPool();
					instance.smallTransactions[j] = null;
				}
			}
			List<VendingMachinePurchaseHistoryEntrySmallMessage> list2 = instance.smallTransactions;
			Pool.Free<VendingMachinePurchaseHistoryEntrySmallMessage>(ref list2, false);
			instance.smallTransactions = list2;
		}
		Pool.Free<VendingMachinePurchaseHistoryMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachinePurchaseHistoryMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachinePurchaseHistoryMessage instance)
	{
		if (transactions != null)
		{
			instance.transactions = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			for (int i = 0; i < transactions.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage item = transactions[i].Copy();
				instance.transactions.Add(item);
			}
		}
		else
		{
			instance.transactions = null;
		}
		if (smallTransactions != null)
		{
			instance.smallTransactions = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
			for (int j = 0; j < smallTransactions.Count; j++)
			{
				VendingMachinePurchaseHistoryEntrySmallMessage item2 = smallTransactions[j].Copy();
				instance.smallTransactions.Add(item2);
			}
		}
		else
		{
			instance.smallTransactions = null;
		}
	}

	public VendingMachinePurchaseHistoryMessage Copy()
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		CopyTo(vendingMachinePurchaseHistoryMessage);
		return vendingMachinePurchaseHistoryMessage;
	}

	public static VendingMachinePurchaseHistoryMessage Deserialize(BufferStream stream)
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		Deserialize(stream, vendingMachinePurchaseHistoryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryMessage;
	}

	public static VendingMachinePurchaseHistoryMessage DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		DeserializeLengthDelimited(stream, vendingMachinePurchaseHistoryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryMessage;
	}

	public static VendingMachinePurchaseHistoryMessage DeserializeLength(BufferStream stream, int length)
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		DeserializeLength(stream, length, vendingMachinePurchaseHistoryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryMessage;
	}

	public static VendingMachinePurchaseHistoryMessage Deserialize(byte[] buffer)
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachinePurchaseHistoryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachinePurchaseHistoryMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachinePurchaseHistoryMessage Deserialize(BufferStream stream, VendingMachinePurchaseHistoryMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.transactions == null)
			{
				instance.transactions = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.smallTransactions == null)
			{
				instance.smallTransactions = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.transactions.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.smallTransactions.Add(VendingMachinePurchaseHistoryEntrySmallMessage.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachinePurchaseHistoryMessage DeserializeLengthDelimited(BufferStream stream, VendingMachinePurchaseHistoryMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.transactions == null)
			{
				instance.transactions = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.smallTransactions == null)
			{
				instance.smallTransactions = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.transactions.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.smallTransactions.Add(VendingMachinePurchaseHistoryEntrySmallMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachinePurchaseHistoryMessage DeserializeLength(BufferStream stream, int length, VendingMachinePurchaseHistoryMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.transactions == null)
			{
				instance.transactions = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.smallTransactions == null)
			{
				instance.smallTransactions = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.transactions.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.smallTransactions.Add(VendingMachinePurchaseHistoryEntrySmallMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachinePurchaseHistoryMessage instance, VendingMachinePurchaseHistoryMessage previous)
	{
		if (instance.transactions != null)
		{
			for (int i = 0; i < instance.transactions.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = instance.transactions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VendingMachinePurchaseHistoryEntryMessage.SerializeDelta(stream, vendingMachinePurchaseHistoryEntryMessage, vendingMachinePurchaseHistoryEntryMessage);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field transactions (ProtoBuf.VendingMachinePurchaseHistoryEntryMessage)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.smallTransactions == null)
		{
			return;
		}
		for (int j = 0; j < instance.smallTransactions.Count; j++)
		{
			VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = instance.smallTransactions[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			VendingMachinePurchaseHistoryEntrySmallMessage.SerializeDelta(stream, vendingMachinePurchaseHistoryEntrySmallMessage, vendingMachinePurchaseHistoryEntrySmallMessage);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field smallTransactions (ProtoBuf.VendingMachinePurchaseHistoryEntrySmallMessage)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, VendingMachinePurchaseHistoryMessage instance)
	{
		if (instance.transactions != null)
		{
			for (int i = 0; i < instance.transactions.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage instance2 = instance.transactions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VendingMachinePurchaseHistoryEntryMessage.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field transactions (ProtoBuf.VendingMachinePurchaseHistoryEntryMessage)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.smallTransactions == null)
		{
			return;
		}
		for (int j = 0; j < instance.smallTransactions.Count; j++)
		{
			VendingMachinePurchaseHistoryEntrySmallMessage instance3 = instance.smallTransactions[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			VendingMachinePurchaseHistoryEntrySmallMessage.Serialize(stream, instance3);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field smallTransactions (ProtoBuf.VendingMachinePurchaseHistoryEntrySmallMessage)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (transactions != null)
		{
			for (int i = 0; i < transactions.Count; i++)
			{
				transactions[i]?.InspectUids(action);
			}
		}
		if (smallTransactions != null)
		{
			for (int j = 0; j < smallTransactions.Count; j++)
			{
				smallTransactions[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachineLongTermStats : IDisposable, IPooled, IProto<VendingMachineLongTermStats>, IProto
{
	[NonSerialized]
	public int numberOfPurchases;

	[NonSerialized]
	public long bestSalesHour;

	[NonSerialized]
	public int uniqueCustomers;

	[NonSerialized]
	public int repeatCustomers;

	[NonSerialized]
	public int bestCustomer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachineLongTermStats instance)
	{
		if (instance.ShouldPool)
		{
			instance.numberOfPurchases = 0;
			instance.bestSalesHour = 0L;
			instance.uniqueCustomers = 0;
			instance.repeatCustomers = 0;
			instance.bestCustomer = 0;
			Pool.Free<VendingMachineLongTermStats>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachineLongTermStats with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachineLongTermStats instance)
	{
		instance.numberOfPurchases = numberOfPurchases;
		instance.bestSalesHour = bestSalesHour;
		instance.uniqueCustomers = uniqueCustomers;
		instance.repeatCustomers = repeatCustomers;
		instance.bestCustomer = bestCustomer;
	}

	public VendingMachineLongTermStats Copy()
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		CopyTo(vendingMachineLongTermStats);
		return vendingMachineLongTermStats;
	}

	public static VendingMachineLongTermStats Deserialize(BufferStream stream)
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		Deserialize(stream, vendingMachineLongTermStats, isDelta: false);
		return vendingMachineLongTermStats;
	}

	public static VendingMachineLongTermStats DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		DeserializeLengthDelimited(stream, vendingMachineLongTermStats, isDelta: false);
		return vendingMachineLongTermStats;
	}

	public static VendingMachineLongTermStats DeserializeLength(BufferStream stream, int length)
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		DeserializeLength(stream, length, vendingMachineLongTermStats, isDelta: false);
		return vendingMachineLongTermStats;
	}

	public static VendingMachineLongTermStats Deserialize(byte[] buffer)
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachineLongTermStats, isDelta: false);
		return vendingMachineLongTermStats;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachineLongTermStats previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachineLongTermStats Deserialize(BufferStream stream, VendingMachineLongTermStats instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.numberOfPurchases = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.bestSalesHour = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.uniqueCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.repeatCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bestCustomer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachineLongTermStats DeserializeLengthDelimited(BufferStream stream, VendingMachineLongTermStats instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.numberOfPurchases = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.bestSalesHour = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.uniqueCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.repeatCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bestCustomer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachineLongTermStats DeserializeLength(BufferStream stream, int length, VendingMachineLongTermStats instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.numberOfPurchases = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.bestSalesHour = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.uniqueCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.repeatCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bestCustomer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachineLongTermStats instance, VendingMachineLongTermStats previous)
	{
		if (instance.numberOfPurchases != previous.numberOfPurchases)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numberOfPurchases);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.bestSalesHour);
		if (instance.uniqueCustomers != previous.uniqueCustomers)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.uniqueCustomers);
		}
		if (instance.repeatCustomers != previous.repeatCustomers)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.repeatCustomers);
		}
		if (instance.bestCustomer != previous.bestCustomer)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bestCustomer);
		}
	}

	public static void Serialize(BufferStream stream, VendingMachineLongTermStats instance)
	{
		if (instance.numberOfPurchases != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numberOfPurchases);
		}
		if (instance.bestSalesHour != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bestSalesHour);
		}
		if (instance.uniqueCustomers != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.uniqueCustomers);
		}
		if (instance.repeatCustomers != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.repeatCustomers);
		}
		if (instance.bestCustomer != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bestCustomer);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ChickenCoopStatusUpdate : IDisposable, IPooled, IProto<ChickenCoopStatusUpdate>, IProto
{
	[NonSerialized]
	public List<FarmableAnimalStatus> animals;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ChickenCoopStatusUpdate instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.animals != null)
		{
			for (int i = 0; i < instance.animals.Count; i++)
			{
				if (instance.animals[i] != null)
				{
					instance.animals[i].ResetToPool();
					instance.animals[i] = null;
				}
			}
			List<FarmableAnimalStatus> list = instance.animals;
			Pool.Free<FarmableAnimalStatus>(ref list, false);
			instance.animals = list;
		}
		Pool.Free<ChickenCoopStatusUpdate>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ChickenCoopStatusUpdate with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ChickenCoopStatusUpdate instance)
	{
		if (animals != null)
		{
			instance.animals = Pool.Get<List<FarmableAnimalStatus>>();
			for (int i = 0; i < animals.Count; i++)
			{
				FarmableAnimalStatus item = animals[i].Copy();
				instance.animals.Add(item);
			}
		}
		else
		{
			instance.animals = null;
		}
	}

	public ChickenCoopStatusUpdate Copy()
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		CopyTo(chickenCoopStatusUpdate);
		return chickenCoopStatusUpdate;
	}

	public static ChickenCoopStatusUpdate Deserialize(BufferStream stream)
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		Deserialize(stream, chickenCoopStatusUpdate, isDelta: false);
		return chickenCoopStatusUpdate;
	}

	public static ChickenCoopStatusUpdate DeserializeLengthDelimited(BufferStream stream)
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		DeserializeLengthDelimited(stream, chickenCoopStatusUpdate, isDelta: false);
		return chickenCoopStatusUpdate;
	}

	public static ChickenCoopStatusUpdate DeserializeLength(BufferStream stream, int length)
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		DeserializeLength(stream, length, chickenCoopStatusUpdate, isDelta: false);
		return chickenCoopStatusUpdate;
	}

	public static ChickenCoopStatusUpdate Deserialize(byte[] buffer)
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, chickenCoopStatusUpdate, isDelta: false);
		return chickenCoopStatusUpdate;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ChickenCoopStatusUpdate previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ChickenCoopStatusUpdate Deserialize(BufferStream stream, ChickenCoopStatusUpdate instance, bool isDelta)
	{
		if (!isDelta && instance.animals == null)
		{
			instance.animals = Pool.Get<List<FarmableAnimalStatus>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.animals.Add(FarmableAnimalStatus.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ChickenCoopStatusUpdate DeserializeLengthDelimited(BufferStream stream, ChickenCoopStatusUpdate instance, bool isDelta)
	{
		if (!isDelta && instance.animals == null)
		{
			instance.animals = Pool.Get<List<FarmableAnimalStatus>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.animals.Add(FarmableAnimalStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ChickenCoopStatusUpdate DeserializeLength(BufferStream stream, int length, ChickenCoopStatusUpdate instance, bool isDelta)
	{
		if (!isDelta && instance.animals == null)
		{
			instance.animals = Pool.Get<List<FarmableAnimalStatus>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.animals.Add(FarmableAnimalStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ChickenCoopStatusUpdate instance, ChickenCoopStatusUpdate previous)
	{
		if (instance.animals == null)
		{
			return;
		}
		for (int i = 0; i < instance.animals.Count; i++)
		{
			FarmableAnimalStatus farmableAnimalStatus = instance.animals[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			FarmableAnimalStatus.SerializeDelta(stream, farmableAnimalStatus, farmableAnimalStatus);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ChickenCoopStatusUpdate instance)
	{
		if (instance.animals == null)
		{
			return;
		}
		for (int i = 0; i < instance.animals.Count; i++)
		{
			FarmableAnimalStatus instance2 = instance.animals[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			FarmableAnimalStatus.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (animals != null)
		{
			for (int i = 0; i < animals.Count; i++)
			{
				animals[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class FarmableAnimalStatus : IDisposable, IPooled, IProto<FarmableAnimalStatus>, IProto
{
	[NonSerialized]
	public NetworkableId animal;

	[NonSerialized]
	public FarmableAnimal data;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FarmableAnimalStatus instance)
	{
		if (instance.ShouldPool)
		{
			instance.animal = default(NetworkableId);
			if (instance.data != null)
			{
				instance.data.ResetToPool();
				instance.data = null;
			}
			Pool.Free<FarmableAnimalStatus>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FarmableAnimalStatus with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FarmableAnimalStatus instance)
	{
		instance.animal = animal;
		if (data != null)
		{
			if (instance.data == null)
			{
				instance.data = data.Copy();
			}
			else
			{
				data.CopyTo(instance.data);
			}
		}
		else
		{
			instance.data = null;
		}
	}

	public FarmableAnimalStatus Copy()
	{
		FarmableAnimalStatus farmableAnimalStatus = Pool.Get<FarmableAnimalStatus>();
		CopyTo(farmableAnimalStatus);
		return farmableAnimalStatus;
	}

	public static FarmableAnimalStatus Deserialize(BufferStream stream)
	{
		FarmableAnimalStatus farmableAnimalStatus = Pool.Get<FarmableAnimalStatus>();
		Deserialize(stream, farmableAnimalStatus, isDelta: false);
		return farmableAnimalStatus;
	}

	public static FarmableAnimalStatus DeserializeLengthDelimited(BufferStream stream)
	{
		FarmableAnimalStatus farmableAnimalStatus = Pool.Get<FarmableAnimalStatus>();
		DeserializeLengthDelimited(stream, farmableAnimalStatus, isDelta: false);
		return farmableAnimalStatus;
	}

	public static FarmableAnimalStatus DeserializeLength(BufferStream stream, int length)
	{
		FarmableAnimalStatus farmableAnimalStatus = Pool.Get<FarmableAnimalStatus>();
		DeserializeLength(stream, length, farmableAnimalStatus, isDelta: false);
		return farmableAnimalStatus;
	}

	public static FarmableAnimalStatus Deserialize(byte[] buffer)
	{
		FarmableAnimalStatus farmableAnimalStatus = Pool.Get<FarmableAnimalStatus>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, farmableAnimalStatus, isDelta: false);
		return farmableAnimalStatus;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FarmableAnimalStatus previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FarmableAnimalStatus Deserialize(BufferStream stream, FarmableAnimalStatus instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.animal = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.data == null)
				{
					instance.data = FarmableAnimal.DeserializeLengthDelimited(stream);
				}
				else
				{
					FarmableAnimal.DeserializeLengthDelimited(stream, instance.data, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static FarmableAnimalStatus DeserializeLengthDelimited(BufferStream stream, FarmableAnimalStatus instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.animal = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.data == null)
				{
					instance.data = FarmableAnimal.DeserializeLengthDelimited(stream);
				}
				else
				{
					FarmableAnimal.DeserializeLengthDelimited(stream, instance.data, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FarmableAnimalStatus DeserializeLength(BufferStream stream, int length, FarmableAnimalStatus instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.animal = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.data == null)
				{
					instance.data = FarmableAnimal.DeserializeLengthDelimited(stream);
				}
				else
				{
					FarmableAnimal.DeserializeLengthDelimited(stream, instance.data, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FarmableAnimalStatus instance, FarmableAnimalStatus previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.animal.Value);
		if (instance.data == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		FarmableAnimal.SerializeDelta(stream, instance.data, previous.data);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, FarmableAnimalStatus instance)
	{
		if (instance.animal != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.animal.Value);
		}
		if (instance.data == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		FarmableAnimal.Serialize(stream, instance.data);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref animal.Value);
		data?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NPCSensesState : IDisposable, IPooled, IProto<NPCSensesState>, IProto
{
	[NonSerialized]
	public NetworkableId targetEntityId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NPCSensesState instance)
	{
		if (instance.ShouldPool)
		{
			instance.targetEntityId = default(NetworkableId);
			Pool.Free<NPCSensesState>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NPCSensesState with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NPCSensesState instance)
	{
		instance.targetEntityId = targetEntityId;
	}

	public NPCSensesState Copy()
	{
		NPCSensesState nPCSensesState = Pool.Get<NPCSensesState>();
		CopyTo(nPCSensesState);
		return nPCSensesState;
	}

	public static NPCSensesState Deserialize(BufferStream stream)
	{
		NPCSensesState nPCSensesState = Pool.Get<NPCSensesState>();
		Deserialize(stream, nPCSensesState, isDelta: false);
		return nPCSensesState;
	}

	public static NPCSensesState DeserializeLengthDelimited(BufferStream stream)
	{
		NPCSensesState nPCSensesState = Pool.Get<NPCSensesState>();
		DeserializeLengthDelimited(stream, nPCSensesState, isDelta: false);
		return nPCSensesState;
	}

	public static NPCSensesState DeserializeLength(BufferStream stream, int length)
	{
		NPCSensesState nPCSensesState = Pool.Get<NPCSensesState>();
		DeserializeLength(stream, length, nPCSensesState, isDelta: false);
		return nPCSensesState;
	}

	public static NPCSensesState Deserialize(byte[] buffer)
	{
		NPCSensesState nPCSensesState = Pool.Get<NPCSensesState>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nPCSensesState, isDelta: false);
		return nPCSensesState;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NPCSensesState previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NPCSensesState Deserialize(BufferStream stream, NPCSensesState instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NPCSensesState DeserializeLengthDelimited(BufferStream stream, NPCSensesState instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NPCSensesState DeserializeLength(BufferStream stream, int length, NPCSensesState instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NPCSensesState instance, NPCSensesState previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetEntityId.Value);
	}

	public static void Serialize(BufferStream stream, NPCSensesState instance)
	{
		if (instance.targetEntityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetEntityId.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetEntityId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PartyData : IDisposable, IPooled, IProto<PartyData>, IProto
{
	[NonSerialized]
	public ulong lobbyId;

	[NonSerialized]
	public List<PartyMemberData> members;

	[NonSerialized]
	public string joinKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PartyData instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.lobbyId = 0uL;
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				if (instance.members[i] != null)
				{
					instance.members[i].ResetToPool();
					instance.members[i] = null;
				}
			}
			List<PartyMemberData> list = instance.members;
			Pool.Free<PartyMemberData>(ref list, false);
			instance.members = list;
		}
		instance.joinKey = string.Empty;
		Pool.Free<PartyData>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PartyData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PartyData instance)
	{
		instance.lobbyId = lobbyId;
		if (members != null)
		{
			instance.members = Pool.Get<List<PartyMemberData>>();
			for (int i = 0; i < members.Count; i++)
			{
				PartyMemberData item = members[i].Copy();
				instance.members.Add(item);
			}
		}
		else
		{
			instance.members = null;
		}
		instance.joinKey = joinKey;
	}

	public PartyData Copy()
	{
		PartyData partyData = Pool.Get<PartyData>();
		CopyTo(partyData);
		return partyData;
	}

	public static PartyData Deserialize(BufferStream stream)
	{
		PartyData partyData = Pool.Get<PartyData>();
		Deserialize(stream, partyData, isDelta: false);
		return partyData;
	}

	public static PartyData DeserializeLengthDelimited(BufferStream stream)
	{
		PartyData partyData = Pool.Get<PartyData>();
		DeserializeLengthDelimited(stream, partyData, isDelta: false);
		return partyData;
	}

	public static PartyData DeserializeLength(BufferStream stream, int length)
	{
		PartyData partyData = Pool.Get<PartyData>();
		DeserializeLength(stream, length, partyData, isDelta: false);
		return partyData;
	}

	public static PartyData Deserialize(byte[] buffer)
	{
		PartyData partyData = Pool.Get<PartyData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, partyData, isDelta: false);
		return partyData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PartyData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PartyData Deserialize(BufferStream stream, PartyData instance, bool isDelta)
	{
		if (!isDelta && instance.members == null)
		{
			instance.members = Pool.Get<List<PartyMemberData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lobbyId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(PartyMemberData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PartyData DeserializeLengthDelimited(BufferStream stream, PartyData instance, bool isDelta)
	{
		if (!isDelta && instance.members == null)
		{
			instance.members = Pool.Get<List<PartyMemberData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lobbyId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(PartyMemberData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PartyData DeserializeLength(BufferStream stream, int length, PartyData instance, bool isDelta)
	{
		if (!isDelta && instance.members == null)
		{
			instance.members = Pool.Get<List<PartyMemberData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lobbyId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(PartyMemberData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PartyData instance, PartyData previous)
	{
		if (instance.lobbyId != previous.lobbyId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lobbyId);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				PartyMemberData partyMemberData = instance.members[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PartyMemberData.SerializeDelta(stream, partyMemberData, partyMemberData);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.joinKey != previous.joinKey)
		{
			if (instance.joinKey == null)
			{
				throw new ArgumentNullException("joinKey", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.joinKey);
		}
	}

	public static void Serialize(BufferStream stream, PartyData instance)
	{
		if (instance.lobbyId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lobbyId);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				PartyMemberData instance2 = instance.members[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PartyMemberData.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.joinKey == null)
		{
			throw new ArgumentNullException("joinKey", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.joinKey);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (members != null)
		{
			for (int i = 0; i < members.Count; i++)
			{
				members[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PartyMemberData : IDisposable, IPooled, IProto<PartyMemberData>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public bool isLeader;

	[NonSerialized]
	public string name;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PartyMemberData instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.isLeader = false;
			instance.name = string.Empty;
			Pool.Free<PartyMemberData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PartyMemberData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PartyMemberData instance)
	{
		instance.steamId = steamId;
		instance.isLeader = isLeader;
		instance.name = name;
	}

	public PartyMemberData Copy()
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		CopyTo(partyMemberData);
		return partyMemberData;
	}

	public static PartyMemberData Deserialize(BufferStream stream)
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		Deserialize(stream, partyMemberData, isDelta: false);
		return partyMemberData;
	}

	public static PartyMemberData DeserializeLengthDelimited(BufferStream stream)
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		DeserializeLengthDelimited(stream, partyMemberData, isDelta: false);
		return partyMemberData;
	}

	public static PartyMemberData DeserializeLength(BufferStream stream, int length)
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		DeserializeLength(stream, length, partyMemberData, isDelta: false);
		return partyMemberData;
	}

	public static PartyMemberData Deserialize(byte[] buffer)
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, partyMemberData, isDelta: false);
		return partyMemberData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PartyMemberData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PartyMemberData Deserialize(BufferStream stream, PartyMemberData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isLeader = ProtocolParser.ReadBool(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PartyMemberData DeserializeLengthDelimited(BufferStream stream, PartyMemberData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isLeader = ProtocolParser.ReadBool(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PartyMemberData DeserializeLength(BufferStream stream, int length, PartyMemberData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isLeader = ProtocolParser.ReadBool(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PartyMemberData instance, PartyMemberData previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.isLeader);
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public static void Serialize(BufferStream stream, PartyMemberData instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.isLeader)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.isLeader);
		}
		if (instance.name != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BasePlayer : IDisposable, IPooled, IProto<BasePlayer>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public ulong userid;

	[NonSerialized]
	public PlayerInventory inventory;

	[NonSerialized]
	public PlayerMetabolism metabolism;

	[NonSerialized]
	public float loadingTimeout;

	[NonSerialized]
	public ModelState modelState;

	[NonSerialized]
	public int playerFlags;

	[NonSerialized]
	public ItemId heldEntity;

	[NonSerialized]
	public float health;

	[NonSerialized]
	public PersistantPlayer persistantData;

	[NonSerialized]
	public float skinCol;

	[NonSerialized]
	public float skinTex;

	[NonSerialized]
	public float skinMesh;

	[NonSerialized]
	public PlayerLifeStory currentLife;

	[NonSerialized]
	public PlayerLifeStory previousLife;

	[NonSerialized]
	public NetworkableId mounted;

	[NonSerialized]
	public ulong currentTeam;

	[NonSerialized]
	public uint underwear;

	[NonSerialized]
	public PlayerModifiers modifiers;

	[NonSerialized]
	public int reputation;

	[NonSerialized]
	public uint loopingGesture;

	[NonSerialized]
	public Missions missions;

	[NonSerialized]
	public string respawnId;

	[NonSerialized]
	public int bagCount;

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public ItemCrafter itemCrafter;

	[NonSerialized]
	public int shelterCount;

	[NonSerialized]
	public int tutorialAllowance;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BasePlayer instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.userid = 0uL;
			if (instance.inventory != null)
			{
				instance.inventory.ResetToPool();
				instance.inventory = null;
			}
			if (instance.metabolism != null)
			{
				instance.metabolism.ResetToPool();
				instance.metabolism = null;
			}
			instance.loadingTimeout = 0f;
			if (instance.modelState != null)
			{
				instance.modelState.ResetToPool();
				instance.modelState = null;
			}
			instance.playerFlags = 0;
			instance.heldEntity = default(ItemId);
			instance.health = 0f;
			if (instance.persistantData != null)
			{
				instance.persistantData.ResetToPool();
				instance.persistantData = null;
			}
			instance.skinCol = 0f;
			instance.skinTex = 0f;
			instance.skinMesh = 0f;
			if (instance.currentLife != null)
			{
				instance.currentLife.ResetToPool();
				instance.currentLife = null;
			}
			if (instance.previousLife != null)
			{
				instance.previousLife.ResetToPool();
				instance.previousLife = null;
			}
			instance.mounted = default(NetworkableId);
			instance.currentTeam = 0uL;
			instance.underwear = 0u;
			if (instance.modifiers != null)
			{
				instance.modifiers.ResetToPool();
				instance.modifiers = null;
			}
			instance.reputation = 0;
			instance.loopingGesture = 0u;
			if (instance.missions != null)
			{
				instance.missions.ResetToPool();
				instance.missions = null;
			}
			instance.respawnId = string.Empty;
			instance.bagCount = 0;
			instance.clanId = 0L;
			if (instance.itemCrafter != null)
			{
				instance.itemCrafter.ResetToPool();
				instance.itemCrafter = null;
			}
			instance.shelterCount = 0;
			instance.tutorialAllowance = 0;
			Pool.Free<BasePlayer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BasePlayer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BasePlayer instance)
	{
		instance.name = name;
		instance.userid = userid;
		if (inventory != null)
		{
			if (instance.inventory == null)
			{
				instance.inventory = inventory.Copy();
			}
			else
			{
				inventory.CopyTo(instance.inventory);
			}
		}
		else
		{
			instance.inventory = null;
		}
		if (metabolism != null)
		{
			if (instance.metabolism == null)
			{
				instance.metabolism = metabolism.Copy();
			}
			else
			{
				metabolism.CopyTo(instance.metabolism);
			}
		}
		else
		{
			instance.metabolism = null;
		}
		instance.loadingTimeout = loadingTimeout;
		if (modelState != null)
		{
			if (instance.modelState == null)
			{
				instance.modelState = modelState.Copy();
			}
			else
			{
				modelState.CopyTo(instance.modelState);
			}
		}
		else
		{
			instance.modelState = null;
		}
		instance.playerFlags = playerFlags;
		instance.heldEntity = heldEntity;
		instance.health = health;
		if (persistantData != null)
		{
			if (instance.persistantData == null)
			{
				instance.persistantData = persistantData.Copy();
			}
			else
			{
				persistantData.CopyTo(instance.persistantData);
			}
		}
		else
		{
			instance.persistantData = null;
		}
		instance.skinCol = skinCol;
		instance.skinTex = skinTex;
		instance.skinMesh = skinMesh;
		if (currentLife != null)
		{
			if (instance.currentLife == null)
			{
				instance.currentLife = currentLife.Copy();
			}
			else
			{
				currentLife.CopyTo(instance.currentLife);
			}
		}
		else
		{
			instance.currentLife = null;
		}
		if (previousLife != null)
		{
			if (instance.previousLife == null)
			{
				instance.previousLife = previousLife.Copy();
			}
			else
			{
				previousLife.CopyTo(instance.previousLife);
			}
		}
		else
		{
			instance.previousLife = null;
		}
		instance.mounted = mounted;
		instance.currentTeam = currentTeam;
		instance.underwear = underwear;
		if (modifiers != null)
		{
			if (instance.modifiers == null)
			{
				instance.modifiers = modifiers.Copy();
			}
			else
			{
				modifiers.CopyTo(instance.modifiers);
			}
		}
		else
		{
			instance.modifiers = null;
		}
		instance.reputation = reputation;
		instance.loopingGesture = loopingGesture;
		if (missions != null)
		{
			if (instance.missions == null)
			{
				instance.missions = missions.Copy();
			}
			else
			{
				missions.CopyTo(instance.missions);
			}
		}
		else
		{
			instance.missions = null;
		}
		instance.respawnId = respawnId;
		instance.bagCount = bagCount;
		instance.clanId = clanId;
		if (itemCrafter != null)
		{
			if (instance.itemCrafter == null)
			{
				instance.itemCrafter = itemCrafter.Copy();
			}
			else
			{
				itemCrafter.CopyTo(instance.itemCrafter);
			}
		}
		else
		{
			instance.itemCrafter = null;
		}
		instance.shelterCount = shelterCount;
		instance.tutorialAllowance = tutorialAllowance;
	}

	public BasePlayer Copy()
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		CopyTo(basePlayer);
		return basePlayer;
	}

	public static BasePlayer Deserialize(BufferStream stream)
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		Deserialize(stream, basePlayer, isDelta: false);
		return basePlayer;
	}

	public static BasePlayer DeserializeLengthDelimited(BufferStream stream)
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		DeserializeLengthDelimited(stream, basePlayer, isDelta: false);
		return basePlayer;
	}

	public static BasePlayer DeserializeLength(BufferStream stream, int length)
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		DeserializeLength(stream, length, basePlayer, isDelta: false);
		return basePlayer;
	}

	public static BasePlayer Deserialize(byte[] buffer)
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, basePlayer, isDelta: false);
		return basePlayer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BasePlayer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BasePlayer Deserialize(BufferStream stream, BasePlayer instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (instance.inventory == null)
				{
					instance.inventory = PlayerInventory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerInventory.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				continue;
			case 34:
				if (instance.metabolism == null)
				{
					instance.metabolism = PlayerMetabolism.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerMetabolism.DeserializeLengthDelimited(stream, instance.metabolism, isDelta);
				}
				continue;
			case 45:
				instance.loadingTimeout = ProtocolParser.ReadSingle(stream);
				continue;
			case 50:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				continue;
			case 56:
				instance.playerFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.heldEntity = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				if (instance.persistantData == null)
				{
					instance.persistantData = PersistantPlayer.DeserializeLengthDelimited(stream);
				}
				else
				{
					PersistantPlayer.DeserializeLengthDelimited(stream, instance.persistantData, isDelta);
				}
				continue;
			case 125:
				instance.skinCol = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinTex = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinMesh = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.currentLife == null)
					{
						instance.currentLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.currentLife, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.previousLife == null)
					{
						instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.Varint)
				{
					instance.mounted = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				}
				break;
			case 23u:
				if (key.WireType == Wire.Varint)
				{
					instance.currentTeam = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 24u:
				if (key.WireType == Wire.Varint)
				{
					instance.underwear = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.modifiers == null)
					{
						instance.modifiers = PlayerModifiers.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
					}
				}
				break;
			case 26u:
				if (key.WireType == Wire.Varint)
				{
					instance.reputation = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 27u:
				if (key.WireType == Wire.Varint)
				{
					instance.loopingGesture = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 28u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.missions == null)
					{
						instance.missions = Missions.DeserializeLengthDelimited(stream);
					}
					else
					{
						Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
					}
				}
				break;
			case 29u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.respawnId = ProtocolParser.ReadString(stream);
				}
				break;
			case 30u:
				if (key.WireType == Wire.Varint)
				{
					instance.bagCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 31u:
				if (key.WireType == Wire.Varint)
				{
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.itemCrafter == null)
					{
						instance.itemCrafter = ItemCrafter.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemCrafter.DeserializeLengthDelimited(stream, instance.itemCrafter, isDelta);
					}
				}
				break;
			case 33u:
				if (key.WireType == Wire.Varint)
				{
					instance.shelterCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 34u:
				if (key.WireType == Wire.Varint)
				{
					instance.tutorialAllowance = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static BasePlayer DeserializeLengthDelimited(BufferStream stream, BasePlayer instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (instance.inventory == null)
				{
					instance.inventory = PlayerInventory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerInventory.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				continue;
			case 34:
				if (instance.metabolism == null)
				{
					instance.metabolism = PlayerMetabolism.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerMetabolism.DeserializeLengthDelimited(stream, instance.metabolism, isDelta);
				}
				continue;
			case 45:
				instance.loadingTimeout = ProtocolParser.ReadSingle(stream);
				continue;
			case 50:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				continue;
			case 56:
				instance.playerFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.heldEntity = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				if (instance.persistantData == null)
				{
					instance.persistantData = PersistantPlayer.DeserializeLengthDelimited(stream);
				}
				else
				{
					PersistantPlayer.DeserializeLengthDelimited(stream, instance.persistantData, isDelta);
				}
				continue;
			case 125:
				instance.skinCol = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinTex = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinMesh = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.currentLife == null)
					{
						instance.currentLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.currentLife, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.previousLife == null)
					{
						instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.Varint)
				{
					instance.mounted = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				}
				break;
			case 23u:
				if (key.WireType == Wire.Varint)
				{
					instance.currentTeam = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 24u:
				if (key.WireType == Wire.Varint)
				{
					instance.underwear = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.modifiers == null)
					{
						instance.modifiers = PlayerModifiers.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
					}
				}
				break;
			case 26u:
				if (key.WireType == Wire.Varint)
				{
					instance.reputation = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 27u:
				if (key.WireType == Wire.Varint)
				{
					instance.loopingGesture = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 28u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.missions == null)
					{
						instance.missions = Missions.DeserializeLengthDelimited(stream);
					}
					else
					{
						Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
					}
				}
				break;
			case 29u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.respawnId = ProtocolParser.ReadString(stream);
				}
				break;
			case 30u:
				if (key.WireType == Wire.Varint)
				{
					instance.bagCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 31u:
				if (key.WireType == Wire.Varint)
				{
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.itemCrafter == null)
					{
						instance.itemCrafter = ItemCrafter.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemCrafter.DeserializeLengthDelimited(stream, instance.itemCrafter, isDelta);
					}
				}
				break;
			case 33u:
				if (key.WireType == Wire.Varint)
				{
					instance.shelterCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 34u:
				if (key.WireType == Wire.Varint)
				{
					instance.tutorialAllowance = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BasePlayer DeserializeLength(BufferStream stream, int length, BasePlayer instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (instance.inventory == null)
				{
					instance.inventory = PlayerInventory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerInventory.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				continue;
			case 34:
				if (instance.metabolism == null)
				{
					instance.metabolism = PlayerMetabolism.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerMetabolism.DeserializeLengthDelimited(stream, instance.metabolism, isDelta);
				}
				continue;
			case 45:
				instance.loadingTimeout = ProtocolParser.ReadSingle(stream);
				continue;
			case 50:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				continue;
			case 56:
				instance.playerFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.heldEntity = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				if (instance.persistantData == null)
				{
					instance.persistantData = PersistantPlayer.DeserializeLengthDelimited(stream);
				}
				else
				{
					PersistantPlayer.DeserializeLengthDelimited(stream, instance.persistantData, isDelta);
				}
				continue;
			case 125:
				instance.skinCol = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinTex = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinMesh = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.currentLife == null)
					{
						instance.currentLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.currentLife, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.previousLife == null)
					{
						instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.Varint)
				{
					instance.mounted = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				}
				break;
			case 23u:
				if (key.WireType == Wire.Varint)
				{
					instance.currentTeam = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 24u:
				if (key.WireType == Wire.Varint)
				{
					instance.underwear = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.modifiers == null)
					{
						instance.modifiers = PlayerModifiers.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
					}
				}
				break;
			case 26u:
				if (key.WireType == Wire.Varint)
				{
					instance.reputation = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 27u:
				if (key.WireType == Wire.Varint)
				{
					instance.loopingGesture = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 28u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.missions == null)
					{
						instance.missions = Missions.DeserializeLengthDelimited(stream);
					}
					else
					{
						Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
					}
				}
				break;
			case 29u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.respawnId = ProtocolParser.ReadString(stream);
				}
				break;
			case 30u:
				if (key.WireType == Wire.Varint)
				{
					instance.bagCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 31u:
				if (key.WireType == Wire.Varint)
				{
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.itemCrafter == null)
					{
						instance.itemCrafter = ItemCrafter.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemCrafter.DeserializeLengthDelimited(stream, instance.itemCrafter, isDelta);
					}
				}
				break;
			case 33u:
				if (key.WireType == Wire.Varint)
				{
					instance.shelterCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 34u:
				if (key.WireType == Wire.Varint)
				{
					instance.tutorialAllowance = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BasePlayer instance, BasePlayer previous)
	{
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.userid != previous.userid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.inventory != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerInventory.SerializeDelta(stream, instance.inventory, previous.inventory);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.metabolism != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PlayerMetabolism.SerializeDelta(stream, instance.metabolism, previous.metabolism);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field metabolism (ProtoBuf.PlayerMetabolism)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.loadingTimeout != previous.loadingTimeout)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.loadingTimeout);
		}
		if (instance.modelState != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(2);
			int position3 = stream.Position;
			ModelState.SerializeDelta(stream, instance.modelState, previous.modelState);
			int num3 = stream.Position - position3;
			if (num3 > 16383)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modelState (global::ModelState)");
			}
			Span<byte> span3 = range3.GetSpan();
			if (ProtocolParser.WriteUInt32((uint)num3, span3, 0) < 2)
			{
				span3[0] |= 128;
				span3[1] = 0;
			}
		}
		if (instance.playerFlags != previous.playerFlags)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerFlags);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.heldEntity.Value);
		if (instance.health != previous.health)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.persistantData != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range4 = stream.GetRange(3);
			int position4 = stream.Position;
			PersistantPlayer.SerializeDelta(stream, instance.persistantData, previous.persistantData);
			int num4 = stream.Position - position4;
			if (num4 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field persistantData (ProtoBuf.PersistantPlayer)");
			}
			Span<byte> span4 = range4.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			if (num5 < 3)
			{
				span4[num5 - 1] |= 128;
				while (num5 < 2)
				{
					span4[num5++] = 128;
				}
				span4[2] = 0;
			}
		}
		if (instance.skinCol != previous.skinCol)
		{
			stream.WriteByte(125);
			ProtocolParser.WriteSingle(stream, instance.skinCol);
		}
		if (instance.skinTex != previous.skinTex)
		{
			stream.WriteByte(133);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.skinTex);
		}
		if (instance.skinMesh != previous.skinMesh)
		{
			stream.WriteByte(141);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.skinMesh);
		}
		if (instance.currentLife != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			PlayerLifeStory.SerializeDelta(stream, instance.currentLife, previous.currentLife);
			int val2 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val2, span5, 0);
			if (num6 < 5)
			{
				span5[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span5[num6++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.previousLife != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			PlayerLifeStory.SerializeDelta(stream, instance.previousLife, previous.previousLife);
			int val3 = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num7 = ProtocolParser.WriteUInt32((uint)val3, span6, 0);
			if (num7 < 5)
			{
				span6[num7 - 1] |= 128;
				while (num7 < 4)
				{
					span6[num7++] = 128;
				}
				span6[4] = 0;
			}
		}
		stream.WriteByte(176);
		stream.WriteByte(1);
		ProtocolParser.WriteUInt64(stream, instance.mounted.Value);
		if (instance.currentTeam != previous.currentTeam)
		{
			stream.WriteByte(184);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.currentTeam);
		}
		if (instance.underwear != previous.underwear)
		{
			stream.WriteByte(192);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.underwear);
		}
		if (instance.modifiers != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(1);
			BufferStream.RangeHandle range7 = stream.GetRange(3);
			int position7 = stream.Position;
			PlayerModifiers.SerializeDelta(stream, instance.modifiers, previous.modifiers);
			int num8 = stream.Position - position7;
			if (num8 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.PlayerModifiers)");
			}
			Span<byte> span7 = range7.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)num8, span7, 0);
			if (num9 < 3)
			{
				span7[num9 - 1] |= 128;
				while (num9 < 2)
				{
					span7[num9++] = 128;
				}
				span7[2] = 0;
			}
		}
		if (instance.reputation != previous.reputation)
		{
			stream.WriteByte(208);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.reputation);
		}
		if (instance.loopingGesture != previous.loopingGesture)
		{
			stream.WriteByte(216);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.loopingGesture);
		}
		if (instance.missions != null)
		{
			stream.WriteByte(226);
			stream.WriteByte(1);
			BufferStream.RangeHandle range8 = stream.GetRange(5);
			int position8 = stream.Position;
			Missions.SerializeDelta(stream, instance.missions, previous.missions);
			int val4 = stream.Position - position8;
			Span<byte> span8 = range8.GetSpan();
			int num10 = ProtocolParser.WriteUInt32((uint)val4, span8, 0);
			if (num10 < 5)
			{
				span8[num10 - 1] |= 128;
				while (num10 < 4)
				{
					span8[num10++] = 128;
				}
				span8[4] = 0;
			}
		}
		if (instance.respawnId != null && instance.respawnId != previous.respawnId)
		{
			stream.WriteByte(234);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.respawnId);
		}
		if (instance.bagCount != previous.bagCount)
		{
			stream.WriteByte(240);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bagCount);
		}
		stream.WriteByte(248);
		stream.WriteByte(1);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.itemCrafter != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(2);
			BufferStream.RangeHandle range9 = stream.GetRange(5);
			int position9 = stream.Position;
			ItemCrafter.SerializeDelta(stream, instance.itemCrafter, previous.itemCrafter);
			int val5 = stream.Position - position9;
			Span<byte> span9 = range9.GetSpan();
			int num11 = ProtocolParser.WriteUInt32((uint)val5, span9, 0);
			if (num11 < 5)
			{
				span9[num11 - 1] |= 128;
				while (num11 < 4)
				{
					span9[num11++] = 128;
				}
				span9[4] = 0;
			}
		}
		if (instance.shelterCount != previous.shelterCount)
		{
			stream.WriteByte(136);
			stream.WriteByte(2);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.shelterCount);
		}
		if (instance.tutorialAllowance != previous.tutorialAllowance)
		{
			stream.WriteByte(144);
			stream.WriteByte(2);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.tutorialAllowance);
		}
	}

	public static void Serialize(BufferStream stream, BasePlayer instance)
	{
		if (instance.name != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.userid != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.inventory != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerInventory.Serialize(stream, instance.inventory);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.metabolism != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PlayerMetabolism.Serialize(stream, instance.metabolism);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field metabolism (ProtoBuf.PlayerMetabolism)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.loadingTimeout != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.loadingTimeout);
		}
		if (instance.modelState != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(2);
			int position3 = stream.Position;
			ModelState.Serialize(stream, instance.modelState);
			int num3 = stream.Position - position3;
			if (num3 > 16383)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modelState (global::ModelState)");
			}
			Span<byte> span3 = range3.GetSpan();
			if (ProtocolParser.WriteUInt32((uint)num3, span3, 0) < 2)
			{
				span3[0] |= 128;
				span3[1] = 0;
			}
		}
		if (instance.playerFlags != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerFlags);
		}
		if (instance.heldEntity != default(ItemId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.heldEntity.Value);
		}
		if (instance.health != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.persistantData != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range4 = stream.GetRange(3);
			int position4 = stream.Position;
			PersistantPlayer.Serialize(stream, instance.persistantData);
			int num4 = stream.Position - position4;
			if (num4 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field persistantData (ProtoBuf.PersistantPlayer)");
			}
			Span<byte> span4 = range4.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			if (num5 < 3)
			{
				span4[num5 - 1] |= 128;
				while (num5 < 2)
				{
					span4[num5++] = 128;
				}
				span4[2] = 0;
			}
		}
		if (instance.skinCol != 0f)
		{
			stream.WriteByte(125);
			ProtocolParser.WriteSingle(stream, instance.skinCol);
		}
		if (instance.skinTex != 0f)
		{
			stream.WriteByte(133);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.skinTex);
		}
		if (instance.skinMesh != 0f)
		{
			stream.WriteByte(141);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.skinMesh);
		}
		if (instance.currentLife != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			PlayerLifeStory.Serialize(stream, instance.currentLife);
			int val2 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val2, span5, 0);
			if (num6 < 5)
			{
				span5[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span5[num6++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.previousLife != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			PlayerLifeStory.Serialize(stream, instance.previousLife);
			int val3 = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num7 = ProtocolParser.WriteUInt32((uint)val3, span6, 0);
			if (num7 < 5)
			{
				span6[num7 - 1] |= 128;
				while (num7 < 4)
				{
					span6[num7++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.mounted != default(NetworkableId))
		{
			stream.WriteByte(176);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.mounted.Value);
		}
		if (instance.currentTeam != 0L)
		{
			stream.WriteByte(184);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.currentTeam);
		}
		if (instance.underwear != 0)
		{
			stream.WriteByte(192);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.underwear);
		}
		if (instance.modifiers != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(1);
			BufferStream.RangeHandle range7 = stream.GetRange(3);
			int position7 = stream.Position;
			PlayerModifiers.Serialize(stream, instance.modifiers);
			int num8 = stream.Position - position7;
			if (num8 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.PlayerModifiers)");
			}
			Span<byte> span7 = range7.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)num8, span7, 0);
			if (num9 < 3)
			{
				span7[num9 - 1] |= 128;
				while (num9 < 2)
				{
					span7[num9++] = 128;
				}
				span7[2] = 0;
			}
		}
		if (instance.reputation != 0)
		{
			stream.WriteByte(208);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.reputation);
		}
		if (instance.loopingGesture != 0)
		{
			stream.WriteByte(216);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.loopingGesture);
		}
		if (instance.missions != null)
		{
			stream.WriteByte(226);
			stream.WriteByte(1);
			BufferStream.RangeHandle range8 = stream.GetRange(5);
			int position8 = stream.Position;
			Missions.Serialize(stream, instance.missions);
			int val4 = stream.Position - position8;
			Span<byte> span8 = range8.GetSpan();
			int num10 = ProtocolParser.WriteUInt32((uint)val4, span8, 0);
			if (num10 < 5)
			{
				span8[num10 - 1] |= 128;
				while (num10 < 4)
				{
					span8[num10++] = 128;
				}
				span8[4] = 0;
			}
		}
		if (instance.respawnId != null)
		{
			stream.WriteByte(234);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.respawnId);
		}
		if (instance.bagCount != 0)
		{
			stream.WriteByte(240);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bagCount);
		}
		if (instance.clanId != 0L)
		{
			stream.WriteByte(248);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.itemCrafter != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(2);
			BufferStream.RangeHandle range9 = stream.GetRange(5);
			int position9 = stream.Position;
			ItemCrafter.Serialize(stream, instance.itemCrafter);
			int val5 = stream.Position - position9;
			Span<byte> span9 = range9.GetSpan();
			int num11 = ProtocolParser.WriteUInt32((uint)val5, span9, 0);
			if (num11 < 5)
			{
				span9[num11 - 1] |= 128;
				while (num11 < 4)
				{
					span9[num11++] = 128;
				}
				span9[4] = 0;
			}
		}
		if (instance.shelterCount != 0)
		{
			stream.WriteByte(136);
			stream.WriteByte(2);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.shelterCount);
		}
		if (instance.tutorialAllowance != 0)
		{
			stream.WriteByte(144);
			stream.WriteByte(2);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.tutorialAllowance);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		inventory?.InspectUids(action);
		metabolism?.InspectUids(action);
		modelState?.InspectUids(action);
		action(UidType.ItemId, ref heldEntity.Value);
		persistantData?.InspectUids(action);
		currentLife?.InspectUids(action);
		previousLife?.InspectUids(action);
		action(UidType.NetworkableId, ref mounted.Value);
		modifiers?.InspectUids(action);
		missions?.InspectUids(action);
		itemCrafter?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerTeam : IDisposable, IPooled, IProto<PlayerTeam>, IProto
{
	public class TeamMember : IDisposable, IPooled, IProto<TeamMember>, IProto
	{
		[NonSerialized]
		public string displayName;

		[NonSerialized]
		public ulong userID;

		[NonSerialized]
		public float healthFraction;

		[NonSerialized]
		public Vector3 position;

		[NonSerialized]
		public bool online;

		[NonSerialized]
		public bool wounded;

		[NonSerialized]
		public ulong teamID;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(TeamMember instance)
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.displayName = string.Empty;
				instance.userID = 0uL;
				instance.healthFraction = 0f;
				instance.position = default(Vector3);
				instance.online = false;
				instance.wounded = false;
				instance.teamID = 0uL;
				Pool.Free<TeamMember>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose TeamMember with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(TeamMember instance)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			instance.displayName = displayName;
			instance.userID = userID;
			instance.healthFraction = healthFraction;
			instance.position = position;
			instance.online = online;
			instance.wounded = wounded;
			instance.teamID = teamID;
		}

		public TeamMember Copy()
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			CopyTo(teamMember);
			return teamMember;
		}

		public static TeamMember Deserialize(BufferStream stream)
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			Deserialize(stream, teamMember, isDelta: false);
			return teamMember;
		}

		public static TeamMember DeserializeLengthDelimited(BufferStream stream)
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			DeserializeLengthDelimited(stream, teamMember, isDelta: false);
			return teamMember;
		}

		public static TeamMember DeserializeLength(BufferStream stream, int length)
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			DeserializeLength(stream, length, teamMember, isDelta: false);
			return teamMember;
		}

		public static TeamMember Deserialize(byte[] buffer)
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, teamMember, isDelta: false);
			return teamMember;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, TeamMember previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static TeamMember Deserialize(BufferStream stream, TeamMember instance, bool isDelta)
		{
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.healthFraction = ProtocolParser.ReadSingle(stream);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 40:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.wounded = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.teamID = ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static TeamMember DeserializeLengthDelimited(BufferStream stream, TeamMember instance, bool isDelta)
		{
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.healthFraction = ProtocolParser.ReadSingle(stream);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 40:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.wounded = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.teamID = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static TeamMember DeserializeLength(BufferStream stream, int length, TeamMember instance, bool isDelta)
		{
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.healthFraction = ProtocolParser.ReadSingle(stream);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 40:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.wounded = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.teamID = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, TeamMember instance, TeamMember previous)
		{
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			if (instance.displayName != null && instance.displayName != previous.displayName)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.userID != previous.userID)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userID);
			}
			if (instance.healthFraction != previous.healthFraction)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.healthFraction);
			}
			if (instance.position != previous.position)
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.online);
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.wounded);
			if (instance.teamID != previous.teamID)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, instance.teamID);
			}
		}

		public static void Serialize(BufferStream stream, TeamMember instance)
		{
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			if (instance.displayName != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.userID != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userID);
			}
			if (instance.healthFraction != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.healthFraction);
			}
			if (instance.position != default(Vector3))
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.Serialize(stream, instance.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.online)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.online);
			}
			if (instance.wounded)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.wounded);
			}
			if (instance.teamID != 0L)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, instance.teamID);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public ulong teamID;

	[NonSerialized]
	public string teamName;

	[NonSerialized]
	public ulong teamLeader;

	[NonSerialized]
	public List<TeamMember> members;

	[NonSerialized]
	public float teamLifetime;

	[NonSerialized]
	public List<MapNote> leaderMapNotes;

	[NonSerialized]
	public List<MapNote> teamPings;

	[NonSerialized]
	public List<ulong> invites;

	[NonSerialized]
	public string joinKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerTeam instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.teamID = 0uL;
		instance.teamName = string.Empty;
		instance.teamLeader = 0uL;
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				if (instance.members[i] != null)
				{
					instance.members[i].ResetToPool();
					instance.members[i] = null;
				}
			}
			List<TeamMember> list = instance.members;
			Pool.Free<TeamMember>(ref list, false);
			instance.members = list;
		}
		instance.teamLifetime = 0f;
		if (instance.leaderMapNotes != null)
		{
			for (int j = 0; j < instance.leaderMapNotes.Count; j++)
			{
				if (instance.leaderMapNotes[j] != null)
				{
					instance.leaderMapNotes[j].ResetToPool();
					instance.leaderMapNotes[j] = null;
				}
			}
			List<MapNote> list2 = instance.leaderMapNotes;
			Pool.Free<MapNote>(ref list2, false);
			instance.leaderMapNotes = list2;
		}
		if (instance.teamPings != null)
		{
			for (int k = 0; k < instance.teamPings.Count; k++)
			{
				if (instance.teamPings[k] != null)
				{
					instance.teamPings[k].ResetToPool();
					instance.teamPings[k] = null;
				}
			}
			List<MapNote> list3 = instance.teamPings;
			Pool.Free<MapNote>(ref list3, false);
			instance.teamPings = list3;
		}
		if (instance.invites != null)
		{
			List<ulong> list4 = instance.invites;
			Pool.FreeUnmanaged<ulong>(ref list4);
			instance.invites = list4;
		}
		instance.joinKey = string.Empty;
		Pool.Free<PlayerTeam>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerTeam with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerTeam instance)
	{
		instance.teamID = teamID;
		instance.teamName = teamName;
		instance.teamLeader = teamLeader;
		if (members != null)
		{
			instance.members = Pool.Get<List<TeamMember>>();
			for (int i = 0; i < members.Count; i++)
			{
				TeamMember item = members[i].Copy();
				instance.members.Add(item);
			}
		}
		else
		{
			instance.members = null;
		}
		instance.teamLifetime = teamLifetime;
		if (leaderMapNotes != null)
		{
			instance.leaderMapNotes = Pool.Get<List<MapNote>>();
			for (int j = 0; j < leaderMapNotes.Count; j++)
			{
				MapNote item2 = leaderMapNotes[j].Copy();
				instance.leaderMapNotes.Add(item2);
			}
		}
		else
		{
			instance.leaderMapNotes = null;
		}
		if (teamPings != null)
		{
			instance.teamPings = Pool.Get<List<MapNote>>();
			for (int k = 0; k < teamPings.Count; k++)
			{
				MapNote item3 = teamPings[k].Copy();
				instance.teamPings.Add(item3);
			}
		}
		else
		{
			instance.teamPings = null;
		}
		if (invites != null)
		{
			instance.invites = Pool.Get<List<ulong>>();
			for (int l = 0; l < invites.Count; l++)
			{
				ulong item4 = invites[l];
				instance.invites.Add(item4);
			}
		}
		else
		{
			instance.invites = null;
		}
		instance.joinKey = joinKey;
	}

	public PlayerTeam Copy()
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		CopyTo(playerTeam);
		return playerTeam;
	}

	public static PlayerTeam Deserialize(BufferStream stream)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		Deserialize(stream, playerTeam, isDelta: false);
		return playerTeam;
	}

	public static PlayerTeam DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		DeserializeLengthDelimited(stream, playerTeam, isDelta: false);
		return playerTeam;
	}

	public static PlayerTeam DeserializeLength(BufferStream stream, int length)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		DeserializeLength(stream, length, playerTeam, isDelta: false);
		return playerTeam;
	}

	public static PlayerTeam Deserialize(byte[] buffer)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerTeam, isDelta: false);
		return playerTeam;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerTeam previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerTeam Deserialize(BufferStream stream, PlayerTeam instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<TeamMember>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<MapNote>>();
			}
			if (instance.teamPings == null)
			{
				instance.teamPings = Pool.Get<List<MapNote>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<ulong>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.teamLeader = ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.members.Add(TeamMember.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.teamLifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 58:
				instance.leaderMapNotes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 66:
				instance.teamPings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.invites.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 82:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerTeam DeserializeLengthDelimited(BufferStream stream, PlayerTeam instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<TeamMember>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<MapNote>>();
			}
			if (instance.teamPings == null)
			{
				instance.teamPings = Pool.Get<List<MapNote>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<ulong>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.teamLeader = ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.members.Add(TeamMember.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.teamLifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 58:
				instance.leaderMapNotes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 66:
				instance.teamPings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.invites.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 82:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerTeam DeserializeLength(BufferStream stream, int length, PlayerTeam instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<TeamMember>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<MapNote>>();
			}
			if (instance.teamPings == null)
			{
				instance.teamPings = Pool.Get<List<MapNote>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<ulong>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.teamLeader = ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.members.Add(TeamMember.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.teamLifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 58:
				instance.leaderMapNotes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 66:
				instance.teamPings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.invites.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 82:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerTeam instance, PlayerTeam previous)
	{
		if (instance.teamID != previous.teamID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.teamID);
		}
		if (instance.teamName != null && instance.teamName != previous.teamName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.teamName);
		}
		if (instance.teamLeader != previous.teamLeader)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.teamLeader);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				TeamMember teamMember = instance.members[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				TeamMember.SerializeDelta(stream, teamMember, teamMember);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.teamLifetime != previous.teamLifetime)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.teamLifetime);
		}
		if (instance.leaderMapNotes != null)
		{
			for (int j = 0; j < instance.leaderMapNotes.Count; j++)
			{
				MapNote mapNote = instance.leaderMapNotes[j];
				stream.WriteByte(58);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				MapNote.SerializeDelta(stream, mapNote, mapNote);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.teamPings != null)
		{
			for (int k = 0; k < instance.teamPings.Count; k++)
			{
				MapNote mapNote2 = instance.teamPings[k];
				stream.WriteByte(66);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				MapNote.SerializeDelta(stream, mapNote2, mapNote2);
				int val3 = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.invites != null)
		{
			for (int l = 0; l < instance.invites.Count; l++)
			{
				ulong val4 = instance.invites[l];
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, val4);
			}
		}
		if (instance.joinKey != null && instance.joinKey != previous.joinKey)
		{
			stream.WriteByte(82);
			ProtocolParser.WriteString(stream, instance.joinKey);
		}
	}

	public static void Serialize(BufferStream stream, PlayerTeam instance)
	{
		if (instance.teamID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.teamID);
		}
		if (instance.teamName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.teamName);
		}
		if (instance.teamLeader != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.teamLeader);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				TeamMember instance2 = instance.members[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				TeamMember.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.teamLifetime != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.teamLifetime);
		}
		if (instance.leaderMapNotes != null)
		{
			for (int j = 0; j < instance.leaderMapNotes.Count; j++)
			{
				MapNote instance3 = instance.leaderMapNotes[j];
				stream.WriteByte(58);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				MapNote.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.teamPings != null)
		{
			for (int k = 0; k < instance.teamPings.Count; k++)
			{
				MapNote instance4 = instance.teamPings[k];
				stream.WriteByte(66);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				MapNote.Serialize(stream, instance4);
				int val3 = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.invites != null)
		{
			for (int l = 0; l < instance.invites.Count; l++)
			{
				ulong val4 = instance.invites[l];
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, val4);
			}
		}
		if (instance.joinKey != null)
		{
			stream.WriteByte(82);
			ProtocolParser.WriteString(stream, instance.joinKey);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (members != null)
		{
			for (int i = 0; i < members.Count; i++)
			{
				members[i]?.InspectUids(action);
			}
		}
		if (leaderMapNotes != null)
		{
			for (int j = 0; j < leaderMapNotes.Count; j++)
			{
				leaderMapNotes[j]?.InspectUids(action);
			}
		}
		if (teamPings != null)
		{
			for (int k = 0; k < teamPings.Count; k++)
			{
				teamPings[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerMetabolism : IDisposable, IPooled, IProto<PlayerMetabolism>, IProto
{
	[NonSerialized]
	public float health;

	[NonSerialized]
	public float calories;

	[NonSerialized]
	public float hydration;

	[NonSerialized]
	public float heartrate;

	[NonSerialized]
	public float temperature;

	[NonSerialized]
	public float poison;

	[NonSerialized]
	public float radiation_level;

	[NonSerialized]
	public float wetness;

	[NonSerialized]
	public float dirtyness;

	[NonSerialized]
	public float oxygen;

	[NonSerialized]
	public float bleeding;

	[NonSerialized]
	public float radiation_poisoning;

	[NonSerialized]
	public float comfort;

	[NonSerialized]
	public float pending_health;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerMetabolism instance)
	{
		if (instance.ShouldPool)
		{
			instance.health = 0f;
			instance.calories = 0f;
			instance.hydration = 0f;
			instance.heartrate = 0f;
			instance.temperature = 0f;
			instance.poison = 0f;
			instance.radiation_level = 0f;
			instance.wetness = 0f;
			instance.dirtyness = 0f;
			instance.oxygen = 0f;
			instance.bleeding = 0f;
			instance.radiation_poisoning = 0f;
			instance.comfort = 0f;
			instance.pending_health = 0f;
			Pool.Free<PlayerMetabolism>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerMetabolism with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerMetabolism instance)
	{
		instance.health = health;
		instance.calories = calories;
		instance.hydration = hydration;
		instance.heartrate = heartrate;
		instance.temperature = temperature;
		instance.poison = poison;
		instance.radiation_level = radiation_level;
		instance.wetness = wetness;
		instance.dirtyness = dirtyness;
		instance.oxygen = oxygen;
		instance.bleeding = bleeding;
		instance.radiation_poisoning = radiation_poisoning;
		instance.comfort = comfort;
		instance.pending_health = pending_health;
	}

	public PlayerMetabolism Copy()
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		CopyTo(playerMetabolism);
		return playerMetabolism;
	}

	public static PlayerMetabolism Deserialize(BufferStream stream)
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		Deserialize(stream, playerMetabolism, isDelta: false);
		return playerMetabolism;
	}

	public static PlayerMetabolism DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		DeserializeLengthDelimited(stream, playerMetabolism, isDelta: false);
		return playerMetabolism;
	}

	public static PlayerMetabolism DeserializeLength(BufferStream stream, int length)
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		DeserializeLength(stream, length, playerMetabolism, isDelta: false);
		return playerMetabolism;
	}

	public static PlayerMetabolism Deserialize(byte[] buffer)
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerMetabolism, isDelta: false);
		return playerMetabolism;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerMetabolism previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerMetabolism Deserialize(BufferStream stream, PlayerMetabolism instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.calories = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.hydration = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.heartrate = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.poison = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radiation_level = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.wetness = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.dirtyness = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.bleeding = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.radiation_poisoning = ProtocolParser.ReadSingle(stream);
				continue;
			case 109:
				instance.comfort = ProtocolParser.ReadSingle(stream);
				continue;
			case 117:
				instance.pending_health = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerMetabolism DeserializeLengthDelimited(BufferStream stream, PlayerMetabolism instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.calories = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.hydration = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.heartrate = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.poison = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radiation_level = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.wetness = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.dirtyness = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.bleeding = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.radiation_poisoning = ProtocolParser.ReadSingle(stream);
				continue;
			case 109:
				instance.comfort = ProtocolParser.ReadSingle(stream);
				continue;
			case 117:
				instance.pending_health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerMetabolism DeserializeLength(BufferStream stream, int length, PlayerMetabolism instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.calories = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.hydration = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.heartrate = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.poison = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radiation_level = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.wetness = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.dirtyness = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.bleeding = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.radiation_poisoning = ProtocolParser.ReadSingle(stream);
				continue;
			case 109:
				instance.comfort = ProtocolParser.ReadSingle(stream);
				continue;
			case 117:
				instance.pending_health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerMetabolism instance, PlayerMetabolism previous)
	{
		if (instance.health != previous.health)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.calories != previous.calories)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.calories);
		}
		if (instance.hydration != previous.hydration)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.hydration);
		}
		if (instance.heartrate != previous.heartrate)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.heartrate);
		}
		if (instance.temperature != previous.temperature)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.poison != previous.poison)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.poison);
		}
		if (instance.radiation_level != previous.radiation_level)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.radiation_level);
		}
		if (instance.wetness != previous.wetness)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.wetness);
		}
		if (instance.dirtyness != previous.dirtyness)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.dirtyness);
		}
		if (instance.oxygen != previous.oxygen)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.oxygen);
		}
		if (instance.bleeding != previous.bleeding)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.bleeding);
		}
		if (instance.radiation_poisoning != previous.radiation_poisoning)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.radiation_poisoning);
		}
		if (instance.comfort != previous.comfort)
		{
			stream.WriteByte(109);
			ProtocolParser.WriteSingle(stream, instance.comfort);
		}
		if (instance.pending_health != previous.pending_health)
		{
			stream.WriteByte(117);
			ProtocolParser.WriteSingle(stream, instance.pending_health);
		}
	}

	public static void Serialize(BufferStream stream, PlayerMetabolism instance)
	{
		if (instance.health != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.calories != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.calories);
		}
		if (instance.hydration != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.hydration);
		}
		if (instance.heartrate != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.heartrate);
		}
		if (instance.temperature != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.poison != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.poison);
		}
		if (instance.radiation_level != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.radiation_level);
		}
		if (instance.wetness != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.wetness);
		}
		if (instance.dirtyness != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.dirtyness);
		}
		if (instance.oxygen != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.oxygen);
		}
		if (instance.bleeding != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.bleeding);
		}
		if (instance.radiation_poisoning != 0f)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.radiation_poisoning);
		}
		if (instance.comfort != 0f)
		{
			stream.WriteByte(109);
			ProtocolParser.WriteSingle(stream, instance.comfort);
		}
		if (instance.pending_health != 0f)
		{
			stream.WriteByte(117);
			ProtocolParser.WriteSingle(stream, instance.pending_health);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerModifiers : IDisposable, IPooled, IProto<PlayerModifiers>, IProto
{
	[NonSerialized]
	public List<Modifier> modifiers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerModifiers instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.modifiers != null)
		{
			for (int i = 0; i < instance.modifiers.Count; i++)
			{
				if (instance.modifiers[i] != null)
				{
					instance.modifiers[i].ResetToPool();
					instance.modifiers[i] = null;
				}
			}
			List<Modifier> list = instance.modifiers;
			Pool.Free<Modifier>(ref list, false);
			instance.modifiers = list;
		}
		Pool.Free<PlayerModifiers>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerModifiers with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerModifiers instance)
	{
		if (modifiers != null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
			for (int i = 0; i < modifiers.Count; i++)
			{
				Modifier item = modifiers[i].Copy();
				instance.modifiers.Add(item);
			}
		}
		else
		{
			instance.modifiers = null;
		}
	}

	public PlayerModifiers Copy()
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		CopyTo(playerModifiers);
		return playerModifiers;
	}

	public static PlayerModifiers Deserialize(BufferStream stream)
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		Deserialize(stream, playerModifiers, isDelta: false);
		return playerModifiers;
	}

	public static PlayerModifiers DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		DeserializeLengthDelimited(stream, playerModifiers, isDelta: false);
		return playerModifiers;
	}

	public static PlayerModifiers DeserializeLength(BufferStream stream, int length)
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		DeserializeLength(stream, length, playerModifiers, isDelta: false);
		return playerModifiers;
	}

	public static PlayerModifiers Deserialize(byte[] buffer)
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerModifiers, isDelta: false);
		return playerModifiers;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerModifiers previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerModifiers Deserialize(BufferStream stream, PlayerModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerModifiers DeserializeLengthDelimited(BufferStream stream, PlayerModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerModifiers DeserializeLength(BufferStream stream, int length, PlayerModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerModifiers instance, PlayerModifiers previous)
	{
		if (instance.modifiers == null)
		{
			return;
		}
		for (int i = 0; i < instance.modifiers.Count; i++)
		{
			Modifier modifier = instance.modifiers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Modifier.SerializeDelta(stream, modifier, modifier);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.Modifier)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, PlayerModifiers instance)
	{
		if (instance.modifiers == null)
		{
			return;
		}
		for (int i = 0; i < instance.modifiers.Count; i++)
		{
			Modifier instance2 = instance.modifiers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Modifier.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.Modifier)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (modifiers != null)
		{
			for (int i = 0; i < modifiers.Count; i++)
			{
				modifiers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Modifier : IDisposable, IPooled, IProto<Modifier>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public int source;

	[NonSerialized]
	public float value;

	[NonSerialized]
	public double timeRemaining;

	[NonSerialized]
	public float duration;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Modifier instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.source = 0;
			instance.value = 0f;
			instance.timeRemaining = 0.0;
			instance.duration = 0f;
			Pool.Free<Modifier>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Modifier with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Modifier instance)
	{
		instance.type = type;
		instance.source = source;
		instance.value = value;
		instance.timeRemaining = timeRemaining;
		instance.duration = duration;
	}

	public Modifier Copy()
	{
		Modifier modifier = Pool.Get<Modifier>();
		CopyTo(modifier);
		return modifier;
	}

	public static Modifier Deserialize(BufferStream stream)
	{
		Modifier modifier = Pool.Get<Modifier>();
		Deserialize(stream, modifier, isDelta: false);
		return modifier;
	}

	public static Modifier DeserializeLengthDelimited(BufferStream stream)
	{
		Modifier modifier = Pool.Get<Modifier>();
		DeserializeLengthDelimited(stream, modifier, isDelta: false);
		return modifier;
	}

	public static Modifier DeserializeLength(BufferStream stream, int length)
	{
		Modifier modifier = Pool.Get<Modifier>();
		DeserializeLength(stream, length, modifier, isDelta: false);
		return modifier;
	}

	public static Modifier Deserialize(byte[] buffer)
	{
		Modifier modifier = Pool.Get<Modifier>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, modifier, isDelta: false);
		return modifier;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Modifier previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Modifier Deserialize(BufferStream stream, Modifier instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.source = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case 33:
				instance.timeRemaining = ProtocolParser.ReadDouble(stream);
				continue;
			case 45:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Modifier DeserializeLengthDelimited(BufferStream stream, Modifier instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.source = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case 33:
				instance.timeRemaining = ProtocolParser.ReadDouble(stream);
				continue;
			case 45:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Modifier DeserializeLength(BufferStream stream, int length, Modifier instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.source = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case 33:
				instance.timeRemaining = ProtocolParser.ReadDouble(stream);
				continue;
			case 45:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Modifier instance, Modifier previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.source != previous.source)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.source);
		}
		if (instance.value != previous.value)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
		if (instance.timeRemaining != previous.timeRemaining)
		{
			stream.WriteByte(33);
			ProtocolParser.WriteDouble(stream, instance.timeRemaining);
		}
		if (instance.duration != previous.duration)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
	}

	public static void Serialize(BufferStream stream, Modifier instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.source != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.source);
		}
		if (instance.value != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
		if (instance.timeRemaining != 0.0)
		{
			stream.WriteByte(33);
			ProtocolParser.WriteDouble(stream, instance.timeRemaining);
		}
		if (instance.duration != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Missions : IDisposable, IPooled, IProto<Missions>, IProto
{
	[NonSerialized]
	public List<MissionInstance> missions;

	[NonSerialized]
	public int activeMission;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Missions instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.missions != null)
		{
			for (int i = 0; i < instance.missions.Count; i++)
			{
				if (instance.missions[i] != null)
				{
					instance.missions[i].ResetToPool();
					instance.missions[i] = null;
				}
			}
			List<MissionInstance> list = instance.missions;
			Pool.Free<MissionInstance>(ref list, false);
			instance.missions = list;
		}
		instance.activeMission = 0;
		Pool.Free<Missions>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Missions with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Missions instance)
	{
		if (missions != null)
		{
			instance.missions = Pool.Get<List<MissionInstance>>();
			for (int i = 0; i < missions.Count; i++)
			{
				MissionInstance item = missions[i].Copy();
				instance.missions.Add(item);
			}
		}
		else
		{
			instance.missions = null;
		}
		instance.activeMission = activeMission;
	}

	public Missions Copy()
	{
		Missions missions = Pool.Get<Missions>();
		CopyTo(missions);
		return missions;
	}

	public static Missions Deserialize(BufferStream stream)
	{
		Missions missions = Pool.Get<Missions>();
		Deserialize(stream, missions, isDelta: false);
		return missions;
	}

	public static Missions DeserializeLengthDelimited(BufferStream stream)
	{
		Missions missions = Pool.Get<Missions>();
		DeserializeLengthDelimited(stream, missions, isDelta: false);
		return missions;
	}

	public static Missions DeserializeLength(BufferStream stream, int length)
	{
		Missions missions = Pool.Get<Missions>();
		DeserializeLength(stream, length, missions, isDelta: false);
		return missions;
	}

	public static Missions Deserialize(byte[] buffer)
	{
		Missions missions = Pool.Get<Missions>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missions, isDelta: false);
		return missions;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Missions previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Missions Deserialize(BufferStream stream, Missions instance, bool isDelta)
	{
		if (!isDelta && instance.missions == null)
		{
			instance.missions = Pool.Get<List<MissionInstance>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.missions.Add(MissionInstance.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.activeMission = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Missions DeserializeLengthDelimited(BufferStream stream, Missions instance, bool isDelta)
	{
		if (!isDelta && instance.missions == null)
		{
			instance.missions = Pool.Get<List<MissionInstance>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.missions.Add(MissionInstance.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.activeMission = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Missions DeserializeLength(BufferStream stream, int length, Missions instance, bool isDelta)
	{
		if (!isDelta && instance.missions == null)
		{
			instance.missions = Pool.Get<List<MissionInstance>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.missions.Add(MissionInstance.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.activeMission = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Missions instance, Missions previous)
	{
		if (instance.missions != null)
		{
			for (int i = 0; i < instance.missions.Count; i++)
			{
				MissionInstance missionInstance = instance.missions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MissionInstance.SerializeDelta(stream, missionInstance, missionInstance);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.activeMission != previous.activeMission)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.activeMission);
		}
	}

	public static void Serialize(BufferStream stream, Missions instance)
	{
		if (instance.missions != null)
		{
			for (int i = 0; i < instance.missions.Count; i++)
			{
				MissionInstance instance2 = instance.missions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MissionInstance.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.activeMission != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.activeMission);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (missions != null)
		{
			for (int i = 0; i < missions.Count; i++)
			{
				missions[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ObjectiveStatus : IDisposable, IPooled, IProto<ObjectiveStatus>, IProto
{
	[NonSerialized]
	public bool started;

	[NonSerialized]
	public bool completed;

	[NonSerialized]
	public bool failed;

	[NonSerialized]
	public float progressCurrent;

	[NonSerialized]
	public float progressTarget;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ObjectiveStatus instance)
	{
		if (instance.ShouldPool)
		{
			instance.started = false;
			instance.completed = false;
			instance.failed = false;
			instance.progressCurrent = 0f;
			instance.progressTarget = 0f;
			Pool.Free<ObjectiveStatus>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ObjectiveStatus with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ObjectiveStatus instance)
	{
		instance.started = started;
		instance.completed = completed;
		instance.failed = failed;
		instance.progressCurrent = progressCurrent;
		instance.progressTarget = progressTarget;
	}

	public ObjectiveStatus Copy()
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		CopyTo(objectiveStatus);
		return objectiveStatus;
	}

	public static ObjectiveStatus Deserialize(BufferStream stream)
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		Deserialize(stream, objectiveStatus, isDelta: false);
		return objectiveStatus;
	}

	public static ObjectiveStatus DeserializeLengthDelimited(BufferStream stream)
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		DeserializeLengthDelimited(stream, objectiveStatus, isDelta: false);
		return objectiveStatus;
	}

	public static ObjectiveStatus DeserializeLength(BufferStream stream, int length)
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		DeserializeLength(stream, length, objectiveStatus, isDelta: false);
		return objectiveStatus;
	}

	public static ObjectiveStatus Deserialize(byte[] buffer)
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, objectiveStatus, isDelta: false);
		return objectiveStatus;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ObjectiveStatus previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ObjectiveStatus Deserialize(BufferStream stream, ObjectiveStatus instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.started = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.completed = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.failed = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.progressCurrent = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.progressTarget = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ObjectiveStatus DeserializeLengthDelimited(BufferStream stream, ObjectiveStatus instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.started = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.completed = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.failed = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.progressCurrent = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.progressTarget = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ObjectiveStatus DeserializeLength(BufferStream stream, int length, ObjectiveStatus instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.started = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.completed = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.failed = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.progressCurrent = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.progressTarget = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ObjectiveStatus instance, ObjectiveStatus previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.started);
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.completed);
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.failed);
		if (instance.progressCurrent != previous.progressCurrent)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.progressCurrent);
		}
		if (instance.progressTarget != previous.progressTarget)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.progressTarget);
		}
	}

	public static void Serialize(BufferStream stream, ObjectiveStatus instance)
	{
		if (instance.started)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.started);
		}
		if (instance.completed)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.completed);
		}
		if (instance.failed)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.failed);
		}
		if (instance.progressCurrent != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.progressCurrent);
		}
		if (instance.progressTarget != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.progressTarget);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MissionPoint : IDisposable, IPooled, IProto<MissionPoint>, IProto
{
	[NonSerialized]
	public string identifier;

	[NonSerialized]
	public Vector3 location;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionPoint instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.identifier = string.Empty;
			instance.location = default(Vector3);
			Pool.Free<MissionPoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionPoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionPoint instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.identifier = identifier;
		instance.location = location;
	}

	public MissionPoint Copy()
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		CopyTo(missionPoint);
		return missionPoint;
	}

	public static MissionPoint Deserialize(BufferStream stream)
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		Deserialize(stream, missionPoint, isDelta: false);
		return missionPoint;
	}

	public static MissionPoint DeserializeLengthDelimited(BufferStream stream)
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		DeserializeLengthDelimited(stream, missionPoint, isDelta: false);
		return missionPoint;
	}

	public static MissionPoint DeserializeLength(BufferStream stream, int length)
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		DeserializeLength(stream, length, missionPoint, isDelta: false);
		return missionPoint;
	}

	public static MissionPoint Deserialize(byte[] buffer)
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionPoint, isDelta: false);
		return missionPoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionPoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionPoint Deserialize(BufferStream stream, MissionPoint instance, bool isDelta)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionPoint DeserializeLengthDelimited(BufferStream stream, MissionPoint instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionPoint DeserializeLength(BufferStream stream, int length, MissionPoint instance, bool isDelta)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionPoint instance, MissionPoint previous)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		if (instance.identifier != previous.identifier)
		{
			if (instance.identifier == null)
			{
				throw new ArgumentNullException("identifier", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.identifier);
		}
		if (instance.location != previous.location)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.location, previous.location);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field location (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, MissionPoint instance)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.identifier == null)
		{
			throw new ArgumentNullException("identifier", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.identifier);
		if (instance.location != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.location);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field location (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionEntity : IDisposable, IPooled, IProto<MissionEntity>, IProto
{
	[NonSerialized]
	public string identifier;

	[NonSerialized]
	public NetworkableId entityID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.identifier = string.Empty;
			instance.entityID = default(NetworkableId);
			Pool.Free<MissionEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionEntity instance)
	{
		instance.identifier = identifier;
		instance.entityID = entityID;
	}

	public MissionEntity Copy()
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		CopyTo(missionEntity);
		return missionEntity;
	}

	public static MissionEntity Deserialize(BufferStream stream)
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		Deserialize(stream, missionEntity, isDelta: false);
		return missionEntity;
	}

	public static MissionEntity DeserializeLengthDelimited(BufferStream stream)
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		DeserializeLengthDelimited(stream, missionEntity, isDelta: false);
		return missionEntity;
	}

	public static MissionEntity DeserializeLength(BufferStream stream, int length)
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		DeserializeLength(stream, length, missionEntity, isDelta: false);
		return missionEntity;
	}

	public static MissionEntity Deserialize(byte[] buffer)
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionEntity, isDelta: false);
		return missionEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionEntity Deserialize(BufferStream stream, MissionEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionEntity DeserializeLengthDelimited(BufferStream stream, MissionEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionEntity DeserializeLength(BufferStream stream, int length, MissionEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionEntity instance, MissionEntity previous)
	{
		if (instance.identifier != previous.identifier)
		{
			if (instance.identifier == null)
			{
				throw new ArgumentNullException("identifier", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.identifier);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
	}

	public static void Serialize(BufferStream stream, MissionEntity instance)
	{
		if (instance.identifier == null)
		{
			throw new ArgumentNullException("identifier", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.identifier);
		if (instance.entityID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionReward : IDisposable, IPooled, IProto<MissionReward>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public int itemAmount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionReward instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.itemAmount = 0;
			Pool.Free<MissionReward>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionReward with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionReward instance)
	{
		instance.itemID = itemID;
		instance.itemAmount = itemAmount;
	}

	public MissionReward Copy()
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		CopyTo(missionReward);
		return missionReward;
	}

	public static MissionReward Deserialize(BufferStream stream)
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		Deserialize(stream, missionReward, isDelta: false);
		return missionReward;
	}

	public static MissionReward DeserializeLengthDelimited(BufferStream stream)
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		DeserializeLengthDelimited(stream, missionReward, isDelta: false);
		return missionReward;
	}

	public static MissionReward DeserializeLength(BufferStream stream, int length)
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		DeserializeLength(stream, length, missionReward, isDelta: false);
		return missionReward;
	}

	public static MissionReward Deserialize(byte[] buffer)
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionReward, isDelta: false);
		return missionReward;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionReward previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionReward Deserialize(BufferStream stream, MissionReward instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionReward DeserializeLengthDelimited(BufferStream stream, MissionReward instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionReward DeserializeLength(BufferStream stream, int length, MissionReward instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionReward instance, MissionReward previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.itemAmount != previous.itemAmount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemAmount);
		}
	}

	public static void Serialize(BufferStream stream, MissionReward instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.itemAmount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemAmount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionInstance : IDisposable, IPooled, IProto<MissionInstance>, IProto
{
	[NonSerialized]
	public uint missionID;

	[NonSerialized]
	public uint missionStatus;

	[NonSerialized]
	public MissionInstanceData instanceData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionInstance instance)
	{
		if (instance.ShouldPool)
		{
			instance.missionID = 0u;
			instance.missionStatus = 0u;
			if (instance.instanceData != null)
			{
				instance.instanceData.ResetToPool();
				instance.instanceData = null;
			}
			Pool.Free<MissionInstance>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionInstance with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionInstance instance)
	{
		instance.missionID = missionID;
		instance.missionStatus = missionStatus;
		if (instanceData != null)
		{
			if (instance.instanceData == null)
			{
				instance.instanceData = instanceData.Copy();
			}
			else
			{
				instanceData.CopyTo(instance.instanceData);
			}
		}
		else
		{
			instance.instanceData = null;
		}
	}

	public MissionInstance Copy()
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		CopyTo(missionInstance);
		return missionInstance;
	}

	public static MissionInstance Deserialize(BufferStream stream)
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		Deserialize(stream, missionInstance, isDelta: false);
		return missionInstance;
	}

	public static MissionInstance DeserializeLengthDelimited(BufferStream stream)
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		DeserializeLengthDelimited(stream, missionInstance, isDelta: false);
		return missionInstance;
	}

	public static MissionInstance DeserializeLength(BufferStream stream, int length)
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		DeserializeLength(stream, length, missionInstance, isDelta: false);
		return missionInstance;
	}

	public static MissionInstance Deserialize(byte[] buffer)
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionInstance, isDelta: false);
		return missionInstance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionInstance previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionInstance Deserialize(BufferStream stream, MissionInstance instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 16:
				instance.missionID = ProtocolParser.ReadUInt32(stream);
				break;
			case 24:
				instance.missionStatus = ProtocolParser.ReadUInt32(stream);
				break;
			case 98:
				if (instance.instanceData == null)
				{
					instance.instanceData = MissionInstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					MissionInstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static MissionInstance DeserializeLengthDelimited(BufferStream stream, MissionInstance instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.missionID = ProtocolParser.ReadUInt32(stream);
				break;
			case 24:
				instance.missionStatus = ProtocolParser.ReadUInt32(stream);
				break;
			case 98:
				if (instance.instanceData == null)
				{
					instance.instanceData = MissionInstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					MissionInstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionInstance DeserializeLength(BufferStream stream, int length, MissionInstance instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.missionID = ProtocolParser.ReadUInt32(stream);
				break;
			case 24:
				instance.missionStatus = ProtocolParser.ReadUInt32(stream);
				break;
			case 98:
				if (instance.instanceData == null)
				{
					instance.instanceData = MissionInstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					MissionInstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionInstance instance, MissionInstance previous)
	{
		if (instance.missionID != previous.missionID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.missionID);
		}
		if (instance.missionStatus != previous.missionStatus)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.missionStatus);
		}
		if (instance.instanceData == null)
		{
			return;
		}
		stream.WriteByte(98);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		MissionInstanceData.SerializeDelta(stream, instance.instanceData, previous.instanceData);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, MissionInstance instance)
	{
		if (instance.missionID != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.missionID);
		}
		if (instance.missionStatus != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.missionStatus);
		}
		if (instance.instanceData == null)
		{
			return;
		}
		stream.WriteByte(98);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		MissionInstanceData.Serialize(stream, instance.instanceData);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		instanceData?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MissionInstanceData : IDisposable, IPooled, IProto<MissionInstanceData>, IProto
{
	[NonSerialized]
	public NetworkableId providerID;

	[NonSerialized]
	public float startTime;

	[NonSerialized]
	public float endTime;

	[NonSerialized]
	public Vector3 missionLocation;

	[NonSerialized]
	public List<ObjectiveStatus> objectiveStatuses;

	[NonSerialized]
	public List<MissionPoint> missionPoints;

	[NonSerialized]
	public List<MissionEntity> missionEntities;

	[NonSerialized]
	public int playerInputRequired;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionInstanceData instance)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.providerID = default(NetworkableId);
		instance.startTime = 0f;
		instance.endTime = 0f;
		instance.missionLocation = default(Vector3);
		if (instance.objectiveStatuses != null)
		{
			for (int i = 0; i < instance.objectiveStatuses.Count; i++)
			{
				if (instance.objectiveStatuses[i] != null)
				{
					instance.objectiveStatuses[i].ResetToPool();
					instance.objectiveStatuses[i] = null;
				}
			}
			List<ObjectiveStatus> list = instance.objectiveStatuses;
			Pool.Free<ObjectiveStatus>(ref list, false);
			instance.objectiveStatuses = list;
		}
		if (instance.missionPoints != null)
		{
			for (int j = 0; j < instance.missionPoints.Count; j++)
			{
				if (instance.missionPoints[j] != null)
				{
					instance.missionPoints[j].ResetToPool();
					instance.missionPoints[j] = null;
				}
			}
			List<MissionPoint> list2 = instance.missionPoints;
			Pool.Free<MissionPoint>(ref list2, false);
			instance.missionPoints = list2;
		}
		if (instance.missionEntities != null)
		{
			for (int k = 0; k < instance.missionEntities.Count; k++)
			{
				if (instance.missionEntities[k] != null)
				{
					instance.missionEntities[k].ResetToPool();
					instance.missionEntities[k] = null;
				}
			}
			List<MissionEntity> list3 = instance.missionEntities;
			Pool.Free<MissionEntity>(ref list3, false);
			instance.missionEntities = list3;
		}
		instance.playerInputRequired = 0;
		Pool.Free<MissionInstanceData>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionInstanceData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionInstanceData instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.providerID = providerID;
		instance.startTime = startTime;
		instance.endTime = endTime;
		instance.missionLocation = missionLocation;
		if (objectiveStatuses != null)
		{
			instance.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			for (int i = 0; i < objectiveStatuses.Count; i++)
			{
				ObjectiveStatus item = objectiveStatuses[i].Copy();
				instance.objectiveStatuses.Add(item);
			}
		}
		else
		{
			instance.objectiveStatuses = null;
		}
		if (missionPoints != null)
		{
			instance.missionPoints = Pool.Get<List<MissionPoint>>();
			for (int j = 0; j < missionPoints.Count; j++)
			{
				MissionPoint item2 = missionPoints[j].Copy();
				instance.missionPoints.Add(item2);
			}
		}
		else
		{
			instance.missionPoints = null;
		}
		if (missionEntities != null)
		{
			instance.missionEntities = Pool.Get<List<MissionEntity>>();
			for (int k = 0; k < missionEntities.Count; k++)
			{
				MissionEntity item3 = missionEntities[k].Copy();
				instance.missionEntities.Add(item3);
			}
		}
		else
		{
			instance.missionEntities = null;
		}
		instance.playerInputRequired = playerInputRequired;
	}

	public MissionInstanceData Copy()
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		CopyTo(missionInstanceData);
		return missionInstanceData;
	}

	public static MissionInstanceData Deserialize(BufferStream stream)
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		Deserialize(stream, missionInstanceData, isDelta: false);
		return missionInstanceData;
	}

	public static MissionInstanceData DeserializeLengthDelimited(BufferStream stream)
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		DeserializeLengthDelimited(stream, missionInstanceData, isDelta: false);
		return missionInstanceData;
	}

	public static MissionInstanceData DeserializeLength(BufferStream stream, int length)
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		DeserializeLength(stream, length, missionInstanceData, isDelta: false);
		return missionInstanceData;
	}

	public static MissionInstanceData Deserialize(byte[] buffer)
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionInstanceData, isDelta: false);
		return missionInstanceData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionInstanceData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionInstanceData Deserialize(BufferStream stream, MissionInstanceData instance, bool isDelta)
	{
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.objectiveStatuses == null)
			{
				instance.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			}
			if (instance.missionPoints == null)
			{
				instance.missionPoints = Pool.Get<List<MissionPoint>>();
			}
			if (instance.missionEntities == null)
			{
				instance.missionEntities = Pool.Get<List<MissionEntity>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.providerID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.startTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.endTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.missionLocation, isDelta);
				continue;
			case 42:
				instance.objectiveStatuses.Add(ObjectiveStatus.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.missionPoints.Add(MissionPoint.DeserializeLengthDelimited(stream));
				continue;
			case 58:
				instance.missionEntities.Add(MissionEntity.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.playerInputRequired = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionInstanceData DeserializeLengthDelimited(BufferStream stream, MissionInstanceData instance, bool isDelta)
	{
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.objectiveStatuses == null)
			{
				instance.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			}
			if (instance.missionPoints == null)
			{
				instance.missionPoints = Pool.Get<List<MissionPoint>>();
			}
			if (instance.missionEntities == null)
			{
				instance.missionEntities = Pool.Get<List<MissionEntity>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.providerID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.startTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.endTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.missionLocation, isDelta);
				continue;
			case 42:
				instance.objectiveStatuses.Add(ObjectiveStatus.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.missionPoints.Add(MissionPoint.DeserializeLengthDelimited(stream));
				continue;
			case 58:
				instance.missionEntities.Add(MissionEntity.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.playerInputRequired = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionInstanceData DeserializeLength(BufferStream stream, int length, MissionInstanceData instance, bool isDelta)
	{
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.objectiveStatuses == null)
			{
				instance.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			}
			if (instance.missionPoints == null)
			{
				instance.missionPoints = Pool.Get<List<MissionPoint>>();
			}
			if (instance.missionEntities == null)
			{
				instance.missionEntities = Pool.Get<List<MissionEntity>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.providerID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.startTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.endTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.missionLocation, isDelta);
				continue;
			case 42:
				instance.objectiveStatuses.Add(ObjectiveStatus.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.missionPoints.Add(MissionPoint.DeserializeLengthDelimited(stream));
				continue;
			case 58:
				instance.missionEntities.Add(MissionEntity.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.playerInputRequired = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionInstanceData instance, MissionInstanceData previous)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.providerID.Value);
		if (instance.startTime != previous.startTime)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.startTime);
		}
		if (instance.endTime != previous.endTime)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.endTime);
		}
		if (instance.missionLocation != previous.missionLocation)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.missionLocation, previous.missionLocation);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field missionLocation (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.objectiveStatuses != null)
		{
			for (int i = 0; i < instance.objectiveStatuses.Count; i++)
			{
				ObjectiveStatus objectiveStatus = instance.objectiveStatuses[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				ObjectiveStatus.SerializeDelta(stream, objectiveStatus, objectiveStatus);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field objectiveStatuses (ProtoBuf.ObjectiveStatus)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
		}
		if (instance.missionPoints != null)
		{
			for (int j = 0; j < instance.missionPoints.Count; j++)
			{
				MissionPoint missionPoint = instance.missionPoints[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				MissionPoint.SerializeDelta(stream, missionPoint, missionPoint);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.missionEntities != null)
		{
			for (int k = 0; k < instance.missionEntities.Count; k++)
			{
				MissionEntity missionEntity = instance.missionEntities[k];
				stream.WriteByte(58);
				BufferStream.RangeHandle range4 = stream.GetRange(5);
				int position4 = stream.Position;
				MissionEntity.SerializeDelta(stream, missionEntity, missionEntity);
				int val2 = stream.Position - position4;
				Span<byte> span4 = range4.GetSpan();
				int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
				if (num4 < 5)
				{
					span4[num4 - 1] |= 128;
					while (num4 < 4)
					{
						span4[num4++] = 128;
					}
					span4[4] = 0;
				}
			}
		}
		if (instance.playerInputRequired != previous.playerInputRequired)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerInputRequired);
		}
	}

	public static void Serialize(BufferStream stream, MissionInstanceData instance)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.providerID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.providerID.Value);
		}
		if (instance.startTime != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.startTime);
		}
		if (instance.endTime != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.endTime);
		}
		if (instance.missionLocation != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.missionLocation);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field missionLocation (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.objectiveStatuses != null)
		{
			for (int i = 0; i < instance.objectiveStatuses.Count; i++)
			{
				ObjectiveStatus instance2 = instance.objectiveStatuses[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				ObjectiveStatus.Serialize(stream, instance2);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field objectiveStatuses (ProtoBuf.ObjectiveStatus)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
		}
		if (instance.missionPoints != null)
		{
			for (int j = 0; j < instance.missionPoints.Count; j++)
			{
				MissionPoint instance3 = instance.missionPoints[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				MissionPoint.Serialize(stream, instance3);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.missionEntities != null)
		{
			for (int k = 0; k < instance.missionEntities.Count; k++)
			{
				MissionEntity instance4 = instance.missionEntities[k];
				stream.WriteByte(58);
				BufferStream.RangeHandle range4 = stream.GetRange(5);
				int position4 = stream.Position;
				MissionEntity.Serialize(stream, instance4);
				int val2 = stream.Position - position4;
				Span<byte> span4 = range4.GetSpan();
				int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
				if (num4 < 5)
				{
					span4[num4 - 1] |= 128;
					while (num4 < 4)
					{
						span4[num4++] = 128;
					}
					span4[4] = 0;
				}
			}
		}
		if (instance.playerInputRequired != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerInputRequired);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref providerID.Value);
		if (objectiveStatuses != null)
		{
			for (int i = 0; i < objectiveStatuses.Count; i++)
			{
				objectiveStatuses[i]?.InspectUids(action);
			}
		}
		if (missionPoints != null)
		{
			for (int j = 0; j < missionPoints.Count; j++)
			{
				missionPoints[j]?.InspectUids(action);
			}
		}
		if (missionEntities != null)
		{
			for (int k = 0; k < missionEntities.Count; k++)
			{
				missionEntities[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerInventory : IDisposable, IPooled, IProto<PlayerInventory>, IProto
{
	[NonSerialized]
	public ItemContainer invMain;

	[NonSerialized]
	public ItemContainer invBelt;

	[NonSerialized]
	public ItemContainer invWear;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerInventory instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.invMain != null)
			{
				instance.invMain.ResetToPool();
				instance.invMain = null;
			}
			if (instance.invBelt != null)
			{
				instance.invBelt.ResetToPool();
				instance.invBelt = null;
			}
			if (instance.invWear != null)
			{
				instance.invWear.ResetToPool();
				instance.invWear = null;
			}
			Pool.Free<PlayerInventory>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerInventory with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerInventory instance)
	{
		if (invMain != null)
		{
			if (instance.invMain == null)
			{
				instance.invMain = invMain.Copy();
			}
			else
			{
				invMain.CopyTo(instance.invMain);
			}
		}
		else
		{
			instance.invMain = null;
		}
		if (invBelt != null)
		{
			if (instance.invBelt == null)
			{
				instance.invBelt = invBelt.Copy();
			}
			else
			{
				invBelt.CopyTo(instance.invBelt);
			}
		}
		else
		{
			instance.invBelt = null;
		}
		if (invWear != null)
		{
			if (instance.invWear == null)
			{
				instance.invWear = invWear.Copy();
			}
			else
			{
				invWear.CopyTo(instance.invWear);
			}
		}
		else
		{
			instance.invWear = null;
		}
	}

	public PlayerInventory Copy()
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		CopyTo(playerInventory);
		return playerInventory;
	}

	public static PlayerInventory Deserialize(BufferStream stream)
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		Deserialize(stream, playerInventory, isDelta: false);
		return playerInventory;
	}

	public static PlayerInventory DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		DeserializeLengthDelimited(stream, playerInventory, isDelta: false);
		return playerInventory;
	}

	public static PlayerInventory DeserializeLength(BufferStream stream, int length)
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		DeserializeLength(stream, length, playerInventory, isDelta: false);
		return playerInventory;
	}

	public static PlayerInventory Deserialize(byte[] buffer)
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerInventory, isDelta: false);
		return playerInventory;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerInventory previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerInventory Deserialize(BufferStream stream, PlayerInventory instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.invMain == null)
				{
					instance.invMain = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invMain, isDelta);
				}
				break;
			case 18:
				if (instance.invBelt == null)
				{
					instance.invBelt = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invBelt, isDelta);
				}
				break;
			case 26:
				if (instance.invWear == null)
				{
					instance.invWear = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invWear, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static PlayerInventory DeserializeLengthDelimited(BufferStream stream, PlayerInventory instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.invMain == null)
				{
					instance.invMain = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invMain, isDelta);
				}
				break;
			case 18:
				if (instance.invBelt == null)
				{
					instance.invBelt = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invBelt, isDelta);
				}
				break;
			case 26:
				if (instance.invWear == null)
				{
					instance.invWear = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invWear, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerInventory DeserializeLength(BufferStream stream, int length, PlayerInventory instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.invMain == null)
				{
					instance.invMain = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invMain, isDelta);
				}
				break;
			case 18:
				if (instance.invBelt == null)
				{
					instance.invBelt = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invBelt, isDelta);
				}
				break;
			case 26:
				if (instance.invWear == null)
				{
					instance.invWear = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invWear, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerInventory instance, PlayerInventory previous)
	{
		if (instance.invMain != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.invMain, previous.invMain);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.invBelt != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.invBelt, previous.invBelt);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.invWear == null)
		{
			return;
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.invWear, previous.invWear);
		int val3 = stream.Position - position3;
		Span<byte> span3 = range3.GetSpan();
		int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
		if (num3 < 5)
		{
			span3[num3 - 1] |= 128;
			while (num3 < 4)
			{
				span3[num3++] = 128;
			}
			span3[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, PlayerInventory instance)
	{
		if (instance.invMain != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance.invMain);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.invBelt != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.Serialize(stream, instance.invBelt);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.invWear == null)
		{
			return;
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		ItemContainer.Serialize(stream, instance.invWear);
		int val3 = stream.Position - position3;
		Span<byte> span3 = range3.GetSpan();
		int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
		if (num3 < 5)
		{
			span3[num3 - 1] |= 128;
			while (num3 < 4)
			{
				span3[num3++] = 128;
			}
			span3[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		invMain?.InspectUids(action);
		invBelt?.InspectUids(action);
		invWear?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PersistantPlayer : IDisposable, IPooled, IProto<PersistantPlayer>, IProto
{
	[NonSerialized]
	public List<int> unlockedItems;

	[NonSerialized]
	public int protocolVersion;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PersistantPlayer instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.unlockedItems != null)
			{
				List<int> list = instance.unlockedItems;
				Pool.FreeUnmanaged<int>(ref list);
				instance.unlockedItems = list;
			}
			instance.protocolVersion = 0;
			Pool.Free<PersistantPlayer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PersistantPlayer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PersistantPlayer instance)
	{
		if (unlockedItems != null)
		{
			instance.unlockedItems = Pool.Get<List<int>>();
			for (int i = 0; i < unlockedItems.Count; i++)
			{
				int item = unlockedItems[i];
				instance.unlockedItems.Add(item);
			}
		}
		else
		{
			instance.unlockedItems = null;
		}
		instance.protocolVersion = protocolVersion;
	}

	public PersistantPlayer Copy()
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		CopyTo(persistantPlayer);
		return persistantPlayer;
	}

	public static PersistantPlayer Deserialize(BufferStream stream)
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		Deserialize(stream, persistantPlayer, isDelta: false);
		return persistantPlayer;
	}

	public static PersistantPlayer DeserializeLengthDelimited(BufferStream stream)
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		DeserializeLengthDelimited(stream, persistantPlayer, isDelta: false);
		return persistantPlayer;
	}

	public static PersistantPlayer DeserializeLength(BufferStream stream, int length)
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		DeserializeLength(stream, length, persistantPlayer, isDelta: false);
		return persistantPlayer;
	}

	public static PersistantPlayer Deserialize(byte[] buffer)
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, persistantPlayer, isDelta: false);
		return persistantPlayer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PersistantPlayer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PersistantPlayer Deserialize(BufferStream stream, PersistantPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.unlockedItems == null)
		{
			instance.unlockedItems = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 24:
				instance.unlockedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.protocolVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static PersistantPlayer DeserializeLengthDelimited(BufferStream stream, PersistantPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.unlockedItems == null)
		{
			instance.unlockedItems = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.unlockedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.protocolVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PersistantPlayer DeserializeLength(BufferStream stream, int length, PersistantPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.unlockedItems == null)
		{
			instance.unlockedItems = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.unlockedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.protocolVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PersistantPlayer instance, PersistantPlayer previous)
	{
		if (instance.unlockedItems != null)
		{
			for (int i = 0; i < instance.unlockedItems.Count; i++)
			{
				int num = instance.unlockedItems[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.protocolVersion != previous.protocolVersion)
		{
			stream.WriteByte(160);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.protocolVersion);
		}
	}

	public static void Serialize(BufferStream stream, PersistantPlayer instance)
	{
		if (instance.unlockedItems != null)
		{
			for (int i = 0; i < instance.unlockedItems.Count; i++)
			{
				int num = instance.unlockedItems[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.protocolVersion != 0)
		{
			stream.WriteByte(160);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.protocolVersion);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerLifeStory : IDisposable, IPooled, IProto<PlayerLifeStory>, IProto
{
	public class DeathInfo : IDisposable, IPooled, IProto<DeathInfo>, IProto
	{
		[NonSerialized]
		public string attackerName;

		[NonSerialized]
		public ulong attackerSteamID;

		[NonSerialized]
		public string hitBone;

		[NonSerialized]
		public string inflictorName;

		[NonSerialized]
		public int lastDamageType;

		[NonSerialized]
		public float attackerDistance;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(DeathInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.attackerName = string.Empty;
				instance.attackerSteamID = 0uL;
				instance.hitBone = string.Empty;
				instance.inflictorName = string.Empty;
				instance.lastDamageType = 0;
				instance.attackerDistance = 0f;
				Pool.Free<DeathInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose DeathInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(DeathInfo instance)
		{
			instance.attackerName = attackerName;
			instance.attackerSteamID = attackerSteamID;
			instance.hitBone = hitBone;
			instance.inflictorName = inflictorName;
			instance.lastDamageType = lastDamageType;
			instance.attackerDistance = attackerDistance;
		}

		public DeathInfo Copy()
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			CopyTo(deathInfo);
			return deathInfo;
		}

		public static DeathInfo Deserialize(BufferStream stream)
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			Deserialize(stream, deathInfo, isDelta: false);
			return deathInfo;
		}

		public static DeathInfo DeserializeLengthDelimited(BufferStream stream)
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			DeserializeLengthDelimited(stream, deathInfo, isDelta: false);
			return deathInfo;
		}

		public static DeathInfo DeserializeLength(BufferStream stream, int length)
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			DeserializeLength(stream, length, deathInfo, isDelta: false);
			return deathInfo;
		}

		public static DeathInfo Deserialize(byte[] buffer)
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, deathInfo, isDelta: false);
			return deathInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, DeathInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static DeathInfo Deserialize(BufferStream stream, DeathInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.attackerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.hitBone = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.inflictorName = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 53:
					instance.attackerDistance = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static DeathInfo DeserializeLengthDelimited(BufferStream stream, DeathInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.attackerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.hitBone = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.inflictorName = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 53:
					instance.attackerDistance = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static DeathInfo DeserializeLength(BufferStream stream, int length, DeathInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.attackerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.hitBone = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.inflictorName = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 53:
					instance.attackerDistance = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, DeathInfo instance, DeathInfo previous)
		{
			if (instance.attackerName != null && instance.attackerName != previous.attackerName)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.attackerName);
			}
			if (instance.attackerSteamID != previous.attackerSteamID)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.attackerSteamID);
			}
			if (instance.hitBone != null && instance.hitBone != previous.hitBone)
			{
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.hitBone);
			}
			if (instance.inflictorName != null && instance.inflictorName != previous.inflictorName)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.inflictorName);
			}
			if (instance.lastDamageType != previous.lastDamageType)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.lastDamageType);
			}
			if (instance.attackerDistance != previous.attackerDistance)
			{
				stream.WriteByte(53);
				ProtocolParser.WriteSingle(stream, instance.attackerDistance);
			}
		}

		public static void Serialize(BufferStream stream, DeathInfo instance)
		{
			if (instance.attackerName != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.attackerName);
			}
			if (instance.attackerSteamID != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.attackerSteamID);
			}
			if (instance.hitBone != null)
			{
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.hitBone);
			}
			if (instance.inflictorName != null)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.inflictorName);
			}
			if (instance.lastDamageType != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.lastDamageType);
			}
			if (instance.attackerDistance != 0f)
			{
				stream.WriteByte(53);
				ProtocolParser.WriteSingle(stream, instance.attackerDistance);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class WeaponStats : IDisposable, IPooled, IProto<WeaponStats>, IProto
	{
		[NonSerialized]
		public string weaponName;

		[NonSerialized]
		public ulong shotsFired;

		[NonSerialized]
		public ulong shotsHit;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(WeaponStats instance)
		{
			if (instance.ShouldPool)
			{
				instance.weaponName = string.Empty;
				instance.shotsFired = 0uL;
				instance.shotsHit = 0uL;
				Pool.Free<WeaponStats>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose WeaponStats with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(WeaponStats instance)
		{
			instance.weaponName = weaponName;
			instance.shotsFired = shotsFired;
			instance.shotsHit = shotsHit;
		}

		public WeaponStats Copy()
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			CopyTo(weaponStats);
			return weaponStats;
		}

		public static WeaponStats Deserialize(BufferStream stream)
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			Deserialize(stream, weaponStats, isDelta: false);
			return weaponStats;
		}

		public static WeaponStats DeserializeLengthDelimited(BufferStream stream)
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			DeserializeLengthDelimited(stream, weaponStats, isDelta: false);
			return weaponStats;
		}

		public static WeaponStats DeserializeLength(BufferStream stream, int length)
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			DeserializeLength(stream, length, weaponStats, isDelta: false);
			return weaponStats;
		}

		public static WeaponStats Deserialize(byte[] buffer)
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, weaponStats, isDelta: false);
			return weaponStats;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, WeaponStats previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static WeaponStats Deserialize(BufferStream stream, WeaponStats instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.weaponName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.shotsFired = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.shotsHit = ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static WeaponStats DeserializeLengthDelimited(BufferStream stream, WeaponStats instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.weaponName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.shotsFired = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.shotsHit = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static WeaponStats DeserializeLength(BufferStream stream, int length, WeaponStats instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.weaponName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.shotsFired = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.shotsHit = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, WeaponStats instance, WeaponStats previous)
		{
			if (instance.weaponName != previous.weaponName)
			{
				if (instance.weaponName == null)
				{
					throw new ArgumentNullException("weaponName", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.weaponName);
			}
			if (instance.shotsFired != previous.shotsFired)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.shotsFired);
			}
			if (instance.shotsHit != previous.shotsHit)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.shotsHit);
			}
		}

		public static void Serialize(BufferStream stream, WeaponStats instance)
		{
			if (instance.weaponName == null)
			{
				throw new ArgumentNullException("weaponName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.weaponName);
			if (instance.shotsFired != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.shotsFired);
			}
			if (instance.shotsHit != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.shotsHit);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class GenericStat : IDisposable, IPooled, IProto<GenericStat>, IProto
	{
		[NonSerialized]
		public string key;

		[NonSerialized]
		public int value;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(GenericStat instance)
		{
			if (instance.ShouldPool)
			{
				instance.key = string.Empty;
				instance.value = 0;
				Pool.Free<GenericStat>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose GenericStat with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(GenericStat instance)
		{
			instance.key = key;
			instance.value = value;
		}

		public GenericStat Copy()
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			CopyTo(genericStat);
			return genericStat;
		}

		public static GenericStat Deserialize(BufferStream stream)
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			Deserialize(stream, genericStat, isDelta: false);
			return genericStat;
		}

		public static GenericStat DeserializeLengthDelimited(BufferStream stream)
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			DeserializeLengthDelimited(stream, genericStat, isDelta: false);
			return genericStat;
		}

		public static GenericStat DeserializeLength(BufferStream stream, int length)
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			DeserializeLength(stream, length, genericStat, isDelta: false);
			return genericStat;
		}

		public static GenericStat Deserialize(byte[] buffer)
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, genericStat, isDelta: false);
			return genericStat;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, GenericStat previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static GenericStat Deserialize(BufferStream stream, GenericStat instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.key = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.value = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static GenericStat DeserializeLengthDelimited(BufferStream stream, GenericStat instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.key = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.value = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static GenericStat DeserializeLength(BufferStream stream, int length, GenericStat instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.key = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.value = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, GenericStat instance, GenericStat previous)
		{
			if (instance.key != previous.key)
			{
				if (instance.key == null)
				{
					throw new ArgumentNullException("key", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.key);
			}
			if (instance.value != previous.value)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
			}
		}

		public static void Serialize(BufferStream stream, GenericStat instance)
		{
			if (instance.key == null)
			{
				throw new ArgumentNullException("key", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.key);
			if (instance.value != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public float secondsAlive;

	[NonSerialized]
	public float metersWalked;

	[NonSerialized]
	public float metersRun;

	[NonSerialized]
	public float secondsSleeping;

	[NonSerialized]
	public uint timeBorn;

	[NonSerialized]
	public uint timeDied;

	[NonSerialized]
	public float secondsWilderness;

	[NonSerialized]
	public float secondsSwimming;

	[NonSerialized]
	public float secondsInBase;

	[NonSerialized]
	public float secondsInMonument;

	[NonSerialized]
	public float secondsFlying;

	[NonSerialized]
	public float secondsBoating;

	[NonSerialized]
	public float secondsDriving;

	[NonSerialized]
	public float totalDamageTaken;

	[NonSerialized]
	public float totalHealing;

	[NonSerialized]
	public DeathInfo deathInfo;

	[NonSerialized]
	public List<WeaponStats> weaponStats;

	[NonSerialized]
	public int killedPlayers;

	[NonSerialized]
	public int killedScientists;

	[NonSerialized]
	public int killedAnimals;

	[NonSerialized]
	public List<GenericStat> genericStats;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerLifeStory instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.secondsAlive = 0f;
		instance.metersWalked = 0f;
		instance.metersRun = 0f;
		instance.secondsSleeping = 0f;
		instance.timeBorn = 0u;
		instance.timeDied = 0u;
		instance.secondsWilderness = 0f;
		instance.secondsSwimming = 0f;
		instance.secondsInBase = 0f;
		instance.secondsInMonument = 0f;
		instance.secondsFlying = 0f;
		instance.secondsBoating = 0f;
		instance.secondsDriving = 0f;
		instance.totalDamageTaken = 0f;
		instance.totalHealing = 0f;
		if (instance.deathInfo != null)
		{
			instance.deathInfo.ResetToPool();
			instance.deathInfo = null;
		}
		if (instance.weaponStats != null)
		{
			for (int i = 0; i < instance.weaponStats.Count; i++)
			{
				if (instance.weaponStats[i] != null)
				{
					instance.weaponStats[i].ResetToPool();
					instance.weaponStats[i] = null;
				}
			}
			List<WeaponStats> list = instance.weaponStats;
			Pool.Free<WeaponStats>(ref list, false);
			instance.weaponStats = list;
		}
		instance.killedPlayers = 0;
		instance.killedScientists = 0;
		instance.killedAnimals = 0;
		if (instance.genericStats != null)
		{
			for (int j = 0; j < instance.genericStats.Count; j++)
			{
				if (instance.genericStats[j] != null)
				{
					instance.genericStats[j].ResetToPool();
					instance.genericStats[j] = null;
				}
			}
			List<GenericStat> list2 = instance.genericStats;
			Pool.Free<GenericStat>(ref list2, false);
			instance.genericStats = list2;
		}
		Pool.Free<PlayerLifeStory>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerLifeStory with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerLifeStory instance)
	{
		instance.secondsAlive = secondsAlive;
		instance.metersWalked = metersWalked;
		instance.metersRun = metersRun;
		instance.secondsSleeping = secondsSleeping;
		instance.timeBorn = timeBorn;
		instance.timeDied = timeDied;
		instance.secondsWilderness = secondsWilderness;
		instance.secondsSwimming = secondsSwimming;
		instance.secondsInBase = secondsInBase;
		instance.secondsInMonument = secondsInMonument;
		instance.secondsFlying = secondsFlying;
		instance.secondsBoating = secondsBoating;
		instance.secondsDriving = secondsDriving;
		instance.totalDamageTaken = totalDamageTaken;
		instance.totalHealing = totalHealing;
		if (deathInfo != null)
		{
			if (instance.deathInfo == null)
			{
				instance.deathInfo = deathInfo.Copy();
			}
			else
			{
				deathInfo.CopyTo(instance.deathInfo);
			}
		}
		else
		{
			instance.deathInfo = null;
		}
		if (weaponStats != null)
		{
			instance.weaponStats = Pool.Get<List<WeaponStats>>();
			for (int i = 0; i < weaponStats.Count; i++)
			{
				WeaponStats item = weaponStats[i].Copy();
				instance.weaponStats.Add(item);
			}
		}
		else
		{
			instance.weaponStats = null;
		}
		instance.killedPlayers = killedPlayers;
		instance.killedScientists = killedScientists;
		instance.killedAnimals = killedAnimals;
		if (genericStats != null)
		{
			instance.genericStats = Pool.Get<List<GenericStat>>();
			for (int j = 0; j < genericStats.Count; j++)
			{
				GenericStat item2 = genericStats[j].Copy();
				instance.genericStats.Add(item2);
			}
		}
		else
		{
			instance.genericStats = null;
		}
	}

	public PlayerLifeStory Copy()
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		CopyTo(playerLifeStory);
		return playerLifeStory;
	}

	public static PlayerLifeStory Deserialize(BufferStream stream)
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		Deserialize(stream, playerLifeStory, isDelta: false);
		return playerLifeStory;
	}

	public static PlayerLifeStory DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		DeserializeLengthDelimited(stream, playerLifeStory, isDelta: false);
		return playerLifeStory;
	}

	public static PlayerLifeStory DeserializeLength(BufferStream stream, int length)
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		DeserializeLength(stream, length, playerLifeStory, isDelta: false);
		return playerLifeStory;
	}

	public static PlayerLifeStory Deserialize(byte[] buffer)
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerLifeStory, isDelta: false);
		return playerLifeStory;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerLifeStory previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerLifeStory Deserialize(BufferStream stream, PlayerLifeStory instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.weaponStats == null)
			{
				instance.weaponStats = Pool.Get<List<WeaponStats>>();
			}
			if (instance.genericStats == null)
			{
				instance.genericStats = Pool.Get<List<GenericStat>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1 || num == 0)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsAlive = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 101u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersWalked = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 102u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersRun = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 103u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSleeping = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 104u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeBorn = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 105u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeDied = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 110u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsWilderness = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 111u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSwimming = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 112u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInBase = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 113u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInMonument = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 114u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsFlying = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 115u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsBoating = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 116u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsDriving = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 150u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalDamageTaken = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 151u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalHealing = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 200u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.deathInfo == null)
					{
						instance.deathInfo = DeathInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						DeathInfo.DeserializeLengthDelimited(stream, instance.deathInfo, isDelta);
					}
				}
				break;
			case 300u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.weaponStats.Add(WeaponStats.DeserializeLengthDelimited(stream));
				}
				break;
			case 301u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 302u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedScientists = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 303u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedAnimals = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 400u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.genericStats.Add(GenericStat.DeserializeLengthDelimited(stream));
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	public static PlayerLifeStory DeserializeLengthDelimited(BufferStream stream, PlayerLifeStory instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.weaponStats == null)
			{
				instance.weaponStats = Pool.Get<List<WeaponStats>>();
			}
			if (instance.genericStats == null)
			{
				instance.genericStats = Pool.Get<List<GenericStat>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsAlive = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 101u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersWalked = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 102u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersRun = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 103u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSleeping = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 104u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeBorn = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 105u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeDied = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 110u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsWilderness = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 111u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSwimming = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 112u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInBase = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 113u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInMonument = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 114u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsFlying = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 115u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsBoating = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 116u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsDriving = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 150u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalDamageTaken = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 151u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalHealing = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 200u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.deathInfo == null)
					{
						instance.deathInfo = DeathInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						DeathInfo.DeserializeLengthDelimited(stream, instance.deathInfo, isDelta);
					}
				}
				break;
			case 300u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.weaponStats.Add(WeaponStats.DeserializeLengthDelimited(stream));
				}
				break;
			case 301u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 302u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedScientists = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 303u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedAnimals = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 400u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.genericStats.Add(GenericStat.DeserializeLengthDelimited(stream));
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	public static PlayerLifeStory DeserializeLength(BufferStream stream, int length, PlayerLifeStory instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.weaponStats == null)
			{
				instance.weaponStats = Pool.Get<List<WeaponStats>>();
			}
			if (instance.genericStats == null)
			{
				instance.genericStats = Pool.Get<List<GenericStat>>();
			}
		}
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsAlive = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 101u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersWalked = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 102u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersRun = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 103u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSleeping = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 104u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeBorn = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 105u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeDied = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 110u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsWilderness = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 111u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSwimming = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 112u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInBase = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 113u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInMonument = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 114u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsFlying = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 115u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsBoating = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 116u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsDriving = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 150u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalDamageTaken = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 151u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalHealing = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 200u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.deathInfo == null)
					{
						instance.deathInfo = DeathInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						DeathInfo.DeserializeLengthDelimited(stream, instance.deathInfo, isDelta);
					}
				}
				break;
			case 300u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.weaponStats.Add(WeaponStats.DeserializeLengthDelimited(stream));
				}
				break;
			case 301u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 302u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedScientists = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 303u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedAnimals = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 400u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.genericStats.Add(GenericStat.DeserializeLengthDelimited(stream));
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerLifeStory instance, PlayerLifeStory previous)
	{
		if (instance.secondsAlive != previous.secondsAlive)
		{
			stream.WriteByte(165);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsAlive);
		}
		if (instance.metersWalked != previous.metersWalked)
		{
			stream.WriteByte(173);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.metersWalked);
		}
		if (instance.metersRun != previous.metersRun)
		{
			stream.WriteByte(181);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.metersRun);
		}
		if (instance.secondsSleeping != previous.secondsSleeping)
		{
			stream.WriteByte(189);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsSleeping);
		}
		if (instance.timeBorn != previous.timeBorn)
		{
			stream.WriteByte(192);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt32(stream, instance.timeBorn);
		}
		if (instance.timeDied != previous.timeDied)
		{
			stream.WriteByte(200);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt32(stream, instance.timeDied);
		}
		if (instance.secondsWilderness != previous.secondsWilderness)
		{
			stream.WriteByte(245);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsWilderness);
		}
		if (instance.secondsSwimming != previous.secondsSwimming)
		{
			stream.WriteByte(253);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsSwimming);
		}
		if (instance.secondsInBase != previous.secondsInBase)
		{
			stream.WriteByte(133);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsInBase);
		}
		if (instance.secondsInMonument != previous.secondsInMonument)
		{
			stream.WriteByte(141);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsInMonument);
		}
		if (instance.secondsFlying != previous.secondsFlying)
		{
			stream.WriteByte(149);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsFlying);
		}
		if (instance.secondsBoating != previous.secondsBoating)
		{
			stream.WriteByte(157);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsBoating);
		}
		if (instance.secondsDriving != previous.secondsDriving)
		{
			stream.WriteByte(165);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsDriving);
		}
		if (instance.totalDamageTaken != previous.totalDamageTaken)
		{
			stream.WriteByte(181);
			stream.WriteByte(9);
			ProtocolParser.WriteSingle(stream, instance.totalDamageTaken);
		}
		if (instance.totalHealing != previous.totalHealing)
		{
			stream.WriteByte(189);
			stream.WriteByte(9);
			ProtocolParser.WriteSingle(stream, instance.totalHealing);
		}
		if (instance.deathInfo != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(12);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			DeathInfo.SerializeDelta(stream, instance.deathInfo, previous.deathInfo);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.weaponStats != null)
		{
			for (int i = 0; i < instance.weaponStats.Count; i++)
			{
				WeaponStats weaponStats = instance.weaponStats[i];
				stream.WriteByte(226);
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WeaponStats.SerializeDelta(stream, weaponStats, weaponStats);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.killedPlayers != previous.killedPlayers)
		{
			stream.WriteByte(232);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedPlayers);
		}
		if (instance.killedScientists != previous.killedScientists)
		{
			stream.WriteByte(240);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedScientists);
		}
		if (instance.killedAnimals != previous.killedAnimals)
		{
			stream.WriteByte(248);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedAnimals);
		}
		if (instance.genericStats == null)
		{
			return;
		}
		for (int j = 0; j < instance.genericStats.Count; j++)
		{
			GenericStat genericStat = instance.genericStats[j];
			stream.WriteByte(130);
			stream.WriteByte(25);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			GenericStat.SerializeDelta(stream, genericStat, genericStat);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, PlayerLifeStory instance)
	{
		if (instance.secondsAlive != 0f)
		{
			stream.WriteByte(165);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsAlive);
		}
		if (instance.metersWalked != 0f)
		{
			stream.WriteByte(173);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.metersWalked);
		}
		if (instance.metersRun != 0f)
		{
			stream.WriteByte(181);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.metersRun);
		}
		if (instance.secondsSleeping != 0f)
		{
			stream.WriteByte(189);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsSleeping);
		}
		if (instance.timeBorn != 0)
		{
			stream.WriteByte(192);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt32(stream, instance.timeBorn);
		}
		if (instance.timeDied != 0)
		{
			stream.WriteByte(200);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt32(stream, instance.timeDied);
		}
		if (instance.secondsWilderness != 0f)
		{
			stream.WriteByte(245);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsWilderness);
		}
		if (instance.secondsSwimming != 0f)
		{
			stream.WriteByte(253);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsSwimming);
		}
		if (instance.secondsInBase != 0f)
		{
			stream.WriteByte(133);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsInBase);
		}
		if (instance.secondsInMonument != 0f)
		{
			stream.WriteByte(141);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsInMonument);
		}
		if (instance.secondsFlying != 0f)
		{
			stream.WriteByte(149);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsFlying);
		}
		if (instance.secondsBoating != 0f)
		{
			stream.WriteByte(157);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsBoating);
		}
		if (instance.secondsDriving != 0f)
		{
			stream.WriteByte(165);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsDriving);
		}
		if (instance.totalDamageTaken != 0f)
		{
			stream.WriteByte(181);
			stream.WriteByte(9);
			ProtocolParser.WriteSingle(stream, instance.totalDamageTaken);
		}
		if (instance.totalHealing != 0f)
		{
			stream.WriteByte(189);
			stream.WriteByte(9);
			ProtocolParser.WriteSingle(stream, instance.totalHealing);
		}
		if (instance.deathInfo != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(12);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			DeathInfo.Serialize(stream, instance.deathInfo);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.weaponStats != null)
		{
			for (int i = 0; i < instance.weaponStats.Count; i++)
			{
				WeaponStats instance2 = instance.weaponStats[i];
				stream.WriteByte(226);
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WeaponStats.Serialize(stream, instance2);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.killedPlayers != 0)
		{
			stream.WriteByte(232);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedPlayers);
		}
		if (instance.killedScientists != 0)
		{
			stream.WriteByte(240);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedScientists);
		}
		if (instance.killedAnimals != 0)
		{
			stream.WriteByte(248);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedAnimals);
		}
		if (instance.genericStats == null)
		{
			return;
		}
		for (int j = 0; j < instance.genericStats.Count; j++)
		{
			GenericStat instance3 = instance.genericStats[j];
			stream.WriteByte(130);
			stream.WriteByte(25);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			GenericStat.Serialize(stream, instance3);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		deathInfo?.InspectUids(action);
		if (weaponStats != null)
		{
			for (int i = 0; i < weaponStats.Count; i++)
			{
				weaponStats[i]?.InspectUids(action);
			}
		}
		if (genericStats != null)
		{
			for (int j = 0; j < genericStats.Count; j++)
			{
				genericStats[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MapNote : IDisposable, IPooled, IProto<MapNote>, IProto
{
	[NonSerialized]
	public int noteType;

	[NonSerialized]
	public Vector3 worldPosition;

	[NonSerialized]
	public int icon;

	[NonSerialized]
	public int colourIndex;

	[NonSerialized]
	public string label;

	[NonSerialized]
	public bool isPing;

	[NonSerialized]
	public float timeRemaining;

	[NonSerialized]
	public float totalDuration;

	[NonSerialized]
	public NetworkableId associatedId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MapNote instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.noteType = 0;
			instance.worldPosition = default(Vector3);
			instance.icon = 0;
			instance.colourIndex = 0;
			instance.label = string.Empty;
			instance.isPing = false;
			instance.timeRemaining = 0f;
			instance.totalDuration = 0f;
			instance.associatedId = default(NetworkableId);
			Pool.Free<MapNote>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MapNote with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MapNote instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.noteType = noteType;
		instance.worldPosition = worldPosition;
		instance.icon = icon;
		instance.colourIndex = colourIndex;
		instance.label = label;
		instance.isPing = isPing;
		instance.timeRemaining = timeRemaining;
		instance.totalDuration = totalDuration;
		instance.associatedId = associatedId;
	}

	public MapNote Copy()
	{
		MapNote mapNote = Pool.Get<MapNote>();
		CopyTo(mapNote);
		return mapNote;
	}

	public static MapNote Deserialize(BufferStream stream)
	{
		MapNote mapNote = Pool.Get<MapNote>();
		Deserialize(stream, mapNote, isDelta: false);
		return mapNote;
	}

	public static MapNote DeserializeLengthDelimited(BufferStream stream)
	{
		MapNote mapNote = Pool.Get<MapNote>();
		DeserializeLengthDelimited(stream, mapNote, isDelta: false);
		return mapNote;
	}

	public static MapNote DeserializeLength(BufferStream stream, int length)
	{
		MapNote mapNote = Pool.Get<MapNote>();
		DeserializeLength(stream, length, mapNote, isDelta: false);
		return mapNote;
	}

	public static MapNote Deserialize(byte[] buffer)
	{
		MapNote mapNote = Pool.Get<MapNote>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mapNote, isDelta: false);
		return mapNote;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MapNote previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MapNote Deserialize(BufferStream stream, MapNote instance, bool isDelta)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 24:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.isPing = ProtocolParser.ReadBool(stream);
				continue;
			case 61:
				instance.timeRemaining = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.totalDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.associatedId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MapNote DeserializeLengthDelimited(BufferStream stream, MapNote instance, bool isDelta)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 24:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.isPing = ProtocolParser.ReadBool(stream);
				continue;
			case 61:
				instance.timeRemaining = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.totalDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.associatedId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MapNote DeserializeLength(BufferStream stream, int length, MapNote instance, bool isDelta)
	{
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 24:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.isPing = ProtocolParser.ReadBool(stream);
				continue;
			case 61:
				instance.timeRemaining = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.totalDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.associatedId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MapNote instance, MapNote previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.noteType != previous.noteType)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
		if (instance.worldPosition != previous.worldPosition)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.worldPosition, previous.worldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.icon != previous.icon)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != previous.colourIndex)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null && instance.label != previous.label)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.label);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.isPing);
		if (instance.timeRemaining != previous.timeRemaining)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.timeRemaining);
		}
		if (instance.totalDuration != previous.totalDuration)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.totalDuration);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteUInt64(stream, instance.associatedId.Value);
	}

	public static void Serialize(BufferStream stream, MapNote instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.noteType != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
		if (instance.worldPosition != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.worldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.icon != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.label);
		}
		if (instance.isPing)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.isPing);
		}
		if (instance.timeRemaining != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.timeRemaining);
		}
		if (instance.totalDuration != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.totalDuration);
		}
		if (instance.associatedId != default(NetworkableId))
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, instance.associatedId.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref associatedId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MapNoteList : IDisposable, IPooled, IProto<MapNoteList>, IProto
{
	[NonSerialized]
	public List<MapNote> notes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MapNoteList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.notes != null)
		{
			for (int i = 0; i < instance.notes.Count; i++)
			{
				if (instance.notes[i] != null)
				{
					instance.notes[i].ResetToPool();
					instance.notes[i] = null;
				}
			}
			List<MapNote> list = instance.notes;
			Pool.Free<MapNote>(ref list, false);
			instance.notes = list;
		}
		Pool.Free<MapNoteList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MapNoteList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MapNoteList instance)
	{
		if (notes != null)
		{
			instance.notes = Pool.Get<List<MapNote>>();
			for (int i = 0; i < notes.Count; i++)
			{
				MapNote item = notes[i].Copy();
				instance.notes.Add(item);
			}
		}
		else
		{
			instance.notes = null;
		}
	}

	public MapNoteList Copy()
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		CopyTo(mapNoteList);
		return mapNoteList;
	}

	public static MapNoteList Deserialize(BufferStream stream)
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		Deserialize(stream, mapNoteList, isDelta: false);
		return mapNoteList;
	}

	public static MapNoteList DeserializeLengthDelimited(BufferStream stream)
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		DeserializeLengthDelimited(stream, mapNoteList, isDelta: false);
		return mapNoteList;
	}

	public static MapNoteList DeserializeLength(BufferStream stream, int length)
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		DeserializeLength(stream, length, mapNoteList, isDelta: false);
		return mapNoteList;
	}

	public static MapNoteList Deserialize(byte[] buffer)
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mapNoteList, isDelta: false);
		return mapNoteList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MapNoteList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MapNoteList Deserialize(BufferStream stream, MapNoteList instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<MapNote>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.notes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MapNoteList DeserializeLengthDelimited(BufferStream stream, MapNoteList instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<MapNote>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.notes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MapNoteList DeserializeLength(BufferStream stream, int length, MapNoteList instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<MapNote>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.notes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MapNoteList instance, MapNoteList previous)
	{
		if (instance.notes == null)
		{
			return;
		}
		for (int i = 0; i < instance.notes.Count; i++)
		{
			MapNote mapNote = instance.notes[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			MapNote.SerializeDelta(stream, mapNote, mapNote);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, MapNoteList instance)
	{
		if (instance.notes == null)
		{
			return;
		}
		for (int i = 0; i < instance.notes.Count; i++)
		{
			MapNote instance2 = instance.notes[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			MapNote.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (notes != null)
		{
			for (int i = 0; i < notes.Count; i++)
			{
				notes[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ItemCrafter : IDisposable, IPooled, IProto<ItemCrafter>, IProto
{
	public class Task : IDisposable, IPooled, IProto<Task>, IProto
	{
		[NonSerialized]
		public int itemID;

		[NonSerialized]
		public float remainingTime;

		[NonSerialized]
		public int taskUID;

		[NonSerialized]
		public bool cancelled;

		[NonSerialized]
		public Item.InstanceData instanceData;

		[NonSerialized]
		public int amount;

		[NonSerialized]
		public int skinID;

		[NonSerialized]
		public List<Item> takenItems;

		[NonSerialized]
		public int numCrafted;

		[NonSerialized]
		public float conditionScale;

		[NonSerialized]
		public NetworkableId workbenchEntity;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Task instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			instance.itemID = 0;
			instance.remainingTime = 0f;
			instance.taskUID = 0;
			instance.cancelled = false;
			if (instance.instanceData != null)
			{
				instance.instanceData.ResetToPool();
				instance.instanceData = null;
			}
			instance.amount = 0;
			instance.skinID = 0;
			if (instance.takenItems != null)
			{
				for (int i = 0; i < instance.takenItems.Count; i++)
				{
					if (instance.takenItems[i] != null)
					{
						instance.takenItems[i].ResetToPool();
						instance.takenItems[i] = null;
					}
				}
				List<Item> list = instance.takenItems;
				Pool.Free<Item>(ref list, false);
				instance.takenItems = list;
			}
			instance.numCrafted = 0;
			instance.conditionScale = 0f;
			instance.workbenchEntity = default(NetworkableId);
			Pool.Free<Task>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Task with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Task instance)
		{
			instance.itemID = itemID;
			instance.remainingTime = remainingTime;
			instance.taskUID = taskUID;
			instance.cancelled = cancelled;
			if (instanceData != null)
			{
				if (instance.instanceData == null)
				{
					instance.instanceData = instanceData.Copy();
				}
				else
				{
					instanceData.CopyTo(instance.instanceData);
				}
			}
			else
			{
				instance.instanceData = null;
			}
			instance.amount = amount;
			instance.skinID = skinID;
			if (takenItems != null)
			{
				instance.takenItems = Pool.Get<List<Item>>();
				for (int i = 0; i < takenItems.Count; i++)
				{
					Item item = takenItems[i].Copy();
					instance.takenItems.Add(item);
				}
			}
			else
			{
				instance.takenItems = null;
			}
			instance.numCrafted = numCrafted;
			instance.conditionScale = conditionScale;
			instance.workbenchEntity = workbenchEntity;
		}

		public Task Copy()
		{
			Task task = Pool.Get<Task>();
			CopyTo(task);
			return task;
		}

		public static Task Deserialize(BufferStream stream)
		{
			Task task = Pool.Get<Task>();
			Deserialize(stream, task, isDelta: false);
			return task;
		}

		public static Task DeserializeLengthDelimited(BufferStream stream)
		{
			Task task = Pool.Get<Task>();
			DeserializeLengthDelimited(stream, task, isDelta: false);
			return task;
		}

		public static Task DeserializeLength(BufferStream stream, int length)
		{
			Task task = Pool.Get<Task>();
			DeserializeLength(stream, length, task, isDelta: false);
			return task;
		}

		public static Task Deserialize(byte[] buffer)
		{
			Task task = Pool.Get<Task>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, task, isDelta: false);
			return task;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Task previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Task Deserialize(BufferStream stream, Task instance, bool isDelta)
		{
			if (!isDelta && instance.takenItems == null)
			{
				instance.takenItems = Pool.Get<List<Item>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 21:
					instance.remainingTime = ProtocolParser.ReadSingle(stream);
					break;
				case 24:
					instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 32:
					instance.cancelled = ProtocolParser.ReadBool(stream);
					break;
				case 42:
					if (instance.instanceData == null)
					{
						instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
					}
					else
					{
						Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
					}
					break;
				case 48:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 56:
					instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 66:
					instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
					break;
				case 72:
					instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 85:
					instance.conditionScale = ProtocolParser.ReadSingle(stream);
					break;
				case 88:
					instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
				case 0:
					return instance;
				}
			}
		}

		public static Task DeserializeLengthDelimited(BufferStream stream, Task instance, bool isDelta)
		{
			if (!isDelta && instance.takenItems == null)
			{
				instance.takenItems = Pool.Get<List<Item>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 21:
					instance.remainingTime = ProtocolParser.ReadSingle(stream);
					break;
				case 24:
					instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 32:
					instance.cancelled = ProtocolParser.ReadBool(stream);
					break;
				case 42:
					if (instance.instanceData == null)
					{
						instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
					}
					else
					{
						Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
					}
					break;
				case 48:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 56:
					instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 66:
					instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
					break;
				case 72:
					instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 85:
					instance.conditionScale = ProtocolParser.ReadSingle(stream);
					break;
				case 88:
					instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Task DeserializeLength(BufferStream stream, int length, Task instance, bool isDelta)
		{
			if (!isDelta && instance.takenItems == null)
			{
				instance.takenItems = Pool.Get<List<Item>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 21:
					instance.remainingTime = ProtocolParser.ReadSingle(stream);
					break;
				case 24:
					instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 32:
					instance.cancelled = ProtocolParser.ReadBool(stream);
					break;
				case 42:
					if (instance.instanceData == null)
					{
						instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
					}
					else
					{
						Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
					}
					break;
				case 48:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 56:
					instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 66:
					instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
					break;
				case 72:
					instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 85:
					instance.conditionScale = ProtocolParser.ReadSingle(stream);
					break;
				case 88:
					instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Task instance, Task previous)
		{
			if (instance.itemID != previous.itemID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
			}
			if (instance.remainingTime != previous.remainingTime)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.remainingTime);
			}
			if (instance.taskUID != previous.taskUID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.taskUID);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.cancelled);
			if (instance.instanceData != null)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Item.InstanceData.SerializeDelta(stream, instance.instanceData, previous.instanceData);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.amount != previous.amount)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
			}
			if (instance.skinID != previous.skinID)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.skinID);
			}
			if (instance.takenItems != null)
			{
				for (int i = 0; i < instance.takenItems.Count; i++)
				{
					Item item = instance.takenItems[i];
					stream.WriteByte(66);
					BufferStream.RangeHandle range2 = stream.GetRange(5);
					int position2 = stream.Position;
					Item.SerializeDelta(stream, item, item);
					int val = stream.Position - position2;
					Span<byte> span2 = range2.GetSpan();
					int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
					if (num2 < 5)
					{
						span2[num2 - 1] |= 128;
						while (num2 < 4)
						{
							span2[num2++] = 128;
						}
						span2[4] = 0;
					}
				}
			}
			if (instance.numCrafted != previous.numCrafted)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.numCrafted);
			}
			if (instance.conditionScale != previous.conditionScale)
			{
				stream.WriteByte(85);
				ProtocolParser.WriteSingle(stream, instance.conditionScale);
			}
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, instance.workbenchEntity.Value);
		}

		public static void Serialize(BufferStream stream, Task instance)
		{
			if (instance.itemID != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
			}
			if (instance.remainingTime != 0f)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.remainingTime);
			}
			if (instance.taskUID != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.taskUID);
			}
			if (instance.cancelled)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteBool(stream, instance.cancelled);
			}
			if (instance.instanceData != null)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Item.InstanceData.Serialize(stream, instance.instanceData);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.amount != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
			}
			if (instance.skinID != 0)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.skinID);
			}
			if (instance.takenItems != null)
			{
				for (int i = 0; i < instance.takenItems.Count; i++)
				{
					Item instance2 = instance.takenItems[i];
					stream.WriteByte(66);
					BufferStream.RangeHandle range2 = stream.GetRange(5);
					int position2 = stream.Position;
					Item.Serialize(stream, instance2);
					int val = stream.Position - position2;
					Span<byte> span2 = range2.GetSpan();
					int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
					if (num2 < 5)
					{
						span2[num2 - 1] |= 128;
						while (num2 < 4)
						{
							span2[num2++] = 128;
						}
						span2[4] = 0;
					}
				}
			}
			if (instance.numCrafted != 0)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.numCrafted);
			}
			if (instance.conditionScale != 0f)
			{
				stream.WriteByte(85);
				ProtocolParser.WriteSingle(stream, instance.conditionScale);
			}
			if (instance.workbenchEntity != default(NetworkableId))
			{
				stream.WriteByte(88);
				ProtocolParser.WriteUInt64(stream, instance.workbenchEntity.Value);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			instanceData?.InspectUids(action);
			if (takenItems != null)
			{
				for (int i = 0; i < takenItems.Count; i++)
				{
					takenItems[i]?.InspectUids(action);
				}
			}
			action(UidType.Clear, ref workbenchEntity.Value);
		}
	}

	[NonSerialized]
	public List<Task> queue;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemCrafter instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.queue != null)
		{
			for (int i = 0; i < instance.queue.Count; i++)
			{
				if (instance.queue[i] != null)
				{
					instance.queue[i].ResetToPool();
					instance.queue[i] = null;
				}
			}
			List<Task> list = instance.queue;
			Pool.Free<Task>(ref list, false);
			instance.queue = list;
		}
		Pool.Free<ItemCrafter>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemCrafter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemCrafter instance)
	{
		if (queue != null)
		{
			instance.queue = Pool.Get<List<Task>>();
			for (int i = 0; i < queue.Count; i++)
			{
				Task item = queue[i].Copy();
				instance.queue.Add(item);
			}
		}
		else
		{
			instance.queue = null;
		}
	}

	public ItemCrafter Copy()
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		CopyTo(itemCrafter);
		return itemCrafter;
	}

	public static ItemCrafter Deserialize(BufferStream stream)
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		Deserialize(stream, itemCrafter, isDelta: false);
		return itemCrafter;
	}

	public static ItemCrafter DeserializeLengthDelimited(BufferStream stream)
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		DeserializeLengthDelimited(stream, itemCrafter, isDelta: false);
		return itemCrafter;
	}

	public static ItemCrafter DeserializeLength(BufferStream stream, int length)
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		DeserializeLength(stream, length, itemCrafter, isDelta: false);
		return itemCrafter;
	}

	public static ItemCrafter Deserialize(byte[] buffer)
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemCrafter, isDelta: false);
		return itemCrafter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemCrafter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemCrafter Deserialize(BufferStream stream, ItemCrafter instance, bool isDelta)
	{
		if (!isDelta && instance.queue == null)
		{
			instance.queue = Pool.Get<List<Task>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.queue.Add(Task.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemCrafter DeserializeLengthDelimited(BufferStream stream, ItemCrafter instance, bool isDelta)
	{
		if (!isDelta && instance.queue == null)
		{
			instance.queue = Pool.Get<List<Task>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.queue.Add(Task.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemCrafter DeserializeLength(BufferStream stream, int length, ItemCrafter instance, bool isDelta)
	{
		if (!isDelta && instance.queue == null)
		{
			instance.queue = Pool.Get<List<Task>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.queue.Add(Task.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemCrafter instance, ItemCrafter previous)
	{
		if (instance.queue == null)
		{
			return;
		}
		for (int i = 0; i < instance.queue.Count; i++)
		{
			Task task = instance.queue[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Task.SerializeDelta(stream, task, task);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ItemCrafter instance)
	{
		if (instance.queue == null)
		{
			return;
		}
		for (int i = 0; i < instance.queue.Count; i++)
		{
			Task instance2 = instance.queue[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Task.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (queue != null)
		{
			for (int i = 0; i < queue.Count; i++)
			{
				queue[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SpectateTeamInfo : IDisposable, IPooled, IProto<SpectateTeamInfo>, IProto
{
	[NonSerialized]
	public List<SpectateTeam> teams;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpectateTeamInfo instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.teams != null)
		{
			for (int i = 0; i < instance.teams.Count; i++)
			{
				if (instance.teams[i] != null)
				{
					instance.teams[i].ResetToPool();
					instance.teams[i] = null;
				}
			}
			List<SpectateTeam> list = instance.teams;
			Pool.Free<SpectateTeam>(ref list, false);
			instance.teams = list;
		}
		Pool.Free<SpectateTeamInfo>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpectateTeamInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpectateTeamInfo instance)
	{
		if (teams != null)
		{
			instance.teams = Pool.Get<List<SpectateTeam>>();
			for (int i = 0; i < teams.Count; i++)
			{
				SpectateTeam item = teams[i].Copy();
				instance.teams.Add(item);
			}
		}
		else
		{
			instance.teams = null;
		}
	}

	public SpectateTeamInfo Copy()
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		CopyTo(spectateTeamInfo);
		return spectateTeamInfo;
	}

	public static SpectateTeamInfo Deserialize(BufferStream stream)
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		Deserialize(stream, spectateTeamInfo, isDelta: false);
		return spectateTeamInfo;
	}

	public static SpectateTeamInfo DeserializeLengthDelimited(BufferStream stream)
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		DeserializeLengthDelimited(stream, spectateTeamInfo, isDelta: false);
		return spectateTeamInfo;
	}

	public static SpectateTeamInfo DeserializeLength(BufferStream stream, int length)
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		DeserializeLength(stream, length, spectateTeamInfo, isDelta: false);
		return spectateTeamInfo;
	}

	public static SpectateTeamInfo Deserialize(byte[] buffer)
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spectateTeamInfo, isDelta: false);
		return spectateTeamInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpectateTeamInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpectateTeamInfo Deserialize(BufferStream stream, SpectateTeamInfo instance, bool isDelta)
	{
		if (!isDelta && instance.teams == null)
		{
			instance.teams = Pool.Get<List<SpectateTeam>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.teams.Add(SpectateTeam.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpectateTeamInfo DeserializeLengthDelimited(BufferStream stream, SpectateTeamInfo instance, bool isDelta)
	{
		if (!isDelta && instance.teams == null)
		{
			instance.teams = Pool.Get<List<SpectateTeam>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.teams.Add(SpectateTeam.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpectateTeamInfo DeserializeLength(BufferStream stream, int length, SpectateTeamInfo instance, bool isDelta)
	{
		if (!isDelta && instance.teams == null)
		{
			instance.teams = Pool.Get<List<SpectateTeam>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.teams.Add(SpectateTeam.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpectateTeamInfo instance, SpectateTeamInfo previous)
	{
		if (instance.teams == null)
		{
			return;
		}
		for (int i = 0; i < instance.teams.Count; i++)
		{
			SpectateTeam spectateTeam = instance.teams[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			SpectateTeam.SerializeDelta(stream, spectateTeam, spectateTeam);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, SpectateTeamInfo instance)
	{
		if (instance.teams == null)
		{
			return;
		}
		for (int i = 0; i < instance.teams.Count; i++)
		{
			SpectateTeam instance2 = instance.teams[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			SpectateTeam.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (teams != null)
		{
			for (int i = 0; i < teams.Count; i++)
			{
				teams[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SpectateTeam : IDisposable, IPooled, IProto<SpectateTeam>, IProto
{
	[NonSerialized]
	public ulong teamId;

	[NonSerialized]
	public List<PlayerTeam.TeamMember> teamMembers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpectateTeam instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.teamId = 0uL;
		if (instance.teamMembers != null)
		{
			for (int i = 0; i < instance.teamMembers.Count; i++)
			{
				if (instance.teamMembers[i] != null)
				{
					instance.teamMembers[i].ResetToPool();
					instance.teamMembers[i] = null;
				}
			}
			List<PlayerTeam.TeamMember> list = instance.teamMembers;
			Pool.Free<PlayerTeam.TeamMember>(ref list, false);
			instance.teamMembers = list;
		}
		Pool.Free<SpectateTeam>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpectateTeam with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpectateTeam instance)
	{
		instance.teamId = teamId;
		if (teamMembers != null)
		{
			instance.teamMembers = Pool.Get<List<PlayerTeam.TeamMember>>();
			for (int i = 0; i < teamMembers.Count; i++)
			{
				PlayerTeam.TeamMember item = teamMembers[i].Copy();
				instance.teamMembers.Add(item);
			}
		}
		else
		{
			instance.teamMembers = null;
		}
	}

	public SpectateTeam Copy()
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		CopyTo(spectateTeam);
		return spectateTeam;
	}

	public static SpectateTeam Deserialize(BufferStream stream)
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		Deserialize(stream, spectateTeam, isDelta: false);
		return spectateTeam;
	}

	public static SpectateTeam DeserializeLengthDelimited(BufferStream stream)
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		DeserializeLengthDelimited(stream, spectateTeam, isDelta: false);
		return spectateTeam;
	}

	public static SpectateTeam DeserializeLength(BufferStream stream, int length)
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		DeserializeLength(stream, length, spectateTeam, isDelta: false);
		return spectateTeam;
	}

	public static SpectateTeam Deserialize(byte[] buffer)
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spectateTeam, isDelta: false);
		return spectateTeam;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpectateTeam previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpectateTeam Deserialize(BufferStream stream, SpectateTeam instance, bool isDelta)
	{
		if (!isDelta && instance.teamMembers == null)
		{
			instance.teamMembers = Pool.Get<List<PlayerTeam.TeamMember>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamMembers.Add(PlayerTeam.TeamMember.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpectateTeam DeserializeLengthDelimited(BufferStream stream, SpectateTeam instance, bool isDelta)
	{
		if (!isDelta && instance.teamMembers == null)
		{
			instance.teamMembers = Pool.Get<List<PlayerTeam.TeamMember>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamMembers.Add(PlayerTeam.TeamMember.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpectateTeam DeserializeLength(BufferStream stream, int length, SpectateTeam instance, bool isDelta)
	{
		if (!isDelta && instance.teamMembers == null)
		{
			instance.teamMembers = Pool.Get<List<PlayerTeam.TeamMember>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamMembers.Add(PlayerTeam.TeamMember.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpectateTeam instance, SpectateTeam previous)
	{
		if (instance.teamId != previous.teamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.teamId);
		}
		if (instance.teamMembers == null)
		{
			return;
		}
		for (int i = 0; i < instance.teamMembers.Count; i++)
		{
			PlayerTeam.TeamMember teamMember = instance.teamMembers[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerTeam.TeamMember.SerializeDelta(stream, teamMember, teamMember);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, SpectateTeam instance)
	{
		if (instance.teamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.teamId);
		}
		if (instance.teamMembers == null)
		{
			return;
		}
		for (int i = 0; i < instance.teamMembers.Count; i++)
		{
			PlayerTeam.TeamMember instance2 = instance.teamMembers[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerTeam.TeamMember.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (teamMembers != null)
		{
			for (int i = 0; i < teamMembers.Count; i++)
			{
				teamMembers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerState : IDisposable, IPooled, IProto<PlayerState>, IProto
{
	[NonSerialized]
	public double unHostileTimestamp;

	[NonSerialized]
	public List<MapNote> pointsOfInterest;

	[NonSerialized]
	public MapNote deathMarker;

	[NonSerialized]
	public Missions missions;

	[NonSerialized]
	public List<MapNote> pings;

	[NonSerialized]
	public bool chatMuted;

	[NonSerialized]
	public double chatMuteExpiryTimestamp;

	[NonSerialized]
	public int numberOfTimesReported;

	[NonSerialized]
	public List<uint> fogImages;

	[NonSerialized]
	public NetworkableId fogImageNetId;

	[NonSerialized]
	public int protocol;

	[NonSerialized]
	public uint seed;

	[NonSerialized]
	public int saveCreatedTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerState instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.unHostileTimestamp = 0.0;
		if (instance.pointsOfInterest != null)
		{
			for (int i = 0; i < instance.pointsOfInterest.Count; i++)
			{
				if (instance.pointsOfInterest[i] != null)
				{
					instance.pointsOfInterest[i].ResetToPool();
					instance.pointsOfInterest[i] = null;
				}
			}
			List<MapNote> list = instance.pointsOfInterest;
			Pool.Free<MapNote>(ref list, false);
			instance.pointsOfInterest = list;
		}
		if (instance.deathMarker != null)
		{
			instance.deathMarker.ResetToPool();
			instance.deathMarker = null;
		}
		if (instance.missions != null)
		{
			instance.missions.ResetToPool();
			instance.missions = null;
		}
		if (instance.pings != null)
		{
			for (int j = 0; j < instance.pings.Count; j++)
			{
				if (instance.pings[j] != null)
				{
					instance.pings[j].ResetToPool();
					instance.pings[j] = null;
				}
			}
			List<MapNote> list2 = instance.pings;
			Pool.Free<MapNote>(ref list2, false);
			instance.pings = list2;
		}
		instance.chatMuted = false;
		instance.chatMuteExpiryTimestamp = 0.0;
		instance.numberOfTimesReported = 0;
		if (instance.fogImages != null)
		{
			List<uint> list3 = instance.fogImages;
			Pool.FreeUnmanaged<uint>(ref list3);
			instance.fogImages = list3;
		}
		instance.fogImageNetId = default(NetworkableId);
		instance.protocol = 0;
		instance.seed = 0u;
		instance.saveCreatedTime = 0;
		Pool.Free<PlayerState>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerState with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerState instance)
	{
		instance.unHostileTimestamp = unHostileTimestamp;
		if (pointsOfInterest != null)
		{
			instance.pointsOfInterest = Pool.Get<List<MapNote>>();
			for (int i = 0; i < pointsOfInterest.Count; i++)
			{
				MapNote item = pointsOfInterest[i].Copy();
				instance.pointsOfInterest.Add(item);
			}
		}
		else
		{
			instance.pointsOfInterest = null;
		}
		if (deathMarker != null)
		{
			if (instance.deathMarker == null)
			{
				instance.deathMarker = deathMarker.Copy();
			}
			else
			{
				deathMarker.CopyTo(instance.deathMarker);
			}
		}
		else
		{
			instance.deathMarker = null;
		}
		if (missions != null)
		{
			if (instance.missions == null)
			{
				instance.missions = missions.Copy();
			}
			else
			{
				missions.CopyTo(instance.missions);
			}
		}
		else
		{
			instance.missions = null;
		}
		if (pings != null)
		{
			instance.pings = Pool.Get<List<MapNote>>();
			for (int j = 0; j < pings.Count; j++)
			{
				MapNote item2 = pings[j].Copy();
				instance.pings.Add(item2);
			}
		}
		else
		{
			instance.pings = null;
		}
		instance.chatMuted = chatMuted;
		instance.chatMuteExpiryTimestamp = chatMuteExpiryTimestamp;
		instance.numberOfTimesReported = numberOfTimesReported;
		if (fogImages != null)
		{
			instance.fogImages = Pool.Get<List<uint>>();
			for (int k = 0; k < fogImages.Count; k++)
			{
				uint item3 = fogImages[k];
				instance.fogImages.Add(item3);
			}
		}
		else
		{
			instance.fogImages = null;
		}
		instance.fogImageNetId = fogImageNetId;
		instance.protocol = protocol;
		instance.seed = seed;
		instance.saveCreatedTime = saveCreatedTime;
	}

	public PlayerState Copy()
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		CopyTo(playerState);
		return playerState;
	}

	public static PlayerState Deserialize(BufferStream stream)
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		Deserialize(stream, playerState, isDelta: false);
		return playerState;
	}

	public static PlayerState DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		DeserializeLengthDelimited(stream, playerState, isDelta: false);
		return playerState;
	}

	public static PlayerState DeserializeLength(BufferStream stream, int length)
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		DeserializeLength(stream, length, playerState, isDelta: false);
		return playerState;
	}

	public static PlayerState Deserialize(byte[] buffer)
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerState, isDelta: false);
		return playerState;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerState previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerState Deserialize(BufferStream stream, PlayerState instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.pointsOfInterest == null)
			{
				instance.pointsOfInterest = Pool.Get<List<MapNote>>();
			}
			if (instance.pings == null)
			{
				instance.pings = Pool.Get<List<MapNote>>();
			}
			if (instance.fogImages == null)
			{
				instance.fogImages = Pool.Get<List<uint>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 9:
				instance.unHostileTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 26:
				instance.pointsOfInterest.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				if (instance.deathMarker == null)
				{
					instance.deathMarker = MapNote.DeserializeLengthDelimited(stream);
				}
				else
				{
					MapNote.DeserializeLengthDelimited(stream, instance.deathMarker, isDelta);
				}
				continue;
			case 42:
				if (instance.missions == null)
				{
					instance.missions = Missions.DeserializeLengthDelimited(stream);
				}
				else
				{
					Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
				}
				continue;
			case 50:
				instance.pings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.chatMuted = ProtocolParser.ReadBool(stream);
				continue;
			case 65:
				instance.chatMuteExpiryTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 72:
				instance.numberOfTimesReported = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.fogImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 88:
				instance.fogImageNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 50u:
				if (key.WireType == Wire.Varint)
				{
					instance.protocol = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 51u:
				if (key.WireType == Wire.Varint)
				{
					instance.seed = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 52u:
				if (key.WireType == Wire.Varint)
				{
					instance.saveCreatedTime = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static PlayerState DeserializeLengthDelimited(BufferStream stream, PlayerState instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.pointsOfInterest == null)
			{
				instance.pointsOfInterest = Pool.Get<List<MapNote>>();
			}
			if (instance.pings == null)
			{
				instance.pings = Pool.Get<List<MapNote>>();
			}
			if (instance.fogImages == null)
			{
				instance.fogImages = Pool.Get<List<uint>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 9:
				instance.unHostileTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 26:
				instance.pointsOfInterest.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				if (instance.deathMarker == null)
				{
					instance.deathMarker = MapNote.DeserializeLengthDelimited(stream);
				}
				else
				{
					MapNote.DeserializeLengthDelimited(stream, instance.deathMarker, isDelta);
				}
				continue;
			case 42:
				if (instance.missions == null)
				{
					instance.missions = Missions.DeserializeLengthDelimited(stream);
				}
				else
				{
					Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
				}
				continue;
			case 50:
				instance.pings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.chatMuted = ProtocolParser.ReadBool(stream);
				continue;
			case 65:
				instance.chatMuteExpiryTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 72:
				instance.numberOfTimesReported = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.fogImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 88:
				instance.fogImageNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 50u:
				if (key.WireType == Wire.Varint)
				{
					instance.protocol = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 51u:
				if (key.WireType == Wire.Varint)
				{
					instance.seed = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 52u:
				if (key.WireType == Wire.Varint)
				{
					instance.saveCreatedTime = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerState DeserializeLength(BufferStream stream, int length, PlayerState instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.pointsOfInterest == null)
			{
				instance.pointsOfInterest = Pool.Get<List<MapNote>>();
			}
			if (instance.pings == null)
			{
				instance.pings = Pool.Get<List<MapNote>>();
			}
			if (instance.fogImages == null)
			{
				instance.fogImages = Pool.Get<List<uint>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 9:
				instance.unHostileTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 26:
				instance.pointsOfInterest.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				if (instance.deathMarker == null)
				{
					instance.deathMarker = MapNote.DeserializeLengthDelimited(stream);
				}
				else
				{
					MapNote.DeserializeLengthDelimited(stream, instance.deathMarker, isDelta);
				}
				continue;
			case 42:
				if (instance.missions == null)
				{
					instance.missions = Missions.DeserializeLengthDelimited(stream);
				}
				else
				{
					Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
				}
				continue;
			case 50:
				instance.pings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.chatMuted = ProtocolParser.ReadBool(stream);
				continue;
			case 65:
				instance.chatMuteExpiryTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 72:
				instance.numberOfTimesReported = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.fogImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 88:
				instance.fogImageNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 50u:
				if (key.WireType == Wire.Varint)
				{
					instance.protocol = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 51u:
				if (key.WireType == Wire.Varint)
				{
					instance.seed = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 52u:
				if (key.WireType == Wire.Varint)
				{
					instance.saveCreatedTime = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerState instance, PlayerState previous)
	{
		if (instance.unHostileTimestamp != previous.unHostileTimestamp)
		{
			stream.WriteByte(9);
			ProtocolParser.WriteDouble(stream, instance.unHostileTimestamp);
		}
		if (instance.pointsOfInterest != null)
		{
			for (int i = 0; i < instance.pointsOfInterest.Count; i++)
			{
				MapNote mapNote = instance.pointsOfInterest[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MapNote.SerializeDelta(stream, mapNote, mapNote);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.deathMarker != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			MapNote.SerializeDelta(stream, instance.deathMarker, previous.deathMarker);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.missions != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			Missions.SerializeDelta(stream, instance.missions, previous.missions);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
		if (instance.pings != null)
		{
			for (int j = 0; j < instance.pings.Count; j++)
			{
				MapNote mapNote2 = instance.pings[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range4 = stream.GetRange(5);
				int position4 = stream.Position;
				MapNote.SerializeDelta(stream, mapNote2, mapNote2);
				int val4 = stream.Position - position4;
				Span<byte> span4 = range4.GetSpan();
				int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
				if (num4 < 5)
				{
					span4[num4 - 1] |= 128;
					while (num4 < 4)
					{
						span4[num4++] = 128;
					}
					span4[4] = 0;
				}
			}
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.chatMuted);
		if (instance.chatMuteExpiryTimestamp != previous.chatMuteExpiryTimestamp)
		{
			stream.WriteByte(65);
			ProtocolParser.WriteDouble(stream, instance.chatMuteExpiryTimestamp);
		}
		if (instance.numberOfTimesReported != previous.numberOfTimesReported)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numberOfTimesReported);
		}
		if (instance.fogImages != null)
		{
			for (int k = 0; k < instance.fogImages.Count; k++)
			{
				uint val5 = instance.fogImages[k];
				stream.WriteByte(80);
				ProtocolParser.WriteUInt32(stream, val5);
			}
		}
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, instance.fogImageNetId.Value);
		if (instance.protocol != previous.protocol)
		{
			stream.WriteByte(144);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.protocol);
		}
		if (instance.seed != previous.seed)
		{
			stream.WriteByte(152);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.saveCreatedTime != previous.saveCreatedTime)
		{
			stream.WriteByte(160);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.saveCreatedTime);
		}
	}

	public static void Serialize(BufferStream stream, PlayerState instance)
	{
		if (instance.unHostileTimestamp != 0.0)
		{
			stream.WriteByte(9);
			ProtocolParser.WriteDouble(stream, instance.unHostileTimestamp);
		}
		if (instance.pointsOfInterest != null)
		{
			for (int i = 0; i < instance.pointsOfInterest.Count; i++)
			{
				MapNote instance2 = instance.pointsOfInterest[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MapNote.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.deathMarker != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			MapNote.Serialize(stream, instance.deathMarker);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.missions != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			Missions.Serialize(stream, instance.missions);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
		if (instance.pings != null)
		{
			for (int j = 0; j < instance.pings.Count; j++)
			{
				MapNote instance3 = instance.pings[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range4 = stream.GetRange(5);
				int position4 = stream.Position;
				MapNote.Serialize(stream, instance3);
				int val4 = stream.Position - position4;
				Span<byte> span4 = range4.GetSpan();
				int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
				if (num4 < 5)
				{
					span4[num4 - 1] |= 128;
					while (num4 < 4)
					{
						span4[num4++] = 128;
					}
					span4[4] = 0;
				}
			}
		}
		if (instance.chatMuted)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.chatMuted);
		}
		if (instance.chatMuteExpiryTimestamp != 0.0)
		{
			stream.WriteByte(65);
			ProtocolParser.WriteDouble(stream, instance.chatMuteExpiryTimestamp);
		}
		if (instance.numberOfTimesReported != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numberOfTimesReported);
		}
		if (instance.fogImages != null)
		{
			for (int k = 0; k < instance.fogImages.Count; k++)
			{
				uint val5 = instance.fogImages[k];
				stream.WriteByte(80);
				ProtocolParser.WriteUInt32(stream, val5);
			}
		}
		if (instance.fogImageNetId != default(NetworkableId))
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, instance.fogImageNetId.Value);
		}
		if (instance.protocol != 0)
		{
			stream.WriteByte(144);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.protocol);
		}
		if (instance.seed != 0)
		{
			stream.WriteByte(152);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.saveCreatedTime != 0)
		{
			stream.WriteByte(160);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.saveCreatedTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (pointsOfInterest != null)
		{
			for (int i = 0; i < pointsOfInterest.Count; i++)
			{
				pointsOfInterest[i]?.InspectUids(action);
			}
		}
		deathMarker?.InspectUids(action);
		missions?.InspectUids(action);
		if (pings != null)
		{
			for (int j = 0; j < pings.Count; j++)
			{
				pings[j]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref fogImageNetId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class GlobalEntityData : IDisposable, IPooled, IProto<GlobalEntityData>, IProto
{
	[NonSerialized]
	public uint prefabId;

	[NonSerialized]
	public NetworkableId uid;

	[NonSerialized]
	public Vector3 pos;

	[NonSerialized]
	public Vector3 rot;

	[NonSerialized]
	public ulong modelState;

	[NonSerialized]
	public int grade;

	[NonSerialized]
	public int flags;

	[NonSerialized]
	public ulong skin;

	[NonSerialized]
	public int customColor;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(GlobalEntityData instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.prefabId = 0u;
			instance.uid = default(NetworkableId);
			instance.pos = default(Vector3);
			instance.rot = default(Vector3);
			instance.modelState = 0uL;
			instance.grade = 0;
			instance.flags = 0;
			instance.skin = 0uL;
			instance.customColor = 0;
			Pool.Free<GlobalEntityData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose GlobalEntityData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(GlobalEntityData instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.prefabId = prefabId;
		instance.uid = uid;
		instance.pos = pos;
		instance.rot = rot;
		instance.modelState = modelState;
		instance.grade = grade;
		instance.flags = flags;
		instance.skin = skin;
		instance.customColor = customColor;
	}

	public GlobalEntityData Copy()
	{
		GlobalEntityData globalEntityData = Pool.Get<GlobalEntityData>();
		CopyTo(globalEntityData);
		return globalEntityData;
	}

	public static GlobalEntityData Deserialize(BufferStream stream)
	{
		GlobalEntityData globalEntityData = Pool.Get<GlobalEntityData>();
		Deserialize(stream, globalEntityData, isDelta: false);
		return globalEntityData;
	}

	public static GlobalEntityData DeserializeLengthDelimited(BufferStream stream)
	{
		GlobalEntityData globalEntityData = Pool.Get<GlobalEntityData>();
		DeserializeLengthDelimited(stream, globalEntityData, isDelta: false);
		return globalEntityData;
	}

	public static GlobalEntityData DeserializeLength(BufferStream stream, int length)
	{
		GlobalEntityData globalEntityData = Pool.Get<GlobalEntityData>();
		DeserializeLength(stream, length, globalEntityData, isDelta: false);
		return globalEntityData;
	}

	public static GlobalEntityData Deserialize(byte[] buffer)
	{
		GlobalEntityData globalEntityData = Pool.Get<GlobalEntityData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, globalEntityData, isDelta: false);
		return globalEntityData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, GlobalEntityData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static GlobalEntityData Deserialize(BufferStream stream, GlobalEntityData instance, bool isDelta)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rot, isDelta);
				continue;
			case 40:
				instance.modelState = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.grade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.skin = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.customColor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static GlobalEntityData DeserializeLengthDelimited(BufferStream stream, GlobalEntityData instance, bool isDelta)
	{
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rot, isDelta);
				continue;
			case 40:
				instance.modelState = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.grade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.skin = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.customColor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static GlobalEntityData DeserializeLength(BufferStream stream, int length, GlobalEntityData instance, bool isDelta)
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rot, isDelta);
				continue;
			case 40:
				instance.modelState = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.grade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.skin = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.customColor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, GlobalEntityData instance, GlobalEntityData previous)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		if (instance.prefabId != previous.prefabId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.prefabId);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		if (instance.pos != previous.pos)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.pos, previous.pos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.rot != previous.rot)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rot, previous.rot);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rot (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.modelState != previous.modelState)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.modelState);
		}
		if (instance.grade != previous.grade)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.grade);
		}
		if (instance.flags != previous.flags)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.skin != previous.skin)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.skin);
		}
		if (instance.customColor != previous.customColor)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.customColor);
		}
	}

	public static void Serialize(BufferStream stream, GlobalEntityData instance)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		if (instance.prefabId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.prefabId);
		}
		if (instance.uid != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		}
		if (instance.pos != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.pos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.rot != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rot);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rot (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.modelState != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.modelState);
		}
		if (instance.grade != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.grade);
		}
		if (instance.flags != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.skin != 0L)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.skin);
		}
		if (instance.customColor != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.customColor);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref uid.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class GlobalEntityCollection : IDisposable, IPooled, IProto<GlobalEntityCollection>, IProto
{
	[NonSerialized]
	public List<GlobalEntityData> entities;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(GlobalEntityCollection instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				if (instance.entities[i] != null)
				{
					instance.entities[i].ResetToPool();
					instance.entities[i] = null;
				}
			}
			List<GlobalEntityData> list = instance.entities;
			Pool.Free<GlobalEntityData>(ref list, false);
			instance.entities = list;
		}
		Pool.Free<GlobalEntityCollection>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose GlobalEntityCollection with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(GlobalEntityCollection instance)
	{
		if (entities != null)
		{
			instance.entities = Pool.Get<List<GlobalEntityData>>();
			for (int i = 0; i < entities.Count; i++)
			{
				GlobalEntityData item = entities[i].Copy();
				instance.entities.Add(item);
			}
		}
		else
		{
			instance.entities = null;
		}
	}

	public GlobalEntityCollection Copy()
	{
		GlobalEntityCollection globalEntityCollection = Pool.Get<GlobalEntityCollection>();
		CopyTo(globalEntityCollection);
		return globalEntityCollection;
	}

	public static GlobalEntityCollection Deserialize(BufferStream stream)
	{
		GlobalEntityCollection globalEntityCollection = Pool.Get<GlobalEntityCollection>();
		Deserialize(stream, globalEntityCollection, isDelta: false);
		return globalEntityCollection;
	}

	public static GlobalEntityCollection DeserializeLengthDelimited(BufferStream stream)
	{
		GlobalEntityCollection globalEntityCollection = Pool.Get<GlobalEntityCollection>();
		DeserializeLengthDelimited(stream, globalEntityCollection, isDelta: false);
		return globalEntityCollection;
	}

	public static GlobalEntityCollection DeserializeLength(BufferStream stream, int length)
	{
		GlobalEntityCollection globalEntityCollection = Pool.Get<GlobalEntityCollection>();
		DeserializeLength(stream, length, globalEntityCollection, isDelta: false);
		return globalEntityCollection;
	}

	public static GlobalEntityCollection Deserialize(byte[] buffer)
	{
		GlobalEntityCollection globalEntityCollection = Pool.Get<GlobalEntityCollection>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, globalEntityCollection, isDelta: false);
		return globalEntityCollection;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, GlobalEntityCollection previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static GlobalEntityCollection Deserialize(BufferStream stream, GlobalEntityCollection instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<GlobalEntityData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entities.Add(GlobalEntityData.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static GlobalEntityCollection DeserializeLengthDelimited(BufferStream stream, GlobalEntityCollection instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<GlobalEntityData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entities.Add(GlobalEntityData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static GlobalEntityCollection DeserializeLength(BufferStream stream, int length, GlobalEntityCollection instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<GlobalEntityData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entities.Add(GlobalEntityData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, GlobalEntityCollection instance, GlobalEntityCollection previous)
	{
		if (instance.entities == null)
		{
			return;
		}
		for (int i = 0; i < instance.entities.Count; i++)
		{
			GlobalEntityData globalEntityData = instance.entities[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			GlobalEntityData.SerializeDelta(stream, globalEntityData, globalEntityData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entities (ProtoBuf.GlobalEntityData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, GlobalEntityCollection instance)
	{
		if (instance.entities == null)
		{
			return;
		}
		for (int i = 0; i < instance.entities.Count; i++)
		{
			GlobalEntityData instance2 = instance.entities[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			GlobalEntityData.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entities (ProtoBuf.GlobalEntityData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entities != null)
		{
			for (int i = 0; i < entities.Count; i++)
			{
				entities[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WorldData : IDisposable, IPooled, IProto<WorldData>, IProto
{
	[NonSerialized]
	public uint size;

	[NonSerialized]
	public List<MapData> maps;

	[NonSerialized]
	public List<PrefabData> prefabs;

	[NonSerialized]
	public List<PathData> paths;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WorldData instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.size = 0u;
		if (instance.maps != null)
		{
			for (int i = 0; i < instance.maps.Count; i++)
			{
				if (instance.maps[i] != null)
				{
					instance.maps[i].ResetToPool();
					instance.maps[i] = null;
				}
			}
			List<MapData> list = instance.maps;
			Pool.Free<MapData>(ref list, false);
			instance.maps = list;
		}
		if (instance.prefabs != null)
		{
			for (int j = 0; j < instance.prefabs.Count; j++)
			{
				if (instance.prefabs[j] != null)
				{
					instance.prefabs[j].ResetToPool();
					instance.prefabs[j] = null;
				}
			}
			List<PrefabData> list2 = instance.prefabs;
			Pool.Free<PrefabData>(ref list2, false);
			instance.prefabs = list2;
		}
		if (instance.paths != null)
		{
			for (int k = 0; k < instance.paths.Count; k++)
			{
				if (instance.paths[k] != null)
				{
					instance.paths[k].ResetToPool();
					instance.paths[k] = null;
				}
			}
			List<PathData> list3 = instance.paths;
			Pool.Free<PathData>(ref list3, false);
			instance.paths = list3;
		}
		Pool.Free<WorldData>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WorldData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WorldData instance)
	{
		instance.size = size;
		if (maps != null)
		{
			instance.maps = Pool.Get<List<MapData>>();
			for (int i = 0; i < maps.Count; i++)
			{
				MapData item = maps[i].Copy();
				instance.maps.Add(item);
			}
		}
		else
		{
			instance.maps = null;
		}
		if (prefabs != null)
		{
			instance.prefabs = Pool.Get<List<PrefabData>>();
			for (int j = 0; j < prefabs.Count; j++)
			{
				PrefabData item2 = prefabs[j].Copy();
				instance.prefabs.Add(item2);
			}
		}
		else
		{
			instance.prefabs = null;
		}
		if (paths != null)
		{
			instance.paths = Pool.Get<List<PathData>>();
			for (int k = 0; k < paths.Count; k++)
			{
				PathData item3 = paths[k].Copy();
				instance.paths.Add(item3);
			}
		}
		else
		{
			instance.paths = null;
		}
	}

	public WorldData Copy()
	{
		WorldData worldData = Pool.Get<WorldData>();
		CopyTo(worldData);
		return worldData;
	}

	public static WorldData Deserialize(BufferStream stream)
	{
		WorldData worldData = Pool.Get<WorldData>();
		Deserialize(stream, worldData, isDelta: false);
		return worldData;
	}

	public static WorldData DeserializeLengthDelimited(BufferStream stream)
	{
		WorldData worldData = Pool.Get<WorldData>();
		DeserializeLengthDelimited(stream, worldData, isDelta: false);
		return worldData;
	}

	public static WorldData DeserializeLength(BufferStream stream, int length)
	{
		WorldData worldData = Pool.Get<WorldData>();
		DeserializeLength(stream, length, worldData, isDelta: false);
		return worldData;
	}

	public static WorldData Deserialize(byte[] buffer)
	{
		WorldData worldData = Pool.Get<WorldData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, worldData, isDelta: false);
		return worldData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WorldData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WorldData Deserialize(BufferStream stream, WorldData instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.maps == null)
			{
				instance.maps = Pool.Get<List<MapData>>();
			}
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.size = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.maps.Add(MapData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WorldData DeserializeLengthDelimited(BufferStream stream, WorldData instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.maps == null)
			{
				instance.maps = Pool.Get<List<MapData>>();
			}
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.size = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.maps.Add(MapData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WorldData DeserializeLength(BufferStream stream, int length, WorldData instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.maps == null)
			{
				instance.maps = Pool.Get<List<MapData>>();
			}
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.size = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.maps.Add(MapData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WorldData instance, WorldData previous)
	{
		if (instance.size != previous.size)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.size);
		}
		if (instance.maps != null)
		{
			for (int i = 0; i < instance.maps.Count; i++)
			{
				MapData mapData = instance.maps[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MapData.SerializeDelta(stream, mapData, mapData);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.prefabs != null)
		{
			for (int j = 0; j < instance.prefabs.Count; j++)
			{
				PrefabData prefabData = instance.prefabs[j];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				PrefabData.SerializeDelta(stream, prefabData, prefabData);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.paths == null)
		{
			return;
		}
		for (int k = 0; k < instance.paths.Count; k++)
		{
			PathData pathData = instance.paths[k];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			PathData.SerializeDelta(stream, pathData, pathData);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, WorldData instance)
	{
		if (instance.size != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.size);
		}
		if (instance.maps != null)
		{
			for (int i = 0; i < instance.maps.Count; i++)
			{
				MapData instance2 = instance.maps[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MapData.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.prefabs != null)
		{
			for (int j = 0; j < instance.prefabs.Count; j++)
			{
				PrefabData instance3 = instance.prefabs[j];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				PrefabData.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.paths == null)
		{
			return;
		}
		for (int k = 0; k < instance.paths.Count; k++)
		{
			PathData instance4 = instance.paths[k];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			PathData.Serialize(stream, instance4);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (maps != null)
		{
			for (int i = 0; i < maps.Count; i++)
			{
				maps[i]?.InspectUids(action);
			}
		}
		if (prefabs != null)
		{
			for (int j = 0; j < prefabs.Count; j++)
			{
				prefabs[j]?.InspectUids(action);
			}
		}
		if (paths != null)
		{
			for (int k = 0; k < paths.Count; k++)
			{
				paths[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MapData : IDisposable, IPooled, IProto<MapData>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public byte[] data;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MapData instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.data = null;
			Pool.Free<MapData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MapData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MapData instance)
	{
		instance.name = name;
		if (data == null)
		{
			instance.data = null;
			return;
		}
		instance.data = new byte[data.Length];
		Array.Copy(data, instance.data, instance.data.Length);
	}

	public MapData Copy()
	{
		MapData mapData = Pool.Get<MapData>();
		CopyTo(mapData);
		return mapData;
	}

	public static MapData Deserialize(BufferStream stream)
	{
		MapData mapData = Pool.Get<MapData>();
		Deserialize(stream, mapData, isDelta: false);
		return mapData;
	}

	public static MapData DeserializeLengthDelimited(BufferStream stream)
	{
		MapData mapData = Pool.Get<MapData>();
		DeserializeLengthDelimited(stream, mapData, isDelta: false);
		return mapData;
	}

	public static MapData DeserializeLength(BufferStream stream, int length)
	{
		MapData mapData = Pool.Get<MapData>();
		DeserializeLength(stream, length, mapData, isDelta: false);
		return mapData;
	}

	public static MapData Deserialize(byte[] buffer)
	{
		MapData mapData = Pool.Get<MapData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mapData, isDelta: false);
		return mapData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MapData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MapData Deserialize(BufferStream stream, MapData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MapData DeserializeLengthDelimited(BufferStream stream, MapData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MapData DeserializeLength(BufferStream stream, int length, MapData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MapData instance, MapData previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteBytes(stream, instance.data);
	}

	public static void Serialize(BufferStream stream, MapData instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteBytes(stream, instance.data);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PrefabData : IDisposable, IPooled, IProto<PrefabData>, IProto
{
	[NonSerialized]
	public string category;

	[NonSerialized]
	public uint id;

	[NonSerialized]
	public VectorData position;

	[NonSerialized]
	public VectorData rotation;

	[NonSerialized]
	public VectorData scale;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PrefabData instance)
	{
		if (instance.ShouldPool)
		{
			instance.category = string.Empty;
			instance.id = 0u;
			instance.position = default(VectorData);
			instance.rotation = default(VectorData);
			instance.scale = default(VectorData);
			Pool.Free<PrefabData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PrefabData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PrefabData instance)
	{
		instance.category = category;
		instance.id = id;
		instance.position = position;
		instance.rotation = rotation;
		instance.scale = scale;
	}

	public PrefabData Copy()
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		CopyTo(prefabData);
		return prefabData;
	}

	public static PrefabData Deserialize(BufferStream stream)
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		Deserialize(stream, prefabData, isDelta: false);
		return prefabData;
	}

	public static PrefabData DeserializeLengthDelimited(BufferStream stream)
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		DeserializeLengthDelimited(stream, prefabData, isDelta: false);
		return prefabData;
	}

	public static PrefabData DeserializeLength(BufferStream stream, int length)
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		DeserializeLength(stream, length, prefabData, isDelta: false);
		return prefabData;
	}

	public static PrefabData Deserialize(byte[] buffer)
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, prefabData, isDelta: false);
		return prefabData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PrefabData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PrefabData Deserialize(BufferStream stream, PrefabData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.category = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				VectorData.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				VectorData.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				VectorData.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PrefabData DeserializeLengthDelimited(BufferStream stream, PrefabData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.category = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				VectorData.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				VectorData.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				VectorData.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PrefabData DeserializeLength(BufferStream stream, int length, PrefabData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.category = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				VectorData.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				VectorData.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				VectorData.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PrefabData instance, PrefabData previous)
	{
		if (instance.category != previous.category)
		{
			if (instance.category == null)
			{
				throw new ArgumentNullException("category", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.category);
		}
		if (instance.id != previous.id)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int num = stream.Position;
		VectorData.SerializeDelta(stream, instance.position, previous.position);
		int num2 = stream.Position - num;
		if (num2 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (ProtoBuf.VectorData)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num2, span, 0);
		stream.WriteByte(34);
		BufferStream.RangeHandle range2 = stream.GetRange(1);
		int num3 = stream.Position;
		VectorData.SerializeDelta(stream, instance.rotation, previous.rotation);
		int num4 = stream.Position - num3;
		if (num4 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (ProtoBuf.VectorData)");
		}
		Span<byte> span2 = range2.GetSpan();
		ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		stream.WriteByte(42);
		BufferStream.RangeHandle range3 = stream.GetRange(1);
		int num5 = stream.Position;
		VectorData.SerializeDelta(stream, instance.scale, previous.scale);
		int num6 = stream.Position - num5;
		if (num6 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (ProtoBuf.VectorData)");
		}
		Span<byte> span3 = range3.GetSpan();
		ProtocolParser.WriteUInt32((uint)num6, span3, 0);
	}

	public static void Serialize(BufferStream stream, PrefabData instance)
	{
		if (instance.category == null)
		{
			throw new ArgumentNullException("category", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.category);
		if (instance.id != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		if (instance.position != default(VectorData))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			VectorData.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != default(VectorData))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			VectorData.Serialize(stream, instance.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (ProtoBuf.VectorData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.scale != default(VectorData))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			VectorData.Serialize(stream, instance.scale);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (ProtoBuf.VectorData)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		position.InspectUids(action);
		rotation.InspectUids(action);
		scale.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PathData : IDisposable, IPooled, IProto<PathData>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public bool spline;

	[NonSerialized]
	public bool start;

	[NonSerialized]
	public bool end;

	[NonSerialized]
	public float width;

	[NonSerialized]
	public float innerPadding;

	[NonSerialized]
	public float outerPadding;

	[NonSerialized]
	public float innerFade;

	[NonSerialized]
	public float outerFade;

	[NonSerialized]
	public float randomScale;

	[NonSerialized]
	public float meshOffset;

	[NonSerialized]
	public float terrainOffset;

	[NonSerialized]
	public int splat;

	[NonSerialized]
	public int topology;

	[NonSerialized]
	public List<VectorData> nodes;

	[NonSerialized]
	public int hierarchy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PathData instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.spline = false;
			instance.start = false;
			instance.end = false;
			instance.width = 0f;
			instance.innerPadding = 0f;
			instance.outerPadding = 0f;
			instance.innerFade = 0f;
			instance.outerFade = 0f;
			instance.randomScale = 0f;
			instance.meshOffset = 0f;
			instance.terrainOffset = 0f;
			instance.splat = 0;
			instance.topology = 0;
			if (instance.nodes != null)
			{
				List<VectorData> list = instance.nodes;
				Pool.FreeUnmanaged<VectorData>(ref list);
				instance.nodes = list;
			}
			instance.hierarchy = 0;
			Pool.Free<PathData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PathData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PathData instance)
	{
		instance.name = name;
		instance.spline = spline;
		instance.start = start;
		instance.end = end;
		instance.width = width;
		instance.innerPadding = innerPadding;
		instance.outerPadding = outerPadding;
		instance.innerFade = innerFade;
		instance.outerFade = outerFade;
		instance.randomScale = randomScale;
		instance.meshOffset = meshOffset;
		instance.terrainOffset = terrainOffset;
		instance.splat = splat;
		instance.topology = topology;
		if (nodes != null)
		{
			instance.nodes = Pool.Get<List<VectorData>>();
			for (int i = 0; i < nodes.Count; i++)
			{
				VectorData item = nodes[i];
				instance.nodes.Add(item);
			}
		}
		else
		{
			instance.nodes = null;
		}
		instance.hierarchy = hierarchy;
	}

	public PathData Copy()
	{
		PathData pathData = Pool.Get<PathData>();
		CopyTo(pathData);
		return pathData;
	}

	public static PathData Deserialize(BufferStream stream)
	{
		PathData pathData = Pool.Get<PathData>();
		Deserialize(stream, pathData, isDelta: false);
		return pathData;
	}

	public static PathData DeserializeLengthDelimited(BufferStream stream)
	{
		PathData pathData = Pool.Get<PathData>();
		DeserializeLengthDelimited(stream, pathData, isDelta: false);
		return pathData;
	}

	public static PathData DeserializeLength(BufferStream stream, int length)
	{
		PathData pathData = Pool.Get<PathData>();
		DeserializeLength(stream, length, pathData, isDelta: false);
		return pathData;
	}

	public static PathData Deserialize(byte[] buffer)
	{
		PathData pathData = Pool.Get<PathData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pathData, isDelta: false);
		return pathData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PathData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PathData Deserialize(BufferStream stream, PathData instance, bool isDelta)
	{
		if (!isDelta && instance.nodes == null)
		{
			instance.nodes = Pool.Get<List<VectorData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.spline = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.start = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.end = ProtocolParser.ReadBool(stream);
				continue;
			case 45:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.innerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.outerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.innerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.outerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.randomScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.meshOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.terrainOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 104:
				instance.splat = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.topology = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.nodes.Add(instance2);
				continue;
			}
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.hierarchy = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static PathData DeserializeLengthDelimited(BufferStream stream, PathData instance, bool isDelta)
	{
		if (!isDelta && instance.nodes == null)
		{
			instance.nodes = Pool.Get<List<VectorData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.spline = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.start = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.end = ProtocolParser.ReadBool(stream);
				continue;
			case 45:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.innerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.outerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.innerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.outerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.randomScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.meshOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.terrainOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 104:
				instance.splat = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.topology = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.nodes.Add(instance2);
				continue;
			}
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.hierarchy = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PathData DeserializeLength(BufferStream stream, int length, PathData instance, bool isDelta)
	{
		if (!isDelta && instance.nodes == null)
		{
			instance.nodes = Pool.Get<List<VectorData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.spline = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.start = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.end = ProtocolParser.ReadBool(stream);
				continue;
			case 45:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.innerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.outerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.innerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.outerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.randomScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.meshOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.terrainOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 104:
				instance.splat = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.topology = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.nodes.Add(instance2);
				continue;
			}
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.hierarchy = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PathData instance, PathData previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.spline);
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.start);
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.end);
		if (instance.width != previous.width)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.width);
		}
		if (instance.innerPadding != previous.innerPadding)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.innerPadding);
		}
		if (instance.outerPadding != previous.outerPadding)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.outerPadding);
		}
		if (instance.innerFade != previous.innerFade)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.innerFade);
		}
		if (instance.outerFade != previous.outerFade)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.outerFade);
		}
		if (instance.randomScale != previous.randomScale)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.randomScale);
		}
		if (instance.meshOffset != previous.meshOffset)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.meshOffset);
		}
		if (instance.terrainOffset != previous.terrainOffset)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.terrainOffset);
		}
		if (instance.splat != previous.splat)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.splat);
		}
		if (instance.topology != previous.topology)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.topology);
		}
		if (instance.nodes != null)
		{
			for (int i = 0; i < instance.nodes.Count; i++)
			{
				VectorData vectorData = instance.nodes[i];
				stream.WriteByte(122);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VectorData.SerializeDelta(stream, vectorData, vectorData);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field nodes (ProtoBuf.VectorData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.hierarchy != previous.hierarchy)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.hierarchy);
		}
	}

	public static void Serialize(BufferStream stream, PathData instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.spline)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.spline);
		}
		if (instance.start)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.start);
		}
		if (instance.end)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.end);
		}
		if (instance.width != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.width);
		}
		if (instance.innerPadding != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.innerPadding);
		}
		if (instance.outerPadding != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.outerPadding);
		}
		if (instance.innerFade != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.innerFade);
		}
		if (instance.outerFade != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.outerFade);
		}
		if (instance.randomScale != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.randomScale);
		}
		if (instance.meshOffset != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.meshOffset);
		}
		if (instance.terrainOffset != 0f)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.terrainOffset);
		}
		if (instance.splat != 0)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.splat);
		}
		if (instance.topology != 0)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.topology);
		}
		if (instance.nodes != null)
		{
			for (int i = 0; i < instance.nodes.Count; i++)
			{
				VectorData instance2 = instance.nodes[i];
				stream.WriteByte(122);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VectorData.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field nodes (ProtoBuf.VectorData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.hierarchy != 0)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.hierarchy);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (nodes != null)
		{
			for (int i = 0; i < nodes.Count; i++)
			{
				nodes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public struct VectorData : IProto<VectorData>, IProto, IEquatable<VectorData>
{
	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public float z;

	public static void ResetToPool(VectorData instance)
	{
		instance.x = 0f;
		instance.y = 0f;
		instance.z = 0f;
	}

	public void CopyTo(VectorData instance)
	{
		instance.x = x;
		instance.y = y;
		instance.z = z;
	}

	public VectorData Copy()
	{
		VectorData vectorData = default(VectorData);
		CopyTo(vectorData);
		return vectorData;
	}

	public static VectorData Deserialize(BufferStream stream)
	{
		VectorData instance = default(VectorData);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static VectorData DeserializeLengthDelimited(BufferStream stream)
	{
		VectorData instance = default(VectorData);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static VectorData DeserializeLength(BufferStream stream, int length)
	{
		VectorData instance = default(VectorData);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static VectorData Deserialize(byte[] buffer)
	{
		VectorData instance = default(VectorData);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, VectorData previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static VectorData Deserialize(BufferStream stream, ref VectorData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VectorData DeserializeLengthDelimited(BufferStream stream, ref VectorData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VectorData DeserializeLength(BufferStream stream, int length, ref VectorData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VectorData instance, VectorData previous)
	{
		if (instance.x != previous.x)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != previous.z)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
	}

	public static void Serialize(BufferStream stream, VectorData instance)
	{
		if (instance.x != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}

	public VectorData(float x, float y, float z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public static implicit operator VectorData(Vector3 v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new VectorData(v.x, v.y, v.z);
	}

	public static implicit operator VectorData(Quaternion q)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return ((Quaternion)(ref q)).eulerAngles;
	}

	public static implicit operator Vector3(VectorData v)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(v.x, v.y, v.z);
	}

	public static implicit operator Quaternion(VectorData v)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.Euler((Vector3)v);
	}

	public bool Equals(VectorData other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is VectorData)
		{
			return Equals((VectorData)obj);
		}
		return false;
	}

	public static bool operator ==(VectorData a, VectorData b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(VectorData a, VectorData b)
	{
		return !a.Equals(b);
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}
}


public enum AppEntityType
{
	Switch = 1,
	Alarm,
	StorageMonitor
}


public enum AppMarkerType
{
	Undefined,
	Player,
	Explosion,
	VendingMachine,
	CH47,
	CargoShip,
	Crate,
	GenericRadius,
	PatrolHelicopter,
	TravellingVendor
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class Packet : IDisposable, IPooled, IProto<Packet>, IProto
{
	[NonSerialized]
	public uint protocol;

	[NonSerialized]
	public int sourceZone;

	[NonSerialized]
	public Request request;

	[NonSerialized]
	public Response response;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Packet instance)
	{
		if (instance.ShouldPool)
		{
			instance.protocol = 0u;
			instance.sourceZone = 0;
			if (instance.request != null)
			{
				instance.request.ResetToPool();
				instance.request = null;
			}
			if (instance.response != null)
			{
				instance.response.ResetToPool();
				instance.response = null;
			}
			Pool.Free<Packet>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Packet with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Packet instance)
	{
		instance.protocol = protocol;
		instance.sourceZone = sourceZone;
		if (request != null)
		{
			if (instance.request == null)
			{
				instance.request = request.Copy();
			}
			else
			{
				request.CopyTo(instance.request);
			}
		}
		else
		{
			instance.request = null;
		}
		if (response != null)
		{
			if (instance.response == null)
			{
				instance.response = response.Copy();
			}
			else
			{
				response.CopyTo(instance.response);
			}
		}
		else
		{
			instance.response = null;
		}
	}

	public Packet Copy()
	{
		Packet packet = Pool.Get<Packet>();
		CopyTo(packet);
		return packet;
	}

	public static Packet Deserialize(BufferStream stream)
	{
		Packet packet = Pool.Get<Packet>();
		Deserialize(stream, packet, isDelta: false);
		return packet;
	}

	public static Packet DeserializeLengthDelimited(BufferStream stream)
	{
		Packet packet = Pool.Get<Packet>();
		DeserializeLengthDelimited(stream, packet, isDelta: false);
		return packet;
	}

	public static Packet DeserializeLength(BufferStream stream, int length)
	{
		Packet packet = Pool.Get<Packet>();
		DeserializeLength(stream, length, packet, isDelta: false);
		return packet;
	}

	public static Packet Deserialize(byte[] buffer)
	{
		Packet packet = Pool.Get<Packet>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, packet, isDelta: false);
		return packet;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Packet previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Packet Deserialize(BufferStream stream, Packet instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.protocol = ProtocolParser.ReadUInt32(stream);
				break;
			case 16:
				instance.sourceZone = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.request == null)
				{
					instance.request = Request.DeserializeLengthDelimited(stream);
				}
				else
				{
					Request.DeserializeLengthDelimited(stream, instance.request, isDelta);
				}
				break;
			case 34:
				if (instance.response == null)
				{
					instance.response = Response.DeserializeLengthDelimited(stream);
				}
				else
				{
					Response.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Packet DeserializeLengthDelimited(BufferStream stream, Packet instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.protocol = ProtocolParser.ReadUInt32(stream);
				break;
			case 16:
				instance.sourceZone = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.request == null)
				{
					instance.request = Request.DeserializeLengthDelimited(stream);
				}
				else
				{
					Request.DeserializeLengthDelimited(stream, instance.request, isDelta);
				}
				break;
			case 34:
				if (instance.response == null)
				{
					instance.response = Response.DeserializeLengthDelimited(stream);
				}
				else
				{
					Response.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Packet DeserializeLength(BufferStream stream, int length, Packet instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.protocol = ProtocolParser.ReadUInt32(stream);
				break;
			case 16:
				instance.sourceZone = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.request == null)
				{
					instance.request = Request.DeserializeLengthDelimited(stream);
				}
				else
				{
					Request.DeserializeLengthDelimited(stream, instance.request, isDelta);
				}
				break;
			case 34:
				if (instance.response == null)
				{
					instance.response = Response.DeserializeLengthDelimited(stream);
				}
				else
				{
					Response.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Packet instance, Packet previous)
	{
		if (instance.protocol != previous.protocol)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.protocol);
		}
		if (instance.sourceZone != previous.sourceZone)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sourceZone);
		}
		if (instance.request != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Request.SerializeDelta(stream, instance.request, previous.request);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.response == null)
		{
			return;
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		Response.SerializeDelta(stream, instance.response, previous.response);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Packet instance)
	{
		if (instance.protocol != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.protocol);
		}
		if (instance.sourceZone != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sourceZone);
		}
		if (instance.request != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Request.Serialize(stream, instance.request);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.response == null)
		{
			return;
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		Response.Serialize(stream, instance.response);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		request?.InspectUids(action);
		response?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class Request : IDisposable, IPooled, IProto<Request>, IProto
{
	[NonSerialized]
	public bool isFireAndForget;

	[NonSerialized]
	public TransferRequest transfer;

	[NonSerialized]
	public PingRequest ping;

	[NonSerialized]
	public SpawnOptionsRequest spawnOptions;

	[NonSerialized]
	public SleepingBagRespawnRequest respawnAtBag;

	[NonSerialized]
	public SleepingBagDestroyRequest destroyBag;

	[NonSerialized]
	public FerryStatusRequest ferryStatus;

	[NonSerialized]
	public FerryRetireRequest ferryRetire;

	[NonSerialized]
	public FerryUpdateScheduleRequest ferryUpdateSchedule;

	[NonSerialized]
	public ClanChatBatchRequest clanChatBatch;

	[NonSerialized]
	public PlayerManifestRequest playerManifest;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Request instance)
	{
		if (instance.ShouldPool)
		{
			instance.isFireAndForget = false;
			if (instance.transfer != null)
			{
				instance.transfer.ResetToPool();
				instance.transfer = null;
			}
			if (instance.ping != null)
			{
				instance.ping.ResetToPool();
				instance.ping = null;
			}
			if (instance.spawnOptions != null)
			{
				instance.spawnOptions.ResetToPool();
				instance.spawnOptions = null;
			}
			if (instance.respawnAtBag != null)
			{
				instance.respawnAtBag.ResetToPool();
				instance.respawnAtBag = null;
			}
			if (instance.destroyBag != null)
			{
				instance.destroyBag.ResetToPool();
				instance.destroyBag = null;
			}
			if (instance.ferryStatus != null)
			{
				instance.ferryStatus.ResetToPool();
				instance.ferryStatus = null;
			}
			if (instance.ferryRetire != null)
			{
				instance.ferryRetire.ResetToPool();
				instance.ferryRetire = null;
			}
			if (instance.ferryUpdateSchedule != null)
			{
				instance.ferryUpdateSchedule.ResetToPool();
				instance.ferryUpdateSchedule = null;
			}
			if (instance.clanChatBatch != null)
			{
				instance.clanChatBatch.ResetToPool();
				instance.clanChatBatch = null;
			}
			if (instance.playerManifest != null)
			{
				instance.playerManifest.ResetToPool();
				instance.playerManifest = null;
			}
			Pool.Free<Request>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Request with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Request instance)
	{
		instance.isFireAndForget = isFireAndForget;
		if (transfer != null)
		{
			if (instance.transfer == null)
			{
				instance.transfer = transfer.Copy();
			}
			else
			{
				transfer.CopyTo(instance.transfer);
			}
		}
		else
		{
			instance.transfer = null;
		}
		if (ping != null)
		{
			if (instance.ping == null)
			{
				instance.ping = ping.Copy();
			}
			else
			{
				ping.CopyTo(instance.ping);
			}
		}
		else
		{
			instance.ping = null;
		}
		if (spawnOptions != null)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = spawnOptions.Copy();
			}
			else
			{
				spawnOptions.CopyTo(instance.spawnOptions);
			}
		}
		else
		{
			instance.spawnOptions = null;
		}
		if (respawnAtBag != null)
		{
			if (instance.respawnAtBag == null)
			{
				instance.respawnAtBag = respawnAtBag.Copy();
			}
			else
			{
				respawnAtBag.CopyTo(instance.respawnAtBag);
			}
		}
		else
		{
			instance.respawnAtBag = null;
		}
		if (destroyBag != null)
		{
			if (instance.destroyBag == null)
			{
				instance.destroyBag = destroyBag.Copy();
			}
			else
			{
				destroyBag.CopyTo(instance.destroyBag);
			}
		}
		else
		{
			instance.destroyBag = null;
		}
		if (ferryStatus != null)
		{
			if (instance.ferryStatus == null)
			{
				instance.ferryStatus = ferryStatus.Copy();
			}
			else
			{
				ferryStatus.CopyTo(instance.ferryStatus);
			}
		}
		else
		{
			instance.ferryStatus = null;
		}
		if (ferryRetire != null)
		{
			if (instance.ferryRetire == null)
			{
				instance.ferryRetire = ferryRetire.Copy();
			}
			else
			{
				ferryRetire.CopyTo(instance.ferryRetire);
			}
		}
		else
		{
			instance.ferryRetire = null;
		}
		if (ferryUpdateSchedule != null)
		{
			if (instance.ferryUpdateSchedule == null)
			{
				instance.ferryUpdateSchedule = ferryUpdateSchedule.Copy();
			}
			else
			{
				ferryUpdateSchedule.CopyTo(instance.ferryUpdateSchedule);
			}
		}
		else
		{
			instance.ferryUpdateSchedule = null;
		}
		if (clanChatBatch != null)
		{
			if (instance.clanChatBatch == null)
			{
				instance.clanChatBatch = clanChatBatch.Copy();
			}
			else
			{
				clanChatBatch.CopyTo(instance.clanChatBatch);
			}
		}
		else
		{
			instance.clanChatBatch = null;
		}
		if (playerManifest != null)
		{
			if (instance.playerManifest == null)
			{
				instance.playerManifest = playerManifest.Copy();
			}
			else
			{
				playerManifest.CopyTo(instance.playerManifest);
			}
		}
		else
		{
			instance.playerManifest = null;
		}
	}

	public Request Copy()
	{
		Request request = Pool.Get<Request>();
		CopyTo(request);
		return request;
	}

	public static Request Deserialize(BufferStream stream)
	{
		Request request = Pool.Get<Request>();
		Deserialize(stream, request, isDelta: false);
		return request;
	}

	public static Request DeserializeLengthDelimited(BufferStream stream)
	{
		Request request = Pool.Get<Request>();
		DeserializeLengthDelimited(stream, request, isDelta: false);
		return request;
	}

	public static Request DeserializeLength(BufferStream stream, int length)
	{
		Request request = Pool.Get<Request>();
		DeserializeLength(stream, length, request, isDelta: false);
		return request;
	}

	public static Request Deserialize(byte[] buffer)
	{
		Request request = Pool.Get<Request>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, request, isDelta: false);
		return request;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Request previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Request Deserialize(BufferStream stream, Request instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.isFireAndForget = ProtocolParser.ReadBool(stream);
				break;
			case 18:
				if (instance.transfer == null)
				{
					instance.transfer = TransferRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					TransferRequest.DeserializeLengthDelimited(stream, instance.transfer, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingRequest.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsRequest.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.respawnAtBag == null)
				{
					instance.respawnAtBag = SleepingBagRespawnRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagRespawnRequest.DeserializeLengthDelimited(stream, instance.respawnAtBag, isDelta);
				}
				break;
			case 50:
				if (instance.destroyBag == null)
				{
					instance.destroyBag = SleepingBagDestroyRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagDestroyRequest.DeserializeLengthDelimited(stream, instance.destroyBag, isDelta);
				}
				break;
			case 58:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusRequest.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			case 66:
				if (instance.ferryRetire == null)
				{
					instance.ferryRetire = FerryRetireRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryRetireRequest.DeserializeLengthDelimited(stream, instance.ferryRetire, isDelta);
				}
				break;
			case 74:
				if (instance.ferryUpdateSchedule == null)
				{
					instance.ferryUpdateSchedule = FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream, instance.ferryUpdateSchedule, isDelta);
				}
				break;
			case 82:
				if (instance.clanChatBatch == null)
				{
					instance.clanChatBatch = ClanChatBatchRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanChatBatchRequest.DeserializeLengthDelimited(stream, instance.clanChatBatch, isDelta);
				}
				break;
			case 90:
				if (instance.playerManifest == null)
				{
					instance.playerManifest = PlayerManifestRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerManifestRequest.DeserializeLengthDelimited(stream, instance.playerManifest, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Request DeserializeLengthDelimited(BufferStream stream, Request instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.isFireAndForget = ProtocolParser.ReadBool(stream);
				break;
			case 18:
				if (instance.transfer == null)
				{
					instance.transfer = TransferRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					TransferRequest.DeserializeLengthDelimited(stream, instance.transfer, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingRequest.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsRequest.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.respawnAtBag == null)
				{
					instance.respawnAtBag = SleepingBagRespawnRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagRespawnRequest.DeserializeLengthDelimited(stream, instance.respawnAtBag, isDelta);
				}
				break;
			case 50:
				if (instance.destroyBag == null)
				{
					instance.destroyBag = SleepingBagDestroyRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagDestroyRequest.DeserializeLengthDelimited(stream, instance.destroyBag, isDelta);
				}
				break;
			case 58:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusRequest.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			case 66:
				if (instance.ferryRetire == null)
				{
					instance.ferryRetire = FerryRetireRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryRetireRequest.DeserializeLengthDelimited(stream, instance.ferryRetire, isDelta);
				}
				break;
			case 74:
				if (instance.ferryUpdateSchedule == null)
				{
					instance.ferryUpdateSchedule = FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream, instance.ferryUpdateSchedule, isDelta);
				}
				break;
			case 82:
				if (instance.clanChatBatch == null)
				{
					instance.clanChatBatch = ClanChatBatchRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanChatBatchRequest.DeserializeLengthDelimited(stream, instance.clanChatBatch, isDelta);
				}
				break;
			case 90:
				if (instance.playerManifest == null)
				{
					instance.playerManifest = PlayerManifestRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerManifestRequest.DeserializeLengthDelimited(stream, instance.playerManifest, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Request DeserializeLength(BufferStream stream, int length, Request instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.isFireAndForget = ProtocolParser.ReadBool(stream);
				break;
			case 18:
				if (instance.transfer == null)
				{
					instance.transfer = TransferRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					TransferRequest.DeserializeLengthDelimited(stream, instance.transfer, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingRequest.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsRequest.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.respawnAtBag == null)
				{
					instance.respawnAtBag = SleepingBagRespawnRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagRespawnRequest.DeserializeLengthDelimited(stream, instance.respawnAtBag, isDelta);
				}
				break;
			case 50:
				if (instance.destroyBag == null)
				{
					instance.destroyBag = SleepingBagDestroyRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagDestroyRequest.DeserializeLengthDelimited(stream, instance.destroyBag, isDelta);
				}
				break;
			case 58:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusRequest.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			case 66:
				if (instance.ferryRetire == null)
				{
					instance.ferryRetire = FerryRetireRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryRetireRequest.DeserializeLengthDelimited(stream, instance.ferryRetire, isDelta);
				}
				break;
			case 74:
				if (instance.ferryUpdateSchedule == null)
				{
					instance.ferryUpdateSchedule = FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream, instance.ferryUpdateSchedule, isDelta);
				}
				break;
			case 82:
				if (instance.clanChatBatch == null)
				{
					instance.clanChatBatch = ClanChatBatchRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanChatBatchRequest.DeserializeLengthDelimited(stream, instance.clanChatBatch, isDelta);
				}
				break;
			case 90:
				if (instance.playerManifest == null)
				{
					instance.playerManifest = PlayerManifestRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerManifestRequest.DeserializeLengthDelimited(stream, instance.playerManifest, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Request instance, Request previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.isFireAndForget);
		if (instance.transfer != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			TransferRequest.SerializeDelta(stream, instance.transfer, previous.transfer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.ping != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PingRequest.SerializeDelta(stream, instance.ping, previous.ping);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ping (ProtoBuf.Nexus.PingRequest)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.spawnOptions != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			SpawnOptionsRequest.SerializeDelta(stream, instance.spawnOptions, previous.spawnOptions);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spawnOptions (ProtoBuf.Nexus.SpawnOptionsRequest)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.respawnAtBag != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			SleepingBagRespawnRequest.SerializeDelta(stream, instance.respawnAtBag, previous.respawnAtBag);
			int val2 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.destroyBag != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			SleepingBagDestroyRequest.SerializeDelta(stream, instance.destroyBag, previous.destroyBag);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destroyBag (ProtoBuf.Nexus.SleepingBagDestroyRequest)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.ferryStatus != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			FerryStatusRequest.SerializeDelta(stream, instance.ferryStatus, previous.ferryStatus);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ferryStatus (ProtoBuf.Nexus.FerryStatusRequest)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.ferryRetire != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			FerryRetireRequest.SerializeDelta(stream, instance.ferryRetire, previous.ferryRetire);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ferryRetire (ProtoBuf.Nexus.FerryRetireRequest)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.ferryUpdateSchedule != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range8 = stream.GetRange(5);
			int position8 = stream.Position;
			FerryUpdateScheduleRequest.SerializeDelta(stream, instance.ferryUpdateSchedule, previous.ferryUpdateSchedule);
			int val3 = stream.Position - position8;
			Span<byte> span8 = range8.GetSpan();
			int num8 = ProtocolParser.WriteUInt32((uint)val3, span8, 0);
			if (num8 < 5)
			{
				span8[num8 - 1] |= 128;
				while (num8 < 4)
				{
					span8[num8++] = 128;
				}
				span8[4] = 0;
			}
		}
		if (instance.clanChatBatch != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range9 = stream.GetRange(5);
			int position9 = stream.Position;
			ClanChatBatchRequest.SerializeDelta(stream, instance.clanChatBatch, previous.clanChatBatch);
			int val4 = stream.Position - position9;
			Span<byte> span9 = range9.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)val4, span9, 0);
			if (num9 < 5)
			{
				span9[num9 - 1] |= 128;
				while (num9 < 4)
				{
					span9[num9++] = 128;
				}
				span9[4] = 0;
			}
		}
		if (instance.playerManifest == null)
		{
			return;
		}
		stream.WriteByte(90);
		BufferStream.RangeHandle range10 = stream.GetRange(3);
		int position10 = stream.Position;
		PlayerManifestRequest.SerializeDelta(stream, instance.playerManifest, previous.playerManifest);
		int num10 = stream.Position - position10;
		if (num10 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerManifest (ProtoBuf.Nexus.PlayerManifestRequest)");
		}
		Span<byte> span10 = range10.GetSpan();
		int num11 = ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		if (num11 < 3)
		{
			span10[num11 - 1] |= 128;
			while (num11 < 2)
			{
				span10[num11++] = 128;
			}
			span10[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Request instance)
	{
		if (instance.isFireAndForget)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.isFireAndForget);
		}
		if (instance.transfer != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			TransferRequest.Serialize(stream, instance.transfer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.ping != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PingRequest.Serialize(stream, instance.ping);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ping (ProtoBuf.Nexus.PingRequest)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.spawnOptions != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			SpawnOptionsRequest.Serialize(stream, instance.spawnOptions);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spawnOptions (ProtoBuf.Nexus.SpawnOptionsRequest)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.respawnAtBag != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			SleepingBagRespawnRequest.Serialize(stream, instance.respawnAtBag);
			int val2 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.destroyBag != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			SleepingBagDestroyRequest.Serialize(stream, instance.destroyBag);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destroyBag (ProtoBuf.Nexus.SleepingBagDestroyRequest)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.ferryStatus != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			FerryStatusRequest.Serialize(stream, instance.ferryStatus);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ferryStatus (ProtoBuf.Nexus.FerryStatusRequest)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.ferryRetire != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			FerryRetireRequest.Serialize(stream, instance.ferryRetire);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ferryRetire (ProtoBuf.Nexus.FerryRetireRequest)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.ferryUpdateSchedule != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range8 = stream.GetRange(5);
			int position8 = stream.Position;
			FerryUpdateScheduleRequest.Serialize(stream, instance.ferryUpdateSchedule);
			int val3 = stream.Position - position8;
			Span<byte> span8 = range8.GetSpan();
			int num8 = ProtocolParser.WriteUInt32((uint)val3, span8, 0);
			if (num8 < 5)
			{
				span8[num8 - 1] |= 128;
				while (num8 < 4)
				{
					span8[num8++] = 128;
				}
				span8[4] = 0;
			}
		}
		if (instance.clanChatBatch != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range9 = stream.GetRange(5);
			int position9 = stream.Position;
			ClanChatBatchRequest.Serialize(stream, instance.clanChatBatch);
			int val4 = stream.Position - position9;
			Span<byte> span9 = range9.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)val4, span9, 0);
			if (num9 < 5)
			{
				span9[num9 - 1] |= 128;
				while (num9 < 4)
				{
					span9[num9++] = 128;
				}
				span9[4] = 0;
			}
		}
		if (instance.playerManifest == null)
		{
			return;
		}
		stream.WriteByte(90);
		BufferStream.RangeHandle range10 = stream.GetRange(3);
		int position10 = stream.Position;
		PlayerManifestRequest.Serialize(stream, instance.playerManifest);
		int num10 = stream.Position - position10;
		if (num10 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerManifest (ProtoBuf.Nexus.PlayerManifestRequest)");
		}
		Span<byte> span10 = range10.GetSpan();
		int num11 = ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		if (num11 < 3)
		{
			span10[num11 - 1] |= 128;
			while (num11 < 2)
			{
				span10[num11++] = 128;
			}
			span10[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		transfer?.InspectUids(action);
		ping?.InspectUids(action);
		spawnOptions?.InspectUids(action);
		respawnAtBag?.InspectUids(action);
		destroyBag?.InspectUids(action);
		ferryStatus?.InspectUids(action);
		ferryRetire?.InspectUids(action);
		ferryUpdateSchedule?.InspectUids(action);
		clanChatBatch?.InspectUids(action);
		playerManifest?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using Facepunch.Nexus;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class Response : IDisposable, IPooled, IProto<Response>, IProto
{
	[NonSerialized]
	public Uuid id;

	[NonSerialized]
	public Status status;

	[NonSerialized]
	public PingResponse ping;

	[NonSerialized]
	public SpawnOptionsResponse spawnOptions;

	[NonSerialized]
	public FerryStatusResponse ferryStatus;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Response instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.id = default(Uuid);
			if (instance.status != null)
			{
				instance.status.ResetToPool();
				instance.status = null;
			}
			if (instance.ping != null)
			{
				instance.ping.ResetToPool();
				instance.ping = null;
			}
			if (instance.spawnOptions != null)
			{
				instance.spawnOptions.ResetToPool();
				instance.spawnOptions = null;
			}
			if (instance.ferryStatus != null)
			{
				instance.ferryStatus.ResetToPool();
				instance.ferryStatus = null;
			}
			Pool.Free<Response>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Response with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Response instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.id = id;
		if (status != null)
		{
			if (instance.status == null)
			{
				instance.status = status.Copy();
			}
			else
			{
				status.CopyTo(instance.status);
			}
		}
		else
		{
			instance.status = null;
		}
		if (ping != null)
		{
			if (instance.ping == null)
			{
				instance.ping = ping.Copy();
			}
			else
			{
				ping.CopyTo(instance.ping);
			}
		}
		else
		{
			instance.ping = null;
		}
		if (spawnOptions != null)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = spawnOptions.Copy();
			}
			else
			{
				spawnOptions.CopyTo(instance.spawnOptions);
			}
		}
		else
		{
			instance.spawnOptions = null;
		}
		if (ferryStatus != null)
		{
			if (instance.ferryStatus == null)
			{
				instance.ferryStatus = ferryStatus.Copy();
			}
			else
			{
				ferryStatus.CopyTo(instance.ferryStatus);
			}
		}
		else
		{
			instance.ferryStatus = null;
		}
	}

	public Response Copy()
	{
		Response response = Pool.Get<Response>();
		CopyTo(response);
		return response;
	}

	public static Response Deserialize(BufferStream stream)
	{
		Response response = Pool.Get<Response>();
		Deserialize(stream, response, isDelta: false);
		return response;
	}

	public static Response DeserializeLengthDelimited(BufferStream stream)
	{
		Response response = Pool.Get<Response>();
		DeserializeLengthDelimited(stream, response, isDelta: false);
		return response;
	}

	public static Response DeserializeLength(BufferStream stream, int length)
	{
		Response response = Pool.Get<Response>();
		DeserializeLength(stream, length, response, isDelta: false);
		return response;
	}

	public static Response Deserialize(byte[] buffer)
	{
		Response response = Pool.Get<Response>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, response, isDelta: false);
		return response;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Response previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Response Deserialize(BufferStream stream, Response instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				UuidSerialized.DeserializeLengthDelimited(stream, ref instance.id, isDelta);
				break;
			case 18:
				if (instance.status == null)
				{
					instance.status = Status.DeserializeLengthDelimited(stream);
				}
				else
				{
					Status.DeserializeLengthDelimited(stream, instance.status, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingResponse.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsResponse.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusResponse.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Response DeserializeLengthDelimited(BufferStream stream, Response instance, bool isDelta)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				UuidSerialized.DeserializeLengthDelimited(stream, ref instance.id, isDelta);
				break;
			case 18:
				if (instance.status == null)
				{
					instance.status = Status.DeserializeLengthDelimited(stream);
				}
				else
				{
					Status.DeserializeLengthDelimited(stream, instance.status, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingResponse.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsResponse.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusResponse.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Response DeserializeLength(BufferStream stream, int length, Response instance, bool isDelta)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				UuidSerialized.DeserializeLengthDelimited(stream, ref instance.id, isDelta);
				break;
			case 18:
				if (instance.status == null)
				{
					instance.status = Status.DeserializeLengthDelimited(stream);
				}
				else
				{
					Status.DeserializeLengthDelimited(stream, instance.status, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingResponse.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsResponse.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusResponse.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Response instance, Response previous)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int position = stream.Position;
		UuidSerialized.SerializeDelta(stream, instance.id, previous.id);
		int num = stream.Position - position;
		if (num > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field id (Facepunch.Nexus.Uuid)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (instance.status == null)
		{
			throw new ArgumentNullException("status", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		Status.SerializeDelta(stream, instance.status, previous.status);
		int val = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
		if (instance.ping != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			PingResponse.SerializeDelta(stream, instance.ping, previous.ping);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ping (ProtoBuf.Nexus.PingResponse)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.spawnOptions != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			SpawnOptionsResponse.SerializeDelta(stream, instance.spawnOptions, previous.spawnOptions);
			int val2 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.ferryStatus == null)
		{
			return;
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range5 = stream.GetRange(5);
		int position5 = stream.Position;
		FerryStatusResponse.SerializeDelta(stream, instance.ferryStatus, previous.ferryStatus);
		int val3 = stream.Position - position5;
		Span<byte> span5 = range5.GetSpan();
		int num5 = ProtocolParser.WriteUInt32((uint)val3, span5, 0);
		if (num5 < 5)
		{
			span5[num5 - 1] |= 128;
			while (num5 < 4)
			{
				span5[num5++] = 128;
			}
			span5[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Response instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.id != default(Uuid))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			UuidSerialized.Serialize(stream, instance.id);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field id (Facepunch.Nexus.Uuid)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.status == null)
		{
			throw new ArgumentNullException("status", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		Status.Serialize(stream, instance.status);
		int val = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
		if (instance.ping != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			PingResponse.Serialize(stream, instance.ping);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ping (ProtoBuf.Nexus.PingResponse)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.spawnOptions != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			SpawnOptionsResponse.Serialize(stream, instance.spawnOptions);
			int val2 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.ferryStatus == null)
		{
			return;
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range5 = stream.GetRange(5);
		int position5 = stream.Position;
		FerryStatusResponse.Serialize(stream, instance.ferryStatus);
		int val3 = stream.Position - position5;
		Span<byte> span5 = range5.GetSpan();
		int num5 = ProtocolParser.WriteUInt32((uint)val3, span5, 0);
		if (num5 < 5)
		{
			span5[num5 - 1] |= 128;
			while (num5 < 4)
			{
				span5[num5++] = 128;
			}
			span5[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		status?.InspectUids(action);
		ping?.InspectUids(action);
		spawnOptions?.InspectUids(action);
		ferryStatus?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class Status : IDisposable, IPooled, IProto<Status>, IProto
{
	[NonSerialized]
	public bool success;

	[NonSerialized]
	public string errorMessage;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Status instance)
	{
		if (instance.ShouldPool)
		{
			instance.success = false;
			instance.errorMessage = string.Empty;
			Pool.Free<Status>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Status with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Status instance)
	{
		instance.success = success;
		instance.errorMessage = errorMessage;
	}

	public Status Copy()
	{
		Status status = Pool.Get<Status>();
		CopyTo(status);
		return status;
	}

	public static Status Deserialize(BufferStream stream)
	{
		Status status = Pool.Get<Status>();
		Deserialize(stream, status, isDelta: false);
		return status;
	}

	public static Status DeserializeLengthDelimited(BufferStream stream)
	{
		Status status = Pool.Get<Status>();
		DeserializeLengthDelimited(stream, status, isDelta: false);
		return status;
	}

	public static Status DeserializeLength(BufferStream stream, int length)
	{
		Status status = Pool.Get<Status>();
		DeserializeLength(stream, length, status, isDelta: false);
		return status;
	}

	public static Status Deserialize(byte[] buffer)
	{
		Status status = Pool.Get<Status>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, status, isDelta: false);
		return status;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Status previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Status Deserialize(BufferStream stream, Status instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.success = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.errorMessage = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Status DeserializeLengthDelimited(BufferStream stream, Status instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.success = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.errorMessage = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Status DeserializeLength(BufferStream stream, int length, Status instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.success = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.errorMessage = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Status instance, Status previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.success);
		if (instance.errorMessage != null && instance.errorMessage != previous.errorMessage)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.errorMessage);
		}
	}

	public static void Serialize(BufferStream stream, Status instance)
	{
		if (instance.success)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.success);
		}
		if (instance.errorMessage != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.errorMessage);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class PingRequest : IDisposable, IPooled, IProto<PingRequest>, IProto
{
	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PingRequest instance)
	{
		if (instance.ShouldPool)
		{
			Pool.Free<PingRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PingRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PingRequest instance)
	{
	}

	public PingRequest Copy()
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		CopyTo(pingRequest);
		return pingRequest;
	}

	public static PingRequest Deserialize(BufferStream stream)
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		Deserialize(stream, pingRequest, isDelta: false);
		return pingRequest;
	}

	public static PingRequest DeserializeLengthDelimited(BufferStream stream)
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		DeserializeLengthDelimited(stream, pingRequest, isDelta: false);
		return pingRequest;
	}

	public static PingRequest DeserializeLength(BufferStream stream, int length)
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		DeserializeLength(stream, length, pingRequest, isDelta: false);
		return pingRequest;
	}

	public static PingRequest Deserialize(byte[] buffer)
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pingRequest, isDelta: false);
		return pingRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PingRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PingRequest Deserialize(BufferStream stream, PingRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1 || num == 0)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static PingRequest DeserializeLengthDelimited(BufferStream stream, PingRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static PingRequest DeserializeLength(BufferStream stream, int length, PingRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PingRequest instance, PingRequest previous)
	{
	}

	public static void Serialize(BufferStream stream, PingRequest instance)
	{
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class PingResponse : IDisposable, IPooled, IProto<PingResponse>, IProto
{
	[NonSerialized]
	public int players;

	[NonSerialized]
	public int maxPlayers;

	[NonSerialized]
	public int queuedPlayers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PingResponse instance)
	{
		if (instance.ShouldPool)
		{
			instance.players = 0;
			instance.maxPlayers = 0;
			instance.queuedPlayers = 0;
			Pool.Free<PingResponse>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PingResponse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PingResponse instance)
	{
		instance.players = players;
		instance.maxPlayers = maxPlayers;
		instance.queuedPlayers = queuedPlayers;
	}

	public PingResponse Copy()
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		CopyTo(pingResponse);
		return pingResponse;
	}

	public static PingResponse Deserialize(BufferStream stream)
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		Deserialize(stream, pingResponse, isDelta: false);
		return pingResponse;
	}

	public static PingResponse DeserializeLengthDelimited(BufferStream stream)
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		DeserializeLengthDelimited(stream, pingResponse, isDelta: false);
		return pingResponse;
	}

	public static PingResponse DeserializeLength(BufferStream stream, int length)
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		DeserializeLength(stream, length, pingResponse, isDelta: false);
		return pingResponse;
	}

	public static PingResponse Deserialize(byte[] buffer)
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pingResponse, isDelta: false);
		return pingResponse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PingResponse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PingResponse Deserialize(BufferStream stream, PingResponse instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.players = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.maxPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.queuedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PingResponse DeserializeLengthDelimited(BufferStream stream, PingResponse instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.players = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.maxPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.queuedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PingResponse DeserializeLength(BufferStream stream, int length, PingResponse instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.players = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.maxPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.queuedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PingResponse instance, PingResponse previous)
	{
		if (instance.players != previous.players)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.players);
		}
		if (instance.maxPlayers != previous.maxPlayers)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxPlayers);
		}
		if (instance.queuedPlayers != previous.queuedPlayers)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.queuedPlayers);
		}
	}

	public static void Serialize(BufferStream stream, PingResponse instance)
	{
		if (instance.players != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.players);
		}
		if (instance.maxPlayers != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxPlayers);
		}
		if (instance.queuedPlayers != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.queuedPlayers);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class TransferRequest : IDisposable, IPooled, IProto<TransferRequest>, IProto
{
	[NonSerialized]
	public string method;

	[NonSerialized]
	public string from;

	[NonSerialized]
	public string to;

	[NonSerialized]
	public List<Entity> entities;

	[NonSerialized]
	public List<PlayerSecondaryData> secondaryData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TransferRequest instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.method = string.Empty;
		instance.from = string.Empty;
		instance.to = string.Empty;
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				if (instance.entities[i] != null)
				{
					instance.entities[i].ResetToPool();
					instance.entities[i] = null;
				}
			}
			List<Entity> list = instance.entities;
			Pool.Free<Entity>(ref list, false);
			instance.entities = list;
		}
		if (instance.secondaryData != null)
		{
			for (int j = 0; j < instance.secondaryData.Count; j++)
			{
				if (instance.secondaryData[j] != null)
				{
					instance.secondaryData[j].ResetToPool();
					instance.secondaryData[j] = null;
				}
			}
			List<PlayerSecondaryData> list2 = instance.secondaryData;
			Pool.Free<PlayerSecondaryData>(ref list2, false);
			instance.secondaryData = list2;
		}
		Pool.Free<TransferRequest>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TransferRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TransferRequest instance)
	{
		instance.method = method;
		instance.from = from;
		instance.to = to;
		if (entities != null)
		{
			instance.entities = Pool.Get<List<Entity>>();
			for (int i = 0; i < entities.Count; i++)
			{
				Entity item = entities[i].Copy();
				instance.entities.Add(item);
			}
		}
		else
		{
			instance.entities = null;
		}
		if (secondaryData != null)
		{
			instance.secondaryData = Pool.Get<List<PlayerSecondaryData>>();
			for (int j = 0; j < secondaryData.Count; j++)
			{
				PlayerSecondaryData item2 = secondaryData[j].Copy();
				instance.secondaryData.Add(item2);
			}
		}
		else
		{
			instance.secondaryData = null;
		}
	}

	public TransferRequest Copy()
	{
		TransferRequest transferRequest = Pool.Get<TransferRequest>();
		CopyTo(transferRequest);
		return transferRequest;
	}

	public static TransferRequest Deserialize(BufferStream stream)
	{
		TransferRequest transferRequest = Pool.Get<TransferRequest>();
		Deserialize(stream, transferRequest, isDelta: false);
		return transferRequest;
	}

	public static TransferRequest DeserializeLengthDelimited(BufferStream stream)
	{
		TransferRequest transferRequest = Pool.Get<TransferRequest>();
		DeserializeLengthDelimited(stream, transferRequest, isDelta: false);
		return transferRequest;
	}

	public static TransferRequest DeserializeLength(BufferStream stream, int length)
	{
		TransferRequest transferRequest = Pool.Get<TransferRequest>();
		DeserializeLength(stream, length, transferRequest, isDelta: false);
		return transferRequest;
	}

	public static TransferRequest Deserialize(byte[] buffer)
	{
		TransferRequest transferRequest = Pool.Get<TransferRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, transferRequest, isDelta: false);
		return transferRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TransferRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TransferRequest Deserialize(BufferStream stream, TransferRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			if (instance.secondaryData == null)
			{
				instance.secondaryData = Pool.Get<List<PlayerSecondaryData>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.method = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.from = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.to = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.secondaryData.Add(PlayerSecondaryData.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TransferRequest DeserializeLengthDelimited(BufferStream stream, TransferRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			if (instance.secondaryData == null)
			{
				instance.secondaryData = Pool.Get<List<PlayerSecondaryData>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.method = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.from = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.to = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.secondaryData.Add(PlayerSecondaryData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TransferRequest DeserializeLength(BufferStream stream, int length, TransferRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			if (instance.secondaryData == null)
			{
				instance.secondaryData = Pool.Get<List<PlayerSecondaryData>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.method = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.from = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.to = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.secondaryData.Add(PlayerSecondaryData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TransferRequest instance, TransferRequest previous)
	{
		if (instance.method != null && instance.method != previous.method)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.method);
		}
		if (instance.from != null && instance.from != previous.from)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.from);
		}
		if (instance.to != null && instance.to != previous.to)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.to);
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				Entity entity = instance.entities[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Entity.SerializeDelta(stream, entity, entity);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.secondaryData == null)
		{
			return;
		}
		for (int j = 0; j < instance.secondaryData.Count; j++)
		{
			PlayerSecondaryData playerSecondaryData = instance.secondaryData[j];
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerSecondaryData.SerializeDelta(stream, playerSecondaryData, playerSecondaryData);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, TransferRequest instance)
	{
		if (instance.method != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.method);
		}
		if (instance.from != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.from);
		}
		if (instance.to != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.to);
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				Entity instance2 = instance.entities[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Entity.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.secondaryData == null)
		{
			return;
		}
		for (int j = 0; j < instance.secondaryData.Count; j++)
		{
			PlayerSecondaryData instance3 = instance.secondaryData[j];
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerSecondaryData.Serialize(stream, instance3);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entities != null)
		{
			for (int i = 0; i < entities.Count; i++)
			{
				entities[i]?.InspectUids(action);
			}
		}
		if (secondaryData != null)
		{
			for (int j = 0; j < secondaryData.Count; j++)
			{
				secondaryData[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class PlayerSecondaryData : IDisposable, IPooled, IProto<PlayerSecondaryData>, IProto
{
	public class RelationshipData : IDisposable, IPooled, IProto<RelationshipData>, IProto
	{
		[NonSerialized]
		public RelationshipManager.PlayerRelationshipInfo info;

		[NonSerialized]
		public ArraySegment<byte> mugshotData;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(RelationshipData instance)
		{
			if (instance.ShouldPool)
			{
				if (instance.info != null)
				{
					instance.info.ResetToPool();
					instance.info = null;
				}
				if (instance.mugshotData.Array != null)
				{
					BufferStream.Shared.ArrayPool.Return(instance.mugshotData.Array);
				}
				instance.mugshotData = default(ArraySegment<byte>);
				Pool.Free<RelationshipData>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose RelationshipData with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(RelationshipData instance)
		{
			if (info != null)
			{
				if (instance.info == null)
				{
					instance.info = info.Copy();
				}
				else
				{
					info.CopyTo(instance.info);
				}
			}
			else
			{
				instance.info = null;
			}
			if (mugshotData.Array == null)
			{
				instance.mugshotData = default(ArraySegment<byte>);
				return;
			}
			byte[] array = BufferStream.Shared.ArrayPool.Rent(mugshotData.Count);
			Array.Copy(mugshotData.Array, 0, array, 0, mugshotData.Count);
			instance.mugshotData = new ArraySegment<byte>(array, 0, mugshotData.Count);
		}

		public RelationshipData Copy()
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			CopyTo(relationshipData);
			return relationshipData;
		}

		public static RelationshipData Deserialize(BufferStream stream)
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			Deserialize(stream, relationshipData, isDelta: false);
			return relationshipData;
		}

		public static RelationshipData DeserializeLengthDelimited(BufferStream stream)
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			DeserializeLengthDelimited(stream, relationshipData, isDelta: false);
			return relationshipData;
		}

		public static RelationshipData DeserializeLength(BufferStream stream, int length)
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			DeserializeLength(stream, length, relationshipData, isDelta: false);
			return relationshipData;
		}

		public static RelationshipData Deserialize(byte[] buffer)
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, relationshipData, isDelta: false);
			return relationshipData;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, RelationshipData previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static RelationshipData Deserialize(BufferStream stream, RelationshipData instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					if (instance.info == null)
					{
						instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
					}
					break;
				case 18:
					instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
				case 0:
					return instance;
				}
			}
		}

		public static RelationshipData DeserializeLengthDelimited(BufferStream stream, RelationshipData instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					if (instance.info == null)
					{
						instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
					}
					break;
				case 18:
					instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static RelationshipData DeserializeLength(BufferStream stream, int length, RelationshipData instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					if (instance.info == null)
					{
						instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
					}
					break;
				case 18:
					instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, RelationshipData instance, RelationshipData previous)
		{
			if (instance.info == null)
			{
				throw new ArgumentNullException("info", "Required by proto specification.");
			}
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			RelationshipManager.PlayerRelationshipInfo.SerializeDelta(stream, instance.info, previous.info);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
			if (instance.mugshotData.Array != null)
			{
				stream.WriteByte(18);
				ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
			}
		}

		public static void Serialize(BufferStream stream, RelationshipData instance)
		{
			if (instance.info == null)
			{
				throw new ArgumentNullException("info", "Required by proto specification.");
			}
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			RelationshipManager.PlayerRelationshipInfo.Serialize(stream, instance.info);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
			if (instance.mugshotData.Array != null)
			{
				stream.WriteByte(18);
				ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			info?.InspectUids(action);
		}
	}

	[NonSerialized]
	public ulong userId;

	[NonSerialized]
	public PlayerState playerState;

	[NonSerialized]
	public List<RelationshipData> relationships;

	[NonSerialized]
	public ulong teamId;

	[NonSerialized]
	public bool isTeamLeader;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerSecondaryData instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.userId = 0uL;
		if (instance.playerState != null)
		{
			instance.playerState.ResetToPool();
			instance.playerState = null;
		}
		if (instance.relationships != null)
		{
			for (int i = 0; i < instance.relationships.Count; i++)
			{
				if (instance.relationships[i] != null)
				{
					instance.relationships[i].ResetToPool();
					instance.relationships[i] = null;
				}
			}
			List<RelationshipData> list = instance.relationships;
			Pool.Free<RelationshipData>(ref list, false);
			instance.relationships = list;
		}
		instance.teamId = 0uL;
		instance.isTeamLeader = false;
		Pool.Free<PlayerSecondaryData>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerSecondaryData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerSecondaryData instance)
	{
		instance.userId = userId;
		if (playerState != null)
		{
			if (instance.playerState == null)
			{
				instance.playerState = playerState.Copy();
			}
			else
			{
				playerState.CopyTo(instance.playerState);
			}
		}
		else
		{
			instance.playerState = null;
		}
		if (relationships != null)
		{
			instance.relationships = Pool.Get<List<RelationshipData>>();
			for (int i = 0; i < relationships.Count; i++)
			{
				RelationshipData item = relationships[i].Copy();
				instance.relationships.Add(item);
			}
		}
		else
		{
			instance.relationships = null;
		}
		instance.teamId = teamId;
		instance.isTeamLeader = isTeamLeader;
	}

	public PlayerSecondaryData Copy()
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		CopyTo(playerSecondaryData);
		return playerSecondaryData;
	}

	public static PlayerSecondaryData Deserialize(BufferStream stream)
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		Deserialize(stream, playerSecondaryData, isDelta: false);
		return playerSecondaryData;
	}

	public static PlayerSecondaryData DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		DeserializeLengthDelimited(stream, playerSecondaryData, isDelta: false);
		return playerSecondaryData;
	}

	public static PlayerSecondaryData DeserializeLength(BufferStream stream, int length)
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		DeserializeLength(stream, length, playerSecondaryData, isDelta: false);
		return playerSecondaryData;
	}

	public static PlayerSecondaryData Deserialize(byte[] buffer)
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerSecondaryData, isDelta: false);
		return playerSecondaryData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerSecondaryData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerSecondaryData Deserialize(BufferStream stream, PlayerSecondaryData instance, bool isDelta)
	{
		if (!isDelta && instance.relationships == null)
		{
			instance.relationships = Pool.Get<List<RelationshipData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.playerState == null)
				{
					instance.playerState = PlayerState.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerState.DeserializeLengthDelimited(stream, instance.playerState, isDelta);
				}
				break;
			case 26:
				instance.relationships.Add(RelationshipData.DeserializeLengthDelimited(stream));
				break;
			case 32:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.isTeamLeader = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static PlayerSecondaryData DeserializeLengthDelimited(BufferStream stream, PlayerSecondaryData instance, bool isDelta)
	{
		if (!isDelta && instance.relationships == null)
		{
			instance.relationships = Pool.Get<List<RelationshipData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.playerState == null)
				{
					instance.playerState = PlayerState.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerState.DeserializeLengthDelimited(stream, instance.playerState, isDelta);
				}
				break;
			case 26:
				instance.relationships.Add(RelationshipData.DeserializeLengthDelimited(stream));
				break;
			case 32:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.isTeamLeader = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerSecondaryData DeserializeLength(BufferStream stream, int length, PlayerSecondaryData instance, bool isDelta)
	{
		if (!isDelta && instance.relationships == null)
		{
			instance.relationships = Pool.Get<List<RelationshipData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.playerState == null)
				{
					instance.playerState = PlayerState.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerState.DeserializeLengthDelimited(stream, instance.playerState, isDelta);
				}
				break;
			case 26:
				instance.relationships.Add(RelationshipData.DeserializeLengthDelimited(stream));
				break;
			case 32:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.isTeamLeader = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerSecondaryData instance, PlayerSecondaryData previous)
	{
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.playerState != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerState.SerializeDelta(stream, instance.playerState, previous.playerState);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.relationships != null)
		{
			for (int i = 0; i < instance.relationships.Count; i++)
			{
				RelationshipData relationshipData = instance.relationships[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				RelationshipData.SerializeDelta(stream, relationshipData, relationshipData);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.teamId != previous.teamId)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.teamId);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.isTeamLeader);
	}

	public static void Serialize(BufferStream stream, PlayerSecondaryData instance)
	{
		if (instance.userId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.playerState != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerState.Serialize(stream, instance.playerState);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.relationships != null)
		{
			for (int i = 0; i < instance.relationships.Count; i++)
			{
				RelationshipData instance2 = instance.relationships[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				RelationshipData.Serialize(stream, instance2);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.teamId != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.teamId);
		}
		if (instance.isTeamLeader)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isTeamLeader);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		playerState?.InspectUids(action);
		if (relationships != null)
		{
			for (int i = 0; i < relationships.Count; i++)
			{
				relationships[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class SpawnOptionsRequest : IDisposable, IPooled, IProto<SpawnOptionsRequest>, IProto
{
	[NonSerialized]
	public ulong userId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpawnOptionsRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.userId = 0uL;
			Pool.Free<SpawnOptionsRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpawnOptionsRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpawnOptionsRequest instance)
	{
		instance.userId = userId;
	}

	public SpawnOptionsRequest Copy()
	{
		SpawnOptionsRequest spawnOptionsRequest = Pool.Get<SpawnOptionsRequest>();
		CopyTo(spawnOptionsRequest);
		return spawnOptionsRequest;
	}

	public static SpawnOptionsRequest Deserialize(BufferStream stream)
	{
		SpawnOptionsRequest spawnOptionsRequest = Pool.Get<SpawnOptionsRequest>();
		Deserialize(stream, spawnOptionsRequest, isDelta: false);
		return spawnOptionsRequest;
	}

	public static SpawnOptionsRequest DeserializeLengthDelimited(BufferStream stream)
	{
		SpawnOptionsRequest spawnOptionsRequest = Pool.Get<SpawnOptionsRequest>();
		DeserializeLengthDelimited(stream, spawnOptionsRequest, isDelta: false);
		return spawnOptionsRequest;
	}

	public static SpawnOptionsRequest DeserializeLength(BufferStream stream, int length)
	{
		SpawnOptionsRequest spawnOptionsRequest = Pool.Get<SpawnOptionsRequest>();
		DeserializeLength(stream, length, spawnOptionsRequest, isDelta: false);
		return spawnOptionsRequest;
	}

	public static SpawnOptionsRequest Deserialize(byte[] buffer)
	{
		SpawnOptionsRequest spawnOptionsRequest = Pool.Get<SpawnOptionsRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spawnOptionsRequest, isDelta: false);
		return spawnOptionsRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpawnOptionsRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpawnOptionsRequest Deserialize(BufferStream stream, SpawnOptionsRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpawnOptionsRequest DeserializeLengthDelimited(BufferStream stream, SpawnOptionsRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpawnOptionsRequest DeserializeLength(BufferStream stream, int length, SpawnOptionsRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpawnOptionsRequest instance, SpawnOptionsRequest previous)
	{
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
	}

	public static void Serialize(BufferStream stream, SpawnOptionsRequest instance)
	{
		if (instance.userId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class SpawnOptionsResponse : IDisposable, IPooled, IProto<SpawnOptionsResponse>, IProto
{
	[NonSerialized]
	public List<RespawnInformation.SpawnOptions> spawnOptions;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpawnOptionsResponse instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.spawnOptions != null)
		{
			for (int i = 0; i < instance.spawnOptions.Count; i++)
			{
				if (instance.spawnOptions[i] != null)
				{
					instance.spawnOptions[i].ResetToPool();
					instance.spawnOptions[i] = null;
				}
			}
			List<RespawnInformation.SpawnOptions> list = instance.spawnOptions;
			Pool.Free<RespawnInformation.SpawnOptions>(ref list, false);
			instance.spawnOptions = list;
		}
		Pool.Free<SpawnOptionsResponse>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpawnOptionsResponse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpawnOptionsResponse instance)
	{
		if (spawnOptions != null)
		{
			instance.spawnOptions = Pool.Get<List<RespawnInformation.SpawnOptions>>();
			for (int i = 0; i < spawnOptions.Count; i++)
			{
				RespawnInformation.SpawnOptions item = spawnOptions[i].Copy();
				instance.spawnOptions.Add(item);
			}
		}
		else
		{
			instance.spawnOptions = null;
		}
	}

	public SpawnOptionsResponse Copy()
	{
		SpawnOptionsResponse spawnOptionsResponse = Pool.Get<SpawnOptionsResponse>();
		CopyTo(spawnOptionsResponse);
		return spawnOptionsResponse;
	}

	public static SpawnOptionsResponse Deserialize(BufferStream stream)
	{
		SpawnOptionsResponse spawnOptionsResponse = Pool.Get<SpawnOptionsResponse>();
		Deserialize(stream, spawnOptionsResponse, isDelta: false);
		return spawnOptionsResponse;
	}

	public static SpawnOptionsResponse DeserializeLengthDelimited(BufferStream stream)
	{
		SpawnOptionsResponse spawnOptionsResponse = Pool.Get<SpawnOptionsResponse>();
		DeserializeLengthDelimited(stream, spawnOptionsResponse, isDelta: false);
		return spawnOptionsResponse;
	}

	public static SpawnOptionsResponse DeserializeLength(BufferStream stream, int length)
	{
		SpawnOptionsResponse spawnOptionsResponse = Pool.Get<SpawnOptionsResponse>();
		DeserializeLength(stream, length, spawnOptionsResponse, isDelta: false);
		return spawnOptionsResponse;
	}

	public static SpawnOptionsResponse Deserialize(byte[] buffer)
	{
		SpawnOptionsResponse spawnOptionsResponse = Pool.Get<SpawnOptionsResponse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spawnOptionsResponse, isDelta: false);
		return spawnOptionsResponse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpawnOptionsResponse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpawnOptionsResponse Deserialize(BufferStream stream, SpawnOptionsResponse instance, bool isDelta)
	{
		if (!isDelta && instance.spawnOptions == null)
		{
			instance.spawnOptions = Pool.Get<List<RespawnInformation.SpawnOptions>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.spawnOptions.Add(RespawnInformation.SpawnOptions.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpawnOptionsResponse DeserializeLengthDelimited(BufferStream stream, SpawnOptionsResponse instance, bool isDelta)
	{
		if (!isDelta && instance.spawnOptions == null)
		{
			instance.spawnOptions = Pool.Get<List<RespawnInformation.SpawnOptions>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.spawnOptions.Add(RespawnInformation.SpawnOptions.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpawnOptionsResponse DeserializeLength(BufferStream stream, int length, SpawnOptionsResponse instance, bool isDelta)
	{
		if (!isDelta && instance.spawnOptions == null)
		{
			instance.spawnOptions = Pool.Get<List<RespawnInformation.SpawnOptions>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.spawnOptions.Add(RespawnInformation.SpawnOptions.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpawnOptionsResponse instance, SpawnOptionsResponse previous)
	{
		if (instance.spawnOptions == null)
		{
			return;
		}
		for (int i = 0; i < instance.spawnOptions.Count; i++)
		{
			RespawnInformation.SpawnOptions spawnOptions = instance.spawnOptions[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			RespawnInformation.SpawnOptions.SerializeDelta(stream, spawnOptions, spawnOptions);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, SpawnOptionsResponse instance)
	{
		if (instance.spawnOptions == null)
		{
			return;
		}
		for (int i = 0; i < instance.spawnOptions.Count; i++)
		{
			RespawnInformation.SpawnOptions instance2 = instance.spawnOptions[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			RespawnInformation.SpawnOptions.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (spawnOptions != null)
		{
			for (int i = 0; i < spawnOptions.Count; i++)
			{
				spawnOptions[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class SleepingBagRespawnRequest : IDisposable, IPooled, IProto<SleepingBagRespawnRequest>, IProto
{
	[NonSerialized]
	public ulong userId;

	[NonSerialized]
	public NetworkableId sleepingBagId;

	[NonSerialized]
	public PlayerSecondaryData secondaryData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SleepingBagRespawnRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.userId = 0uL;
			instance.sleepingBagId = default(NetworkableId);
			if (instance.secondaryData != null)
			{
				instance.secondaryData.ResetToPool();
				instance.secondaryData = null;
			}
			Pool.Free<SleepingBagRespawnRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SleepingBagRespawnRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SleepingBagRespawnRequest instance)
	{
		instance.userId = userId;
		instance.sleepingBagId = sleepingBagId;
		if (secondaryData != null)
		{
			if (instance.secondaryData == null)
			{
				instance.secondaryData = secondaryData.Copy();
			}
			else
			{
				secondaryData.CopyTo(instance.secondaryData);
			}
		}
		else
		{
			instance.secondaryData = null;
		}
	}

	public SleepingBagRespawnRequest Copy()
	{
		SleepingBagRespawnRequest sleepingBagRespawnRequest = Pool.Get<SleepingBagRespawnRequest>();
		CopyTo(sleepingBagRespawnRequest);
		return sleepingBagRespawnRequest;
	}

	public static SleepingBagRespawnRequest Deserialize(BufferStream stream)
	{
		SleepingBagRespawnRequest sleepingBagRespawnRequest = Pool.Get<SleepingBagRespawnRequest>();
		Deserialize(stream, sleepingBagRespawnRequest, isDelta: false);
		return sleepingBagRespawnRequest;
	}

	public static SleepingBagRespawnRequest DeserializeLengthDelimited(BufferStream stream)
	{
		SleepingBagRespawnRequest sleepingBagRespawnRequest = Pool.Get<SleepingBagRespawnRequest>();
		DeserializeLengthDelimited(stream, sleepingBagRespawnRequest, isDelta: false);
		return sleepingBagRespawnRequest;
	}

	public static SleepingBagRespawnRequest DeserializeLength(BufferStream stream, int length)
	{
		SleepingBagRespawnRequest sleepingBagRespawnRequest = Pool.Get<SleepingBagRespawnRequest>();
		DeserializeLength(stream, length, sleepingBagRespawnRequest, isDelta: false);
		return sleepingBagRespawnRequest;
	}

	public static SleepingBagRespawnRequest Deserialize(byte[] buffer)
	{
		SleepingBagRespawnRequest sleepingBagRespawnRequest = Pool.Get<SleepingBagRespawnRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sleepingBagRespawnRequest, isDelta: false);
		return sleepingBagRespawnRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SleepingBagRespawnRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SleepingBagRespawnRequest Deserialize(BufferStream stream, SleepingBagRespawnRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.sleepingBagId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 26:
				if (instance.secondaryData == null)
				{
					instance.secondaryData = PlayerSecondaryData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerSecondaryData.DeserializeLengthDelimited(stream, instance.secondaryData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static SleepingBagRespawnRequest DeserializeLengthDelimited(BufferStream stream, SleepingBagRespawnRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.sleepingBagId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 26:
				if (instance.secondaryData == null)
				{
					instance.secondaryData = PlayerSecondaryData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerSecondaryData.DeserializeLengthDelimited(stream, instance.secondaryData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SleepingBagRespawnRequest DeserializeLength(BufferStream stream, int length, SleepingBagRespawnRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.sleepingBagId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 26:
				if (instance.secondaryData == null)
				{
					instance.secondaryData = PlayerSecondaryData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerSecondaryData.DeserializeLengthDelimited(stream, instance.secondaryData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SleepingBagRespawnRequest instance, SleepingBagRespawnRequest previous)
	{
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.sleepingBagId.Value);
		if (instance.secondaryData == null)
		{
			throw new ArgumentNullException("secondaryData", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		PlayerSecondaryData.SerializeDelta(stream, instance.secondaryData, previous.secondaryData);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, SleepingBagRespawnRequest instance)
	{
		if (instance.userId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.sleepingBagId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.sleepingBagId.Value);
		}
		if (instance.secondaryData == null)
		{
			throw new ArgumentNullException("secondaryData", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		PlayerSecondaryData.Serialize(stream, instance.secondaryData);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref sleepingBagId.Value);
		secondaryData?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class SleepingBagDestroyRequest : IDisposable, IPooled, IProto<SleepingBagDestroyRequest>, IProto
{
	[NonSerialized]
	public ulong userId;

	[NonSerialized]
	public NetworkableId sleepingBagId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SleepingBagDestroyRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.userId = 0uL;
			instance.sleepingBagId = default(NetworkableId);
			Pool.Free<SleepingBagDestroyRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SleepingBagDestroyRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SleepingBagDestroyRequest instance)
	{
		instance.userId = userId;
		instance.sleepingBagId = sleepingBagId;
	}

	public SleepingBagDestroyRequest Copy()
	{
		SleepingBagDestroyRequest sleepingBagDestroyRequest = Pool.Get<SleepingBagDestroyRequest>();
		CopyTo(sleepingBagDestroyRequest);
		return sleepingBagDestroyRequest;
	}

	public static SleepingBagDestroyRequest Deserialize(BufferStream stream)
	{
		SleepingBagDestroyRequest sleepingBagDestroyRequest = Pool.Get<SleepingBagDestroyRequest>();
		Deserialize(stream, sleepingBagDestroyRequest, isDelta: false);
		return sleepingBagDestroyRequest;
	}

	public static SleepingBagDestroyRequest DeserializeLengthDelimited(BufferStream stream)
	{
		SleepingBagDestroyRequest sleepingBagDestroyRequest = Pool.Get<SleepingBagDestroyRequest>();
		DeserializeLengthDelimited(stream, sleepingBagDestroyRequest, isDelta: false);
		return sleepingBagDestroyRequest;
	}

	public static SleepingBagDestroyRequest DeserializeLength(BufferStream stream, int length)
	{
		SleepingBagDestroyRequest sleepingBagDestroyRequest = Pool.Get<SleepingBagDestroyRequest>();
		DeserializeLength(stream, length, sleepingBagDestroyRequest, isDelta: false);
		return sleepingBagDestroyRequest;
	}

	public static SleepingBagDestroyRequest Deserialize(byte[] buffer)
	{
		SleepingBagDestroyRequest sleepingBagDestroyRequest = Pool.Get<SleepingBagDestroyRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sleepingBagDestroyRequest, isDelta: false);
		return sleepingBagDestroyRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SleepingBagDestroyRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SleepingBagDestroyRequest Deserialize(BufferStream stream, SleepingBagDestroyRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.sleepingBagId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SleepingBagDestroyRequest DeserializeLengthDelimited(BufferStream stream, SleepingBagDestroyRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.sleepingBagId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SleepingBagDestroyRequest DeserializeLength(BufferStream stream, int length, SleepingBagDestroyRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.sleepingBagId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SleepingBagDestroyRequest instance, SleepingBagDestroyRequest previous)
	{
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.sleepingBagId.Value);
	}

	public static void Serialize(BufferStream stream, SleepingBagDestroyRequest instance)
	{
		if (instance.userId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.sleepingBagId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.sleepingBagId.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref sleepingBagId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryStatusRequest : IDisposable, IPooled, IProto<FerryStatusRequest>, IProto
{
	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryStatusRequest instance)
	{
		if (instance.ShouldPool)
		{
			Pool.Free<FerryStatusRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryStatusRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryStatusRequest instance)
	{
	}

	public FerryStatusRequest Copy()
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		CopyTo(ferryStatusRequest);
		return ferryStatusRequest;
	}

	public static FerryStatusRequest Deserialize(BufferStream stream)
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		Deserialize(stream, ferryStatusRequest, isDelta: false);
		return ferryStatusRequest;
	}

	public static FerryStatusRequest DeserializeLengthDelimited(BufferStream stream)
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		DeserializeLengthDelimited(stream, ferryStatusRequest, isDelta: false);
		return ferryStatusRequest;
	}

	public static FerryStatusRequest DeserializeLength(BufferStream stream, int length)
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		DeserializeLength(stream, length, ferryStatusRequest, isDelta: false);
		return ferryStatusRequest;
	}

	public static FerryStatusRequest Deserialize(byte[] buffer)
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryStatusRequest, isDelta: false);
		return ferryStatusRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryStatusRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryStatusRequest Deserialize(BufferStream stream, FerryStatusRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1 || num == 0)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static FerryStatusRequest DeserializeLengthDelimited(BufferStream stream, FerryStatusRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static FerryStatusRequest DeserializeLength(BufferStream stream, int length, FerryStatusRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryStatusRequest instance, FerryStatusRequest previous)
	{
	}

	public static void Serialize(BufferStream stream, FerryStatusRequest instance)
	{
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryStatusResponse : IDisposable, IPooled, IProto<FerryStatusResponse>, IProto
{
	[NonSerialized]
	public List<FerryStatus> statuses;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryStatusResponse instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.statuses != null)
		{
			for (int i = 0; i < instance.statuses.Count; i++)
			{
				if (instance.statuses[i] != null)
				{
					instance.statuses[i].ResetToPool();
					instance.statuses[i] = null;
				}
			}
			List<FerryStatus> list = instance.statuses;
			Pool.Free<FerryStatus>(ref list, false);
			instance.statuses = list;
		}
		Pool.Free<FerryStatusResponse>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryStatusResponse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryStatusResponse instance)
	{
		if (statuses != null)
		{
			instance.statuses = Pool.Get<List<FerryStatus>>();
			for (int i = 0; i < statuses.Count; i++)
			{
				FerryStatus item = statuses[i].Copy();
				instance.statuses.Add(item);
			}
		}
		else
		{
			instance.statuses = null;
		}
	}

	public FerryStatusResponse Copy()
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		CopyTo(ferryStatusResponse);
		return ferryStatusResponse;
	}

	public static FerryStatusResponse Deserialize(BufferStream stream)
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		Deserialize(stream, ferryStatusResponse, isDelta: false);
		return ferryStatusResponse;
	}

	public static FerryStatusResponse DeserializeLengthDelimited(BufferStream stream)
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		DeserializeLengthDelimited(stream, ferryStatusResponse, isDelta: false);
		return ferryStatusResponse;
	}

	public static FerryStatusResponse DeserializeLength(BufferStream stream, int length)
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		DeserializeLength(stream, length, ferryStatusResponse, isDelta: false);
		return ferryStatusResponse;
	}

	public static FerryStatusResponse Deserialize(byte[] buffer)
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryStatusResponse, isDelta: false);
		return ferryStatusResponse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryStatusResponse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryStatusResponse Deserialize(BufferStream stream, FerryStatusResponse instance, bool isDelta)
	{
		if (!isDelta && instance.statuses == null)
		{
			instance.statuses = Pool.Get<List<FerryStatus>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.statuses.Add(FerryStatus.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FerryStatusResponse DeserializeLengthDelimited(BufferStream stream, FerryStatusResponse instance, bool isDelta)
	{
		if (!isDelta && instance.statuses == null)
		{
			instance.statuses = Pool.Get<List<FerryStatus>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.statuses.Add(FerryStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FerryStatusResponse DeserializeLength(BufferStream stream, int length, FerryStatusResponse instance, bool isDelta)
	{
		if (!isDelta && instance.statuses == null)
		{
			instance.statuses = Pool.Get<List<FerryStatus>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.statuses.Add(FerryStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryStatusResponse instance, FerryStatusResponse previous)
	{
		if (instance.statuses == null)
		{
			return;
		}
		for (int i = 0; i < instance.statuses.Count; i++)
		{
			FerryStatus ferryStatus = instance.statuses[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			FerryStatus.SerializeDelta(stream, ferryStatus, ferryStatus);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, FerryStatusResponse instance)
	{
		if (instance.statuses == null)
		{
			return;
		}
		for (int i = 0; i < instance.statuses.Count; i++)
		{
			FerryStatus instance2 = instance.statuses[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			FerryStatus.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (statuses != null)
		{
			for (int i = 0; i < statuses.Count; i++)
			{
				statuses[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryStatus : IDisposable, IPooled, IProto<FerryStatus>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public string ownerZone;

	[NonSerialized]
	public List<string> schedule;

	[NonSerialized]
	public int scheduleIndex;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public bool isRetiring;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryStatus instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.timestamp = 0L;
			instance.ownerZone = string.Empty;
			if (instance.schedule != null)
			{
				List<string> list = instance.schedule;
				Pool.FreeUnmanaged<string>(ref list);
				instance.schedule = list;
			}
			instance.scheduleIndex = 0;
			instance.state = 0;
			instance.isRetiring = false;
			Pool.Free<FerryStatus>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryStatus with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryStatus instance)
	{
		instance.entityId = entityId;
		instance.timestamp = timestamp;
		instance.ownerZone = ownerZone;
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<string>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				string item = schedule[i];
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
		instance.scheduleIndex = scheduleIndex;
		instance.state = state;
		instance.isRetiring = isRetiring;
	}

	public FerryStatus Copy()
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		CopyTo(ferryStatus);
		return ferryStatus;
	}

	public static FerryStatus Deserialize(BufferStream stream)
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		Deserialize(stream, ferryStatus, isDelta: false);
		return ferryStatus;
	}

	public static FerryStatus DeserializeLengthDelimited(BufferStream stream)
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		DeserializeLengthDelimited(stream, ferryStatus, isDelta: false);
		return ferryStatus;
	}

	public static FerryStatus DeserializeLength(BufferStream stream, int length)
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		DeserializeLength(stream, length, ferryStatus, isDelta: false);
		return ferryStatus;
	}

	public static FerryStatus Deserialize(byte[] buffer)
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryStatus, isDelta: false);
		return ferryStatus;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryStatus previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryStatus Deserialize(BufferStream stream, FerryStatus instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 40:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FerryStatus DeserializeLengthDelimited(BufferStream stream, FerryStatus instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 40:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FerryStatus DeserializeLength(BufferStream stream, int length, FerryStatus instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 40:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryStatus instance, FerryStatus previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.ownerZone != previous.ownerZone)
		{
			if (instance.ownerZone == null)
			{
				throw new ArgumentNullException("ownerZone", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.ownerZone);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != previous.scheduleIndex)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.isRetiring);
	}

	public static void Serialize(BufferStream stream, FerryStatus instance)
	{
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.ownerZone == null)
		{
			throw new ArgumentNullException("ownerZone", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.ownerZone);
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.isRetiring)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isRetiring);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryRetireRequest : IDisposable, IPooled, IProto<FerryRetireRequest>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryRetireRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.timestamp = 0L;
			Pool.Free<FerryRetireRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryRetireRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryRetireRequest instance)
	{
		instance.entityId = entityId;
		instance.timestamp = timestamp;
	}

	public FerryRetireRequest Copy()
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		CopyTo(ferryRetireRequest);
		return ferryRetireRequest;
	}

	public static FerryRetireRequest Deserialize(BufferStream stream)
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		Deserialize(stream, ferryRetireRequest, isDelta: false);
		return ferryRetireRequest;
	}

	public static FerryRetireRequest DeserializeLengthDelimited(BufferStream stream)
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		DeserializeLengthDelimited(stream, ferryRetireRequest, isDelta: false);
		return ferryRetireRequest;
	}

	public static FerryRetireRequest DeserializeLength(BufferStream stream, int length)
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		DeserializeLength(stream, length, ferryRetireRequest, isDelta: false);
		return ferryRetireRequest;
	}

	public static FerryRetireRequest Deserialize(byte[] buffer)
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryRetireRequest, isDelta: false);
		return ferryRetireRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryRetireRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryRetireRequest Deserialize(BufferStream stream, FerryRetireRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FerryRetireRequest DeserializeLengthDelimited(BufferStream stream, FerryRetireRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FerryRetireRequest DeserializeLength(BufferStream stream, int length, FerryRetireRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryRetireRequest instance, FerryRetireRequest previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, FerryRetireRequest instance)
	{
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryUpdateScheduleRequest : IDisposable, IPooled, IProto<FerryUpdateScheduleRequest>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public List<string> schedule;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryUpdateScheduleRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.timestamp = 0L;
			if (instance.schedule != null)
			{
				List<string> list = instance.schedule;
				Pool.FreeUnmanaged<string>(ref list);
				instance.schedule = list;
			}
			Pool.Free<FerryUpdateScheduleRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryUpdateScheduleRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryUpdateScheduleRequest instance)
	{
		instance.entityId = entityId;
		instance.timestamp = timestamp;
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<string>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				string item = schedule[i];
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
	}

	public FerryUpdateScheduleRequest Copy()
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		CopyTo(ferryUpdateScheduleRequest);
		return ferryUpdateScheduleRequest;
	}

	public static FerryUpdateScheduleRequest Deserialize(BufferStream stream)
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		Deserialize(stream, ferryUpdateScheduleRequest, isDelta: false);
		return ferryUpdateScheduleRequest;
	}

	public static FerryUpdateScheduleRequest DeserializeLengthDelimited(BufferStream stream)
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		DeserializeLengthDelimited(stream, ferryUpdateScheduleRequest, isDelta: false);
		return ferryUpdateScheduleRequest;
	}

	public static FerryUpdateScheduleRequest DeserializeLength(BufferStream stream, int length)
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		DeserializeLength(stream, length, ferryUpdateScheduleRequest, isDelta: false);
		return ferryUpdateScheduleRequest;
	}

	public static FerryUpdateScheduleRequest Deserialize(byte[] buffer)
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryUpdateScheduleRequest, isDelta: false);
		return ferryUpdateScheduleRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryUpdateScheduleRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryUpdateScheduleRequest Deserialize(BufferStream stream, FerryUpdateScheduleRequest instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FerryUpdateScheduleRequest DeserializeLengthDelimited(BufferStream stream, FerryUpdateScheduleRequest instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FerryUpdateScheduleRequest DeserializeLength(BufferStream stream, int length, FerryUpdateScheduleRequest instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryUpdateScheduleRequest instance, FerryUpdateScheduleRequest previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, FerryUpdateScheduleRequest instance)
	{
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class ClanChatBatchRequest : IDisposable, IPooled, IProto<ClanChatBatchRequest>, IProto
{
	public class Message : IDisposable, IPooled, IProto<Message>, IProto
	{
		[NonSerialized]
		public long clanId;

		[NonSerialized]
		public ulong userId;

		[NonSerialized]
		public string text;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public long timestamp;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Message instance)
		{
			if (instance.ShouldPool)
			{
				instance.clanId = 0L;
				instance.userId = 0uL;
				instance.text = string.Empty;
				instance.name = string.Empty;
				instance.timestamp = 0L;
				Pool.Free<Message>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Message with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Message instance)
		{
			instance.clanId = clanId;
			instance.userId = userId;
			instance.text = text;
			instance.name = name;
			instance.timestamp = timestamp;
		}

		public Message Copy()
		{
			Message message = Pool.Get<Message>();
			CopyTo(message);
			return message;
		}

		public static Message Deserialize(BufferStream stream)
		{
			Message message = Pool.Get<Message>();
			Deserialize(stream, message, isDelta: false);
			return message;
		}

		public static Message DeserializeLengthDelimited(BufferStream stream)
		{
			Message message = Pool.Get<Message>();
			DeserializeLengthDelimited(stream, message, isDelta: false);
			return message;
		}

		public static Message DeserializeLength(BufferStream stream, int length)
		{
			Message message = Pool.Get<Message>();
			DeserializeLength(stream, length, message, isDelta: false);
			return message;
		}

		public static Message Deserialize(byte[] buffer)
		{
			Message message = Pool.Get<Message>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, message, isDelta: false);
			return message;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Message previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Message Deserialize(BufferStream stream, Message instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.userId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.text = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Message DeserializeLengthDelimited(BufferStream stream, Message instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.userId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.text = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Message DeserializeLength(BufferStream stream, int length, Message instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.userId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.text = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Message instance, Message previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			if (instance.userId != previous.userId)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userId);
			}
			if (instance.text != previous.text)
			{
				if (instance.text == null)
				{
					throw new ArgumentNullException("text", "Required by proto specification.");
				}
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.text);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.name);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}

		public static void Serialize(BufferStream stream, Message instance)
		{
			if (instance.clanId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			}
			if (instance.userId != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userId);
			}
			if (instance.text == null)
			{
				throw new ArgumentNullException("text", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.text);
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Message> messages;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanChatBatchRequest instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.messages != null)
		{
			for (int i = 0; i < instance.messages.Count; i++)
			{
				if (instance.messages[i] != null)
				{
					instance.messages[i].ResetToPool();
					instance.messages[i] = null;
				}
			}
			List<Message> list = instance.messages;
			Pool.Free<Message>(ref list, false);
			instance.messages = list;
		}
		Pool.Free<ClanChatBatchRequest>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanChatBatchRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanChatBatchRequest instance)
	{
		if (messages != null)
		{
			instance.messages = Pool.Get<List<Message>>();
			for (int i = 0; i < messages.Count; i++)
			{
				Message item = messages[i].Copy();
				instance.messages.Add(item);
			}
		}
		else
		{
			instance.messages = null;
		}
	}

	public ClanChatBatchRequest Copy()
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		CopyTo(clanChatBatchRequest);
		return clanChatBatchRequest;
	}

	public static ClanChatBatchRequest Deserialize(BufferStream stream)
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		Deserialize(stream, clanChatBatchRequest, isDelta: false);
		return clanChatBatchRequest;
	}

	public static ClanChatBatchRequest DeserializeLengthDelimited(BufferStream stream)
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		DeserializeLengthDelimited(stream, clanChatBatchRequest, isDelta: false);
		return clanChatBatchRequest;
	}

	public static ClanChatBatchRequest DeserializeLength(BufferStream stream, int length)
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		DeserializeLength(stream, length, clanChatBatchRequest, isDelta: false);
		return clanChatBatchRequest;
	}

	public static ClanChatBatchRequest Deserialize(byte[] buffer)
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanChatBatchRequest, isDelta: false);
		return clanChatBatchRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanChatBatchRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanChatBatchRequest Deserialize(BufferStream stream, ClanChatBatchRequest instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<Message>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.messages.Add(Message.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanChatBatchRequest DeserializeLengthDelimited(BufferStream stream, ClanChatBatchRequest instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<Message>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(Message.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanChatBatchRequest DeserializeLength(BufferStream stream, int length, ClanChatBatchRequest instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<Message>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(Message.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanChatBatchRequest instance, ClanChatBatchRequest previous)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			Message message = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Message.SerializeDelta(stream, message, message);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ClanChatBatchRequest instance)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			Message instance2 = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Message.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (messages != null)
		{
			for (int i = 0; i < messages.Count; i++)
			{
				messages[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class PlayerManifestRequest : IDisposable, IPooled, IProto<PlayerManifestRequest>, IProto
{
	[NonSerialized]
	public List<ulong> userIds;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerManifestRequest instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.userIds != null)
			{
				List<ulong> list = instance.userIds;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.userIds = list;
			}
			Pool.Free<PlayerManifestRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerManifestRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerManifestRequest instance)
	{
		if (userIds != null)
		{
			instance.userIds = Pool.Get<List<ulong>>();
			for (int i = 0; i < userIds.Count; i++)
			{
				ulong item = userIds[i];
				instance.userIds.Add(item);
			}
		}
		else
		{
			instance.userIds = null;
		}
	}

	public PlayerManifestRequest Copy()
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		CopyTo(playerManifestRequest);
		return playerManifestRequest;
	}

	public static PlayerManifestRequest Deserialize(BufferStream stream)
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		Deserialize(stream, playerManifestRequest, isDelta: false);
		return playerManifestRequest;
	}

	public static PlayerManifestRequest DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		DeserializeLengthDelimited(stream, playerManifestRequest, isDelta: false);
		return playerManifestRequest;
	}

	public static PlayerManifestRequest DeserializeLength(BufferStream stream, int length)
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		DeserializeLength(stream, length, playerManifestRequest, isDelta: false);
		return playerManifestRequest;
	}

	public static PlayerManifestRequest Deserialize(byte[] buffer)
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerManifestRequest, isDelta: false);
		return playerManifestRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerManifestRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerManifestRequest Deserialize(BufferStream stream, PlayerManifestRequest instance, bool isDelta)
	{
		if (!isDelta && instance.userIds == null)
		{
			instance.userIds = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerManifestRequest DeserializeLengthDelimited(BufferStream stream, PlayerManifestRequest instance, bool isDelta)
	{
		if (!isDelta && instance.userIds == null)
		{
			instance.userIds = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerManifestRequest DeserializeLength(BufferStream stream, int length, PlayerManifestRequest instance, bool isDelta)
	{
		if (!isDelta && instance.userIds == null)
		{
			instance.userIds = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerManifestRequest instance, PlayerManifestRequest previous)
	{
		if (instance.userIds != null)
		{
			for (int i = 0; i < instance.userIds.Count; i++)
			{
				ulong val = instance.userIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, PlayerManifestRequest instance)
	{
		if (instance.userIds != null)
		{
			for (int i = 0; i < instance.userIds.Count; i++)
			{
				ulong val = instance.userIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum Flag
{
	Ducked = 1,
	Jumped = 2,
	OnGround = 4,
	Sleeping = 8,
	Sprinting = 0x10,
	OnLadder = 0x20,
	Flying = 0x40,
	Aiming = 0x80,
	Prone = 0x100,
	Mounted = 0x200,
	Relaxed = 0x400,
	OnPhone = 0x800,
	Crawling = 0x1000,
	Loading = 0x2000,
	HeadLook = 0x4000,
	HasParachute = 0x8000,
	Blocking = 0x10000,
	Ragdolling = 0x20000,
	Catching = 0x40000
}


using Facepunch;

public static class Shared
{
	public static int StartingCapacity = 64;

	public static int MaximumCapacity = 536870912;

	public static int MaximumPooledSize = 67108864;

	public static readonly ArrayPool<byte> ArrayPool = new ArrayPool<byte>(MaximumPooledSize);
}


using System;
using System.Runtime.CompilerServices;

public readonly ref struct RangeHandle
{
	private readonly BufferStream _stream;

	private readonly int _offset;

	private readonly int _length;

	public RangeHandle(BufferStream stream, int offset, int length)
	{
		if (offset < 0)
		{
			throw new ArgumentOutOfRangeException("offset");
		}
		if (length < 0)
		{
			throw new ArgumentOutOfRangeException("length");
		}
		_stream = stream ?? throw new ArgumentNullException("stream");
		_offset = offset;
		_length = length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Span<byte> GetSpan()
	{
		return new Span<byte>(_stream._buffer, _offset, _length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ArraySegment<byte> GetSegment()
	{
		return new ArraySegment<byte>(_stream._buffer, _offset, _length);
	}
}


private struct MonoScriptData
{
	public byte[] FilePathsData;

	public byte[] TypesData;

	public int TotalTypes;

	public int TotalFiles;

	public bool IsEditorOnly;
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Monument : IDisposable, IPooled, IProto<Monument>, IProto
{
	[NonSerialized]
	public string token;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Monument instance)
	{
		if (instance.ShouldPool)
		{
			instance.token = string.Empty;
			instance.x = 0f;
			instance.y = 0f;
			Pool.Free<Monument>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Monument with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Monument instance)
	{
		instance.token = token;
		instance.x = x;
		instance.y = y;
	}

	public Monument Copy()
	{
		Monument monument = Pool.Get<Monument>();
		CopyTo(monument);
		return monument;
	}

	public static Monument Deserialize(BufferStream stream)
	{
		Monument monument = Pool.Get<Monument>();
		Deserialize(stream, monument, isDelta: false);
		return monument;
	}

	public static Monument DeserializeLengthDelimited(BufferStream stream)
	{
		Monument monument = Pool.Get<Monument>();
		DeserializeLengthDelimited(stream, monument, isDelta: false);
		return monument;
	}

	public static Monument DeserializeLength(BufferStream stream, int length)
	{
		Monument monument = Pool.Get<Monument>();
		DeserializeLength(stream, length, monument, isDelta: false);
		return monument;
	}

	public static Monument Deserialize(byte[] buffer)
	{
		Monument monument = Pool.Get<Monument>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, monument, isDelta: false);
		return monument;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Monument previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Monument Deserialize(BufferStream stream, Monument instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.token = ProtocolParser.ReadString(stream);
				continue;
			case 21:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Monument DeserializeLengthDelimited(BufferStream stream, Monument instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.token = ProtocolParser.ReadString(stream);
				continue;
			case 21:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Monument DeserializeLength(BufferStream stream, int length, Monument instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.token = ProtocolParser.ReadString(stream);
				continue;
			case 21:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Monument instance, Monument previous)
	{
		if (instance.token != previous.token)
		{
			if (instance.token == null)
			{
				throw new ArgumentNullException("token", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.token);
		}
		if (instance.x != previous.x)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
	}

	public static void Serialize(BufferStream stream, Monument instance)
	{
		if (instance.token == null)
		{
			throw new ArgumentNullException("token", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.token);
		if (instance.x != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Item : IDisposable, IPooled, IProto<Item>, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public int quantity;

	[NonSerialized]
	public bool itemIsBlueprint;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Item instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
			Pool.Free<Item>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Item with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Item instance)
	{
		instance.itemId = itemId;
		instance.quantity = quantity;
		instance.itemIsBlueprint = itemIsBlueprint;
	}

	public Item Copy()
	{
		Item item = Pool.Get<Item>();
		CopyTo(item);
		return item;
	}

	public static Item Deserialize(BufferStream stream)
	{
		Item item = Pool.Get<Item>();
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLengthDelimited(BufferStream stream)
	{
		Item item = Pool.Get<Item>();
		DeserializeLengthDelimited(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLength(BufferStream stream, int length)
	{
		Item item = Pool.Get<Item>();
		DeserializeLength(stream, length, item, isDelta: false);
		return item;
	}

	public static Item Deserialize(byte[] buffer)
	{
		Item item = Pool.Get<Item>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Item previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Item Deserialize(BufferStream stream, Item instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Item DeserializeLengthDelimited(BufferStream stream, Item instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Item DeserializeLength(BufferStream stream, int length, Item instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Item instance, Item previous)
	{
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != previous.quantity)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
	}

	public static void Serialize(BufferStream stream, Item instance)
	{
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		if (instance.itemIsBlueprint)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Member : IDisposable, IPooled, IProto<Member>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public bool isOnline;

	[NonSerialized]
	public uint spawnTime;

	[NonSerialized]
	public bool isAlive;

	[NonSerialized]
	public uint deathTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Member instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.name = string.Empty;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
			Pool.Free<Member>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Member with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Member instance)
	{
		instance.steamId = steamId;
		instance.name = name;
		instance.x = x;
		instance.y = y;
		instance.isOnline = isOnline;
		instance.spawnTime = spawnTime;
		instance.isAlive = isAlive;
		instance.deathTime = deathTime;
	}

	public Member Copy()
	{
		Member member = Pool.Get<Member>();
		CopyTo(member);
		return member;
	}

	public static Member Deserialize(BufferStream stream)
	{
		Member member = Pool.Get<Member>();
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLengthDelimited(BufferStream stream)
	{
		Member member = Pool.Get<Member>();
		DeserializeLengthDelimited(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLength(BufferStream stream, int length)
	{
		Member member = Pool.Get<Member>();
		DeserializeLength(stream, length, member, isDelta: false);
		return member;
	}

	public static Member Deserialize(byte[] buffer)
	{
		Member member = Pool.Get<Member>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Member previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Member Deserialize(BufferStream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.isOnline = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.spawnTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.isAlive = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.deathTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Member DeserializeLengthDelimited(BufferStream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.isOnline = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.spawnTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.isAlive = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.deathTime = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Member DeserializeLength(BufferStream stream, int length, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.isOnline = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.spawnTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.isAlive = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.deathTime = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Member instance, Member previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.x != previous.x)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.isOnline);
		if (instance.spawnTime != previous.spawnTime)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.spawnTime);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.isAlive);
		if (instance.deathTime != previous.deathTime)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.deathTime);
		}
	}

	public static void Serialize(BufferStream stream, Member instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.x != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.isOnline)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isOnline);
		}
		if (instance.spawnTime != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.spawnTime);
		}
		if (instance.isAlive)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isAlive);
		}
		if (instance.deathTime != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.deathTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Note : IDisposable, IPooled, IProto<Note>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public int icon;

	[NonSerialized]
	public int colourIndex;

	[NonSerialized]
	public string label;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Note instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
			instance.label = string.Empty;
			Pool.Free<Note>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Note with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Note instance)
	{
		instance.type = type;
		instance.x = x;
		instance.y = y;
		instance.icon = icon;
		instance.colourIndex = colourIndex;
		instance.label = label;
	}

	public Note Copy()
	{
		Note note = Pool.Get<Note>();
		CopyTo(note);
		return note;
	}

	public static Note Deserialize(BufferStream stream)
	{
		Note note = Pool.Get<Note>();
		Deserialize(stream, note, isDelta: false);
		return note;
	}

	public static Note DeserializeLengthDelimited(BufferStream stream)
	{
		Note note = Pool.Get<Note>();
		DeserializeLengthDelimited(stream, note, isDelta: false);
		return note;
	}

	public static Note DeserializeLength(BufferStream stream, int length)
	{
		Note note = Pool.Get<Note>();
		DeserializeLength(stream, length, note, isDelta: false);
		return note;
	}

	public static Note Deserialize(byte[] buffer)
	{
		Note note = Pool.Get<Note>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, note, isDelta: false);
		return note;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Note previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Note Deserialize(BufferStream stream, Note instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Note DeserializeLengthDelimited(BufferStream stream, Note instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Note DeserializeLength(BufferStream stream, int length, Note instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Note instance, Note previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.x != previous.x)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.icon != previous.icon)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != previous.colourIndex)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null && instance.label != previous.label)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteString(stream, instance.label);
		}
	}

	public static void Serialize(BufferStream stream, Note instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.x != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.icon != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteString(stream, instance.label);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SellOrder : IDisposable, IPooled, IProto<SellOrder>, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public int quantity;

	[NonSerialized]
	public int currencyId;

	[NonSerialized]
	public int costPerItem;

	[NonSerialized]
	public int amountInStock;

	[NonSerialized]
	public bool itemIsBlueprint;

	[NonSerialized]
	public bool currencyIsBlueprint;

	[NonSerialized]
	public float itemCondition;

	[NonSerialized]
	public float itemConditionMax;

	[NonSerialized]
	public float priceMultiplier;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SellOrder instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
			Pool.Free<SellOrder>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SellOrder with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SellOrder instance)
	{
		instance.itemId = itemId;
		instance.quantity = quantity;
		instance.currencyId = currencyId;
		instance.costPerItem = costPerItem;
		instance.amountInStock = amountInStock;
		instance.itemIsBlueprint = itemIsBlueprint;
		instance.currencyIsBlueprint = currencyIsBlueprint;
		instance.itemCondition = itemCondition;
		instance.itemConditionMax = itemConditionMax;
		instance.priceMultiplier = priceMultiplier;
	}

	public SellOrder Copy()
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		CopyTo(sellOrder);
		return sellOrder;
	}

	public static SellOrder Deserialize(BufferStream stream)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		Deserialize(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder DeserializeLengthDelimited(BufferStream stream)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		DeserializeLengthDelimited(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder DeserializeLength(BufferStream stream, int length)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		DeserializeLength(stream, length, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder Deserialize(byte[] buffer)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SellOrder previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SellOrder Deserialize(BufferStream stream, SellOrder instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SellOrder DeserializeLengthDelimited(BufferStream stream, SellOrder instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SellOrder DeserializeLength(BufferStream stream, int length, SellOrder instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SellOrder instance, SellOrder previous)
	{
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != previous.quantity)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		if (instance.currencyId != previous.currencyId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
		}
		if (instance.costPerItem != previous.costPerItem)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
		}
		if (instance.amountInStock != previous.amountInStock)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
		if (instance.itemCondition != previous.itemCondition)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.itemCondition);
		}
		if (instance.itemConditionMax != previous.itemConditionMax)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
		}
		if (instance.priceMultiplier != previous.priceMultiplier)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
		}
	}

	public static void Serialize(BufferStream stream, SellOrder instance)
	{
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		if (instance.currencyId != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
		}
		if (instance.costPerItem != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
		}
		if (instance.amountInStock != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
		}
		if (instance.itemIsBlueprint)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		}
		if (instance.currencyIsBlueprint)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
		}
		if (instance.itemCondition != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.itemCondition);
		}
		if (instance.itemConditionMax != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
		}
		if (instance.priceMultiplier != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum EntityType
{
	Tree = 1,
	Player
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Entity : IDisposable, IPooled, IProto<Entity>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public EntityType type;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 rotation;

	[NonSerialized]
	public Vector3 size;

	[NonSerialized]
	public string name;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entity instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.type = (EntityType)0;
			instance.position = default(Vector3);
			instance.rotation = default(Vector3);
			instance.size = default(Vector3);
			instance.name = string.Empty;
			Pool.Free<Entity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entity instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.entityId = entityId;
		instance.type = type;
		instance.position = position;
		instance.rotation = rotation;
		instance.size = size;
		instance.name = name;
	}

	public Entity Copy()
	{
		Entity entity = Pool.Get<Entity>();
		CopyTo(entity);
		return entity;
	}

	public static Entity Deserialize(BufferStream stream)
	{
		Entity entity = Pool.Get<Entity>();
		Deserialize(stream, entity, isDelta: false);
		return entity;
	}

	public static Entity DeserializeLengthDelimited(BufferStream stream)
	{
		Entity entity = Pool.Get<Entity>();
		DeserializeLengthDelimited(stream, entity, isDelta: false);
		return entity;
	}

	public static Entity DeserializeLength(BufferStream stream, int length)
	{
		Entity entity = Pool.Get<Entity>();
		DeserializeLength(stream, length, entity, isDelta: false);
		return entity;
	}

	public static Entity Deserialize(byte[] buffer)
	{
		Entity entity = Pool.Get<Entity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entity, isDelta: false);
		return entity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Entity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entity Deserialize(BufferStream stream, Entity instance, bool isDelta)
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 50:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entity DeserializeLengthDelimited(BufferStream stream, Entity instance, bool isDelta)
	{
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 50:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entity DeserializeLength(BufferStream stream, int length, Entity instance, bool isDelta)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 50:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Entity instance, Entity previous)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.position != previous.position)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rotation, previous.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.size != previous.size)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.size, previous.size);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public static void Serialize(BufferStream stream, Entity instance)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.size != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.size);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.name != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Role : IDisposable, IPooled, IProto<Role>, IProto
{
	[NonSerialized]
	public int roleId;

	[NonSerialized]
	public int rank;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public bool canSetMotd;

	[NonSerialized]
	public bool canSetLogo;

	[NonSerialized]
	public bool canInvite;

	[NonSerialized]
	public bool canKick;

	[NonSerialized]
	public bool canPromote;

	[NonSerialized]
	public bool canDemote;

	[NonSerialized]
	public bool canSetPlayerNotes;

	[NonSerialized]
	public bool canAccessLogs;

	[NonSerialized]
	public bool canAccessScoreEvents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Role instance)
	{
		if (instance.ShouldPool)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.name = string.Empty;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
			Pool.Free<Role>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Role with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Role instance)
	{
		instance.roleId = roleId;
		instance.rank = rank;
		instance.name = name;
		instance.canSetMotd = canSetMotd;
		instance.canSetLogo = canSetLogo;
		instance.canInvite = canInvite;
		instance.canKick = canKick;
		instance.canPromote = canPromote;
		instance.canDemote = canDemote;
		instance.canSetPlayerNotes = canSetPlayerNotes;
		instance.canAccessLogs = canAccessLogs;
		instance.canAccessScoreEvents = canAccessScoreEvents;
	}

	public Role Copy()
	{
		Role role = Pool.Get<Role>();
		CopyTo(role);
		return role;
	}

	public static Role Deserialize(BufferStream stream)
	{
		Role role = Pool.Get<Role>();
		Deserialize(stream, role, isDelta: false);
		return role;
	}

	public static Role DeserializeLengthDelimited(BufferStream stream)
	{
		Role role = Pool.Get<Role>();
		DeserializeLengthDelimited(stream, role, isDelta: false);
		return role;
	}

	public static Role DeserializeLength(BufferStream stream, int length)
	{
		Role role = Pool.Get<Role>();
		DeserializeLength(stream, length, role, isDelta: false);
		return role;
	}

	public static Role Deserialize(byte[] buffer)
	{
		Role role = Pool.Get<Role>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, role, isDelta: false);
		return role;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Role previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Role Deserialize(BufferStream stream, Role instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rank = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.canSetMotd = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.canSetLogo = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.canInvite = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.canKick = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.canPromote = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.canDemote = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.canAccessLogs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Role DeserializeLengthDelimited(BufferStream stream, Role instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rank = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.canSetMotd = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.canSetLogo = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.canInvite = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.canKick = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.canPromote = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.canDemote = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.canAccessLogs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Role DeserializeLength(BufferStream stream, int length, Role instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rank = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.canSetMotd = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.canSetLogo = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.canInvite = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.canKick = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.canPromote = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.canDemote = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.canAccessLogs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Role instance, Role previous)
	{
		if (instance.roleId != previous.roleId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		if (instance.rank != previous.rank)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.canSetMotd);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.canSetLogo);
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.canInvite);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.canKick);
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.canPromote);
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.canDemote);
		stream.WriteByte(80);
		ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
		stream.WriteByte(88);
		ProtocolParser.WriteBool(stream, instance.canAccessLogs);
		stream.WriteByte(96);
		ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
	}

	public static void Serialize(BufferStream stream, Role instance)
	{
		if (instance.roleId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		if (instance.rank != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.canSetMotd)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.canSetMotd);
		}
		if (instance.canSetLogo)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.canSetLogo);
		}
		if (instance.canInvite)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.canInvite);
		}
		if (instance.canKick)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.canKick);
		}
		if (instance.canPromote)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.canPromote);
		}
		if (instance.canDemote)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.canDemote);
		}
		if (instance.canSetPlayerNotes)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
		}
		if (instance.canAccessLogs)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteBool(stream, instance.canAccessLogs);
		}
		if (instance.canAccessScoreEvents)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Member : IDisposable, IPooled, IProto<Member>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public int roleId;

	[NonSerialized]
	public long joined;

	[NonSerialized]
	public long lastSeen;

	[NonSerialized]
	public string notes;

	[NonSerialized]
	public bool online;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Member instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.notes = string.Empty;
			instance.online = false;
			Pool.Free<Member>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Member with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Member instance)
	{
		instance.steamId = steamId;
		instance.roleId = roleId;
		instance.joined = joined;
		instance.lastSeen = lastSeen;
		instance.notes = notes;
		instance.online = online;
	}

	public Member Copy()
	{
		Member member = Pool.Get<Member>();
		CopyTo(member);
		return member;
	}

	public static Member Deserialize(BufferStream stream)
	{
		Member member = Pool.Get<Member>();
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLengthDelimited(BufferStream stream)
	{
		Member member = Pool.Get<Member>();
		DeserializeLengthDelimited(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLength(BufferStream stream, int length)
	{
		Member member = Pool.Get<Member>();
		DeserializeLength(stream, length, member, isDelta: false);
		return member;
	}

	public static Member Deserialize(byte[] buffer)
	{
		Member member = Pool.Get<Member>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Member previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Member Deserialize(BufferStream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.online = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.joined = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Member DeserializeLengthDelimited(BufferStream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.online = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.joined = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Member DeserializeLength(BufferStream stream, int length, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.online = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.joined = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Member instance, Member previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.roleId != previous.roleId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
		if (instance.notes != null && instance.notes != previous.notes)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.notes);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.online);
	}

	public static void Serialize(BufferStream stream, Member instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.roleId != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		if (instance.joined != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
		}
		if (instance.lastSeen != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
		}
		if (instance.notes != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.notes);
		}
		if (instance.online)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.online);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Invite : IDisposable, IPooled, IProto<Invite>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public ulong recruiter;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Invite instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
			Pool.Free<Invite>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Invite with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Invite instance)
	{
		instance.steamId = steamId;
		instance.recruiter = recruiter;
		instance.timestamp = timestamp;
	}

	public Invite Copy()
	{
		Invite invite = Pool.Get<Invite>();
		CopyTo(invite);
		return invite;
	}

	public static Invite Deserialize(BufferStream stream)
	{
		Invite invite = Pool.Get<Invite>();
		Deserialize(stream, invite, isDelta: false);
		return invite;
	}

	public static Invite DeserializeLengthDelimited(BufferStream stream)
	{
		Invite invite = Pool.Get<Invite>();
		DeserializeLengthDelimited(stream, invite, isDelta: false);
		return invite;
	}

	public static Invite DeserializeLength(BufferStream stream, int length)
	{
		Invite invite = Pool.Get<Invite>();
		DeserializeLength(stream, length, invite, isDelta: false);
		return invite;
	}

	public static Invite Deserialize(byte[] buffer)
	{
		Invite invite = Pool.Get<Invite>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, invite, isDelta: false);
		return invite;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Invite previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Invite Deserialize(BufferStream stream, Invite instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Invite DeserializeLengthDelimited(BufferStream stream, Invite instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Invite DeserializeLength(BufferStream stream, int length, Invite instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Invite instance, Invite previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.recruiter != previous.recruiter)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, Invite instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.recruiter != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
{
	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public string eventKey;

	[NonSerialized]
	public string arg1;

	[NonSerialized]
	public string arg2;

	[NonSerialized]
	public string arg3;

	[NonSerialized]
	public string arg4;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entry instance)
	{
		if (instance.ShouldPool)
		{
			instance.timestamp = 0L;
			instance.eventKey = string.Empty;
			instance.arg1 = string.Empty;
			instance.arg2 = string.Empty;
			instance.arg3 = string.Empty;
			instance.arg4 = string.Empty;
			Pool.Free<Entry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entry instance)
	{
		instance.timestamp = timestamp;
		instance.eventKey = eventKey;
		instance.arg1 = arg1;
		instance.arg2 = arg2;
		instance.arg3 = arg3;
		instance.arg4 = arg4;
	}

	public Entry Copy()
	{
		Entry entry = Pool.Get<Entry>();
		CopyTo(entry);
		return entry;
	}

	public static Entry Deserialize(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLengthDelimited(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLength(BufferStream stream, int length)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLength(stream, length, entry, isDelta: false);
		return entry;
	}

	public static Entry Deserialize(byte[] buffer)
	{
		Entry entry = Pool.Get<Entry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.eventKey = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.arg3 = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.arg4 = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.eventKey = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.arg3 = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.arg4 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.eventKey = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.arg3 = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.arg4 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.eventKey != previous.eventKey)
		{
			if (instance.eventKey == null)
			{
				throw new ArgumentNullException("eventKey", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.eventKey);
		}
		if (instance.arg1 != null && instance.arg1 != previous.arg1)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null && instance.arg2 != previous.arg2)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
		if (instance.arg3 != null && instance.arg3 != previous.arg3)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.arg3);
		}
		if (instance.arg4 != null && instance.arg4 != previous.arg4)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.arg4);
		}
	}

	public static void Serialize(BufferStream stream, Entry instance)
	{
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.eventKey == null)
		{
			throw new ArgumentNullException("eventKey", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.eventKey);
		if (instance.arg1 != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
		if (instance.arg3 != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.arg3);
		}
		if (instance.arg4 != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.arg4);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
{
	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public int type;

	[NonSerialized]
	public int score;

	[NonSerialized]
	public int multiplier;

	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public ulong otherSteamId;

	[NonSerialized]
	public long otherClanId;

	[NonSerialized]
	public string arg1;

	[NonSerialized]
	public string arg2;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entry instance)
	{
		if (instance.ShouldPool)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
			instance.arg1 = string.Empty;
			instance.arg2 = string.Empty;
			Pool.Free<Entry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entry instance)
	{
		instance.timestamp = timestamp;
		instance.type = type;
		instance.score = score;
		instance.multiplier = multiplier;
		instance.steamId = steamId;
		instance.otherSteamId = otherSteamId;
		instance.otherClanId = otherClanId;
		instance.arg1 = arg1;
		instance.arg2 = arg2;
	}

	public Entry Copy()
	{
		Entry entry = Pool.Get<Entry>();
		CopyTo(entry);
		return entry;
	}

	public static Entry Deserialize(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLengthDelimited(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLength(BufferStream stream, int length)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLength(stream, length, entry, isDelta: false);
		return entry;
	}

	public static Entry Deserialize(byte[] buffer)
	{
		Entry entry = Pool.Get<Entry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 74:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 74:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 74:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.type != previous.type)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.score != previous.score)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
		if (instance.multiplier != previous.multiplier)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.otherSteamId != previous.otherSteamId)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
		if (instance.arg1 != null && instance.arg1 != previous.arg1)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null && instance.arg2 != previous.arg2)
		{
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
	}

	public static void Serialize(BufferStream stream, Entry instance)
	{
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.score != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
		if (instance.multiplier != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
		if (instance.steamId != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.otherSteamId != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
		}
		if (instance.otherClanId != 0L)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
		}
		if (instance.arg1 != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null)
		{
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Invitation : IDisposable, IPooled, IProto<Invitation>, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public ulong recruiter;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Invitation instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
			Pool.Free<Invitation>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Invitation with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Invitation instance)
	{
		instance.clanId = clanId;
		instance.recruiter = recruiter;
		instance.timestamp = timestamp;
	}

	public Invitation Copy()
	{
		Invitation invitation = Pool.Get<Invitation>();
		CopyTo(invitation);
		return invitation;
	}

	public static Invitation Deserialize(BufferStream stream)
	{
		Invitation invitation = Pool.Get<Invitation>();
		Deserialize(stream, invitation, isDelta: false);
		return invitation;
	}

	public static Invitation DeserializeLengthDelimited(BufferStream stream)
	{
		Invitation invitation = Pool.Get<Invitation>();
		DeserializeLengthDelimited(stream, invitation, isDelta: false);
		return invitation;
	}

	public static Invitation DeserializeLength(BufferStream stream, int length)
	{
		Invitation invitation = Pool.Get<Invitation>();
		DeserializeLength(stream, length, invitation, isDelta: false);
		return invitation;
	}

	public static Invitation Deserialize(byte[] buffer)
	{
		Invitation invitation = Pool.Get<Invitation>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, invitation, isDelta: false);
		return invitation;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Invitation previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Invitation Deserialize(BufferStream stream, Invitation instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Invitation DeserializeLengthDelimited(BufferStream stream, Invitation instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Invitation DeserializeLength(BufferStream stream, int length, Invitation instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Invitation instance, Invitation previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.recruiter != previous.recruiter)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, Invitation instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.recruiter != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public long score;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entry instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			instance.name = string.Empty;
			instance.score = 0L;
			Pool.Free<Entry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entry instance)
	{
		instance.clanId = clanId;
		instance.name = name;
		instance.score = score;
	}

	public Entry Copy()
	{
		Entry entry = Pool.Get<Entry>();
		CopyTo(entry);
		return entry;
	}

	public static Entry Deserialize(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLengthDelimited(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLength(BufferStream stream, int length)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLength(stream, length, entry, isDelta: false);
		return entry;
	}

	public static Entry Deserialize(byte[] buffer)
	{
		Entry entry = Pool.Get<Entry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.score = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.score = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.score = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
	}

	public static void Serialize(BufferStream stream, Entry instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.score != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class StoredBuriedItem : IDisposable, IPooled, IProto<StoredBuriedItem>, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public ItemOwnershipAmount ownership;

	[NonSerialized]
	public ulong skinId;

	[NonSerialized]
	public long expiryTimeDiff;

	[NonSerialized]
	public Vector2 location;

	[NonSerialized]
	public float condition;

	[NonSerialized]
	public ulong uid;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(StoredBuriedItem instance)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.itemId = 0;
			if (instance.ownership != null)
			{
				instance.ownership.ResetToPool();
				instance.ownership = null;
			}
			instance.skinId = 0uL;
			instance.expiryTimeDiff = 0L;
			instance.location = default(Vector2);
			instance.condition = 0f;
			instance.uid = 0uL;
			Pool.Free<StoredBuriedItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose StoredBuriedItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(StoredBuriedItem instance)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		instance.itemId = itemId;
		if (ownership != null)
		{
			if (instance.ownership == null)
			{
				instance.ownership = ownership.Copy();
			}
			else
			{
				ownership.CopyTo(instance.ownership);
			}
		}
		else
		{
			instance.ownership = null;
		}
		instance.skinId = skinId;
		instance.expiryTimeDiff = expiryTimeDiff;
		instance.location = location;
		instance.condition = condition;
		instance.uid = uid;
	}

	public StoredBuriedItem Copy()
	{
		StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
		CopyTo(storedBuriedItem);
		return storedBuriedItem;
	}

	public static StoredBuriedItem Deserialize(BufferStream stream)
	{
		StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
		Deserialize(stream, storedBuriedItem, isDelta: false);
		return storedBuriedItem;
	}

	public static StoredBuriedItem DeserializeLengthDelimited(BufferStream stream)
	{
		StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
		DeserializeLengthDelimited(stream, storedBuriedItem, isDelta: false);
		return storedBuriedItem;
	}

	public static StoredBuriedItem DeserializeLength(BufferStream stream, int length)
	{
		StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
		DeserializeLength(stream, length, storedBuriedItem, isDelta: false);
		return storedBuriedItem;
	}

	public static StoredBuriedItem Deserialize(byte[] buffer)
	{
		StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, storedBuriedItem, isDelta: false);
		return storedBuriedItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, StoredBuriedItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static StoredBuriedItem Deserialize(BufferStream stream, StoredBuriedItem instance, bool isDelta)
	{
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.ownership == null)
				{
					instance.ownership = ItemOwnershipAmount.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemOwnershipAmount.DeserializeLengthDelimited(stream, instance.ownership, isDelta);
				}
				break;
			case 24:
				instance.skinId = ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.expiryTimeDiff = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 42:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				break;
			case 53:
				instance.condition = ProtocolParser.ReadSingle(stream);
				break;
			case 56:
				instance.uid = ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static StoredBuriedItem DeserializeLengthDelimited(BufferStream stream, StoredBuriedItem instance, bool isDelta)
	{
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.ownership == null)
				{
					instance.ownership = ItemOwnershipAmount.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemOwnershipAmount.DeserializeLengthDelimited(stream, instance.ownership, isDelta);
				}
				break;
			case 24:
				instance.skinId = ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.expiryTimeDiff = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 42:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				break;
			case 53:
				instance.condition = ProtocolParser.ReadSingle(stream);
				break;
			case 56:
				instance.uid = ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static StoredBuriedItem DeserializeLength(BufferStream stream, int length, StoredBuriedItem instance, bool isDelta)
	{
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.ownership == null)
				{
					instance.ownership = ItemOwnershipAmount.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemOwnershipAmount.DeserializeLengthDelimited(stream, instance.ownership, isDelta);
				}
				break;
			case 24:
				instance.skinId = ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.expiryTimeDiff = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 42:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				break;
			case 53:
				instance.condition = ProtocolParser.ReadSingle(stream);
				break;
			case 56:
				instance.uid = ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, StoredBuriedItem instance, StoredBuriedItem previous)
	{
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.ownership != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemOwnershipAmount.SerializeDelta(stream, instance.ownership, previous.ownership);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.skinId != previous.skinId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.skinId);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.expiryTimeDiff);
		if (instance.location != previous.location)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector2Serialized.SerializeDelta(stream, instance.location, previous.location);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field location (UnityEngine.Vector2)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.condition != previous.condition)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.condition);
		}
		if (instance.uid != previous.uid)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.uid);
		}
	}

	public static void Serialize(BufferStream stream, StoredBuriedItem instance)
	{
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.ownership != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemOwnershipAmount.Serialize(stream, instance.ownership);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.skinId != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.skinId);
		}
		if (instance.expiryTimeDiff != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.expiryTimeDiff);
		}
		if (instance.location != default(Vector2))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector2Serialized.Serialize(stream, instance.location);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field location (UnityEngine.Vector2)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.condition != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.condition);
		}
		if (instance.uid != 0L)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.uid);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		ownership?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Private : IDisposable, IPooled, IProto<Private>, IProto
{
	[NonSerialized]
	public List<ItemContainer> container;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Private instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.container != null)
		{
			for (int i = 0; i < instance.container.Count; i++)
			{
				if (instance.container[i] != null)
				{
					instance.container[i].ResetToPool();
					instance.container[i] = null;
				}
			}
			List<ItemContainer> list = instance.container;
			Pool.Free<ItemContainer>(ref list, false);
			instance.container = list;
		}
		Pool.Free<Private>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Private with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Private instance)
	{
		if (container != null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
			for (int i = 0; i < container.Count; i++)
			{
				ItemContainer item = container[i].Copy();
				instance.container.Add(item);
			}
		}
		else
		{
			instance.container = null;
		}
	}

	public Private Copy()
	{
		Private @private = Pool.Get<Private>();
		CopyTo(@private);
		return @private;
	}

	public static Private Deserialize(BufferStream stream)
	{
		Private @private = Pool.Get<Private>();
		Deserialize(stream, @private, isDelta: false);
		return @private;
	}

	public static Private DeserializeLengthDelimited(BufferStream stream)
	{
		Private @private = Pool.Get<Private>();
		DeserializeLengthDelimited(stream, @private, isDelta: false);
		return @private;
	}

	public static Private DeserializeLength(BufferStream stream, int length)
	{
		Private @private = Pool.Get<Private>();
		DeserializeLength(stream, length, @private, isDelta: false);
		return @private;
	}

	public static Private Deserialize(byte[] buffer)
	{
		Private @private = Pool.Get<Private>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, @private, isDelta: false);
		return @private;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Private previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Private Deserialize(BufferStream stream, Private instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Private DeserializeLengthDelimited(BufferStream stream, Private instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Private DeserializeLength(BufferStream stream, int length, Private instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Private instance, Private previous)
	{
		if (instance.container == null)
		{
			return;
		}
		for (int i = 0; i < instance.container.Count; i++)
		{
			ItemContainer itemContainer = instance.container[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, itemContainer, itemContainer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, Private instance)
	{
		if (instance.container == null)
		{
			return;
		}
		for (int i = 0; i < instance.container.Count; i++)
		{
			ItemContainer instance2 = instance.container[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (container != null)
		{
			for (int i = 0; i < container.Count; i++)
			{
				container[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Private : IDisposable, IPooled, IProto<Private>, IProto
{
	[NonSerialized]
	public string code;

	[NonSerialized]
	public List<ulong> users;

	[NonSerialized]
	public string guestCode;

	[NonSerialized]
	public List<ulong> guestUsers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Private instance)
	{
		if (instance.ShouldPool)
		{
			instance.code = string.Empty;
			if (instance.users != null)
			{
				List<ulong> list = instance.users;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.users = list;
			}
			instance.guestCode = string.Empty;
			if (instance.guestUsers != null)
			{
				List<ulong> list2 = instance.guestUsers;
				Pool.FreeUnmanaged<ulong>(ref list2);
				instance.guestUsers = list2;
			}
			Pool.Free<Private>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Private with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Private instance)
	{
		instance.code = code;
		if (users != null)
		{
			instance.users = Pool.Get<List<ulong>>();
			for (int i = 0; i < users.Count; i++)
			{
				ulong item = users[i];
				instance.users.Add(item);
			}
		}
		else
		{
			instance.users = null;
		}
		instance.guestCode = guestCode;
		if (guestUsers != null)
		{
			instance.guestUsers = Pool.Get<List<ulong>>();
			for (int j = 0; j < guestUsers.Count; j++)
			{
				ulong item2 = guestUsers[j];
				instance.guestUsers.Add(item2);
			}
		}
		else
		{
			instance.guestUsers = null;
		}
	}

	public Private Copy()
	{
		Private @private = Pool.Get<Private>();
		CopyTo(@private);
		return @private;
	}

	public static Private Deserialize(BufferStream stream)
	{
		Private @private = Pool.Get<Private>();
		Deserialize(stream, @private, isDelta: false);
		return @private;
	}

	public static Private DeserializeLengthDelimited(BufferStream stream)
	{
		Private @private = Pool.Get<Private>();
		DeserializeLengthDelimited(stream, @private, isDelta: false);
		return @private;
	}

	public static Private DeserializeLength(BufferStream stream, int length)
	{
		Private @private = Pool.Get<Private>();
		DeserializeLength(stream, length, @private, isDelta: false);
		return @private;
	}

	public static Private Deserialize(byte[] buffer)
	{
		Private @private = Pool.Get<Private>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, @private, isDelta: false);
		return @private;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Private previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Private Deserialize(BufferStream stream, Private instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.users == null)
			{
				instance.users = Pool.Get<List<ulong>>();
			}
			if (instance.guestUsers == null)
			{
				instance.guestUsers = Pool.Get<List<ulong>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.code = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.users.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.guestCode = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.guestUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Private DeserializeLengthDelimited(BufferStream stream, Private instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.users == null)
			{
				instance.users = Pool.Get<List<ulong>>();
			}
			if (instance.guestUsers == null)
			{
				instance.guestUsers = Pool.Get<List<ulong>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.code = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.users.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.guestCode = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.guestUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Private DeserializeLength(BufferStream stream, int length, Private instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.users == null)
			{
				instance.users = Pool.Get<List<ulong>>();
			}
			if (instance.guestUsers == null)
			{
				instance.guestUsers = Pool.Get<List<ulong>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.code = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.users.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.guestCode = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.guestUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Private instance, Private previous)
	{
		if (instance.code != null && instance.code != previous.code)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.code);
		}
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				ulong val = instance.users[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.guestCode != null && instance.guestCode != previous.guestCode)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.guestCode);
		}
		if (instance.guestUsers != null)
		{
			for (int j = 0; j < instance.guestUsers.Count; j++)
			{
				ulong val2 = instance.guestUsers[j];
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public static void Serialize(BufferStream stream, Private instance)
	{
		if (instance.code != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.code);
		}
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				ulong val = instance.users[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.guestCode != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.guestCode);
		}
		if (instance.guestUsers != null)
		{
			for (int j = 0; j < instance.guestUsers.Count; j++)
			{
				ulong val2 = instance.guestUsers[j];
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SpawnedEnt : IDisposable, IPooled, IProto<SpawnedEnt>, IProto
{
	[NonSerialized]
	public uint uid;

	[NonSerialized]
	public uint spawnPointIndex;

	[NonSerialized]
	public bool mobile;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpawnedEnt instance)
	{
		if (instance.ShouldPool)
		{
			instance.uid = 0u;
			instance.spawnPointIndex = 0u;
			instance.mobile = false;
			Pool.Free<SpawnedEnt>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpawnedEnt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpawnedEnt instance)
	{
		instance.uid = uid;
		instance.spawnPointIndex = spawnPointIndex;
		instance.mobile = mobile;
	}

	public SpawnedEnt Copy()
	{
		SpawnedEnt spawnedEnt = Pool.Get<SpawnedEnt>();
		CopyTo(spawnedEnt);
		return spawnedEnt;
	}

	public static SpawnedEnt Deserialize(BufferStream stream)
	{
		SpawnedEnt spawnedEnt = Pool.Get<SpawnedEnt>();
		Deserialize(stream, spawnedEnt, isDelta: false);
		return spawnedEnt;
	}

	public static SpawnedEnt DeserializeLengthDelimited(BufferStream stream)
	{
		SpawnedEnt spawnedEnt = Pool.Get<SpawnedEnt>();
		DeserializeLengthDelimited(stream, spawnedEnt, isDelta: false);
		return spawnedEnt;
	}

	public static SpawnedEnt DeserializeLength(BufferStream stream, int length)
	{
		SpawnedEnt spawnedEnt = Pool.Get<SpawnedEnt>();
		DeserializeLength(stream, length, spawnedEnt, isDelta: false);
		return spawnedEnt;
	}

	public static SpawnedEnt Deserialize(byte[] buffer)
	{
		SpawnedEnt spawnedEnt = Pool.Get<SpawnedEnt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spawnedEnt, isDelta: false);
		return spawnedEnt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpawnedEnt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpawnedEnt Deserialize(BufferStream stream, SpawnedEnt instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.uid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.spawnPointIndex = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpawnedEnt DeserializeLengthDelimited(BufferStream stream, SpawnedEnt instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.spawnPointIndex = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpawnedEnt DeserializeLength(BufferStream stream, int length, SpawnedEnt instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.spawnPointIndex = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpawnedEnt instance, SpawnedEnt previous)
	{
		if (instance.uid != previous.uid)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.uid);
		}
		if (instance.spawnPointIndex != previous.spawnPointIndex)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.spawnPointIndex);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.mobile);
	}

	public static void Serialize(BufferStream stream, SpawnedEnt instance)
	{
		if (instance.uid != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.uid);
		}
		if (instance.spawnPointIndex != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.spawnPointIndex);
		}
		if (instance.mobile)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.mobile);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class MountPoint : IDisposable, IPooled, IProto<MountPoint>, IProto
{
	[NonSerialized]
	public int index;

	[NonSerialized]
	public NetworkableId mountableId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MountPoint instance)
	{
		if (instance.ShouldPool)
		{
			instance.index = 0;
			instance.mountableId = default(NetworkableId);
			Pool.Free<MountPoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MountPoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MountPoint instance)
	{
		instance.index = index;
		instance.mountableId = mountableId;
	}

	public MountPoint Copy()
	{
		MountPoint mountPoint = Pool.Get<MountPoint>();
		CopyTo(mountPoint);
		return mountPoint;
	}

	public static MountPoint Deserialize(BufferStream stream)
	{
		MountPoint mountPoint = Pool.Get<MountPoint>();
		Deserialize(stream, mountPoint, isDelta: false);
		return mountPoint;
	}

	public static MountPoint DeserializeLengthDelimited(BufferStream stream)
	{
		MountPoint mountPoint = Pool.Get<MountPoint>();
		DeserializeLengthDelimited(stream, mountPoint, isDelta: false);
		return mountPoint;
	}

	public static MountPoint DeserializeLength(BufferStream stream, int length)
	{
		MountPoint mountPoint = Pool.Get<MountPoint>();
		DeserializeLength(stream, length, mountPoint, isDelta: false);
		return mountPoint;
	}

	public static MountPoint Deserialize(byte[] buffer)
	{
		MountPoint mountPoint = Pool.Get<MountPoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mountPoint, isDelta: false);
		return mountPoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MountPoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MountPoint Deserialize(BufferStream stream, MountPoint instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.mountableId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MountPoint DeserializeLengthDelimited(BufferStream stream, MountPoint instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.mountableId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MountPoint DeserializeLength(BufferStream stream, int length, MountPoint instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.mountableId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MountPoint instance, MountPoint previous)
	{
		if (instance.index != previous.index)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.mountableId.Value);
	}

	public static void Serialize(BufferStream stream, MountPoint instance)
	{
		if (instance.index != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
		if (instance.mountableId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.mountableId.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref mountableId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SellOrder : IDisposable, IPooled, IProto<SellOrder>, IProto
{
	[NonSerialized]
	public int itemToSellID;

	[NonSerialized]
	public int itemToSellAmount;

	[NonSerialized]
	public int currencyID;

	[NonSerialized]
	public int currencyAmountPerItem;

	[NonSerialized]
	public int inStock;

	[NonSerialized]
	public bool currencyIsBP;

	[NonSerialized]
	public bool itemToSellIsBP;

	[NonSerialized]
	public float itemCondition;

	[NonSerialized]
	public float itemConditionMax;

	[NonSerialized]
	public int instanceData;

	[NonSerialized]
	public List<int> attachmentsList;

	[NonSerialized]
	public int totalAttachmentSlots;

	[NonSerialized]
	public float priceMultiplier;

	[NonSerialized]
	public int ammoType;

	[NonSerialized]
	public int ammoCount;

	[NonSerialized]
	public float receivedQuantityMultiplier;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SellOrder instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemToSellID = 0;
			instance.itemToSellAmount = 0;
			instance.currencyID = 0;
			instance.currencyAmountPerItem = 0;
			instance.inStock = 0;
			instance.currencyIsBP = false;
			instance.itemToSellIsBP = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.instanceData = 0;
			if (instance.attachmentsList != null)
			{
				List<int> list = instance.attachmentsList;
				Pool.FreeUnmanaged<int>(ref list);
				instance.attachmentsList = list;
			}
			instance.totalAttachmentSlots = 0;
			instance.priceMultiplier = 0f;
			instance.ammoType = 0;
			instance.ammoCount = 0;
			instance.receivedQuantityMultiplier = 0f;
			Pool.Free<SellOrder>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SellOrder with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SellOrder instance)
	{
		instance.itemToSellID = itemToSellID;
		instance.itemToSellAmount = itemToSellAmount;
		instance.currencyID = currencyID;
		instance.currencyAmountPerItem = currencyAmountPerItem;
		instance.inStock = inStock;
		instance.currencyIsBP = currencyIsBP;
		instance.itemToSellIsBP = itemToSellIsBP;
		instance.itemCondition = itemCondition;
		instance.itemConditionMax = itemConditionMax;
		instance.instanceData = instanceData;
		if (attachmentsList != null)
		{
			instance.attachmentsList = Pool.Get<List<int>>();
			for (int i = 0; i < attachmentsList.Count; i++)
			{
				int item = attachmentsList[i];
				instance.attachmentsList.Add(item);
			}
		}
		else
		{
			instance.attachmentsList = null;
		}
		instance.totalAttachmentSlots = totalAttachmentSlots;
		instance.priceMultiplier = priceMultiplier;
		instance.ammoType = ammoType;
		instance.ammoCount = ammoCount;
		instance.receivedQuantityMultiplier = receivedQuantityMultiplier;
	}

	public SellOrder Copy()
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		CopyTo(sellOrder);
		return sellOrder;
	}

	public static SellOrder Deserialize(BufferStream stream)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		Deserialize(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder DeserializeLengthDelimited(BufferStream stream)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		DeserializeLengthDelimited(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder DeserializeLength(BufferStream stream, int length)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		DeserializeLength(stream, length, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder Deserialize(byte[] buffer)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SellOrder previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SellOrder Deserialize(BufferStream stream, SellOrder instance, bool isDelta)
	{
		if (!isDelta && instance.attachmentsList == null)
		{
			instance.attachmentsList = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemToSellID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemToSellAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.currencyAmountPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.inStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.currencyIsBP = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.itemToSellIsBP = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.instanceData = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.attachmentsList.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.totalAttachmentSlots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 109:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 112:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 120:
				instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Fixed32)
				{
					instance.receivedQuantityMultiplier = ProtocolParser.ReadSingle(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static SellOrder DeserializeLengthDelimited(BufferStream stream, SellOrder instance, bool isDelta)
	{
		if (!isDelta && instance.attachmentsList == null)
		{
			instance.attachmentsList = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemToSellID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemToSellAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.currencyAmountPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.inStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.currencyIsBP = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.itemToSellIsBP = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.instanceData = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.attachmentsList.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.totalAttachmentSlots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 109:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 112:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 120:
				instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Fixed32)
				{
					instance.receivedQuantityMultiplier = ProtocolParser.ReadSingle(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SellOrder DeserializeLength(BufferStream stream, int length, SellOrder instance, bool isDelta)
	{
		if (!isDelta && instance.attachmentsList == null)
		{
			instance.attachmentsList = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemToSellID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemToSellAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.currencyAmountPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.inStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.currencyIsBP = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.itemToSellIsBP = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.instanceData = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.attachmentsList.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.totalAttachmentSlots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 109:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 112:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 120:
				instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Fixed32)
				{
					instance.receivedQuantityMultiplier = ProtocolParser.ReadSingle(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SellOrder instance, SellOrder previous)
	{
		if (instance.itemToSellID != previous.itemToSellID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellID);
		}
		if (instance.itemToSellAmount != previous.itemToSellAmount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellAmount);
		}
		if (instance.currencyID != previous.currencyID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyID);
		}
		if (instance.currencyAmountPerItem != previous.currencyAmountPerItem)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyAmountPerItem);
		}
		if (instance.inStock != previous.inStock)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inStock);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.currencyIsBP);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.itemToSellIsBP);
		if (instance.itemCondition != previous.itemCondition)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.itemCondition);
		}
		if (instance.itemConditionMax != previous.itemConditionMax)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
		}
		if (instance.instanceData != previous.instanceData)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.instanceData);
		}
		if (instance.attachmentsList != null)
		{
			for (int i = 0; i < instance.attachmentsList.Count; i++)
			{
				int num = instance.attachmentsList[i];
				stream.WriteByte(88);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.totalAttachmentSlots != previous.totalAttachmentSlots)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAttachmentSlots);
		}
		if (instance.priceMultiplier != previous.priceMultiplier)
		{
			stream.WriteByte(109);
			ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
		}
		if (instance.ammoType != previous.ammoType)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
		if (instance.ammoCount != previous.ammoCount)
		{
			stream.WriteByte(120);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
		}
		if (instance.receivedQuantityMultiplier != previous.receivedQuantityMultiplier)
		{
			stream.WriteByte(133);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.receivedQuantityMultiplier);
		}
	}

	public static void Serialize(BufferStream stream, SellOrder instance)
	{
		if (instance.itemToSellID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellID);
		}
		if (instance.itemToSellAmount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellAmount);
		}
		if (instance.currencyID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyID);
		}
		if (instance.currencyAmountPerItem != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyAmountPerItem);
		}
		if (instance.inStock != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inStock);
		}
		if (instance.currencyIsBP)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.currencyIsBP);
		}
		if (instance.itemToSellIsBP)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.itemToSellIsBP);
		}
		if (instance.itemCondition != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.itemCondition);
		}
		if (instance.itemConditionMax != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
		}
		if (instance.instanceData != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.instanceData);
		}
		if (instance.attachmentsList != null)
		{
			for (int i = 0; i < instance.attachmentsList.Count; i++)
			{
				int num = instance.attachmentsList[i];
				stream.WriteByte(88);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.totalAttachmentSlots != 0)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAttachmentSlots);
		}
		if (instance.priceMultiplier != 0f)
		{
			stream.WriteByte(109);
			ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
		}
		if (instance.ammoType != 0)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
		if (instance.ammoCount != 0)
		{
			stream.WriteByte(120);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
		}
		if (instance.receivedQuantityMultiplier != 0f)
		{
			stream.WriteByte(133);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.receivedQuantityMultiplier);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SellOrderContainer : IDisposable, IPooled, IProto<SellOrderContainer>, IProto
{
	[NonSerialized]
	public List<SellOrder> sellOrders;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SellOrderContainer instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.sellOrders != null)
		{
			for (int i = 0; i < instance.sellOrders.Count; i++)
			{
				if (instance.sellOrders[i] != null)
				{
					instance.sellOrders[i].ResetToPool();
					instance.sellOrders[i] = null;
				}
			}
			List<SellOrder> list = instance.sellOrders;
			Pool.Free<SellOrder>(ref list, false);
			instance.sellOrders = list;
		}
		Pool.Free<SellOrderContainer>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SellOrderContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SellOrderContainer instance)
	{
		if (sellOrders != null)
		{
			instance.sellOrders = Pool.Get<List<SellOrder>>();
			for (int i = 0; i < sellOrders.Count; i++)
			{
				SellOrder item = sellOrders[i].Copy();
				instance.sellOrders.Add(item);
			}
		}
		else
		{
			instance.sellOrders = null;
		}
	}

	public SellOrderContainer Copy()
	{
		SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
		CopyTo(sellOrderContainer);
		return sellOrderContainer;
	}

	public static SellOrderContainer Deserialize(BufferStream stream)
	{
		SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
		Deserialize(stream, sellOrderContainer, isDelta: false);
		return sellOrderContainer;
	}

	public static SellOrderContainer DeserializeLengthDelimited(BufferStream stream)
	{
		SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
		DeserializeLengthDelimited(stream, sellOrderContainer, isDelta: false);
		return sellOrderContainer;
	}

	public static SellOrderContainer DeserializeLength(BufferStream stream, int length)
	{
		SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
		DeserializeLength(stream, length, sellOrderContainer, isDelta: false);
		return sellOrderContainer;
	}

	public static SellOrderContainer Deserialize(byte[] buffer)
	{
		SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sellOrderContainer, isDelta: false);
		return sellOrderContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SellOrderContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SellOrderContainer Deserialize(BufferStream stream, SellOrderContainer instance, bool isDelta)
	{
		if (!isDelta && instance.sellOrders == null)
		{
			instance.sellOrders = Pool.Get<List<SellOrder>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SellOrderContainer DeserializeLengthDelimited(BufferStream stream, SellOrderContainer instance, bool isDelta)
	{
		if (!isDelta && instance.sellOrders == null)
		{
			instance.sellOrders = Pool.Get<List<SellOrder>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SellOrderContainer DeserializeLength(BufferStream stream, int length, SellOrderContainer instance, bool isDelta)
	{
		if (!isDelta && instance.sellOrders == null)
		{
			instance.sellOrders = Pool.Get<List<SellOrder>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SellOrderContainer instance, SellOrderContainer previous)
	{
		if (instance.sellOrders == null)
		{
			return;
		}
		for (int i = 0; i < instance.sellOrders.Count; i++)
		{
			SellOrder sellOrder = instance.sellOrders[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			SellOrder.SerializeDelta(stream, sellOrder, sellOrder);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.VendingMachine.SellOrder)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, SellOrderContainer instance)
	{
		if (instance.sellOrders == null)
		{
			return;
		}
		for (int i = 0; i < instance.sellOrders.Count; i++)
		{
			SellOrder instance2 = instance.sellOrders[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			SellOrder.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.VendingMachine.SellOrder)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (sellOrders != null)
		{
			for (int i = 0; i < sellOrders.Count; i++)
			{
				sellOrders[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class IOConnection : IDisposable, IPooled, IProto<IOConnection>, IProto
{
	public class LineVec : IDisposable, IPooled, IProto<LineVec>, IProto
	{
		[NonSerialized]
		public Vector4 vec;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(LineVec instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.vec = default(Vector4);
				Pool.Free<LineVec>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose LineVec with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(LineVec instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			instance.vec = vec;
		}

		public LineVec Copy()
		{
			LineVec lineVec = Pool.Get<LineVec>();
			CopyTo(lineVec);
			return lineVec;
		}

		public static LineVec Deserialize(BufferStream stream)
		{
			LineVec lineVec = Pool.Get<LineVec>();
			Deserialize(stream, lineVec, isDelta: false);
			return lineVec;
		}

		public static LineVec DeserializeLengthDelimited(BufferStream stream)
		{
			LineVec lineVec = Pool.Get<LineVec>();
			DeserializeLengthDelimited(stream, lineVec, isDelta: false);
			return lineVec;
		}

		public static LineVec DeserializeLength(BufferStream stream, int length)
		{
			LineVec lineVec = Pool.Get<LineVec>();
			DeserializeLength(stream, length, lineVec, isDelta: false);
			return lineVec;
		}

		public static LineVec Deserialize(byte[] buffer)
		{
			LineVec lineVec = Pool.Get<LineVec>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, lineVec, isDelta: false);
			return lineVec;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, LineVec previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static LineVec Deserialize(BufferStream stream, LineVec instance, bool isDelta)
		{
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static LineVec DeserializeLengthDelimited(BufferStream stream, LineVec instance, bool isDelta)
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static LineVec DeserializeLength(BufferStream stream, int length, LineVec instance, bool isDelta)
		{
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, LineVec instance, LineVec previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			if (instance.vec != previous.vec)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.vec, previous.vec);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}

		public static void Serialize(BufferStream stream, LineVec instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			if (instance.vec != default(Vector4))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector4Serialized.Serialize(stream, instance.vec);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class LinePointList : IDisposable, IPooled, IProto<LinePointList>, IProto
	{
		[NonSerialized]
		public Vector4 a;

		[NonSerialized]
		public Vector4 b;

		[NonSerialized]
		public Vector4 c;

		[NonSerialized]
		public Vector4 d;

		[NonSerialized]
		public Vector4 e;

		[NonSerialized]
		public Vector4 f;

		[NonSerialized]
		public Vector4 g;

		[NonSerialized]
		public Vector4 h;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(LinePointList instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.a = default(Vector4);
				instance.b = default(Vector4);
				instance.c = default(Vector4);
				instance.d = default(Vector4);
				instance.e = default(Vector4);
				instance.f = default(Vector4);
				instance.g = default(Vector4);
				instance.h = default(Vector4);
				Pool.Free<LinePointList>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose LinePointList with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(LinePointList instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			instance.a = a;
			instance.b = b;
			instance.c = c;
			instance.d = d;
			instance.e = e;
			instance.f = f;
			instance.g = g;
			instance.h = h;
		}

		public LinePointList Copy()
		{
			LinePointList linePointList = Pool.Get<LinePointList>();
			CopyTo(linePointList);
			return linePointList;
		}

		public static LinePointList Deserialize(BufferStream stream)
		{
			LinePointList linePointList = Pool.Get<LinePointList>();
			Deserialize(stream, linePointList, isDelta: false);
			return linePointList;
		}

		public static LinePointList DeserializeLengthDelimited(BufferStream stream)
		{
			LinePointList linePointList = Pool.Get<LinePointList>();
			DeserializeLengthDelimited(stream, linePointList, isDelta: false);
			return linePointList;
		}

		public static LinePointList DeserializeLength(BufferStream stream, int length)
		{
			LinePointList linePointList = Pool.Get<LinePointList>();
			DeserializeLength(stream, length, linePointList, isDelta: false);
			return linePointList;
		}

		public static LinePointList Deserialize(byte[] buffer)
		{
			LinePointList linePointList = Pool.Get<LinePointList>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, linePointList, isDelta: false);
			return linePointList;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, LinePointList previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static LinePointList Deserialize(BufferStream stream, LinePointList instance, bool isDelta)
		{
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
					continue;
				case 18:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
					continue;
				case 26:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
					continue;
				case 34:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
					continue;
				case 42:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
					continue;
				case 50:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
					continue;
				case 58:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
					continue;
				case 66:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static LinePointList DeserializeLengthDelimited(BufferStream stream, LinePointList instance, bool isDelta)
		{
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
					continue;
				case 18:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
					continue;
				case 26:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
					continue;
				case 34:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
					continue;
				case 42:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
					continue;
				case 50:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
					continue;
				case 58:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
					continue;
				case 66:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static LinePointList DeserializeLength(BufferStream stream, int length, LinePointList instance, bool isDelta)
		{
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
					continue;
				case 18:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
					continue;
				case 26:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
					continue;
				case 34:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
					continue;
				case 42:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
					continue;
				case 50:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
					continue;
				case 58:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
					continue;
				case 66:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, LinePointList instance, LinePointList previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_013c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0169: Unknown result type (might be due to invalid IL or missing references)
			//IL_0208: Unknown result type (might be due to invalid IL or missing references)
			//IL_020e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0271: Unknown result type (might be due to invalid IL or missing references)
			//IL_0277: Unknown result type (might be due to invalid IL or missing references)
			//IL_0235: Unknown result type (might be due to invalid IL or missing references)
			//IL_023b: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_029e: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0307: Unknown result type (might be due to invalid IL or missing references)
			//IL_030d: Unknown result type (might be due to invalid IL or missing references)
			if (instance.a != previous.a)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.a, previous.a);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.b != previous.b)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.b, previous.b);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.c != previous.c)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.c, previous.c);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
			if (instance.d != previous.d)
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.d, previous.d);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
			if (instance.e != previous.e)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range5 = stream.GetRange(1);
				int position5 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.e, previous.e);
				int num5 = stream.Position - position5;
				if (num5 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
				}
				Span<byte> span5 = range5.GetSpan();
				ProtocolParser.WriteUInt32((uint)num5, span5, 0);
			}
			if (instance.f != previous.f)
			{
				stream.WriteByte(50);
				BufferStream.RangeHandle range6 = stream.GetRange(1);
				int position6 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.f, previous.f);
				int num6 = stream.Position - position6;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
				}
				Span<byte> span6 = range6.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span6, 0);
			}
			if (instance.g != previous.g)
			{
				stream.WriteByte(58);
				BufferStream.RangeHandle range7 = stream.GetRange(1);
				int position7 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.g, previous.g);
				int num7 = stream.Position - position7;
				if (num7 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
				}
				Span<byte> span7 = range7.GetSpan();
				ProtocolParser.WriteUInt32((uint)num7, span7, 0);
			}
			if (instance.h != previous.h)
			{
				stream.WriteByte(66);
				BufferStream.RangeHandle range8 = stream.GetRange(1);
				int position8 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.h, previous.h);
				int num8 = stream.Position - position8;
				if (num8 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
				}
				Span<byte> span8 = range8.GetSpan();
				ProtocolParser.WriteUInt32((uint)num8, span8, 0);
			}
		}

		public static void Serialize(BufferStream stream, LinePointList instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_012e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0194: Unknown result type (might be due to invalid IL or missing references)
			//IL_019b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_015e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0207: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0260: Unknown result type (might be due to invalid IL or missing references)
			//IL_0267: Unknown result type (might be due to invalid IL or missing references)
			//IL_026d: Unknown result type (might be due to invalid IL or missing references)
			//IL_022a: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0290: Unknown result type (might be due to invalid IL or missing references)
			//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
			if (instance.a != default(Vector4))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector4Serialized.Serialize(stream, instance.a);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.b != default(Vector4))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.b);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.c != default(Vector4))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.c);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
			if (instance.d != default(Vector4))
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.d);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
			if (instance.e != default(Vector4))
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range5 = stream.GetRange(1);
				int position5 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.e);
				int num5 = stream.Position - position5;
				if (num5 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
				}
				Span<byte> span5 = range5.GetSpan();
				ProtocolParser.WriteUInt32((uint)num5, span5, 0);
			}
			if (instance.f != default(Vector4))
			{
				stream.WriteByte(50);
				BufferStream.RangeHandle range6 = stream.GetRange(1);
				int position6 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.f);
				int num6 = stream.Position - position6;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
				}
				Span<byte> span6 = range6.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span6, 0);
			}
			if (instance.g != default(Vector4))
			{
				stream.WriteByte(58);
				BufferStream.RangeHandle range7 = stream.GetRange(1);
				int position7 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.g);
				int num7 = stream.Position - position7;
				if (num7 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
				}
				Span<byte> span7 = range7.GetSpan();
				ProtocolParser.WriteUInt32((uint)num7, span7, 0);
			}
			if (instance.h != default(Vector4))
			{
				stream.WriteByte(66);
				BufferStream.RangeHandle range8 = stream.GetRange(1);
				int position8 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.h);
				int num8 = stream.Position - position8;
				if (num8 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
				}
				Span<byte> span8 = range8.GetSpan();
				ProtocolParser.WriteUInt32((uint)num8, span8, 0);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public string niceName;

	[NonSerialized]
	public int type;

	[NonSerialized]
	public NetworkableId connectedID;

	[NonSerialized]
	public int connectedToSlot;

	[NonSerialized]
	public bool inUse;

	[NonSerialized]
	public List<LineVec> linePointList;

	[NonSerialized]
	public int colour;

	[NonSerialized]
	public Vector3 worldSpaceRotation;

	[NonSerialized]
	public float lineThickness;

	[NonSerialized]
	public List<WireLineAnchorInfo> lineAnchorList;

	[NonSerialized]
	public Vector3 originPosition;

	[NonSerialized]
	public Vector3 originRotation;

	[NonSerialized]
	public List<float> slackLevels;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(IOConnection instance)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.niceName = string.Empty;
		instance.type = 0;
		instance.connectedID = default(NetworkableId);
		instance.connectedToSlot = 0;
		instance.inUse = false;
		if (instance.linePointList != null)
		{
			for (int i = 0; i < instance.linePointList.Count; i++)
			{
				if (instance.linePointList[i] != null)
				{
					instance.linePointList[i].ResetToPool();
					instance.linePointList[i] = null;
				}
			}
			List<LineVec> list = instance.linePointList;
			Pool.Free<LineVec>(ref list, false);
			instance.linePointList = list;
		}
		instance.colour = 0;
		instance.worldSpaceRotation = default(Vector3);
		instance.lineThickness = 0f;
		if (instance.lineAnchorList != null)
		{
			for (int j = 0; j < instance.lineAnchorList.Count; j++)
			{
				if (instance.lineAnchorList[j] != null)
				{
					instance.lineAnchorList[j].ResetToPool();
					instance.lineAnchorList[j] = null;
				}
			}
			List<WireLineAnchorInfo> list2 = instance.lineAnchorList;
			Pool.Free<WireLineAnchorInfo>(ref list2, false);
			instance.lineAnchorList = list2;
		}
		instance.originPosition = default(Vector3);
		instance.originRotation = default(Vector3);
		if (instance.slackLevels != null)
		{
			List<float> list3 = instance.slackLevels;
			Pool.FreeUnmanaged<float>(ref list3);
			instance.slackLevels = list3;
		}
		Pool.Free<IOConnection>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose IOConnection with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(IOConnection instance)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		instance.niceName = niceName;
		instance.type = type;
		instance.connectedID = connectedID;
		instance.connectedToSlot = connectedToSlot;
		instance.inUse = inUse;
		if (linePointList != null)
		{
			instance.linePointList = Pool.Get<List<LineVec>>();
			for (int i = 0; i < linePointList.Count; i++)
			{
				LineVec item = linePointList[i].Copy();
				instance.linePointList.Add(item);
			}
		}
		else
		{
			instance.linePointList = null;
		}
		instance.colour = colour;
		instance.worldSpaceRotation = worldSpaceRotation;
		instance.lineThickness = lineThickness;
		if (lineAnchorList != null)
		{
			instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
			for (int j = 0; j < lineAnchorList.Count; j++)
			{
				WireLineAnchorInfo item2 = lineAnchorList[j].Copy();
				instance.lineAnchorList.Add(item2);
			}
		}
		else
		{
			instance.lineAnchorList = null;
		}
		instance.originPosition = originPosition;
		instance.originRotation = originRotation;
		if (slackLevels != null)
		{
			instance.slackLevels = Pool.Get<List<float>>();
			for (int k = 0; k < slackLevels.Count; k++)
			{
				float item3 = slackLevels[k];
				instance.slackLevels.Add(item3);
			}
		}
		else
		{
			instance.slackLevels = null;
		}
	}

	public IOConnection Copy()
	{
		IOConnection iOConnection = Pool.Get<IOConnection>();
		CopyTo(iOConnection);
		return iOConnection;
	}

	public static IOConnection Deserialize(BufferStream stream)
	{
		IOConnection iOConnection = Pool.Get<IOConnection>();
		Deserialize(stream, iOConnection, isDelta: false);
		return iOConnection;
	}

	public static IOConnection DeserializeLengthDelimited(BufferStream stream)
	{
		IOConnection iOConnection = Pool.Get<IOConnection>();
		DeserializeLengthDelimited(stream, iOConnection, isDelta: false);
		return iOConnection;
	}

	public static IOConnection DeserializeLength(BufferStream stream, int length)
	{
		IOConnection iOConnection = Pool.Get<IOConnection>();
		DeserializeLength(stream, length, iOConnection, isDelta: false);
		return iOConnection;
	}

	public static IOConnection Deserialize(byte[] buffer)
	{
		IOConnection iOConnection = Pool.Get<IOConnection>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, iOConnection, isDelta: false);
		return iOConnection;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, IOConnection previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static IOConnection Deserialize(BufferStream stream, IOConnection instance, bool isDelta)
	{
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePointList == null)
			{
				instance.linePointList = Pool.Get<List<LineVec>>();
			}
			if (instance.lineAnchorList == null)
			{
				instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.niceName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.connectedID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.connectedToSlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.inUse = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				instance.linePointList.Add(LineVec.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.colour = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldSpaceRotation, isDelta);
				continue;
			case 77:
				instance.lineThickness = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				instance.lineAnchorList.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originPosition, isDelta);
				continue;
			case 98:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originRotation, isDelta);
				continue;
			case 109:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static IOConnection DeserializeLengthDelimited(BufferStream stream, IOConnection instance, bool isDelta)
	{
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePointList == null)
			{
				instance.linePointList = Pool.Get<List<LineVec>>();
			}
			if (instance.lineAnchorList == null)
			{
				instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.niceName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.connectedID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.connectedToSlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.inUse = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				instance.linePointList.Add(LineVec.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.colour = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldSpaceRotation, isDelta);
				continue;
			case 77:
				instance.lineThickness = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				instance.lineAnchorList.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originPosition, isDelta);
				continue;
			case 98:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originRotation, isDelta);
				continue;
			case 109:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static IOConnection DeserializeLength(BufferStream stream, int length, IOConnection instance, bool isDelta)
	{
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePointList == null)
			{
				instance.linePointList = Pool.Get<List<LineVec>>();
			}
			if (instance.lineAnchorList == null)
			{
				instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.niceName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.connectedID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.connectedToSlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.inUse = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				instance.linePointList.Add(LineVec.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.colour = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldSpaceRotation, isDelta);
				continue;
			case 77:
				instance.lineThickness = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				instance.lineAnchorList.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originPosition, isDelta);
				continue;
			case 98:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originRotation, isDelta);
				continue;
			case 109:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, IOConnection instance, IOConnection previous)
	{
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		if (instance.niceName != null && instance.niceName != previous.niceName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.niceName);
		}
		if (instance.type != previous.type)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.connectedID.Value);
		if (instance.connectedToSlot != previous.connectedToSlot)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.connectedToSlot);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.inUse);
		if (instance.linePointList != null)
		{
			for (int i = 0; i < instance.linePointList.Count; i++)
			{
				LineVec lineVec = instance.linePointList[i];
				stream.WriteByte(50);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				LineVec.SerializeDelta(stream, lineVec, lineVec);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePointList (ProtoBuf.IOEntity.IOConnection.LineVec)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.colour != previous.colour)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colour);
		}
		if (instance.worldSpaceRotation != previous.worldSpaceRotation)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.worldSpaceRotation, previous.worldSpaceRotation);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldSpaceRotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.lineThickness != previous.lineThickness)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lineThickness);
		}
		if (instance.lineAnchorList != null)
		{
			for (int j = 0; j < instance.lineAnchorList.Count; j++)
			{
				WireLineAnchorInfo wireLineAnchorInfo = instance.lineAnchorList[j];
				stream.WriteByte(82);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				WireLineAnchorInfo.SerializeDelta(stream, wireLineAnchorInfo, wireLineAnchorInfo);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.originPosition != previous.originPosition)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.originPosition, previous.originPosition);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPosition (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.originRotation != previous.originRotation)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.originRotation, previous.originRotation);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originRotation (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(109);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public static void Serialize(BufferStream stream, IOConnection instance)
	{
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.niceName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.niceName);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.connectedID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.connectedID.Value);
		}
		if (instance.connectedToSlot != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.connectedToSlot);
		}
		if (instance.inUse)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.inUse);
		}
		if (instance.linePointList != null)
		{
			for (int i = 0; i < instance.linePointList.Count; i++)
			{
				LineVec instance2 = instance.linePointList[i];
				stream.WriteByte(50);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				LineVec.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePointList (ProtoBuf.IOEntity.IOConnection.LineVec)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.colour != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colour);
		}
		if (instance.worldSpaceRotation != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.worldSpaceRotation);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldSpaceRotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.lineThickness != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lineThickness);
		}
		if (instance.lineAnchorList != null)
		{
			for (int j = 0; j < instance.lineAnchorList.Count; j++)
			{
				WireLineAnchorInfo instance3 = instance.lineAnchorList[j];
				stream.WriteByte(82);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				WireLineAnchorInfo.Serialize(stream, instance3);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.originPosition != default(Vector3))
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.originPosition);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPosition (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.originRotation != default(Vector3))
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.originRotation);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originRotation (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(109);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref connectedID.Value);
		if (linePointList != null)
		{
			for (int i = 0; i < linePointList.Count; i++)
			{
				linePointList[i]?.InspectUids(action);
			}
		}
		if (lineAnchorList != null)
		{
			for (int j = 0; j < lineAnchorList.Count; j++)
			{
				lineAnchorList[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PlayerRelationshipInfo : IDisposable, IPooled, IProto<PlayerRelationshipInfo>, IProto
{
	[NonSerialized]
	public ulong playerID;

	[NonSerialized]
	public int type;

	[NonSerialized]
	public int weight;

	[NonSerialized]
	public uint mugshotCrc;

	[NonSerialized]
	public string displayName;

	[NonSerialized]
	public string notes;

	[NonSerialized]
	public float timeSinceSeen;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerRelationshipInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.playerID = 0uL;
			instance.type = 0;
			instance.weight = 0;
			instance.mugshotCrc = 0u;
			instance.displayName = string.Empty;
			instance.notes = string.Empty;
			instance.timeSinceSeen = 0f;
			Pool.Free<PlayerRelationshipInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerRelationshipInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerRelationshipInfo instance)
	{
		instance.playerID = playerID;
		instance.type = type;
		instance.weight = weight;
		instance.mugshotCrc = mugshotCrc;
		instance.displayName = displayName;
		instance.notes = notes;
		instance.timeSinceSeen = timeSinceSeen;
	}

	public PlayerRelationshipInfo Copy()
	{
		PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
		CopyTo(playerRelationshipInfo);
		return playerRelationshipInfo;
	}

	public static PlayerRelationshipInfo Deserialize(BufferStream stream)
	{
		PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
		Deserialize(stream, playerRelationshipInfo, isDelta: false);
		return playerRelationshipInfo;
	}

	public static PlayerRelationshipInfo DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
		DeserializeLengthDelimited(stream, playerRelationshipInfo, isDelta: false);
		return playerRelationshipInfo;
	}

	public static PlayerRelationshipInfo DeserializeLength(BufferStream stream, int length)
	{
		PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
		DeserializeLength(stream, length, playerRelationshipInfo, isDelta: false);
		return playerRelationshipInfo;
	}

	public static PlayerRelationshipInfo Deserialize(byte[] buffer)
	{
		PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerRelationshipInfo, isDelta: false);
		return playerRelationshipInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerRelationshipInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerRelationshipInfo Deserialize(BufferStream stream, PlayerRelationshipInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.weight = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 61:
				instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerRelationshipInfo DeserializeLengthDelimited(BufferStream stream, PlayerRelationshipInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.weight = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 61:
				instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerRelationshipInfo DeserializeLength(BufferStream stream, int length, PlayerRelationshipInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.weight = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 61:
				instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerRelationshipInfo instance, PlayerRelationshipInfo previous)
	{
		if (instance.playerID != previous.playerID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.type != previous.type)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.weight != previous.weight)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.weight);
		}
		if (instance.mugshotCrc != previous.mugshotCrc)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.mugshotCrc);
		}
		if (instance.displayName != null && instance.displayName != previous.displayName)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.notes != null && instance.notes != previous.notes)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.notes);
		}
		if (instance.timeSinceSeen != previous.timeSinceSeen)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.timeSinceSeen);
		}
	}

	public static void Serialize(BufferStream stream, PlayerRelationshipInfo instance)
	{
		if (instance.playerID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.weight != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.weight);
		}
		if (instance.mugshotCrc != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.mugshotCrc);
		}
		if (instance.displayName != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.notes != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.notes);
		}
		if (instance.timeSinceSeen != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.timeSinceSeen);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PlayerRelationships : IDisposable, IPooled, IProto<PlayerRelationships>, IProto
{
	[NonSerialized]
	public ulong playerID;

	[NonSerialized]
	public List<PlayerRelationshipInfo> relations;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerRelationships instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.playerID = 0uL;
		if (instance.relations != null)
		{
			for (int i = 0; i < instance.relations.Count; i++)
			{
				if (instance.relations[i] != null)
				{
					instance.relations[i].ResetToPool();
					instance.relations[i] = null;
				}
			}
			List<PlayerRelationshipInfo> list = instance.relations;
			Pool.Free<PlayerRelationshipInfo>(ref list, false);
			instance.relations = list;
		}
		Pool.Free<PlayerRelationships>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerRelationships with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerRelationships instance)
	{
		instance.playerID = playerID;
		if (relations != null)
		{
			instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			for (int i = 0; i < relations.Count; i++)
			{
				PlayerRelationshipInfo item = relations[i].Copy();
				instance.relations.Add(item);
			}
		}
		else
		{
			instance.relations = null;
		}
	}

	public PlayerRelationships Copy()
	{
		PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
		CopyTo(playerRelationships);
		return playerRelationships;
	}

	public static PlayerRelationships Deserialize(BufferStream stream)
	{
		PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
		Deserialize(stream, playerRelationships, isDelta: false);
		return playerRelationships;
	}

	public static PlayerRelationships DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
		DeserializeLengthDelimited(stream, playerRelationships, isDelta: false);
		return playerRelationships;
	}

	public static PlayerRelationships DeserializeLength(BufferStream stream, int length)
	{
		PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
		DeserializeLength(stream, length, playerRelationships, isDelta: false);
		return playerRelationships;
	}

	public static PlayerRelationships Deserialize(byte[] buffer)
	{
		PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerRelationships, isDelta: false);
		return playerRelationships;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerRelationships previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerRelationships Deserialize(BufferStream stream, PlayerRelationships instance, bool isDelta)
	{
		if (!isDelta && instance.relations == null)
		{
			instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerRelationships DeserializeLengthDelimited(BufferStream stream, PlayerRelationships instance, bool isDelta)
	{
		if (!isDelta && instance.relations == null)
		{
			instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerRelationships DeserializeLength(BufferStream stream, int length, PlayerRelationships instance, bool isDelta)
	{
		if (!isDelta && instance.relations == null)
		{
			instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerRelationships instance, PlayerRelationships previous)
	{
		if (instance.playerID != previous.playerID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.relations == null)
		{
			return;
		}
		for (int i = 0; i < instance.relations.Count; i++)
		{
			PlayerRelationshipInfo playerRelationshipInfo = instance.relations[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerRelationshipInfo.SerializeDelta(stream, playerRelationshipInfo, playerRelationshipInfo);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, PlayerRelationships instance)
	{
		if (instance.playerID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.relations == null)
		{
			return;
		}
		for (int i = 0; i < instance.relations.Count; i++)
		{
			PlayerRelationshipInfo instance2 = instance.relations[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerRelationshipInfo.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (relations != null)
		{
			for (int i = 0; i < relations.Count; i++)
			{
				relations[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class EggHunter : IDisposable, IPooled, IProto<EggHunter>, IProto
{
	[NonSerialized]
	public string displayName;

	[NonSerialized]
	public int numEggs;

	[NonSerialized]
	public ulong playerID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EggHunter instance)
	{
		if (instance.ShouldPool)
		{
			instance.displayName = string.Empty;
			instance.numEggs = 0;
			instance.playerID = 0uL;
			Pool.Free<EggHunter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EggHunter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EggHunter instance)
	{
		instance.displayName = displayName;
		instance.numEggs = numEggs;
		instance.playerID = playerID;
	}

	public EggHunter Copy()
	{
		EggHunter eggHunter = Pool.Get<EggHunter>();
		CopyTo(eggHunter);
		return eggHunter;
	}

	public static EggHunter Deserialize(BufferStream stream)
	{
		EggHunter eggHunter = Pool.Get<EggHunter>();
		Deserialize(stream, eggHunter, isDelta: false);
		return eggHunter;
	}

	public static EggHunter DeserializeLengthDelimited(BufferStream stream)
	{
		EggHunter eggHunter = Pool.Get<EggHunter>();
		DeserializeLengthDelimited(stream, eggHunter, isDelta: false);
		return eggHunter;
	}

	public static EggHunter DeserializeLength(BufferStream stream, int length)
	{
		EggHunter eggHunter = Pool.Get<EggHunter>();
		DeserializeLength(stream, length, eggHunter, isDelta: false);
		return eggHunter;
	}

	public static EggHunter Deserialize(byte[] buffer)
	{
		EggHunter eggHunter = Pool.Get<EggHunter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, eggHunter, isDelta: false);
		return eggHunter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EggHunter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EggHunter Deserialize(BufferStream stream, EggHunter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EggHunter DeserializeLengthDelimited(BufferStream stream, EggHunter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EggHunter DeserializeLength(BufferStream stream, int length, EggHunter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EggHunter instance, EggHunter previous)
	{
		if (instance.displayName != null && instance.displayName != previous.displayName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.numEggs != previous.numEggs)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numEggs);
		}
		if (instance.playerID != previous.playerID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
	}

	public static void Serialize(BufferStream stream, EggHunter instance)
	{
		if (instance.displayName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.numEggs != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numEggs);
		}
		if (instance.playerID != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ScoreEntry : IDisposable, IPooled, IProto<ScoreEntry>, IProto
{
	[NonSerialized]
	public ulong playerID;

	[NonSerialized]
	public string displayName;

	[NonSerialized]
	public int score;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ScoreEntry instance)
	{
		if (instance.ShouldPool)
		{
			instance.playerID = 0uL;
			instance.displayName = string.Empty;
			instance.score = 0;
			Pool.Free<ScoreEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ScoreEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ScoreEntry instance)
	{
		instance.playerID = playerID;
		instance.displayName = displayName;
		instance.score = score;
	}

	public ScoreEntry Copy()
	{
		ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
		CopyTo(scoreEntry);
		return scoreEntry;
	}

	public static ScoreEntry Deserialize(BufferStream stream)
	{
		ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
		Deserialize(stream, scoreEntry, isDelta: false);
		return scoreEntry;
	}

	public static ScoreEntry DeserializeLengthDelimited(BufferStream stream)
	{
		ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
		DeserializeLengthDelimited(stream, scoreEntry, isDelta: false);
		return scoreEntry;
	}

	public static ScoreEntry DeserializeLength(BufferStream stream, int length)
	{
		ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
		DeserializeLength(stream, length, scoreEntry, isDelta: false);
		return scoreEntry;
	}

	public static ScoreEntry Deserialize(byte[] buffer)
	{
		ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, scoreEntry, isDelta: false);
		return scoreEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ScoreEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ScoreEntry Deserialize(BufferStream stream, ScoreEntry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ScoreEntry DeserializeLengthDelimited(BufferStream stream, ScoreEntry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ScoreEntry DeserializeLength(BufferStream stream, int length, ScoreEntry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ScoreEntry instance, ScoreEntry previous)
	{
		if (instance.playerID != previous.playerID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.displayName != null && instance.displayName != previous.displayName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.score != previous.score)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public static void Serialize(BufferStream stream, ScoreEntry instance)
	{
		if (instance.playerID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.displayName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.score != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class StringPoint : IDisposable, IPooled, IProto<StringPoint>, IProto
{
	[NonSerialized]
	public Vector3 point;

	[NonSerialized]
	public Vector3 normal;

	[NonSerialized]
	public float slack;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(StringPoint instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.point = default(Vector3);
			instance.normal = default(Vector3);
			instance.slack = 0f;
			Pool.Free<StringPoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose StringPoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(StringPoint instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.point = point;
		instance.normal = normal;
		instance.slack = slack;
	}

	public StringPoint Copy()
	{
		StringPoint stringPoint = Pool.Get<StringPoint>();
		CopyTo(stringPoint);
		return stringPoint;
	}

	public static StringPoint Deserialize(BufferStream stream)
	{
		StringPoint stringPoint = Pool.Get<StringPoint>();
		Deserialize(stream, stringPoint, isDelta: false);
		return stringPoint;
	}

	public static StringPoint DeserializeLengthDelimited(BufferStream stream)
	{
		StringPoint stringPoint = Pool.Get<StringPoint>();
		DeserializeLengthDelimited(stream, stringPoint, isDelta: false);
		return stringPoint;
	}

	public static StringPoint DeserializeLength(BufferStream stream, int length)
	{
		StringPoint stringPoint = Pool.Get<StringPoint>();
		DeserializeLength(stream, length, stringPoint, isDelta: false);
		return stringPoint;
	}

	public static StringPoint Deserialize(byte[] buffer)
	{
		StringPoint stringPoint = Pool.Get<StringPoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, stringPoint, isDelta: false);
		return stringPoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, StringPoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static StringPoint Deserialize(BufferStream stream, StringPoint instance, bool isDelta)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 29:
				instance.slack = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static StringPoint DeserializeLengthDelimited(BufferStream stream, StringPoint instance, bool isDelta)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 29:
				instance.slack = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static StringPoint DeserializeLength(BufferStream stream, int length, StringPoint instance, bool isDelta)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 29:
				instance.slack = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, StringPoint instance, StringPoint previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (instance.point != previous.point)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.point, previous.point);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field point (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != previous.normal)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.slack != previous.slack)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.slack);
		}
	}

	public static void Serialize(BufferStream stream, StringPoint instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (instance.point != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.point);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field point (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.slack != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.slack);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PlayerStorage : IDisposable, IPooled, IProto<PlayerStorage>, IProto
{
	public class PlayerStoredVehicle : IDisposable, IPooled, IProto<PlayerStoredVehicle>, IProto
	{
		[NonSerialized]
		public string shortname;

		[NonSerialized]
		public string resourcePath;

		[NonSerialized]
		public float health;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerStoredVehicle instance)
		{
			if (instance.ShouldPool)
			{
				instance.shortname = string.Empty;
				instance.resourcePath = string.Empty;
				instance.health = 0f;
				Pool.Free<PlayerStoredVehicle>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerStoredVehicle with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerStoredVehicle instance)
		{
			instance.shortname = shortname;
			instance.resourcePath = resourcePath;
			instance.health = health;
		}

		public PlayerStoredVehicle Copy()
		{
			PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
			CopyTo(playerStoredVehicle);
			return playerStoredVehicle;
		}

		public static PlayerStoredVehicle Deserialize(BufferStream stream)
		{
			PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
			Deserialize(stream, playerStoredVehicle, isDelta: false);
			return playerStoredVehicle;
		}

		public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
			DeserializeLengthDelimited(stream, playerStoredVehicle, isDelta: false);
			return playerStoredVehicle;
		}

		public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length)
		{
			PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
			DeserializeLength(stream, length, playerStoredVehicle, isDelta: false);
			return playerStoredVehicle;
		}

		public static PlayerStoredVehicle Deserialize(byte[] buffer)
		{
			PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerStoredVehicle, isDelta: false);
			return playerStoredVehicle;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerStoredVehicle previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerStoredVehicle Deserialize(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.shortname = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.resourcePath = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.health = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.shortname = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.resourcePath = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.health = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length, PlayerStoredVehicle instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.shortname = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.resourcePath = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.health = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerStoredVehicle instance, PlayerStoredVehicle previous)
		{
			if (instance.shortname != null && instance.shortname != previous.shortname)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.shortname);
			}
			if (instance.resourcePath != null && instance.resourcePath != previous.resourcePath)
			{
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.resourcePath);
			}
			if (instance.health != previous.health)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.health);
			}
		}

		public static void Serialize(BufferStream stream, PlayerStoredVehicle instance)
		{
			if (instance.shortname != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.shortname);
			}
			if (instance.resourcePath != null)
			{
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.resourcePath);
			}
			if (instance.health != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.health);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public ulong userid;

	[NonSerialized]
	public List<PlayerStoredVehicle> storedVehicles;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerStorage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.userid = 0uL;
		if (instance.storedVehicles != null)
		{
			for (int i = 0; i < instance.storedVehicles.Count; i++)
			{
				if (instance.storedVehicles[i] != null)
				{
					instance.storedVehicles[i].ResetToPool();
					instance.storedVehicles[i] = null;
				}
			}
			List<PlayerStoredVehicle> list = instance.storedVehicles;
			Pool.Free<PlayerStoredVehicle>(ref list, false);
			instance.storedVehicles = list;
		}
		Pool.Free<PlayerStorage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerStorage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerStorage instance)
	{
		instance.userid = userid;
		if (storedVehicles != null)
		{
			instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
			for (int i = 0; i < storedVehicles.Count; i++)
			{
				PlayerStoredVehicle item = storedVehicles[i].Copy();
				instance.storedVehicles.Add(item);
			}
		}
		else
		{
			instance.storedVehicles = null;
		}
	}

	public PlayerStorage Copy()
	{
		PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
		CopyTo(playerStorage);
		return playerStorage;
	}

	public static PlayerStorage Deserialize(BufferStream stream)
	{
		PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
		Deserialize(stream, playerStorage, isDelta: false);
		return playerStorage;
	}

	public static PlayerStorage DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
		DeserializeLengthDelimited(stream, playerStorage, isDelta: false);
		return playerStorage;
	}

	public static PlayerStorage DeserializeLength(BufferStream stream, int length)
	{
		PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
		DeserializeLength(stream, length, playerStorage, isDelta: false);
		return playerStorage;
	}

	public static PlayerStorage Deserialize(byte[] buffer)
	{
		PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerStorage, isDelta: false);
		return playerStorage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerStorage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerStorage Deserialize(BufferStream stream, PlayerStorage instance, bool isDelta)
	{
		if (!isDelta && instance.storedVehicles == null)
		{
			instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerStorage DeserializeLengthDelimited(BufferStream stream, PlayerStorage instance, bool isDelta)
	{
		if (!isDelta && instance.storedVehicles == null)
		{
			instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerStorage DeserializeLength(BufferStream stream, int length, PlayerStorage instance, bool isDelta)
	{
		if (!isDelta && instance.storedVehicles == null)
		{
			instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerStorage instance, PlayerStorage previous)
	{
		if (instance.userid != previous.userid)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.storedVehicles == null)
		{
			return;
		}
		for (int i = 0; i < instance.storedVehicles.Count; i++)
		{
			PlayerStoredVehicle playerStoredVehicle = instance.storedVehicles[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerStoredVehicle.SerializeDelta(stream, playerStoredVehicle, playerStoredVehicle);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, PlayerStorage instance)
	{
		if (instance.userid != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.storedVehicles == null)
		{
			return;
		}
		for (int i = 0; i < instance.storedVehicles.Count; i++)
		{
			PlayerStoredVehicle instance2 = instance.storedVehicles[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerStoredVehicle.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (storedVehicles != null)
		{
			for (int i = 0; i < storedVehicles.Count; i++)
			{
				storedVehicles[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Lights : IDisposable, IPooled, IProto<Lights>, IProto
{
	[NonSerialized]
	public Color topLeft;

	[NonSerialized]
	public Color topRight;

	[NonSerialized]
	public Color bottomLeft;

	[NonSerialized]
	public Color bottomRight;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Lights instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.topLeft = default(Color);
			instance.topRight = default(Color);
			instance.bottomLeft = default(Color);
			instance.bottomRight = default(Color);
			Pool.Free<Lights>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Lights with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Lights instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.topLeft = topLeft;
		instance.topRight = topRight;
		instance.bottomLeft = bottomLeft;
		instance.bottomRight = bottomRight;
	}

	public Lights Copy()
	{
		Lights lights = Pool.Get<Lights>();
		CopyTo(lights);
		return lights;
	}

	public static Lights Deserialize(BufferStream stream)
	{
		Lights lights = Pool.Get<Lights>();
		Deserialize(stream, lights, isDelta: false);
		return lights;
	}

	public static Lights DeserializeLengthDelimited(BufferStream stream)
	{
		Lights lights = Pool.Get<Lights>();
		DeserializeLengthDelimited(stream, lights, isDelta: false);
		return lights;
	}

	public static Lights DeserializeLength(BufferStream stream, int length)
	{
		Lights lights = Pool.Get<Lights>();
		DeserializeLength(stream, length, lights, isDelta: false);
		return lights;
	}

	public static Lights Deserialize(byte[] buffer)
	{
		Lights lights = Pool.Get<Lights>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lights, isDelta: false);
		return lights;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Lights previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Lights Deserialize(BufferStream stream, Lights instance, bool isDelta)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
				continue;
			case 26:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
				continue;
			case 34:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Lights DeserializeLengthDelimited(BufferStream stream, Lights instance, bool isDelta)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
				continue;
			case 26:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
				continue;
			case 34:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Lights DeserializeLength(BufferStream stream, int length, Lights instance, bool isDelta)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
				continue;
			case 26:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
				continue;
			case 34:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Lights instance, Lights previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		if (instance.topLeft != previous.topLeft)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.topLeft, previous.topLeft);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topLeft (UnityEngine.Color)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.topRight != previous.topRight)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.topRight, previous.topRight);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topRight (UnityEngine.Color)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.bottomLeft != previous.bottomLeft)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.bottomLeft, previous.bottomLeft);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomLeft (UnityEngine.Color)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.bottomRight != previous.bottomRight)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.bottomRight, previous.bottomRight);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomRight (UnityEngine.Color)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
	}

	public static void Serialize(BufferStream stream, Lights instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.topLeft != default(Color))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ColorSerialized.Serialize(stream, instance.topLeft);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topLeft (UnityEngine.Color)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.topRight != default(Color))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			ColorSerialized.Serialize(stream, instance.topRight);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topRight (UnityEngine.Color)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.bottomLeft != default(Color))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			ColorSerialized.Serialize(stream, instance.bottomLeft);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomLeft (UnityEngine.Color)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.bottomRight != default(Color))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			ColorSerialized.Serialize(stream, instance.bottomRight);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomRight (UnityEngine.Color)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


